{"meta":{"title":"张建的博客","subtitle":"成功的道路上只有荆棘，没有坦途","description":"我是小J，关注我","author":"小J","url":"https://www.bboyzj.cn"},"pages":[{"title":"about","date":"2023-03-06T11:05:41.000Z","updated":"2023-03-06T11:05:41.514Z","comments":true,"path":"about/index.html","permalink":"https://www.bboyzj.cn/about/index.html","excerpt":"","text":""},{"title":"link","date":"2023-03-06T11:05:48.000Z","updated":"2023-03-06T11:05:48.692Z","comments":true,"path":"link/index.html","permalink":"https://www.bboyzj.cn/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-06T11:05:02.000Z","updated":"2023-03-06T11:05:02.715Z","comments":true,"path":"tags/index-1.html","permalink":"https://www.bboyzj.cn/tags/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-01T03:07:03.000Z","updated":"2023-03-01T03:07:47.616Z","comments":true,"path":"tags/index.html","permalink":"https://www.bboyzj.cn/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-03-01T04:01:29.000Z","updated":"2023-03-01T04:01:29.226Z","comments":true,"path":"categories/index.html","permalink":"https://www.bboyzj.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"OC学习13：上传App Store所需各图标和图片尺寸","slug":"OC学习/OC学习13：上传App-Store所需各图标和图片尺寸","date":"2023-03-08T19:13:37.000Z","updated":"2023-03-08T20:50:44.306Z","comments":true,"path":"2023/03/09/OC学习/OC学习13：上传App-Store所需各图标和图片尺寸/","link":"","permalink":"https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A013%EF%BC%9A%E4%B8%8A%E4%BC%A0App-Store%E6%89%80%E9%9C%80%E5%90%84%E5%9B%BE%E6%A0%87%E5%92%8C%E5%9B%BE%E7%89%87%E5%B0%BA%E5%AF%B8/","excerpt":"","text":"App Icon 图标尺寸 型号 分辨率（pt） 像素（px） 图片后缀 iPhone 20 40x40 2x iPhone 20 60x60 3x iPhone 29 58x58 2x iPhone 29 87x87 3x iPhone 40 80x80 2x iPhone 40 120x120 3x iPhone 60 120x120 2x iPhone 60 180x180 2x iPad 20 20x20 1x iPad 20 40x40 2x iPad 29 29x29 1x iPad 29 58x58 2x iPad 40 40x40 1x iPad 40 80x80 2x iPad 76 76x76 1x iPad 76 152x152 2x iPad 83.5 167x167 2x App Store 1024 1024x1024 1x App Store 引导页图片尺寸 屏幕大小（英寸） 像素（px） 5.5 886x1920 6.5 1080x1920 12.9 1200x1600","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习12：HTTP状态码大全","slug":"OC学习/OC学习12：HTTP状态码大全","date":"2023-03-08T19:12:49.000Z","updated":"2023-03-08T21:20:21.570Z","comments":true,"path":"2023/03/09/OC学习/OC学习12：HTTP状态码大全/","link":"","permalink":"https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A012%EF%BC%9AHTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E5%85%A8/","excerpt":"","text":"前言HTTP状态码（HTTP Status Code）是用来表示网页服务器HTTP响应状态的3位数字代码。 类型所有状态码的第一个数字代表了响应的五种状态之一，其分类如下： 状态码 描述 1xx 信息，表示临时响应并需要请求者继续执行操作 2xx 成功，操作被成功接收并处理 3xx 表示要完成请求，需要进一步操作。通常这些代码用来重定向 4xx 客户端错误，请求包含语法错误或无法完成请求 5xx 这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错 状态码详解 1xx： 100：（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101：（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 102：由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。 2xx： 200：（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201：（已创建） 请求成功并且服务器创建了新的资源。 202：（已接受） 服务器已接受请求，但尚未处理。 203：（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204：（无内容） 服务器成功处理了请求，但没有返回任何内容。 205：（重置内容） 服务器成功处理了请求，但没有返回任何内容。 206：（部分内容） 服务器成功处理了部分 GET 请求。 208：（已经报告）一个DAV的绑定成员被前一个请求枚举，并且没有被再一次包括。 226：（IM Used）服务器已经满足了请求所要的资源，并且响应是一个或者多个实例操作应用于当前实 3xx： 300：（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301：（永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302：（临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303：（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304：（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305：（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307：（临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx： 400:（错误请求) 服务器不理解请求的语法。 401：(未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 402：该状态码是为了将来可能的需求而预留的。 403：（禁止) 服务器拒绝请求。 404：（未找到) 服务器找不到请求的网页。 405：（方法禁用) 禁用请求中指定的方法。 406：（不接受) 无法使用请求的内容特性响应请求的网页。 407：（需要代理授权) 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408：（请求超时) 服务器等候请求时发生超时。 409：（冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410：（已删除) 如果请求的资源已永久删除，服务器就会返回此响应。 411：（需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。 412：（未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。 413：（请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414：（请求的 URI 过长) 请求的 URI（通常为网址）过长，服务器无法处理。 415：（不支持的媒体类型) 请求的格式不受请求页面的支持。 416：（请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417：（未满足期望值) 服务器未满足”期望”请求标头字段的要求。 418：（我是一个茶壶）这个代码是在1998年作为传统的IETF April Fools‘ jokes被定义的在RFC2324，超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现。RFC指定了这个代码应该是由茶罐返回给速溶咖啡。 419：（认证超时）并不是HTTP标注的一部分，419认证超时表示以前的有效证明已经失效了。同时也被用于401未认证的替代选择为了从其它被拒绝访问的已认证客户端中指定服务器的资源。 420：（方法失效）不是HTTP的标准，但是被Spring定义在HTTP状态类中当方法失时使用。这个状态码已经不推荐在Spring中使用。 420：（提高你的耐心）也不是HTTP标准的一部分，但是被版本1的Twitter搜索和趋势APi返回当客户端的速率被限制的时候。其它的服务提供商可能会使用429太多的请求响应码来代替。 421：从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422：请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV） 424：由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV） 425：在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。 426：客户端应当切换到TLS&#x2F;1.0。（RFC 2817） 428：(需要前置条件)原始服务器需要有条件的请求。当客户端GET一个资源的状态的时候，同时又PUT回给服务器，与此同时第三方修改状态到服务器上的时候，为了避免丢失更新的问题发生将会导致冲突。 429：（过多请求）用户已经发送了太多的请求在指定的时间里。用于限制速率。 431：（请求头部字段太大）服务器由于一个单独的请求头部字段或者是全部的字段太大而不愿意处理请求。 440：（登陆超时（微软））一个微软的扩展，意味着你的会话已经超时。 444：（无响应）被使用在Nginx的日志中表明服务器没有返回信息给客户端并且关闭了连接（在威慑恶意软件的时候比较有用）。 449：（重试（微软））一个微软的扩展。请求应该在执行适当的动作之后被重试。 450：（被Windows家长控制阻塞（微软））一个微软的扩展。这个错误是当Windows家长控制打开并且阻塞指定网页的访问的时候被指定。 451：（由于法律原因而无效（因特网草稿））被定义在因特网草稿“一个新的HTTP状态码用于法律限制的资源”。被用于当资源的访问由于法律原因被禁止的时候。例如检查制度或者是政府强制要求禁止访问。一个例子是1953年dystopian的小说Fahrenheit 451就是一个非法的资源。 451：（重定向（微软））被用在Exchange ActiveSync中如果一个更有效的服务器能够被使用或者是服务器不能访问用户的邮箱。客户端会假定重新执行HTTP自动发现协议去寻找更适合的服务器。 494：（请求头太大（Nginx））Nginx内置代码和431类似，但是是被更早地引入在版本0.9.4（在2011年1月21日）。 495：（证书错误（Nginx））Nginx内置的代码，当使用SSL客户端证书的时候错误会出现为了在日志错误中区分它和4XX和一个错误页面的重定向。。 496：（没有证书（Nginx））Nginx内置的代码，当客户端不能提供证书在日志中分辨4XX和一个错误页面的重定向。 497：（HTTP到HTTPS（Nginx））Nginx内置的代码，被用于原始的HTTP的请求发送给HTTPS端口去分辨4XX在日志中和一个错误页面的重定向。 498：（令牌超时或失效（Esri））由ArcGIS for Server返回。这个代码意味着令牌的超时或者是失效。 499：（客户端关闭请求（Nginx））被用在Nginx日志去表明一个连接已经被客户端关闭当服务器仍然正在处理它的请求，是的服务器无法返货状态码。 499：（需要令牌（Esri））由ArcGIS for Server返回。意味着需要一个令牌（如果没有令牌被提交）。 5xx： 500：（服务器内部错误） 服务器遇到错误，无法完成请求。 501：（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502：（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503：（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504：（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505：（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 506：由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。 507：服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918) 508：（发现环路）服务器发现了一个无限的循环档处理请求的时候。 509：服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。 510：获取资源所需要的策略并没有没满足。（RFC 2774）。 511：（需要网络授权）客户端需要授权去火的网络的访问权限。一般用于代理交互中被用来进行网络的访问控制。 520：（未知错误）这个状态码也没有被指定在任何RFC中，并且只会被一些服务器返回，例如微软的Azure和CloudFlare服务器:”520错误。本质上是一个捕获全部的响应当原始服务器返回一些未知的或者一些不能被忍受或者被解释的(协议违反或者空响应)”。 598：（网络读取超时异常(未知)）这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络读取超时在一个客户端之前的代理的后面。 599：（网络连接超时异常(未知)）这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络连接超时在一个客户端之前的代理的后面。","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习11：Xcode 常用的快捷键大全","slug":"OC学习/OC学习11：Xcode-常用的快捷键大全","date":"2023-03-08T19:12:11.000Z","updated":"2023-03-08T20:26:04.054Z","comments":true,"path":"2023/03/09/OC学习/OC学习11：Xcode-常用的快捷键大全/","link":"","permalink":"https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A011%EF%BC%9AXcode-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/","excerpt":"","text":"通用快捷键 Command + A ：全选Command + C ：复制Command + V ：粘贴Command + X ：剪切Command + Z ：撤销Command + Shift + Z ： 撤销刚才的撤销 文件快捷键 Command + S ：保存Command + Shift + S ：另存为 项目快捷键 Command + Shift + N ：新建项目Command + N ：新建文件Command + O ：打开文件Command + D ：快速复制一段代码Optional + 单击 ：显示描述文件Command + 单击：跳转函数Command + Optional + 上&#x2F;下箭头 ：快速切换.h和.m文件 Command + 0 ：显示&#x2F;隐藏导航器面板Command + Optional + 0 ：显示&#x2F;隐藏工具面板Command + Shift + o ：快速搜索 注释快捷键 Command + Optional + &#x2F; ：快速注释Command + &#x2F; ：单行注释 折叠&#x2F;展开快捷键 Command + Optional + 左箭头 ：折叠代码Command + Optional + 右箭头 ：展开代码 文字快捷键 Command + - ：缩小文字Command + + ：放大文字 调试运行、停止 Command + B ：编译Command + R ：运行Command + . ：停止Command + Shift + K ：清理 移动代码块 Command + [ ：左移代码块Command + ] ：右移代码块 Command + Optional + [ ：上移代码块Command + Optional + ] ：下移代码块 移动光标快捷键 Command + 左&#x2F;右箭头 ：将光标移动至行首&#x2F;尾Command + 上&#x2F;下箭头 ：将光标移动至文档行首&#x2F;尾 Command + Shift + 左&#x2F;右箭头 ：向左&#x2F;右选择一个单词 Command + Shift + 左&#x2F;右箭头 ：选择到行首&#x2F;尾 调试快捷键 Command + \\ ：设置&#x2F;取消断点 窗口快捷键 Command + H ：隐藏Command + M ：最小化Command + P ：打印Command + Q ：退出项目Command + W ：关闭当前文件 窗口切换快捷键 Command + Tab ：程序间切换Command + ~ ：窗口间切换 屏幕快捷键 Command + Shift + F3 ：截图整个屏幕Command + Shift + F4 ：截取指定区域 系统快捷键 Command + Optional + ESC ：强制退出程序Command + Space ：切换语言Command + Shift + ？：帮助 编辑快捷键 Command + Delete ：删除Command + Shift + Delete ：清空垃圾桶Command + Shift + A ：打开应用程序目录Command + Shift + C ：打开 Computer 目录Command + Shift + H ：打开 Home 目录","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习10：iPhone各系列尺寸大全","slug":"OC学习/OC学习10：iPhone各系列尺寸大全","date":"2023-03-08T19:11:14.000Z","updated":"2023-03-08T21:07:28.498Z","comments":true,"path":"2023/03/09/OC学习/OC学习10：iPhone各系列尺寸大全/","link":"","permalink":"https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A010%EF%BC%9AiPhone%E5%90%84%E7%B3%BB%E5%88%97%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%85%A8/","excerpt":"","text":"iPhone手机尺寸大全 机型 屏幕尺寸 （英寸） 分辨率（pt） 像素（px） 图片后缀 安全区域（上&#x2F;下） iPhone4&#x2F;4s 3.5 320x480 640x960 @2x iPhone5&#x2F;5c&#x2F;5s&#x2F;SE 4 320x568 640x1136 @2x iPhone6&#x2F;6s&#x2F;7&#x2F;8 4.7 375x667 750x1334 @2x iPhone6&#x2F;6s&#x2F;7&#x2F;8 Plus 5.5 414x736 1080x1920 @3x iPhoneX&#x2F;iPhoneXS&#x2F;11Pro 5.8 375x812 1125x2436 @3x 44&#x2F;34 iPhoneXR&#x2F;11 6.1 414x896 828x1792 @2x 48&#x2F;34 iPhoneXSMax&#x2F;11ProMax 6.5 414x896 1242x2688 @3x 47&#x2F;34 iPhone12mini（&gt;&#x3D;iOS14） iPhone13mini（&gt;&#x3D;iOS15） 5.4 360x780 1080x2340 @3x 47&#x2F;34 iPhone12&#x2F;12Pro iPhone13&#x2F;13Pro 6.1 390x844 1170x2532 @3x 47&#x2F;34 iPhone12&#x2F;13ProMax 6.7 428x926 1284x2778 @3x 47&#x2F;34 iPhone14 （&gt;&#x3D;iOS16） 6.1 390x844 1170x2532 @3x 47&#x2F;34 iPhone14 Plus 6.7 428x926 1284x2778 @3x 47&#x2F;34 iPhone14 Pro 6.1 393x852 1179x2556 @3x 59&#x2F;34 iPhone14 Pro Max 6.7 430x932 1290x2796 @3x 59&#x2F;34","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习12：集成SDwebImage报Framework not found Pods_________解决方案","slug":"OC学习/OC学习08：修改项目名称的流程","date":"2023-03-08T12:20:10.000Z","updated":"2023-03-08T19:10:30.498Z","comments":true,"path":"2023/03/08/OC学习/OC学习08：修改项目名称的流程/","link":"","permalink":"https://www.bboyzj.cn/2023/03/08/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A008%EF%BC%9A%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E7%9A%84%E6%B5%81%E7%A8%8B/","excerpt":"","text":"前言 如果我们在项目中集成三方库 SDwebImage 时，报错 Framework not found Pods_________，说明 工程名称用汉字了，这个时候就需要更改项目名 在开发过程中需求想更改项目名 修改名称Xcode 修改 工程名 打开 Xcode 的 Show the File Inspector，修改 Name 为 FirstFrameDemo 修改成 FirstFrameDemo 之后，回车， 这里 Xcode 列举了可以为我们做的更改的名称 点击 Rename -&gt; OK，Xcode 为我们重命名了一部分。 关闭项目工程，修改项目文件夹名称（由原工程名 -&gt; 修改成新的工程名） 修改前： 修改后： 修改项目文件名（右击选择包内容） 点击 project.phxproj 文件，将 获取视频的第一帧 替换成 FirstFrameDemo ，全部替换 All -&gt; Done 打开项目 FirstFrameDemo.xcworkspace ，项目内全局替换 获取视频的第一帧 -&gt; FirstFrameDemo 修改 Podfile 文件中项目名称 打开终端，切换到当前项目目录下，执行 pos intall 删除旧的 workspace 文件 至此项目名已经完全修改完成了","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习11：Pch文件","slug":"OC学习/OC学习09：Pch文件","date":"2023-03-08T11:43:38.000Z","updated":"2023-03-08T18:54:39.914Z","comments":true,"path":"2023/03/08/OC学习/OC学习09：Pch文件/","link":"","permalink":"https://www.bboyzj.cn/2023/03/08/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A009%EF%BC%9APch%E6%96%87%E4%BB%B6/","excerpt":"","text":"","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习10：UITableViw点击事件和页面上的手势冲突怎么解决？","slug":"OC学习/OC学习07：UITableViw点击事件和页面上的手势冲突怎么解决？","date":"2023-03-07T11:17:26.000Z","updated":"2023-03-08T11:41:42.465Z","comments":true,"path":"2023/03/07/OC学习/OC学习07：UITableViw点击事件和页面上的手势冲突怎么解决？/","link":"","permalink":"https://www.bboyzj.cn/2023/03/07/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A007%EF%BC%9AUITableViw%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%92%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/","excerpt":"","text":"举例说明下面以一个例子讲解 图中 superView 有两个 subView，分别是 testView 和 testBtn。我们在 superView 和 testView 都重载 touchsBegan:withEvent、touchsEnded:withEvent、 touchsMoved:withEvent、touchsCancelled:withEvent方法，并且在 superView 上添加单击手势 UITapGestureRecognizer，action名为tapAction，给testBtn绑定action名为testBtnClicked。 主要代码如下： SuperView 1234567891011121314151617181920212223242526- (void)initUI&#123; UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapAction)]; [self addGestureRecognizer:tap]; [self addSubview:self.testView]; [self addSubview:self.testBtn];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@&quot;=========&gt; superView touchs Began&quot;);&#125;- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@&quot;=========&gt; superView touchs Moved&quot;);&#125;- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@&quot;=========&gt; superView touchs Ended&quot;);&#125;- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@&quot;=========&gt; superView touchs Cancelled&quot;);&#125;- (void)tapAction &#123; NSLog(@&quot;=========&gt; single Tapped&quot;);&#125;- (void)clickBtn &#123; NSLog(@&quot;=========&gt; click btn&quot;);&#125; textView 12345678910111213//testView- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@&quot;=========&gt; testView touchs Began&quot;);&#125;- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@&quot;=========&gt; testView touchs Moved&quot;);&#125;- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@&quot;=========&gt; testView touchs Ended&quot;);&#125;- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@&quot;=========&gt; testView touchs Cancelled&quot;);&#125; 情景O：注释 手势 ，分别点击 superView 和 testView： 123452023-03-08 17:58:44.408166+0800 手势冲突[20427:1092257] =========&gt; superView touchs Began2023-03-08 17:58:44.544181+0800 手势冲突[20427:1092257] =========&gt; superView touchs Ended2023-03-08 17:58:54.666862+0800 手势冲突[20427:1092257] =========&gt; testView touchs Began2023-03-08 17:58:54.825938+0800 手势冲突[20427:1092257] =========&gt; testView touchs Ended 情景A：单击 superView ，输出结果： 1232023-03-08 17:32:44.983101+0800 手势冲突[20227:1064772] =========&gt; superView touchs Began2023-03-08 17:32:45.043310+0800 手势冲突[20227:1064772] =========&gt; single Tapped2023-03-08 17:32:45.043538+0800 手势冲突[20227:1064772] =========&gt; superView touchs Cancelled 情景B：单击 testView，输出结果： 1232023-03-08 17:43:16.370199+0800 手势冲突[20326:1077469] =========&gt; testView touchs Began2023-03-08 17:43:16.430723+0800 手势冲突[20326:1077469] =========&gt; single Tapped2023-03-08 17:43:16.430939+0800 手势冲突[20326:1077469] =========&gt; testView touchs Cancelled 情景C：单击 testBtn，输出结果： 12023-03-08 17:43:40.690096+0800 手势冲突[20326:1077469] =========&gt; click btn 情景D：按住 testView，过3秒后或更久释放，输出结果： 122023-03-08 17:43:50.678603+0800 手势冲突[20326:1077469] =========&gt; testView touchs Began2023-03-08 17:43:53.499119+0800 手势冲突[20326:1077469] =========&gt; testView touchs Ended 情景 O、A、B 分析开发文档可知： Gesture Recognizers Get the First Opportunity to Recognize a Touch. A window delays the delivery of touch objects to the view so that the gesture recognizer can analyze the touch first. During the delay, if the gesture recognizer recognizes a touch gesture, then the window never delivers the touch object to the view, and also cancels any touch objects it previously sent to the view that were part of that recognized sequence. Google翻译： 手势识别器获得识别触摸的第一个机会。 一个窗口延迟将触摸对象传递到视图，使得手势识别器可以首先分析触摸。 在延迟期间，如果手势识别器识别出触摸手势，则窗口不会将触摸对象传递到视图，并且还将先前发送到作为识别的序列的一部分的视图的任何触摸对象取消。 触摸事件首先传递到手势上，如果手势识别成功了，就会取消事件的继续传递，否则，事件还是会被响应链处理。系统维持了与响应链关联的所有手势，事件首先传递给手势，然后才传递给响应链。这样我们就解释A和B的场景了 情景 C 分析：iOS 开发文档里这样说： In iOS 6.0 and later, default control actions prevent overlapping gesture recognizer behavior. For example, the default action for a button is a single tap. If you have a single tap gesture recognizer attached to a button’s parent view, and the user taps the button, then the button’s action method receives the touch event instead of the gesture recognizer. This applies only to gesture recognition that overlaps the default action for a control, which includes: A single finger single tap on a UIButton, UISwitch, UISegmentedControl, UIStepper,and UIPageControl.A single finger swipe on the knob of a UISlider, in a direction parallel to the slider.A single finger pan gesture on the knob of a UISwitch, in a direction parallel to the switch. Google 翻译为： 在iOS 6.0及更高版本中，默认控制操作可防止重叠的手势识别器行为。 例如，按钮的默认操作是单击。 如果您有一个单击手势识别器附加到按钮的父视图，并且用户点击按钮，则按钮的动作方法接收触摸事件而不是手势识别器。 这仅适用于与控件的默认操作重叠的手势识别，其中包括： 单个手指单击UIButton，UISwitch，UISegmentedControl，UIStepper和UIPageControl.单个手指在UISlider的旋钮上滑动，在平行于滑块的方向上。在UISwitch的旋钮上的单个手指平移手势 与开关平行的方向。 因此，在情景C，点击testBtn的action，按钮获取了事件响应，不会把事件响应传递给父视图的supView 情景 C 分析： 长按testView已经不是单击事件了，tap手势就不会识别 实际开发中遇到的问题 父视图上先后添加了一个 UIGestureRecognizer 和一个 UITableView 我们发现在点击 UITableView 的 cell 的时候，并没有触发 -(void)tableView:(UITableView*)tableView didSelectRowAtIndexPath:(NSIndexPath*)indexPath; 方法。 分析由于 cell 继承 cell -&gt; UIView -&gt; UIResponder，是可以接收和处理事件的，但是添加了 tap 后会导致 cell 响应链无法正常响应，导致 手势冲突 解决方法在我们点击 cell 的时候，不让父视图的 手势 干扰子视图cell的点击事件或者说响应链正常传递，一般会重写 UIGestureRecognizerDelegate 中的 - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch方法。 12345678910111213- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch&#123; // 如果是UITableViewCell类或子类响应事件 if ([touch.view isKindOfClass:[UITableViewCell class]]) &#123; return YES; &#125; //默认都需要响应 return NO;&#125;=========2023-03-08 18:19:39.851593+0800 手势冲突[20552:1111844] -[ParentV tableView:didSelectRowAtIndexPath:]2023-03-08 18:19:40.583123+0800 手势冲突[20552:1111844] -[ParentV tableView:didSelectRowAtIndexPath:]...","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习06：截取视频文件第一帧的方法有哪些？","slug":"OC学习/OC学习06：截取视频文件第一帧的方法有哪些？","date":"2023-03-07T11:16:39.000Z","updated":"2023-03-08T18:53:13.543Z","comments":true,"path":"2023/03/07/OC学习/OC学习06：截取视频文件第一帧的方法有哪些？/","link":"","permalink":"https://www.bboyzj.cn/2023/03/07/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A006%EF%BC%9A%E6%88%AA%E5%8F%96%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E7%AC%AC%E4%B8%80%E5%B8%A7%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/","excerpt":"","text":"前言iOS 中获取视频第一帧有两种方式 第一种：使用AVFoundation获取将耗时的操作放在异步执行队列 dispatch_async，防止造成线程堵塞，刷新UI放在 主线程 123456789101112- (UIImage *)getFirstFrameFromVideoWithUrl:(NSURL *)url&#123; AVURLAsset *asset = [[AVURLAsset alloc] initWithURL:url options:nil]; AVAssetImageGenerator *assetGennerator = [[AVAssetImageGenerator alloc] initWithAsset:asset]; assetGennerator.appliesPreferredTrackTransform = YES; CMTime time = CMTimeMakeWithSeconds(0.0, 600); CMTime actualTime; NSError *error = nil; CGImageRef image = [assetGennerator copyCGImageAtTime:time actualTime:&amp;actualTime error:&amp;error]; UIImage *videoImg = [[UIImage alloc] initWithCGImage:image]; CGImageRelease(image); return videoImg;&#125; 第二种方式：使用SDWebImage获取，并缓存图片123456789101112131415161718192021222324252627282930313233343536373839404142- (void)method2&#123; NSURL *url = [NSURL URLWithString:@&quot;https://klxxcdn.oss-cn-hangzhou.aliyuncs.com/histudy/hrm/media/bg1.mp4&quot;]; NSString *urlKey = url.absoluteString; // 先从缓存中查找是否有图片 SDImageCache *imgCache = [SDImageCache sharedImageCache]; UIImage *memoryImg = [imgCache imageFromCacheForKey:urlKey]; if (memoryImg) &#123; self.imgV.image = memoryImg; &#125;else &#123; // 从磁盘中查找是否有图片 UIImage *diskImg = [imgCache imageFromDiskCacheForKey:urlKey]; if (diskImg) &#123; self.imgV.image = diskImg; &#125;else &#123; // 如果都不存在 // 开启异步线程下载图片 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; AVURLAsset *asset = [[AVURLAsset alloc] initWithURL:url options:nil]; NSParameterAssert(asset); AVAssetImageGenerator *assetGenerator = [[AVAssetImageGenerator alloc] initWithAsset:asset]; assetGenerator.appliesPreferredTrackTransform = YES; assetGenerator.apertureMode = AVAssetImageGeneratorApertureModeEncodedPixels; CGImageRef thumbImgRef = NULL; CFTimeInterval thumbImgTime = 1; NSError *thumbImgError = nil; thumbImgRef = [assetGenerator copyCGImageAtTime:CMTimeMake(thumbImgTime, 60) actualTime:NULL error:&amp;thumbImgError]; if (!thumbImgRef)&#123; NSLog(@&quot;thumbImgError:%@&quot;,thumbImgError); &#125; UIImage *thumbImg = thumbImgRef ? [[UIImage alloc] initWithCGImage:thumbImgRef] : nil; // 主线程显示UI dispatch_async(dispatch_get_main_queue(), ^&#123; SDImageCache *imgCache = [SDImageCache sharedImageCache]; [imgCache storeImage:thumbImg forKey:urlKey completion:^&#123; NSLog(@&quot;store Image success&quot;); &#125;]; self.imgV.image = thumbImg; &#125;); &#125;); &#125; &#125; &#125;","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习05：分类和扩展","slug":"OC学习/OC学习05：分类和扩展","date":"2023-03-06T13:50:50.000Z","updated":"2023-03-08T19:02:49.668Z","comments":true,"path":"2023/03/06/OC学习/OC学习05：分类和扩展/","link":"","permalink":"https://www.bboyzj.cn/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A005%EF%BC%9A%E5%88%86%E7%B1%BB%E5%92%8C%E6%89%A9%E5%B1%95/","excerpt":"","text":"分类 Category Category 的主要作用是为 已经存在的类添加(扩展)方法 已存在的类可以是 系统的类 或 自定义的类 不能定义 变量（成员变量或实例变量） 一般情况下也可以定义 属性，但是 不会实现 它的 set 和 get 方法，需要利用 runtime 机制去实现它的 set 和 get 方法。 分类文件有 .h 和 .m 两个文件，文件名 @interface 类名 (分类名) 创建 系统 分类 command + n 点击 Objective-C File 创建完成后会生成 系统文件名+Category.h 和 系统文件名+Category.m 两个文件 在分类中可以添加 实例方法和类方法 123456789101112131415@interface UIViewController (Cate)- (void)sayHello;+ (void)sayBye;@end==============@implementation UIViewController (Cate)- (void)sayHello&#123; NSLog(@&quot;hello&quot;);&#125;+ (void)sayBye&#123; NSLog(@&quot;bye&quot;);&#125;@end 在本类中调用，需要引入头文件 文件名+Category.h 12345678 // 分类[self sayHello];[ViewController sayBye];======Category[30386:1690552] bye2023-03-06 22:06:37.369596+0800 Category[30386:1690552] hello2023-03-06 22:06:37.369794+0800 Category[30386:1690552] bye 自定义的类 添加 分类 创建方式类似 与系统类类似，在 class 中选择自定义的类 Person 可以在 分类中声明并实现 两个方法，在本类中调用 分类中声明并实现 123456789101112131415@interface Person (Category)- (void)sayHello;+ (void)sayBye;@end---------@implementation Person (Category)- (void)sayHello&#123; NSLog(@&quot;%s&quot;,__func__);&#125;+ (void)sayBye&#123; NSLog(@&quot;%s&quot;,__func__);&#125;@end 本类中调用，编译运行，查看打印结果 123456789101112131415@implementation Person- (instancetype)init&#123; self = [super init]; if (self) &#123; // 本类中调用分类添加的方法 [self sayHello]; [Person sayBye]; &#125; return self;&#125;@end============2023-03-07 08:14:34.439456+0800 Category[3555:114948] -[Person(Category) sayHello]2023-03-07 08:14:34.439626+0800 Category[3555:114948] +[Person(Category) sayBye] 那么问题来了，既然本类中可以调用，那么在其他类中是否也可以调用呢？ 其他类中调用 分类 方法1234567891011121314// 自定义的类#import &quot;Person.h&quot;#import &quot;Person+Category.h&quot;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // 自定义的类 Person * p = [[Person alloc] init]; [p sayHello]; [Person sayBye];&#125;========2023-03-07 08:19:57.913133+0800 Category[3631:119871] -[Person(Category) sayHello]2023-03-07 08:19:57.913667+0800 Category[3631:119871] +[Person(Category) sayBye] 由打印结果可知，在VC中时可以调用的 那么问题又来了，如果本类中和分类中均实现了 同样的方法 会调用哪个？ 分类和本类实现了同样的方法 在 Person 类中实现一个 sayHello 123- (void)sayHello&#123; NSLog(@&quot;%s&quot;,__func__);&#125; 在 VC 中调用 sayHello 123456// 自定义的类Person * p = [[Person alloc] init];[p sayHello];============2023-03-07 08:24:09.821814+0800 Category[3670:122944] -[Person(Category) sayHello] 由打印结果可知，调用的是 分类 的方法，由此我们可以推断，本类的方法被分类替代了 扩展 Extension 是类的一部分，在编译器和头文件里的@interface一级实现文件里的@implement一起形成一个完整的类，它伴随着类的产生而产生，亦随之一起消亡 作用 声明 私有属性、私有方法、私有成员变量，想要被访问 @public 扩展不能为系统类添加扩展（必须有一个类的源码才能添加一个类的Extension），所以你无法为系统的类添加Extension 成员变量和实例变量是 私有的，不能被外界访问， 属性可以被外界访问，由于没有实现调用会 carsh 方法可以被外界访问，由于没有实现set和get方法，访问会 carsh 扩展只有一个 .h 文件，因此 所有的都是没办法调用 使用 创建 Extension 自定义类中的代码 12345678910111213@interface Person : NSObject@end========#import &quot;Person.h&quot;#import &quot;Person+Extension.h&quot;@implementation Person- (void)sayHello&#123; NSLog(@&quot;%s hello&quot;,__func__);&#125;@end 在 #import &quot;Person+Ext.h&quot; 中实现如下代码 123456789@interface UIViewController ()&#123; NSString * name; @public int age;&#125;@property (nonatomic,copy)NSString * sex;- (void)sayHello;+ (void)sayBye;@end 在 VC 中调用 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; Person * p = [Person new]; // 调用报错或崩溃// p-&gt;age = 30;// p-&gt;name = &quot;ZJ&quot;;// p.sex = @&quot;男&quot;;// [Person sayBye]; [p sayHello];&#125;=======2023-03-06 22:35:02.277867+0800 Extension[30580:1704777] -[Person sayHello] hello 如果只有声明没有实现，则调用会 Crash 分类 和 扩展的区别 category 在运行时决议。extension 在编译时决议。所以扩展中的方法没有被实现编译器会报警告，分类中没有被实现编译器不会警告 分类原则上只能添加方法，不能添加属性（因为没有实现属性的seter和getter方法，可以通过runtime添加）。扩展能添加方法、实例变量，默认是@private类型的，且只能作用于自身类 分类有自己的实现部分。扩展没有实现部分，只能依托对应的类的实现部分。 分类可以为系统添加分类。扩展不能为系统添加分类。","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习04：JSON和XML数据解析","slug":"OC学习/OC学习04：JSON和XML数据解析","date":"2023-03-06T06:09:53.000Z","updated":"2023-03-07T12:01:51.659Z","comments":true,"path":"2023/03/06/OC学习/OC学习04：JSON和XML数据解析/","link":"","permalink":"https://www.bboyzj.cn/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A004%EF%BC%9AJSON%E5%92%8CXML%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/","excerpt":"","text":"前言 在 iOS 开发中，常见的数据传输格式有两种：JSON和XML。 服务器返回客户端的数据，一般都是 JSON格式或XML格式（文件下载除外） JSON 由于 体积小、传输快速 等优点，逐渐成为了 主流的数据传输格式。 JSON在 iOS 中，常见解析方案有以下几种： 第三方框架：JSONKit、SBJson、TouchJSON（性能从左到右，越来越差） 性能最好的是使用 苹果原生的框架： NSJSONSerialization JSON格式很像OC中的数组和字典，key必须用双引号 1&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:22&#125;、[&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:22&#125;,&#123;&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:22&#125;] JSON格式 JSON 转 OC 第一个参数：要解析的JSON数据，是NSData类型也就是二进制数据 第二个参数：解析JSON的可选配置参数 NSJSONReadingMutableContainers 解析出来的字典和数组是可变的 NSJSONReadingFragmentsAllowed 解析出来的对象中的字符串是可变的 NSJSONReadingMutableLeaves 被解析的数据如果既不是字典也不是数组，那么就使用这个 第三个参数：错误信息 1NSDictionary * dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&amp;error]; OC 转 JSON 第一个参数：要转换成JSON数据的OC对象，这里是一个字典 第二个参数：NSJSONWritingPrettyPrinted 对转换之后的JSON对象进行排版，无意义 第三个参数：错误信息 1NSData *data = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;error]; XML XML 可扩展标记语言，是一种数据交互格式，也叫XML文档 XML 被设计用来传输和存储数据 构成常见的XML文档由三部分组成 文档声明 在XML文档最前面，必须编写一个文档声明，用来声明XML文档的类型 12345// 最简单的声明&lt;?xml version=&quot;1.0&quot; ?&gt;// 用encoding属性说明文档的字符编码&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; 元素 一个元素包括了 开始标签和结束标签， 有内容的元素 &lt;name&gt;Tom&lt;/name&gt;；没内容的元素 &lt;from&gt;&lt;/from&gt;，可简写成 &lt;from/&gt; 元素可嵌套其他元素，不可出现交叉嵌套 属性 一个元素最多可以拥有多个属性，属性值必须用双引号 &quot; &quot; 或 单引号 &#39; &#39; 括住 示例 123456&lt;root&gt; &lt;person id=&quot;p1&quot;&gt; &lt;name&gt;Tom&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;/person&gt;&lt;/root&gt; XML 解析的方法要想从XML中提取信息，就得解析XML，目前针对XML的解析有两种方式： SAX：从根元素开始，按照顺序一个元素一个元素的往下解析，可用于解析大、小文件 DOM：一次性将整个XML文档加载到内存中，适合较小的文件 iOS 中解析 XML 有两种： 苹果原生：使用 NSXMLParse，SAX方式解析，使用简答 第三方框架：libxml2、GDataXML libxml2 纯 c 语音，默认包含在iOS SDK中，同时支持DOM和SAX方式解析 GDataXMLDOM 解析，由 google 基于 libxml2 开发 解析XML大文件建议用：NSXMLParse、libxml2解析XML小文件上述三种都可以 NSXMLParse 使用 添加NSXMLParserDelegate协议 获取XML文件，初始化NSXMLParser，并开启解析 实现协议中的方法 XMLElement 文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@interface XMLElement : NSObject// 元素名称@property (nonatomic,strong)NSString *name;//元素节点文本@property (nonatomic,strong)NSMutableString *text;@property (nonatomic,strong)NSDictionary *attribute;@property (nonatomic,strong)XMLElement *parent;@property (nonatomic,strong)NSMutableArray&lt;XMLElement *&gt; *childElement;@end🔽#import &quot;XMLElement.h&quot;@implementation XMLElement- (instancetype)init&#123; self = [super init]; if (self) &#123; _text=[[NSMutableString alloc]init]; &#125; return self;&#125;- (NSMutableArray&lt;XMLElement *&gt; *)childElement&#123; if (!_childElement) &#123; _childElement = [[NSMutableArray alloc]init]; &#125; return _childElement;&#125;- (NSString *)description&#123; NSDictionary *dic = [self convertToDic]; if ([NSJSONSerialization isValidJSONObject:dic]) &#123; NSError *error; NSData *jsonData=[NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;error]; if (error) &#123; return @&quot;&#123;&#125;&quot;; &#125; if (jsonData) &#123; @try &#123; NSString *jsonStr = [[NSString alloc]initWithData:jsonData encoding:NSUTF8StringEncoding]; return jsonStr; &#125; @catch (NSException *exception) &#123; &#125; &#125; &#125; return @&quot;&#123;&#125;&quot;; &#125;- (NSDictionary *)convertToDic&#123; NSMutableDictionary *dic = [[NSMutableDictionary alloc] init]; if (self.name) &#123; dic[self.name]=self.text; &#125; if (self.attribute &amp;&amp; self.attribute.count &gt; 0) &#123; [dic addEntriesFromDictionary:self.attribute]; &#125; if (self.childElement &amp;&amp; self.childElement.count &gt; 0) &#123; NSMutableArray *child=[[NSMutableArray alloc]init]; for (XMLElement *element in self.childElement) &#123; NSDictionary *childDic = [element convertToDic]; if (element.childElement &amp;&amp; element.childElement.count &gt; 0) &#123; [child addObject:childDic]; &#125;else&#123; [dic addEntriesFromDictionary:childDic]; &#125; &#125; if (child.count &gt; 0) &#123; dic[@&quot;child&quot;]=child; &#125; &#125; return dic;&#125;@end XMLParserManager 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#import &lt;Foundation/Foundation.h&gt;#import &quot;XMLElement.h&quot;NS_ASSUME_NONNULL_BEGINtypedef void(^ParserXMLCompletion) (BOOL success, XMLElement * _Nullable data,NSError * _Nullable error);@interface XMLParserManager : NSObject@property(nonatomic,copy)ParserXMLCompletion completion;- (void)parserXMLWithUrl:(NSURL *)url completion:(ParserXMLCompletion)completion;@end🔽#import &quot;XMLParserManager.h&quot;@interface XMLParserManager()&lt;NSXMLParserDelegate&gt;@property (nonatomic,strong)NSXMLParser *parser;@property (nonatomic,strong)XMLElement *rootElement;@property (nonatomic,strong)XMLElement *currentElement;@end@implementation XMLParserManager- (void)parserXMLWithUrl:(NSURL *)url completion:(ParserXMLCompletion)completion&#123; if (url) &#123; self.completion = completion; __weak typeof(self) weakSelf = self; NSInputStream *fileInput=[[NSInputStream alloc] initWithURL:url]; // 创建一个解析器 _parser = [[NSXMLParser alloc] initWithStream:fileInput]; // 设置代理 _parser.delegate = self; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^&#123; __strong typeof(weakSelf) strongSelf = weakSelf; // 开始解析 [strongSelf.parser parse]; // 解析错误 if (weakSelf.parser.parserError) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (completion) &#123; completion(NO,nil,strongSelf.parser.parserError); &#125; &#125;); &#125; &#125;); &#125;&#125;// 文档开始-(void)parserDidStartDocument:(NSXMLParser *)parser&#123; self.rootElement = nil; self.currentElement = nil;&#125;/* 开始解析某个节点 parser xml对象 elementName 标签 namespaceURI 命名控件指向的链接 qName 命名控件名称 attributeDict 节点的所有属性 */-(void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary&lt;NSString *,NSString *&gt; *)attributeDict&#123; if (!self.rootElement) &#123; self.rootElement = [[XMLElement alloc]init]; self.currentElement = self.rootElement; &#125;else&#123; XMLElement *element = [[XMLElement alloc]init]; // 父节点 element.parent = self.currentElement; // 当前元素的子节点 [self.currentElement.childElement addObject:element]; element.name = elementName; // 更换当前元素 self.currentElement = element; &#125; // 元素名和属性 self.currentElement.name = elementName; self.currentElement.attribute = attributeDict;&#125;// 当解析器找到开始标记和结束标记之间的字符时，调用这个方法解析当前节点的所有字符- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string&#123; // 获取当前元素的内容 [self.currentElement.text appendString:string];&#125;// 结束解析-(void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName&#123; self.currentElement = self.currentElement.parent;&#125;// 文档结束-(void)parserDidEndDocument:(NSXMLParser *)parser&#123; __weak typeof(self) weakSelf = self; if (self &amp;&amp; self.completion) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; __strong typeof(weakSelf) strongSelf = weakSelf; strongSelf.completion(YES, strongSelf.rootElement, nil); &#125;); &#125;&#125;// 解析失败- (void)parser:(NSXMLParser *)parser validationErrorOccurred:(NSError *)validationError&#123; if (self.completion) &#123; __weak typeof(self) weakSelf = self; dispatch_async(dispatch_get_main_queue(), ^&#123; __strong typeof(weakSelf) strongSelf = weakSelf; strongSelf.completion(NO, nil,validationError); &#125;); &#125;&#125;@end VC 调用 1234567891011121314151617181920212223242526272829303132#import &quot;ViewController.h&quot;#import &quot;XMLParserManager.h&quot;@interface ViewController ()@property (nonatomic,strong)XMLParserManager *manager;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; &#125;-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [self parserXML];&#125;-(void)parserXML&#123; NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;xmlText&quot; ofType:@&quot;xml&quot;]; NSURL *url = [NSURL fileURLWithPath:path]; _manager=[[XMLParserManager alloc]init]; [_manager parserXMLWithUrl:url completion:^(BOOL success, XMLElement * _Nullable data, NSError * _Nullable error) &#123; if (success) &#123; NSLog(@&quot;%@&quot;,data); &#125;else&#123; NSLog(@&quot;error = %@&quot;,error); &#125; &#125;]; NSLog(@&quot;start == &quot;); &#125;@end GDataXML 使用 GDataXMLDocument：xml解析入口 GdataXMLElement：保存查找的数据 GdataXMLNode：保存解析的数据 第一步：集成 GDataXML-HTML 123456789target &#x27;XML文件解析&#x27; do # Comment the next line if you don&#x27;t want to use dynamic frameworks use_frameworks! pod &#x27;GDataXML-HTML&#x27;, &#x27;~&gt; 1.4.1&#x27; # Pods for XML文件解析end 第二步：项目中配置 pod 安装 GDataXML 选中target -&gt; Build Settings -&gt; Link Binary With Libraried，搜索添加 libxml2 Header Search Paths 添加 /usr/include/libxml2 Other Linker Flags 添加 -lxml2 引入头文件使用 123456789101112131415161718- (void)GDataParserXML&#123; // 加载xmlwen文件 NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;xmlText&quot; ofType:@&quot;xml&quot;]; NSURL *url = [NSURL fileURLWithPath:path]; NSData *data = [NSData dataWithContentsOfURL:url]; NSError *error= nil; GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithData:data error:&amp;error]; // 拿到根元素，得到根元素下所有子孙元素 NSArray * elementList =[doc.rootElement elementsForName:@&quot;book&quot;]; for (GDataXMLElement *element in elementList) &#123; NSString *title=((GDataXMLElement *)[[element elementsForName:@&quot;title&quot;] firstObject]).stringValue; NSString *author=((GDataXMLElement *)[[element elementsForName:@&quot;author&quot;] firstObject]).stringValue; NSString *year=((GDataXMLElement *)[[element elementsForName:@&quot;year&quot;] firstObject]).stringValue; NSString *price=((GDataXMLElement *)[[element elementsForName:@&quot;price&quot;] firstObject]).stringValue; NSLog(@&quot;title = %@ author = %@ year = %@ price = %@&quot;,title,author,year,price); &#125;&#125;","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"Swift学习40：类&结构体&枚举：下标和下标重载","slug":"Swift学习/Swift学习40：类-结构体-枚举：下标和下标重载","date":"2023-03-05T12:28:10.000Z","updated":"2023-03-05T13:05:24.366Z","comments":true,"path":"2023/03/05/Swift学习/Swift学习40：类-结构体-枚举：下标和下标重载/","link":"","permalink":"https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A040%EF%BC%9A%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE%EF%BC%9A%E4%B8%8B%E6%A0%87%E5%92%8C%E4%B8%8B%E6%A0%87%E9%87%8D%E8%BD%BD/","excerpt":"","text":"下标 类、结构体和枚举可以定义 下标，它可以作为访问集合、列表或序列号成员元素的快捷方式。你可以使用下标通过索引值来设置或检索值而不需要为设置和检索分别使用实例方法 你可以为一个类型定义多个下标，并且下标会基于传入的索引值的类型选择合适的下标重载使用。下标没有限制单个维度，你可以使用多个输入形参来定义下标以满足自定义类型的需求 下标语法 下标脚本允许你通过在实例名后面的方括号内写一个或多个值对该类的实例进行查询。它的语法类似于实例方法和计算属性。使用关键字 subscript 来定义下标，并且指定一个或多个输入形式参数和返回类型，与实例方法一样。与实例方法不同的是，下标可以是读写也可以是只读的 1","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习39：为类&结构体&枚举添加属性和方法","slug":"Swift学习/Swift学习39：为类-结构体-枚举添加属性和方法","date":"2023-03-05T10:25:21.000Z","updated":"2023-03-05T12:58:00.612Z","comments":true,"path":"2023/03/05/Swift学习/Swift学习39：为类-结构体-枚举添加属性和方法/","link":"","permalink":"https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A039%EF%BC%9A%E4%B8%BA%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/","excerpt":"","text":"为类、结构体、枚举添加 属性存储属性 存储属性 是一个作为特定类和结构体实例一部分的 常量或变量。存储属性要么是变量存储属性（由 var 关键字引入），要么是常量存储属性（由 let 关键字引入） 1234567// 存储属性class DataManager &#123; // 变量存储属性 var fileName = &quot;tex&quot; // 常量存储属性 let age = 10&#125; 常量结构体实例的存储属性 如果你创建了一个 结构体的实例 并且把这个 实例赋值给常量，你 不能修改 这个实例的属性，即使是声明为变量的属性 延迟存储属性 延迟存储属性的初始值在第一次使用时才进行计算。你可以通过在其声明前面标注 lazy 修饰语 来表示一个 延迟存储属性 如果被标记为 lazy 修饰符的属性同时被多个线程访问并且属性还没有被初始化，则无法保证属性只初始化一次。 12345// 存储属性class DataManager &#123; // 延迟存储属性 lazy var data = [String]()&#125; 计算属性 除了存储属性，类、结构体、枚举 还能定义 计算属性，而它实际并不是存储值。相反，它提供一个读取器和一个可选的设置器来间接得到和设置其它的属性和值。类似于 OC 的 set/get 方法去设值和取值 123456789101112131415161718192021222324252627// 计算属性struct Point &#123; var x = 0.0,y = 0.0&#125;struct Size &#123; var width = 0.0,height = 0.0&#125;struct Rect &#123; // 存储属性 var origin = Point() var size = Size() // 计算属性：可以通过origin 和 size 计算出来 var center: Point &#123; get &#123; let centerX = origin.x + size.width/2.0 let centerY = origin.y + size.height/2.0 return Point(x:centerX, y:centerY) &#125; set(newCenter) &#123; origin.x = newCenter.x - size.width/2.0 origin.y = newCenter.y - size.height/2.0 &#125; &#125;&#125;============= 简写 setter 如果一个计算属性的设置器没有为将要被设置的值定义一个名字，那么它将被默认命名为 newValue 1234set &#123; origin.x = newValue.x - size.width/2.0 origin.y = newValue.y - size.height/2.0&#125; 简写 getter 如果整个 getter 的函数体是一个单一的表达式，那么 getter 隐士返回这个表达式 1234// 简写 getget &#123; Point(x: origin.x + size.width/2.0,y: origin.y + size.height/2.0)&#125; 只读计算属性 一个 有读取器 但是 没有设置器 的 计算属性 就是所谓的 只读计算属性。只读计算属性返回一个值，也可以通过点语法访问，但是不能被修改为另一个值 你必须用 var关键字 定义计算属性（包括只读计算属性）为变量属性，因为它的值不是固定的。let关键字 只能用于常量属性，用于明确哪些值一旦作为实例初始化就不能更改 123456789101112// 只读计算属性struct Rect &#123; // 存储属性 var origin = Point() var size = Size() // 计算属性：可以通过origin 和 size 计算出来 var center: Point &#123; get &#123; return Point(x: origin.x + size.width/2.0,y: origin.y + size.height/2.0) &#125; &#125;&#125; 属性观察者 willSet 会在该值被存储之前被调用 didSet 会在一个新值被存储之后被调用 如果你实现了一个 willSet 观察者，新的属性值会以常量形式参数传递。你可以再你的 willSet 实现中为这个参数定义名字。如果你没有为它命名，那么它会使用默认值的名字 newValue 如果你实现了一个 didSet 观察者，一个包含旧属性值的常量形式参数将会被传递。你可以为它命名，也可以使用默认值的形式参数名 oldValue。如果你在属性自己的 disSet 观察者里给自己赋值，你赋值的新值就会取代刚刚设置的值。 12345678910111213141516171819202122// 属性观察者class StepCounter &#123; var totalSteps: Int = 0 &#123; willSet(newValue) &#123; print(&quot;totalSteps to \\(newValue)&quot;) &#125; didSet &#123; if totalSteps &gt; oldValue &#123; print(&quot;add \\(totalSteps - oldValue) steps&quot;) &#125; &#125; &#125;&#125;let stepCounter = StepCounter()stepCounter.totalSteps = 100stepCounter.totalSteps = 200============totalSteps to 100add 100 stepstotalSteps to 200add 100 steps 全局和局部变量 观察属性的能力同样对全局变量和局部变量有效。全局变量 是定义在 任何函数、方法、闭包或者类型环境之外的变量。局部变量 是定义在 函数、方法或闭包环境之中的变量。 1234567891011121314// 全局变量var count: Int = 0 &#123; willSet &#123; print(&quot;will set count to \\(newValue)&quot;) &#125; didSet &#123; print(&quot;did change count from \\(oldValue) to \\(count)&quot;) &#125;&#125;count = 10==============will set count to 10did change count from 0 to 10 类型属性 使用 static 关键字来定义 类型属性。对于 类 的 类型属性，你可以使用 class 关键字来 允许子类重写父类的实现 1234567891011// 类型属性class SomeClass &#123; static var storedProperty = &quot;some value&quot; static var computedProperty: Int &#123; return 27 &#125; // 重写get方法 class var overrideComputedProperty: Int &#123; return 107 &#125;&#125; 为类、结构体、枚举添加 方法实例方法 实例方法 是属于 特定类实例、结构体实例或枚举实例的函数。他们为这些实例提供功能性，要么通过提供访问和修改实例属性的方法，要么通过提供与实例目的相关的功能 每一个类的实例都隐含一个叫做 self 的属性，它完全与实例本身相等。你可以用 self 属性在当前实例中调用自身的方法 实际上，你不需要经常在代码中写 self。如果你没有显示地写出 self，swift 会在你方法中使用已知属性或方法的时候假定你调用了当前实例中的属性或者方法 例外就是当一个实例方法的形式参数名与实例中某个属性拥有相同的名字的时候。在这种情况下，形式参数名具有优先权，并且调用属性的时候使用更加严谨的方式就很有必要了。你可以使用 self 属性来 区分形式参数名和属性名 123456789101112struct Point &#123; var x = 0.0, y = 0.0 // 实例方法 func pringInfo() &#123; print(&quot;x is \\(x),y is \\(y)&quot;) &#125;&#125;var p = Point(x: 2,y: 2)p.pringInfo()=======x is 2.0,y is 2.0 实例方法 self1234567891011121314struct Point &#123; var x = 0.0, y = 0.0 // 实例方法 self func isToTheRightOf(x: Double) -&gt; Bool &#123; return self.x &gt; x &#125;&#125;let somePoint = Point(x: 2.0,y: 3.0)if somePoint.isToTheRightOf(x: 1.0) &#123; print(&quot;the point is x \\(somePoint.x)&quot;)&#125;=======the point is x 2.0 在实例方法中修改属性 结构体和枚举是值类型。默认情况下，值类型属性不能被自身的实例方法修改 你可以选择在 func 关键字前放一个 mutating(异变方法) 关键字来 指定可以修改属性 123456789101112131415// 修改属性struct Point &#123; var x = 0.0, y = 0.0 // 异变方法 mutating func moveBy(x deltaX: Double,y deltaY: Double) &#123; x += deltaX y += deltaY &#125;&#125;var somePoint = Point(x: 1.0, y: 3.0)somePoint.moveBy(x: 2.0,y: 2.0)print(&quot;\\(somePoint.x) \\(somePoint.y)&quot;)===========3.0 5.0 在 mutating 方法中赋值给 self mutating 方法可以指定整个实例给隐含的 self 属性 1234567891011121314// selfstruct Point &#123; var x = 0.0, y = 0.0 // 异变方法 mutating func moveBy(x deltaX: Double,y deltaY: Double) &#123; self = Point(x:x+deltaX,y:y+deltaY) &#125;&#125;var somePoint = Point(x: 2.0, y: 4.0)somePoint.moveBy(x: 2.0,y: 2.0)print(&quot;\\(somePoint.x) \\(somePoint.y)&quot;)=======4.0 6.0 枚举的 mutating 方法 枚举的 异变方法 可以设置隐含的 self 属性为相同枚举里的不同成员 1234567891011121314151617// 枚举 mutating 方法enum StateSwitch &#123; case off,low,high mutating func next() &#123; switch self &#123; case .off: self = .low case .low: self = .high case .high: self = .off &#125; &#125;&#125;var light = StateSwitch.lowlight.next()light.next() 类型方法 通过在 func 关键字前用 static 关键字来明确一个类型方法。类同样可以使用 class关键字 来允许子类重写父类对类型方法的实现 1234567891011121314151617181920// 实例方法 selfstruct Point &#123; var x = 0.0, y = 0.0 func pringInfo() &#123; print(&quot;x is \\(x),y is \\(y)&quot;) &#125; // 类方法 static func printTypeInfo() &#123; print(&quot;A Point&quot;) &#125;&#125;var p = Point(x: 2,y: 2)p.pringInfo()// 类方法用类型调用Point.printTypeInfo()=====x is 2.0,y is 2.0A Point","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习37：扩展","slug":"Swift学习/Swift学习42：扩展","date":"2023-03-05T09:05:03.000Z","updated":"2023-03-05T09:05:03.104Z","comments":true,"path":"2023/03/05/Swift学习/Swift学习42：扩展/","link":"","permalink":"https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A042%EF%BC%9A%E6%89%A9%E5%B1%95/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习37：协议","slug":"Swift学习/Swift学习41：协议","date":"2023-03-05T09:04:54.000Z","updated":"2023-03-05T09:04:54.483Z","comments":true,"path":"2023/03/05/Swift学习/Swift学习41：协议/","link":"","permalink":"https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A041%EF%BC%9A%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习37：类","slug":"Swift学习/Swift学习40：类","date":"2023-03-05T09:04:46.000Z","updated":"2023-03-05T09:04:46.898Z","comments":true,"path":"2023/03/05/Swift学习/Swift学习40：类/","link":"","permalink":"https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A040%EF%BC%9A%E7%B1%BB/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习37：结构体","slug":"Swift学习/Swift学习43：结构体","date":"2023-03-05T09:04:39.000Z","updated":"2023-03-05T09:04:39.405Z","comments":true,"path":"2023/03/05/Swift学习/Swift学习43：结构体/","link":"","permalink":"https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A043%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习38：枚举","slug":"Swift学习/Swift学习38：枚举","date":"2023-03-05T09:04:28.000Z","updated":"2023-03-05T10:21:35.158Z","comments":true,"path":"2023/03/05/Swift学习/Swift学习38：枚举/","link":"","permalink":"https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A038%EF%BC%9A%E6%9E%9A%E4%B8%BE/","excerpt":"","text":"增强的枚举枚举的语法 用 enum 关键字来定义一个枚举，然后将其所有的定义内容放在一个大括号 &#123;&#125; 中 多个成员值可以出现在同一行中，用逗号隔开 每个枚举都定义了一个全新的类型。正如swift中其它类型那样，它的名称（例如： ComP）需要首字母大写。给枚举类型起一个单数的而不是复数的名字，从而使得他们能够顾名思义 123456789101112enum ComP &#123; case east case south case west case north&#125;或enum ComP2 &#123; case ease, south, west, north&#125; 使用 Switch 语句来匹配枚举值 你可以用 switch 语句来匹配每一个单独的枚举值 1234567891011121314let directionToHead = ComP.southswitch directionToHead &#123;case .east: print(&quot;east&quot;)case .south: print(&quot;south&quot;)case .west: print(&quot;west&quot;)case .north: print(&quot;north&quot;)&#125;======south 遍历枚举的 case 枚举也可以被遍历，需要遵守 CaseIterable 协议来 允许枚举被遍历，写法：在枚举名后面写 :CaseIterable 12345678910111213141516// 遍历枚举enum ComP : CaseIterable&#123; case east case south case west case north&#125;for direction in ComP.allCases &#123; print(direction)&#125;=========eastsouthwestnorth 或者 12345678// 遍历枚举enum ComP2 : CaseIterable&#123; case east, south, west, north&#125;print(ComP2.allCases)=========[__lldb_expr_75.ComP2.east, __lldb_expr_75.ComP2.south, __lldb_expr_75.ComP2.west, __lldb_expr_75.ComP2.north] 关联值 可以定义swift枚举来存储任意给定类型的关联值，如果需要的话不同枚举成员关联值的类型可以不同 12345678910111213// 关联值enum Barcde &#123; case upc(Int,Int,Int,Int) // 元组 case qrCode(String) // 元组&#125;var productBarcode = Barcde.upc(5,111,33,245)print(productBarcode)productBarcode = .qrCode(&quot;aaaaaddddd&quot;)print(productBarcode)==============upc(5, 111, 33, 245)qrCode(&quot;aaaaaddddd&quot;) 关联值绑定12345678910// 关联值绑定switch productBarcode &#123;case .upc(let a,let b,let c,let d): print(&quot;UPC: \\(a) \\(b) \\(c) \\(d)&quot;)case .qrCode(let codeString): print(&quot;QR Code: \\(codeString)&quot;)&#125;=========QR Code: aaaaaddddd 原始值 枚举成员可以用相同类型的默认值预先填充（称为原始值） 12345678// 原始值enum carS: Character &#123; case tab = &quot;\\t&quot; case lineFeed = &quot;\\n&quot; case carrReturn = &quot;\\r&quot;&#125;let car = carS.tabprint(car.rawValue) 预设原始值 当你操作存储整数或字符串原始值枚举的时候，你不必显示地给每一个成员都分配一个原始值。当你没有分配时，swift将自动为你分配值 12345678// 预设原始值enum ComP: Int &#123; case ease = 4,south,west,north&#125;print(ComP.south.rawValue)========5 从原始值初始化 当你用原始值定义了一个枚举，那么枚举就会自动收到一个可以接受原始值类型的初始化器（叫做 rawValue 的形式参数）然后返回一个枚举成员或者 nil。你可以用这个初始化器来尝试创建一个枚举的 新实例 1234567891011// 初始化器enum ComP: Int &#123; case ease = 4,south,west,north&#125;let direction = ComP(rawValue: 6)print(direction)let direction2 = ComP(rawValue: 8)print(direction2)========Optional(__lldb_expr_82.ComP.west)nil 递归枚举 递归枚举是拥有另一个枚举作为枚举成员关联值的枚举。当编译器操作递归枚举时必须插入 简介寻址层。你可以在声明枚举成员之前使用 indrect 关键字来明确它是递归的 如果说表达式 (5+4)*2 在乘法右侧有一个数但有其他表达式在乘法的左侧 123456789101112131415// 递归枚举indirect enum ArExp &#123; case number(Int) case add(ArExp,ArExp) case mutiply(ArExp,ArExp)&#125;let firstExp = ArExp.number(5)let secondExp = ArExp.number(4)let addExp = ArExp.add(firstExp,secondExp)let thirdExp = ArExp.number(2)let mutipExp = ArExp.mutiply(addExp,thirdExp)print(mutipExp)=========mutiply(__lldb_expr_89.ArExp.add(__lldb_expr_89.ArExp.number(5), __lldb_expr_89.ArExp.number(4)), __lldb_expr_89.ArExp.number(2)) 我们可以写一个函数来执行这个表达式 1234567891011121314func eval(_ exp: ArExp) -&gt; Int &#123; switch exp &#123; case .number(let value): return value case .add(let first,let second): return eval(first) + eval(second) case .mutiply(let first,let second): return eval(first) * eval(second) &#125;&#125;print(eval(mutipExp))=========18","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习35：如何使用swift中的高阶函数","slug":"Swift学习/Swift学习35：如何使用swift中的高阶函数","date":"2023-03-05T06:57:55.000Z","updated":"2023-03-05T07:27:45.406Z","comments":true,"path":"2023/03/05/Swift学习/Swift学习35：如何使用swift中的高阶函数/","link":"","permalink":"https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A035%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8swift%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","excerpt":"","text":"map 对于演示集合里的每一个元素，以一个 变换后的元素替换它，形成一个新的集合 示例： 123456// map：尾随闭包的形式输出let nums = [1,2,3,4,5]print(nums.map &#123; $0 * 10 &#125;)========[10, 20, 30, 40, 50] filter 对于原始集合里的每一个元素，通过判定来将其丢弃或者放进新集合 示例： 123456// filter：尾随闭包的形式输出let nums = [1,2,3,4,5]print(nums.filter &#123; $0 &gt; 3 &#125;)========[4, 5] reduce 对于原始集合里的每一个元素，作用于当前累计的结果上 示例： 123456// reduce：尾随闭包的形式输出let nums = [1,2]print(nums.reduce(10, &#123; $0 + $1 &#125;))=======13 flatMap 对于元素是集合的集合，可以得到单级的集合 123456789let results = [[1,2,3],[4,5,6]];let allResults = results.flatMap&#123; $0.map &#123; $0 &#125; &#125;let passMarks = results.flatMap&#123; $0.filter &#123; $0 &gt; 5 &#125; &#125;print(allResults)print(passMarks)===========[1, 2, 3, 4, 5, 6][6] compactMap 过滤空值 12345678910111213// compactMaplet keys: [String?] = [&quot;a&quot;,nil,&quot;b&quot;]let key = keys.map&#123; $0 &#125;print(key)let validNames = keys.compactMap&#123; $0 &#125;print(validNames)let counts = keys.compactMap&#123; $0?.count &#125;print(counts)==========[Optional(&quot;a&quot;), nil, Optional(&quot;b&quot;)][&quot;a&quot;, &quot;b&quot;][1, 1]","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"OC组件化06：Github-Desktop管理工具使用","slug":"OC组件化/OC组件化06：Github-Desktop管理工具使用","date":"2023-03-04T15:47:00.000Z","updated":"2023-03-04T15:55:05.157Z","comments":true,"path":"2023/03/04/OC组件化/OC组件化06：Github-Desktop管理工具使用/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9606%EF%BC%9AGithub-Desktop%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言GitHub Desktop 简单说就是 图形界面 版的 Git，不需要命令行的操作 通过 GitHub官网 可以下载、安装使用 准备工作 注册你的 GitHub 账号，已注册 GitHub 账号的，跳过 在 GitHub Desktop 登录你的账号 创建仓库：File -&gt; new repository 创建分支：branch -&gt; new branch 创建一个开发的分支 zj_feature 克隆仓库到 GitHub Desktop File -&gt; Clone Repository 切换分支 修改工程代码，将 0.2.0 版本代码完成，并提交到新分支 zj_feature Summary：必填 0.2.0 Description：描述 0.2.0 版本的内容 Commit to zj_feature push origin 合并分支： 先切换到 main 主分支 合并分支：branch菜单 -&gt; merge into current branch 提交 main 分支 删除分支：菜单branch -&gt; delete 删除分支 版本回滚 还未提交代码：文件右键 -&gt; Discard Changes 放弃更改 已经提交代码：文件右键选择 -&gt; Revert This Commit 恢复到当前提交 使用 打开项目代码：Show in Finder 所有 新增代码 可以在工程项目中实时修改，并可以运行查看效果 在 GitHub Desktop 上可以看到实时的修改 修改完记得修改一下版本号 提交代码到 本地mian 分支 提交代码到 远程main 分支 终端搜索 ZJWeakProxy 库mac@bogon ~ % pod search ZJWeakProxy 【问题：】未搜索到自己创建的组件库 解决方法：更新本地Pod的索引文件 12mac@bogon ~ % rm ~/Library/Caches/CocoaPods/search_index.jsonmac@bogon ~ % pod repo update 如果还是搜索不到： 12mac@bogon ~ % sudo gem install -n /usr/local/bin cocoapods --pre mac@bogon ~ % pod setup 再次搜索","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"OC组件化05：【方案二】cocoapods组件化","slug":"OC组件化/OC组件化05：【方案二】cocoapods组件化","date":"2023-03-04T15:30:55.000Z","updated":"2023-03-04T15:45:45.042Z","comments":true,"path":"2023/03/04/OC组件化/OC组件化05：【方案二】cocoapods组件化/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9605%EF%BC%9A%E3%80%90%E6%96%B9%E6%A1%88%E4%BA%8C%E3%80%91cocoapods%E7%BB%84%E4%BB%B6%E5%8C%96/","excerpt":"","text":"背景 随着公司业务的不断发展，应用的代码体积将会越来越大，业务代码耦合也越来越多，代码量也是急剧增加 如果仅仅完成代码拆分还不足以解决业务之间的代码耦合，而组件化是一种能够解决代码耦合、业务工程能够独立运行的技术 这篇文章主要介绍远程私有库的创建和管理以及本地索引库的使用 本文以创建 公有库 为例 查看本地索引库 我们用 cocoaPods 的时候，默认使用的是cocoaPods自带的索引库终端中使用命令 $ pod repo 1234567891011cocoapods- Type: git (remotes/origin/master)- URL: https://github.com/CocoaPods/Specs.git- Path: /Users/mac/.cocoapods/repos/cocoapodstrunk- Type: CDN- URL: https://cdn.cocoapods.org/- Path: /Users/mac/.cocoapods/repos/trunk2 repos 组件化分类 公有库：所有人都能使用 私有库：公司内部拥有特殊权限才能使用 framework：公私都有，动态库静态库。只能看到.h文件。 准备工作 GitHub 账号一个：上传组件工程用 安装 CocoaPods：创建并验证 pod 用 安装 Git 命令行 ：首次上传组件工程用 安装 Github Desktop 或者 SourceTree：后续更新组件用的，Git命令使用熟练者忽略此项 创建公有库 首先在 Github 创建一个新的 Repository，你的 pods 最终要托管在 Github 平台上的，所以在 Github 上创建一个空的 Repository 注意：库名 = 项目前缀 + 组件名称 ，如 ZJWeakProxy &#x3D; 解决循环引用组件库 创建完成后的信息如下： 注册 cocoapods 账户 先安装 cocoapods，这个很简单，可以百度搜索自行安装 想要创建一个开源 pod 库，首先我们需要注册 cocoapods账户，基于 cocoapods 已经安装好的前提下，这里直接使用 trunk 去注册 cocopods账户，在终端执行： 12pod trunk register 邮箱地址 &#x27;用户名&#x27; --verbosemac@bogon ~ % pod trunk register 13718004742@163.com &#x27;BboyZJ&#x27; --verbose 邮箱地址：一般会使用 GitHub邮箱用户名：随便 注册之后，在邮箱会受到确认邮件 注册成功之后可以在终端 验证是否注册成功： 123// 验证是否注册成功mac@bogon ~ % pod trunk me 查看注册信息，以后可以使用该开源pod库发布工具，也可以通过此方式查看已经发布过的pods： 123456789101112mac@bogon ~ % pod trunk me - Name: BboyZJ - Email: 13718004742@163.com - Since: October 20th, 2021 19:20 - Pods: - ZJSDKDemo - ZJSDK_iOS - Sessions: - October 20th, 2021 19:20 - March 31st, 2022 04:01. IP: 114.253.15.66 Description: imac - February 27th, 02:33 - July 5th, 02:37. IP: 114.252.233.188 在本地创建pod库 利用pod命令创建名为 ZJWeakProxy 的 pod 库 注：这个名字要和 GitHub 创建的 Repository 名一致 1234# cd 到桌面文件夹(组件文件夹)ZJComponent目录下，这个不强制随意mac@bogon ~ % cd ZJComponent # 执行 pod lib create ZJWeakProxymac@bogon ~ % pod lib create ZJWeakProxy 出现 fatal: unable to access ‘https://github.com/CocoaPods/pod-template.git/ ‘: HTTP&#x2F;2 stream 1 was not closed cleanly before end of the underlying stream 报错 原因分析：一般这是因为服务器的 SSL 证书没有经过第三方机构的签署，所以才报错 解决办法：解除 SSL 验证，再次执行 1mac@bogon ZJComponent % git config --global http.sslVerify false 执行完上述命令后，会问你几个问题，按需求填写即可 123456789101112131415161718# 你想使用哪个平台？1、What platform do you want to use?? [ iOS / macOS ]iOS# 库语言选择？2、What language do you want to use?? [ Swift / ObjC ]ObjC# 是否需要一个demo工程，用于调试Pod？3、Would you like include a demo application with your library? [ Yes / No ]Yes# 你要使用哪个测试框架？4、Which testing frameworks will you use? [ Specta / Kiwi / None ]None# 是否要UI测试？5、Would you like to do view based testing? [ Yes / No ]NO# 类名前缀？6、What is your class prefix?ZJ 到这里 pod 库就创建完成了，它会自己打开刚才创建的pod库 工程目录介绍 目录结构如下： 【第1部分】：主要是用来编辑pod相关配置元数据区【第2部分】：主要是用来验证pod效果区【第3部分】：主要是用来 提供给别人使用暴露出来的pod，ReplaceMe空的可以删除，是提示我们可以添加自己的类 配置 podspec 本地索引文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445Pod::Spec.new do |s| # 库名称 s.name = &#x27;ZJWeakProxy&#x27; # 版本号 s.version = &#x27;0.1.0&#x27; # 库简短介绍 s.summary = &#x27;A short description of ZJWeakProxy.&#x27;# This description is used to generate tags and improve search results.# * Think: What does it do? Why did you write it? What is the focus?# * Try to keep it short, snappy and to the point.# * Write the description between the DESC delimiters below.# * Finally, don&#x27;t worry about the indent, CocoaPods strips it! # 开源库描述 s.description = &lt;&lt;-DESCTODO: Add long description of the pod here. DESC # 开源库地址，或者是博客、社交地址等 s.homepage = &#x27;https://github.com/BboyZJ/ZJWeakProxy&#x27; # s.screenshots = &#x27;www.example.com/screenshots_1&#x27;, &#x27;www.example.com/screenshots_2&#x27; # 开源协议 s.license = &#123; :type =&gt; &#x27;MIT&#x27;, :file =&gt; &#x27;LICENSE&#x27; &#125; # 开源库作者 s.author = &#123; &#x27;BboyZJ&#x27; =&gt; &#x27;13718004742@163.com&#x27; &#125; # 开源库资源文件 s.source = &#123; :git =&gt; &#x27;https://github.com/BBoyZJ/ZJWeakProxy.git&#x27;, :tag =&gt; s.version.to_s &#125; # 社交网址 # s.social_media_url = &#x27;https://twitter.com/&lt;TWITTER_USERNAME&gt;&#x27; # 开源库最低支持 s.ios.deployment_target = &#x27;10.0&#x27; # 开源库源文件 s.source_files = &#x27;ZJWeakProxy/Classes/**/*&#x27; # 添加图片等资源文件 # s.resource_bundles = &#123; # &#x27;ZJWeakProxy&#x27; =&gt; [&#x27;ZJWeakProxy/Assets/*.png&#x27;] # &#125; # s.public_header_files = &#x27;Pod/Classes/**/*.h&#x27; # 依赖系统库 多个用逗号隔开 # s.frameworks = &#x27;UIKit&#x27;, &#x27;MapKit&#x27; # 引入第三方依赖库 # s.dependency &#x27;AFNetworking&#x27;, &#x27;~&gt; 2.3&#x27;end 【s.dependency】：设置依赖三方库或其他组件，多个库可以分开写多次 需要注意如图： Readme 主要是介绍这个组件的用途和使用，可以随时编辑。目前就确认一下自己的名字和邮箱就可以了 协议文件，也是确认一下自己的名字和邮箱就可以了 添加自己的类 打开pod库目录，删除ReplaceMe 创建 ZJWeakProxy 简单类，声明一个打印函数，方便后续测试 注：创建类文件一定要放到 Classes 目录下 .h 文件下 12345#import &quot;ZJWeakProxy.h&quot;@interface ZJWeakProxy : NSProxy- (void)printZJWeakProxy;@end .m 文件下 1234567#import &quot;ZJWeakProxy.h&quot;@implementation ZJWeakProxy- (void)printZJWeakProxy&#123; NSLog(@&quot;%s&quot;,__func__);&#125;@end 此时 cd 到 Example 路径下执行 pod install 命令，看看是否能将刚刚添加的库文件引入到工程中 12mac@bogon ~ % cd /Users/mac/Desktop/ZJComponent/ZJWeakProxy/Example mac@bogon Example % pod install 如果成功会在Pods中看到： 可以到项目中导入头文件简单使用一下 证明是可用的 【注】：CocoaPods 工具的另外一个优点就是，多个组件依赖同一个组件时，它会自动帮你检测安装，而 不会重复导入。 项目上传与发布 cd到你的项目路径下，将项目上传到GitHub中（即刚刚创建的ZJWeakProxy公有库中），依次使用下列命令行，不要遗漏 123456789101112# cd 到 组件ZJWeakProxy路径下mac@bogon Example % cd /Users/mac/Desktop/ZJComponent/ZJWeakProxy# 添加github项目路径mac@bogon ZJWeakProxy % git remote add origin https://github.com/BboyZ/ZJWeakProxy.git# 添加文件mac@bogon ZJWeakProxy % git add .# 将暂存区里的改动提交到本地的版本库mac@bogon ZJWeakProxy % git commit -m &quot;first commit&quot;# 创建分支mainmac@bogon ZJWeakProxy % git branch -M main# 提交版本号并push到main分支mac@bogon ZJWeakProxy % git push -u origin main 在执行 git push -u origin main 时，如果遇到需要输入用户名和密码： 12Username for &#x27;https://github.com&#x27;: BboyZJPassword for &#x27;https://BboyZJ@github.com&#x27;: 【注意】：这个 密码 不是你 GitHub 的登录密码，而是需要生成一个 access tokens 生成 access token 需要在 GitHub 个人设置页 -&gt; Settings -&gt; Developer Settings -&gt; Personal access tokens 中创建一个 token Generate new token 生成新的 token 设置 token 的有效期 按需设置，访问权限等 选择要授予令牌token的范围或权限 要使用token从命令行访问仓库，请选择repo 要使用token从命令行删除仓库，请选择delete_repo 其他根据需要进行勾选 点击 Generate token 生成 token ghp_VcqgAmF...ZPJ2IGxu0 【注】：记得把这个 token 保存下来，因为下次再刷新这个页面的时候，你会看不到了 在命令行输入完 token 密码 123456789101112Username for &#x27;https://github.com&#x27;: BboyZJPassword for &#x27;https://BboyZJ@github.com&#x27;: Enumerating objects: 91, done.Counting objects: 100% (91/91), done.Delta compression using up to 4 threadsCompressing objects: 100% (83/83), done.Writing objects: 100% (91/91), 29.35 KiB | 2.45 MiB/s, done.Total 91 (delta 23), reused 0 (delta 0), pack-reused 0remote: Resolving deltas: 100% (23/23), done.To https://github.com/BboyZJ/ZJWeakProxy.git * [new branch] main -&gt; mainbranch &#x27;main&#x27; set up to track &#x27;origin/main&#x27;. 由上面看代表上传成功了 打开浏览器 https://github.com/BboyZJ/ZJWeakProxy ，就可以看到你的pod库已经push上去了 打 tag 并发布到 Cocoapods至此，我们已经成功将本地的仓库关联并推送到远程仓库，现在我们需要发布一个可用的组件 首先我们要给当前项目打一个 tag 版本号，在 podspec 中： 1s.version = &#x27;0.1.0&#x27; 指定的版本号是 0.1.0 ，那么我们就同样打个 0.1.0 的 tag 1234// 打 tag mac@bogon ZJWeakProxy % git tag 0.1.0// 推送到远程mac@bogon ZJWeakProxy % git push --tags 打 tag 默认在当前分支上，这里只有 master ，所以不用切换分支 发布到 cocoapods 我们创建的项目以及标签版本号都是沿用了 podspec 文件中的信息，因此可以直接验证 podspec 文件信息是否可以通过验证，podspec 文件的版本号一定要和 tag 保持一致 1mac@bogon ZJWeakProxy % pod spec link 如果通过验证，那么你会看到类似下面的提示，绿色的 passed validation 首先要通过 trunk 注册生成一条会话： 12// pod trunk register 邮箱 用户名 描述mac@bogon ZJWeakProxy % pod trunk register 13718004742@163.com BboyZJ --description=ZJWeakProxy组件 然后去邮箱进行验证，验证成功会出现下面页面： 现在，就可以将 podspec 提交给 CocoaPods 了。这个文件将是别人搜索你的组件的索引。 1mac@bogon ZJWeakProxy % pod trunk push ZJWeakProxy.podspec --allow-warnings pod search 组件名 上传完成之后，接可以通过 pod search ZJWeakProxy 搜索到自己的组件了，如果搜索不到，删除本地的搜索文件，命令 ： 1mac@bogon ZJWeakProxy % rm ~/Library/Caches/CocoaPods/search_index.json 重新 search 产生新的搜索文件，发布新版本则需要打新的 tag，重新编辑 podspec 文件，然后再次提交给 CocoaPods。 集成到宿主工程经过上面的操作我们已经完成了组件的创建和发布，也支持了 Cocoapods 的集成。现在我们需要将该组件集成到宿主工程中去，使用方式和集成三方库是一样的。 新建个带 pod 的项目 Demo，把我们做好的 ZJWeakProxy 加入 podfile 文件 12345678910111213# Uncomment the next line to define a global platform for your projectplatform :ios, &#x27;10.0&#x27;target &#x27;ZJWeakProxy-Demo&#x27; do # Comment the next line if you don&#x27;t want to use dynamic frameworks use_frameworks! # ZJWeakProxy pod &#x27;ZJWeakProxy&#x27;,:git =&gt;&quot;https://github.com/BboyZJ/ZJWeakProxy.git&quot; # Pods for ZJWeakProxy-Demoend 执行 pod install mac@bogon ZJWeakProxy-Demo % pod install 【问题1】安装报错：[!] Unable to find a specification for ZJWeakProxy 解决办法： mac@bogon ZJWeakProxy-Demo % pod repo update --verbose 【问题2】：HTTP&#x2F;2 stream 1 was not closed cleanly before end of the underlying stream 解决办法：更改默认通信协议 mac@bogon ZJWeakProxy-Demo % git config --global http.version HTTP/1.1 引入头文件并打印结果 版本更新与维护 现在的 ZJWeakProxy 库已经在GitHub上托管了，以后维护这个项目就可以了（开始本地创建的ZJWeakProxy项目就可以删除了），管理GitHub仓库，有两种方案： 可以使用命令行 git clone https://github.com/BboyZJ/ZJWeakProxy 也可以使用 GitHub Desktop 下载 GitHub Desktop 登录你的用户名和密码，File -&gt; Responsitory 其实 GitHub Desktop 更加可视化一些，上面History就是刚才git命令行的记录 总结终于写完了，哇哦😮！","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"OC组件化04：【方案一】本地组件化","slug":"OC组件化/OC组件化04：【方案一】本地组件化","date":"2023-03-04T15:27:35.000Z","updated":"2023-03-04T15:31:43.723Z","comments":true,"path":"2023/03/04/OC组件化/OC组件化04：【方案一】本地组件化/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9604%EF%BC%9A%E3%80%90%E6%96%B9%E6%A1%88%E4%B8%80%E3%80%91%E6%9C%AC%E5%9C%B0%E7%BB%84%E4%BB%B6%E5%8C%96/","excerpt":"","text":"前言 本地组件化：主要是通过在 工程中创建library，利用 cocoapods 的 workspec 进行本地管理，不需要将项目上传git，而是直接在本项目中以 framework 的方法进行调用 创建主工程 首先创建一个名为 Modularization 的工程 集成 cocoapods，进行本地管理 1234zhangjian@zhangjiandeMBP ~ % cd /Users/zhangjian/Desktop/Modularization zhangjian@zhangjiandeMBP Modularization % pod initIgnoring ffi-1.13.1 because its extensions are not built. Try: gem pristine ffi --version 1.13.1zhangjian@zhangjiandeMBP Modularization % pod install 创建组件假设有以下几个模块 主工程：承载主要的表层业务代码 Core：独立存在，应用加密、接口请求等敏感代码 Base：基类封装，拓展，基本的数据处理 Service：服务层，封装业务工具类，例如网络层服务、持久化服务等 Pods：三方依赖 其中，各个模块间的关系如下图 下面，我们来进行模块的创建，以 Core 模块为例： 选择 File -&gt; new -&gt; project -&gt; iOS -&gt; Framework，新建一个 ZJCore 模块 选择正确的 Group 和 WorkSpace（这里注意：创建的 library 最好放在 主工程根目录下，否则后续的 podfile 执行 pod install 会报错） 创建成功后，看到的结果如下： 将创建的 library 的 Build Settings -&gt; Mach-O Type 修改为静态库 Static Library 主工程调用Library 在 ZJCore 中新建一个文件，并添加如下代码 1234567@interface ZJCoreSetting : NSObject// 声明属性@property (nonatomic,copy)NSString * name;@end@implementation ZJCoreSetting@end 在 Build Phases -&gt; Headers -&gt; Public 中将新建的文件拖拽到 Puclic 中，这样主工程才能访问该文件 在ZJCore文件中添加引用 在主工程中，选择 target -&gt; Frameworks,Libraries,and Embedded Content -&gt; + 号 -&gt; 添加 ZJCore，只需要build主工程，library能够自动联编 使用首先 #import &lt;ZJCore/ZJCoreSetting.h&gt;，然后使用 这里需要注意的是，子library之间的互相调用，与主工程调用library类似，主需要添加依赖、暴露header即可","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"OC组件化03：面向协议Protocol Class的使用","slug":"OC组件化/OC组件化03：面向协议Protocol-Class的使用","date":"2023-03-04T08:16:42.000Z","updated":"2023-03-04T14:56:27.815Z","comments":true,"path":"2023/03/04/OC组件化/OC组件化03：面向协议Protocol-Class的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AEProtocol-Class%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"面向协议 Protocol Class 在 URL Scheme路由 和 target-action 方案中，都存在 硬编码、参数不明确问题：URL 、Target_ 、 Action_ 的硬编码，参数都是通过字典的形式传递，类型不明确。 面向接口 的方式能够很好的解决这两个问题。 实现方式 中间件先注册 Protocol 和 Class 对应关系，将 protocol 和 对应的类 进行 字典 匹配 中间件返回 Protocol 对应的 Class，然后动态创建实例 优点 面向协议编程 安全性高 模块解耦 缺点 无法多端通用 需要进行协议的注册 示例 创建 ZJProtocol.h 协议类文件 12345678910// 将各个模块的协议统一放在一个文件中 ，在各个模块中依赖这个文件，实现其协议@protocol OneMoudleProtocol &lt;NSObject&gt;@required // 返回模块one+ (UIViewController *)oneMoudleVC;@end@protocol OneDetailMoudleProtocol &lt;NSObject&gt;@required+ (UIViewController *)oneDetailMoudleVCWithParas:(NSDictionary *)paras;@end 创建 ZJMediator 协议管理类 ZJMediator.h 文件下： 12345678@interface ZJMediator : NSObject// 单例+ (instancetype)shareManager;// 注册绑定- (void)registerProtocol:(Protocol *)protocol class:(Class)cls;// 获取类- (Class)classFromProtocol:(Protocol *)protocol;@end ZJMediator.m 文件下： 1234567891011121314151617181920212223242526272829303132#import &quot;ZJMediator.h&quot;@interface ZJMediator ()@property (nonatomic,strong)NSMutableDictionary * protocolCache;@end@implementation ZJMediator+ (instancetype)shareManager&#123; static ZJMediator * mediator; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; mediator = [[ZJMediator alloc] init]; &#125;); return mediator;&#125;// 注册绑定- (void)registerProtocol:(Protocol *)protocol class:(Class)cls&#123; if (protocol &amp;&amp; cls) &#123; [self.protocolCache setObject:cls forKey:NSStringFromProtocol(protocol)]; &#125;&#125;// 获取类- (Class)classFromProtocol:(Protocol *)protocol&#123; return [self.protocolCache objectForKey:NSStringFromProtocol(protocol)];&#125;// 懒加载- (NSMutableDictionary *)protocolCache&#123; if (!_protocolCache) &#123; _protocolCache = @&#123;&#125;.mutableCopy; &#125; return _protocolCache;&#125;@end 创建 OneDetailMoudleEntry 模块 123456789101112131415161718#import &quot;OneDetailMoudleEntry.h&quot;#import &quot;ZJOneDetailViewController.h&quot;@interface OneDetailMoudleEntry ()&lt;OneDetailMoudleProtocol&gt;@end@implementation OneDetailMoudleEntry+ (void)load&#123; [[ZJMediator shareManager] registerProtocol:@protocol(OneDetailMoudleProtocol) class:[self class]];&#125;// 继承+ (UIViewController *)WithParas:(NSDictionary *)paras&#123; ZJOneDetailViewController * detailVC = [[ZJOneDetailViewController alloc] init]; detailVC.name = paras[@&quot;name&quot;]; detailVC.age = params[@&quot;age&quot;]; return detailVC;&#125;@end 在任何地方调用 1234567//下一页的点击事件- (void)next:(UIButton *)sender&#123; Class cls = [[ZJMediator shareManager] classFromProtocol:@protocol(OneDetailMoudleProtocol)]; UIViewController * detailVC = [cls oneDetailMoudleVCWithParas:@&#123;@&quot;name&quot;:@&quot;ZJ&quot;,@&quot;age&quot;:30&#125;]; [self.navigationController pushViewController:detailVC animated:YES];&#125;","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"OC组件化03：基于RuntTime的target-action的使用","slug":"OC组件化/OC组件化03：基于RuntTime的target-action的使用","date":"2023-03-04T08:16:13.000Z","updated":"2023-03-04T15:12:11.241Z","comments":true,"path":"2023/03/04/OC组件化/OC组件化03：基于RuntTime的target-action的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E5%9F%BA%E4%BA%8ERuntTime%E7%9A%84target-action%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言target action 是利用 Runtime 的 performSelector:withObject: 方法调用，无需注册 优缺 优点：无需注册路由，避免了load里注册影响启动速度 不用维护全局路由表，避免了查找对应路由 统一了路由入口 进行了一定的安全处理 缺点 缺点：不能多端使用同一套路由H5，Android 增加了文件，同时在获取target，sel时存在一定的硬编码 示例：","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"OC组件化02：基于URL Scheme的使用","slug":"OC组件化/OC组件化02：基于URL-Scheme的使用","date":"2023-03-04T08:15:30.000Z","updated":"2023-03-04T15:02:44.049Z","comments":true,"path":"2023/03/04/OC组件化/OC组件化02：基于URL-Scheme的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9602%EF%BC%9A%E5%9F%BA%E4%BA%8EURL-Scheme%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"URL Scheme 路由 使 URL Scheme 处理本地的跳转 通过中间层进行注册 &amp; 调用（load方法里面把被调用者注册到中间层） 命名规范12//协议://主机名[:端口]/路径/[?参数]#fragment@&quot;lstest://lsapp:11111/china/ls.com?a=1&amp;b=2&quot; lstest：协议名 lsapp：主机名，为了区分 不同的app 端口号：可以将端口号作为 模块ID china&#x2F;ls.com：路径，可以是跳转到模块的 指定页面 a&#x3D;1&amp;b&#x3D;2：参数，跳转的参数 解析 优缺点 优点：实现简单 缺点：存在硬编码问题，参数都是通过字典的形式传递，类型不明确 URL Scheme 路由示例思路：B组件使用URL将Block注册给路由，路由以URL为key，将Block存储起来。 A组件通过URL调用路由的方法，找到对应的Block，完成对A的调用 创建路由 123456789101112131415161718192021222324252627282930313233#import &quot;ZJRouter.h&quot;@interface ZJRouter ()@property (strong,nonatomic)NSMutableDictionary * blockDic;@end@implementation ZJRouter// 参数 @&#123;@&quot;&quot;:...&#125;+ (instancetype)shareInstance&#123; static ZJRouter * router = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; router = [[self alloc] init]; router.blockDic = @&#123;&#125;.mutableCopy; &#125;); return router;&#125;// 注册- (void)registerUrl:(NSString *)url block:(ZJRouterBlock)block&#123; if (!url || !block) return; if (block) &#123; self.blockDic[url] = [block copy]; &#125;&#125;// 执行- (void)excuteBlockWithUrl:(NSString *)key params:(NSDictionary *)params&#123; if (!key) return; ZJRouterBlock block = self.blockDic[key]; if (!block) return; block(params);&#125;@end B 组件中注册 12345+ (void)load &#123; [[ZJRouter shareInstance] registerUrl:@&quot;A:aTestAction&quot; block:^(NSDictionary * _Nonnull dic) &#123; NSLog(@&quot;dic:%@&quot;,dic); &#125;];&#125; A 组件中调用 1[[ZJRouter shareInstance] excuteBlockWithUrl:@&quot;A:aTestAction&quot; params:@&#123;@&quot;text&quot;:@&quot;文字&quot;&#125;];","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"OC组件化01：组件化介绍","slug":"OC组件化/OC组件化01：组件化介绍","date":"2023-03-04T06:05:40.000Z","updated":"2023-03-04T15:26:25.315Z","comments":true,"path":"2023/03/04/OC组件化/OC组件化01：组件化介绍/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9601%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"什么组件化 组件化其实就是 将模块单独抽离、分层，并指定模块间的 通讯 方式，从而实现 解耦 的一种方式，主要运用与团队开发 组件化开发就是将一个臃肿的、单一的项目，根据 功能/业务/技术 等进行拆分，形成一个个独立的功能组件，然后借助 Cocoapods 管理工具将其任意组合，集成一个完整的项目。 你可以将 AFNetworking、SDWebImage、Bugly、MLeaksFinder 等三方库理解为工程的一部分，属于 基础组件模块，我们要做的就是将项目划分多个独立功能模块，再集成一个完整的项目。 为什么要组件化？主要有以下四个原因 模块间解耦 模块重用 提高团队协作开发效率 单元测试 当项目因为各种需求，模块越来越多时，如果此时的各个模块之间是互相调用的，即 你中有我，我中有你 这种情况时，会造成 高耦合 的情况，一旦我们需要对某一模块代码进行 修改 时，就会 牵一发而动全身，导致项目难以维护 其问题主要体现在以下几个方面： 修改某个功能时，同时需要修改其他模块的代码，因为在其他模块中有该模块的引用，可以理解为 高耦合导致代码修改困难 模块对外接口不明确，甚至暴露了本不该暴露的私有接口，修改时费时费力。可以理解为 接口不固定导致的接口混乱 高耦合代码产生的后果就是会影响团队其他成员的开发，产生 代码冲突 当模块需要重用到其他项目时，难以单独抽离 模块间耦合的忌口导致接口和依赖关系混乱，无法进行单元测试 所以为了解决以上问题，我们需要采用更规范的方式来 降低模块 间的 耦合度，这就是 组件化，也可以理解为 模块化 但是，这里还需要说明一点，因为组件化也是需要一定成本的，需要花费时间设计接口、分离代码等，所以并不是所有的项目都需要组件化。如果你的项目有以下这些特征就 不需要组件化： 项目较小，模块间交互简单，耦合少 项目没有被多个外部模块引用，只是一个单独的小模块 模块不需要重用，代码也很少被修改 团队规模很小 不需要编写单元测试 如果你的有以下特性，说明你就必须要 考虑进行组件化 了： 模块逻辑复杂，多个模块之间频繁互相引用 项目规模逐渐变大，修改代码变的越来越困难（这里可以理解为：修改一处代码，需要同时修改其他多个地方） 团队人数变多，提交代码经常和其他成员冲突 项目编译耗时较大 模块的单元测试经常由于其他模块的修改而失败 组件化方案组件化方案的8条指标： 一个项目经过组件化后如何来评判，主要有以下几个 标准： 模块之间没有耦合，模块内部的修改不会影响其他模块 模块可以单独编译 模块间数据传递明确 模块对外接口清晰且易维护 当模块接口改变时，此模块的外部代码能够被高效重构 尽量用最少的修改和代码，让现有项目实现模块化 支持OC和Swift，以及混编 前4条主要用于 衡量一个模块是否真正解耦，后4条主要用于衡量在项目中 实践中的易用程序 组件化原则 一个项目主要分为3层：业务层、通用层 以及 基础层，在进行组件化时，有以下几点说明 只能上层对下层依赖，不能下层对上层依赖，因为下层是对上层的抽象 项目公共代码资源下沉 横向的依赖尽量减少，最好下层至通用模块，或者基础模块 组件化和非组件化区别组件化能够帮助我们将大部分项目拆解成数个小组件，开发者只需要关注组件所依赖的其他组件，而无需关心完整项目的其他部分，每个组件可以自己采取所习惯的架构模式：MVC、MVVM等，就行开发一款个人独立的App那样自由 非组件化： 代码高耦合度、高依赖 项目复杂、臃肿、编译时间过长（影响调试） 难以融合、集成其他产品 … 组件化： 代码复用性提高，可方便集成到其他项目 项目可配置，方便集成和功能回退 方便组件并行开发 可方便单元测试 … 组件化分层项目组件化，最难的就是 粒度 问题，需要开发者根据自己的经验把控。这里给出个人认为的层次划分： 【基础组件】：宏定义&#x2F;常量&#x2F;自定义工具类，如常用的自定义分类【功能组件】：项目中常用的功能，如地图&#x2F;消息推送&#x2F;分享&#x2F;登录等【业务组件】：项目中的模块&#x2F;业务，如文章详情&#x2F;个人中心等【中间组件】：负责项目中的路由&#x2F;消息通知&#x2F;传参&#x2F;回调等【宿主工程】：项目容器，用来集成组件，调整各个组件之间的消息传递容器 中间层几种方案在组件化中，中间层是各个组件的通信桥梁，中间层在组件化过程中扮演着非常重要的角色。 中间层的三种方式： 基于 URL Scheme 的 路由 基于 Runtime 的 target-action 面向接口 的 Protocol - Class 基于 URL Scheme 的三方库iOS 中支持的 URL Scheme 让我们能够在 应用之间、应用内部传递消息。 JLRoutes routable-ios HHRouter 具体怎么使用，可以自行去探索 基于 Runtime 的 target-action相比 url scheme 的提前注册、实现服务，CTMediator 借助 OC 运行时的特性，现实组件之间服务的自动发现，无需提前注册即可实现组件间的调用，因此，这种方案的可维护性、可读性、扩展性相对较高。 CTMediator 面向接口 Protocol - Class Protocol - Class 面向接口的方案通常由两部分组成，一个是用来管理接口协议的类（ProtocolManager），一个是具体的接口协议（ComponentProtocol） 组件化的核心工具 组件化工程，需要一个宿主工程，负责集成所有的组件。每个组件都是一个单独的工程，通过 Git 私有仓库来管理。 所有组件都上传到 Git 仓库并支持 cocoapods 集成。主工程通过配置 Podfile 文件，然后一键 pod update 即可。使用 Cocoapods 来管理组件主要因为其本身功能强大，方便的集成整个项目，解放对依赖库的管理。使用组件化的集成方式，可以很好的避免传统项目中的代码冲突问题。 组件化的核心工具就是 CocoaPods ，我们要做的就是将组件项目上传到 Gitee码云 或者 Gitlab极狐，编写项目的 podSpec 文件让组件支持 CocoaPods 集成即可。","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"Swift学习37：对象","slug":"Swift学习/Swift学习37：面向对象编程","date":"2023-03-03T16:37:01.000Z","updated":"2023-03-05T09:05:26.014Z","comments":true,"path":"2023/03/04/Swift学习/Swift学习37：面向对象编程/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A037%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","excerpt":"","text":"swift面向对象概述面向对象的三大特性 继承 封装 多态 基本单元 枚举 结构体 类 协议 扩展 面向对象概述 从整体功能上看 swift 的枚举、结构体、类三者具有完全平等的地位 swift 的类、结构体、枚举中都可以定义（属性、方法、下标、构造体、嵌套类型） 在swift中，枚举和结构体 是 值类型，类 是 引用类型 类和结构体的相似点 定义属性用来存储值 定义方法用来提供功能 定义下标脚本用来允许使用下标语法访问值 定义初始化器用来初始化状态 可以被扩展来默认所没有的功能 遵循协议来针对特定类型提供标准功能 类和结构体不同点 继承允许一个类继承另一个类的特性 类型转换允许你再运行检查和解释一个类实例的类型 反初始化器允许一个类实例释放任何其被分配的资源 引用计数器允许不止一个类对实例的引用","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习36：函数式编程","slug":"Swift学习/Swift学习36：函数式编程","date":"2023-03-03T14:56:24.000Z","updated":"2023-03-05T08:49:29.852Z","comments":true,"path":"2023/03/03/Swift学习/Swift学习36：函数式编程/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A036%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"范式转换-函数式读入一个文本，确定所有单词的使用频率并从高到低排序，打印出所有单词及其频率的排序列表 命令式编程 风格尝尝迫使我们出于性能考虑，把不同的任务交织起来，以便能够用一次循环来完成多个任务 123456789101112131415161718192021222324252627282930let words = &quot;&quot;&quot;This rectangle defines the size and position of the view in its superview’s coordinate system.&quot;&quot;&quot;let NON_WORDS = [&quot;e&quot;,&quot;of&quot;,&quot;end&quot;,&quot;on&quot;]func wordFrep(words: String) -&gt; [String:Int] &#123; var wordDict: [String:Int] = [:] // 分割成一个数组 let wordList = words.split(separator: &quot; &quot;) // 遍历数组 for word in wordList &#123; // 数组每个元素转小写 let lowercaseWord = word.lowercased() // 不包含元素 if !NON_WORDS.contains(lowercaseWord) &#123; // 有count if let count = wordDict[lowercaseWord] &#123; wordDict[lowercaseWord] = count + 1 &#125;else &#123; // 无count wordDict[lowercaseWord] = 1 &#125; &#125; &#125; return wordDict&#125;print(wordFrep(words:words))============[&quot;and&quot;: 1, &quot;superview’s&quot;: 1, &quot;system.&quot;: 1, &quot;view&quot;: 1, &quot;defines&quot;: 1, &quot;its&quot;: 1, &quot;coordinate&quot;: 1, &quot;in&quot;: 1, &quot;the&quot;: 2, &quot;rectangle&quot;: 1, &quot;this&quot;: 1, &quot;size&quot;: 1, &quot;position&quot;: 1] 而 函数式编程 用 map()、filter() 这些高级函数把我们解法出来，让我们站在更高的抽象层次上去考虑问题，把问题看的更清楚 1234567891011121314151617// 函数式写法func wordFrep2(words: String) -&gt; [String:Int] &#123; var wordDict: [String:Int] = [:] // 分割成一个数组 let wordList = words.split(separator: &quot; &quot;) // map：尾随闭包的方式 wordList.map &#123; $0.lowercased() &#125; .filter &#123; !NON_WORDS.contains( $0 ) &#125; .forEach &#123; wordDict[$0] = (wordDict[$0] ?? 0) + 1 &#125; return wordDict&#125;print(wordFrep2(words:words))=============[&quot;view&quot;: 1, &quot;its&quot;: 1, &quot;and&quot;: 1, &quot;defines&quot;: 1, &quot;in&quot;: 1, &quot;the&quot;: 2, &quot;size&quot;: 1, &quot;this&quot;: 1, &quot;position&quot;: 1, &quot;coordinate&quot;: 1, &quot;superview’s&quot;: 1, &quot;system.&quot;: 1, &quot;rectangle&quot;: 1] 函数式编程-简洁 函数式编程简洁，面向对象编程 通过 封装不确定因素 来使代码能够被人理解，函数式编程 通过 尽量减少少不确定因素 来使代码能够被人理解 在面向对象的命令式编程语言里，重用的单元是类和类之间沟通用的消息 函数式编程语言实现重用的思路很不一样。函数式语言提倡在有限的几种关键数据结果（如：list、set、map）上运用针对这些数据结构高度优化过的操作，以此构建成基本的运转机构。开发者再根据具体用途，插入自己的数据结构和高阶函数去调整机构的运转方式 比起以为创建新的类结构体系，把封装的元素降低到函数级别，更有利达到细粒度的、基础层面的重用 函数式程序员喜欢用少数几个核心数据结构，围绕它们去建立一套充分优化的运转机构。面向对象程序员喜欢不断的创建新的数据结构和附属的操作，因为压倒一切的面向对象编程范式就是建立新的类和类间的消息。把所有的数据结构封装成类，一方面压制了方法层面的重用，另一方面鼓励了大粒度的框架式重用。函数式编程的程序结构方便我们在比较细小的层面上重用代码 业务需求 假设我们有一个名字列表，其中一些条目由单个字符组成。现在的任务是，将除去单字符条目之外的列表内容，放在一个逗号分割的字符串里返回，且每个名字的首字母都要大写 命令式解法 命令式编程是按照 程序是一系列改变状态的命名 来建模的一种编程风格。传统的 for 循环是命令式风格的句号例子 12345678910111213141516let names = [&quot;neal&quot;,&quot;s&quot;,&quot;stu&quot;,&quot;h&quot;,&quot;rich&quot;]func cleanNames(names: Array&lt;String&gt;) -&gt; String &#123; var cleanedNames = &quot;&quot; for name in names &#123; if name.count &gt; 1 &#123; cleanedNames += name.capitalized + &quot;,&quot; &#125; &#125; // 去掉最后一个, cleanedNames.remove(at: cleanedNames.index(before: cleanedNames.endIndex)) return cleanedNames&#125;print(cleanNames(names: names))==========Neal,Stu,Rich 函数式解法 函数式编程将程序描述为 表达式和变换，以数学方程的形式建立模型，并且尽量避免可变的状态。 12345678910111213141516// 函数式解法let names = [&quot;neal&quot;,&quot;s&quot;,&quot;stu&quot;,&quot;h&quot;,&quot;rich&quot;]// 过滤let cleanedNames = names.filter &#123; $0.count &gt; 1 &#125;print(cleanedNames)// 首字母大写let cleanedNames2 = cleanedNames.map &#123; $0.capitalized &#125;print(cleanedNames2)// 拼接let cleanedNames3 = cleanedNames2.joined(separator: &quot;,&quot;)print(cleanedNames3)=========[&quot;neal&quot;, &quot;stu&quot;, &quot;rich&quot;][&quot;Neal&quot;, &quot;Stu&quot;, &quot;Rich&quot;]Neal,Stu,Rich 上面的方式还可以简写： 12345678// 简写let cleanedName = names.filter &#123; $0.count &gt; 1 &#125; .map &#123; $0.capitalized &#125; .joined(separator: &quot;,&quot;)print(cleanedName)========Neal,Stu,Rich 具有普遍意义的基本构造单元 筛选：filter 映射：map 折叠&#x2F;化约：foldLeft/reduce 等 swift 的劣势-并行 不是线程安全的 123456789101112131415161718192021222324252627282930// 函数式let names = [&quot;neal&quot;,&quot;s&quot;,&quot;stu&quot;,&quot;h&quot;,&quot;rich&quot;,&quot;ff&quot;,&quot;sag&quot;]let cleanedName = names.filter &#123; $0.count &gt; 1 &#125; .map &#123; $0.capitalized &#125; .joined(separator: &quot;,&quot;)print(cleanedName)// 数组的扩展extension Array where Element : Any &#123; // 函数 public func currentMap&lt;T&gt;(_ transform: (Element) -&gt; T) -&gt; [T] &#123; let n = self.count if n == 0 &#123; return [] &#125; var result = Array&lt;T&gt;() // 初始化一个数组 result.reserveCapacity(n) DispatchQueue.concurrentPerform(iterations: n) &#123; i in result.append(transform(self[i])) &#125; return result &#125;&#125;// 并行写法let cleanedName2 = names.filter &#123; $0.count &gt; 1 &#125; .currentMap &#123; $0.capitalized &#125; .joined(separator: &quot;,&quot;)print(cleanedName2)========Neal,Stu,Rich,Ff,SagStu,Neal,Rich,Ff,Sag 有结果可知：打印的顺序不同，或者会少，说明线程不安全","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习34：闭包","slug":"Swift学习/Swift学习34：闭包","date":"2023-03-03T14:56:01.000Z","updated":"2023-03-05T06:23:33.028Z","comments":true,"path":"2023/03/03/Swift学习/Swift学习34：闭包/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A034%EF%BC%9A%E9%97%AD%E5%8C%85/","excerpt":"","text":"闭包和闭包表达式闭包的概念 闭包是可以在你的代码中被 传递和引用 的功能性独立代码块 闭包能够 补获和存储 定义上下文的任何 常量和变量，这就是所谓的闭合并包裹哪些常量和变量，因此成为 闭包，Swift能够为你处理所有关于补获的内存管理操作 全局和内嵌函数，实际上是 特殊的闭包。闭包符合以下三种形式的一种 全局函数时一个有名字但不会补获任何值的闭包 内嵌函数时一个有名字且能从其上下层函数补获值的闭包 闭包表达式是一个轻量级语法所写的可 以补获其上下文中常量和变量值 的没有名字的闭包 闭包表达式 闭包表达式是一种在简短行内就能写完闭包的语法 闭包表达式从 sorted 函数说起 swift标准库提供了一个叫做 sorted(by:) 的方法，会根据你提供的 排序闭包 将已经数组排序，返回一个已排好序的新数组，原数组不会被 sorted(by:) 方法修改 正序排列 1var newname = name.sorted() 逆序排列 123456789let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]func backward(_ s1:String,_ s2:String) -&gt; Bool &#123; return s1 &gt; s2&#125;var newname = name.sorted(by: backward)print(&quot;\\(name) , \\(newname)&quot;)======[&quot;a&quot;, &quot;bb&quot;, &quot;c&quot;, &quot;ddd&quot;] , [&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;] 闭包表达式语法 闭包表达式语法能够使用 常量形式参数、变量形式参数和输入输出形式参数，但不能提供默认值。 可变形式参数也能使用，需要在形式参数列表的最后面使用 元组也可被用来作为形式参数和返回类型 123&#123; (parameters) -&gt; (return type) in statements&#125; 将之前 backward(::) 函数改为闭包表达式 12345678let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]var newname = name.sorted(by: &#123; (s1: String,s2: String) -&gt; Bool in return s1 &gt; s2&#125;)print(&quot;\\(name) , \\(newname)&quot;)===========[&quot;a&quot;, &quot;bb&quot;, &quot;c&quot;, &quot;ddd&quot;] , [&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;] 从语境中推断类型 排序闭包为实际参数来传递给函数，swift能推断它的形式参数类型和返回类型 可以省略 形式参数、括号、返回箭头 123456let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]var newname = name.sorted(by: &#123; s1,s2 in return s1 &gt; s2 &#125;)print(&quot;\\(newname)&quot;)========[&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;] 但表达式闭包隐士返回 但表达式闭包能够通过从它们声明中删掉 return 关键字来隐士返回它们单个表达式的结果 123456let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]var newname = name.sorted(by: &#123; s1,s2 in s1 &gt; s2 &#125;)print(&quot;\\(newname)&quot;)=======[&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;] 简写实际参数名 swift 自动对行内闭包提供简写实际参数，可以通过 $0,$1,$2 等名字来引用闭包的 实际参数 123456let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]var newname = name.sorted(by: &#123; $0 &gt; $1 &#125;)print(&quot;\\(newname)&quot;)==========[&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;] 运算符函数 swift 的 string 类型定义了关于大于号 &gt; 的特定类型字符串实现，让其作为一个有两个 string 类型形式参数的函数并返回一个 bool 类型的值。正好 soreted(by:) 方法的形式参数需要的函数相匹配。因此你可以简单的传入一个 &gt; 123456let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]var newname = name.sorted(by: &gt;)print(&quot;\\(newname)&quot;)=======[&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;] 尾随闭包 如果你需要一个 很长的闭包表达式 作为 函数最后一个实际参数 传递给函数，使用尾随闭包将增强函数的可读性。 尾随闭包 是一个被 写在函数形式参数的括号后面 的闭包表达式 123456let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]var newname = name.sorted&#123; $0 &gt; $1&#125;print(&quot;\\(newname)&quot;)=======[&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;] 闭包捕获值捕获值 一个闭包能够 从上下文捕获已被定义的常量和变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍能在其函数体内引用和修改这些值 1234567891011func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int &#123; var runningTotal = 0 func incrementor() -&gt; Int &#123; runningTotal += amount return runningTotal &#125; return incrementor&#125;======= 作为一种优化，如果一个值没有改变或在闭包外面，swift可能会使用这个值的 拷贝 而 不是捕获 如果 runningTotal 没有在闭包里使用或改变，则是 拷贝 swift也处理了变量的内存管理操作，当变量不再需要时会被释放 闭包是引用类型 在swift中，函数和闭包都是引用类型 无论是什么时候赋值给 函数或闭包 一个 常量或变量，实际上都是将常量和变量设置为对函数和闭包的 引用 如果你分配了一个闭包给类实例的属性，并且闭包通过引用该实例或者它的成员来捕获实例，你将在闭包和实例间会产生 循环引用 逃逸闭包 当闭包作为一个实际参数传递给一个函数时，它会在 函数返回之后调用，我们就说这个 闭包逃逸了。当你声明一个接收闭包作为形式参数的函数时， 你可以在形式参数前加 @escaping 来明确闭包是允许逃逸的 闭包可以逃逸的一种方法是 被存储在定义函数外的变量里。比如说，很多函数接收闭包实际参数来作为启动异步任务的回调。函数在启动任务后返回，但是闭包要直到任务完成—闭包需要逃逸，以便稍后调用。一般是网络请求成功或失败使用 逃逸闭包 让闭包 @escaping 你必须在闭包中显示的使用 self 自动闭包 通过 @autoclosure 标志标记它的形式是使用了自动闭包。现在你调用函数就像它接受了一个 String 类型的实际参数而不是闭包。实际参数自动地转换为闭包。 可以将一个 表达式 直接传递给 @autoclosure自动闭包 自动闭包是一种自动创建的用来把作为实际参数传递给函数的表达式的闭包。它不接受任何实际参数，并且当它被调用时，它会返回内部打包的表达式的值。这个语法的好处在于通过写普通表达式代替显示闭包而使你 省略 包围 函数形式参数 的括号() 自动闭包允许你 延迟执行，因此闭包内部的代码直到你调用时才会运行。对于有副作用或者占用资源的代码来说很有用，因为它可以允许你控制代码何时才进行求值 12345678910111213141516// 自动闭包var custom = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;];print(custom.count)let customPro = &#123; custom.remove(at: 0)&#125;print(custom.count)// 调用才求值print(&quot;new \\(customPro())&quot;)print(custom.count)=======44new a3 自动 + 逃逸 如果你想要自动闭包允许逃逸，就同时使用 @autoclosure 和 @escaping 标志 1234567891011// 自动+逃逸var names = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]var providers:[() -&gt; String] = []func collectCustomsProviders(provider: @escaping () -&gt; String) &#123; providers.append(provider )&#125;// 表达式 name.remove(at:0) StringcollectCustomsProviders(provider:names.remove(at: 0))=========报错 不能直接给 闭包 传递表达式，需要添加 @autoclosure 正确的写法 1234567891011121314151617181920212223// 自动+逃逸var names = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]var providers:[() -&gt; String] = []func collectCustomsProviders(provider: @autoclosure @escaping () -&gt; String) &#123; providers.append(provider )&#125;// 表达式 name.remove(at:0) StringcollectCustomsProviders(provider:names.remove(at: 0))collectCustomsProviders(provider:names.remove(at: 0))// 实际上逃逸闭包print(names.count)for provide in providers &#123; print(provide())&#125;print(names.count)========4122","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习33：函数","slug":"Swift学习/Swift学习33：函数","date":"2023-03-03T14:54:55.000Z","updated":"2023-03-04T16:39:01.522Z","comments":true,"path":"2023/03/03/Swift学习/Swift学习33：函数/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A033%EF%BC%9A%E5%87%BD%E6%95%B0/","excerpt":"","text":"Swift中如何定义和使用函数基本概念 函数是一个独立的代码块，用来执行特定的任务。通过给函数一个名字来定义它的功能，并且在需要的时候，通过这个名字来 调用 函数执行它的任务 Swift统一的函数语法十分灵活。可以从简单的无形式参数到复杂的每个形式参数都带有局部和外部形式参数名。形式参数提供一个默认值来简化函数的调用，可被当做输入输出形式参数被传递，在函数执行完成时修改传递进来的变量。 Swift中每一个函数都有类型，由函数的形式参数类型和返回类型组成 。可以像swift中其它类型来使用它。可以将函数当一个形式参数传递到另外一个函数中。也可以在一个函数中返回另一个函数。同时也可以写在其他函数内部在内嵌范围封装有用的功能。 函数是 引用类型 的，不是值类型的 定义和调用函数 当你定义一个函数时，可以 选择定义一个或多个形式参数类型，也可以定义返回类型 每个函数都有函数名，藐视执行的任务。 使用函数可通过 函数名 并且 传入 函数的 实际参数 （即形式参数类型的输入值 ）来 调用函数。 实际参数顺序必须符合形式参数的列表顺序 无形式参数的函数 函数不要求必须传入一个参数，可以没有形式参数 函数定义需要在名字的后面加一个圆括号，即使没有形式参数也得加 调用函数的时候也要在函数的名字后面加一个圆括号 多形式参数的函数 函数可以输入多个形式参数，写在圆括号内，用逗号分割 123func manyPara(a:Int,b:Int) &#123; pring(&quot;\\(a) \\(b)&quot;)&#125; 无返回值的函数 函数定义可以没有返回类型，即没有返回箭头 -&gt; 或返回类型 严格上，函数还是有一个返回类型的，尽管没有定义返回值，实际上返回一个特殊的类型 void。它是一个空的元组，作用相当于没有元素的元组，写作() 123func manyTuple() -&gt; void &#123; return nil&#125; 多返回值的函数 可以让函数返回多个值作为一个复合的返回值，你可以使用元组类型作为返回类型 123func manyTuple() -&gt; (a:Int,b:String) &#123; return (1,&quot;aaa&quot;)&#125; 可选元组返回类型 如果在函数返回类型中元组可能 没有值，可以用可选元组说明元组可能是 nil 写法是可选元组圆括号后面加一个问号 ？，例如 (Int,Int)? 或 (String,Int,Bool)? 示例： 1234567891011121314151617181920212223// 返回元组func minMax(arr: [Int]) -&gt; (min:Int,max:Int)? &#123; if arr.isEmpty &#123; return nil &#125; var minValue = arr[0] var maxValue = arr[0] for value in arr &#123; if value &lt; minValue &#123; minValue = value &#125; if value &gt; maxValue &#123; maxValue = value &#125; &#125; return (minValue,maxValue)&#125;// 绑定if let minMaxValue = minMax(arr: [1,3,4,2,5]) &#123; print(&quot;min is \\(minMaxValue.min),max is \\(minMaxValue.max)&quot;)&#125; 编译运行，查看打印结果： 1min is 1,max is 5 隐士返回函数 如果整个函数体是一个单一的表达式，那么函数隐士返回这个表达式 1234func greet(person: String) -&gt; String&#123; &quot;Hello,&quot; + person + &quot;!&quot;&#125;print(&quot;\\(greet(person: &quot;World&quot;))&quot;) 打印结果 1Hello,World! Swift形式参数和返回值实参标签和形参名 每一个函数的形式参数都包含实际参数标签和形式参数名。 形式参数必须有唯一的名字，有助于代码易读 1234func someFunc(firstParamName:Int,secondParamName:Int)&#123; // 形式参数 firstParamName secondParamName&#125;someFunc(firstParamName: 1, secondParamName: 2) 指定实际参数标签 形式参数名之前写实际参数标签，用 空格 分割 如果你为 形式参数 定义了 实际参数标签，那么在调用函数的时候必须使用 实际参数标签 实际参数标签能够让函数的调用更加明确，更像自然语言，更可读，更清晰表达你的意图 12345// 实际参数标签 homefunc greet(person: String, from home: String) -&gt; String &#123; return &quot;Hello \\(person)! my home is \\(home)&quot;&#125;print(greet(person: &quot;ZJ&quot;,from: &quot;BeiJing&quot;)) 打印结果： 1Hello ZJ! my home is BeiJing 省略实际参数标签 可以利用下划线 _ 替代显示的实际参数标签 1234func greet(_ person: String, _ home: String) -&gt; String &#123; return &quot;Hello \\(person)! my home is \\(home)&quot;&#125;print(greet(person: &quot;ZJ&quot;,from: &quot;BeiJing&quot;)) 默认形式参数值 可以在形式参数类型后，给类型定义一个默认值 如果定义了默认值，你就可以在调用的时候省略这个形式参数 123456789func someFunc(paramDefault: Int = 10) &#123; print(&quot;\\(paramDefault)&quot;)&#125;someFunc(paramDefault: 6)someFunc()===========610 可变形式参数 一个可变的形式参数可以接受零或多个特定类型的值。 通过在形式参数类型名后插入三个点符号 ... 来书写可变形式参数。 传入到可变参数中的值在函数的主体中被当做是对应类型的 数组。 1234567891011func changeFunc(_ numbers: Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total / Double(numbers.count)&#125;changeFunc(1,2,3,4,5)=============3 输入输出形式参数 可变形式参数只能在函数的内部做改变。如果你想函数能修改一个形式参数的值，而且这些改变在函数结束之后依然生效，那么就需要将形式参数定义为输入输出形式参数 输入输出形式参数：在形式参数前边加 inout 关键字。 只能把 变量 作为输入输出形式参数的 实际参数，在将变量作为实际参数传入给输入输出形式参数时，在它前边添加一个符号 &amp; 来明确可以被函数修改 输入输出形式参数不能有默认值，可变形式参数不能被标记为 inout 12345678910111213// 输入输出形式参数func swapTwoInt(_ a: inout Int, _ b: inout Int) &#123; let temp = a a = b b = temp&#125;var one = 10var two = 20swapTwoInt(&amp;one,&amp;two)print(&quot;\\(one) \\(two)&quot;)=========20 10 函数类型和内嵌函数函数类型 每一个函数都有一个特定的函数类型，它由形式参数类型，返回类型组成 12345678func addTwo(_ a:Int,_ b:Int) -&gt; Int &#123; return a + b&#125;let c = addTwo(1,2)print(&quot;\\(c)&quot;)========3 和 (Int,Int) -&gt; Int 相关 使用函数类型 你可以像使用Swift中的其他类型一样使用函数类型。例如：你可一个常量或变量定义一个函数类型，并且未变量指定一个相应的函数 12345678func addTwo(_ a:inout Int,_ b:inout Int) -&gt; Int &#123; return a + b&#125;var mathFunc:(inout Int,inout Int) -&gt; Int = addTwoprint(mathFunc(2,3))============5 函数类型作为形式参数类型 你可以将 函数 作为 其他函数的形式参数 12345678910func addTwo(_ a:Int,_ b:Int) -&gt; Int &#123; return a + b&#125;func printResult(_ mathFunc:(Int,Int) -&gt; Int,_ a:Int,_ b:Int) &#123; print(&quot;Result:\\(mathFunc(a,b))&quot;)&#125;printResult(addTwo,2,3)==========5 函数类型作为返回类型 可以利用函数的类型作为另一个函数的返回类型。写法在函数的返回箭头后写一个完整的函数类型 123456func backF(_ input:Int) -&gt; Int&#123; return input - 1&#125;func chooseFunc(back: Bool) -&gt; (Int) -&gt; Int &#123; return backF&#125; 内嵌函数 可以在函数内定义另外一个函数。这就是内嵌函数 内嵌函数默认是被隐藏起来的，但仍然可以通过包裹他们的函数来调用他们。 包裹的函数也可以返回它内部的一个内嵌函数来在另外的返回里使用 1234567891011121314func chooseFunc(back: Bool) -&gt; (Int) -&gt; Int &#123; func stepForward(step:Int) -&gt; Int &#123; return step + 1&#125; func stepBackward(step:Int) -&gt; Int &#123; return step - 1&#125; return back ? stepBackward : stepForward&#125;var current = -4let stepFunc = chooseFunc(back: current &gt; 0)while current != 0 &#123; current = stepFunc(current)&#125;print(current)=======0","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习32：Dictionary字典底层实现探索","slug":"Swift学习/Swift学习32：Dictionary字典底层实现探索","date":"2023-03-03T14:54:19.000Z","updated":"2023-03-03T14:54:19.622Z","comments":true,"path":"2023/03/03/Swift学习/Swift学习32：Dictionary字典底层实现探索/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A032%EF%BC%9ADictionary%E5%AD%97%E5%85%B8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习32：Dictionary字典","slug":"Swift学习/Swift学习32：Dictionary字典","date":"2023-03-03T14:54:00.000Z","updated":"2023-03-03T14:54:00.489Z","comments":true,"path":"2023/03/03/Swift学习/Swift学习32：Dictionary字典/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A032%EF%BC%9ADictionary%E5%AD%97%E5%85%B8/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习31：Set底层实现探究","slug":"Swift学习/Swift学习31：Set底层实现探究","date":"2023-03-03T14:53:34.000Z","updated":"2023-03-03T14:53:34.196Z","comments":true,"path":"2023/03/03/Swift学习/Swift学习31：Set底层实现探究/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A031%EF%BC%9ASet%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%A9%B6/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习30：Set集合","slug":"Swift学习/Swift学习30：Set集合","date":"2023-03-03T14:52:43.000Z","updated":"2023-03-03T14:52:43.195Z","comments":true,"path":"2023/03/03/Swift学习/Swift学习30：Set集合/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A030%EF%BC%9ASet%E9%9B%86%E5%90%88/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习29：如何用数组来实现栈和队列","slug":"Swift学习/Swift学习29：如何用数组来实现栈和队列","date":"2023-03-03T14:51:03.000Z","updated":"2023-03-03T14:51:03.634Z","comments":true,"path":"2023/03/03/Swift学习/Swift学习29：如何用数组来实现栈和队列/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A029%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习28：数组的底层实现","slug":"Swift学习/Swift学习28：数组的底层实现","date":"2023-03-03T14:50:24.000Z","updated":"2023-03-03T14:50:24.173Z","comments":true,"path":"2023/03/03/Swift学习/Swift学习28：数组的底层实现/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A028%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习27：访问和操作数组","slug":"Swift学习/Swift学习27：访问和操作数组","date":"2023-03-03T14:49:55.000Z","updated":"2023-03-03T14:49:55.779Z","comments":true,"path":"2023/03/03/Swift学习/Swift学习27：访问和操作数组/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A027%EF%BC%9A%E8%AE%BF%E9%97%AE%E5%92%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习26：创建数组的几种方式","slug":"Swift学习/Swift学习26：创建数组的几种方式","date":"2023-03-03T14:49:30.000Z","updated":"2023-03-03T14:49:30.624Z","comments":true,"path":"2023/03/03/Swift学习/Swift学习26：创建数组的几种方式/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A026%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"OC三方框架01：bugly搜集Crash","slug":"OC三方库/OC三方框架01：bugly搜集Crash","date":"2023-03-03T08:17:48.000Z","updated":"2023-03-03T12:11:09.074Z","comments":true,"path":"2023/03/03/OC三方库/OC三方框架01：bugly搜集Crash/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/OC%E4%B8%89%E6%96%B9%E5%BA%93/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B601%EF%BC%9Abugly%E6%90%9C%E9%9B%86Crash/","excerpt":"","text":"Bugly 介绍为了能够快速并准确的定位用户 App 发生 Crash 的代码位置，Bugly 使用 符号表文件 对发生 Crash 的程序 堆栈 进行 解析和还原 举例： Bugly 上传方式 Bugly 已不再支持直接上传dSYM文件，需要 下载工具包手动上传 本文主要介绍 下载工具包手动上传 安装java运行环境 终端查看是否已安装 1234zhangjian@zhangjiandeMBP ~ % java -versionjava version &quot;1.8.0_291&quot;Java(TM) SE Runtime Environment (build 1.8.0_291-b10)Java HotSpot(TM) 64-Bit Server VM (build 25.291-b10, mixed mode) 上面的显示表示已安装 未安装的情况如下： 到 Java官网 下载 jdk，如下图： 下载完成之后打开 dmg，安装、一路下一步即可安装成功。 在终端输入 java -version 可以查看 java 版本，如果输出信息和上面类似，表示安装成功 获取 dSYM 文件 什么是 dSYM 文件？ 在 iOS 平台中，dSYM文件是指 具有调试信息的目标文件，文件名通常为 xxx.app.dSYM 【注】：为了方便找回 Crash 对应的 dSYM文件 和 还原堆栈，建议每次 构建或发布App版本 时，备份好 dSYM文件 获取 dSYM 方式 我们可以配置 Edit Scheme -&gt; Archives 打包 Debug 和 Release 两种环境，去获取 dSYM文件，本文以 Release 发布环境为例 配置打包环境 Release Show in Finder -&gt; 显示包内容，找到 dSYM文件 最后，在桌面或任意位置，新建一个文件夹如 appdSYM ，将 xxx.app.dSYM 拷贝进来 至此，获取 dSYM文件 完成 工具手动上传符号表 下载 Bugly iOS 符号表 上传工具，如下图： 我们需要用到的是 buglySymboliOS.jar 文件，单独放在一个新建的空文件夹如 buglySymboliOS 里面 下载后得到 buglyqq-upload-symbol 文件，解压里面 jar包，得到 buglySymboliOS.jar 包 通过终端命令行上传 1java -jar buglyqq-upload-symbol.jar -appid c4f4e4dc67 -appkey cb791b15-dbe1-44d9-bd33-b3fe558b773b -bundleid cn.epod.srsf -version 1.6.2 -platform IOS -inputSymbol /Users/mac/Desktop/appdSYM/中图云书房.app.dSYM 【参数说明】： -addid ：在 bugly 上对应的 appid c4f4e4dc67-appkey ：在 bugly 上对应的 appkey-bundleid ： iOS平台的 bundle id cn.epod.srsf-version ：版本号 1.6.2-platform ：平台（注意大小写）IOS Android-inputSymbol ：dSYM调试文件 &#x2F;Users&#x2F;mac&#x2F;Desktop&#x2F;appdSYM&#x2F;中图云书房.app.dSYM 项目中使用 项目需要集成cocoapods三方依赖管理工具，用cocoapods集成 Bugly SDK 12345678910111213141516171819202122232425platform :ios, &#x27;9.0&#x27;# 忽略所有警告inhibit_all_warnings!target &#x27;SRSF&#x27; do # Comment the next line if you don&#x27;t want to use dynamic frameworks use_frameworks! # Pods for SRSF # 官方提示：三方动态库最好最多是6个 # Bugly pod &#x27;Bugly&#x27; target &#x27;SRSFTests&#x27; do inherit! :search_paths # Pods for testing end target &#x27;SRSFUITests&#x27; do # Pods for testing endend 使用 1234567#pragma mark -Bugly- (void)startBugly&#123; BuglyConfig * config = [[BuglyConfig alloc] init]; config.debugMode = YES; // Debug信息开关 config.reportLogLevel = BuglyLogLevelWarn; // 设置为BuglyLogLevelWarn，则在崩溃时会上报Warn、Error接口打印的日志 [Bugly startWithAppId:@&quot;AppId&quot; config:config];&#125;","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-三方框架","slug":"OC-三方框架","permalink":"https://www.bboyzj.cn/tags/OC-%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"性能优化02：卡顿检测","slug":"OC性能优化/性能优化02：卡顿检测","date":"2023-03-02T15:32:46.000Z","updated":"2023-03-02T15:32:46.851Z","comments":true,"path":"2023/03/02/OC性能优化/性能优化02：卡顿检测/","link":"","permalink":"https://www.bboyzj.cn/2023/03/02/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602%EF%BC%9A%E5%8D%A1%E9%A1%BF%E6%A3%80%E6%B5%8B/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"性能优化01：内存泄漏检测","slug":"OC性能优化/性能优化01：内存泄漏检测","date":"2023-03-02T15:32:21.000Z","updated":"2023-03-02T15:32:21.654Z","comments":true,"path":"2023/03/02/OC性能优化/性能优化01：内存泄漏检测/","link":"","permalink":"https://www.bboyzj.cn/2023/03/02/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"OC学习03：内存管理","slug":"OC学习/OC学习03：内存管理","date":"2023-03-02T10:51:48.000Z","updated":"2023-03-03T08:09:37.000Z","comments":true,"path":"2023/03/02/OC学习/OC学习03：内存管理/","link":"","permalink":"https://www.bboyzj.cn/2023/03/02/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A003%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"前言本文主要介绍 内存的五大区 、函数栈 和 内存管理 内存五大区在iOS中，内存主要分为 栈区、堆区、全局区、常量区、代码区 五个区域，如下图所示： 栈区定义 栈是 系统数据结构，其对应的 进程或者线程是唯一的 栈是 向低地址扩展 的数据结构 栈是一块 连续的内存区域，遵循 先进后出（FILO） 原则 栈区一般在 运行时 分配 存储 栈区是由 编译器自动分配并释放的，主要用来存储 局部变量 函数的参数，例如函数的隐藏参数（id self, SEL _cmd） 优缺点 优点：因为栈是由 编译器自动分配并释放 的，不会产生内存碎片，所以 快速高效 确定：栈的 内存大小有限制，数据不灵活 iOS主线程大小是1MB 其他线程是 512KB MAC 只有 8MB 以上内存大小的说明，在Threading Programming Guide 中有相关说明，如下图： 堆区定义 堆是 向高地址扩展 的数据结构 堆是 不连续的内存区域，类似于 链表结构（便于增删，不便于查询），遵循 先进先出（FIFO）原则 堆的 地址空间 在iOS中是是动态的 堆区的分配一般是以在 运行时分配 存储 堆区是 由程序员动态分配和释放 的，如果程序员不释放，程序结束后，可能由操作系统回收，主要用于存放： OC 中使用 alloc 、 new 开辟空间创建 对象 ，或者 block经过copy后 C 语言中使用 malloc、calloc、realloc 分配的空间，需要 free 释放 一般一个 new/alloc 就要对应一个 release，在 ARC 下编译器会自动在合适位置为 OC 对象添加 release 操作，会在当前 线程Runloop退出或休眠时销毁这些对象。MRC 则需程序员手动释放。 优缺点 优点：灵活方便，数据适应面广泛 缺点：需 手动管理、速度慢，容易产生内存碎片 当需要访问堆中数据时，一般需要 先通过对象读取到栈区的指针地址，然后通过 指针地址访问堆区 全局区（静态区，即.bss &amp; .data）全局区是 编译时分配 的内存空间，在程序运行过程中，此内存中的数据一直存在，程序结束后由系统释放，主要存放： 未初始化的全局变量和静态变量，即BSS区（.bss） 已初始化的全局变量和静态变量，即DATA区（.data） 其中，全局变量 是指变量值可以在 运行时被动态修改，而 静态变量 是 static 修饰的变量，包含 静态局部变量 和 静态全局变量 常量区（即.rodata）常量区是 编译时分配 的内存空间，在 程序结束后由系统释放，主要存放： 已经使用了的，且没有指向的 字符串常量 字符串常量因为可能在程序中被多次使用，所以在程序运行之前就会提前分配内存 代码区（即.text）代码区是 由编译时分配，主要用于存放 程序运行时的代码，代码会被编译成 二进制存进内存 的 内存五大区验证运行下面的一段代码，看看变量在内存中是如何分配的： 1234567891011121314int a = 10; // 全局区（已初始化的全局变量）char * b; // 全局区(未初始化的全局变量)- (void)test&#123; NSInteger i = 123; // 栈区（局部变量） NSLog(@&quot;i的内存地址：%p&quot;, &amp;i); NSString *string = @&quot;ZJ&quot;; // 常量区（字符串常量） NSLog(@&quot;string的内存地址：%p&quot;, string); NSLog(@&quot;&amp;string的内存地址：%p&quot;, &amp;string); NSObject *obj = [[NSObject alloc] init]; // 堆区（alloc对象） NSLog(@&quot;obj的内存地址：%p&quot;, obj); NSLog(@&quot;&amp;obj的内存地址：%p&quot;, &amp;obj); &#125; 运行结果如下： 123452022-03-11 14:34:25.438913+0800 内存五大区[70321:4340509] i的内存地址：0x16f6f5a182022-03-11 14:34:25.438976+0800 内存五大区[70321:4340509] string的内存地址：0x1007100982022-03-11 14:34:25.438997+0800 内存五大区[70321:4340509] &amp;string的内存地址：0x16f6f5a102022-03-11 14:34:25.439014+0800 内存五大区[70321:4340509] obj的内存地址：0x280fa0bc02022-03-11 14:34:25.439031+0800 内存五大区[70321:4340509] &amp;obj的内存地址：0x16f6f5a08 对于 局部变量i， 存放在栈区 对于 字符串对象string，分别打印了 string得对象地址 和 string对象的指针地址 string的 对象地址 是是存放在 常量区 string 对象的指针地址，是存放在 栈区 对于 alloc创建的对象obj，分别打印了 obj得对象地址 和 obj对象的指针地址 obj的 对象地址 是存放在 堆区 obj 对象的指针地址 是存放在 栈区 函数栈 函数栈 又称为 栈区，在内存中从高地址往低地址分配，与堆区相对，具体图示请看上面 栈帧 是指 函数（运行中且未完成）占用的一块独立的连续内存区域 应用中新创建的 每个线程都有专用的栈空间，栈可以在线程期间自由使用，而线程中有千千万万的函数调用，这些函数 共享 进程的这个 栈空间。每个函数所使用的栈空间是一个栈帧，所有栈帧就组成了这个线程完成的栈 函数调用是发生在栈上 的，每个 函数的相关信息（例如局部变量、调用记录等）都 存储在一个栈帧 中，每执行一次 函数调用，就会生成一个与其相关的栈帧，然后将其 栈帧压入函数栈，而当函数 执行结束，则将此函数对应的 栈帧出栈并释放掉 如下图所示，是经典图- ARM的栈帧布局方式 其中 main stack frame 为调用函数的栈帧 func1 stack frame 为当前 当前函数（被调用者）的栈帧 栈底 在 高 地址，栈向下增长 FP 就是 栈基址，它指向函数的 栈帧起始地址 SP 则是函数的 栈指针，它指向 栈顶 的位置 ARM压栈 的 顺序 很是规则（也比较容易被黑客攻破），依次为 当前函数指针PC、返回指针LR、栈指针SP、栈基址FP、传入参数个数及指针、本地变量 和 临时变量。如果函数准备调用另一个函数，跳转之前临时变量区先要保存另一个函数的参数 ARM 也可以 用栈基址和栈指针明确标示栈帧的位置，栈指针SP一直移动，ARM的特点是，两个栈空间内的地址（SP+FP）前面，必然有两个代码地址（PC+LP）明确标示着调用函数位置内的某个地址 堆栈溢出一般情况下应用程序是不需要考虑堆和栈的大小的，但是事实上堆和栈不是无上限的，过多的递归会导致栈溢出，过多的alloc变量会导致堆溢出 所以 预防堆栈溢出 的方法： 避免层次过深 的 递归 调用 不要使用过多的局部变量，控制局部变量的大小 避免分配 占用空间 太大的对象，并 及时释放 实在不行，适当的情景下 调用系统API修改线程的堆栈大小 栈帧示例描述下面代码的栈帧变化 栈帧程序示例 1234567891011int Add(int x,int y) &#123; int z = 0; z = x + y; return z;&#125;int main() &#123; int a = 10; int b = 20; int ret = Add(a, b);&#125; 程序执行时，栈区中栈帧的变化如下图所示： 内存管理概述 在iOS中开发中，我们或多或少都听说过内存管理。iOS的内存管理一般指的是OC对象的内存管理，因为OC对象分配在堆内存，堆内存需要程序员自己去动态分配和回收；基础数据类型(非OC对象)则分配在栈内存中，超过作用域就会由系统检测回收。如果我们在开发过程中，对内存管理得不到位，就有可能造成内存泄露。 我们通常讲的内存管理，实际上从发展的角度来说，分为两个阶段：MRC和ARC。 MRC指的是 手动内存管理，在开发过程中需要开发者手动去编写内存管理的代码； ARC指的是 自动内存管理，在此内存管理模式下由LLVM编译器和OC运行时库生成相应内存管理的代码。 引用计数 在 OC 中，使用 引用计数 来 进行内存管理。 每个对象都有一个与其相对应的引用计数器，当持有一个对象，这个对象的引用计数就会递增；当这个对象的某个持有被释放，这个对象的引用计数就会递减。当这个对象的引用计数变为0，那么这个对象就会被系统回收。 当一个对象使用完没有释放，此时其引用计数永远大于1。该对象就会一直占用其分配在堆内存的空间，就会导致内存泄露。内存泄露到一定程度有可能导致内存溢出，进而导致程序崩溃。 MRC 简介 全称 Manual Reference Counting，管理通过使用 retain, release, 以及 autorelease 的消息发送来实现。 retain: 持有（拥有）对象，对象引用数加 1 release: 释放对象，对象引用数减 1 autorelease: 通知系统，在 @autoreleasepool 代码块结束时，对对象调用 release 管理原则 自己创建的对象，自己获得拥有权 在苹果规定中，使用 alloc/new/copy/mutableCopy 创建返回的对象归调用者所有，例如以下 1234/* NSMutableArray类对象A */NSMutableArray *array = [[NSMutableArray alloc] init]; NSLog(@&quot;%p&quot;, array);[array release]; // 释放 由于对象 A 由 alloc 生成，符合苹果规定，指针变量array指向并持有对象A，引用计数器会加 1。另外，array在使用完对象A后需要对其进行释放。当调用release后，释放了其对对象A的引用，计数器减1。对象A此时引用计数值为零，所以对象A被回收。不能访问已经被回收的对象，会发生崩溃。 别人创建的对象，可以通过 retain 来获得拥有权 123456789// 例如已有 fooArray, 通过 array 方法获得其引用NSArray *bar = [fooArray array];// 不可以直接调用 release，因为没有拥有权// [bar release];// 需要先 retain 来获得拥有权，然后才能释放[bar retain];[bar release]; 你所拥有的对象不再需要使用时，必须将其释放 不能释放你不拥有的对象 retain retain和属性 我们可以通过属性来保存对象，如果一个属性为强引用，我们就可以通过属性的实例变量和存取方法来对某个对象进行操作，例如某个属性的setter方法如下： 12345678910- (void)setPerson:(Person *)person &#123; [person retain]; [_person release]; _person = person; &#125; 我们通过 retain新值，release旧值，再给实例变量更新值。 需要注意的一点是：需要先retain新值，再release旧值。因为如果新旧值是同一个对象的话，先release就有可能导致该对象被系统回收，再去retain就没有任何意义了。例如下面这个例子： 123456789101112131415161718192021222324252627282930#import &quot;ViewController.h&quot;#import &quot;Person.h&quot;@interface ViewController ()@property (nonatomic, strong)Person *person;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // 实例变量持有Person类对象(P对象)。这样赋值不会调用set方法 _person = [[Person alloc] init]; // 调用set方法 self.person = _person; &#125;- (void)setPerson:(Person *)person &#123; // release释放对P对象的引用，P对象引用计数值变为零，则P对象被系统回收 [_person release]; // 由于P对象已经被回收，再去retain就容易出问题 [person retain]; _person = person;&#125;@end 由于P对象被回收，对应其所分配的内存被置于 可用内存池 中。如果该内存未被覆写，那么P对象依然有效；如果内存被覆写，那么实例变量_person就会指向一个被覆写的未知对象的指针，那么实例变量就变成一个 悬挂指针。 retain和数组 如果我们把一个对象加入到一个数组中，那么该数组的addObject方法会对该对象调用retain方法。例如以下代码： 12345678// person获得并持有P对象，P对象引用计数为1Person *person = [[Person alloc] init]; // Person类对象生成的P对象 NSMutableArray *array = [NSMutableArray array]; // person被加入到数组，对象P引用计数值为2[array addObject:person]; 此时，对象P被person和array两个变量同时持有。 release 自己持有的对象自己释放 当我们持有一个对象，如果在不需要继续使用该对象，我们需要对其进行释放(release)。例如以下代码： 12345678// array获得并持有NSArray类对象NSArray *array = [[NSArray alloc] init]; // 当不再需要使用该对象时，需要释放[array release]; // obj获得但不持有该对象id obj = [NSArray array]; 非自己持有的对象不要释放 当我们不持有某个对象，却对该对象进行释放，应用程序就会崩溃。 12345678// 获得并持有A对象Person *p = [[Person alloc] init]; // Person类对象A // 对象A引用计数为零，所以对象A被回收[p release];// 释放非自己持有的对象[p release]; 另外，我们也不能访问某个已经被释放的对象，该对象所占的堆空间如果被覆写就会发生崩溃的情况。 autorelease autorelease 指的是自动释放，当一个对象收到 autorelease 的时候，该 对象就会被注册到当前处于栈顶的自动释放池（autorelease pool）。如果没有主动生成自动释放池，则当前自动释放池对应的是主运行循环的自动释放池。在当前线程的RunLoop进入休眠前，就会对被注册到该自动释放池的所有对象进行一次release操作。 autorelease和release的区别是： release：是马上释放对某个对象的强引用； autorelease：是延迟释放某个对象的生命周期。 12345678910111213141516171819202122232425&#123; // 外部调用 Person *p = [Person person]; NSLog(@&quot;%p&quot;, p); //使用无须retain // 持有则需要retain [p retain]; _person = p; [_person release];&#125;// Person类内部定义+ (id)person &#123; //创建的Person类对象由person获得并持有 Person *person = [[Person alloc] init]; // [person release]; // 将 person 对象放入自动释放池 [person autorelease]; return person;&#125; 在外部调用，从方法名person知道，创建的对象由p指针变量获得但不持有。在函数内部，person获得并持有了Person类对象，所返回的person对象的引用计数加1。换句话说，调用者需要额外处理这多出来的一个持有操作。另外，我们不能在函数内部调用release，不然对象还没返回就已经被系统回收。这时候使用autorelease就能很好地解决这个问题。 只要把要返回的对象调用autorelease方法，注册到自动释放池就能延长person对象的生命周期，使其在 autorelease pool销毁(drain)前依然能够存活。 另外，person对象在返回时调用了 autorelease方法。该对象已经在自动释放池中，我们可以直接使用对象p，无须再通过[p retain]访问；不过，如果要用实例变量持有该对象，则需要对变量p进行一次retain操作，实例变量使用完该对象需要释放该对象。 autorelease pool autorelease pool 和 RunLoop(运行循环) 当应用程序启动，系统默认会 开启一条线程，该线程就是 主线程。主线程也有一个与之对应的自动释放池。 每条线程都包含一个与其对应的自动释放池，当某条线程被终止的时候，对应该线程的自动释放池会被销毁。同时，处于该自动释放池的对象将会进行一次 release 操作。 ，例如我们常见的 ARC 下的 main.h 文件： 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 该自动释放池用来释放在主线程下注册到该自动释放池的对象。 需要注意的是，当我们 开启一条子线程，并且在该线程 开启RunLoop 的时候，需要为其增加一个autorelease pool，这样有助于保证内存的安全。 autorelease pool和降低内存峰值 当我们执行一些复杂的操作，特别是如果这些复杂的操作要被循环执行，那么中间会免不了会产生一些临时变量。当被加到主线程自动释放池的对象越来越来多，却没有得到及时释放，就会导致内存溢出。这个时候，我们可以手动添加自动释放池来解决这个问题。如以下例子所示： 123456789101112for (int i = 0; i &lt; largeNumber; i++) &#123; // 创建自动释放池 NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init]; // 产生许多被注册到自动释放池的临时对象 id obj = [Person personWithComplexOperation]; // 释放池中对象 [pool drain]; &#125; 如上述例子所示，我们执行的循环次数是一个非常大的数字。并且调用personWithComplexOperation方法的过程中会产生许多临时对象，所产生的临时对象有可能会被注册到自动释放池中。我们通过手动生成一个自动释放池，并且在每次循环结束前把该自动释放池的对象执行release操作释放掉，这样就能有效地降低内存的峰值了。 ARC 概述 Automatic Reference Counting，自动引用计数，即 ARC，WWDC2011 和 iOS5 所引入的最大的变革和最激动人心的变化。ARC是新的LLVM 3.0编译器的一项特性，使用ARC，可以说举解决了广大iOS开发者所憎恨的手动内存管理的麻烦。 此处的 A 就是 automatic。其实 ARC 只是比 MRC 多了一步，就是在 编译时编译器自动帮开发者添加 retain, release 以及 autorelease 的调用，底层的内存管理机制还是和 MRC 一样。 在 ARC 模式下，我们通常在对象变量的声明里用 属性标记符 来指引 ARC 机制来管理我们的对象变量，它们是：strong, retain, weak, copy, assign。默认标记是 strong 标记符的区别 strong: 顾名思义，就是 强引用，对应 MRC 下的 retain，即引用数加 1 retain: 同 strong weak: 弱引用，不增加引用数，引用的对象被释放后变为 nil copy: 对对象进行 copy 后再赋值，因此对象必须遵循 NSCopying 协议。如： 123@property(copy)Foo *foo;...self.foo = bar; // 相当于 self.foo = [bar copy]; assign: 一般用于原始数据类型（primitive type）的赋值。可以用于对象，效果相当于 weak，可是有一个坑是当对象被释放后，assign 属性的变量不会变成 nil，而是成为 野指针（dangling pointer），因此不建议使用在对象上。 借助以上的属性标记符，我们可以在对象声明的时候集中制定它们的内存管理策略，清晰明了。 ARC的判断原则 ARC判断一个对象是否需要释放不是通过引用计数来进行判断的，而是通过强指针来进行判断的。那么什么是强指针? 强指针 默认所有对象的指针变量都是强指针 被__strong修饰的指针 12Person *p1 = [[Person alloc] init];__strong Person *p2 = [[Person alloc] init]; 弱指针 被 __weak 修饰的指针 1__weak Person *p = [[Person alloc] init]; ARC如何通过强指针来判断？ 只要还有一个强指针变量指向对象，对象就会保持在内存中 ARC的使用 123456int main(int argc, const char * argv[]) &#123; // 不用写release, main函数执行完毕后p会被自动释放 Person *p = [[Person alloc] init]; return 0;&#125; ARC的注意点 不允许调用对象的 release方法 不允许调用 autorelease方法 重写父类的dealloc方法时，不能再调用 [super dealloc]; ARC下单对象内存管理 局部变量释放对象随之被释放 12345678int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *p = [[Person alloc] init]; &#125; // 执行到这一行局部变量p释放 // 由于没有强指针指向对象, 所以对象也释放 return 0;&#125; 清空指针对象随之被释放 12345678int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *p = [[Person alloc] init]; p = nil; // 执行到这一行, 由于没有强指针指向对象, 所以对象被释放 &#125; return 0;&#125; 默认清空所有指针都是强指针 123456789int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // p1和p2都是强指针 Person *p1 = [[Person alloc] init]; __strong Person *p2 = [[Person alloc] init]; &#125; return 0;&#125; 弱指针需要明确说明 注意: 千万不要使用弱指针保存新创建的对象 12345678int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // p是弱指针, 对象会被立即释放 __weak Person *p1 = [[Person alloc] init]; NSLog(@&quot;%@&quot;,p); &#125; return 0;&#125; 打印结果： 12020-07-31 18:02:51.021697+0800 iOS-OC之ARC[2134:984503] (null) ARC下多对象内存管理 ARC和MRC一样, 想拥有某个对象必须用强指针保存对象, 但是不需要在dealloc方法中release 1234567@interface Person : NSObject// MRC写法//@property (nonatomic, retain) Dog *dog;// ARC写法@property (nonatomic, strong) Dog *dog;@end 自动释放池 概述 AutoreleasePool（自动释放池）是 OC 中的一种 内存自动回收机制。 当向一个对象发送 autorelease 消息时，会将对象加入到自动释放池，这个对象不会立即释放，而是等到 runloop休眠或超出autoreleasepool作用域 之后进行 释放。 MRC 下使用自动释放池 在MRC环境中使用自动释放池需要用到 NSAutoreleasePool 对象，其生命周期就相当于C语言变量的作用域。对于所有调用过 autorelease方法的对象，在废弃NSAutoreleasePool对象时，都将调用release实例方法。用源代码表示如下： 12345678910111213// MRC环境下的测试：// 第一步：生成并持有释放池NSAutoreleasePool对象;NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];// 第二步：调用对象的autorelease实例方法;id obj = [[NSObject alloc] init];[obj autorelease];// 第三步：废弃NSAutoreleasePool对象;[pool drain]; // 向pool管理的所有对象发送消息，相当于[obj release]// obj已经释放，再次调用会崩溃(Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT))NSLog(@&quot;打印obj：%@&quot;, obj); ARC 下使用自动释放池 ARC环境不能使用NSAutoreleasePool类也不能调用autorelease方法，代替它们实现对象自动释放的是 @autoreleasepool块。 12345// ARC环境下的测试：@autoreleasepool &#123; id obj = [[NSObject alloc] init]; NSLog(@&quot;打印obj：%@&quot;, obj); &#125; ARC 下 AutoReleasePool 内部实现使用@autoreleasepool{}我们在main函数中写入自动释放池相关的测试代码如下： 123456int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125; 为了探究释放池的底层实现，我们在终端使用 clang -rewrite-objc + 文件名命令将上述OC代码转化为 C++ 源码： 123456789int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_d37e0d_mi_0); &#125; // 大括号对应释放池的作用域 return 0;&#125; 在经过编译器 clang 命令转化后，我们看到的所谓的 @autoreleasePool块，其实对应着__AtAutoreleasePool的结构体。 分析结构体 __AtAutoreleasePool 的具体实现在源码中找到 __AtAutoreleasePool结构体 的实现代码，具体如下： 12345678extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; void * atautoreleasepoolobj;&#125;; __AtAutoreleasePool结构体包含了：构造函数、析构函数和一个对象； 构造函数内部调用：objc_autoreleasePoolPush() 方法，返回对象atautoreleasepoolobj 析构函数内部调用：objc_autoreleasePoolPop() 方法，传入对象atautoreleasepoolobj 分析main函数中 __autoreleasepool结构体实例的生命周期是这样的： __autoreleasepool是一个自动变量，其构造函数是在程序执行到声明这个对象的位置时调用的，而其析构函数则是在程序执行到离开这个对象的作用域时调用。所以，我们可以将上面main函数的代码简化如下： 12345678int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; void *atautoreleasepoolobj = objc_autoreleasePoolPush(); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kb_06b822gn59df4d1zt99361xw0000gn_T_main_d39a79_mi_0); objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; return 0;&#125; objc_autoreleasePoolPush 与 objc_autoreleasePoolPop进一步观察自动释放池构造函数与析构函数的实现，其实它们都只是对AutoreleasePoolPage 对应静态方法 push 和 pop 的封装： 1234567void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; 理解 AutoreleasePoolPageAutoreleasePoolPage 是一个 C++ 中的类，打开Runtime的源码工程，在NSObject.mm文件中可以找到它的定义，摘取其中的关键代码如下： 123456789101112131415161718192021class AutoreleasePoolPage &#123;# define EMPTY_POOL_PLACEHOLDER ((id*)1) // 空池占位# define POOL_BOUNDARY nil // 即哨兵对象 static pthread_key_t const key = AUTORELEASE_POOL_KEY; static uint8_t const SCRIBBLE = 0xA3; // 0xA3A3A3A3 after releasing static size_t const SIZE = #if PROTECT_AUTORELEASEPOOL PAGE_MAX_SIZE; // must be multiple of vm page size#else PAGE_MAX_SIZE; // size and alignment, power of 2#endif static size_t const COUNT = SIZE / sizeof(id); magic_t const magic; // 校验AutoreleasePagePoolPage结构是否完整 id *next; // 指向新加入的autorelease对象的下一个位置，初始化时指向begin() pthread_t const thread; // 当前所在线程，AutoreleasePool是和线程一一对应的 AutoreleasePoolPage * const parent; // 指向父节点page，第一个结点的parent值为nil AutoreleasePoolPage *child; // 指向子节点page，最后一个结点的child值为nil uint32_t const depth; // 链表深度，节点个数 uint32_t hiwat; // 数据容纳的一个上限 //......&#125;; AutoreleasePoolPage 中拥有 parent 和 child 指针，分别指向上一个和下一个 page；当前一个page的空间被占满(每个AutorelePoolPage的大小为4096字节)时，就会新建一个AutorelePoolPage对象并连接到链表中，后来的Autorelease对象也会添加到新的page中；另外，当next&#x3D;&#x3D; begin()时，表示AutoreleasePoolPage为空；当next &#x3D;&#x3D; end()，表示AutoreleasePoolPage已满。 理解 哨兵对象(POOL_BOUNDARY)的作用，而它的作用事实上也就是为了 起到一个标识的作用。 每当自动释放池初始化调用 objc_autoreleasePoolPush 方法时，总会通过 AutoreleasePoolPage 的 push 方法，将 POOL_BOUNDARY 放到当前 page 的栈顶，并且返回这个对象 atautoreleasepoolobj； 而在自动释放池释放调用 objc_autoreleasePoolPop 方法时，又会将 atautoreleasepoolobj对象 以参数传入，这样自动释放池就会向释放池中对象发送release消息，直至找到第一个边界对象为止。 理解 objc_autoreleasePoolPush 方法经过前面的分析，objc_autoreleasePoolPush 最终调用的是 AutoreleasePoolPage 的 push 方法，该方法的具体实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static inline void *push() &#123; return autoreleaseFast(POOL_BOUNDARY);&#125;static inline id *autoreleaseFast(id obj)&#123; AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123; return page-&gt;add(obj); &#125; else if (page) &#123; return autoreleaseFullPage(obj, page); &#125; else &#123;1. return autoreleaseNoPage(obj); &#125;&#125;// 压栈操作：将对象加入AutoreleaseNoPage并移动栈顶的指针id *add(id obj) &#123; id *ret = next; *next = obj; next++; return ret;&#125;// 当前hotPage已满时调用static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123; do &#123; if (page-&gt;child) page = page-&gt;child; else page = new AutoreleasePoolPage(page); &#125; while (page-&gt;full()); setHotPage(page); return page-&gt;add(obj);&#125;// 当前hotpage不存在时调用static id *autoreleaseNoPage(id obj) &#123; AutoreleasePoolPage *page = new AutoreleasePoolPage(nil); setHotPage(page); if (obj != POOL_SENTINEL) &#123; page-&gt;add(POOL_SENTINEL); &#125; return page-&gt;add(obj);&#125; 观察上述代码，每次调用 push 其实就是 创建一个新的AutoreleasePoolPage，在对应的AutoreleasePoolPage中插入一个 POOL_BOUNDARY ，并且返回插入的 POOL_BOUNDARY 的内存地址。自动释放池最终都会通过 page-&gt;add(obj) 方法 将对象添加到page中，而这一过程被分为三种情况： * 当前page存在且不满，调用 `page-&gt;add(obj)` 方法将 `对象` 添加至page的栈中，即next指向的位置 * 当前page存在但是已满，调用 autoreleaseFullPage 初始化一个新的 page，调用page-&gt;add(obj)方法将对象添加至page的栈中 * 当前page不存在时，调用 autoreleaseNoPage 创建一个 hotPage，再调用page-&gt;add(obj) 方法将对象添加至page的栈中 理解 objc_autoreleasePoolPop 方法 AutoreleasePool 的释放调用的是 objc_autoreleasePoolPop 方法，此时需要传入 atautoreleasepoolobj 对象作为参数。 同理，我们找到 objc_autoreleasePoolPop 最终调用的方法，即 AutoreleasePoolPage 的pop方法，该方法的具体实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041static inline void pop(void *token) // POOL_BOUNDARY的地址&#123; AutoreleasePoolPage *page; id *stop; page = pageForPointer(token); // 通过POOL_BOUNDARY找到对应的page stop = (id *)token; if (DebugPoolAllocation &amp;&amp; *stop != POOL_SENTINEL) &#123; // This check is not valid with DebugPoolAllocation off // after an autorelease with a pool page but no pool in place. _objc_fatal(&quot;invalid or prematurely-freed autorelease pool %p; &quot;, token); &#125; if (PrintPoolHiwat) printHiwat(); // 记录最高水位标记 page-&gt;releaseUntil(stop); // 向栈中的对象发送release消息，直到遇到第一个哨兵对象 // memory: delete empty children // 删除空掉的节点 if (DebugPoolAllocation &amp;&amp; page-&gt;empty()) &#123; // special case: delete everything during page-per-pool debugging AutoreleasePoolPage *parent = page-&gt;parent; page-&gt;kill(); setHotPage(parent); &#125; else if (DebugMissingPools &amp;&amp; page-&gt;empty() &amp;&amp; !page-&gt;parent) &#123; // special case: delete everything for pop(top) // when debugging missing autorelease pools page-&gt;kill(); setHotPage(nil); &#125; else if (page-&gt;child) &#123; // hysteresis: keep one empty child if page is more than half full if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125; &#125;&#125; 【总结】【结构】： 自动释放池的压栈和出栈，通过结构体的构造函数和析构函数实现： 压栈：调用 objc_autoreleasePoolPush() 函数，内部调用的是 AutoreleasePoolPage 的 push() 方法，返回 atautoreleasepoolobj 对象 出栈：调用 objc_autoreleasePololPop() 函数，内部调用的是 AutoreleasePoolPage 的 pop() 方法，传入 atautoreleasepoolobj 对象 【容量】： 池页大小为4096字节，每一页都包含56字节的成员变量，但一个自动释放池中，只会压栈一个哨兵对象，占8字节 【原理】： 自动释放池的本质是 __AtAutoreleasePool 结构体，包含构造函数和析构函数 结构体声明，触发构造函数，调用 objc_autoreleasePoolPush() 函数，对象压栈 如果存在page，并且没有存满，调用add函数 将对象压栈 如果存在page，但存储已满，调用autoreleaseFullPage函数 遍历链表，找到最后一个空白的子页面 对其进行创建新页 设置为热页面 添加对象 否则，不存在page，调用autoreleaseNoPage函数 通过父类AutoreleasePoolPageData进行初始化 begin：获取对象压栈的起始位置 objc_thread_self：通过tls获取当前线程 链接双向链表 设置为热页面 pushExtraBoundary为YES，哨兵对象压栈 对象压栈 结构体出作用域，触发析构函数，调用 objc_autoreleasePoolPop() 函数，对象出栈 调用popPage函数，传入stop为哨兵对象的位置 当前页中对象出栈，到stop位置停止 调用kill函数，销毁当前页面 AutoreleasePool在主线程上的释放时机 分析主线程RunLoop管理自动释放池并释放对象的详细过程，我们在如下Demo中的主线程中设置断点，并执行lldb命令：po [NSRunLoop currentRunLoop]，具体效果如下： 我们看到主线程RunLoop中有两个与自动释放池相关的Observer,对应CFRunLoopActivity的类型如下: 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), //0x1，启动Runloop循环 kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //0xa0，即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), kCFRunLoopExit = (1UL &lt;&lt; 7), //0xa0，退出RunLoop循环 kCFRunLoopAllActivities = 0x0FFFFFFFU &#125;; 结合RunLoop监听的事件类型，分析主线程上自动释放池的使用过程如下： App启动后，苹果在主线程RunLoop里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler(); 第一个Observer监视的事件 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。 第二个Observer监视了两个事件 : BeforeWaiting(准备进入休眠) 时调用 _objc_autoreleasePoolPop() 和_objc_autoreleasePoolPush() 释放旧的池并创建新池； Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄漏，开发者也不必显示创建AutoreleasePool了; 之后的时机 程序启动到加载完成后，主线程对应的RunLoop会停下来等待用户交互 用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。 RunLoop检测到事件后，就会创建自动释放池; 所有的延迟释放对象都会被添加到这个池子中; 在一次完整的运行循环结束之前，会向池中所有对象发送release消息，然后自动释放池被销毁; AutoreleasePool子线程上的释放时机子线程默认不开启RunLoop，那么其中的延时对象该如何释放呢？其实这依然要从Thread和AutoreleasePool的关系来考虑： 就是说，每一个线程都会维护自己的 Autoreleasepool栈，所以子线程虽然默认没有开启RunLoop，但是依然存在AutoreleasePool，在 子线程退出 的时候会去释放autorelease对象。 前面讲到过，ARC会根据一些情况进行优化，添加__autoreleasing修饰符，其实这就相当于对需要延时释放的对象调用了autorelease方法。从源码分析的角度来看，如果子线程中没有创建AutoreleasePool ，而一旦产生了Autorelease对象，就会调用autoreleaseNoPage方法自动创建hotpage，并将对象加入到其栈中。所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。 AutoreleasePool需要手动添加的情况 尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建 AutoreleasePool，而其中的延时对象将在当前释放池的作用域结束时释放。苹果文档中说明了三种情况，我们可能会需要手动添加自动释放池： 编写的不是基于UI框架的程序，例如命令行工具； 通过循环方式创建大量临时对象； 使用非Cocoa程序创建的子线程； 而在ARC环境下的实际开发中，我们最常遇到的也是第二种情况，以下面的代码为例： 1234567- (void)viewDidLoad &#123; [super viewDidLoad]; for (int i = 0; i &lt; 1000000; i++) &#123; NSObject *obj = [[NSObject alloc] init]; NSLog(@&quot;打印obj：%@&quot;, obj); &#125; &#125; 上述代码中，obj因为离开作用域所以会被加入最近一次创建的自动释放池中，而这个释放池就是主线程上的RunLoop管理的；因为for循环在当前线程没有执行完毕，Runloop也就没有完成当前这一次的迭代，所以导致大量对象被延时释放。释放池中的对象将会在viewDidAppear方法执行前就被销毁。在此情况下，我们就有必要通过手动干预的方式及时释放不需要的对象，减少内存消耗；优化的代码如下： 123456789- (void)viewDidLoad &#123; [super viewDidLoad]; for (int i = 0; i &lt; 1000000; i++) &#123; @autoreleasepool&#123; NSObject *obj = [[NSObject alloc] init]; NSLog(@&quot;打印obj：%@&quot;, obj); &#125; &#125; &#125;","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习02：文件导入#include,#import,@class区别","slug":"OC学习/OC学习02：文件导入#include,#import,@class区别","date":"2023-03-02T08:39:08.000Z","updated":"2023-03-02T10:13:48.926Z","comments":true,"path":"2023/03/02/OC学习/OC学习02：文件导入#include,#import,@class区别/","link":"","permalink":"https://www.bboyzj.cn/2023/03/02/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A002%EF%BC%9A%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5#include,#import,@class%E5%8C%BA%E5%88%AB/","excerpt":"","text":"前言 #include 、 #import 和 @class 都是用来 包含头文件 C/C++ 只能用 #include 包含头文件，没有 #import 和 @class OC 中 #include 、 #import 和 @class 都可以用 那么问题来了，三种包含头文件方式在 OC 中有什么区别呢？ include、import #include 会重复导入头文件，重复导入会报重复定义的错误；#import 不会重复导入头文件，允许交叉编译 #include &lt;xxx.h&gt; 或 #import &lt;xxx.h&gt; ：用于导入 系统自带文件，在 系统文件目录下查找 #include “xxx.h” 或 #import “xxx.h” ：用于导入 用户自定义的文件，查找顺序：用户文件目录 -&gt; 安装文件目录 -&gt; 系统文件目录，所以 “xxx.h” 一般用来导入用户自定义的文件 class @class XXXClassName ： 用于声明一个类，用于解决互相引用的问题（A引用B，B引用A） include 示例 A文件导入两次B文件：报重复定义错误 12345678910#import &lt;UIKit/UIKit.h&gt;// include 不允许重复导入两次#include &quot;VB.h&quot;#include &quot;VB.h&quot;NS_ASSUME_NONNULL_BEGIN@interface VA : UIView@end command + b 编译报错： A引用B，B引用C，A再引用C：同样 报重复定义错误，相当于A引用了两次C import 示例 导入两次A文件，不报错 123// 导入两次A文件#import &quot;A.h&quot;#import &quot;A.h&quot; class 使用场景 A类引用B类，B类引用A：互相引用报错 A.h文件 12345#import &lt;UIKit/UIKit.h&gt;#import &quot;B.h&quot;@interface A : UIView@property (nonatomic,strong)B * b;@end B.h文件 12345#import &lt;UIKit/UIKit.h&gt;#import &quot;A.h&quot;@interface B : UIView@property (nonatomic,strong)A * a;@end 可以用 @class 方式进行引用，一个用@class或者两个都用 @class 1234//#import &quot;A.h&quot;// class声明A@class A;","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"Blog-05：Picgo+Gitee图床","slug":"Blog搭建/Blog-05：Picgo-Gitee图床","date":"2023-03-01T11:25:22.000Z","updated":"2023-03-02T16:23:50.879Z","comments":true,"path":"2023/03/01/Blog搭建/Blog-05：Picgo-Gitee图床/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-05%EF%BC%9APicgo-Gitee%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"背景最近发现上传到 GitHub 上的图片大部分不能使用了，然后上网查了一下，应该是 DNS 的问题，网上也有很多解决方案，有兴趣的可以去网上找找，本文主要介绍 Picgo + Gitee 做图床。 Picgo 介绍picgo 是一款功能实用、操作简捷的图床工具，图床工具简单来说就是本地图片上传自动转换成链接的一款工具。 picgo 本体支持如下图床： 七牛图床 v1.0 腾讯云 COS v4\\v5 版本 v1.1 &amp; v1.5.0 又拍云 v1.2.0 GitHub v1.5.0 SM.MS V2 v2.3.0-beta.0 阿里云 OSS v1.6.0 Imgur v1.6.0 Tips: 本体不再增加默认的图床支持。你可以自行开发第三方图床插件。 特色功能 支持拖拽图片上传 支持快捷键上传剪贴板里第一张图片 Windows 和 macOS 支持右键图片文件通过菜单上传 (v2.1.0+) 上传图片后自动复制链接到剪贴板 支持自定义复制到剪贴板的链接格式 支持修改快捷键，默认快速上传快捷键：command+shift+p（macOS） | control+shift+p（Windows\\Linux） 支持插件系统，已有插件支持 Gitee、青云等第三方图床 Tips: 请确保你安装了 Node.js， 并且版本 &gt;&#x3D; 8。 默认上传图床为 SM.MS。picgo 上传之后，会自动将上传成功的 URL复制到你的剪贴板，支持5种复制格式。 Mini窗口只支持Windows（圆形）和Linux（方形），macOS可以使用顶部栏图标。（因为Windows和Linux的任务栏不支持拖拽事件） 准备 nodejs 环境 picgo 客户端 picgo 的 Gitee 上传插件 git、Gitee 账号和一个公开仓库 安装 nodejs官网 安装 点击链接下载安装 nodejs，安装完成后，查看版本 12345mac@bogon ~ % node -vv18.14.2mac@bogon ~ % npm -vmac@bogon ~ % npm -v9.5.0 安装 picgo 客户端 picgo安装链接 如果电脑是 Intel 就选 x64，如果电脑是 M1 就选 arm64 安装 git Mac 默认是已经安装好了 git 注册&#x2F;登录 Gitee 账号 Gitee 首页按要求自行注册&#x2F;登录即可 新建一个 Gitee 仓库 仓库名：随意，如 Picgo私有创建 将仓库 开源 由于创建仓库的时候只能 私有，所以此步配置 开源 操作如下： 进入仓库 -&gt; 管理 -&gt; 基本信息 -&gt; 开源（空仓库不允许） -&gt; 保存 生成 Token Token 用于 picgo 操作 Gitee repository： 点击头像 -&gt; 设置 -&gt; 私人令牌 -&gt; 生成新令牌 -&gt; 提交 复制你生成的令牌，只显示一次，再次刷新则看不见了，因此你要保存好 配置 picgo 启动 picgo -&gt; 插件设置 -&gt; 搜索 Gitee -&gt; 点击插件图标 安装 即可，本文使用 gitee 2.0.5 插件来进行演示 Tips： 插件装完后，重启生效 配置 Gitee 插件进入 图床设置 -&gt; gitee， 依次填入相关配置如下所示，填写如下： repo： 用户名&#x2F;仓库名（必填）， bboy-zhang-jian/picgo path: 上传路径，仓库里的图片保存路径（非必填） token: 私人令牌（必填），刚才保存的 token message: 提交消息（非必填） path: 上传路径，仓库里的图片保存路径（非必填） customPath: 定制路径（非必填） customUrl: 图片定制URL（非必填） 将仓库开源头像 -&gt; 仓库 -&gt; 管理 -&gt; 公开 -&gt; 仓库公开须知全部 勾选 上传图片 将图片拖动到 上传区 里 快捷键 Ctrl + shift + p ERROR Plugin load failed: hexo-renderer-scss1mac@bogon Blog % npm install hexo-renderer-scss 出现 Error: Cannot find module ‘node-sass’1mac@bogon Blog % npm install node-sass 不用管了，版本不一致导致的","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"OC学习01：事件传递链和响应链","slug":"OC学习/OC学习01：事件传递链和响应链","date":"2023-03-01T09:30:34.000Z","updated":"2023-03-02T08:54:15.933Z","comments":true,"path":"2023/03/01/OC学习/OC学习01：事件传递链和响应链/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/","excerpt":"","text":"前言在 iOS 中只有继承 UIResponder 的 对象 才能够接收并处理事件，UIResponder 是所有响应对象的 基类。继承关系如下： UIApplication -&gt; UIResponder -&gt; NSObject UIViewController -&gt; UIResponder -&gt; NSObject UIWindow -&gt; UIViww -&gt; UIResponder -&gt; NSObject UIButton -&gt; UIControl -&gt; UIView -&gt; UIResponder -&gt; NSObject UIView -&gt; UIResponder -&gt; NSObject 事件链 传递链：由系统向离用户最近的view传递。顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; RootViewController -&gt; subViews 响应链：由离用户最近的view向系统传递。顺序： superViews –&gt; RootViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate 传递链 事件传递的两个核心方法 1234// 返回哪个视图进行事件响应- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event; // 判断某一个点击的位置是否在视图范围内- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event; 其中 UIView 不接受事件处理的情况有 hidden &#x3D; YES 视图被隐藏 userInteractionEnabled &#x3D; NO 不接受响应事件 alpha &lt;&#x3D; 0.01,透明视图不接收响应事件 子视图超出父视图范围 需响应视图被其他视图盖住 是否重写了其父视图以及自身的hitTest方法 是否重写了其父视图以及自身的pointInside方法 流程描述 当iOS程序发生触摸事件后，系统会利用 Runloop 将事件加入到 UIApplication 的任务队列中 UIApplication 分发触摸事件到 UIWindow 然后 UIWindow 依次向下分发给 UIView UIView 调用 hitTest:withEvent: 方法返回一个最终响应的视图 在 hitTest:withEvent: 方法中就会去调用 pointInside: withEvent: 去判断当前点击的 point 是否在 UIView 范围内，如果是的话，就会去 逆序遍历 它的子视图来查找最终响应的 子视图 遍历的方式是使用 倒序 的方式来遍历子视图，也就是说最后添加的子视图会最先遍历，在每一个视图中都会去调用它的 hitTest:withEvent: 方法，可以理解为是一个 递归调用 最终会返回一个响应视图，如果返回视图有值，那么这个视图就作为最终响应视图，结束整个事件传递；如果没有值，那么就会将UIView作为响应者 响应链响应者链的事件传递过程 如果 view 的控制器存在，就传递给控制器处理；如果控制器不存在，则传递给它的 父视图 在视图层次结构的最顶层，如果也不能处理收到的事件，则将事件传递给 UIWindow 对象进行处理 如果 UIWindow 对象也不处理，则将事件传递给 UIApplication 对象 如果 UIApplication 也不能处理该事件，则将该事件丢弃 面试题 实现一个按钮的点击范围扩大效果 思路：自定义一个按钮，重写 poinstInSide 方法，增大内边距，返回一个新的bounds 1234567891011#import &quot;ZJBtn.h&quot;@implementation ZJBtn- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; // 当前btn大小 CGRect btnBounds = self.bounds; // 扩大按钮的点击范围，增大内边距 btnBounds = CGRectInset(btnBounds, -50, -50); // 若点击的点在新的bounds里，返回YES return CGRectContainsPoint(btnBounds, point);&#125;@end 子视图超过父视图部分仍然能响应 思路：正常情况下子视图超出部分是不能响应事件的，需重写 hitTest:withEvent 方法，指定 子视图 可点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#import &quot;VA.h&quot;@interface VA ()@property (nonatomic,strong)UIButton * btn;@end@implementation VA- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; [self addSubview:self.btn]; &#125; return self;&#125;- (void)clickBtn&#123; NSLog(@&quot;%s&quot;,__func__);&#125;- (UIButton *)btn&#123; if (!_btn) &#123; _btn = [[UIButton alloc] initWithFrame:CGRectMake(-50, 20, self.frame.size.width + 100, 100)]; _btn.backgroundColor = [UIColor blueColor]; [_btn addTarget:self action:@selector(clickBtn) forControlEvents:UIControlEventTouchUpInside]; &#125; return _btn;&#125;/* 子视图超过父视图部分，需要点击超出范围的部分也有相应 */- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // 判断btn能否接收事件 if (self.btn.userInteractionEnabled == NO || self.btn.hidden == YES || self.btn.alpha &lt;= 0.01) &#123; return nil; &#125; // 把当前点转换成btn坐标系上的点 CGPoint btnP = [self convertPoint:point toView:self.btn]; // 当触摸点在btn上时，才让按钮相应事件 if ([self.btn pointInside:btnP withEvent:event]) &#123; NSLog(@&quot;%@&quot;,NSStringFromCGPoint(btnP)); return self.btn; &#125; NSLog(@&quot;父视图相应&quot;); return [super hitTest:point withEvent:event];&#125;@end","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"iOS面试题：Swift","slug":"面试题/iOS面试题：Swift","date":"2023-03-01T08:57:50.000Z","updated":"2023-03-05T23:34:26.569Z","comments":true,"path":"2023/03/01/面试题/iOS面试题：Swift/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/%E9%9D%A2%E8%AF%95%E9%A2%98/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASwift/","excerpt":"","text":"swift 和 oc 的区别？ swift 是静态语言，有类型判断。OC 是动态语言。 swift 可以面向 函数、协议、对象 编程；oc以面向 对象 编程为主，可以引入 Reactive Cocoa类库 来进行函数式编程 Swift 是 类型安全 的语言。OC 不是类型安全的语言。 Swift 大部分都是 值类型，少部分是 引用类型。OC 有的是 值类型，有的是 指针类型。 swift类型？Swiift 值类型 和 引用类型的区别？特点？ swift的类型分为 值类型 和 引用类型。 值类型：在swift中定义的很多类型都是值类型：如 struct、enum、Int、Float、Bool、String、Array、Dictionary、String 等都是 值类型。 引用类型： class类型、closure闭包、函数 为引用类型 区别 值类型：传递和赋值 时是一个 副本，使用过程中不会影响 源数据 引用类型：传递和赋值 是 本身（内存地址），使用过程中会影响源数据 常用的关键字 final： 只能用于 类 中，修饰的 方法、属性，不能被重写 final 修饰的类，不能被继承 inout：输入输出形式参数 将函数的参数由 值类型 转为 引用类型 mutating：异变方法 默认情况下结构体和枚举，不允许修改属性，可以在 func 前加 mutating 指定可以修改属性 #available 用来判断平台和操作系统 @available 用于修饰 方法、属性、协议、扩展，用来表达它的可用性 闭包是什么？闭包作用？ 可以传递和引用的代码块 可以捕获和存储上下文的常量和变量 全局函数和内嵌函数时 特殊的闭包 闭包的类型函数和闭包都是 引用类型 尾随闭包：闭包作为函数最后一个参数 逃逸闭包：函数返回之后调用 @escaping 自动闭包：延迟执行 @autoclosure 属性观察者 willSet：会在该值被存储之前被调用，newValue didSet：会在一个新值被存储之后被调用，oldValue 什么是扩展？作用？ 扩展就是向一个 已有类、结构体或枚举 添加新功能 扩展可以向一个 类型 添加新的功能，不能重写已有的功能 添加 属性（存储、计算），方法（实例方法、类方法），构造器，下标脚本，嵌套类型，协议等。 什么是协议？作用？ 协议规定了 用来实现某一特定功能所必须的方法和属性 类、结构体、枚举 都可以遵循协议，提供具体的实现来完成协议定义的方法和功能 协议用于指定特定的 实例属性或类属性，而不用指定是 存储属性或计算属性，必须指定是只读还是可读可写 常用的三方框架 Alamofire：网络加载 SwiftyJSON：JSON解析 R.swift：使用资源文件 Snapkit：自动布局 MonkeyKing：将内容分享到社交平台 Kingfisher：网络图片加载和缓存","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-面试题","slug":"Swift-面试题","permalink":"https://www.bboyzj.cn/tags/Swift-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"iOS面试题：OC","slug":"面试题/iOS面试题：OC","date":"2023-03-01T08:57:33.000Z","updated":"2023-03-08T08:18:47.952Z","comments":true,"path":"2023/03/01/面试题/iOS面试题：OC/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/%E9%9D%A2%E8%AF%95%E9%A2%98/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AOC/","excerpt":"","text":"OC算法1. 冒泡排序1）依次比较相邻两个元素，顺序错误则交换位置；需要两层循环，外层循环控制趟数，内层循环控制比较次数 2）例子： 123456789101112NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;5&quot;,@&quot;4&quot;]]; // 外循环控制排序趟数,进行 array.count-1 趟 for (int i = 0; i &lt; arr.count; i ++) &#123; // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序 for (int j = 0; j &lt; arr.count - i - 1; j++) &#123; // 相邻元素比较，若逆序则交换 if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123; [arr exchangeObjectAtIndex:j withObjectAtIndex:j + 1]; &#125; &#125; &#125; 2. 选择排序1）从第一个元素与其他元素比较找到最小值，重复操作，直到最后一位结束；需要两层循环，外层循环趟数，里层循环比较次数 2）例子 1234567891011NSMutableArray * arr = [NSMutableArray arrayWithObjects:@&quot;2&quot;,@&quot;1&quot;,@&quot;5&quot;,@&quot;3&quot;, nil];// 外循环控制排序趟数,进行 array.count-1 趟for (int i = 0; i &lt; arr.count; i ++) &#123; // 里循环获比较换位 for (int j = i + 1; j &lt; arr.count; j ++) &#123; if ([arr[i] intValue] &gt; [arr[j] intValue]) &#123; [arr exchangeObjectAtIndex:i withObjectAtIndex:j]; &#125; &#125;&#125;NSLog(@&quot;arr:%@&quot;,arr); 3. 直接插入排序1） 始终定义第一个元素为 已排序 的，将剩余元素定义为 未排序 逐个插入到 已排序 的排列中；不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去 2）例子 12345678910111213141516171819NSMutableArray * arr = @[@2,@1,@3,@5,@4].mutableCopy;// 插入排序的原理：始终定义第一个元素为有序的，将元素逐个插入到有序的排列中// 其特点是：不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去for(int i = 0;i &lt; arr.count;i++)&#123; // 待排序值 NSNumber * temp = arr[i]; // 已排序下标 int j = i - 1; // 待排序与已排序比较，从后向前比较 while (j &gt;= 0 &amp;&amp; [arr[j] integerValue] &gt; [temp integerValue]) &#123; // 如果已排序的 &gt; 待排序的 往后移动一个位置 [arr replaceObjectAtIndex:(j + 1) withObject:arr[j]]; j --; &#125; // 空出来的位置插入新元素 [arr replaceObjectAtIndex:(j + 1) withObject:temp]; NSLog(@&quot;arr:%@&quot;,arr);&#125; 打印结果： 12345672022-12-13 10:26:19.242271+0800 插入排序[4184:77845] arr:( 1, 2, 3, 4, 5) 4. 希尔排序1）希尔排序相当于 直接插入排序加强版，引入了 增量 的概念；直到增量为 1 时，再进行直接插入排序 2）例子 1234567891011121314151617181920212223NSMutableArray * arr = @[@7,@3,@8,@5,@2,@6,@1,@4].mutableCopy;// 其实间隔值设值为总数的一半int gap = arr.count/2;// 直到间隔小于1时结束while (gap &gt;= 1) &#123; // i 待排元素，以 步距 gap 从后向前扫描 for(int i = 0;i &lt; arr.count;i++)&#123; // 待排元素 NSNumber * temp = arr[i]; // 当前位置 int j = i; // 跳跃式比较 while (j &gt;= gap &amp;&amp; [arr[j - gap] integerValue] &gt; [temp integerValue] ) &#123; [arr replaceObjectAtIndex:j withObject:arr[j - gap]]; j -= gap; &#125; // 空出来位置，插入待排序 [arr replaceObjectAtIndex:j withObject:temp]; &#125; // 改变步长 gap = gap/2;&#125;NSLog(@&quot;arr:%@&quot;,arr); 打印结果： 123456789102022-12-13 10:22:41.910840+0800 插入排序[4124:74568] arr:( 1, 2, 3, 4, 5, 6, 7, 8) 5. 斐波那契数列1）也就是 兔子数列，当前数是前两个数列之和 2）例子 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; NSInteger num = 10; NSInteger total = [self getTotalNum:num]; NSLog(@&quot;total:%ld&quot;,total);&#125;- (NSInteger)getTotalNum:(NSInteger)num&#123; if(num == 0)&#123; return 0; &#125; if(num == 1)&#123; return 1; &#125; return [self getTotalNum:num-2] + [self getTotalNum:num-1];&#125; 打印结果： 12022-12-13 10:28:32.672554+0800 斐波那契数列[4285:80606] total:89 6. 二分查找1）有序的数组，将数组分割成两份，利用查找的值跟中间值进行比较，如果查找的值大于中间值，就在数组的右边进行查找；如果查找的值小于中间值，就在数组的左边进行查找。如此循环的执行下去，最终找到符合的值。 2）例子 123456789101112131415161718192021222324NSArray * arr = @[@(1),@(3),@(5),@(6),@(8),@(10)];int key = [@(5) intValue];int min = 0;int max = arr.count - 1;int mid;while (min &lt;= max) &#123; // 计算中间下标 mid = (min + max) / 2; // 如果目标值 &gt; 中间下标的中间值 if (key &gt; [arr[mid] intValue]) &#123; //最小变为中间下标+1 min = mid + 1; &#125; // 如果目标值 &lt; 中间下标的中间值 else if (key &lt; [arr[mid] intValue])&#123; //最大变为中间下标-1 max = max - 1; &#125; // 否则，正好 else &#123; NSLog(@&quot;key:%d&quot;,mid); break; &#125;&#125; 打印结果： 12022-12-13 10:33:18.661324+0800 二分查找[4607:86953] key:2 7. 递归算法递归求和1+2+..+n? 1234567891011121314- (void)viewDidLoad &#123; [super viewDidLoad]; int sum = [self sum:4]; NSLog(@&quot;sum:%d&quot;,sum);&#125;- (int)sum:(int)n&#123; if (n == 1) &#123; return 1; &#125;else &#123; return [self sum:n-1] + n; &#125;&#125; 链表OC数据结构01：链表的探索 二叉树OC数据结构02：二叉树探索 OC常见的面试题什么是野指针？是一个没有指向 任何内存 的 指针，尝试使用它会导致 应用程序崩溃 什么是内存泄漏？一个 对象 没有被释放，会 内存泄漏，内存泄漏会导致应用程序占用的内存会越来越大，直到应用程序无内存可用时，会导致 应用程序崩溃 iOS 关键词有哪些？各有什么作用？ 重点 readwrite 可读可写 特性，同时生成get方法和set方法的声明和实现 readonly 只读 特性，只会生成get方法的声明和实现，不希望属性在类外改变 retain 持有 特性，retaincount 会 +1,用于 MRC nonatomic 非原子 特性 atomic 原子 特性，默认属性 atomic不是绝对线程安全的，只是对 setter/getter 方法使用了 自旋锁(spinlock_t)，内部使用 互斥锁(os_unfair_lock)，保证了 读/写 安全。 atomic并不能保证 整个对象 是线程安全的，需要对 整个对象 进行 加锁 来保证线程安全： * NSLock（互斥锁） * dispathch_semaphore（信号量） * @synchronized（互斥递归锁） assign 可以修饰 基本数据类型和对象。 通常用于修饰 基本数据类型，如Int、CGFloat、Double等，这是因为 基本数据类型放在栈区，栈由编译器自动分配和释放内存，栈先进后出，基本数据类型出栈后，assign修饰的基本数据类型就不存在了，不会出现 野指针 修饰对象，如NSString、实例对象等，引用计数不会增加，但 assign 修饰对象释放后，指针 不会被系统置为nil，会产生 野指针 或 EXC_BAD_ACCESS 错误。 strong 强引用，只修饰对象，属性默认修饰符 指向并持有该对象，其修饰的对象引用计数会 +1，引用计数不为 0 则不会被销毁，需要将其置为 nil 可以销毁。否则会出现 内存泄漏。 weak 弱引用，只修饰对象。 指向但并不拥有该对象，引用计数不增加。该对象自动在内存中销毁。 copy 用于修饰 不可变的对象。 比如NSString、NSDictionary、NSArray等。 浅拷贝和深拷贝 重点 浅拷贝 浅拷贝，拷贝了一个新的指针，与原对象指针指向同一块内存，引用计数 + 1；(A,CopyA &#x3D; [A copy]，A 变化，CopyA 的值也变化) 深拷贝 深拷贝，拷贝了一个新的对象，指向新的内存，新对象的 引用计数为 1，源对象引用计数不变；(A,MutableA &#x3D; [A mutbleCopy]，A 变化，MutableA 的值不变)。 NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？重点 对于不可变NSString&#x2F;NSArray&#x2F;NSDictionary，copy浅拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝) 对于可变NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary，copy深拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝) 自定义对象的copy和mutableCopy？ 重点 copy和mutableCopy都是深拷贝(属性：浅拷贝） 属性用copy还是strong？ 重点 对于不可变属性，推荐用copy，目的是为了 让本属性不受外界影响，无论给我传入可变还是不可变对象，我本身持有的就是一个不可变的副本，被set时，改变的是这个副本。 对于可变属性，推荐用strong，因为copy修饰后，会变成不可变对象，再调用可变对象函数时会 crash 一个APP是如何唤醒另一个APP的？ 重点URL Scheme：iOS有一个特性就是将 自身绑定 到一个自定义的 URL Scheme 上，该 scheme 用于从 浏览器或其他应用中启动本应用。 单例的写法和作用？ 重点单例模式的作用：可以保证程序运行过程中，一个类只返回一个实例，供外界访问；static保证类只分配一次内存；dispatch_once方法保证调用一次，并自动加锁，线程安全 123456789101112static id _instance = nil; // 定义static全局变量，保证只分配一次内存+ (id)shareInstance&#123; return [[self alloc] init];&#125;+ (id)copyWithZone:(struct _NSZone *)zone&#123; static dispatch_once_t onceToken; // 声明一个静态的GcD单次任务 // 保证只执行一次 dispatch_once(&amp;onceToken,^&#123; // _instance = [super allocWithZone:zone]; &#125;); return p;&#125; 这么写可以保证下面两种方式返回同一个实例： 123Single * p1 = [Single shareInstance];Single * p2 = [[Single alloc] init];NSLog(@&quot;%d&quot;,p1==p2); // 1 常用的数据存储方式有哪些？各自的优缺点？ plist：plist文件是将某些特定的类，通过 XML文件 的方式保存在目录中。 NSUserdefault：归档 数据库：适合储存数据量较大的数据,一般使用FMDB和CoreData来实现. Keychain：用于 本地重要数据的存储，将数据加密后存储在本地。如：密码,秘钥,序列号 等,当你 删除APP后Keychain存储的数据不会删除，所以在重装App后，Keychain里的数据还能使用。 沙盒写入：存储非机密数据 Application：存放程序源文件，上架前经过数字签名，上架后不可修改。 Documents: 保存应⽤运行时生成的需要持久化的数据。iTunes 同步设备时会 备份 该目录。 tmp: 保存应⽤运行时所需的临时数据，使⽤完毕后再将相应的文件从该目录删除。iTunes 同步设备时 不会备份 该目录。 Library&#x2F;Caches: 保存应用运行时⽣成的需要持久化的数据。 iTunes 同步设备时 不会备份 该目录。 Library&#x2F;Preference: 保存应用的所有偏好设置。iTunes 同步设备时会 备份 该目录。 加密方式有哪些？各自的加密算法哪些？ 对称加密：又称公开密钥加密，加密和解密 都会用到 同一个密钥。常见的对称加密算法有 DES、3DES、AES、Blowfish、IDEA、RC5、RC6。 非对称加密：非对称加密又称 共享密钥加密，使用 一对非对称的密钥，一把叫做 私有密钥，另一把叫做 公有密钥；公钥加密只能用私钥来解密，私钥加密只能用公钥来解密。常见的有：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法。 成员变量和实例变量区别？ 成员变量：在文件中@interface下{}内的均统称为 成员变量 实例变量：实例变量是 类定义 的变量 区别： 去除基本数据类型int,float…等，其他类型的变量均叫做 实例变量 成员变量 = 实例变量 + 基本数据类型 @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的? @property &#x3D; _ivar + getter + setter; property（属性）&#x3D; _ivar（实例变量）+ setter（存方法）+ getter（取方法） 属性引用self.name与_name的区别？ self.name是对属性的访问，&#x3D; 左侧是调用setter方法，&#x3D; 右侧是调用getter方法，可以在类外使用，_name不能在类外使用。 _name是对 局部变量 的访问，直接调用变量，不通过getter方法 frame 和 bounds 区别？ frame：参考系是父视图坐标 bounds：参考系是自身坐标 常见的状态码？ 2xx 成功：200表示请求正常。 3xx 重定向：302是请求重定向。解决方法 NSURLConnetion 和 NSURLSession 进行拦截 4xx 客户端错误：400客户端请求的语法错误，404Not Found 找不到&#x2F;请求失败 5xx 服务器错误：500 Internal Server Error 服务器的内部错误 HTTPS和HTTP的区别？ 重点 HTTP：超文本传输协议，信息明文传输；端口号80；响应速度快（使用TCP三次握手，客户端和服务端需要交换3个包）； HTTPS：是由 HTTP+SSL&#x2F;TLS 加密传输；端口号443；响应速度慢（除了使用TCP三个包，还要加上SSL握手的9个包）；需要到CA申请证书 TCP 和 UDP 区别? 重点 都是 传输层 协议 TCP协议是 面向连接的可靠的传输层协议。UDP协议是 面向非连接的传输层协议 TCP需要 建立连接和断开连接。UDP不需要连接。 TCP传 输数据没有大小限制。UDP 传输数据有大小限制。 TCP会 处理数据丢包重发。UDP不会处理。 HTTP和socket区别？ 重点 HTTP 应用层协议；socket 不属于协议范畴，而是一个接口（API），是对TCP&#x2F;IP协议的封装 HTTP 是基于 请求-响应 形式 短连接，即客户端发送一次请求，服务端响应后立即 断开连接；socket 是基于TCP协议的 长链接，理论上 客户端和服务端一旦建立连接将不会主动断开 HTTP 传输慢，数据量大，安全差；socket 数据可自定义，数据量小，安全性高，适合信息实时交互（推送、聊天等） staitc 和 const 的区别？ 重点 const：表示 只读 的意思 const 放在 类型 前：可以改变指针的指向，可以改变指针指向的内容 const 放在 变量 前：不可以改变指针的指向，不可以改变指针指向的内容 static： 静态变量，可修饰 局部变量和全局变量，可修饰方法 static 可修饰 局部/全局变量，称为 局部静态变量和全局静态变量，只初始化一次，只分配一次内存，生命周期被改变，不再是作用域内 static 修饰的 方法，可以在不同文件下重名，互不影响运行 通用链接（Universal Links）重点 服务端配置 HTTPS 证书 和添加 apple-app-site-association 地址关联文件 移动端在plist添加 Associated Domains 关联域权限 简述GET和POST请求的区别？ 重点 GET 传输数据 有缓存；POST 传输数据 没有缓存 GET的 参数 放在 URL 的后面，并且第一个参数用 ? 号拼接，后面的从第二个参数开始，直到最后一个，用 &amp; 分割；POST的 参数 放在 请求体 里面，并且第一个参数用 , 号拼接，后面从第二开始，直到最后用 &amp; 分割; GET一般用于 获取数据；POST一般用于 向服务器提交数据 GET 的参数是暴漏在 地址栏 的，不安全；POST 的参数隐藏在 请求体 里面，相对安全一点; iOS中几种常见的设计模式？ 重点 代理模式 一对一的依赖关系，当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。 观察者模式 KVO机制 和 Notification通知机制 单例模式 保证程序运行过程中，一个类只返回一个实例，供外界访问 工厂模式 通过一个类方法，根据已有模板批量生产对象。 MVC模式 Model即数据模型 view即视图 controller即控制器 RunLoop是什么？ 重点 概念 RunLoop 又叫 运行循环，内部就是一个 do-while循环，在这个循环内部不断 处理各种任务，保证程序持续运行。 目的 RunLoop存在的目的： 就是当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，提高程序性能，节省CPU资源，该做事的时候做事，该休息的时候休息 RunLoop的作用？ 重点 保持程序持续运行。 App一启动就会开启主线程，主线程在开启的时候就会开启主线程对应的RunLoop，RunLoop能保证线程不被销毁，主线程不销毁，程序就会持续运行。 处理App中各类事件。 事件响应、手势识别、界面刷新、AutoreleasePool自动释放池、NSTimer等事件处理。 节省CPU资源，提高程序性能。 如概述所述，当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，提高程序性能，节省资源，该做事的时候做事，该休息的时候休息。 可以用Runloop实现什么功能？ 重点 tableView 滚动时图片不加载 SDWebImage + Runloop，图片延迟加载，滑动不加载图片 线程保活 往 runloop 中添加 [[NSPort alloc] init] 事件， 解决NSTimer在滑动时停止工作的问题 default 模式改为 common 模式 检测卡顿 displaylink + runloop 进行卡顿检测，将数值和页面绑定上传到服务器 RunLoop接收几种输入源，系统默认定义了几种模式？ 重点 输入源有两种基于 端口 的输入源（port）自定义 的输入源（custom） 系统定义的RunLoop模式有五种，最常用的有三种，如下所示：NSDefaultRunLoopMode默认模式，主线程中默认是NSDefaultRunLoopModeUITrackingRunLoopMode视图滚动模式，RunLoop会处于该模式下NSRunLoopCommonModes并不是真正意义上的Mode，是一个占位用的“Mode”，默认包含了NSDefaultRunLoopMode和UITrackingRunLoopMode两种模式 RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？ 重点 每一个线程都有一个runloop，主线程的runloop默认启动。子线程的runloop默认不启动 mode：主要用来指定事件在运行时循环的优先级 作用：保持程序的持续运行、随时处理各种事件、节省cpu资源(没事件休息释放资源)，提高程序的性能。 怎么理解Objective-C是动态运行时语言。 重点主要是 将数据类型的确定和函数的调用由编译时推迟到了运行时。这个问题其实浅涉及到两个概念，运行时和多态。 运行时：简单来说，运行时机制使我们 直到运行时才去确定数据类型和要调用的函数。 多态：不同对象以自己的方式响应相同的消息的能力 叫做多态。 runtime项目中具体应用？ 重点 方法交换。 给 分类添加属性。 动态添加方法。 字典转模型。 数组越界。 动态获取成员属性、成员变量、实例方法 KVC是什么？重点KVC 全程 Key Value Coding，中文 键值编码，是由 NSKeyValueCoding 非正式协议启动的一种机制，对象 采用该协议来 间接访问对象的属性。 12345- (nullable id)valueForKey:(NSString *)key; - (nullable id)valueForKeyPath:(NSString *)keyPath; - (void)setValue:(nullable id)value forKey:(NSString *)key;- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; KVC底层原理： KVO是什么？重点KVO 全程 Key Value Observing，中文 键值观察，它 用于监听实例对象属性的变化。 KVO的实现原理？(KVO的本质是什么？) 重点当一个 实例对象 的 属性注册了KVO，实例对象 isa指针 的指向在注册KVO观察者之后，由 原有类 改为 中间类(NSKVONotifing_类名)；中间类 重写了 属性setter方法、class、dealloc、_isKVOA 方法；dealloc 方法中，移除 KVO 观察者之后，实例对象isa 指向由 中间类 更改为 原有类;中间类 从创建后就 一直存在内存中，不会被销毁。 KVO实际应用 重点 观察 实例对象 的 属性 变化 观察 实例对象 的 容器 变化 观察容器用： mutableArrayValueForKey KVO底层原理： category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？重点 category 原则上它 只能增加方法，不能增加成员（实例）变量。可以添加属性，但是不会自动生成实例变量_name和setter和getter方法。可以添加方法 扩展 主要用来为一个类添加额外的原来没有的 实例变量、方法和属性。extension常用的形式并不是以一个单独的.h文件存在，而是寄生在类的.m文件中。 类扩展中： 123456@interface Person ()&#123; int age; //实例变量&#125;@property (nonatomic,copy)NSString * name;//属性- (void)run;//方法@end iOS开发中有多少类型的线程？ 重点 pthread 一套用于 C 的多线程 API、适用于 Unix / Linux / Windows 等系统、跨平台、可移植、使用难度大 NSThread 使用更加面向对象、简单易用，可直接操作线程对象 GCD 旨在替代NSThread等线程技术、充分利用设备的 多核、基于 C 的底层的 API NSOperation NSOperation 是基于 GCD 之上的更高一层的封装， NSOpetation 需要配合 NSOpetationQueue 来实现多线程 根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？ 重点dispatch_group_t + dispatch_group_enter + dispatch_group_leave + dispatch_group_notify 10个网络请求顺序回调? GCD如何实现？重点dispatch_group_t + dispatch_semaphore_t：信号量（dispatch_semaphore_wait + dispatch_group_leave） GCD和NSOperation的区别？ 重点 GCD执行效率更高，而且由于队列中执行的是由block构成的任务，这是一个轻量级的数据结构，写起来更方便 GCD只支持FIFO的队列，而 NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序 NSOperationQueue甚至可以跨队列设置依赖关系，但是GCD只能通过设置串行队列，或者在队列内添加barrier(dispatch_barrier_async)任务，才能控制执行顺序,较为复杂 NSOperationQueue因为面向对象，所以 支持KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished）、是否取消（isCanceld） 具体的底层看 OC底层原理27：GCD之 NSThread &amp; GCD &amp; NSOperation 什么是Block？ 重点Block 是将 函数及其上下文封装起来的对象 Block的本质 重点 block 的 本质 是 对象、函数、结构体，由于block函数没有名称，也被称为 匿名函数 Block的分类？ 重点 分为 全局Block(_NSConcreteGlobalBlock)、栈Block(_NSConcreteStackBlock)、堆Block(_NSConcreteMallocBlock) 三种形式。 其中 栈Block存储在栈(stack)区，堆Block存储在堆(heap)区，全局Block存储在已初始化数据(.data)区。 堆：动态分配内存，需要程序员自己申请，程序员自己管理 栈：自动分配内存，自动销毁，先入后出，栈上的内容存在自动销毁的情况 具体看底层原理 OC底层原理30：Block底层原理 循环引用的几种情况和解决方式？ 重点 Block 原因： self 强引用了 block，而 block 内部又调用了 self解决： 使用 Weak-Strong Dance Delegate 原因：委托者和被委托人之间的相互强引用问题 strong解决：用 weak 进行弱引用 或者 通过中间对象(代理对象)的方式来解决(效率更加高的中间对象NSProxy：不需要进行发送消息和动态解析，直接进行消息转发) NSTimer 原因：self → timer → self(target) 的循环持有链解决：在适当的时机销毁 12[_timer invalidate];_timer = nil; OC 如何进行内存管理的？ 重点 手动内存管理 MRC 自动内存管理 ARC LLVM + Runtime 会为我们代码自动插入 retain 和 release 以及 autorelease等代码,不需要我们手动管理 自动释放池 自动释放池原理 重点 自动释放池的本质是 __AtAutoreleasePool 结构体，包含构造函数和析构函数 结构体声明，触发构造函数，调用 objc_autoreleasePoolPush() 函数，对象压栈 结构体出作用域，触发析构函数，调用 objc_autoreleasePoolPop() 函数，对象出栈 内存优化 重点 cell复用 绘制的话：用CAShaperLayer，渲染快，内存使用高效 按需加载：懒加载 合理利用缓存：比如三方图片压缩缓存 尽量使用透明View：控件有背景色增大内存消耗 启动优化 重点 pre-main 阶段：二进制重排 尽量 少用外部动态库，苹果官方建议自定义的动态库最好 不要超过6个，如果超过6个，需要 合并 动态库 减少 OC 类，因为类越多，越耗时 将不必须在 +load 方法中做的事情延迟到 +initialize 中，尽量不要用 C++ 虚函数 main 阶段：mian -&gt; didFinishLaunching 减少启动初始化的流程，能懒加载的懒加载，能延迟的延迟，能放后台初始化的放后台，尽量少占用主线程的启动时间 优化代码逻辑，去除非必须的代码逻辑，减少每个流程的消耗时间 启动阶段能 使用多线程 来初始化的，就使用多线程 尽量 使用纯代码 来进行UI框架的搭建，尤其是主UI框架，例如 UITabBarController，尽量避免使用Xib或者SB，相比纯代码而言，这种更耗时 删除废弃类、方法 卡顿监听 重点主要是用 displayLink + Runloop 进行FPS监测 主要从减轻 CPU 和 GPU 消耗入手，保证写一个 VSync 到来时，CPU 和 GPU 能够写作完成下一帧的渲染并缓存到帧缓冲区 卡顿优化在 CPU 层面： 1）尽量用轻量级的对象，比如 用不到事件处理 的地方，可以考虑使用 CALayer 取代 UIView2）不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改3）尽量 提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性4）图片的 size 最好刚好跟 UIImageView 的 size 保持一致5）控制一下线程的最大并发数量6）尽量把 耗时的操作放到子线程：如text宽高获取等 卡顿优化在 GPU层面： 1）GPU能处理的 最大纹理 尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸2）尽量 减少视图数量和层次3）减少透明的视图（alpha&lt;1），不透明的就设置 opaque 为 YES4）尽量 避免出现离屏渲染：圆角、阴影、遮罩等 tableView卡顿优化 重点 最常用的就是cell的复用， 注册复用标识符 避免cell的重新布局，初始化时就布局好 提前计算并缓存cell的高度 减少cell中控件的数量，少动态添加 view 避免背景透明 能使用局部更新 的就使用 局部更新 加载网络数据，下载图片，使用异步加载，并缓存 按需加载cell：cell滚动很快时，只加载范围内的cell 不要实现无用的代理方法，tableView只遵守两个协议 网络优化 重点 DNS优化：即域名解析优化，缓存 ip 资源优化： 图片webp，比png&#x2F;jpg小 数据传输用ProtocolBuffer代替json，数据小，序列化和反序列化也简单 请求压缩、请求合并 数据缓存 网络环境监测 针对性请求重试 TCP三次握手，四次挥手过程？重点 为什么是三次握手，而不是二次握手？ 三次握手是为了建立一个可靠的数据传输通道： 刚开始客户端和服务端处于关闭状态，而且服务端B一直处于监听状态，时刻监听是否有建立连接的请求 当客户端需要建立连接的时候就会发送一个 请求连接 的报文，此报文是 同步报文SYN=1，并且会生成一个 随机的序号seq=x，这是第一次握手 当服务端接收到请求连接报文时，会发送一个 确认连接 的报文，此报文是 同步报文SYN=1，并且 确认报文ACK=1，同时服务端也会生成一个 随机的序号seq=y，并且将 确认报文确认号ack=x+1，回传给客户端，这是第二次握手 当客户端接收到服务端的 ACK确认报文后，会回复一个 ACK确认报文，用于确认确认报文已经收到，此报文 ACK=1，seq=x+1，ack=y+1，这是第三次握手 四次挥手 四次挥手则是为了保证数据传输完成接收再关闭连接。 客户端断开连接时会发送一个 请求断开连接 的报文，此报文是 FIN=1，并且会生成一个 随机的序号seq=u，发送给服务端，这是第一次挥手 服务端接收到请求断开连接 FIN报文 后，回复一个 确认断开连接 报文 ACK=1,seq=v,ack=u+1，这是第二次挥手 当服务端数据发送完后，再发送一个FIN报文给客户端，通知客户端，服务端准备关闭连接，此报文 FIN=1,ACK=1,ack=u+1,seq=w，这是第三次挥手 当客户端收到 FIN确认报文，再发送一个FIN确认报文 ACK=1,seq=u+1,ack=w+1，并进入 TIME-WAIT 等待，等待 2MSL 后关闭连接，这是第四次挥手 事件链 重点OC学习01：事件传递链和响应链 传递链：由系统向离用户最近的view传递。顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; ViewController -&gt; subViews 响应链：由离用户最近的view向系统传递。顺序： superViews –&gt; ViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate 事件传递的两个核心方法？ 重点1234// 返回最适合处理事件的视图- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event; // 判断点是否在这个View内部- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event; 第一个方法返回的是一个 UIView，是用来寻找最终哪一个视图来响应这个事件 第二个方法是用来判断某一个点击的位置是否在视图范围内，如果在就返回YES 实现一个按钮的点击范围扩大效果 重点自定义一个按钮，继承UIButton，重写 pointInside:withEvent: 方法， 12345678- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; // 当前btn大小 CGRect btnBounds = self.bounds; // 扩大按钮的点击范围，增大内边距 btnBounds = CGRectInset(btnBounds, -10, -10); // 若点击的点在新的bounds里，返回YES return CGRectContainsPoint(btnBounds, point);&#125; 子视图超过父视图部分仍然能响应 重点重写 hitTest:withEvent 方法，让 子视图 去相应事件 123456789101112131415- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // 判断btn能否接收事件 if (self.btn.userInteractionEnabled == NO || self.btn.hidden == YES || self.btn.alpha &lt;= 0.01) &#123; return nil; &#125; // 把当前点转换成btn坐标系上的点 CGPoint btnP = [self convertPoint:point toView:self.btn]; // 当触摸点在btn上时，才让按钮相应事件 if ([self.btn pointInside:btnP withEvent:event]) &#123; NSLog(@&quot;%@&quot;,NSStringFromCGPoint(btnP)); return self.btn; &#125; NSLog(@&quot;父视图相应&quot;); return [super hitTest:point withEvent:event];&#125; 项目面试题直播功能怎么实现的？直播间是通过集成金山云SDK实现的，分为两端 主播 和 观众 主播 通过 推流 创建直播间，通过 摄像头和麦克风 获取 音视频流 ，设置 推流参数，主要是 视频编码器和音频编码率的设置，设置完推流参数之后，将流媒体推送服务器 观众 进入直播间，初始化播放器，从服务器获取播放拉流的数据 直播间的聊天IM实现？ 聊天功能是使用的融云SDK，通过加入聊天室实现的。 融云SDK实现了私聊的功能 自己写的聊天页面，通过 融云接口 传入参数 会话类型：单聊、群组。聊天室等，目标会话ID），消息数量，获取某个会话的内容。发送文本消息、图片消息，监听消息，刷新列表 面试官问还有什么想问的？ 重点技术面不问薪资待遇，人事面问薪资待遇 问岗位： 在这个岗位上，会直接 接触到哪些类型的项目？ 这个岗位的主要职责是什么？主要的KPI是什么？ 这个岗位如何评估绩效，试用期需要达到什么指标？ 这个岗位的最大挑战是什么？ 问团队： 团队的基本情况？ 这个团队在公司的角色是什么？ 可以跟我介绍一下我的领导吗？ 问公司 公司的文化氛围是什么样的？ 员工的晋升机制是什么样的？我这个岗位的晋升机会如何？ 这个岗位所在的团队如何支持公司目标的实现？","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-面试题","slug":"OC-面试题","permalink":"https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"Blog-04：主题完善","slug":"Blog搭建/Blog-04：主题完善","date":"2023-03-01T02:54:01.000Z","updated":"2023-03-01T17:50:03.426Z","comments":true,"path":"2023/03/01/Blog搭建/Blog-04：主题完善/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-04%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/","excerpt":"","text":"前言我们以 Snippet 主题问例 下载安装1mac@bogon Blog % $ git clone git://github.com/shenliyang/hexo-theme-snippet.git themes/hexo-theme-snippet 安装主题插件1mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S 部署主题具体部署看下面的链接：1、2、3步骤可省略 Snippet","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"Blog-03：Github域名绑定阿里云域名","slug":"Blog搭建/Blog-03：Github域名绑定阿里云域名","date":"2023-03-01T02:17:25.000Z","updated":"2023-03-06T23:34:33.444Z","comments":true,"path":"2023/03/01/Blog搭建/Blog-03：Github域名绑定阿里云域名/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-03%EF%BC%9AGithub%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/","excerpt":"","text":"注册域名去 阿里云 注册账号、并购买域名，具体流程这里就不一一介绍了 域名解析 在终端 ping 一下之前配置的静态页面地址,可以获取到对应的ip地址: 123456mac@bogon ~ % ping BboyZJ.github.ioPING bboyzj.github.io (185.199.109.153): 56 data bytes64 bytes from 185.199.109.153: icmp_seq=0 ttl=50 time=261.217 ms64 bytes from 185.199.109.153: icmp_seq=1 ttl=50 time=337.547 ms64 bytes from 185.199.109.153: icmp_seq=2 ttl=50 time=260.716 ms... @解析 记录类型：A主机记录：@解析请求来源：默认记录值：185.199.109.153TTL：10分钟 点击确定 www解析 记录类型：CNAME主机记录：www解析线路来源：默认记录值：BboyZJ.github.ioTTL：10分钟 点击确定 配置项目 CNAME 在 Blog/source 目录下，新建 CNAME 文件，内容输入阿里云申请的域名 www.bboyzj.cn 12mac@bogon ~ % cd /Users/mac/Desktop/Blog/source mac@bogon source % touch CNAME 配置 Blog 目录下 _config.yml 文件，URL 模块 123456789# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://www.bboyzj.cnroot: /BboyZJ.github.io/permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks 执行 123mac@bogon ~ % hexo cleanmac@bogon ~ % hexo gmac@bogon ~ % hexo d 提交陈成功后，就可以在 GitHub 和 www.bboyzj.cn 个人域名绑定上了","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"Blog-02：部署博客到GitHub","slug":"Blog搭建/Blog-02：部署博客到GitHub","date":"2023-03-01T01:12:01.000Z","updated":"2023-03-01T13:45:55.546Z","comments":true,"path":"2023/03/01/Blog搭建/Blog-02：部署博客到GitHub/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-02%EF%BC%9A%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0GitHub/","excerpt":"","text":"注册GitHub账号前往 Github 网站，注册一个新用户。用邮箱注册的一定前往邮箱去验证邮件。 部署到 GitHub 上 新建 reponsity 仓库 仓库名设置成 用户名.github.io ，比如我的是 BboyZJ.github.io，选择 Public，勾选 Add a README file ，最后 Create respository 配置秘钥 查看秘钥 123$ cd ~/.ssh$ ls$ cat id_rsa.pub 添加SSH秘钥：头像 -&gt; Setting -&gt; SSH and GPG keys Title 随意写，Key 需要填写刚才复制的 秘钥 文本内容 添加完成，验证链接 123mac@bogon ~ % ssh -T git@github.comHi BboyZJ! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 上传文件到 GitHub 配置 Blog 下 _config.yml 中的 Deployment 模块 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repository: https://github.com/BboyZJ/BboyZJ.github.io.git branch: master 安装部署插件 通过 Hexo 发布到 GitHub，需要安装部署插件 1mac@bogon ~ % npm install hexo-deployer-git --save 部署 123mac@bogon ~ % cd /Users/mac/Desktop/Blogmac@bogon ~ % hexo gmac@bogon ~ % hexo d 访问 这时我们的 GitHub 域名 https://BboyZJ.github.io 就可以看到 Hexo 网站了，如果没显示出来就 刷新 一下","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"Blog-01：Hexo个人博客搭建","slug":"Blog搭建/Blog-01：Hexo个人博客搭建","date":"2023-02-28T23:39:40.000Z","updated":"2023-03-02T17:14:57.071Z","comments":true,"path":"2023/03/01/Blog搭建/Blog-01：Hexo个人博客搭建/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-01%EF%BC%9AHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Hexo 什么是Hexo？ 简介：Hexo 是一个快速、简洁且高效的博客框架。想要详细的了解 Hexo ，去官网学习。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提 检查是否安装 homebrew 12345mac@bogon ~ % brew -vHomebrew 3.6.21-28-ge6548a8Homebrew/homebrew-core (git revision 5434c8344e8; last commit 2023-02-09)Homebrew/homebrew-cask (git revision 15c2c1fa53; last commit 2023-02-09)mac@bogon ~ % 如果顺利显示版本号，说明homebrew已经安装。否则，输入以下命令进行安装： 1mac@bogon ~ % ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装过程如果出现下面的问题 1curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused 解决: 1mac@bogon ~ % /usr/bin/ruby -e &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)&quot; 安装 Node.js 123mac@bogon ~ % brew install nodemac@bogon ~ % node -vv18.14.2 安装GitMac系统默认已经安装好了，所以不需要再安装 安装Hexo如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往安装 Hexo 步骤。 使用npm完成 hexo 安装 12345678910111213141516171819202122mac@bogon ~ % npm install -g hexo-climac@bogon ~ % hexo -vhexo-cli: 4.1.0os: Darwin 21.6.0 darwin x64node: 12.16.1v8: 7.8.279.23-node.31uv: 1.34.0zlib: 1.2.11brotli: 1.0.7ares: 1.15.0modules: 72nghttp2: 1.40.0napi: 5llhttp: 2.0.4http_parser: 2.9.3openssl: 1.1.1dcldr: 35.1icu: 64.2tz: 2019cunicode: 12.1mac@bogon ~ % 建站 桌面新建 Blog 文件夹，打开终端，cd到 Blog 下，执行: 123456789101112mac@bogon ~ % cd /Users/mac/Desktop/Blog mac@bogon Blog % hexo initINFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO Install dependenciesnpm notice npm notice New major version of npm available! 7.3.0 -&gt; 9.5.1npm notice Changelog: https://github.com/npm/cli/releases/tag/v9.5.1npm notice Run npm install -g npm@9.5.1 to update!npm notice INFO Start blogging with Hexo!mac@bogon Blog % 【目录文件】： _config.landscape.yml：网站本地配置信息_config.yml：网站的配置信息，可以在此配置大部分的参数source–posts：存放 md 文件themes：主题文件夹，常用主题 会放入这里public：Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 hexo 测试 生成静态页面 1mac@bogon Blog % hexo g 会在根目录 Blog\\ 下生成 public 文件夹，里面包含相应的 html 页面。 启动服务器 1mac@bogon Blog % hexo s 打开浏览器，输入网址: http://localhost:4000 ，即可看到hexo生成的静态页面。 停止服务器 Ctrl + C 主题hexo提供了很多主题可以参考，下面以 hexo-theme-casual 主题为例 安装主题插件 hexo-theme-redefine 1无 hexo-theme-casual 1mac@bogon Blog % $ npm install --save hexo-renderer-jade hexo-renderer-scss hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-generator-search hexo-theme-snippet 1mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S hexo-theme-butterfly 12mac@bogon Blog % $ git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterflymac@bogon Blog % $ npm install hexo-renderer-pug hexo-renderer-stylus 下载主题 进入主题的 github 下载页，点击 code -&gt; clone，复制 https 下载链接，进入 博库Blog目录，运行下面的命令： 123mac@bogon Blog % cd /Users/mac/Desktop/Blog mac@bogon Blog % cd themes mac@bogon themes % git clone https://github.com/littlewin-wang/hexo-theme-casual.git 【注】：主题存放的目录是 Blog/themes，为了方便管理，每一个下载的主题都建一个单独的目录，我这个主题的目录是 hexo-theme-casual，可以下载多个主题: 主题应用 找到 博客Blog 目录下的配置文件 _config.yml，找到 Extensions 模块，修改 theme 字段： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-casual 启动本地服务器 1234567891011mac@bogon Blog % hexo sINFO Validating configINFO Start processingINFO Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.[Browsersync] Access URLs: ---------------------------------- UI: http://localhost:3001 ---------------------------------- UI External: http://localhost:3001 ---------------------------------- 查看效果 通过 http://localhost:4000/ 查看修改后的效果 主题更新 这一步不是必须的，如果主题有优化，我们需要在本地同步更新一下 12mac@bogon Blog % /Users/mac/Desktop/Blog/themes/casual mac@bogon Blog % git pull 其他命令 清除旧的内容 hexo clean 生成静态发布页面 hexo g 发布页面 hexo d","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"Swift学习25：Swift中的模式和模式匹配","slug":"Swift学习/Swift学习25：Swift中的模式和模式匹配","date":"2023-02-23T13:36:05.000Z","updated":"2023-03-03T14:33:00.000Z","comments":true,"path":"2023/02/23/Swift学习/Swift学习25：Swift中的模式和模式匹配/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A025%EF%BC%9ASwift%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/","excerpt":"","text":"模式 模式代表 单个值或复合值 的 结构， 可以用模式来匹配各种各样的值，例如：(x,y) 匹配 元组(1,2) 可以从复合值中取出部分或全部值，然后把值绑定一个常量或变量，例如：(let x,y) 提取 (1,2) 模式分类Swift 中模式分为两类： 一种能成功匹配任何类型的值；另一种在运行时匹配某个特定值可能会失败 第一种模式用于解构简单的常量、变量和可选绑定中的值 第二种模式用于全模式匹配。 模式分类： 通配符模式（Wildcard Pattern） 标识符模式（Identifier Pattern） 值绑定模式（Value-Binding Pattern） 元组模式（Tuple Pattern） 枚举用例模式（Enumeratinal Case Pattern） 可选项模式（Optional Pattern） 类型转换模式（Type-Casting Pattern） 表达式模式（Expression Pattern） 通配符模式（Wildcard Pattern） 通配符模式（Wildcard Pattern） 用一个下划线 _ 构成，用于匹配并忽略任何职 123for _ in 1...3 &#123;&#125; 标识符模式（Identifier Pattern） 标识符模式匹配任何值，并将匹配的值和一个变量或常量绑定起来 1let someValue = 42 值绑定模式（Value-Binding Pattern） 把匹配到的值绑定给一个 变量let或常量var 123456let point = (2,3)switch point &#123;// 将 point 中的元素绑定到 x 和 ycase let (x,y): print(&quot;\\(x),\\(y)&quot;)&#125; 元组模式（Tuple Pattern） 元组模式由逗号分割，具有零个或多个模式的列表，由一对圆括号括起来。 1234let points = [(0,0),(0,1),(1,1)]for (x,0) in points &#123; print(&quot;&quot;)&#125; 枚举用例模式（Enumeratinal Case Pattern） 匹配现有某个枚举类型的某个用例，体现在 switch 中 case 标签中，及 if、while、guard 和 for in 的 case 中 可选项模式（Optional Pattern） 匹配 Optional&lt;Wrapped&gt; 枚举在 some&lt;Wrapped&gt; 中包装的值 可选项模式为 for in 语句提供了一种迭代数组的简便方式，只为数组中的非 nil 元素执行循环体 12345678let someNum: Int? = 10if case .some(let x) = someNum &#123; print(x)&#125;if case let x? = someNum &#123; print(x)&#125; 类型转换模式（Type-Casting Pattern） 有两种：is模式 和 as模式，is 模式只出现在 switch 语句 case 标签中 is 类型：仅当一个值类型在运行时和 is模式 右边指定的类型一致，或子类下，才匹配值，没有返回类型 模式 as 类型：仅当一个值类型在运行时和 as模式 右边指定的类型一致，或子类下，才匹配值，如果匹配成功，被转换成 as模式右边指定的类型 12345678910111213141516171819202122232425262728protocol Animal &#123; var name:String &#123; get &#125;&#125;struct Dog:Animal &#123; var name:String &#123; return &quot;dog&quot; &#125; var runSpeed:Int&#125;struct Bird:Animal &#123; var name:String&#123; return &quot;bird&quot; &#125; var flightHeight:Int&#125;let animals:[Any] = [Dog(runSpeed:40),Bird(flightHeight:500)]for animal in animals &#123; switch animal&#123; case let dog as Dog: print(&quot;\\(dog.name) run at \\(dog.runSpeed)&quot;) case let bird as Bird: print(&quot;\\(bird.name) swip at \\(bird.flightHeight)&quot;) default: break &#125;&#125; 表达式模式（Expression Pattern） 表达式模式代表表达式的值，只出现在 switch 语句中的 case 标签中 可重载 ~= 运算符来提供自定义的表达式匹配行为 自定义类或结构体类型 默认也是无法进行表达式模式匹配的，也需要重载 ~= 运算符 123456789101112131415struct Employee&#123; var salary:Int&#125;func ~= (left:ClosedRange&lt;Int&gt;,right:Employee) -&gt; Bool&#123; return left.contains(right.salary)&#125;var e: Employee = Employee(salary:2000)switch e&#123;case 0...1000: print(&quot;吃不饱&quot;)case 1000...5000: print(&quot;勉强度日&quot;)default: break&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习24：如何在Swift里面进行控制转移","slug":"Swift学习/Swift学习24：如何在Swift里面进行控制转移","date":"2023-02-23T13:35:34.000Z","updated":"2023-03-03T14:25:43.000Z","comments":true,"path":"2023/02/23/Swift学习/Swift学习24：如何在Swift里面进行控制转移/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A024%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8Swift%E9%87%8C%E9%9D%A2%E8%BF%9B%E8%A1%8C%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB/","excerpt":"","text":"控制转移 continue break fallthrough return throw continue continue 告诉我不再继续当前循环遍历了，再次从头开始下一次遍历 break break 会立即结束整个控制流语句，即跳出整个循环 fallthrough 你确定要贯穿行为，你可以在 switch 每个 case 末尾 使用 fallthrough 关键字 12345678910let num = 5var des = &quot;the num \\(num) is&quot;switch num &#123;case 2,3,5,7: des += &quot;a prime number&quot; fallthroughdefault: des += &quot; also a int&quot;&#125;print(des) 语句标签 可以用 k 来给循环语句或条件语句做标记。 配合 break 或 continue 来结束被标记的语句 12345678910111213141516171819var num = 10whileLoop: while num &gt; 0 &#123; switch num &#123; case 9: print(&quot;9&quot;) case 10: var sum = 0 for i in 0...10 &#123; sum += i if i == 9 &#123; print(sum) break whileLoop &#125; &#125; default: print(&quot;default&quot;) &#125; num -= 1&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习23：更加强大的switch","slug":"Swift学习/Swift学习23：更加强大的switch","date":"2023-02-23T13:35:07.000Z","updated":"2023-03-03T14:24:22.000Z","comments":true,"path":"2023/02/23/Swift学习/Swift学习23：更加强大的switch/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A023%EF%BC%9A%E6%9B%B4%E5%8A%A0%E5%BC%BA%E5%A4%A7%E7%9A%84switch/","excerpt":"","text":"swift switch 语句会将一个值与多个可能匹配的模式匹配，然后基于第一个成功匹配的模式来执行合适的代码块 switch 语句一定得是全面的。给定类型里的每一个值都得匹配到一个 switch 的 case。你可以定义一个默认匹配的 case 来匹配所有未明确的值，用关键字 default 标记 OC 中 switch 语句不全面，仍然可以运行 1234567let c:Character = &quot;z&quot;switch c &#123;case &quot;a&quot;: print(&quot;the first letter is alphabet&quot;)case &quot;z&quot;: print(&quot;the last letter is alphabet&quot;)&#125; 修改 123456789let c:Character = &quot;z&quot;switch c &#123;case &quot;a&quot;: print(&quot;the first letter is alphabet&quot;)case &quot;z&quot;: print(&quot;the last letter is alphabet&quot;)default: print(&quot;other&quot;)&#125; 没有隐私贯穿 相比 OC 和 C ，Swift 里的 Switch 不会默认从匹配的 case 末尾 贯穿到下一个 case 里 相反，整个 Switch 在匹配到第一个 case 执行完毕之后退出，不再需要显示 break 每一个 case 的函数体必须包含至少一个可执行的语句 在一个 Switch 的 case 中匹配多个值可以用 逗号分割，并且可以写成多行 123456789let c = &quot;a&quot;switch c &#123;case &quot;a&quot;,&quot;e&quot;,&quot;i&quot;: print(&quot;元音字母&quot;)case &quot;b&quot;,&quot;c&quot;: print(&quot;符印字母&quot;)default: print(&quot;其他字符&quot;)&#125; 区间匹配 Switch 的 case 的值可以再一个区间中匹配 123456789101112let count = 43switch count&#123;case 0: print(&quot;none&quot;)case 1...25: print(&quot;1~25&quot;)case 26..&lt;51: print(&quot;26~50&quot;)default: print(&quot;other&quot;)&#125; 元组匹配 你可以使用元组来在一个 switch 中测试有多个值 使用下划线 _ 来表明匹配所有可能的值 1234567891011121314let point = (1,1)switch point&#123;case (0,0): print(&quot;point at origin&quot;)case (_,0): print(&quot;point at x&quot;)case (0,_): print(&quot;point at y&quot;)case (-2...2,-2...2): print(&quot;point at box&quot;)default: print(0,0)&#125; 值绑定 switch 的 case 可以将匹配到的值临时 绑定 到一个 常量或变量，来给 case 的函数体使用 如果使用 var 关键字，临时的变量就会以合适的值来创建并初始化。对这个变量的任何改变都只会在 case 的函数体内有效 123456789let point = (1,0)switch point&#123;case (let x,0): print(&quot;x is \\(x) when y is 0&quot;)case (0,let y): print(&quot;y is \\(y) when x is 0&quot;)default: print(&quot;other&quot;)&#125; where 语句 switch case 可以使用 where 语句来检查是否符合特定的约束 123456789let point = (1,-1)switch point&#123;case (let x,let y) where x == y: print(&quot;x == y&quot;)case (let x,let y) where x == -y: print(&quot;x == -y&quot;)default: print(&quot;other&quot;)&#125; 复合匹配 case 后可以写多个模式来复合，在每个模式间用 , 号分割 复合匹配 - 值绑定 复合匹配同样可以包含 值绑定。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习22：如何在Swift里进行循环控制","slug":"Swift学习/Swift学习22：如何在Swift里进行循环控制","date":"2023-02-23T13:34:50.000Z","updated":"2023-03-03T14:20:09.000Z","comments":true,"path":"2023/02/23/Swift学习/Swift学习22：如何在Swift里进行循环控制/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A022%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8Swift%E9%87%8C%E8%BF%9B%E8%A1%8C%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6/","excerpt":"","text":"for in 循环 使用 for in 循环来遍历序列，比如一个范围的数字，数组中元素或者字符串中的字符 如果你不需要序列的每一个值，你可以使用下划线 _ 来取代遍历名 123456789101112131415// 遍历for i in 0...3&#123; print(i)&#125;// 遍历字符串for c in &quot;hello,world&quot; &#123; print(c)&#125;// 遍历数组let letter = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]for str in letter &#123; print(str)&#125; for in 遍历字典 当遍历字典时，每一个元素都返回一个 (key,value) 元组，你可以在 for in 循环体中使用显示命名常量来分解 (key,value) 元组成员 1234567let nums = [&quot;age&quot;:&quot;30&quot;,&quot;sex&quot;:&quot;男&quot;]for (key,value) in nums &#123; print(&quot;key is \\(key),value is \\(value)&quot;)&#125;for t in nums &#123; print(&quot;key is \\(t.0),value is \\(t.1)&quot;)&#125; for in 分段区间 使用 stride(from:to:by) 函数来跳过不想要的标记（开区间） 123for i in stride(from: 0, to: 50, by: 10) &#123; print(i)&#125; 闭区间 也同样适用，使用 stride(from:through:by:) 即可 123for i in stride(from: 0, through: 50, by: 10) &#123; print(i)&#125; while 循环 repeat-while 循环 （oc 中是 do-while）","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习21：如何在swift中自定义运算符","slug":"Swift学习/Swift学习21：如何在swift中自定义运算符","date":"2023-02-22T20:03:04.000Z","updated":"2023-03-03T14:18:08.000Z","comments":true,"path":"2023/02/23/Swift学习/Swift学习21：如何在swift中自定义运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A021%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8swift%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"自定义运算符 除了实现标准的运算符，在 swift 当中还可以声明和实现自定义运算符（custom operators） 新的运算符要在全局作用域内，使用 operator 关键字进行声明，同时还要指定 prefix、infix 或者 postfix 限定符 【示例1】：一元运算符 123456789101112131415struct Vector2D &#123; var x = 0.0,y = 0.0&#125;// 声明一元运算符prefix operator +++// 扩展extension Vector2D &#123; static prefix func +++ (vector: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: vector.x + vector.x,y: vector.y + vector.y) &#125;&#125;let vectorToDouble = Vector2D(x: 1.0,y: 2.0)let doubleVector = +++vectorToDoubleprint(&quot;\\(doubleVector.x) \\(doubleVector.y)&quot;) 编译运行，查看打印结果 12.0 4.0 【示例2】： 1234567891011121314// 中缀运算符struct Vector2D &#123; var x = 0.0,y = 0.0&#125;infix operator +-: AdditionPrecedenceextension Vector2D &#123; static func +- (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x,y: left.y - right.y) &#125;&#125;let firstVector = Vector2D(x: 1.0,y: 3.0)let secondVector = Vector2D(x: 2.0,y: 5.0)let result = firstVector +- secondVectorprint(&quot;\\(result.x) \\(result.y)&quot;) 编译运行，查看打印结果： 13.0 -2.0 【示例3】： 1234567891011121314// 中缀运算符struct Vector2D &#123; var x = 0.0,y = 0.0&#125;infix operator *^: MultiplicationPrecedenceextension Vector2D &#123; static func *^ (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x * right.x,y: left.y * left.y + right.y * right.y) &#125;&#125;let firstVector = Vector2D(x: 1.0,y: 3.0)let secondVector = Vector2D(x: 2.0,y: 5.0)let result = firstVector *^ secondVectorprint(&quot;\\(result.x) \\(result.y)&quot;) 编译运行，查看打印结果： 12.0 34.0 自定义中缀运算符的优先级和结合性 自定义 中缀（infix） 运算符也可以指定优先级和结核性 每一个自定义的中缀运算符都属于一个 优先级组 优先级组指定了自定义中缀运算符和其他中缀运算符的关系 【示例】： 123456789101112131415161718192021// 优先级和结合性struct Vector2D &#123; var x = 0.0,y = 0.0&#125;infix operator +-: AdditionPrecedenceextension Vector2D &#123; static func +- (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x,y: left.y - right.y) &#125;&#125;infix operator *^: MultiplicationPrecedenceextension Vector2D &#123; static func *^ (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x * right.x,y: left.y * left.y + right.y * right.y) &#125;&#125;let firstVector = Vector2D(x: 1.0,y: 2.0)let secondVector = Vector2D(x: 2.0,y: 3.0)let thirdVector = Vector2D(x: 3.0,y: 4.0)let result = firstVector +- secondVector *^ thirdVectorprint(&quot;\\(result.x) \\(result.y)&quot;) 编译运行，查看打印结果： 17.0 -23.0 【注】：先计算 *^ 优先级组，再计算 +- 优先级组 x: 2 * 3 &#x3D; 6 + 1 &#x3D; 7.0y: 3 * 3 + 4 * 4 &#x3D; 2 - 25 &#x3D; -23 接下来我们自己定义一个优先级组 123456789101112131415161718192021222324252627282930// 自定义优先级和结合性struct Vector2D &#123; var x = 0.0,y = 0.0&#125;infix operator +-: AdditionPrecedenceextension Vector2D &#123; static func +- (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x,y: left.y - right.y) &#125;&#125;infix operator *^: MyPrecedencegroup// 我的优先级组precedencegroup MyPrecedencegroup &#123; // 结合性 associativity: left // 优先级 lowerThan: AdditionPrecedence&#125;extension Vector2D &#123; static func *^ (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x * right.x,y: left.y * left.y + right.y * right.y) &#125;&#125;let firstVector = Vector2D(x: 1.0,y: 2.0)let secondVector = Vector2D(x: 2.0,y: 3.0)let thirdVector = Vector2D(x: 3.0,y: 4.0)let result = firstVector +- secondVector *^ thirdVectorprint 编译运行，查看打印结果： 19.0 17.0 【注】：先计算 *^ 优先级组，再计算 +- 优先级组 x：1 + 2 &#x3D; 3 * 3 &#x3D; 9.0y：2 - 3 &#x3D; -1 * -1 + 4 * 4 &#x3D; 17.0","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习20：如何为类和结构体自定义运算符","slug":"Swift学习/Swift学习20：如何为类和结构体自定义运算符","date":"2023-02-22T20:02:46.000Z","updated":"2023-03-03T13:32:17.035Z","comments":true,"path":"2023/02/23/Swift学习/Swift学习20：如何为类和结构体自定义运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A020%EF%BC%9A%E5%A6%82%E4%BD%95%E4%B8%BA%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"运算符重载 类和结构体 可以为现有的运算符提供自定义的实现，称为 运算符重载 1234567struct Vector2D &#123; var x = 0.0,y = 0.0&#125;let vector = Vector2D(x: 1.0,y: 2.0)let anotherVertor = Vector2D(x: 3.0,y: 1.0)let thirdVertor = vector + anotherVertor 运算符重载 1234567891011121314struct Vector2D &#123; var x = 0.0,y = 0.0&#125;extension Vector2D &#123; static func + (left:Vector2D,right:Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x,y: left.y + right.y) &#125;&#125;let vector = Vector2D(x: 1.0,y: 2.0)let anotherVertor = Vector2D(x: 3.0,y: 1.0)let thirdVector = vector + anotherVertorprint(&quot;x is \\(thirdVector.x),y is \\(thirdVector.y)&quot;) 编译运行，查看打印结果： 1x is 4.0,y is 3.0 一元运算符的重载 类和结构体 也能提供 标准一元运算符 的实现 要实现 前缀 或者 后缀 运算符，需要在声明运算符函数的时候在 func 关键字之前指定 prefix 或者 postfix 限定符 1234567891011struct Vector2D &#123; var x = 0.0,y = 0.0&#125;extension Vector2D &#123; static prefix func - (vector:Vector2D) -&gt; Vector2D &#123; return Vector2D(x: -vector.x,y: -vector.y) &#125;&#125;let vector = Vector2D(x: 1.0,y: 2.0)let vector2 = -vectorprint(&quot;x is \\(vector2.x),y is \\(vector2.y)&quot;) 编译运行，查看打印结果： 1x is -1.0,y is -2.0 组合赋值运算符重载 组合赋值运算符将赋值运算符 = 与其他运算符进行结合 在实现的时候，需要把运算符的左参数设置成 inout 类型，因为这个参数的值会在运算符函数内直接被修改 123456789extension Vector2D &#123; static func += (left: inout Vector2D,right:Vector2D) &#123; left = Vector2D(x: left.x + right.x,y: left.y + right.y) &#125;&#125;var vector3 = Vector2D(x: 1.0, y: 2.0)let vector4 = Vector2D(x: 2.0,y: 3.0)vector3 += vector4print(&quot;x is \\(vector3.x),y is \\(vector3.y)&quot;) 编译运行，查看打印结果： 1x is 3.0,y is 5.0 等价运算符重载 自定义类和结构体不接收等价运算符的默认实现，也就是所谓的 等于 运算符 == 和 不等于 运算符 != 要使用等价运算符来检查你自己类型的等价，需要和其他 中缀运算符 一样提供一个 等于 运算符重载，并且遵循标准库的 Equatable 协议 swift 为一下自定义类型提供等价运算符合成实现 只有遵循 Equatable 协议存储属性的 结构体 只拥有遵循 Equatable 协议关联类型的 枚举 没有关联类型的枚举 123456789101112// 等价运算符struct Vector2D &#123; var x = 0.0,y = 0.0&#125;extension Vector2D: Equatable &#123; static func == (left:Vector2D,right:Vector2D) -&gt; Bool &#123; return (left.x == right.x) &amp;&amp; (left.y == right.y) &#125;&#125;var vector1 = Vector2D(x: 1.0, y: 2.0)let vector2 = Vector2D(x: 2.0,y: 3.0)print(vector1 == vector2) 编译运行，查看打印结果： 1false 自定义中缀运算符的优先级和结合性 自定义的中缀 infix 运算符也可以指定优先级和结合性 每一个自定义的中缀运算符都属于一个优先级组 优先级组指定了自定义中缀运算符和其他中缀运算符的关系","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习19：运算符优先级和结合性","slug":"Swift学习/Swift学习19：运算符优先级和结合性","date":"2023-02-22T20:02:16.000Z","updated":"2023-03-03T10:52:29.000Z","comments":true,"path":"2023/02/23/Swift学习/Swift学习19：运算符优先级和结合性/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A019%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7/","excerpt":"","text":"运算符优先级和结合性 运算符的优先级使得一些运算符优先于其他运算符，高优先级的运算符会先被计算 结合性定义了具有相同优先级的运算符是如何结合（或关联）的 一一 是左边结合为一组，还是与右边结合为一组。可以这样理解：它们是与左边的表达式结合的 或者 它们是与右边的表示式结合的 运算符优先级-显示括号 2 + 3 % 4 * 5 等价于 2 + ((3 % 4) * 5) swift 语言中逻辑运算符 &amp;&amp; 和 || 是左相关的，这意味着多个逻辑运算符组合的表达式会首先计算最左边的","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习18：运算符应用举例","slug":"Swift学习/Swift学习18：运算符应用举例","date":"2023-02-22T17:32:43.000Z","updated":"2023-03-03T10:51:44.000Z","comments":true,"path":"2023/02/23/Swift学习/Swift学习18：运算符应用举例/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A018%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/","excerpt":"","text":"两个数字交换 不借助临时变量，交换两个变量的值 1234567var a = 1var b = 2a = a ^ bb = a ^ ba = a ^ bprint(a)print(b) 求无符号整数二进制中 1 的个数 给定一个无符号整型 UInt 变量，求其二进制表中 1 的个数，要求算法执行效率尽可能的高 思路：看一个八位整数 10 100 001 ，先判断最后一位是否为 1 ，而 与 操作可以达到目前。可以把这个 八位数字 与 00 0000 01 进行 与 操作，如果结果为 1，则表示当前八位数的最后一位为 1，否则为 0 。怎么判断第 二 位呢？向右移位，再延续前面的判断即可 12345678910111213// 有几个 1func countsOfOnes(num:UInt) -&gt; UInt &#123; var count:UInt = 0 var temp = num while temp != 0 &#123; // 如果都是位 1 才累加 count += temp &amp; 1 // 右移 temp = temp &gt;&gt; 1 &#125; return count&#125;countsOfOnes(num: 8) 如果整数的二进制中有较多的 0，那么我们每一次右移做判断会很浪费，怎么改进前面的算法呢？有没有办法让算法的复杂度只有与 1 的个数有关？ 思路：为了简化这个问题，我们考虑只有高位 1 的情况。例如：11 000 000，如何跳过前面低位的 6 个 0 ，而直接判断第 七 位的 1？我们可以设计 11 000 000 和 10 111 111（也就是 11 000 000 - 1）做 与 操作，消去最低位的 1。如果得到的结果为 0，说明我们已经找到或消去里面最后一个 1，如果不为 0，那么说明我们消去了最低位的 1，但是二进制中还有其他的 1，我们的计数器需要加 1，然后继续上面的操作 计数器 count &#x3D; 0 步骤一：整数不为0，说明二进制里面肯定有1，count &#x3D; 1 11 000 000 &amp; 10 111 111 &#x3D; 10 000 000 (消去第7位的1) 步骤二：结果不为 0，说明二进制里还有 1，count &#x3D; 2 10 000 000 &amp; 01 111 111 &#x3D; 0（消去第8位的1） 12345678910func countsOfOnes2(num:UInt) -&gt; UInt &#123; var count:UInt = 0 var temp = num while temp != 0 &#123; count += 1 temp = temp &amp; (temp - 1) &#125; return count&#125;countsOfOnes2(num: 3) 引申：如果判断一个征收为2的整数次幂 给定一个无符号整型 UInt 变量，判断是否为 2 的整数次幂 思路：一个整数如果是 2 的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位都是 0，根据前面的分析，把这个整数减去 1 后再和它自己做 &amp; 运算，这个整数中唯一的 1 就变成 0 了，也就是得到的结果是 0 12345// 2的整数次幂func isPowerTwo(num:UInt) -&gt; Bool &#123; return (num &amp; (num - 1)) == 0&#125;isPowerTwo(num: 18) 缺失的数字 很多成对出现的正整数保存在磁盘文件中，注意成对数字不一定是相邻的，如果 2、3、4、3、4、2、..，由于意外有一个数字消失了，如何尽快找到是哪个数字消失了？ 思路：考虑 ^ 异或操作的定义，当两个操作的数对应位不相同时，改数的对应位就为1。也就是说如果是相等的两个数 ^异或，得到的结果就是 0，而 0 与任何数字 ^异或，得到的是那个数字本身。所以我们考虑将所有的数字做 ^异或操作，因为只有一个数字消失，那么其他俩俩出现的数字 ^异或后为0，0与仅有的一个的数字做 ^异或，我们就得到了消失的数字是哪个？ 123456789// 缺失的数字func findLostNum(nums:[UInt]) -&gt; UInt &#123; var lostNum:UInt = 0 for num in nums &#123; lostNum = lostNum ^ num &#125; return lostNum&#125;findLostNum(nums: [1,3,2,4,2,1,3]) 如果有两个数字意外丢失了（丢失的不是相等的数字），改如何找到丢失的两个数字？ 思路：假设题目中这两个只出现1次的数字分别是A和B，如果能将A，B分开到二个数组中，那显然符合 异或 解法的关键点了，因此这个题目的关键点事将A和B分开到二个数组中。由于A，B肯定是不相等的，因此在二进制上肯定有一位是不同的。根据这一位是 0 还是 1 可以将A和B分开到A组合B组。而这个数组中其它数字那么就属于A组，要么就属于B组。再对A组 和 B组 分别执行 异或 解法，就可以得到A,B了。而要判断A，B在哪一位上不相同，只要根据 A ^ B 的结果就可以知道了，这个结果在二进制上为 1 的位都说明 A，B在这一位上是不同的 12345678910111213141516171819202122232425// 丢失的两个不同数func findTwoLostNum(nums:[UInt]) -&gt; (UInt,UInt) &#123; var lostNum1:UInt = 0 var lostNum2:UInt = 0 var temp:UInt = 0 // 计算两个数的异或结果 for num in nums &#123; temp = temp ^ num &#125; // 找到第一个为 1 的位 var flag:UInt = 1 while ((flag &amp; temp) == 0) &#123; flag = flag &lt;&lt; 1 &#125; // 找到两个丢失的数字 for num in nums &#123; if (num &amp; flag) == 0 &#123; lostNum1 = lostNum1 ^ num &#125;else &#123; lostNum2 = lostNum2 ^ num &#125; &#125; return (lostNum1,lostNum2)&#125;findTwoLostNum(nums: [1,2,3,4,2,1])","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习17：位运算符","slug":"Swift学习/Swift学习17：位运算符","date":"2023-02-22T17:32:26.000Z","updated":"2023-03-03T10:39:50.000Z","comments":true,"path":"2023/02/23/Swift学习/Swift学习17：位运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A017%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"位取反运算符 位取反运算符 ~ 是对所有位的数字进行取反操作 123let n1:UInt8 = 255let n2 = ~n1print(n2) 位与运算符 位与运算符 &amp; 可以对两个数的比特位进行合并，它会返回一个新的数，只有当这两个数都是 1 时才能返回 1 123456let n1:UInt8 = 255let n2 = ~n1let n3 = n1 &amp; n2let n4 = n1 | n2print(n3)print(n4) 位或运算符 位或运算符 | 可以对两个比特位进行比较，然后返回一个新的数，只要两个操作位任意一个为 1 时，那么对应的位数就为 1 位异或运算符 位异或运算符，或者说 互斥或 ^ 可以对两个数的比特位进行比较，它返回一个新的数，当两个操作数的对应位不同时，该数的对应位就为 1 1234let n1:UInt8 = 255let n2 = ~n1let n5 = n1 ^ n2print(n5) 位左移和右移运算符 位左移运算符 &lt;&lt; 和位右移运算符 &gt;&gt; 可以把所有位数的数字向左或向右移动一个确定的位数 位 左移和右移 具有给 整数乘以或除以二 的效果，将一个数 左移 一位相当于把这个 数翻倍，将一个数 右移 相当于把这个数 减半 无符号整数的位移操作 已经存在的比特位按指定的位数进行左移和右移 任何移动超出整型存储边界的位都会被丢弃 用 0 来填充向左或向右移动后产生的空白位 有符号整数的位移操作 有符号整数使用它的第一位（所谓的符号位）来表示这个整数是正数还是负数，符号位 0 表示 正数，1 表示 负数 其余的位数（所谓的数值位）存储了实际的值，有符号正整数和无符号数的存储方式是一样的，都是从 0 开始算起 但是负数的存储方式略有不同，它存储的是 2 的 n 次方减去它的绝对值，这里的 n 为数值位的位数 示例： 123let n6: Int = 8print(n6 &lt;&lt; 1)print(n6 &gt;&gt; 1) 补码表示的优点 首先，如果想给 -4 加个 -1，只需要将这两个数的全部 8 个比特位相加（包括符号位），并且将计算结果中超出的部分丢掉 其次，使用二进制补码可以使负数位的位左移和右移操作得到根正数同样的效果，即每向左移一位就将自身的数值 乘以2 ，每向右移一位就将自身的数值 除以2，要达到此目的，对 有符号的整数 的右移有一个额外的规则：当对整数进行位右移操作时，遵循与无符号整数相同的规则，但是对于位移产生的空白位使用符号进行填充，而不是 0","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习16：区间运算符","slug":"Swift学习/Swift学习16：区间运算符","date":"2023-02-22T17:32:10.000Z","updated":"2023-03-03T10:24:08.000Z","comments":true,"path":"2023/02/23/Swift学习/Swift学习16：区间运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A016%EF%BC%9A%E5%8C%BA%E9%97%B4%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"闭区间运算符 闭区间运算符 a...b 定义了从 a 到 b 的一组范围，并且包含 a 和 b ，a 的值不能大于 b 12345// 闭区间let range = 0...5for index in range &#123; print(index)&#125; 半开区间运算符 半开区间运算符 a..&lt;b 定义了从 a 到 b 但不包括 b 的区间 12345// 半开半闭区间let range = 0..&lt;5for index in range &#123; print(index)&#125; 如同闭区间运算符，a 的值也不能大于 b ，如果 a 与 b 的值相等，那返回的区间将会是空的 单侧区间 闭区间运算符有另外一种形式来让区间朝一个方向尽可能的远，这种区间叫做单侧区间 12345// 单侧闭区间let names = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]for name in names[...2] &#123; print(name)&#125; 半开区间运算符同样可以有单侧形式，只需要写它最终的值 12345// 单侧半开半闭区间let names = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]for name in names[..&lt;2] &#123; print(name)&#125; 比如说，一个包含数组所有元素的区间，从索引 2 到数组的结束，在这种情况下，你可以省略区间运算符一侧的值 123for name in names[2...] &#123; print(name)&#125; 单侧区间可以再其他上下文中使用，不仅仅是下标 不能变量省略了第一个值的单侧区间，因为遍历根本不知道该从哪里开始，你可以遍历省略了最终值的单侧区间 字符串索引区间 字符串范围可以使用区间运算符 12345// 字符串索引区间var str = &quot;hello,world&quot;let range = str.startIndex...str.index(str.endIndex, offsetBy: -6)str.removeSubrange(range)print(str) 倒叙索引 通过 reversed() 方法，我们可以将一个正序循环变成逆序循环 1234// 逆序for i in (0...4).reversed() &#123; print(i)&#125; Comparable 区别 区间运算符可以作用在 Comparable 类型上，返回闭区间和半闭区间 1234567var str = &quot;hello,world&quot;let range = &quot;a&quot;...&quot;z&quot;for c:Character in str &#123; if !range.contains(String(c)) &#123; print(&quot;\\(c) 不是小写字符&quot;) &#125; &#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习15：为了Optional，合并空置运算符","slug":"Swift学习/Swift学习15：为了Optional，合并空置运算符","date":"2023-02-22T17:31:50.000Z","updated":"2023-03-01T17:27:39.000Z","comments":true,"path":"2023/02/23/Swift学习/Swift学习15：为了Optional，合并空置运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A015%EF%BC%9A%E4%B8%BA%E4%BA%86Optional%EF%BC%8C%E5%90%88%E5%B9%B6%E7%A9%BA%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"合并空值运算符 合并空值运算符 a ?? b 如果可选项 a 有值则展开，如果没有值是 nil，则返回默认值 b 表达式 a 必须是一个可选类型，表达式 b 必须与 a 的存储类型相同 实际上是 三元运算符 作用到 Optional 上的缩写 a != nil ? a : b 如果 a 的值是非空的，b 的值将不会被考虑，也就是合并空值运算符是短路的 可选值为nil时，不能强制解包 可以用 if 判断实现 123456789101112131415161718let a:Int? = nillet b = 2func sum(x:Int?,y:Int?) -&gt; Int&#123;// return x! + y! if x != nil &#123; if y != nil &#123; return x! + y! &#125;else &#123; return x! &#125; &#125;else &#123; if y != nil &#123; return y! &#125;else &#123; return 0 &#125; &#125;&#125; 也可以用 ?? 来实现 1return (a ?? 0) + b","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习14：在Swift里如何处理算术结果溢出","slug":"Swift学习/Swift学习14：在Swift里如何处理算术结果溢出","date":"2023-02-22T17:31:22.000Z","updated":"2023-03-01T17:30:15.039Z","comments":true,"path":"2023/02/23/Swift学习/Swift学习14：在Swift里如何处理算术结果溢出/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A014%EF%BC%9A%E5%9C%A8Swift%E9%87%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%AE%97%E6%9C%AF%E7%BB%93%E6%9E%9C%E6%BA%A2%E5%87%BA/","excerpt":"","text":"溢出运算符 在默认情况下，当向一个整数赋超出它容量的值时，swift 会报错而不是生成一个无效的数，给我们操作过大或过小的数时提供了额外的安全性 同时提供三个算术溢出运算符来让系统支持整数溢出运算 溢出加法 &amp;+ 溢出减法 &amp;- 溢出乘法 &amp;* 值溢出 数值可以出现向上溢出或向下溢出 溢出也会发生在有符号整型数值上 对于无符号与有符号整型数值来说，当出现溢出时，它们会从数值所能容纳的最大数变成最小的数，同样的，当发生下溢时，它们会从所能容纳的最小数变成最大的数 代码示例 上溢出 下溢出","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习13：赋值和算术运算符","slug":"Swift学习/Swift学习13：赋值和算术运算符","date":"2023-02-22T17:30:48.000Z","updated":"2023-03-01T17:25:29.347Z","comments":true,"path":"2023/02/23/Swift学习/Swift学习13：赋值和算术运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A013%EF%BC%9A%E8%B5%8B%E5%80%BC%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"基本概念 一元运算符对一个目标进行操作。一元前缀运算符（如!b），一元后缀运算符（b!） 二元运算符对两个目标进行操作（a+b）同时因为它们出现在两个目标之间，所以是中缀 三元运算符操作三个目标，swift 语言也仅有一个 三元运算符，三元条件运算符（a?b:c） swift 运算符的改进 swift在支持 c 中的大多数标准运算符的同时也增加了一些排除常见代码错误的能力 赋值符号 = 不会返回值，以防止它被无用于等于符号 == 算术符号 +、-、*、/、% 以及其他可以监测并阻止值溢出，以避免你在操作比存储类型允许的范围更大或更小的数字时得到各种奇怪的结果 赋值运算符 赋值运算符将一个值赋值给另外一个值 如果赋值符号右侧是拥有多个值的元组，它的元素将会一次性地拆分成常量或者变量 Swift 的赋值符号自身不会返回值 算术运算符-标准运算符 标准算术运算符 + - * / 算术运算符同时也支持 String 的拼接 swift 算术运算符默认不允许值溢出 算术运算符 - 余数运算符 余数运算符 a%b 可以求出多少个 b 的倍数能够刚好放进 a 中并且返回剩下的值（就是我们所谓的余数） 当 a 是负数时也适用相同的方法来进行计算 当 b 为负数时它的正负号被忽略掉。这意味着 a%b 与 a%-b 能够获得相同的答案 12345678let c = 9 % 4print(c)let d = 9 % -4print(d)let e = -9 % 4print(e) 算术运算符 - 一元 数字值的正负号可以用前缀 - 来切换，我们称之为一元减号运算符 一元减号运算符 - 直接在要进行操作的值前边放置，不加任何空格 一元加号运算符 + 直接返回它操作的值，不会对其进行任何的修改","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习12：获取子串和字符串比较","slug":"Swift学习/Swift学习12：获取子串和字符串比较","date":"2023-02-21T18:59:39.000Z","updated":"2023-03-01T17:25:21.832Z","comments":true,"path":"2023/02/22/Swift学习/Swift学习12：获取子串和字符串比较/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A012%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AD%90%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/","excerpt":"","text":"子字符串 使用下标或者类似 prefix(_:) 的方法得到的子字符串是 Substring 类型 Substring 拥有 String 的大部分方法 Substring 可以转成 String 类型 1234let str = &quot;hello,world&quot;let index = str.firstIndex(of: &quot;,&quot;) ?? str.endIndexlet begin = str[..&lt;index]let new = String(begin) 子字符串重用一部分原字符串的内存 修改字符串或子字符串之前都不需要花费拷贝内存的代价 String 和 Substring 都遵循 StringProtocol 协议，也就是说它基本上都能很方便的兼容所有接受 StringProtocol 值的字符串操作函数 字符串的比较 字符串和字符相等性 == 和 != 前缀相等性 hasPrefis(_:) 后缀相等性 hasSubffix(_:) 12345var str1 = &quot;1&quot;var str2 = &quot;2&quot;print(str1 == str2)print(str1.hasPrefix(&quot;1&quot;))print(str2.hasSuffix(&quot;2&quot;))","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习11：索引访问和修改字符串","slug":"Swift学习/Swift学习11：索引访问和修改字符串","date":"2023-02-21T18:59:05.000Z","updated":"2023-03-01T17:18:31.138Z","comments":true,"path":"2023/02/22/Swift学习/Swift学习11：索引访问和修改字符串/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A011%EF%BC%9A%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串索引 每一个 String 值都有相关的索引类型，String.Index，他相当于每个 Character 在字符串中的位置 startIndex 属性来访问 String 中第一个 Character 的位置。endIndex 属性就是 String 中最后一个字符串的位置 endIndex 属性并不是字符串下标脚本的合法实际参数 如果 String 为空，则 startIndex 与 endIndex 相等 使用 index(before:) 和 index(after:) 方法来访问给定索引的前后 要访问给定索引更远的索引，你可以使用 index(_:offetBy:) 使用 indices 属性来访问字符串中每个字符的索引 123456var greeting = &quot;Hello, playground&quot;greeting[greeting.startIndex]greeting[greeting.index(before: greeting.endIndex)]greeting[greeting.index(after: greeting.startIndex)]let index = greeting.index(greeting.startIndex, offsetBy: 7)greeting[index] 插入 插入字符，使用 insert(_:at:) 方法 插入到另一个字符串的内容到特定的索引，使用 insert(contentsOf:at:) 方法 1234var str = &quot;hello&quot;str.insert(&quot;!&quot;, at: str.endIndex)str.insert(contentsOf: &quot; world&quot;, at: str.firstIndex(of: &quot;!&quot;)!)print(str) 删除 移除字符，使用 remove(at:) 方法 12var str = &quot;hello&quot;str.remove(at: str.index(before: str.endIndex)) 移除一小段特定范围的字符串，使用 removeSubrange(_:) 方法 123var str = &quot;hello&quot;let range = str.index(str.endIndex, offsetBy: -str.count)..&lt;str.endIndexstr.removeSubrange(range)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习10：字符串常见操作","slug":"Swift学习/Swift学习10：字符串常见操作","date":"2023-02-21T18:58:45.000Z","updated":"2023-03-01T17:15:30.150Z","comments":true,"path":"2023/02/22/Swift学习/Swift学习10：字符串常见操作/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A010%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/","excerpt":"","text":"字符串的可变性 var 指定的可以修改 let 指定的不可修改 对比 Object-C (NSString 和 NSMutableString) 字符串是 值类型 String 值在传递给方法或函数的时候会被复制过去 赋值给常量或变量的时候也是一样 Swift 编译器优化了字符串使用的资源，实际上拷贝只会在确实需要的时候才进行 123456var str1 = &quot;hello&quot;var str2 = str1print(str1 == str2)str1.append(&quot;,world&quot;)print(str1)print(str2) 操作字符 for in 循环遍历 String 中的每一个独立的 Character Character 类型 String 值可以通过传入 Character 数组来构造 1234var str = &quot;hello&quot;for c in str&#123; print(c)&#125; 字符串的拼接 使用加运算符 + 创建新字符串 使用 + 赋值符号 += 在已经存在的 String 值末尾追加一个 String 值 使用 String 类型的 append() 方法来可以给一个 String 变量的末尾追加 Character 值 字符串插值 字符串插值是一种从混合常量、变量、字面量和表达式的字符串字面量构造新 String 值的方法 每一个你插入到字符串字面量的元素都要被一对圆括号包裹，然后使用反斜杠前缀 \\() 类似于 NSString 的 stringWithFormat 方法，但是更加简便，更强大 可以在扩展字符串分割符中创建一个包含在其他情况下会被当做字符串插值的字符 要在使用扩展分隔符的字符串中使用字符串插值，在反斜杠后使用匹配首尾井号数量的井号 12let str = &quot;6 * 7 = \\(6 * 7)&quot;print(str)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习09：字符串创建和使用","slug":"Swift学习/Swift学习09：字符串创建和使用","date":"2023-02-21T18:58:24.000Z","updated":"2023-03-01T17:06:09.757Z","comments":true,"path":"2023/02/22/Swift学习/Swift学习09：字符串创建和使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A009%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"初始化空串 字面量 初始化器语法 isEmpty 检查是否为空串 123456var emptyString = &quot;&quot;var anotherEmptyString = String()if emptyString.isEmpty &#123; print(&quot;Nothing to see here&quot;)&#125; 字面量 字符串字面量是被双引号 “” 包裹的固定顺序文本字符 Swift 会为 str 常量推断类型为 String 1let str = &quot;some string&quot; 多行字面量 多行字符串字面量是用三个双引号引起来的一系列字符 多行字符串字面量把所有行包括在引号内，开始和结束默认不会有换行符 如果为了书写美观而不换行在后面加 \\ 12345678let someStr = &quot;&quot;&quot;1\\2\\345&quot;&quot;&quot;print(someStr) 要让多行字符串字面量起始或结束于换行，就在第一或最后一行写一个空行 多行字符串可以 缩进 以匹配周围的代码。双引号（”””）前的空格会告诉Swift其他行前应该有多少空白是需要忽略的 如果你在某行的空格超过了结束的双引号（”””），那么这些空格会被包含 12345678 let someStr = &quot;&quot;&quot; 1 2 3 4 5 &quot;&quot;&quot;print(someStr) 字符串里的特殊字符 转义特殊字符 \\o（空字符）,\\（反斜杠），\\t（水平制表符），\\n（换行符），\\r（回车符），\\”（双引号）以及 &#39;（单引号） 任意的 Unicode 标量，写作 \\u&#123;&#125;n，里边的 n 是一个 1-8 位的16进制数字，其值是合法 Unicode 值 1let str = &quot;\\u&#123;24&#125;&quot; 可以在多行字符串字面量中包含双引号（”）而不需要转义。要在多行字符串中包含文本 “”””””，转义至少一个双引号 扩展字符串分隔符(Raw String) 在字符串字面量中放置扩展分隔符来使 包含特殊字符的字符串 不让他们真的生效 把字符串放在双引号 (“) 内并由 (#) 包裹 12let str = #&quot;1\\n2\\n3\\n&quot;#print(str) 如果字符串里面有 &quot;# 则首尾需要两个 ## 12let str = ##&quot;1\\&quot;#n2\\#n3\\#n&quot;##print(str) 如果你需要字符串中某个特殊符号的效果，使用匹配你包裹的 # 号数量的 # 号，并在前面写转义符号 \\ 12let str = #&quot;1\\#n2\\#n3\\#n&quot;#print(str)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习08：Optional的使用Optional实现原理探索","slug":"Swift学习/Swift学习08：Optional的使用Optional实现原理探索","date":"2023-02-21T18:56:00.000Z","updated":"2023-03-01T17:03:15.000Z","comments":true,"path":"2023/02/22/Swift学习/Swift学习08：Optional的使用Optional实现原理探索/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A008%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8Optional%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"Optional-实现探究 Optional 其实是一个标准库里的一个 public 的 enum 类型，而且是 泛型 的，泛型的类型是 Wrapped 用标准库实现语言特性的典型 Optional.none 就是 nil Optional.some 则包装了实际的值 12345var str:Optional&lt;String&gt; = &quot;abc&quot;if let actualStr = str &#123; let count = actualStr.count print(count)&#125; Optional-解包实现 泛型属性 unsafelyUnwrapped 理论上我我们可以直接调用 unsafelyUnwrapped 获取可选项的值 123var str:String? = &quot;abc&quot;let count = str.unsafelyUnwrapped.countprint(count)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习07：Optional的使用","slug":"Swift学习/Swift学习07：Optional的使用","date":"2023-02-21T18:55:20.000Z","updated":"2023-03-01T16:54:26.000Z","comments":true,"path":"2023/02/22/Swift学习/Swift学习07：Optional的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A007%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"为什么需要 Optional？ Object-C 里的 nil 是无类型的指针 Object-C 里面的数组、字典、集合等不允许放入 nil Object-C 所有 对象的变量 都可以为 nil Object-C 只能用在对象上，而在其他地方又用其他特殊值（例如NSNotFound）表示值的缺失 Optional 通过在 变量类型 后面加 ? 表示 这里有一个值，它等于 x 或者 这里根本没有值 你可以通过给可选变量赋值一个 nil 来将之设置为没有值 在 Object-C 中 nil 是一个指向不存在对象的指针 在 Swift 中，nil 不是指针，它是 值缺失的一种特殊类型，任何类型的可选项都可以设置成 nil 而不仅仅是对象 只有可选项才能设置为 nil 12var str: String = nilvar str1: String? = nil Optional-If 语句以及强制解包 可选项是没法直接使用的 需要用 ! 号强制解包后才能使用（意思是我知道这个可选项里面有值，使用吧） 12var str: String? = &quot;abc&quot;let count = str.count 需要改成如下代码，才能正确执行 12var str: String? = &quot;abc&quot;let count = str!.count 或 1234var str: String? = &quot;abc&quot;if str != nil &#123; let count = str!.count&#125; Optional-绑定 可以使用 可选绑定 来判断可选项是否包含值，如果包含就把赋值给一个临时的 常量或变量 可选绑定可以与 if 和 while 的语句使用来检查可选项内部的值，并赋值给一个变量或常量 同一个 if 语句中包含多可选项绑定，用逗号分割即可。如果任一可选绑定结果是 nil 或者 布尔值 为 false ，那么整个 if 判断会被看做 false 12345var str:String? = &quot;abc&quot;if let actualStr = str &#123; let count = actualStr.count print(count)&#125; Optional - 隐士解包 有些可选项一旦被设定值之后，就会一直拥有值，在这种情况下，就可以去掉检查的需求，也不必每次访问的时候都进行解包 通过有声明的类型后边添加一个叹号（String!）而非问号（String?）来书写隐士解包可选项 123var str:String! = &quot;abc&quot;let count = str.countprint(count) 隐士解包可选项主要被用在Swift 类 的初始化过程中 Optional-可选链 可选项后面加问号 如果可选项不为nil，返回一个可选项结果，否则为nil 123var str:String? = &quot;abc&quot;let count = str?.countlet lastIndex = count - 1 将上面的代码改为： 1234567var str:String? = &quot;abc&quot;let count = str?.count//let lastIndex = count - 1if count != nil &#123; let lastIndex = count! - 1 print(lastIndex)&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习06：Tuple元组","slug":"Swift学习/Swift学习06：Tuple元组","date":"2023-02-21T18:54:43.000Z","updated":"2023-03-01T16:48:14.682Z","comments":true,"path":"2023/02/22/Swift学习/Swift学习06：Tuple元组/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A006%EF%BC%9ATuple%E5%85%83%E7%BB%84/","excerpt":"","text":"Tuple 元组 把多个值合并成单一的复合型的值 元组 内的值可以是任何类型，而且可以不必是统一类型 123let error = (1,&quot;没有权限&quot;)print(error.0)print(error.1) 元素命名 元组中的每一个元素可以指定对应的元素名称 123let error = (errorCode:1,errorMessage:&quot;没有权限&quot;)print(error.errorCode)print(error.errorMessage) 如果没有指定名称的元素也可以使用下标的方式来引用 123let error = (1,&quot;没有权限&quot;)print(error.0)print(error.1) Tuple 修改 用 var 定义的元组就是可变元组，let 定义的元组就是不可变元组 不管是可变还是不可变元组，元组在创建后就不能增加和删除元素 可以对可变元组的元素进行修改，但是不能改变其类型 123var error = (errorCode:1,errorMessage:&quot;没有权限&quot;)error.errorCode = 2error.errorMessage = &quot;2&quot; any 类型可以改为任何类型 12345var error: (Any,String) = (1,&quot;没有权限&quot;)error.0 = 2print(error)error.0 = &quot;abc&quot;print(error) Tuple 分解 将一个元组的内容分解成单独的常量或变量 1234let error = (1,&quot;没有权限&quot;)let (errorCode,errorMessage) = errorprint(errorCode)print(errorMessage) 如果只需要使用其中的一部分数据，不需要的数据可以用下划线 _ 代替 123let error = (1,&quot;没有权限&quot;)let (_,errorMessage) = errorprint(errorMessage) 作为函数返回值 使用 Tuple 为函数返回多个值 返回值的 Tuple 可以再函数的返回类型部分被命名 12345func writeToFile(content:String) -&gt; (errorCode:Int,errorMessage:String) &#123; return (1,&quot;没有权限&quot;)&#125;let error = writeToFile(content: &quot;&quot;)print(error)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习05：数值类型","slug":"Swift学习/Swift学习05：数值类型","date":"2023-02-21T18:53:56.000Z","updated":"2023-03-01T16:43:16.134Z","comments":true,"path":"2023/02/22/Swift学习/Swift学习05：数值类型/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A005%EF%BC%9A%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"整数 Swift 提供了 8，16，32，64 位编码的有符号和无符号整数 命名方式：例如 8位无符号整数的类型是 UInt8，32位有符号整数的类型是 Int32 通过 min 和 max 属性来访问每个整数类型的最小值和最大值 Swift 提供了一个额外的整数类型：Int，它拥有与当前平台的原生字相同的长度 同时 Swift 也提供 UInt 类型，来表示平台长度相关的无符号整型 建议在用到证书的地方都使用 Int 浮点类型 Double：64位浮点数，至少有 15 位数字的精度 Float：32位浮点数，至少有 6 为数字的精度 在两种类型都可以的情况下，推荐使用 Double 类型 数值范围 123let a = 8let b: UInt8 = 240print(&quot;UInt8 min \\(UInt8.min),UInt8 max \\(UInt8.max)&quot;) Bool Bool：true 和 false Swift 的类型安全机制会阻止你用一个非布尔量的值替换掉 Bool 1234let i = 1if i &#123; print(i)&#125; 我们修改一下 类型别名 类型别名是一个为 已存在类型 定义的一个 可选择的名字 你可以用关键字 typealias 定义一个类型的别名 当你想通过在一个在上下文中看起来更合适可具有表达行的名字来引用一个已存在的类型时，这时别名就非常有用了 123// 音频采样率typealias AudioSample = UInt8let sample:AudioSample = 32","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习04：变量和常量","slug":"Swift学习/Swift学习04：变量和常量","date":"2023-02-21T18:12:27.000Z","updated":"2023-03-01T16:40:54.558Z","comments":true,"path":"2023/02/22/Swift学习/Swift学习04：变量和常量/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A004%EF%BC%9A%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/","excerpt":"","text":"声明变量和常量 使用关键字 let 声明常量 12let a = 1a = 2 由于 x 是常量，不能给常量赋值，会报错 使用关键字 var 声明变量 12var b = 1b = 2 可以在一行中声明多个变量和常量，用逗号分割 1var x = 0.0,y = 1.0,z = 2.0 类型标注 在声明一个变量或常量时提供类型标注，来明确变量或常量能够存储值的类型 添加 类型标注 的方法是在 变量或常量 的名字后面加一个 冒号，再跟一个 空格，最后加上使用的 类型名称 可以在一行中定义多个相关的变量为相同的类型，用 逗号 分割，只要在最后的变量名字后加上类型标注 123var a: Stringa = &quot;hello&quot;a = 10 常量和变量命名 常量和变量的名字几乎可以使用任何字符，甚至包括 Unicode 字符 常量和变量的名字不能包含 空白字符、数学符号、箭头、保留的（或者无效的）Unicode码位、连线和制表符。也不能以 数字 开头，尽管数字几乎可以使用在名字其他的任何地方 123let π = 3.1415let 你好 = &quot;你好世界&quot;let 🐶🐂 = &quot;dog,cow&quot; 打印常量和变量 print(_:separator:teminator) 字符串插入 用 \\() 来插入 123456let π = 3.1415let 你好 = &quot;你好世界&quot;let 🐶🐂 = &quot;dog,cow&quot;print(π)print(&quot;\\(你好)&quot;)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习03：Playgorund使用","slug":"Swift学习/Swift学习03：Playground使用","date":"2023-02-21T16:41:59.000Z","updated":"2023-03-01T16:37:15.616Z","comments":true,"path":"2023/02/22/Swift学习/Swift学习03：Playground使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A003%EF%BC%9APlayground%E4%BD%BF%E7%94%A8/","excerpt":"","text":"简介 Swift 的 Playgorund 是为了让人人都能愉快的学习 swift 编程 但发展至今，这个工具越来越强大 Playgorund 使用 创建一个 Playgorund 应用 Next，默认名 MyPlayground 可以通过 New -&gt; Playground Page 创建多个 Playground 来学习 注：快捷键 command + option + n 创建 Playground Page command + shift + enter 快速运行程序 简单使用 写一个求和的函数 12345678// 求和函数func sum(a:Int,b:Int) -&gt; Int &#123; return a+b&#125;// 调用求和函数 赋值给 常量 clet c = sum(a: 1, b: 2)// 打印常量 cprint(c)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习02：REPL交互式解释器","slug":"Swift学习/Swift学习02：REPL交互式解释器","date":"2023-02-21T16:41:38.000Z","updated":"2023-03-01T17:50:48.372Z","comments":true,"path":"2023/02/22/Swift学习/Swift学习02：REPL交互式解释器/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A002%EF%BC%9AREPL%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%99%A8/","excerpt":"","text":"介绍 xcode 6.1 引进了另外一种以交互式的方式来体验 Swift 的方法 Read Eval PrintLoop，简称REPL 使用REPL 除了可以 定义常量和变量 外，还是可 定义函数 打开终端输入 12mac@bogon ~ % swiftmac@bogon ~ % swift repl 定义变量 定义函数 REPL 其他命令 退出：:quit 帮助：:help 将光标移动到当前行的开始处：Control + A 将光标移动到当前行的结束处：Control + E","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习01：Swift编译流程","slug":"Swift学习/Swift学习01：Swift编译过程","date":"2023-02-21T15:49:55.000Z","updated":"2023-03-01T17:50:40.800Z","comments":true,"path":"2023/02/21/Swift学习/Swift学习01：Swift编译过程/","link":"","permalink":"https://www.bboyzj.cn/2023/02/21/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A001%EF%BC%9ASwift%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","excerpt":"","text":"编译器架构Swift编译过程和OC基本类似，仅仅是前端编译器不一样。 OC/C 前端编译器是 Clang Swift 先解析成 Swift AST（抽象语法树），通过 swiftc 这个命令行参数，编译成 Swift IL OC 和 Swift 最后均编译成 LLVM IR 中间层表示 OC 和 Swift 最终通过 后端编译器 LLVM compiler ，编译成最终的在具体地址上可以执行的二进制，包括x86、arm和other 详细编译流程 Swift 先解析成 AST（抽象语法树） 经过一系列工具编程 Swift 的 SIL(中间语言) 再经过 分析、IR工具 转成 LLVM IR(中间表示层) 最终通过 后端编译器 LLVM compiler 编译成 .o 目标文件 命令行流程使用终端创建一个简单的 main.swift 文件 12mac@bogon ~ % cd Desktopmac@bogon Desktop % touch main.swift 此时你可以在桌面看到一个 main.swift 文件 在该文件下写下两个数相加的一个函数 123456func sum(a:Int,b:Int) -&gt; Int &#123; return a + b&#125;let value = sum(a: 1, b: 2)print(value) 打开命令行工具 mac@bogon ~ % cd Desktop 生成 AST 抽象语法树 mac@bogon ~ % swiftc main.swift -dump-ast 生成 SIL 中间语言 mac@bogon ~ % swiftc main.swift -emit-sil 生成 LLVM IR 中间表示层 mac@bogon ~ % swiftc main.swift -emit-ir 生成 Assembly Language 汇编语言 mac@bogon ~ % swiftc main.swift -emit-assembly 生成二进制文件 mac@bogon ~ % swiftc -o main.out main.swift 命令行输入： 1234mac@bogon ~ % cd /Users/mac/Desktop/01swift编译流程 mac@bogon 01swift编译流程 % swiftc -o main.out main.swiftmac@bogon 01swift编译流程 % ./main.out3","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"C语言学习19：数据类型","slug":"C学习/C语言学习19：数据类型","date":"2023-02-18T08:41:06.000Z","updated":"2023-03-01T13:51:51.657Z","comments":true,"path":"2023/02/18/C学习/C语言学习19：数据类型/","link":"","permalink":"https://www.bboyzj.cn/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A019%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"数据类型 基本类型 数值类型： 整数类型：短整型 short、整型 int、长整型 long 浮点类型：单精度型 float、双精度型 double 字符类型：char 构造类型 数组 结构体：struct 共用体：union 枚举类型：enum 指针类型 空类型 void 注意： c 语言中没有字符串类型，使用 字符数组char[] 表示字符串 不同操作系统，数据类型 占用字节长度不一样 基本数据类型 sizeof运算符 用于 获取数据类型或表达式的长度，长度以 字节 表示 signed 和 unsigned signed：有符号，第一个位代表正负，剩余代表大小。 unsigned：无符号，所有位都为大小，没有负数。 基本数据类型的取值范围 比特位 CPU能读懂的最小单位是：比特位，bit，b。每个比特位只能存放二进制数，即0和1。 字节 内存机构最小寻址单位：字节，Byte，B 1Byte &#x3D; 8 bit","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习18：常量","slug":"C学习/C语言学习18：常量","date":"2023-02-18T08:14:14.000Z","updated":"2023-03-01T13:51:44.295Z","comments":true,"path":"2023/02/18/C学习/C语言学习18：常量/","link":"","permalink":"https://www.bboyzj.cn/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A018%EF%BC%9A%E5%B8%B8%E9%87%8F/","excerpt":"","text":"C 常量 常量是固定值，在执行期间不会改变，这些固定值，又叫做 字面量 常量可以是任何的 基本数据类型。 常量 就是常规的变量，只不过在定义后不能进行修改。 定义常量 使用 #define 预处理器 #define LENGTH 10 使用 const 关键字 const type variable = value;","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习17：typedef","slug":"C学习/C语言学习17：typedef","date":"2023-02-18T05:58:49.000Z","updated":"2023-03-01T13:51:40.382Z","comments":true,"path":"2023/02/18/C学习/C语言学习17：typedef/","link":"","permalink":"https://www.bboyzj.cn/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A017%EF%BC%9Atypedef/","excerpt":"","text":"typedefC 语言提供了关键字 typedef ，可以用它为 类型 取一个新的名字。 例如：为无符号字符定义一个名称 UChar typedef unsigned char UChar; 例如：为结构体定义一个名称 MyBook 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;string.h&gt;typedef struct Book&#123; char title[50]; int book_id;&#125;MyBook;int main(int argc, const char * argv[]) &#123; // typedef前// struct Book myBook; // typedef后 MyBook book; strcpy(book.title,&quot;ZJ&quot;); book.book_id = 12; printf(&quot;标题：%s\\n&quot;,book.title); printf(&quot;书 ID:%d\\n&quot;,book.book_id); return 0;&#125; 当上面的代码 编译和运行 时，产生的结果 123标题：ZJ书 ID:12Program ended with exit code: 0 typedef 和 #define 区别 typedef 仅限于为 类型 定义名称；#define 不仅可以为 类型 定义别买，也可以为 数值 定义 typedef由编译器 执行 解释；#define由编译器 预处理 处理","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习16：enum(枚举)","slug":"C学习/C语言学习16：enum-枚举","date":"2023-02-18T05:58:37.000Z","updated":"2023-03-01T13:51:36.445Z","comments":true,"path":"2023/02/18/C学习/C语言学习16：enum-枚举/","link":"","permalink":"https://www.bboyzj.cn/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A016%EF%BC%9Aenum-%E6%9E%9A%E4%B8%BE/","excerpt":"","text":"enum(枚举)枚举在 C 中是一种 基本数据类型，它可以让数据 更简洁、更易读 枚举语法定义格式： enum 枚举名 &#123;枚举元素1,枚举元素2,...&#125; 一个星期的例子： 123enum DAY&#123; MON=1,TUE,WED,THU,FRI,SAT,SUN&#125;; 枚举变量的定义 先定义枚举类型，再定义枚举变量 123456789101112// 定义枚举类型enum DAY&#123; MON=1,TUE,WED,THU,FRI,SAT,SUN&#125;;int main(int argc, const char * argv[]) &#123; // 定义枚举变量 enum DAY day; printf(&quot;%d\\n&quot;,day=WED); return 0;&#125; 定义枚举类型的同时，定义枚举变量 1234// 定义枚举类型和变量enum DAY&#123; MON=1,TUE,WED,THU,FRI,SAT,SUN&#125;day; 省略枚举名称，直接定义枚举变量 1234// 省略枚举名称，直接定义枚举变量enum &#123; MON=1,TUE,WED,THU,FRI,SAT,SUN&#125;day; 实例，遍历枚举 1234567891011// 省略枚举名称，直接定义枚举变量enum &#123; MON=1,TUE,WED,THU,FRI,SAT,SUN&#125;day;int main(int argc, const char * argv[]) &#123; for (day = MON; day&lt;=SUN; day++) &#123; printf(&quot;%d\\n&quot;,day); &#125; return 0;&#125; 当上面的代码 编译和运行 时，产生结果 123456781234567Program ended with exit code: 0","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习15：递归","slug":"C学习/C语言学习15：递归","date":"2023-02-18T05:58:13.000Z","updated":"2023-03-01T13:51:32.643Z","comments":true,"path":"2023/02/18/C学习/C语言学习15：递归/","link":"","permalink":"https://www.bboyzj.cn/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A015%EF%BC%9A%E9%80%92%E5%BD%92/","excerpt":"","text":"递归递归指： 函数中使用函数自身的方法 C 语言中支持递归，即 一个函数可以调用自身，在使用递归时，程序员要注意函数的 退出条件，否则会进入死循环 数的阶乘1234567891011121314double factorial(unsigned int i)&#123; if (i&lt;=1)&#123; return 1; &#125; return i * factorial(i-1);&#125;int main(int argc, const char * argv[]) &#123; int i = 5; printf(&quot;%d 的阶乘是：%f\\n&quot;,i,factorial(i)); return 0;&#125; 当上面的代码被 编译和运行 时，产生的结果： 125 的阶乘是：120.000000Program ended with exit code: 0 斐波那契额数列当前数是前两个数之和 12345678910111213141516171819int fibonaci(int i)&#123; if (i == 0) &#123; return 0; &#125; if (i == 1) &#123; return 1; &#125; return fibonaci(i-1) + fibonaci(i-2);&#125;int main(int argc, const char * argv[]) &#123; for (int i = 0; i &lt; 10; i++)&#123; printf(&quot;%d\\t\\n&quot;, fibonaci(i)); &#125; return 0;&#125; 当上面的代码 编译和运行时，产生的结果： 12345678910110 1 1 2 3 5 8 13 21 34 Program ended with exit code: 0","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"Flutter面试题：Flutter总结","slug":"面试题/Flutter面试题01：Flutter面试题","date":"2023-02-15T17:21:00.000Z","updated":"2023-03-03T06:19:14.597Z","comments":true,"path":"2023/02/16/面试题/Flutter面试题01：Flutter面试题/","link":"","permalink":"https://www.bboyzj.cn/2023/02/16/%E9%9D%A2%E8%AF%95%E9%A2%98/Flutter%E9%9D%A2%E8%AF%95%E9%A2%9801%EF%BC%9AFlutter%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"什么是flutter？原理是什么？ flutter 是 google 推出并 开源的移动应用开发框架，通过 dart 语言开发APP，一套代码可以同时运行在 iOS 和 Android 平台。 flutter 底层使用 skia 作为 2D渲染引擎，通过自己的渲染引擎来 绘制widget(组件)，dart 语言借鉴了 Java 和 JavaScript 同时加入了一些 现代编程语言 特性。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://www.bboyzj.cn/categories/Flutter/"}],"tags":[{"name":"Flutter-面试题","slug":"Flutter-面试题","permalink":"https://www.bboyzj.cn/tags/Flutter-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"Flutter","slug":"Flutter","permalink":"https://www.bboyzj.cn/categories/Flutter/"}]},{"title":"C语言学习14：内存管理","slug":"C学习/C语言学习14：内存管理","date":"2023-02-14T16:14:03.000Z","updated":"2023-03-01T13:51:28.902Z","comments":true,"path":"2023/02/15/C学习/C语言学习14：内存管理/","link":"","permalink":"https://www.bboyzj.cn/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A014%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"内存管理C 语言为内存 分配和管理 提供了几个函数，这些函数都在 &lt;stdlib.h&gt; 头文件中 动态内存分配 全局变量 分配在内存中的 静态存储区 局部变量 分配在内存中的 动态存储区，存放在 栈（stack） 区。 临时数据 分配在内存中的 动态存储区，存放在 堆（heap） 区 用 malloc 函数开辟动态存储区 void * malloc(unsigned int size); 在内存动态存储区分配一个长度为size的连续空间，形参size类型为无符号整型 malloc(100)：开辟100字节的临时分配域，其值为第一个字节的地址 用 calloc 函数开辟动态存储区 void * calloc(unsigned n,unsigned int size); 内存中分配n个长度为size的连续空间 用 recalloc 函数重新分配动态存储区 void * recalloc(void *p,unsigned int size); 如果已经用 malloc 和 calloc 函数获取了，想改变大小，用 recalloc 重新分配 recalloc(p,50); &#x2F;&#x2F; 将p所指向的已分配的动态内存改为50字节 用 free 函数释放动态存储区 void free(void *p); 其作用是释放指针变量p所指向的动态空间。","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习13：文件","slug":"C学习/C语言学习13：文件","date":"2023-02-14T16:13:49.000Z","updated":"2023-03-01T13:51:25.322Z","comments":true,"path":"2023/02/15/C学习/C语言学习13：文件/","link":"","permalink":"https://www.bboyzj.cn/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A013%EF%BC%9A%E6%96%87%E4%BB%B6/","excerpt":"","text":"打开文件FILE * fopen(const char * filename,const * mode); filename:文件名mode：样式 关闭文件int fclose(int c,FILE *fp); fclose()函数返回零：关闭成功fclose()韩式返回EOF：关闭失败 注：EOF 是一个定义在头文件&lt;stdio.h&gt;中的常量 写入文件 把字符写入到流中 int fputc(char c,FILE *fp); 把字符串写入到流中 int fputs(const char *s,FILE *fp); 或 int fprintf(FILE *fp,const char *format,...); 注：请确保您有可用的tmp目录 读取文件 读取一个字符 int fgetc(FILE *fp); 读取 字符串 char * fgets(char *buf,int n,FILE *fp); 读取 n-1 个字符，读取到的字符串复制到缓冲区buf，并追加一个 null 字符；如果读取到 \\n或EOF 结束 或 int fscanf(FILE *fp, const char *format, ...); 读取字符串，遇到 空格或换行符 停止 二进制 I&#x2F;O 函数二进制输入和输出 12345size_t fread(void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file); size_t fwrite(const void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file);","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习12：预处理器","slug":"C学习/C语言学习12：预处理器","date":"2023-02-14T16:13:38.000Z","updated":"2023-03-01T13:51:21.761Z","comments":true,"path":"2023/02/15/C学习/C语言学习12：预处理器/","link":"","permalink":"https://www.bboyzj.cn/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A012%EF%BC%9A%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/","excerpt":"","text":"C 预处理器预处理器 不是 编译器的组成部分，是编译过程的一个单独的步骤。简言之，C预处理器是一个 文本替换工具，它会指示编译器在实际编译前完成所需的 预处理；我们把 C 预处理器(C Preprocessor) 简写成(CPP) 所有的预处理器都是以 # 开头，非空字符，为增加可读性，从第一列开始，下面列出了所有的预处理命令： 预处理实例#define MAX_LENGTH 20 这个指令告诉 CPP 把所有的 MAX_LENGTH 定义为 20，使用 #define 定义常量来增强可读性 12#include &lt;stdio,h&gt;#include &quot;myheader.h&quot; 这个指令告诉 CPP 从 系统库 中读取 stdio.h，并添加到 当前源文件 中；下一行告诉 CPP 从 本地目录 中获取 myheader.h，并添加到 当前源文件中 12#undef FILE_SIZE#define FILE_SIZE 30 这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 30 123#ifndef MESSAGE #define MESSAGE &quot;You wish!&quot;#endif 这个指令告诉 CPP 只要当 MESSAGE 未定义时，才定义 MESSAGE 123#ifdef DEBUG /*debug here*/#endif 这个指令告诉 CPP ，如果定义了 DEBUG,则执行语句。 预定义宏ANSI C 定义了许多宏 1234567891011#include &lt;stdio.h&gt; main()&#123; printf(&quot;File :%s\\n&quot;, __FILE__ ); printf(&quot;Date :%s\\n&quot;, __DATE__ ); printf(&quot;Time :%s\\n&quot;, __TIME__ ); printf(&quot;Line :%d\\n&quot;, __LINE__ ); printf(&quot;ANSI :%d\\n&quot;, __STDC__ ); &#125; 当上面的代码在 main.c 中编译和执行时，它会产生下列结果： 123456File :/Users/mac/Desktop/预处理器/预处理器/main.mDate :Feb 18 2023Time :13:22:02Line :16ANSI :1Program ended with exit code: 0 预处理器运算符 宏延续运算符 () 一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用 宏延续运算符（\\）。例如： 12#define msg(a,b) \\ printf(#a &quot;and&quot; #b &quot;\\n&quot;) 字符串常量化运算符（#） 在宏定义中，把一个 宏参数 转为 字符串常量 在 main.c 中 编译和运行上面的代码，得到下面的结果 11and&#x27;a&#x27; 标记粘贴运算符（##） 宏定义内标记粘贴运算符（##）会合并两个参数 参数化宏#define square(x) (x*x) 12#define max(x,y) \\ printf(&quot;%d\\n&quot;,x&gt;y?x:y);","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习11：基本语法","slug":"C学习/C语言学习11：基本语法","date":"2023-02-14T16:13:29.000Z","updated":"2023-03-01T13:51:18.607Z","comments":true,"path":"2023/02/15/C学习/C语言学习11：基本语法/","link":"","permalink":"https://www.bboyzj.cn/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A011%EF%BC%9A%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"C 的令牌（Token）C 程序由各种令牌组成，令牌可以是 关键字、常量、字符串或一个符号。 分号;分号是语句 结束符 注释 单行注释 // 单行注释 多行注释 123456/* 单行注释*//* 多行注释 多行注释 ...*/ 关键字 auto：声明自动变量 const：定义常量，如果一个变量被const修饰，那么它的值就不能被改变 extern：声明变量或函数可以被其他文件使用 register：声明寄存器变量 typedef：给数据类型起别名","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习10：共用体","slug":"C学习/C语言学习10：共用体","date":"2023-02-14T16:13:03.000Z","updated":"2023-03-01T13:51:14.889Z","comments":true,"path":"2023/02/15/C学习/C语言学习10：共用体/","link":"","permalink":"https://www.bboyzj.cn/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A010%EF%BC%9A%E5%85%B1%E7%94%A8%E4%BD%93/","excerpt":"","text":"共用体共用体 是一种特殊的数据类型，允许您在 相同的内存位置存储不同的数据类型。 定义共用体必须用 union 语句，方式与结构体类型。 12345union MyData&#123; int i; float j; char k[5];&#125;data; 当上面的代码被 编译和运行时，产生的结果 12内存占用：8Program ended with exit code: 0 说明：共用体占用的内存应足够存储共用体中最大的成员，因为内存对齐，4的整数倍&#x3D;8 访问共用体我们使用 成员访问运算符(.)。 1234567891011121314int main(int argc, const char * argv[]) &#123; union MyData data; printf(&quot;内存占用：%lu\\n&quot;,sizeof(data)); data.i = 1; data.j = 3.14; strcpy(data.k, &quot;ZJ&quot;); printf(&quot;i:%d\\n&quot;,data.i); printf(&quot;j:%f\\n&quot;,data.j); printf(&quot;k:%s\\n&quot;,data.k); return 0;&#125; 当上面的代码编译和运行是，产生的结果： 12345内存占用：8i:1073760858j:2.004538k:ZJProgram ended with exit code: 0","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习09：结构体","slug":"C学习/C语言学习09：结构体","date":"2023-02-14T16:12:43.000Z","updated":"2023-03-01T13:51:02.563Z","comments":true,"path":"2023/02/15/C学习/C语言学习09：结构体/","link":"","permalink":"https://www.bboyzj.cn/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A009%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"","text":"声明结构体1234struct st&#123; int a; char ch[4];&#125; 定义结构体1234struct st&#123; int a; char ch[4];&#125;t1; 注：t1：结构体变量名 初始化结构体1struct test t1 = &#123;5&#125;; 结构体数组1struct test arr[3] = &#123;1,2,3&#125;; 结构体指针struct 结构体名 *变量名； 12345678910111213141516#include &lt;stdio.h&gt;struct test&#123; int a; char c; char arr[5];&#125;t1;int main(int argc, const char * argv[]) &#123; // 初始化结构体 struct test t1 = &#123;.a=1,.c=&#x27;a&#x27;,.arr=&quot;abc&quot;&#125;; printf(&quot;%d %c %s\\n&quot;,t1.a,t1.c,t1.arr); return 0;&#125; 结构体指针获取成员变量 (*ptr).structMenber ptr-&gt;structMenber 注：.运算符 高于 * ，所以(*ptr)括号不能少 字节对齐#pragma pack(n)：指定按照n字节对齐规则进行存储 字节对齐的原因 计算机内存以字节为单位划分，CPU通过 地址总线 来访问内存，一次能处理几个字节，地址总线就读取几个字节。32位一次读取4个字节。64位一次读取8个字节。 内存对齐原因：避免存取效率的损失 总结 结构体不占内存空间，是一个创建变量的 模板 结构体 成员变量 需要开辟内存空间","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习08：字符串","slug":"C学习/C语言学习08：字符串","date":"2023-02-14T16:07:57.000Z","updated":"2023-03-01T13:51:06.835Z","comments":true,"path":"2023/02/15/C学习/C语言学习08：字符串/","link":"","permalink":"https://www.bboyzj.cn/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A008%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串的输入和输出 scanf(格式控制,地址列表(变量前加&amp;)) printf(格式控制,地址列表) gets(字符数组) puts(字符数组) 区别： gets() 和 puts() ： 只能输入或输出一个字符串 scanf() 和 printf() ：可以输出多个字符串 字符串连接strcat(字符数组1,字符数组2) 字符串复制函数strcpy(字符数组1,字符串2或字符数组名) strncpy(字符数组1,字符串2或字符数组名,n) 字符串比较函数strcmp(字符数组1,字符串2或字符数组) 字符串长度函数strlen(字符串或字符串数组) 字符串转换大小写函数大写转小写：strlwr(字符数组) 小写转大写：strupr(字符数组)","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习07：指针","slug":"C学习/C语言学习07：指针","date":"2023-02-13T12:37:03.000Z","updated":"2023-03-01T13:50:58.640Z","comments":true,"path":"2023/02/13/C学习/C语言学习07：指针/","link":"","permalink":"https://www.bboyzj.cn/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A007%EF%BC%9A%E6%8C%87%E9%92%88/","excerpt":"","text":"定义指针变量类型名 * 指针变量名 星号 是用来指定一个 变量是指针。 什么是指针？指针 就是 内存地址，指针变量 是用来 存放内存地址的变量。 指针的声明： 12int *ip; // 一个整型的指针char *cp; // 一个字符型的指针 如何使用指针12345678910111213141516int main(int argc, const char * argv[]) &#123; int var=20; // 实际变量的声明 int *ip; // 指针变量的声明 ip = &amp;var; // 在 指针变量中存储 var 的地址 printf(&quot;var 变量的地址：%p\\n&quot;,&amp;var); /* 在指针变量中存储的地址 */ printf(&quot;ip 变量存储的地址: %p\\n&quot;,ip); /* 使用指针访问值 */ printf(&quot;*ip 变量的值: %d\\n&quot;,*ip); return 0;&#125; 当上面的代码被 编译和运行 时，产生的结果 1234var 变量的地址：0x7ff7bfeff45cip 变量存储的地址: 0x7ff7bfeff45c*ip 变量的值: 20Program ended with exit code: 0 注：&amp;取地址运算符。&amp;a是变量a的地址。 指针数组指向整数类型的指针数组 123456789101112131415161718// 常量const int MAX = 3;int main(int argc, const char * argv[]) &#123; // 数组 int var[] = &#123;10,100,200&#125;; int i,*ptr[MAX]; for (i=0; i&lt;MAX; i++) &#123; // 赋值为整数的地址 ptr[i] = &amp;var[i]; &#125; for (i=0; i&lt;MAX; i++) &#123; printf(&quot;value of var[%d]=%d\\n&quot;,i,*ptr[i]); &#125; return 0;&#125; 当上面的代码被 编译和运行 时，结果 1234value of var[0]=10value of var[1]=100value of var[2]=200Program ended with exit code: 0 指向指针的指针指向指针的指针是一个 指针链，第一个指针指向第二个指针的 地址，第二个指针指向 实际值的位置。 12345678910111213141516171819202122int main(int argc, const char * argv[]) &#123; int v; int *p1; int **p2; v=100; // 获取v的地址 p1=&amp;v; // 获取p1的地址 p2=&amp;p1; // 打印值 printf(&quot;var=%d\\n&quot;,v); printf(&quot;p1=%p\\n&quot;,p1); printf(&quot;*p1=%d\\n&quot;,*p1); printf(&quot;p2=%p\\n&quot;,p2); printf(&quot;**p1=%d\\n&quot;,**p2); return 0;&#125; 当上面的代码被 编译和运行 时，结果： 123456var=100p1=0x7ff7bfeff3bc*p1=100p2=0x7ff7bfeff3b0**p1=100Program ended with exit code: 0 传递指针给函数C 语言允许传递 指针给 函数，只需要简单的声明函数参数为指针即可 示例 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; // 函数的声明 void exchange(int *a,int *b,int *c); int a,b,c; printf(&quot;请输入 a b c:&quot;); scanf(&quot;%d,%d,%d&quot;,&amp;a,&amp;b,&amp;c); exchange(&amp;a, &amp;b, &amp;c); printf(&quot;order:%d,%d,%d\\n&quot;,a,b,c); return 0;&#125;void exchange(int *a,int *b,int *c)&#123; // 函数的声明 void swap(int *x,int *y); // 交换 if (*a &gt; *b) swap(a, b); if (*a &gt; *c) swap(a, c); if (*b &gt; *c) swap(b, c);&#125;void swap(int *x,int *y)&#123; int temp; temp = *x; *x = *y; *y = temp;&#125; 从函数中返回指针必须 声明一个返回指针的函数，C 语言不支持调用函数时，返回局部变量的地址，除非定义局部变量的 static 变量 实例 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX 5;// 函数定义int * getRandom(void)&#123; static int r[10]; for (int i=0; i&lt;MAX; i++) &#123; r[i]=rand(); printf(&quot;%d\\n&quot;,r[i]); &#125; return r;&#125;int main(int argc, const char * argv[]) &#123; int *p; p=getRandom(); for (int i=0; i&lt;MAX; i++) &#123; printf(&quot;*(p+[%d]):%d\\n&quot;,i,*(p+i)); &#125; return 0;&#125; 当上面的代码 编译和运行 时，产生的结果 12345678910111680728247524916226500739849436581144108930*(p+[0]):16807*(p+[1]):282475249*(p+[2]):1622650073*(p+[3]):984943658*(p+[4]):1144108930Program ended with exit code: 0","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习06：数组","slug":"C学习/C语言学习06：数组","date":"2023-02-13T12:36:53.000Z","updated":"2023-03-07T04:06:59.576Z","comments":true,"path":"2023/02/13/C学习/C语言学习06：数组/","link":"","permalink":"https://www.bboyzj.cn/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A006%EF%BC%9A%E6%95%B0%E7%BB%84/","excerpt":"","text":"一维数组 数组创建 type_t arr_name[const_n] type_t : 数组元素的类型 arr_name : 数组名称 const_n : 是一个常量表达式，用来执行数组的大小 数组初始化 int arr[10] &#x3D; {0}; &#x2F;&#x2F; 数组的不完全初始化 int sz &#x3D; sizeof(arr)&#x2F;sizeof(arr[0]); &#x2F;&#x2F; 计算数组的元素个数 数组在内存中的存储是连续的 123456789101112#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; // 数组不完成初始化 int arr[10] = &#123;0&#125;; int sz = sizeof(arr)/sizeof(arr[0]); for (int i=0; i&lt;sz; i++) &#123; printf(&quot;&amp;arr[%d]=%p\\n&quot;,i,&amp;arr[i]); &#125; return 0;&#125; 查看打印结果 1234567891011&amp;arr[0]=0x7ff7bfeff3c0&amp;arr[1]=0x7ff7bfeff3c4&amp;arr[2]=0x7ff7bfeff3c8&amp;arr[3]=0x7ff7bfeff3cc&amp;arr[4]=0x7ff7bfeff3d0&amp;arr[5]=0x7ff7bfeff3d4&amp;arr[6]=0x7ff7bfeff3d8&amp;arr[7]=0x7ff7bfeff3dc&amp;arr[8]=0x7ff7bfeff3e0&amp;arr[9]=0x7ff7bfeff3e4Program ended with exit code: 0 二维数组 二维数组创建 123int arr[行][列]int arr[3][4] = &#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;; 二维数组的使用 12345678910int main(int argc, const char * argv[]) &#123; int arr[3][4] = &#123;&#123;1,2,3&#125;,&#123;5,6,7,8&#125;&#125;; for (int i=0; i&lt;2; i++) &#123; for (int j=0; j&lt;2; j++) &#123; printf(&quot;%d\\n&quot;,arr[i][j]); &#125; &#125; return 0;&#125; 二维数组在内存的存储 内存是连续的 数组作为形式参数有三种方式告诉编译器将要接收一个 整型指针 形式参数是一个指针 123void myFunc(int *param)&#123; ...&#125; 形式参数是一个已定大小的数组 123void myFunc(int param[10])&#123;...&#125; 形式参数是一个未定义大小的数组 123void myFunc(int param[])&#123;...&#125; 从函数返回数组C 语言不允许返回一个完成的数组，可以通过 声明一个返回指针的函数 123int * myFunc&#123;...&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习05：函数与程序结构","slug":"C学习/C语言学习05：函数与程序结构","date":"2023-02-13T12:36:40.000Z","updated":"2023-03-01T13:50:51.098Z","comments":true,"path":"2023/02/13/C学习/C语言学习05：函数与程序结构/","link":"","permalink":"https://www.bboyzj.cn/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A005%EF%BC%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/","excerpt":"","text":"函数的声明和定义 在C语言中，函数的定义顺序是有讲究的：默认情况下，只有后面定义的函数才可以调用前面定义过的函数 如果想把函数的定义写在main函数后面，而且main函数能正常调用这些函数，那就必须在main函数的前面进行函数的声明 函数的声明： 返回值类型 函数名(参数1,参数2,…) 注：如果只有函数的声明，没有函数的定义，那么链接时会出错 多个源文件项目大，如果都放在一个.c文件源代码会非常多，因此需要创建新的.c文件存放不同的代码 1234567891011main.cint main()&#123; int c = sum(1,2); return 0;&#125;sum.cint sum(int a,int b)&#123; return a+b;&#125; include 作用 include 是 C 语言 预处理 指令之一，后面跟一个文件名，会根据文件名去查找文件，并把这个文件的内容包含到当前文件中。 include&lt;&gt; 和 include“”区别 “”：从父文件夹搜索，找不到去父的父文件夹搜索，找不到去编译器设置的inlcude路径内搜索，找不到则在系统的INCLUDE环境变量内搜索 &lt;&gt;：编译器设置的include路径内搜索，找不到则在系统的INCLUDE环境变量内搜索 头文件.h 和 源文件 .c的分工 函数的声明写在 .h 文件中 函数的定义卸载 .c 源文件中 函数的参数 形式参数 形参 在定义时编译系统不分配内存，只有在调用函数时才分配内存。调用结束内存被释放。 实际参数 实参 出现在主函数中，当函数调用时，函数把实参的值传递给函数的形参，从而实现函数间的传递。 传递的方式有两种：值传递 和 地址传递 局部变量和全局变量 局部变量：首先是一个变量，其次是这个变量在程序的 局部范围有效 书写：首字母小写 全局变量：首先是变量，其次在 定义处以下才有效 书写：首字母大写 头文件 include作用： include：把头文件里的内容原封不动的复制到引用该头文件的地方。 头文件的格式说明 123456#ifndef 头文件名 // 头文件名的格式是&quot;_头文件名_&quot;，注意要大写#define 头文件名头文件内容#endif 示例代码：头文件main.h 12345678910#ifndef _MATH_H_ // 如果没有定义main.h，则执行下面的代码。这是防止重复定义#define _MATH_H_ // 定义头文件// 下面的代码是头文件内容#include&lt;stido.h&gt; // 头文件#define ADD 1 // 宏定义extern int x; // 全局变量void swap(int a,int b); // 函数声明#endif // 表示头文件结束 内部函数和外部函数 外部函数：可以被其他源文件调用的函数 在函数声明处添加 extern关键字，可省略 内部函数：只在定义的源文件中有效 在函数的返回值类型前面添加 static关键字，也称 静态函数 练习 形参和实参 输入两个正整数m和n，求从m加到n的和（m&lt;&#x3D;n），并输出 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;int sum(int a,int b);void swap(int *a,int *b);int main(int argc, const char * argv[]) &#123; int m,n,total; printf(&quot;请输入两个整数：&quot;); scanf(&quot;%d,%d&quot;,&amp;m,&amp;n); if (m&gt;n)&#123; swap(&amp;m, &amp;n); &#125; total = sum(m, n); printf(&quot;a=%d,b=%d\\n&quot;,m,n); printf(&quot;total=%d\\n&quot;,total); return 0;&#125;int sum(int a,int b)&#123; for (int i = a+1; i &lt;= b; i++) &#123; a += i; &#125; return a;&#125;void swap(int *a,int *b)&#123; int temp = *a; *a = *b; *b = temp;&#125; 定义选择排序和使用选择排序分别在不同的文件中 main.c 1234567891011121314151617181920#include &lt;stdio.h&gt;#define ARR_LEN 10void select_sort(int arr[],int len);void print_arr(int arr[],int len);int main(int argc, const char * argv[]) &#123; int arr[ARR_LEN] = &#123;8,1,4,10,3,6,2,7,9,5&#125;; printf(&quot;排序前：\\n&quot;); print_arr(arr, ARR_LEN); select_sort(arr, ARR_LEN); printf(&quot;排序后：\\n&quot;); print_arr(arr, ARR_LEN); return 0;&#125; ssort.c 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;// 交换static void swap(int *a,int *b)&#123; int temp = *a; *a = *b; *b = temp;&#125;// 打印数组extern void print_arr(int arr[],int len)&#123; for (int i = 0; i &lt; len; i++) &#123; printf(&quot;%d&quot;,arr[i]); &#125; printf(&quot;\\n&quot;);&#125;// 选择排序extern void select_sort(int arr[],int len)&#123; int i,j; for (i = 0; i &lt; len; i ++) &#123; for (j = i+1; j &lt; len; j++) &#123; if (arr[i] &gt; arr[j])&#123; swap(&amp;arr[i], &amp;arr[j]); &#125; &#125; &#125;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习04：语句和控制块","slug":"C学习/C语言学习04：语句和控制块","date":"2023-02-13T04:58:15.000Z","updated":"2023-03-01T13:50:46.354Z","comments":true,"path":"2023/02/13/C学习/C语言学习04：语句和控制块/","link":"","permalink":"https://www.bboyzj.cn/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A004%EF%BC%9A%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%8E%A7%E5%88%B6%E5%9D%97/","excerpt":"","text":"输入输出语句 printf(格式控制,输出表列) %d格式符：输出有符号十进制整数。 c格式符：输出一个字符。 s格式符：输出一个字符串。 f格式符：%f-实数部分全部输出，小数部分输出6位。%m.nf-m表示包括小数在内的整个浮点数长度，n表示小数点保留几位。 p格式符：用来输出地址。 scanf 一般形式为 scanf(格式控制,地址表列) 正则 需要通过 #include &lt;regex.h&gt; 库 %[abc]：读取a&#x2F;b&#x2F;c任意一员 %[^a-z]：读取不在a-z之间的字符串 %[^&#x3D;]：读取字符串直到碰到&#x3D;号 %[^&#x3D;]：前面号表示不保存变量 字符输入输出 putchar(c)：用于输出字符c c &#x3D; getchar()：用于输入一个字符，返回的不是char类型，而是 int 类型 一般用法 while(c&#x3D;getchar() &amp;&amp; a!&#x3D;EOF) { } EOF：指检测文件尾，宏定义值为-1 判断语句 if(…){} if(…){} else{} if(…){} else if(…){} … else{…} switch(表达式){case 常量1:语句1;case 常量2:语句2;…;case 常量n:语句n;default:语句n+1} 循环语句 while while (表达式) { 语句} do…while：至少会执行一次 do 语句while (表达式); for for (表达式1,表达式2,表达式3) 语句 循环打断 break 或 goto continue continue 不跳出循环，而是将程序执行跳转到末尾处 练习题 循环打印字符串 123456789101112#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; char str[] = &quot;Hello World!&quot;; size_t len = sizeof(str)/sizeof(char); printf(&quot;%zu\\n&quot;,len); for (int i = 0; i&lt;len; i++) &#123; printf(&quot;%c\\n&quot;,str[i]); &#125; return 0;&#125; 判断字符 12345678910111213141516171819202122232425262728293031323334// 声明void judge_char(char ch);int main(int argc, const char * argv[]) &#123; char ch; printf(&quot;请输入一个字符：&quot;); scanf(&quot;%c&quot;,&amp;ch); judge_char(ch); return 0;&#125;// 定义void judge_char(char ch)&#123; /* getchar和putchar 专门用于字符的输入和输出 getchar()写法上要为 变量 = getchar(); putchar()写法上要为 putchar(变量) getchar(&#x27;\\n&#x27;)输出一个控制符 putchar(&#x27;字母/字符&#x27;);输出一个字母/字符 */// ch = getchar(); if (ch &lt; 31) &#123; printf(&quot;这是一个控制字符或通讯专用字符!\\n&quot;); &#125;else if (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123; printf(&quot;这是一个数字!&quot;); &#125;else if (ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;) &#123; printf(&quot;这是一个大写字母!\\n&quot;); &#125;else if (ch &gt;= &#x27;a&#x27; &amp;&amp; ch &lt;= &#x27;z&#x27;) &#123; printf(&quot;这是一个小写字母!\\n&quot;); &#125;else &#123; printf(&quot;这是其他字符!\\n&quot;); &#125;&#125; 任意输入3个整数，使用if语句对这3个语句从小到大升序排序。 123456789101112131415161718192021222324252627// 交换x,yvoid swap(int *x,int *y)&#123; int temp = *x; *x = *y; *y = temp;&#125;int main(int argc, const char * argv[]) &#123; int a,b,c; printf(&quot;请输入a,b,c:\\n&quot;); scanf(&quot;%d,%d,%d&quot;,&amp;a,&amp;b,&amp;c); if (a&gt;b)&#123; swap(&amp;a, &amp;b); &#125; if (a&gt;c)&#123; swap(&amp;a, &amp;c); &#125; if (b&gt;c)&#123; swap(&amp;b, &amp;c); &#125; printf(&quot;升序排序结果：\\n&quot;); printf(&quot;%d,%d,%d\\n&quot;,a,b,c); return 0;&#125; 九九乘法表 1234567891011int main(int argc, const char * argv[]) &#123; int i = 0; int j = 0; for (i = 1; i &lt;= 9; i++) &#123; for (j = 1; j &lt;= 9; j++) &#123; printf(&quot;%d*%d=%2d\\t&quot;,i,j,i*j); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 使用goto语句模拟循环，求10以内整数之和。 1234567891011121314#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; int sum = 0; int i = 0; LOOP: if (++i &lt;= 10) &#123; sum += i; goto LOOP; &#125; printf(&quot;10以内的正整数之和为：%d\\n&quot;,sum); return 0;&#125; while循环：最大公约数 和 最小公倍数 公约数：几个自然数共有的约数，为他们的公约数最大公约数：公约数中的最大一个 公倍数：能够被一个整数整除额整数成为其倍数最小公倍数：两个或多个整数的公倍数最小的一个 问：使用while循环，求两个正整数的最大公约数和最小公倍数 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; int a,b,m,c; printf(&quot;请输入两个数：&quot;); scanf(&quot;%d,%d&quot;,&amp;a,&amp;b); // 给两个整数排序 if (a&lt;b)&#123; int temp = a; a = b; b = temp; &#125; m = a*b; c = a%b; while (c != 0) &#123; a = b; // 最大公约数 b = c; c = a%b; &#125; printf(&quot;最大公约数是：%d\\n&quot;,b); printf(&quot;最小公倍数是：%d\\n&quot;,m/b); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习03：运算符和表达式","slug":"C学习/C语言学习03：运算符和表达式","date":"2023-02-12T18:10:04.000Z","updated":"2023-03-07T05:14:48.910Z","comments":true,"path":"2023/02/13/C学习/C语言学习03：运算符和表达式/","link":"","permalink":"https://www.bboyzj.cn/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A003%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"测试题 判断正整数的位数 1234567891011121314151617181920212223#include &lt;stdio.h&gt;// 声明void IntCount(int num);// 入口函数int main(int argc, const char * argv[]) &#123; // 判断正整数的位数 int num; printf(&quot;请输入一个正整数：&quot;); scanf(&quot;%d&quot;,&amp;num); IntCount(12345); return 0;&#125;// 判断正整数的位数void IntCount(int num) &#123; int count = 0; // 位数 while (num &gt; 0) &#123; num = num/10; count += 1; &#125; printf(&quot;%d\\n&quot;, count);&#125; 打印100以内（包含100）能被10整除的正整数 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; // 打印100以内被10整除的正整数 int i = 1; while (i &lt; 100) &#123; if (i % 10 == 0) &#123; printf(&quot;%d\\n&quot;,i); &#125; i ++; &#125; return 0;&#125;==========102030405060708090 输入两个闭区间，并判断两个区间是否重叠？ 1234567891011121314151617181920#define MAX(a,b) ((a&gt;b) ? a:b)#define MIN(a,b) ((a&lt;b) ? a:b)int main(int argc, const char * argv[]) &#123; int start_1,end_1; int start_2,end_2; printf(&quot;请输入第一个闭区间(逗号分割)：&quot;); scanf(&quot;%d,%d&quot;,&amp;start_1,&amp;end_1); printf(&quot;请输入第二个闭区间(逗号分割)：&quot;); scanf(&quot;%d,%d&quot;,&amp;start_2,&amp;end_2); if (MIN(end_1, end_2) &lt; MAX(start_1, start_2)) &#123; printf(&quot;不重叠&quot;); &#125;else &#123; printf(&quot;重叠&quot;); &#125; return 0;&#125; 输入任意年份的正整数n，判断该年份是否为闰年？ 闰年的定义：能被400整除的年份为闰年；能被4整除同时不能被100整除的年份是闰年 闰年一年有366天，2月份有29天平年一年有365天，2月份有28天 1234567891011121314151617// 判断闰年void is_leap_year(int year)&#123; if (year%400==0 || (year%4==0 &amp;&amp; year%100!=0)) &#123; printf(&quot;%d年是闰年\\n&quot;,year); &#125;else&#123; printf(&quot;%d年不是闰年\\n&quot;,year); &#125;&#125;int main(int argc, const char * argv[]) &#123; // 判断闰年 int year; printf(&quot;请输入年份：&quot;); scanf(&quot;%d&quot;,&amp;year); is_leap_year(year); return 0;&#125; 打印邮费价格表，输出20kg以内物品的邮费价格表，邮费计算规则如下： 1kg以内6元 超过1kg,每增加1kg加收2元 注：逗号运算符与表达式小知识 1.逗号运算符的优先级是所有运算符中最低的 2.整个逗号表达式的值为其中最后一个子表达式的值 3.逗号运算符常用在for循环头部初始化或递增多个变量 123456789101112#define FIRST_COST 6#define NEXT_COST 2int main(int argc, const char * argv[]) &#123; int weight,cost; printf(&quot;重量\\t价格\\t\\n&quot;); for (weight=1,cost=FIRST_COST;weight&lt;=10;++weight,cost=FIRST_COST+(weight-1)*NEXT_COST) &#123; printf(&quot;%d\\t￥%d\\n&quot;,weight,cost); &#125; return 0;&#125; 输入三个整数，求出最大值并输出？ 123456789int main(int argc, const char * argv[]) &#123; int a,b,c,max; printf(&quot;请输入3个整数：&quot;); scanf(&quot;%d,%d,%d&quot;,&amp;a,&amp;b,&amp;c); max = c&gt;((a&gt;b)?a:b) ? c:((a&gt;b)?a:b); printf(&quot;3个数中的最大值是：%d\\n&quot;,max); return 0;&#125; 定义并初始化一个整型数组（未显示指定数组长度），循环输出数组中每个元素。在完成以上任务的过程中，为了得到数组的长度，需要借助sizeof运算符？ 小知识： 1.sizeof在使用的时候看上去像是一个函数（因为后面有一对小括号），但他是一个运算符。它的使用方法有以下三种： a)sizeof(变量名) b)sizeof(数据类型名) c)sizeof 变量名 2. sizeof的返回值类型是size_t 12345678910int main(int argc, const char * argv[]) &#123; int arr[]=&#123;1,2,3,4,5&#125;; size_t len = sizeof(arr)/sizeof(arr[0]); size_t i; for (i=0; i&lt;len; ++i) &#123; printf(&quot;%d\\n&quot;,arr[i]); &#125; return 0;&#125; 根据运算符优先级及求职顺序，使程序输出结果为2，3，1 12345678910int main(int argc, const char * argv[]) &#123; int x,y,z; printf(&quot;请输入2个整数：&quot;); scanf(&quot;%d,%d&quot;,&amp;x,&amp;y); z=x++,++y,y++; printf(&quot;%d,%d,%d\\n&quot;,x,y,z); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习02：变量的类型","slug":"C学习/C语言学习02：变量","date":"2023-02-12T16:52:46.000Z","updated":"2023-03-07T04:49:39.109Z","comments":true,"path":"2023/02/13/C学习/C语言学习02：变量/","link":"","permalink":"https://www.bboyzj.cn/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A002%EF%BC%9A%E5%8F%98%E9%87%8F/","excerpt":"","text":"变量 什么是变量？ 变量表示 内存中的一个存储区域（不同的数据类型，占用的空间大小不一样） 为什么需要变量？ 答：变量是其程序的 基本组成单位 定义变量type variable_list; type：变量类型 variable_list：一个或多个标识符组成，多个用逗号分割 1int i, j, k; 变量的声明变量的声明有两种： 一种是需要建立存储空间。 int i; &#x2F;&#x2F; 声明，也是定义 另一种是不需要建立存储空间的，用 extern关键字 声明的。 extern int i; &#x2F;&#x2F; 声明，不是定义","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习01：C语言概述","slug":"C学习/C语言学习01：C语言概述","date":"2023-02-12T16:32:23.000Z","updated":"2023-03-07T04:03:58.139Z","comments":true,"path":"2023/02/13/C学习/C语言学习01：C语言概述/","link":"","permalink":"https://www.bboyzj.cn/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A001%EF%BC%9AC%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/","excerpt":"","text":"C语言特点C 语言是一门过程性语言，C 语言可以 代替机器语言或汇编语言编写运行速度快的程序。 语言简洁，使用方便灵活 可移植性好 表达能力强 表达方式灵活 可进行结构化程序设计 可以直接操作计算机硬件 生成的目标代码质量高 编程机制C 语言程序从源代码到二进制程序都经历了哪些过程？ 预处理(Preprocession) 预处理用于将所有的 #include头文件及宏定义 替换成 真正的内容test.c 到 test.i 编译(Complication) 编译过程将 预处理之后的程序 转换成特定的 汇编代码(Assemble Code)test.i 到 test.s 汇编(Assemble) 汇编过程将 汇编代码 转换成 机器码(machine code)，这一步产生的文件叫 目标文件，每一个 源文件 都会产生一个 目标文件test.s 到 test.o 链接(Linking) 链接过程将 多个目标文件及所需的库文件 链接成最终的 可执行文件(executable file)","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"OC数据结构00：入门","slug":"数据结构和算法/OC数据结构00：入门","date":"2022-11-23T00:55:26.000Z","updated":"2023-03-07T04:47:05.090Z","comments":true,"path":"2022/11/23/数据结构和算法/OC数据结构00：入门/","link":"","permalink":"https://www.bboyzj.cn/2022/11/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8400%EF%BC%9A%E5%85%A5%E9%97%A8/","excerpt":"","text":"概述 数据结构概念： 我们把现实中 大量复杂的问题 以特定的数据类型和特定的存储结构保存到 主存储器（内存）中，在此基础上实现某个功能（排序等）的操作叫 算法。 数据结构 &#x3D; 元素 + 元素关系 算法 &#x3D; 对数据结构的操作 算法：解决问题的方法和步骤 衡量标准： 时间复杂度：算法要执行的次数，非执行时间 空间复杂度：算法执行过程 大概要占用的最大内存 指针定义 地址 地址是内存单元的编号，其编号从 0 开始的非负整数，范围：0 – 0xFFFFFFFF x64平台下最大内存地址为 2^64 - 1 指针 指针就是地址，地址就是指针 即 * = &amp;，指针变量 是存放 内存单元地址 的变量，它内部保存的值是对应的 地址， 地址就是内存单元编号。 例子： 123456int i = 10; // 定义一个 整形变量 i 初始值 10int *p = i; // 定义一个 整形的指针变量p，变量p 指向 i的地址// 这两行等于上面两行int *p; *p = &amp;i; 结构体结构体是用户根据自己的实际需要，自定义的复合数据类型 12345678910// 学生类型typedef struct Student &#123; // 结构体定义 int age; char *name;&#125;myStudent;// 直接传递 只占用 4 byte 的指针，省时效率也高&lt;推荐用法&gt;void func(struct Student *p)&#123; print(&quot;age = %d&quot;,p)&#125; 有两种结构体的使用方式： 直接使用 1struct Student stu = &#123;12,&quot;xiaojian&quot;&#125;; 通过指针使用 12struct Student *p = &amp;stu;p -&gt; age = 31;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.bboyzj.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"OC-数据结构探索篇","slug":"OC-数据结构探索篇","permalink":"https://www.bboyzj.cn/tags/OC-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.bboyzj.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"OC数据结构02：二叉树探索","slug":"数据结构和算法/OC数据结构02：二叉树探索","date":"2020-08-26T08:35:40.000Z","updated":"2023-03-06T10:16:16.075Z","comments":true,"path":"2020/08/26/数据结构和算法/OC数据结构02：二叉树探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"什么是二叉树树形结构，两个节点 以内均称为 二叉树，分为 左子树 和 右子树，有顺序，不能颠倒；比如把人看做树：头是树根，左右是坐子树，右手是右子树。 二叉树遍历类型 深度优先遍历：采用栈 先序遍历：对任一子树，先访问根，然后遍历左子树，最后遍历其右子树 中序遍历：对任一子树，先遍历左子树，然后访问根，最后遍历其右子树 后序遍历：对任一子树，先遍历其左子树，然后遍历其右子树，最后访问根 广度优先遍历：采用队列 层次遍历，从上往下 对每一层依次访问，每一层从 左往右（或从右往左）访问节点，访问完一层就进入下一层，直到没有节点可以访问为止。 区别： 深度优先算法：不全部保留节点，占用空间小，有回溯操作，运行速度慢，用时间换空间 广度优先算法：保留全部节点，占用空间大，无回溯操作，运行速度快，用空间换时间 二叉排序树的好处？二叉树是一种比较折中的方案；数组的搜索比较方便，可以直接用下标，但删除或插入比较耗时；链表与之相反，删除或插入很快，但查找很慢；二叉排序树既有链表的好处，也有数组的好处，在处理大批量的动态数据是比较有用的 二叉排序树节点定义采用单项链表的形式，只从根节点指向孩子节点，不保存父节点。 对于二叉搜索树这种数据类型，用简单的数组来表示是不适合的。所以要建立一个模型： 值：就用最简单的整数来表示，实际使用中，这个整型值也是必不可少的，可以当做key来用，这是二叉搜索树排序的凭证。 左子树：用一个同类型的指针表示 右子树：用一个同类型的指针表示 以上3个是二叉搜索树必不可少的属性 123456789// 二叉排序树节点@interface BinaryTreeNode : NSObject// 值@property (nonatomic, assign) NSInteger value;// 左节点@property (nonatomic, strong) BinaryTreeNode *leftNode;// 右节点@property (nonatomic, strong) BinaryTreeNode *rightNode;@end 如何验证两个二叉树是完全相等的？递归 去判断每个节点的 值 是否相等，如果均相等，则两个二叉树完全相等 123456789101112- (void)isSameTree:(TreeNode *)root1 tree:(TreeNode *)root2&#123; if (root1 == null &amp;&amp; root2 == null) &#123; return true; &#125; if ((root1 == null &amp;&amp; root2 != null) || (root1 != null &amp;&amp; root2 == null))&#123; return false; &#125; if (root1.val != root2.val) &#123; // 判断每个节点的值是否相等，如果去除此判断，则判断两个二叉树是否结构相等 return false; &#125; return [self isSameTree:root1.left tree:root2.left] &amp;&amp; [self isSameTree:root1.right tree:root2.right];&#125; 创建二叉排序树 二叉树中左右节点值本身没有大小之分，所以如果要创建二叉树，就需要考虑如何处理某个节点是左节点还是右节点，如何终止某个子树而切换到另一个子树。 因此我选择了 二叉排序树，二叉排序树中对于左右节点有明确的要求，程序可以自动根据键值大小自动选择是左节点还是右节点。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 创建二叉排序树 * 二叉排序树：左节点值全部小于根节点值，右节点值全部大于根节点值 * @param values 数组 * @return 二叉树根节点 */+ (BinaryTreeNode *)createTreeWithValues:(NSArray *)values &#123; BinaryTreeNode *root = nil; for (NSInteger i=0; i&lt;values.count; i++) &#123; NSInteger value = [(NSNumber *)[values objectAtIndex:i] integerValue]; root = [BinaryTree addTreeNode:root value:value]; &#125; return root;&#125;/** * 向二叉排序树节点添加一个节点 * * @param treeNode 根节点 * @param value 值 * * @return 根节点 */+ (BinaryTreeNode *)addTreeNode:(BinaryTreeNode *)treeNode value:(NSInteger)value &#123; //根节点不存在，创建节点 if (!treeNode) &#123; treeNode = [BinaryTreeNode new]; treeNode.value = value; NSLog(@&quot;node:%@&quot;, @(value)); &#125; else if (value &lt;= treeNode.value) &#123; NSLog(@&quot;to left&quot;); // 值小于根节点，则插入到左子树 treeNode.leftNode = [BinaryTree addTreeNode:treeNode.leftNode value:value]; &#125;else &#123; NSLog(@&quot;to right&quot;); // 值大于根节点，则插入到右子树 treeNode.rightNode = [BinaryTree addTreeNode:treeNode.rightNode value:value]; &#125; return treeNode;&#125; 实际使用 1）创建一个二叉树类BinaryTreeNode，在类中实现如下代码： 12345678910111213141516171819#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface BinaryTreeNode : NSObject// 值：当做key来用，是排序用的凭证@property (nonatomic,assign)NSInteger value;// 左子树@property (nonatomic,strong)BinaryTreeNode * leftChild;// 右子树@property (nonatomic,strong)BinaryTreeNode * rightChild;// 创建二叉排序树+ (BinaryTreeNode *)createBinaryTreeWithValues:(NSArray *)values;// 向二叉排序树中添加一个节点+ (BinaryTreeNode *)addNode:(BinaryTreeNode *)rootNode value:(NSInteger)value;@endNS_ASSUME_NONNULL_END 12345678910111213141516171819202122232425262728293031323334353637383940/* 创建二叉排序树 二叉排序树：左节点值全部小于根节点值，右节点值全部大于根节点值 @param values：数组 @return 二叉排序树根节点 */+ (BinaryTreeNode *)createBinaryTreeWithValues:(NSArray *)values&#123; BinaryTreeNode * rootNode = nil; for (NSNumber * number in values) &#123; NSInteger value = [number integerValue]; rootNode = [BinaryTreeNode addNode:rootNode value:value]; &#125; return rootNode;&#125;/* 向二叉排序树节点添加一个节点 @param rootNode 根节点 @param value 值 @return 根节点 */+ (BinaryTreeNode *)addNode:(BinaryTreeNode *)rootNode value:(NSInteger)value&#123; // 根节点不存在，创建节点 if (rootNode == nil) &#123; rootNode = [[BinaryTreeNode alloc] init]; rootNode.value = value; NSLog(@&quot;node:%@&quot;,@(value)); &#125;else if (value &lt;= rootNode.value) &#123; NSLog(@&quot;to left&quot;); // 值小于根节点，则插入到左子树；这是递归，左子树将做同样的事儿 rootNode.leftChild = [self addNode:rootNode.leftChild value:value]; &#125;else if (value &gt; rootNode.value) &#123; NSLog(@&quot;to right&quot;); // 值大于根节点，则插入到右子树；这是递归，右子树将做同样的事儿 rootNode.rightChild = [self addNode:rootNode.rightChild value:value]; &#125;else &#123; NSLog(@&quot;二叉排序树没有键值相等的节点，值%@已存在，不能插入&quot;,@(value)); &#125; return rootNode;&#125; 2）在controller中，用一个属性持有这个二叉搜索树。 12345678#import &quot;ViewController.h&quot;//二叉树#import &quot;BinaryTreeNode.h&quot;@interface ViewController ()// 二叉搜索树的根节点，代表一棵树@property (strong, nonatomic) BinaryTreeNode *rootNode;@end 输入用一串值，得到一颗二叉搜索树 1234567- (void)viewDidLoad &#123; [super viewDidLoad]; //创建一个二叉树 NSArray *values = @[@200, @23, @456, @89, @23, @670, @5674, @15]; self.rootNode = [BinaryTreeNode createBinaryTreeWithValues:values]; &#125; 3）用断点，查看“链式”结构，同时通过log可以看出创建过程。 4）生成的二叉树图 先序遍历 先访问根，再遍历左子树，再遍历右子树。典型的递归思想。 123456789101112131415161718/** * 先序遍历 * 先访问根，再遍历左子树，再遍历右子树 * * @param rootNode 根节点 * @param handler 访问节点处理函数 */+ (void)preOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123; if (rootNode) &#123; // 先根 if (handler) &#123; handler(rootNode); &#125; // 再左 [self preOrderTraverseTree:rootNode.leftNode handler:handler]; // 最后右 [self preOrderTraverseTree:rootNode.rightNode handler:handler]; &#125;&#125; 实际使用 12345678// 先序遍历- (void)preOrderTraverse&#123; NSMutableArray * preArr = [NSMutableArray array]; [BinaryTreeNode preOrderTraverseTree:self.rootNode handler:^(BinaryTreeNode * _Nonnull treeNode) &#123; [preArr addObject:[NSNumber numberWithInteger:treeNode.value]]; &#125;]; NSLog(@&quot;先序遍历：%@&quot;, preArr);&#125; 查看打印结果： 1234567892020-08-26 22:45:09.310234+0800 OC-二叉树[50561:2829401] 先序遍历：( 200, 23, 15, 89, 456, 670, 5674) 中序遍历 先遍历左子树，再访问根，再遍历右子树。对于二叉排序树来说，中序遍历得到的序列是一个从小到大排序好的序列。 12345678910111213141516/** * 中序遍历 * 先遍历左子树，再访问根，再遍历右子树 * * @param rootNode 根节点 * @param handler 访问节点处理函数 */+ (void)inOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123; if (rootNode) &#123; [self inOrderTraverseTree:rootNode.leftNode handler:handler]; if (handler) &#123; handler(rootNode); &#125; [self inOrderTraverseTree:rootNode.rightNode handler:handler]; &#125;&#125; 实际使用 12345678//中序遍历- (void)inOrderTraverse&#123; NSMutableArray * inArr = [NSMutableArray array]; [BinaryTreeNode inOrderTraverseTree:self.rootNode handler:^(BinaryTreeNode * _Nonnull treeNode) &#123; [inArr addObject:[NSNumber numberWithInteger:treeNode.value]]; &#125;]; NSLog(@&quot;中序遍历：%@&quot;, inArr);&#125; 查看打印结果 1234567892020-08-26 22:49:26.310344+0800 OC-二叉树[50591:2832806] 中序遍历：( 15, 23, 89, 200, 456, 670, 5674) 后续遍历 先遍历左子树，再遍历右子树，再访问根 12345678910111213141516/** * 后序遍历 * 先遍历左子树，再遍历右子树，再访问根 * * @param rootNode 根节点 * @param handler 访问节点处理函数 */+ (void)afterOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123; if (rootNode) &#123; [self afterOrderTraverseTree:rootNode.leftNode handler:handler]; [self afterOrderTraverseTree:rootNode.rightNode handler:handler]; if (handler) &#123; handler(rootNode); &#125; &#125;&#125; 实际使用 12345678//后序遍历- (void)afterOrderTraverse&#123; NSMutableArray * afterArr = [NSMutableArray array]; [BinaryTreeNode afterOrderTraverseTree:self.rootNode handler:^(BinaryTreeNode * _Nonnull treeNode) &#123; [afterArr addObject:[NSNumber numberWithInteger:treeNode.value]]; &#125;]; NSLog(@&quot;后序遍历：%@&quot;, afterArr);&#125; 查看打印结果 123456789102020-08-26 22:51:50.637367+0800 OC-二叉树[50628:2835309] 后序遍历：( 15, 89, 23, 5674, 670, 456, 200) 翻转二叉树 你会翻转二叉树吗？如果不会，那对不起，我们不会录用你！ 翻转二叉树，又叫求二叉树的镜像，就是把二叉树的左右子树对调（当然是递归的） 1234567891011121314151617181920212223242526272829/* 翻转二叉树（又叫：二叉树的镜像） @param rootNode 根节点 @return 翻转后的树根节点（其实就是原二叉树的根节点） */// 翻转二叉树+ (BinaryTreeNode *)flipBinaryTree:(BinaryTreeNode *)rootNode&#123; // 判空 if(!rootNode)&#123; return nil; &#125; // 没有子节点 if(!rootNode.leftNode &amp;&amp; !rootNode.rightNode)&#123; return rootNode; &#125; // 左右子树递归 [self flipBinaryTree:rootNode.leftNode]; [self flipBinaryTree:rootNode.rightNode]; // 左右节点交换 BinaryTreeNode * tempNode = rootNode.leftNode; rootNode.leftNode = rootNode.rightNode; rootNode.rightNode = tempNode.leftNode; return rootNode;&#125; 实际使用 1234// 翻转二叉树- (void)invertBinaryTree&#123; self.rootNode = [BinaryTreeNode invertBinaryTree:self.rootNode];&#125; 查看打印结果 生成二叉树的图 查找二叉树中某个位置的结点类似索引操作，按 层次 遍历，位置从0开始算。 12345678910111213141516171819202122232425262728293031323334353637/* 查找二叉树某个位置的结点 @param index 按层次便利树是的位置（从0开始） @param rootNode 树根结点 @return 结点 */// 指定位置查找节点+ (BinaryTreeNode *)findTreeNodeAtIndex:(int)index withRootTree:(BinaryTreeNode *)rootNode&#123; // 如果节点不存在，查找位置不符合规范 if (!rootNode || index &lt; 0)&#123; return nil; &#125; NSMutableArray * queueArr = [NSMutableArray arrayWithCapacity:0]; // 压入根节点 [queueArr addObject:rootNode]; while (queueArr.count &gt; 0) &#123; BinaryTreeNode * node = [queueArr firstObject]; // 如果是根节点，则直接返回 if(index == 0)&#123; return node; &#125; // 仿照队列先进先出FIFO，移除最前面的节点 [queueArr removeObjectAtIndex:0]; index --; // 按照从左往右依次压入节点 if(node.leftNode)&#123; [queueArr addObject:node.leftNode]; &#125; if(node.rightNode)&#123; [queueArr addObject:node.rightNode]; &#125; &#125; // 遍历完，还没有找到位置，返回nil return nil;&#125; 在controller中调用 12345678// 查找某个位置的节点- (void)searchNode&#123; BinaryTreeNode * node = [BinaryTreeNode findTreeNodeAtIndex:4 withTree:self.rootNode]; NSLog(@&quot;node-------%@&quot;,[NSNumber numberWithInteger:node.value]);&#125;********打印结果******2020-08-27 11:29:47.724120+0800 OC-二叉树[51450:2892148] node-------89 层次遍历 按照从上到下、从左到右的次序进行遍历。先遍历完一层，再遍历下一层，因此又叫广度优先遍历。需要用到队列，在OC里可以用可变数组来实现。 根改了：NSArray *values &#x3D; @[@100, @23, @45, @89, @23, @67, @54, @15]; 1234567891011121314151617181920212223242526272829303132333435/*层次遍历（广度优先）@param rootNode 树根节点@param handler 访问节点处理函数*/// 层次遍历+ (void)levelTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *))handler&#123; // 空节点 if(!rootNode)&#123; return; &#125; // 数组当成队列 NSMutableArray * queueArr = [NSMutableArray array]; // 压入根节点 [queueArr addObject:rootNode]; // 当队列有数据的时候去遍历 while (queueArr.count &gt; 0) &#123; BinaryTreeNode * node = [queueArr firstObject]; if (handler)&#123; handler(node); &#125; // 仿照队列先进先出FIFO，移除最前面的节点 [queueArr removeObjectAtIndex:0]; // 按照从左往右依次压入节点 if(node.leftNode)&#123; [queueArr addObject:node.leftNode]; &#125; if(node.rightNode)&#123; [queueArr addObject:node.rightNode]; &#125; &#125;&#125; 在controller中调用 12345678//层次遍历- (void)levelTraverse&#123; NSMutableArray * levelArr = [NSMutableArray array]; [BinaryTreeNode levelTraverseTree:self.rootNode handler:^(BinaryTreeNode * _Nonnull treeNode) &#123; NSLog(@&quot;value:%ld&quot;,treeNode.value); [levelArr addObject:treeNode]; &#125;];&#125; 次遍历：查看打印结果 12345672020-08-31 17:18:50.185983+0800 OC-二叉树[59736:4179500] value:1002020-08-31 17:18:50.186414+0800 OC-二叉树[59736:4179500] value:232020-08-31 17:18:50.186896+0800 OC-二叉树[59736:4179500] value:152020-08-31 17:18:50.187158+0800 OC-二叉树[59736:4179500] value:452020-08-31 17:18:50.187479+0800 OC-二叉树[59736:4179500] value:892020-08-31 17:18:50.187753+0800 OC-二叉树[59736:4179500] value:672020-08-31 17:18:50.188040+0800 OC-二叉树[59736:4179500] value:54 二叉树的深度 二叉树的深度定义为：从根节点到叶子结点依次经过的结点形成树的一条路径,最长路径的长度为树的深度。1）如果根节点为空，则深度为0；2）如果左右节点都是空，则深度为1；3）递归思想：二叉树的深度&#x3D;max（左子树的深度，右子树的深度）+ 1 12345678910111213141516171819202122/* 二叉树的深度 @param rootNode 二叉树根节点 @return 二叉树的深度 */// 二叉树的深度+ (NSInteger)depthOfTree:(BinaryTreeNode *)rootNode&#123; if (!rootNode)&#123; return 0; &#125; if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode)&#123; return 1; &#125; // 左子树深度 NSInteger leftDepth = [self depthOfTree:rootNode.leftNode]; // 右子树深度 NSInteger rightDepth = [self depthOfTree:rootNode.rightNode]; // 二叉树深度 NSInteger totalDepth = MAX(leftDepth, rightDepth) + 1; return totalDepth;&#125; 在controller中调用 12345//树的深度- (void)depthTree&#123; NSInteger depth = [BinaryTreeNode depthOfTree:self.rootNode]; NSLog(@&quot;depth:%ld&quot;,depth);&#125; 查看结果 12020-08-31 17:29:49.989752+0800 OC-二叉树[59816:4186549] depth:6 二叉树的宽度二叉树的 宽度 定义为各层节点数的最大值。 12345678910111213141516171819202122232425262728293031323334353637/** * 二叉树的宽度 * @param rootNode 二叉树根节点 * @return 二叉树宽度 */+ (NSInteger)widthOfTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return 0; &#125; NSMutableArray * queueArray = [NSMutableArray array]; [queueArray addObject:rootNode]; // 压入根节点 NSInteger maxWidth = 1; // 最大的宽度，初始化为1（因为已经有根节点） NSInteger curWidth = 0; // 当前层的宽度 while (queueArray.count &gt; 0) &#123; curWidth = queueArray.count; //依次弹出当前层的节点 for (NSInteger i=0; i&lt;curWidth; i++) &#123; BinaryTreeNode * node = [queueArray firstObject]; // 弹出最前面的节点，仿照队列先进先出原则 [queueArray removeObjectAtIndex:0]; // 压入左子数 if (node.leftNode) &#123; [queueArray addObject:node.leftNode]; &#125; // 压入右子树 if (node.rightNode) &#123; [queueArray addObject:node.rightNode]; &#125; &#125; // 宽度 = 当前层节点数 maxWidth = MAX(maxWidth, queueArray.count); &#125; return maxWidth;&#125; vc实现 123// 二叉树宽度NSInteger width = [BinaryTreeNode widthOfTree:self.rootNode];NSLog(@&quot;width-%ld&quot;,width); 打印结果 12022-11-26 16:21:36.767352+0800 二叉树[4523:170689] width-2 二叉树的所有节点数递归思想：二叉树所有节点数 &#x3D; 左子树节点数 + 右子树节点数 + 1 1234567891011121314151617/** * 二叉树的所有节点数 * * @param rootNode 根节点 * * @return 所有节点数 */// 二叉树所有节点数+ (NSInteger)numberOfNodesInTree:(BinaryTreeNode *)rootNode&#123; if (!rootNode)&#123; return 0; &#125; // 总节点数 = 左子树节点数 + 右子树节点数 + 1 NSInteger totalNode = [self numberOfNodesInTree:rootNode.leftNode] + [self numberOfNodesInTree:rootNode.rightNode] + 1; return totalNode;&#125; vc实现 123// 二叉树节点数NSInteger totalNode = [BinaryTreeNode numberOfNodesInTree:self.rootNode];NSLog(@&quot;totalNode-%ld&quot;,totalNode); 打印结果 12022-11-26 16:10:38.371816+0800 二叉树[4369:160462] totalNode-5 二叉树某层中的节点数1）根节点为空，则节点数为0； 2）层为1，则节点数为1（即根节点） 3）递归思想：二叉树第k层节点数 &#x3D; 左子树第k-1层节点数 + 右子树第k-1层节点数 12345678910111213141516171819202122/** * 二叉树某层中的节点数 * * @param level 层 * @param rootNode 根节点 * * @return 层中的节点数 */// 二叉树某层中的节点数+ (NSInteger)numberOfNodesOnLevel:(NSInteger)level inTree:(BinaryTreeNode *)rootNode&#123; // 根节点不存在 或 level &lt; 0 if (!rootNode || level &lt; 1) &#123; return 0; &#125; // level = 1，返回1（根节点） if (level == 1) &#123; return 1; &#125; // 递归：level层节点数 = 左子树level-1层节点数 + 右子树level-1层节点数 NSInteger levelNode = [self numberOfNodesOnLevel:level-1 inTree:rootNode.leftNode] + [self numberOfNodesOnLevel:level-1 inTree:rootNode.rightNode]; return levelNode;&#125; vc实现 123// 某层节点数NSInteger levelNode = [BinaryTreeNode numberOfNodesOnLevel:1 inTree:self.rootNode];NSLog(@&quot;levelNode-%ld&quot;,levelNode); 打印结果 12022-11-26 16:27:02.360866+0800 二叉树[4593:175705] levelNode-1 二叉树叶子节点数叶子节点，又叫终端节点，是左右子树都是空的节点。 123456789101112131415161718/** * 二叉树叶子节点数 * * @param rootNode 根节点 * * @return 叶子节点数 */+ (NSInteger)numberOfLeafsInTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return 0; &#125; // 左子树和右子树都是空，说明是叶子节点 if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123; return 1; &#125; // 递归：叶子数 = 左子树叶子数 + 右子树叶子数 return [self numberOfLeafsInTree:rootNode.leftNode] + [self numberOfLeafsInTree:rootNode.rightNode];&#125; 二叉树最大距离（二叉树的直径）二叉树中任意两个节点都有且仅有一条路径，这个路径的长度叫这两个节点的距离。二叉树中所有节点之间的距离的最大值就是二叉树的直径。 有一种解法，把这个最大距离划分了3种情况： 1）这2个节点分别在根节点的左子树和右子树上，他们之间的路径肯定经过根节点，而且他们肯定是根节点左右子树上最远的叶子节点（他们到根节点的距离&#x3D;左右子树的深度）。 2）这2个节点都在左子树上 3）这2个节点都在右子树上 综上，只要取这3种情况中的最大值，就是二叉树的直径。 12345678910111213141516171819202122/** * 二叉树最大距离（直径） * * @param rootNode 根节点 * * @return 最大距离 */+ (NSInteger)maxDistanceOfTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return 0; &#125;// 方案一：（递归次数较多，效率较低） //分3种情况： //1、最远距离经过根节点：距离 = 左子树深度 + 右子树深度 NSInteger distance = [self depthOfTree:rootNode.leftNode] + [self depthOfTree:rootNode.rightNode]; //2、最远距离在根节点左子树上，即计算左子树最远距离 NSInteger disLeft = [self maxDistanceOfTree:rootNode.leftNode]; //3、最远距离在根节点右子树上，即计算右子树最远距离 NSInteger disRight = [self maxDistanceOfTree:rootNode.rightNode]; return MAX(MAX(disLeft, disRight), distance);&#125; 这个方案效率较低，因为计算子树的深度和最远距离是分开递归的，存在重复递归遍历的情况。其实一次递归，就可以分别计算出深度和最远距离，于是有了第二种方案： 123456789101112131415161718192021222324252627282930313233343536373839/** * 二叉树最大距离（直径） * * @param rootNode 根节点 * * @return 最大距离 */+ (NSInteger)maxDistanceOfTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return 0; &#125;// 方案2：将计算节点深度和最大距离放到一次递归中计算，方案一是分别单独递归计算深度和最远距离 TreeNodeProperty *p = [self propertyOfTreeNode:rootNode]; return p.distance;&#125;/** * 计算树节点的最大深度和最大距离 * * @param rootNode 根节点 * * @return TreeNodeProperty */+ (TreeNodeProperty *)propertyOfTreeNode:(BinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return nil; &#125; TreeNodeProperty *left = [self propertyOfTreeNode:rootNode.leftNode]; TreeNodeProperty *right = [self propertyOfTreeNode:rootNode.rightNode]; TreeNodeProperty *p = [TreeNodeProperty new]; //节点的深度depth = 左子树深度、右子树深度中最大值+1（+1是因为根节点占了1个depth） p.depth = MAX(left.depth, right.depth) + 1; //最远距离 = 左子树最远距离、右子树最远距离和横跨左右子树最远距离中最大值 p.distance = MAX(MAX(left.distance, right.distance), left.depth+right.depth); return p;&#125; 二叉树中某个节点到根节点的路径既是寻路问题，又是查找节点问题。 定义一个存放路径的栈（不是队列了，但是还是用可变数组来实现的） 1）压入根节点，再从左子树中查找（递归进行的），如果未找到，再从右子树中查找，如果也未找到，则弹出根节点，再遍历栈中上一个节点。 2）如果找到，则栈中存放的节点就是路径所经过的节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 二叉树中某个节点到根节点的路径 * * @param treeNode 节点 * @param rootNode 根节点 * * @return 存放路径节点的数组 */+ (NSArray *)pathOfTreeNode:(BinaryTreeNode *)treeNode inTree:(BinaryTreeNode *)rootNode &#123; NSMutableArray *pathArray = [NSMutableArray array]; [self isFoundTreeNode:treeNode inTree:rootNode routePath:pathArray]; return pathArray;&#125;/** * 查找某个节点是否在树中 * * @param treeNode 待查找的节点 * @param rootNode 根节点 * @param path 根节点到待查找节点的路径 * * @return YES：找到，NO：未找到 */+ (BOOL)isFoundTreeNode:(BinaryTreeNode *)treeNode inTree:(BinaryTreeNode *)rootNode routePath:(NSMutableArray *)path &#123; if (!rootNode || !treeNode) &#123; return NO; &#125; //找到节点 if (rootNode == treeNode) &#123; [path addObject:rootNode]; return YES; &#125; //压入根节点，进行递归 [path addObject:rootNode]; //先从左子树中查找 BOOL find = [self isFoundTreeNode:treeNode inTree:rootNode.leftNode routePath:path]; //未找到，再从右子树查找 if (!find) &#123; find = [self isFoundTreeNode:treeNode inTree:rootNode.rightNode routePath:path]; &#125; //如果2边都没查找到，则弹出此根节点 if (!find) &#123; [path removeLastObject]; &#125; return find;&#125; 二叉树中两个节点最近的公共父节点首先需要明白，根节点肯定是二叉树中任意两个节点的公共父节点（不一定是最近的），因此二叉树中2个节点的最近公共父节点一定在从根节点到这个节点的路径上。因此我们可以先分别找到从根节点到这2个节点的路径，再从这两个路径中找到最近的公共父节点。 1234567891011121314151617181920212223242526272829303132333435/** * 二叉树中两个节点最近的公共父节点 * * @param nodeA 第一个节点 * @param nodeB 第二个节点 * @param rootNode 二叉树根节点 * * @return 最近的公共父节点 */+ (BinaryTreeNode *)parentOfNode:(BinaryTreeNode *)nodeA andNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode || !nodeA || !nodeB) &#123; return nil; &#125; if (nodeA == nodeB) &#123; return nodeA; &#125; //从根节点到节点A的路径 NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode]; //从根节点到节点B的路径 NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode]; //其中一个节点不在树中，则没有公共父节点 if (pathA.count == 0 || pathB == 0) &#123; return nil; &#125; //从后往前推，查找第一个出现的公共节点 for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123; for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123; if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123; //找到 return [pathA objectAtIndex:i]; &#125; &#125; &#125; return nil;&#125; 二叉树中两个节点之间的路径从查找最近公共父节点衍生出来的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 二叉树中两个节点之间的路径 * * @param nodeA 第一个节点 * @param nodeB 第二个节点 * @param rootNode 二叉树根节点 * * @return 两个节点间的路径 */+ (NSArray *)pathFromNode:(BinaryTreeNode *)nodeA toNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode || !nodeA || !nodeB) &#123; return nil; &#125; NSMutableArray *path = [NSMutableArray array]; if (nodeA == nodeB) &#123; [path addObject:nodeA]; [path addObject:nodeB]; return path; &#125; //从根节点到节点A的路径 NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode]; //从根节点到节点B的路径 NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode]; //其中一个节点不在树中，则没有路径 if (pathA.count == 0 || pathB == 0) &#123; return nil; &#125; //从后往前推，查找第一个出现的公共节点 for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123; [path addObject:[pathA objectAtIndex:i]]; for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123; //找到公共父节点，则将pathB中后面的节点压入path if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123; j++; //j++是为了避开公共父节点 while (j&lt;pathB.count) &#123; [path addObject:[pathB objectAtIndex:j]]; j++; &#125; return path; &#125; &#125; &#125; return nil;&#125; 二叉树两个节点之间的距离可以从两个节点之间的路径衍生出来。 123456789101112131415161718192021222324252627282930313233343536/** * 二叉树两个节点之间的距离 * * @param nodeA 第一个节点 * @param nodeB 第二个节点 * @param rootNode 二叉树根节点 * * @return 两个节点间的距离（-1：表示没有找到路径） */+ (NSInteger)distanceFromNode:(BinaryTreeNode *)nodeA toNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode || !nodeA || !nodeB) &#123; return -1; &#125; if (nodeA == nodeB) &#123; return 0; &#125; //从根节点到节点A的路径 NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode]; //从根节点到节点B的路径 NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode]; //其中一个节点不在树中，则没有路径 if (pathA.count == 0 || pathB == 0) &#123; return -1; &#125; //从后往前推，查找第一个出现的公共节点 for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123; for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123; //找到公共父节点 if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123; //距离=路径节点数-1 （这里要-2，因为公共父节点重复了一次） return (pathA.count - i) + (pathB.count - j) - 2; &#125; &#125; &#125; return -1;&#125; 判断二叉树是否完全二叉树完全二叉树定义为：若设二叉树的高度为h，除第h层外，其它各层的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布。 完全二叉树必须满足2个条件： 1）如果某个节点的右子树不为空，则它的左子树必须不为空 2）如果某个节点的右子树为空，则排在它后面的节点必须没有孩子节点 这里还需要理解“排在它后面的节点”，回头看看层次遍历算法，我们就能知道在层次遍历时，是从上到下从左到右遍历的，先将根节点弹出队列，再压入孩子节点，因此“排在它后面的节点”有2种情况： 1）同层次的后面的节点 2）同层次的前面的节点的孩子节点（因为遍历前面的节点时，会弹出节点，同时将孩子节点压入队列） 通过上面的分析，我们可以设置一个标志位flag，当子树满足完全二叉树时，设置flag&#x3D;YES。当flag&#x3D;YES而节点又破坏了完全二叉树的条件，那么它就不是完全二叉树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 是否完全二叉树 * 完全二叉树：若设二叉树的高度为h，除第h层外，其它各层的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布 * * @param rootNode 根节点 * * @return YES：是完全二叉树，NO：不是完全二叉树 */+ (BOOL)isCompleteBinaryTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return NO; &#125; //左子树和右子树都是空，则是完全二叉树 if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123; return YES; &#125; //左子树是空，右子树不是空，则不是完全二叉树 if (!rootNode.leftNode &amp;&amp; rootNode.rightNode) &#123; return NO; &#125; //按层次遍历节点，找到满足完全二叉树的条件： //条件1：如果某个节点的右子树不为空，则它的左子树必须不为空 //条件2：如果某个节点的右子树为空，则排在它后面的节点必须没有孩子节点 //排在该节点后面的节点有2种：1）同层次的后面的节点 2）同层次的前面的节点的孩子节点（因为遍历前面的节点的时候，会将节点从队列里pop，同时把它的孩子节点push到队列里） NSMutableArray *queue = [NSMutableArray array]; [queue addObject:rootNode]; BOOL isComplete = NO; //是否已经满足完全二叉树 while (queue.count &gt; 0) &#123; BinaryTreeNode *node = [queue firstObject]; [queue removeObjectAtIndex:0]; //左子树为空且右子树不为空，则不是完全二叉树 if (!node.leftNode &amp;&amp; node.rightNode) &#123; return NO; &#125; if (isComplete &amp;&amp; (node.leftNode || node.rightNode)) &#123; //前面的节点已满足完全二叉树,如果还有孩子节点，则不是完全二叉树 return NO; &#125; //右子树为空，则已经满足完全二叉树 if (!node.rightNode) &#123; isComplete = YES; &#125; //压入 if (node.leftNode) &#123; [queue addObject:node.leftNode]; &#125; if (node.rightNode) &#123; [queue addObject:node.rightNode]; &#125; &#125; return isComplete;&#125; 判断二叉树是否满二叉树 满二叉树定义为：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树 满二叉树的一个特性是：叶子数&#x3D;2^(深度-1)，因此我们可以根据这个特性来判断二叉树是否是满二叉树。 123456789101112131415161718192021222324/** * 是否满二叉树 * 满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树 * * @param rootNode 根节点 * * @return YES：满二叉树，NO：非满二叉树 */+ (BOOL)isFullBinaryTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return NO; &#125; //二叉树深度 NSInteger depth = [self depthOfTree:rootNode]; //二叉树叶子节点数 NSInteger leafNum = [self numberOfLeafsInTree:rootNode]; //满二叉树特性：叶子数=2^(深度-1) if (leafNum == pow(2, (depth - 1))) &#123; return YES; &#125; return NO;&#125; 判断二叉树是否平衡二叉树平衡二叉树定义为：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树又叫AVL树。 12345678910111213141516171819202122232425262728293031/** * 是否平衡二叉树 * 平衡二叉树：即AVL树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树 * * @param rootNode 根节点 * * @return YES：平衡二叉树，NO：非平衡二叉树 */+ (BOOL)isAVLBinaryTree:(BinaryTreeNode *)rootNode &#123; static NSInteger height; if (!rootNode) &#123; height = 0; return YES; &#125; if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123; height = 1; return YES; &#125; BOOL isAVLLeft = [self isAVLBinaryTree:rootNode.leftNode]; NSInteger heightLeft = height; BOOL isAVLRight = [self isAVLBinaryTree:rootNode.rightNode]; NSInteger heightRight = height; height = MAX(heightLeft, heightRight)+1; if (isAVLLeft &amp;&amp; isAVLRight &amp;&amp; ABS(heightLeft-heightRight) &lt;= 1) &#123; return YES; &#125; return NO;&#125; 总结 以上就是我目前整理的一些二叉树相关的算法，算法资料和思想都来源于网络，如有错误，欢迎指正！后续如果有新的算法，我也会更新进去。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.bboyzj.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"OC-数据结构探索篇","slug":"OC-数据结构探索篇","permalink":"https://www.bboyzj.cn/tags/OC-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.bboyzj.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"OC算法04：二分查找探索","slug":"数据结构和算法/OC算法04：二分查找探索","date":"2020-08-26T08:34:46.000Z","updated":"2023-03-06T10:17:20.158Z","comments":true,"path":"2020/08/26/数据结构和算法/OC算法04：二分查找探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9504%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"二分查找 简介 二分查找(也称折半查找)是很常见的一种在数组中查找数据的算法,作为一名程序员是应该必须会的。 基本思想 获取数组的中间值，将数组分割成两份，利用查找的值跟中间值进行比较，如果查找的值大于中间值，就在数组的右边进行查找；如果查找的值小于中间值，就在数组的左边进行查找。如此循环的执行下去，最终找到符合的值。 优缺点 1）优点： 速度快 比较次数少 性能好 2）缺点： 必须是一个有序的数组（升序或者降序） 适用范围：适用不经常变动的数组 复杂度 时间复杂度就变成了O(logN) 具体代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748- (void)viewDidLoad &#123; [super viewDidLoad]; NSArray * arr = @[@1,@3,@5,@6,@8,@15,@20]; NSInteger result = [self binarySearchTarget:@1 inArray:arr]; NSLog(@&quot;%ld&quot;,(long)result);&#125;// 在某个数组中搜索目标- (NSInteger)binarySearchTarget:(NSNumber *)target inArray:(NSArray *)arr&#123; //如果数组无元素，则返回 if (arr.count &lt; 1) &#123; return -1; &#125; //如果数组有元素 //定义三个变量 第一个值下标、最后一个值下标、中间值下标 NSInteger start = 0; NSInteger end = arr.count - 1; NSInteger mid = 0; //如果开始和结束中间还有元素，则循环 while (start &lt; end - 1) &#123; //会有一些朋友看到有些人是( start + end ) / 2这样写的,但是这样写有一点不好,就是start+end会出现整数溢出的情况,如果存在溢出,你再除以2也是没有用的,所以不能这么写 mid = start + (end - start) / 2; //如果中间值大于目标值 if ([arr[mid] intValue] &gt; [target intValue]) &#123; //中间值做为最后一个值，在前半段再进行相同的搜索 end = mid; &#125; //如果中间值小于或等于目标值 else &#123; start = mid; &#125; &#125; //考虑到边界问题，所以下面这俩个必须写 //如果第一个值和目标值相等则获取第一个值的下标 if ([arr[start] intValue] == [target intValue]) &#123; return start; &#125; //如果最后一个值和目标值相等则获取最后一个值的下标 if ([arr[end] intValue] == [target intValue]) &#123; return end; &#125; return -1;&#125; 查看打印结果 122020-08-26 18:06:44.754180+0800 iOS-OC之二分查找[49535:2738585] 0","categories":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"OC-算法探索篇","slug":"OC-算法探索篇","permalink":"https://www.bboyzj.cn/tags/OC-%E7%AE%97%E6%B3%95%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"OC算法05：选择排序探索","slug":"数据结构和算法/OC算法05：选择排序探索","date":"2020-08-26T04:20:18.000Z","updated":"2023-03-06T10:17:23.942Z","comments":true,"path":"2020/08/26/数据结构和算法/OC算法05：选择排序探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9505%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"选择排序 基本思路：选择排序（Selection sort）是最基本的 O(n^2) 的排序算法，它的原理是每一次从待排序的数据元素中 选出最小或最大 的一个元素，存放在序列的起始位置，然后，再从 剩余未排序的元素当中继续寻找最小或大的元素， 然后放到未排序的末尾，以此类推，直到全部待排序的数据元素排完。 稳定性 选择排序是不稳定的排序方法。 主要流程：从小到大 第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换； 第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换； 以此类推，第i趟在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，使有序序列不断增长直到全部排序完毕。 具体代码 123456789101112131415161718192021222324252627- (void)viewDidLoad &#123; [super viewDidLoad]; [self selectionSortWithArr:[NSMutableArray arrayWithArray:@[@3,@1,@2,@5,@4]]];&#125;// 选择排序- (void)selectionSortWithArr:(NSMutableArray *)arr&#123; // 开始时间 double startTime = CFAbsoluteTimeGetCurrent(); // 外层遍历 for (int i = 0; i&lt; arr.count; i++) &#123; int minIndex = i; // 内层遍历 for (int j = i + 1; j &lt; arr.count; j++) &#123; // 获取最小下标 if ([arr[j] intValue]&lt; [arr[minIndex] intValue]) &#123; minIndex = j; &#125; &#125; //交换位置 [arr exchangeObjectAtIndex:i withObjectAtIndex:minIndex]; &#125; double endTime = CFAbsoluteTimeGetCurrent(); NSLog(@&quot;%@&quot;,arr); NSLog(@&quot;选择排序用时:%f s&quot;,endTime - startTime);&#125; 查看打印结果 1234567892020-08-26 17:11:21.653476+0800 OC-选择排序[48845:2694230] ( 1, 2, 3, 4, 5)2020-08-26 17:11:21.653672+0800 OC-选择排序[48845:2694230] 选择排序用时:0.000003 s","categories":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"OC-算法探索篇","slug":"OC-算法探索篇","permalink":"https://www.bboyzj.cn/tags/OC-%E7%AE%97%E6%B3%95%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"Swift学习00：简介","slug":"Swift学习/Swift学习00：简介","date":"2020-08-22T13:17:43.000Z","updated":"2023-03-01T17:50:37.544Z","comments":true,"path":"2020/08/22/Swift学习/Swift学习00：简介/","link":"","permalink":"https://www.bboyzj.cn/2020/08/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A000%EF%BC%9A%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Swift介绍Swift是Apple在2014年6月WWDC发布的全新的编程语言。 Swift是一种高性能系统编程语言，提供了对现有C和OC代码框架的无缝访问，并且是内存安全的。 Swift语言更加简洁，是一门类型安全的语言。 Swift和OC的区别 编程范式 Swift可以 面试协议编程、函数式编程和面向对象编程 OC以 面向对象编程 为主，当然你可以引入 Reactive Cocoa 的类库来进行函数式编程 类型安全 Swift是一门 类型安全的语言。鼓励程序员在代码中清楚明确值的类型。如果代码中使用一个字符串String，那么你不能错误地传递一个整型Int给它。因为Swift是类型安全的，它会在代码编译的时候做类型检查，并且把所有不匹配的类型作为一个错误标记出来。这样使得程序员在开发中尽可能早地发现和修正错误。 而OC则 不是类型安全的语言，你声明一个NSString变量，仍然可以传递一个NSNumber给它，尽管编译器会抱怨，但是你仍然可以作为NSNumber来使用它。 值类型的增强 在Swift中，典型的有 struct、enum 以及 元祖tuple 都是值类型。而平时使用的Int、Double、Float 、String 、Array 、Dictionary、Set其实都是用结构体实现的，也是 值类型。 OC中，NSNumber、NSString以及集合类对象都是指针类型。 枚举增强 Swift的枚举可以使用 整型、浮点型、字符串等，还能拥有 属性和方法，甚至支持 泛型、协议、扩展等。 OC里面的枚举则鸡肋很多。 泛型 Swift中 支持泛型，也支持泛型的类型约束等特性 苹果推出了Swift2.0版本，为了让开发者从OC更好的国度到Swift上，苹果也为OC带来了Gennerics泛型支持，不过OC的泛型约束也仅停留在编译器警告阶段。 协议和扩展 Swift对协议的支持更加丰富，配合扩展（extension）、泛型、关联类型等可以实现面向协议编程，从而大大提高代码的灵活性。同时swift中的protocol还可以用于值类型，如结构体和枚举 OC的协议却反强约束，提供optional特性往往成为很多问题得来源，而如果放弃optional又会让实现代价过大。 函数和闭包 Swift函数是一等公民，可以直接定义函数类型变量，可以作为其他函数参数传递，可以作为函数的返回值类型。 OC里面函数仍然是次等公民，需要selector封装或者使用block才能模拟Swift中类似的效果。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"OC算法01：冒泡排序探索","slug":"数据结构和算法/OC算法01：冒泡排序探索","date":"2020-08-10T11:48:48.000Z","updated":"2023-03-06T10:16:59.351Z","comments":true,"path":"2020/08/10/数据结构和算法/OC算法01：冒泡排序探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9501%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"冒泡排序 基本思路： 重复地走访要排序的元素列，依次比较两个相邻的元素，如果他们的 顺序错误就把他们交换过来。 算法思想： 1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。2）对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。3）针对所有的元素重复以上的步骤，除了最后一个。4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 主要流程： 首先我们需要 双层循环，外层循环控制排序趟数，内存循环控制每趟比较次数以及是否需要交换位置，我们先不关心是否交换位置，我们内层循环每次比较都是取 array[j] 和 array[j+1] 相比较，根据比较结果来判断是否交换位置。 时间复杂度 最好的情况：冒泡排序中最好的情况是数组本身就是正序排列的，并不需要交换，例如：@[1,2,3,4,5]; 当正序数组放入冒泡排序中的时候，只会进行4次比较，分别是1和2，2和3，3和4，4和5。比较完后发现没有任何数需要交换，那么说明数组已经排序正确，不要在进行最外层循环。当正序数组中有 N 个数的时候，那么只需要 N-1 次比较。 而正序数组在冒泡排序中的时间复杂度为O(n)，因为n-1中，在n的基数很大的情况，比如n为1000时，1其实可以忽略不计。所以 冒泡排序中最短的时间**复杂度为O(n)**。 冒泡排序中最坏的情况是数组本身就是逆序排列的，需要每两个数都进行交换，例如：@[5,4,3,2,1]；当逆序数组放入冒泡排序中，最外层的每一次循环都要进行n-1次比较，而逆序数组需要进行n次最外层循环才能正确排序，最终比较次数为(n-1)n&#x2F;2，所以冒泡排序中最长的时间**复杂度为(n²)**，因为当n基数很大时，(n-1)n&#x2F;2 &#x3D; (n² - n)&#x2F;2； n²与n、1&#x2F;2的差距越大，n与1&#x2F;2可以忽略不计。 冒泡排序例子：元数据：@[@”1”,@”3”,@”2”,@”5”,@”4”] 123456789101112NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;5&quot;,@&quot;4&quot;]]; // 外循环控制排序趟数,进行 array.count-1 趟 for (int i = 0; i &lt; arr.count; i ++) &#123; // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序 for (int j = 0; j &lt; arr.count - i - 1; j++) &#123; // 相邻元素比较，若逆序则交换 if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123; [arr exchangeObjectAtIndex:j withObjectAtIndex:j + 1]; &#125; &#125; &#125; 打印结果： 12345672020-08-10 20:29:10.492517+0800 OC冒泡排序[27771:1528609] ( 1, 2, 3, 4, 5) 有序数组冒泡排序的优化如果数据是有序的： 第一种优化方式是设置一个标记位来标记是否发生了交换，如果没有发生交换就提前结束； 12345678910111213141516171819NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;5&quot;,@&quot;4&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;1&quot;]]; int flag = 0; // 外循环控制排序趟数,进行 array.count-1 趟 for (int i = 0; i &lt; arr.count; i ++) &#123; // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序 for (int j = 0; j &lt; arr.count - i - 1; j++) &#123; //相邻元素比较，若逆序则交换 if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123; flag = 1; id temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; if (flag == 0) &#123; break; &#125; &#125; NSLog(@&quot;%@&quot;,arr); 打印结果 12345672020-08-10 20:45:33.770139+0800 OC冒泡排序[28047:1546936] ( 1, 2, 3, 4, 5) 两个数组合并成一个数据，并排序1234567891011121314151617NSArray * ary1 = @[@1,@3,@4,@5,@9];NSArray * ary2 = @[@2,@4,@6,@8];NSMutableArray * res = [NSMutableArray arrayWithCapacity:[ary1 count] + [ary2 count]]; int i = 0, j = 0; // i 表示ary1的下标 j表示ary2的下标 while (i &lt; ary1.count &amp;&amp; j &lt; ary2.count) &#123; int a1 = [ary1[i] intValue]; int a2 = [ary2[j] intValue]; if (a1 &lt;= a2) &#123; [res addObject:ary1[i++]]; &#125;else &#123; [res addObject:ary2[j++]]; &#125; &#125; NSLog(@&quot;%@&quot;,res); 打印 123456789102020-08-10 21:11:11.311203+0800 OC冒泡排序[28372:1568516] ( 1, 2, 3, 4, 4, 5, 6, 8)","categories":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"OC-算法探索篇","slug":"OC-算法探索篇","permalink":"https://www.bboyzj.cn/tags/OC-%E7%AE%97%E6%B3%95%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"OC数据结构01：链表的探索","slug":"数据结构和算法/OC数据结构01：链表的探索","date":"2020-08-09T14:39:22.000Z","updated":"2023-03-06T10:15:00.063Z","comments":true,"path":"2020/08/09/数据结构和算法/OC数据结构01：链表的探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"数据结构顺序存储结构 举个例子，数组：1-2-3-4-5-6-7-8-9-10，这个就是一个顺序存储结构，存储是按顺序的。 比如 栈，先进后出，比如 hello world 在栈里面是从 栈底到栈顶的逻辑，依次是 h-e-l-l-o-w-o-r-l-d 这个顺序存储 再比如 队列，先进先出，从头到尾 h-e-l-l-o-w-o-r-l-d 这个顺序排序 链式存储结构-链表链表是一种 物里存储单元上非连续、非顺序的存储结构，数据元素的顺序是通过链表中的 指针 链接次序实现的。链表由 一系列节点组成，在 运行时动态生成。每个节点包括两部分：一个是 数据域，一个是 指针域。 链表链表的组成 链表的数据元素的组成部分：指针域 和 数据域 指针域 用来存放指示数据元素之间的逻辑关系的指针。 数据域 用来存放数据信息。 数据元素这种特殊的存储方式称之为 结点（Node）。 链表的分类链表分为4类： 单链表：一个数据域data、一个后继指针域next。也即：上一个节点指向下一个节点，尾节点next指向nil，首节点pre指向nil。 双向链表：一个数据域data、一个前驱指针域previous、一个后继指针域next。也即：上一个节点和下一个节点互相指向，尾节点next指向nil，首节点pre指向nil。 循环链表：一个数据域data、一个后继指针域next。也即：上一个节点指向下一个节点，尾节点next指向首节点。 双向循环链表：一个数据域data、一个前驱指针域previous、一个后继指针域next。也即：上一个节点和下一个节点互相指向，尾节点和首节点也互相指向。 链表的优缺点 数组： 我们知道，用数组存放数据时，必须事先定义固定的长度（即元素个数）。如果事先难以确定元素个数，则必须把数组定义的足够大，以便存放，显然这样会浪费内存。 而链表可根据需要开辟内存单元，不会浪费内存。 数组 和 链表 的区别？ 数组：数组 静态分配 内存；数组元素在内存上是连续的，可以通过下标查找元素；插入、删除需要移动大量元素，比较使用元素很少变化的情况；数组插入删除操作时间复杂度是 O(n)，数组查询操作时间复杂度是 O(1) 链表：链表 动态分配 内存；链表元素在内存中不是顺序存储的，查找慢；插入、删除只需要对元素指针重新赋值，效率高；链表插入删除操作时间复杂度是 O(1)，链表查询操作时间复杂度是 O(n) 如何检测单链表中是否有环？ 穷举遍历 首先从头节点开始，依次遍历每个节点，每遍历到一个新节点，就从头节点重新遍历新节点之前的所有节点，当 新节点的ID 和 此节点之前的所有节点ID 依次比较，如果发现 ID相同，则证明链表有环。 哈希表缓存 首先创建一个以 节点ID为键 的HashSet集合，用来存储曾经遍历过的节点。然后同样是从头节点开始，依次遍历每一个节点，当新节点和HashSet集合当中存储的节点ID相同，则说明链表右环。 快慢指针 首先创建两个指针，指针1和指针2，同时指向这个头节点，指针1每次向下移动一个节点，指针2向下移动2个节点，比较节点是否相同，如果相同则说明链表有环。如果不同执行下一次循环。 单向链表代码实现 定义节点 12345678910111213141516// 单链表节点@interface SingleLinkNode : NSObject@property (nonatomic,strong)id data; // 数据域@property (nonatomic,strong,nullable)SingleLinkNode * next; // 后继指针域+ (instancetype)constructNodeWithData:(id)data;@end@interface SingleLinkNode ()@end@implementation SingleLinkNode+ (instancetype)constructNodeWithData:(id)data&#123; SingleLinkNode * node = [[SingleLinkNode alloc] init]; node.data = data; node.next = nil; return node;&#125; 构建链表 12// 构建一个单链表SingleLinkNode * headNode = [[SingleLinkNode alloc] init]; 对外接口类 123456789101112131415161718192021222324@interface LinkInterface : NSObject// 单链表：在头部插入节点+ (void)insertNewNodeToHead:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode;// 单链表：在尾部插入节点+ (void)insertNewNodeToTail:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode;// 单链表：在指定位置插入节点+ (void)insertNodeAtIndex:(int)index node:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode;// 单链表：删除指定位置节点+ (void)deleteNodeAtIndex:(int)index headNode:(SingleLinkNode *)headNode;// 单链表：查询指定位置节点+ (SingleLinkNode *)queryNodeAtIndex:(int)index headNode:(SingleLinkNode *)headNode;// 单链表：正序遍历链表+ (NSArray *)printFromHeadWithNode:(SingleLinkNode *)headNode printPrefixText:(NSString *)text;// 单链表：倒叙遍历链表+ (NSMutableArray *)printFromTailWithNode:(SingleLinkNode *)headNode;// 单链表：反转链表+ (SingleLinkNode *)reverseWithNode:(SingleLinkNode *)headNode;// 单链表：两个有序链表合并成一个新的有序链表+ (SingleLinkNode *)combineWithNode:(SingleLinkNode *)headNode otherNode:(SingleLinkNode *)otherNode;// 单链表：判断两个链表是否相交+ (BOOL)intersectWithNode:(SingleLinkNode *)headNode otherNode:(SingleLinkNode *)otherNode;// 单链表：判断链表是否构成环，如果成环，求出环的入口节点+ (SingleLinkNode *)circleWithNode:(SingleLinkNode *)headNode;@end 插入节点 在头部插入节点 12345678910111213141516// 在头部插入节点+ (void)insertNewNodeToHead:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode&#123; // 判空处理 if (!headNode)&#123; return; &#125; // 先把新节点指向头节点的下一个节点，再让头结点指向新节点（比较常用） if (headNode.next == nil) &#123; headNode.next = newNode; &#125;else &#123; // 将下一个节点赋值给新节点 newNode.next = headNode.next; // 再将头节点指向新节点 headNode.next = newNode; &#125;&#125; vc实现： 12345// 插入节点到头部SingleLinkNode * newHeadNode = [SingleLinkNode constructNodeWithData:@1];[LinkInterface insertNewNodeToHead:newHeadNode headNode:headNode];// 正序打印节点[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;构造单链表为：&quot;]; 打印结果： 12022-11-23 16:44:46.140163+0800 单链表[39792:20769651] 单链表为:1 在尾部插入节点 123456789101112131415161718// 在尾部插入节点+ (void)insertNewNodeToTail:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode&#123; // 判空处理 if(!headNode)&#123; return; &#125; // 如果头节点就是尾节点 if(headNode.next == nil) &#123; headNode.next = newNode; &#125;else &#123; // 设置中间变量 SingleLinkNode * pNode = headNode; while (pNode.next != nil) &#123; // 未遍历到尾节点 pNode = pNode.next; &#125; pNode.next = newNode; &#125;&#125; vc实现： 123456789// 插入节点到尾部SingleLinkNode * newTailNode = [SingleLinkNode constructNodeWithData:@2];SingleLinkNode * newTailNode1 = [SingleLinkNode constructNodeWithData:@3];SingleLinkNode * newTailNode2 = [SingleLinkNode constructNodeWithData:@5];[LinkInterface insertNewNodeToTail:newTailNode headNode:headNode];[LinkInterface insertNewNodeToTail:newTailNode1 headNode:headNode];[LinkInterface insertNewNodeToTail:newTailNode2 headNode:headNode];// 正序打印节点[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;]; 打印结果： 12022-11-23 16:46:42.287876+0800 单链表[39960:20772937] 单链表为:1-&gt;2-&gt;3-&gt;5 在指定位置插入 123456789101112131415161718192021// 单链表：在指定位置插入节点+ (void)insertNodeAtIndex:(int)index node:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode&#123; // 判空处理 if(!headNode)&#123; return; &#125; // 如果头节点即尾节点 if (headNode.next == nil)&#123; headNode.next = newNode; &#125;else &#123; SingleLinkNode * pNode = headNode; int i = 1; while (i &lt; index &amp;&amp; pNode.next != nil) &#123; pNode = pNode.next; i ++; &#125; newNode.next = pNode.next; pNode.next = newNode; &#125; &#125; vc实现： 12345// 插入指定位置节点SingleLinkNode * newIndexNode = [SingleLinkNode constructNodeWithData:@4];[LinkInterface insertNodeAtIndex:4 node:newIndexNode headNode:headNode];// 正序打印节点[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;]; 打印结果： 12022-11-23 16:47:38.507939+0800 单链表[40048:20774861] 构造单链表为：:1-&gt;2-&gt;3-&gt;4-&gt;5 删除节点 12345678910111213141516171819202122// 单链表：删除指定位置节点+ (void)deleteNodeAtIndex:(int)index headNode:(SingleLinkNode *)headNode&#123; // 判空处理 if(headNode == nil || !headNode.next || index &lt;= 0)&#123; NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;没有要删除的第%d个节点&quot;,index]); return; &#125; SingleLinkNode * pNode = headNode; SingleLinkNode * p = pNode; // 移动指针 int i = 0; while (i &lt; index &amp;&amp; pNode.next != nil) &#123; p = pNode; pNode = pNode.next; i ++; &#125; if(pNode != nil)&#123; p.next = p.next.next; return; &#125; NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;没有要删除的第%d个节点&quot;,index]);&#125; vc实现： 1234// 删除指定位置的节点[LinkInterface deleteNodeAtIndex:1 headNode:headNode];// 正序打印节点[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;]; 打印结果： 12022-11-23 16:50:48.638460+0800 单链表[40345:20779532] 单链表为:2-&gt;3-&gt;4-&gt;5 查询节点 12345678910111213141516171819// 单链表：查询指定位置节点+ (SingleLinkNode *)queryNodeAtIndex:(int)index headNode:(SingleLinkNode *)headNode&#123; // 判空处理 if (!headNode || !headNode.next) &#123; NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;没有查询到的第%d个节点&quot;,index]); return nil; &#125; SingleLinkNode * pNode = headNode.next; int i = 1; while (i &lt; index &amp;&amp; pNode != nil) &#123; pNode = pNode.next; i ++; &#125; if(pNode != nil)&#123; return pNode; &#125; NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;没有查询到的第%d个节点&quot;,index]); return nil;&#125; vc实现： 1234// 查询指定位置的节点[LinkInterface queryNodeAtIndex:3 headNode:headNode];// 正序打印节点[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;]; 打印结果： 12022-11-23 16:55:10.563221+0800 单链表[40694:20785389] 单链表为:2-&gt;3-&gt;4-&gt;5 遍历链表 正向遍历 1234567891011121314151617// 正序遍历链表+ (NSArray *)printFromHeadWithNode:(SingleLinkNode *)headNode printPrefixText:(NSString *)text&#123; // 判空处理 if (!headNode || !headNode.next) &#123; return nil; &#125; // 设置偏移指针 SingleLinkNode * pNode = headNode.next; NSMutableArray * dataArr = [NSMutableArray array]; while (pNode != nil) &#123; [dataArr addObject:pNode.data]; pNode = pNode.next; // 指向下一个节点 &#125; NSLog(@&quot;%@:%@&quot;,text,[dataArr componentsJoinedByString:@&quot;-&gt;&quot;]); return dataArr;&#125; vc实现： 12// 正序打印节点[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;]; 打印结果： 12022-11-23 16:55:10.563221+0800 单链表[40694:20785389] 单链表为:2-&gt;3-&gt;4-&gt;5 反向遍历 123456789101112131415161718192021// 单链表：倒叙遍历链表+ (NSMutableArray *)printFromTailWithNode:(SingleLinkNode *)headNode&#123; // 判空处理 if(!headNode || !headNode.next)&#123; return nil; &#125; // 遍历指针偏移，每次遍历完一次后，要记录最后一个节点，然后将遍历指针移动到开头重新开始，与记录的最后一个节点作比较 NSMutableArray * items = [NSMutableArray array]; SingleLinkNode * pNode = headNode; SingleLinkNode * lastNode = nil; while (pNode != nil &amp;&amp; lastNode != pNode) &#123; pNode = pNode.next; if (pNode.next == nil || pNode.next == lastNode) &#123; lastNode = pNode; pNode = headNode; [items addObject:lastNode.data]; &#125; &#125; return items;&#125; vc实现： 123// 倒叙打印节点NSMutableArray * tailArr = [LinkInterface printFromTailWithNode:headNode];NSLog(@&quot;tail:%@&quot;,tailArr); 打印结果： 1234562022-11-23 17:00:09.521947+0800 单链表[41100:20791055] tail:( 5, 4, 3, 2) 反转链表 1234567891011121314151617181920212223242526// 单链表：反转链表+ (SingleLinkNode *)reverseWithNode:(SingleLinkNode *)headNode&#123; // 判空处理 if(!headNode|| !headNode.next)&#123; return nil; &#125; // 采用头节点插入的方式反转 // 定义遍历指针 SingleLinkNode * p = headNode.next; // 定义反转后头节点 SingleLinkNode * newHead = [[SingleLinkNode alloc] init]; while (p != nil) &#123; // 记录下一个节点用来往下循环 SingleLinkNode * temp = p.next; // 替换当前节点的next为新头next p.next = newHead.next; // 更新新头节点指向当前节点即可反转 newHead.next = p; // 移动p指针 p = temp; &#125; return newHead;&#125; vc实现： 12// 反转链表SingleLinkNode * reverseNode = [LinkInterface reverseWithNode:headNode]; 合并有序链表（有问题，排序不对） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 两个有序链表合并成一个新的有序链表+ (SingleLinkNode *)combineWithNode:(SingleLinkNode *)headNode otherNode:(SingleLinkNode *)otherNode&#123; // 判空处理 if(!headNode || !headNode.next)&#123; return otherNode; &#125; if(!otherNode || !otherNode.next)&#123; return headNode; &#125; // 一起遍历 SingleLinkNode * p1 = headNode.next; SingleLinkNode * p2 = otherNode.next; // 定义一个新头节点 SingleLinkNode * newHead = [[SingleLinkNode alloc] init]; while (p1 != nil &amp;&amp; p2 != nil) &#123; if([p1.data integerValue] &gt; [p2.data integerValue])&#123; // 移动otherNode节点指向otherNode当前节点的下一个节点 otherNode.next = p2.next; // 将当前otherNode节点链表断掉 p2.next = nil; // 将当前otherNode节点插入到新节点newHead链表的尾部 [self insertNewNodeToTail:p2 headNode:newHead]; // 获取otherNode链表的下一个节点 p2 = otherNode.next; &#125;else &#123; headNode.next = p1.next; p1.next = nil; [self insertNewNodeToTail:p1 headNode:newHead]; p1 = headNode.next; &#125; &#125; // 处理没扫描结束的链表 while (p1 != nil) &#123; headNode.next = p1.next; p1.next = nil; [self insertNewNodeToTail:p1 headNode:newHead]; p1 = headNode.next; &#125; while (p2 != nil) &#123; otherNode.next = p2.next; p2.next = nil; [self insertNewNodeToTail:p2 headNode:newHead]; p2 = otherNode.next; &#125; return newHead;&#125; 判断两个链表是否相交 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 单链表：判断两个链表是否相交+ (BOOL)intersectWithNode:(SingleLinkNode *)headNode otherNode:(SingleLinkNode *)otherNode&#123; // 判空处理 if(!headNode || !headNode.next || !otherNode || !otherNode.next)&#123; return NO; &#125; // 思路：分别获取两个链表的长度，判断谁的链表更长，链表更长的先走完相差的步数，然后再齐步走 SingleLinkNode * p1 = headNode.next; SingleLinkNode * p2 = otherNode.next; int L1 = 1; int L2 = 1; while (p1 != nil) &#123; L1 ++; p1 = p1.next; &#125; while (p2 != nil) &#123; L2 ++; p2 = p2.next; &#125; p1 = headNode.next; // 将p1遍历指针移动到首节点 p2 = headNode.next; // 将p2遍历指针移动到首节点 int i = 0; if (L1 &gt; L2) &#123; while (i &lt; L1 - L2 &amp;&amp; p1 != nil) &#123; // p1先走 p1 = p1.next; i ++; &#125; &#125;else &#123; while (i &lt; L2 - L1 &amp;&amp; p2 != nil) &#123; // p2先走 p2 = p2.next; i ++; &#125; &#125; // p1、p2齐步走 if(i == ABS(L1 - L2))&#123; while (p1 != nil &amp;&amp; p2 != nil) &#123; if(p1.next == p2.next) return YES; p1 = p1.next; p2 = p2.next; &#125; &#125; return NO;&#125; 判断链表是否头程还，如果成环，求出环的入口节点 1234567891011121314151617181920212223242526272829// 单链表：判断链表是否构成环，如果成环，求出环的入口节点+ (SingleLinkNode *)circleWithNode:(SingleLinkNode *)headNode&#123; // 判空处理 if(!headNode || !headNode.next)&#123; return nil; &#125; // 思路：采用快慢指针 // 快指针先走两步，满指针走一步，如果成环，必然重合。 // 走到第一次重合的地点后，重新设置一个指针p指向头节点，并与慢节点同步伐齐步走 // 走到第二次相遇的地方，即为构成环的节点 SingleLinkNode * quick = headNode.next; SingleLinkNode * slow = headNode.next; SingleLinkNode * p = headNode.next; while (quick != nil &amp;&amp; slow != nil) &#123; quick = quick.next.next; slow = slow.next; if (quick == slow) &#123; // 第一次重合，结束循环 break; &#125; &#125; while (p != nil &amp;&amp; slow != nil) &#123; p = p.next; slow = slow.next; if (p == slow) &#123; // 第二次重合，找到成环的入口节点 return p; &#125; &#125; return nil;&#125; 双向链表双向链表：每一个节点前后指针域都和他的上一个节点互相指向，尾节点的next指向nil，首节点的pre指向nil 定义节点 12345678910111213141516@interface DoubleLinkNode : NSObject@property (nonatomic,strong)id data; // 数据域@property (nonatomic,weak,nullable)DoubleLinkNode * pre; // 前驱指针域（防止循环引用）@property (nonatomic,strong,nullable)DoubleLinkNode * next; // 后继指针域+ (instancetype)constructNodeWithData:(id)data;@end@implementation DoubleLinkNode+ (instancetype)constructNodeWithData:(id)data&#123; DoubleLinkNode * node = [[DoubleLinkNode alloc] init]; node.data = data; node.pre = nil; node.next = nil; return node;&#125;@end 构建一个双向链表 123456789// 构造一个双向链表DoubleLinkNode * head = [[DoubleLinkNode alloc] init];DoubleLinkNode * node1 = [DoubleLinkNode constructNodeWithData:@1];DoubleLinkNode * node2 = [DoubleLinkNode constructNodeWithData:@2];head.next = node1;node1.pre = head;node1.next = node2;node2.pre = node1;[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双链表为&quot;]; 打印结果： 12022-11-24 13:38:50.045234+0800 单链表[50291:20937675] 双链表为:1⇄2 在头部插入节点 123456789101112131415161718// 双向链表：向头部插入节点+ (void)insertDoubleNewNodeToHead:(DoubleLinkNode *)newNode headNode:(DoubleLinkNode *)headNode&#123; // 判空处理 if(!headNode)&#123; return; &#125; // 如果只有一个头节点 if(headNode.next == nil)&#123; headNode.next = newNode; newNode.pre = headNode; &#125;else &#123; newNode.next = headNode.next; // 当前节点的后继指向头节点的后继 headNode.next.pre = newNode; // 头结点后继的前驱指向当前节点 newNode.pre = headNode; // 当前节点的前驱指向头结点 headNode.next = newNode; // 头结点的后继指向当前节点 &#125;&#125; vc实现 1234// 在头部插入节点DoubleLinkNode * node0 = [DoubleLinkNode constructNodeWithData:@0];[LinkInterface insertDoubleNewNodeToHead:node0 headNode:head];[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双链表为&quot;]; 打印结果： 12022-11-24 13:53:01.240605+0800 单链表[51484:20953802] 双链表为:0⇄1⇄2 在尾部插入节点 1234567891011121314// 双向链表：向尾部插入节点+ (void)insertDoubleNewNodeToTail:(DoubleLinkNode *)newNode headNode:(DoubleLinkNode *)headNode&#123; // 判空处理 if(!headNode)&#123; return; &#125; // 设置偏移指针 DoubleLinkNode * pNode = headNode.next; while (pNode.next != nil) &#123; pNode = pNode.next; &#125; pNode.next = newNode; newNode.pre = pNode;&#125; vc实现 1234// 在尾部插入节点DoubleLinkNode * node4 = [DoubleLinkNode constructNodeWithData:@4];[LinkInterface insertDoubleNewNodeToTail:node4 headNode:head];[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双向链表为&quot;]; 打印结果 12022-11-24 13:59:04.853558+0800 单链表[52038:20962187] 双向链表为:0⇄1⇄2⇄4 在指定位置插入节点 1234567891011121314151617181920212223242526272829// 双向链表：在指定位置插入节点+(void)insertDoubleNewNodeToIndex:(int)index newNode:(DoubleLinkNode *)newNode headNode:(DoubleLinkNode *)headNode&#123; if(!headNode)&#123; return; &#125; // 如果头结点即尾节点 if (headNode.next == nil)&#123; headNode.next = newNode; newNode.pre = headNode; &#125;else &#123; &#125; // 如果头节点即尾节点 if (headNode.next == nil)&#123; headNode.next = newNode; &#125;else &#123; // 设置偏移指针 DoubleLinkNode * pNode = headNode.next; int i = 1; while (i &lt; index &amp;&amp; pNode.next != nil) &#123; pNode = pNode.next; i ++; &#125; newNode.next = pNode.next; pNode.next.pre = newNode; newNode.pre = pNode; pNode.next = newNode; &#125;&#125; vc实现 1234// 在指定位置插入节点DoubleLinkNode * node3 = [DoubleLinkNode constructNodeWithData:@3];[LinkInterface insertDoubleNewNodeToIndex:3 newNode:node3 headNode:head];[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双向链表为&quot;]; 打印结果 12022-11-24 14:08:41.539116+0800 单链表[52850:20973592] 双向链表为:0⇄1⇄2⇄3⇄4 删除指定位置节点 1234567891011121314151617181920// 双向链表：删除指定位置节点+ (DoubleLinkNode *)deleteDoubleNodeAtIndex:(int)index headNode:(DoubleLinkNode *)headNode&#123; // 判空处理 if(!headNode)&#123; return nil; &#125; // 设置偏移指针 DoubleLinkNode * pNode = headNode.next; int i = 1; while (i &lt; index &amp;&amp; pNode.next != nil) &#123; pNode = pNode.next; i ++; &#125; if(i == index)&#123; pNode.pre.next = pNode.next; pNode.next.pre = pNode.pre; return pNode; &#125; return nil;&#125; vc实现 123// 删除指定位置节点[LinkInterface deleteDoubleNodeAtIndex:1 headNode:head];[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双向链表为&quot;]; 打印结果 12022-11-24 14:15:01.766124+0800 单链表[53365:20980542] 双向链表为:1⇄2⇄3⇄4 遍历并打印链表 // 双向链表：遍历并打印链表 + (void)printDoubleFromHeadWithNode:(DoubleLinkNode *)headNode printPrefixText:(NSString *)text&#123; if(!headNode)&#123; return; &#125; DoubleLinkNode * pNode = headNode.next; NSMutableArray * items = [NSMutableArray array]; while (pNode != nil) &#123; [items addObject:pNode.data]; pNode = pNode.next; &#125; NSLog(@&quot;%@:%@&quot;,text,[items componentsJoinedByString:@&quot;⇄&quot;]); &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.bboyzj.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"OC-数据结构探索篇","slug":"OC-数据结构探索篇","permalink":"https://www.bboyzj.cn/tags/OC-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.bboyzj.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"OC算法03：斐波那契数列探索","slug":"数据结构和算法/OC算法03：斐波那契数列探索","date":"2020-08-09T05:56:16.000Z","updated":"2023-03-06T10:44:55.267Z","comments":true,"path":"2020/08/09/数据结构和算法/OC算法03：斐波那契数列探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9503%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"简介斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(1)&#x3D;1，F(2)&#x3D;1, F(n)&#x3D;F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*），用文字来说，就是斐波那契数列由 0 和 1 开始，之后的斐波那契数列系数就由 之前的两数相加。 排列组合问：有一段楼梯有10级台阶，规定每一步只能跨一级或两级，要登上第 10 级台阶有几种不同的走法? 分析：这就是一个斐波那契数列：登上第一级台阶有一种登法；登上两级台阶，有两种登法；登上三级台阶，有三种登法；登上四级台阶，有五种登法……1，2，3，5，8，13…… 所以，登上十级，有 89 种走法。 答： 123456789101112131415161718192021- (void)demo&#123; // 有10级台阶 NSInteger tjNum = 10; NSInteger total = [self getTotalNumOfMethods:tjNum]; NSLog(@&quot;total:%ld&quot;,total);&#125;- (NSInteger)getTotalNumOfMethods:(NSInteger)num&#123; if (num == 0) &#123; return 0; &#125; if (num == 1) &#123; return 1; &#125; if (num == 2) &#123; return 2; &#125; return [self getTotalNumOfMethods:num-1] + [self getTotalNumOfMethods:num - 2];&#125; 打印结果：89 兔子繁殖问题斐波那契数列又因数学家莱昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”。 问：一般而言，兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。如果所有兔子都不死，那么一年以后可以繁殖多少对兔子？ 分析：我们不妨拿新出生的一对小兔子分析一下：第一个月小兔子没有繁殖能力，所以还是一对 两个月后，生下一对小兔对数共有两对 三个月以后，老兔子又生下一对，因为小兔子还没有繁殖能力，所以一共是三对－－－－－－依次类推可以列出下表： 幼仔对数&#x3D;前月成兔对数成兔对数&#x3D;前月成兔对数+前月幼仔对数总体对数&#x3D;本月成兔对数+本月幼仔对数可以看出幼仔对数、成兔对数、总体对数都构成了一个数列。这个数列有关十分明显的特点，那是：前面相邻两项之和，构成了后一项。 答： 1234567891011121314151617181920- (void)demo1&#123; NSInteger month = 12; NSInteger tuTotal = [self getTuTotalNum:month]; NSLog(@&quot;tuTotal:%ld&quot;,tuTotal);&#125;- (NSInteger)getTuTotalNum:(NSInteger)month&#123; if (month == 0) &#123; return 1; &#125; if (month == 1) &#123; return 1; &#125; if (month == 2) &#123; return 2; &#125; return [self getTuTotalNum:month-1] + [self getTuTotalNum:month - 2];&#125; 打印结果：233","categories":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"OC-算法探索篇","slug":"OC-算法探索篇","permalink":"https://www.bboyzj.cn/tags/OC-%E7%AE%97%E6%B3%95%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"OC算法02：插入排序探索","slug":"数据结构和算法/OC算法02：插入排序探索","date":"2020-08-07T11:28:01.000Z","updated":"2023-03-06T10:39:36.281Z","comments":true,"path":"2020/08/07/数据结构和算法/OC算法02：插入排序探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9502%EF%BC%9A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"基本思想每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，直到全部对象都插入为止。即边插入边排序，保证子序列中随时都是排好序的。 基本操作有序插入 在有序列序列中插入一个元素，保持序列有序，有序长度不断增加。 可以插入在中间、最前面和最后面 插入排序种类 顺序法定位插入位置 – 直接插入排序 缩小增量多遍插入排序 – 希尔排序 直接插入排序 基本思路：每轮排序把数组分为2部分，一部分为已排序好的数组，一部分为还未排序好的数组。每次取出还未排序好的数组中首元素与已排序好的数组从右往左比较。如果发现从未排序中取出的元素比从已排序中取出的元素大，就把该未排序的元素插入到从已排序中取出元素的后面。这样每一轮就能确定一个未排序元素在已排序数组中的准确位置 算法思想 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到下一位置中 重复步骤2~5 直接插入排序的流程演示 流程举例: 红色的为已排序部分，蓝色的为未排序部分 1）原始数据：首先把原数组从下坐标1开始拆分为2部分， 已排序部分(红色)，未排序部分(蓝色)。默认原数组首元素为已排序元素。 2）第一轮：接着用后面未排序部分的第一个元素与已排序部分的最后一个元素进行比较，这里发现已排序最末尾元素5小于未排序元素第一个元素9.且元素5余元素9的位置是相邻的。不发生插入。把元素9列入已排序数组中。此时已排序好的元素多了一个。 3）第二轮：然后接着用后面未排序部分的第一个元素与已排序部分的最后一个元素进行比较，这里发现已排序最末尾元素9大于未排序元素第一个元素2。并且9不是已排序元素最前面一个元素，所以忽略本次操作，让元素2与已排序元素从右往左的下一个元素进行比较，此时发现已排序元素5大于元素2，但发现元素5是已排序元素中首个元素。则直接把元素2插入到元素5前面。 4）第三轮排序：用后面未排序部分的第一个元素与已排序部分的最后一个元素进行比较，这里发现已排序最末尾元素9小于未排序元素第一个元素15。且两个元素相邻。不发生插入，把元素15加入已排序部分。 5）第四轮排序：用后面未排序部分的第一个元素与已排序部分的最后一个元素进行比较，这里发现已排序最末尾元素15小于未排序元素第一个元素46。且两个元素相邻。不发生插入，把元素46加入已排序部分。 6）最后：依次按照上面的方式递归排序。直到所有元素排序完成。 列子: 代码实现： 1234567891011121314151617181920212223242526272829303132- (void)viewDidLoad &#123; [super viewDidLoad]; NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@15,@2,@5,@10,@20]]; // 插入排序的原理：始终定义第一个元素为有序的，将元素逐个插入到有序的排列中 // 其特点是：不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去 for (int i = 0 ; i &lt; arr.count; i ++) &#123; // temp为待排元素i为其位置 NSNumber * temp = arr[i]; // j为已排元素最后一个元素的位置 int j = i - 1; // 当j&gt;=0时，i为第一个待排元素，取已排元素和待排元素比较，在已经排好序中从后向前扫描 while (j &gt;= 0 &amp;&amp; [arr[j] integerValue] &gt; [temp integerValue]) &#123; // 如果已经排好序的序列中元素大于新元素，则将该元素往右移动一个位置 [arr replaceObjectAtIndex:j+1 withObject:arr[j]]; j --; &#125; // 跳出循环时，j已排元素小于或等于i的元素（待排元素）。插入新元素a[j+1] = temp，即空出来的位置插入待排序的值 [arr replaceObjectAtIndex:j+1 withObject:temp]; NSLog(@&quot;插入排序排序中:%@&quot;,[self getArrayStr:arr]); &#125;&#125;// 将数组中的元素拼接成字符串 - 方便打印- (NSString *)getArrayStr:(NSArray *)array &#123; NSMutableString *strM = [NSMutableString string]; for (NSNumber *num in array) &#123; [strM appendString:[NSString stringWithFormat:@&quot;%@,&quot;,num]]; &#125; return strM.copy;&#125; 打印结果: 123452020-08-07 21:30:38.316438+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:15,2,5,10,20,2020-08-07 21:30:38.316483+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:2,15,5,10,20,2020-08-07 21:30:38.316502+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:2,5,15,10,20,2020-08-07 21:30:38.316519+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:2,5,10,15,20,2020-08-07 21:30:38.316535+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:2,5,10,15,20, 算法分析 直接插入排序的算法性能 时间复杂度 最好的情况（关键字在记录中顺序有序）： 当元素的初始序列为正序时，仅外循环要进行n-1趟排序且每一趟只进行一次比较，没有进入if语句不存在元素之间的交换(移动)。此时比较次数(Cmin)和移动次数(Mmin)达到最小值。 此时时间复杂度为O(n)。 12比较次数：Cmin = n-1;移动次数：Mmin = 0; 举例： 如：1 2 3 4 5比较： 次数 移动第2个元素和第一个元素比较 1 0第3个元素和第二个元素比较 1 0…第n个元素和第n-1个元素比较 1 0比较的次数：n-1移动的次数：0 最坏的情况（关键字在记录序列中逆序有序）： 最差就是逆序。每趟排序中待插入的元素都要和[0,i-1]中的i个元素进行比较且要将这i个元素后移，i个元素后移移动次数当然也就为i了，再加上temp &#x3D; arr[i]与arr[j+1] &#x3D; temp的两次移动，每趟移动的次数为i+2,此时比较次数(Cmin)和移动次数(Mmin)达到最小值。 此时时间复杂度为O(n2)。 12Cmax = 1+2+...+(n-1) = n*(n-1)/2 = O(n2)Mmax = (1+2)+(2+2)+...+(n-1+2) = (n-1)*(n+4)/2 = O(n2) (i取值范围1~n-1) 例子： 如：5 4 3 2 1比较： 次数 移动第2个元素和第1个元素比较 1 1+2第3个元素和前2个元素比较 2 2+2…第n个元素和前n-1个比较 n-1 n-1+2最后： 把1+2+…+n-1加起来求平均值比较的次数：1+2+…+n-1 &#x3D; (n+2)(n-1)&#x2F;2移动的次数：(1+2)+(2+2)+…+(n-1+2) &#x3D; (n-1)*(n+4)&#x2F;2 &#x3D; O(n2) (i取值范围1~n-1) 事件复杂度结论：原始数据越接近有序，排序速度越快 1）最好的情况下（顺序有序）：O(n)2）最坏的情况下（逆序有序）：O(n^2)3）平均情况下，耗时差不多是最坏情况的一般：O(n^2)4）要提高查找速度 减少元素的比较次数减少元素的移动次数 空间复杂度 由直接插入排序算法可知，我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 O(1) 。 算法稳定性 直接插入排序的过程中，不需要改变相等数值元素的位置，所以它是稳定的算法。 插入排序和选择排序的区别 插入排序和选择排序都有两层循环，外循环遍历整个数组 内循环稍有区别： 选择排序的内循环是遍历一组未排过序的数组。 插入排序的内循环是遍历一组已排过序的数组。 希尔排序 简介 希尔排序(Shell Sort)，一听这名字就知道是一个叫希尔的外国人发明的排序。没错，他就是唐纳德 希尔（Donald Shell），一位美国的计算机科学家，他于1959年发明的希尔排序算法。 希尔排序思路 希尔排序相当于 直接插入排序的加强版，在直接插入排序的概念之上加入了 增量 这个概念。 什么是增量？ 插入排序只能与相邻的元素进行比较，而希尔排序则是进行 跳跃 比较，而 增量 就是 跳跃的 间隔数。 所谓增量即是把数组按照一定间隔数分组成不同的数组。例如:@{1,2,3,4,5,6,7},一共有6个元素，假设把数组按照增量3进行分组，那么就是@{1,4,7},@{2,5},@{3,6}各分为一组。因为增量是3，所以每间隔3个下坐标为一组。 按照增量分组后，把每一组的元素按照插入排序进行排序。当按照一个增量分组完成并每组数据按照插入排序完成后，将增量设为原本的二分之一，然后重复上面的步骤进行插入排序。直到增量为1，按照增量为1的最后一次进行分组插入排序。即完成了排序。 希尔排序的流程演示 原始数据：@[@(11),@(10),@(9),@(8),@(7),@(6),@(5),@(4),@(3),@(2),@(1)] 第一次分组： 第一步，数组中有11个元素，把数组除以二，得到5(11&#x2F;2实际是等于5余1，由于取正所以为5，由于有余数，所以按照增量取出来的数组的 组数 有 增量+1 即 5 + 1 = 6组。如果没有余数则组数就是增量数。)，以5为增量，从数组第一个元素开始，每间隔5个数取出来的所有元素分为一组，分为6组，分别是：@{11,7}、@{10,4}、@{9,3}、@{8,2}、@{5,1}、@{6} 第一次排序：每种颜色为一组。接着对每组进行插入排序(具体比较过程就不说了，看过上面插入排序的应该懂)，排序结果为下图(共交换5次):@{7,11}、@{4,10}、@{3,9}、@{2,8}、@{1,5}、@{6} 2)第二次分组：将增量5再次除以2，得到2(实际5&#x2F;2是等于2余1，有余数所以组数为3)。分为3组分别是:@{7,2,11,8}、@{4,1,10,5}、@{3,6,9} 第二次排序：每种颜色为一组，对每组元素进行插入排序。排序结果为(共交换4次)@{2,7,8,11}、@{1,4,5,10}、@{3,6,9} 3)第三次分组：将增量2再次除以1，得到1(实际2&#x2F;2等1，没有余数，所以分为1组)。分组后是@{2,1,3,7,4,6,8,5,9,11,10} 第三次排序：最后对整组数组进行插入排序，排序结果为(共交换7次)： 希尔排序的特点 1）一次移动，移动位置比较大，跳跃式地接近排序后的最终位置2）最后一次只需要少量移动3）增量序列必须是递减的，最后一个必须是14）增量序列应该是互质的 实例 12345678910111213141516171819202122232425262728293031323334353637383940- (void)viewDidLoad &#123; [super viewDidLoad]; NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@(9),@(3),@(8),@(5),@(2),@(4),@(7),@(6),@(1)]]; [self shellSort:arr];&#125;- (void)shellSort:(NSMutableArray *)list&#123; // 起始间隔值gap设置为总数的一半 int gap = (int)list.count / 2; // 直到gap==1结束 while (gap &gt;= 1) &#123; //i为待排元素，以步距gap从后向前扫描 for(int i = gap ; i &lt; [list count]; i++)&#123; //temp为待排元素i为其位置 NSInteger temp = [[list objectAtIndex:i] intValue]; //获取当前位置 int j = i; //然后将此位置之前的元素，按照增量进行跳跃式比较 while (j &gt;= gap &amp;&amp; temp &lt; [[list objectAtIndex:(j - gap)] intValue]) &#123; [list replaceObjectAtIndex:j withObject:[list objectAtIndex:j-gap]]; j -= gap; &#125; //跳出循环时，j元素小于i的元素（待排元素）。插入新元素a[j] = temp，即空出来的位置插入待排序的值 [list replaceObjectAtIndex:j withObject:[NSNumber numberWithInteger:temp]]; &#125; NSLog(@&quot;步长：%d --- 希尔排序:%@&quot;,gap,[self getArrayStr:list]); //步长 gap = gap / 2; &#125;&#125;// 将数组中的元素拼接成字符串 - 方便打印- (NSString *)getArrayStr:(NSArray *)array &#123; NSMutableString *strM = [NSMutableString string]; for (NSNumber *num in array) &#123; [strM appendString:[NSString stringWithFormat:@&quot;%@,&quot;,num]]; &#125; return strM.copy;&#125; 打印结果 1232020-08-09 22:02:14.160098+0800 OC-哈希排序[23997:1116332] 步长：4 --- 希尔排序:1,3,7,5,2,4,8,6,9,2020-08-09 22:02:14.160373+0800 OC-哈希排序[23997:1116332] 步长：2 --- 希尔排序:1,3,2,4,7,5,8,6,9,2020-08-09 22:02:14.160620+0800 OC-哈希排序[23997:1116332] 步长：1 --- 希尔排序:1,2,3,4,5,6,7,8,9, 希尔排序算法分析： 1）希尔排序的时间复杂度与增量的选取有关。例如，当增量为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为O(N²)，而Hibbard增量的希尔排序的时间复杂度为O(N3&#x2F;2)。2）空间复杂度：O(1)3）是一种不稳定的排序算法：","categories":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"OC-算法探索篇","slug":"OC-算法探索篇","permalink":"https://www.bboyzj.cn/tags/OC-%E7%AE%97%E6%B3%95%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}]}]}