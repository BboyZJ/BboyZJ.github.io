{"meta":{"title":"张建的博客","subtitle":"成功的道路上只有荆棘，没有坦途","description":"我是小J，关注我","author":"小J","url":"https://www.bboyzj.cn"},"pages":[{"title":"link","date":"2023-03-06T11:05:48.000Z","updated":"2023-03-06T11:05:48.692Z","comments":true,"path":"link/index.html","permalink":"https://www.bboyzj.cn/link/index.html","excerpt":"","text":""},{"title":"about","date":"2023-03-06T11:05:41.000Z","updated":"2023-03-06T11:05:41.514Z","comments":true,"path":"about/index.html","permalink":"https://www.bboyzj.cn/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-06T11:05:02.000Z","updated":"2023-03-06T11:05:02.715Z","comments":true,"path":"tags/index-1.html","permalink":"https://www.bboyzj.cn/tags/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-01T03:07:03.000Z","updated":"2023-03-01T03:07:47.616Z","comments":true,"path":"tags/index.html","permalink":"https://www.bboyzj.cn/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-03-01T04:01:29.000Z","updated":"2023-03-01T04:01:29.226Z","comments":true,"path":"categories/index.html","permalink":"https://www.bboyzj.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Swift学习：国际化/多语言适配","slug":"Swift/Swift学习：国际化-多语言适配","date":"2023-03-14T22:27:39.000Z","updated":"2023-03-15T13:01:04.721Z","comments":true,"path":"2023/03/15/Swift/Swift学习：国际化-多语言适配/","link":"","permalink":"https://www.bboyzj.cn/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%9B%BD%E9%99%85%E5%8C%96-%E5%A4%9A%E8%AF%AD%E8%A8%80%E9%80%82%E9%85%8D/","excerpt":"","text":"前言项目开发中不同语言环境需要进行多语言适配，例如：中文、英语、法语、俄语、葡萄牙语等 纯代码界面开发时，直接添加本地化语言文件，并针对键值对获取即可 下面我们来介绍如何国际化： 全局添加需要适配的多语言PROHECT -&gt; Info -&gt; Localizetions 下：选择 + 号添加： Chinese，Simplified：中文简体Chinese，Traditional：中文繁体English - Development Localization：英语French(fr)：法语Russian：俄语Arabic：阿拉伯语… 添加完成之后的效果： 细心的朋友会发现如今 English 后面是 1 File Localized，这是因为 英语 是系统默认加入的，并且同一时刻为 Main.storyboard 和 LaunchScreen.storyboard 设置了多语言 纯代码本地化 创建本地化文件 默认文件名为 Localizable ，不要去修改 点击 Next，Save As：Localizable Localizable.strings 就是你需要的本地化文化 关联对应的本地化语言 点击右侧的 Localizable，关联本地化语言 勾选需要关联的本地化语言，全部勾选 在本地化文件中设置 Key-Value 注意：不要忘记行末的 ; 号 分别在对应的本地化语言文件中，设置不同的 Key-Value 调用本地化 使用 NSLocalizedString 函数来访问 Localizable.strings 资源文件 NSLocalizedString 函数第一个参数为对应的 键名，第二个是自定义的说明，给开发或翻译人员看的。 123// 调用字符串对应的本地化符号let title = NSLocalizedString(&quot;title&quot;, comment: &quot;title&quot;)MyLog(message: title) 这种设置完之后仅仅能让应用随系统的语言进行切换，而用户不能手进行切换 图片本地化 选中需要本地化的图片，同上面一样点击 Localize... ，创建本地化 图片资源文件 关联你需要本地化的语言 图片 Show In Finder，可以看到在 中文和英文资源下都有这个图片，把需要替换的图片换掉即可 图片使用和平常一样 1let img = UIImage(named: &quot;loading.png&quot;) App 名称的 本地化 要实现应用名称根据语言环境显示不一样的名称，只需要创建 InfoPlist.strings 文件，创建 InfoPlist.strings 并关联语言 获取info.plist中的key 点击 Infoplist 右键选择 Open As -&gt; Source Code，查看我们所要获取权限的原始key。 新版Xcode获取不出来数据不用急，去代码中将info打印出来，拿到key效果一样。 12let infoPlist = Bundle.main.infoDictionaryMyLog(message: infoPlist) 本地化文件中，对key-value进行配置 12345// Chinese,Simplified&quot;CFBundleDisplayName&quot; = &quot;中图云书房&quot;// Englist&quot;CFBundleDisplayName&quot; = &quot;SRSF&quot; 运行App，然后切换手机语言为英文，会发现软件名称变成了英文 Xcode中切换语言为了调试国际化，我们除了可以进入 模拟器或真机 切换系统语言，也可以在 Xcode 中配置相关项，使 Debug 环境下运行时预览不同语言和地区 App的界面效果 选择 Product -&gt; Scheme -&gt; Edit Scheme 切换语言后，运行工程 应用内切换语言纯代码本地化只能跟随系统进行切换，并不能手动进行切换，下面先介绍一下相关宏 123456789101112// 尾随系统切换, 多语言文件名称必须是LocalizableNSLocalizedString(&quot;title&quot;, nil);// 以下三个都能够手动设置多语言// 第一个參数:是多语言中的key// 第二个參数:是多语言文件的名字// 第三个參数:是对key的自定义的说明,一般传nilNSLocalizedStringFromTable(@&quot;title&quot;, @&quot;Localizable&quot;, nil);// 指定多语言文件名称和bundleNSLocalizedStringFromTableInBundle(@&quot;title&quot;, @&quot;Localizable&quot;, bundle, nil);// 在上面的基础上添加一个默认值的參数NSLocalizedStringWithDefaultValue(@&quot;title&quot;, @&quot;Localizable&quot;, bundle, @&quot;label&quot;, nil); Resources -&gt; Show In Finder后，发现每一种语言都有对应的文件目录，后缀是 .lproj 总结：因此 ar.lproj、en.lproj、fr.lproj、ru.lproj、zh-Hans.lproj、zh-Hant.lproj 为我们可以从本地获取到的 语言资源文件在 App 内切换语言的时候，实际上就是获取 语言资源文件 的 Localizable.strings 文件 将所有的 语言文件 设置成 字符串类型的枚举 并且有初始值 rawValue， 获取 Localizable.strings 获取 某语言 文件的 value值，相应的想要切换语言的话，直接切换 pathForResource 面的 参数 就可以 12345678910111213141516// 本地化语言类型enum LocalizedType: String &#123; // 字符串需要对应本地的国际化文件名 .lproj case English = &quot;en&quot; // 英语 case ChineseHans = &quot;zh-Hans&quot; // 简体中文 case ChineseHant = &quot;zh-Hant&quot; // 繁体中文 case Russian = &quot;ru&quot; // 俄语 case Frcench = &quot;fr&quot; // 法语&#125;// 获取语言文件路径(可以为：en/zh-Hans/zh-Hant/fr/ru 任意一个)let languageBundlePath = Bundle.main.path(forResource: LocalizedType.English, ofType: &quot;lproj&quot;)// 获取语言文件路径下对应 key 的 valuelet value = Bundle(path: languageBundlePath ?? &quot;&quot;)?.localizedString(forKey: &quot;title&quot;, value: nil, table: &quot;ZJLocalizable&quot;)MyLog(message: value) 根据上面的思路，我们可以用 NSUserDefaults 缓存当前的 语言，以便 第一次启动程序 或 程序退出去后，下次进入继续使用上次关闭程序的语言。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 本地化语言类型enum LocalizedType: String &#123; // 字符串需要对应本地的国际化文件名 .lproj case English = &quot;en&quot; // 英语 case ChineseHans = &quot;zh-Hans&quot; // 简体中文 case ChineseHant = &quot;zh-Hant&quot; // 繁体中文 case Russian = &quot;ru&quot; // 俄语 case Frcench = &quot;fr&quot; // 法语&#125;// 初始化启动时语言func initLaunchLanguage() &#123; // 获取上一次设置的语言 var languageType = kUserDefault.getInfo(key: &quot;appLanguage&quot;) // 如果是第一次启动 if languageType == nil &#123; // 获取系统第一个首选语言 let systemLanguage = Locale.preferredLanguages.first! MyLog(message: systemLanguage) if systemLanguage.hasPrefix(LocalizedType.English.rawValue) &#123; // 英文 languageType = LocalizedType.English.rawValue &#125;else if systemLanguage.hasPrefix(LocalizedType.ChineseHans.rawValue) &#123; // 简体中文 languageType = LocalizedType.ChineseHans.rawValue &#125;else if systemLanguage.hasPrefix(LocalizedType.ChineseHant.rawValue) &#123; // 繁体中文 languageType = LocalizedType.ChineseHant.rawValue &#125;else if systemLanguage.hasPrefix(LocalizedType.Frcench.rawValue) &#123; // 法文 languageType = LocalizedType.Frcench.rawValue &#125;else if systemLanguage.hasPrefix(LocalizedType.Russian.rawValue) &#123; // 俄文 languageType = LocalizedType.Russian.rawValue &#125; // 赋值给上一次设置的语言类型 languageType = systemLanguage &#125; // 缓存语言 kUserDefault.saveInfo(value: languageType!, key: &quot;appLanguage&quot;) // 设置bundle setCurrentBundle()&#125; 注：每次设置完语言，我们跟要更新一下 bundle，以便随时获取 key-value 接下来，我们要根据缓存的语言来获取本地语言资源文件，赋值给一个全局的 bundle，以便随时可以通过 bundle 来拿到具体语言文件下的 keu-value 12345678910111213141516171819// 设置bundlefunc setCurrentBundle() &#123; // 拿到当前语言 let currentLanguageType = kUserDefault.getInfo(key: &quot;appLanguage&quot;) as! String // 获取本地语言资源路径 let languageBundlePath = Bundle.main.path(forResource: currentLanguageType, ofType: &quot;lproj&quot;)// MyLog(message: languageBundlePath) guard languageBundlePath != nil else &#123; return &#125; // 获取 bundle let languageBundle = Bundle(path: languageBundlePath!) guard languageBundle != nil else &#123; return &#125; // 赋值给全局的 bundle currentBundle = languageBundle// MyLog(message: currentBundle)&#125; 根据 key 获取 value 123456// 获取要显示的文本func getLanguageValueWithKey(key: String) -&gt; String &#123; let bundle = LocalizableManager.sharedManager.currentBundle let value = bundle?.localizedString(forKey: key, value: nil, table: nil) return value ?? &quot;&quot;&#125; 至此，我们的 App内+系统 切换国际化语言，大功告成！！！","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Blog-06：阿里云图床","slug":"Blog搭建/Blog-06：阿里云图床","date":"2023-03-14T21:11:50.000Z","updated":"2023-03-14T22:11:14.010Z","comments":true,"path":"2023/03/15/Blog搭建/Blog-06：阿里云图床/","link":"","permalink":"https://www.bboyzj.cn/2023/03/15/Blog%E6%90%AD%E5%BB%BA/Blog-06%EF%BC%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"前言最近Gitee突然加了防盗链，导致基于Gitee的图床直接GG了！好家伙还带这样玩的，数据要是没有备份真的心惊胆跳的，不白嫖了，直接付费转战阿里云OSS去。 ​分享一下搭建过程:​ 阿里云OSS开通及配置​​1、开通及购买服务包​​登录 阿里云官网，开通对象存储OSS，开通对象存储OSS不用扣费，只有使用OSS才需要扣费。​​​​​​ 2、OSS有两种扣费方式（产品计费详细介绍）： 按量付费 资源包 根据需要按需购买对应的 资源包 即可，作为一个只是搭建个人向图床的我，只需要购买一个 40GB 的《标准(LRS)存储包》即可，半年只要4.98，四舍五入相当于白嫖…… 我每个月也用不了多少流量，《下行流量包》先暂时不购买，要是后续那天顶不住后再考虑购买即可。 根据需求选择 购买时长，最后支付 注意事项：记得给阿里云账户充值！！！别到时候欠费停用了 3、基础配置 创建 Bucket 打开 OSS管理控制台Bucket页面，按需创建一个Bucket。 Bucket 名称：bboy-blog（自定义）地域：华北2（选择最近）存储类型：标准存储读写权限：公共读其他：默认不改动 创建完成你的 Bucket 就在列表显示了 找到你的地域节点 点击你的 bucket，然后点击 bucket 下的 概览，在 访问域名 一栏找你的 地域节点，后面会用到 找到你的 key 右上角找到头像，在弹出框里选择 AccessKey 管理，在弹出框选择 继续使用 进入后，创建一个新的 AccessKey，在弹出框里，复制你的 AccessKeyId和AccessKeySecret，保存好，以便后续使用 配置 picgo1、打开picgo，在图床设置里选择 阿里云OSS，一招以下步骤填写信息 设定Keyld：必填，填写刚刚获得的AccessKeyID设定KeySecret：必填，填写AccessKeyIDSecret设定Bucket：必填 bboy-blog，填写bucket名称（这里填写的是bucket名称，不是浏览器里的域名）确认存储区域：必填 oss-cn-beijing，填写你的地域节点，注意复制的格式设定存储路径：选填，其实就是自定义一个文件夹的名字，以&#x2F;结尾，它会自动在你的bucket里面创建一个文件夹，并把图片上传进去指定自定义域名：选填 2、配置完成之后，确定，并点击 设置为默认图床 3、PicGo设置 打开 时间戳重命名 和 上传后自动赋值URL 选项 4、至此，你已经配置成功了，可以随意用 PicGo 上传图片了","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"Swift学习：自定义Log","slug":"Swift/Swift学习：自定义Log","date":"2023-03-14T20:26:24.000Z","updated":"2023-03-14T20:50:42.917Z","comments":true,"path":"2023/03/15/Swift/Swift学习：自定义Log/","link":"","permalink":"https://www.bboyzj.cn/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89Log/","excerpt":"","text":"打印文件名、方法、行数1234567891011// 1.获取打印所在的文件let file = (#file as NSString).lastPathComponent;print(file);// 2.获取打印所在的方法let function = #functionprint(function);// 3.获取打印所在的行号let line = #line;print(line) 全局化swift 中的 全局函数：写在单独的一个 .swift 文件下即可，比如：Common.swift 1234567func ZNLog&lt;T&gt;(message:T, file:String = #file, funcName:String = #function, lineNum:Int = #line) &#123; let fileName = (file as NSString).lastPathComponent; print(&quot;[文件名:\\(fileName)]:[函数名:\\(funcName)]:[行数:\\(lineNum)]-打印内容:\\n\\(message)&quot;);&#125; 配置DeBug下打印，Release 下不打印swift 没有宏定义，只能通过添加配置字段 最终写法1234567// 自定义Logfunc MyLog&lt;T&gt;(message: T,file: String = #file, funcName: String = #function, lineNum: Int = #line) &#123;#if DEBUG let fileName = (file as NSString).lastPathComponent print(&quot;[文件名:\\(fileName)]:[函数名:\\(funcName)]:[行数:\\(lineNum)]-打印内容:\\n\\(message)&quot;);#endif&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习49：Any","slug":"Swift课程/Swift学习49：Any","date":"2023-03-13T22:34:03.000Z","updated":"2023-03-13T22:49:03.150Z","comments":true,"path":"2023/03/14/Swift课程/Swift学习49：Any/","link":"","permalink":"https://www.bboyzj.cn/2023/03/14/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A049%EF%BC%9AAny/","excerpt":"","text":"前言在Swift中，Objective-C中的 id 类型现在映射成了Swift中的 Any 类型，它可以代表任何类型的值，无论是类、枚举、结构体还是任何其他Swift类型。这种变化使得Swift中的Objective-C API更加灵活，因为Swift定义的值类型可以传递给Objective-C API并作为Swift中的类型获取，从而无需手动“框选”类型（本人理解为转换、解包）。 集合类型对于Swift中哈希类的集合，例如Dictionary和Set，有一个新类型 AnyHashable，可以保存任何遵守Swift中 Hashable 协议的类型的值。。Array 对应 Any 非集合类型 属性列表，JSON和用户信息字典在Cocoa框架中很常见，Cocoa框架将这些表示为非类型化集合。 Swift可以导入 Cocoa API 接受 Any或AnyHashable 类型的集合，所以我们可以用[AnyHashable：Any] 1234567891011121314151617181920212223// Swift 3struct State &#123; var name: String var abbreviation: String var population: Int // Change the dictionary type to [AnyHashable: Any] here... var asPropertyList: [AnyHashable: Any] &#123; var result: [AnyHashable: Any] = [:] // No implicit conversions necessary, since String and Int are subtypes // of Any and AnyHashable result[&quot;name&quot;] = self.name result[&quot;abbreviation&quot;] = self.abbreviation result[&quot;population&quot;] = self.population return result &#125;&#125;let california = State(name: &quot;California&quot;, abbreviation: &quot;CA&quot;, population: 39_000_000)// ...and you can still use it with Cocoa API hereNotification(name: &quot;foo&quot;, object: nil, userInfo: california.asPropertyList) 未链接上下文的显式转换在某些确定的情况下，Swift不能自动桥接C和Objective-C。 例如，一些C和Cocoa API使用id *指针作为“out”或“in-out”参数，并且由于Swift不能静态地确定指针的使用方式，因此它不能对内存中的值自动执行桥接转换 。 在这种情况下，指针仍将显示为UnsafePointer 。 如果您需要使用到这些不能自动桥接转换的API，您可以使用显式桥接转换，在代码中使用 as Type 或 as AnyObject 显式转换。 12345// ObjC@interface Foo- (void)updateString:(NSString **)string;- (void)updateObject:(id *)obj;@end 123456789101112// Swiftfunc interactWith(foo: Foo) -&gt; (String, Any) &#123; var string = &quot;string&quot; as NSString // explicit conversion foo.updateString(&amp;string) // parameter imports as UnsafeMutablePointer&lt;NSString&gt; let finishedString = string as String var object = &quot;string&quot; as AnyObject foo.updateObject(&amp;object) // parameter imports as UnsafeMutablePointer&lt;AnyObject&gt; let finishedObject = object as Any return (finishedString, finishedObject)&#125; 另外，Objective-C中的协议在Swift中仍然是类约束（及只有类才可以遵守协议），所以你不能让Swift中的结构体或枚举直接遵守Objective-C中的协议或者是使用轻量级的泛型类。 当您需要使用到这些协议和API时应该像这样 String as NSString、Array as NSArray 进行显式转换。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习48：ARC","slug":"Swift课程/Swift学习48：ARC","date":"2023-03-13T09:44:18.000Z","updated":"2023-03-13T22:34:49.569Z","comments":true,"path":"2023/03/13/Swift课程/Swift学习48：ARC/","link":"","permalink":"https://www.bboyzj.cn/2023/03/13/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A048%EF%BC%9AARC/","excerpt":"","text":"ARC swift 使用 自动引用计数（ARC） 来跟踪并管理应用使用的 内存。 引用计数 只应用在 类 的实例。 结构体和枚举 都是 值类型，并非引用类型，不是以引用的方式来 存储和传递 的 ARC 如何工作 每次创建一个类的实例，ARC 就会分配一个内存块，用来存储这个实例的相关信息。这个内存块保存着实例的类型，以及这个实例相关的属性的值 当实例不再被使用时，ARC 是否这个实例使用的内存，使这块内存可做它用。保证了实例不再被使用时，不会占用内存空间 但是，如果 ARC 释放了仍在使用的实例，那么你就不能再访问这个实例的苏醒或者调用它的方法。如果你仍然视图访问这个实例，应用极有可能会崩溃 为了保证不会发生上述的情况， ARC 跟踪类实例的相关属性、常量及变量的数量。只要有一个有效的引用，ARC 都不会释放这个实例 为了让这个变成现实，只要你将一个类的实例赋值给一个属性或常量或变量，这个属性、常量、变量就是这个实例的 强引用（strong reference）。之所以称之为 强引用，是因为它持有这实例，并且只要这个强引用还存在，就不能销毁实例 循环引用 在两个类实例彼此保持对方的强应用，使得每个实例都使对方保持有效时会发生这种情况。我们称之为强引用环 通过用 弱引用或者无主引用 来 取代强引用，我们可以 解决强引用环问题 解决循环引用 弱引用和无主引用 允许引用环中的一个实例引用另外一个实例，但 不是强引用。因此实例可以互相引用但是不会产生强引用 弱引用不会增加实例的引用计数，因此不会阻止ARC销毁被引用的实例。这种特性使得引用不会编程强引用环。声明属性或者变量的时候，关键字 weak 表明引用为弱引用。 弱引用只能声明为变量类型，因为运行时它的值可能会变。弱引用绝对不能声明为常量 因为弱引用可以没有值，所以声明弱引用的时候 必须是可选类型 的。在swift语言中，推荐使用可选类型作为可能没有值的引用类型 123var person: Person?weak var student: Student? 对于生命周期中引用会变nil的实例，使用弱引用；对于初始化时赋值之后引用再也不会赋值为nil的实例，使用无主引用 和弱引用相似，无主引用 也不强持有实例。但是和弱引用不同的是，无主引用默认始终有值。因此，无主引用只能定义为非可选类型。在属性、变量前添加 unowned 关键字，可以声明一个无主引用 因为是 可选类型，因此当使用无主引用时，不需要展开，可直接访问。不过非可选类型变量不能赋值为 nil，因此当实例被销毁的时候，ARC无法将引用赋值为 nil 当实例被销毁后，试图访问该实例的无主引用会触发运行时错误。使用无主引用时请确保引用始终指向一个未销毁的实例 12345678910111213class City &#123; // 无主引用 unowned let country: Country init(country: Country) &#123; self.country = country &#125;&#125;class Country &#123; var capitaCity: City! init(capitaCity: City) &#123; self.capitaCity = capitaCity &#125;&#125; 闭包引用循环将一个闭包赋值给类实例的某个属性，并且这个闭包使用了实例，这样也会产生强引用环。这个闭包可能反问了实例的某个属性，如果 self.someProperty，或者调用了实例的某个方法 self.someMethod。这两种情况都导致了闭包使用 self，从而产生了循环引用 解决： 定义占有列表-占有列表中的每个元素都是由 weak 或者 unowend 关键字和实例的引用（如 self 或 someInstance）组成。每一对都在括号中，通过逗号分开 当闭包和占有的实例总是互相引用时并且总是同时销毁时，将闭包内的占有定义为无主引用 相反的，当占有引用有时可能会是 nil 时，将闭包内的占有定义为 弱引用 123456lazy var someClosure = &#123; [unowned self, weak delete = self.delete] (index: Int,stringToProcess: String) -&gt; String in // closure body goes here&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习47:多线程","slug":"Swift课程/Swift学习47：多线程","date":"2023-03-12T14:52:33.000Z","updated":"2023-03-13T09:40:14.167Z","comments":true,"path":"2023/03/12/Swift课程/Swift学习47：多线程/","link":"","permalink":"https://www.bboyzj.cn/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A047%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"前言为什么几乎所有的GUI框架都是单线程的？：处理问题代价大于收益 多线程可以做什么 网络请求 IO：读写文件 计算 数据模型转换 …. 多线程编程的方式 Thread Operation 和 OperationQueue GCD Thread 三种中最轻量级的，自己管理线程的生命周期和线程同步 线程同步对数据加锁有一定的系统开销 1、快捷方式创建 detachNewThread(_ block: @escaping @Sendable () -&gt; Void) 1234567891011import Foundationimport PlaygroundSupport// 不希望程代码在主线完成后退出，因为很多线程需要异步操作PlaygroundPage.current.needsIndefiniteExecution = truefor i in 0...10 &#123; Thread.detachNewThread &#123; print(i) &#125;&#125; detachNewThreadSelector(_ selector: Selector, toTarget target: Any, with argument: Any?) 2、初始化器 Thread(target: selector: , object: ) 1234567891011121314151617181920import Foundationimport PlaygroundSupport// 不希望程代码在主线完成后退出，因为很多线程需要异步操作PlaygroundPage.current.needsIndefiniteExecution = trueclass ObjectThread &#123; func threadTest() &#123; let thread = Thread(target: self, selector: #selector(threadMethod), object: nil) // 手动开启 thread.start() &#125; @objc func threadMethod() &#123; print(&quot;threadMethod&quot;) &#125;&#125;// 实例let obj = ObjectThread()obj.threadTest() Operation 和 OperationQueue 概述 面向对象 Operation + OperationQueue 取消、依赖、任务优先级、复杂逻辑、保存业务状态、子类化 Operation Operation：抽象类，任务 BlockOperation 1、状态： isReady：准备好了，可以执行了 isExecuting：执行中 isFinished：执行完成 isCancelled：取消执行 2、同步、异步 sync async 3、添加依赖 OperationQueue OperationQueue 队列，可以加入很多 Operation， 底层使用 GCD maxConcurrentOperationCount：可以设置最大并发数 defaultMaxConcurrentOperationCount：根据当前系统条件动态确定的最大并发数，建议使用这个 可以取消所有的 Operation，但是当前正在执行的不会取消 所有 Operation 执行完毕后退出销毁 BlockOperation1234567891011121314151617181920class ObjectOperation &#123; func test() &#123; let operation = BlockOperation&#123; [weak self] in self?.threadMethod() &#125; let queue = OperationQueue() queue.addOperation(operation) &#125; @objc func threadMethod() &#123; sleep(1) print(&quot;threadMethod&quot;) &#125;&#125;let op = ObjectOperation()op.test()print(&quot;after invoke test&quot;)=====after invoke testthreadMethod 由打印结果可知，异步执行了 继承 Operation1234567891011121314151617181920212223242526class ObjectOperation &#123; func test() &#123; let operation = MyOpetation() let queue = OperationQueue() queue.addOperation(operation) &#125; @objc func threadMethod() &#123; sleep(1) print(&quot;threadMethod&quot;) &#125;&#125;class MyOpetation: Operation &#123; override func main() &#123; sleep(1) print(&quot;myOperation main&quot;) &#125;&#125;let op = ObjectOperation()op.test()print(&quot;after invoke test&quot;)========after invoke testmyOperation main Operation 完成的回调 completionBlock 12345678operation.completionBlock = &#123; () -&gt; Void in print(&quot;completionBlock&quot;)&#125;========after invoke testmyOperation maincompletionBlock GCD 任务 + 队列 易用 效率 性能 GCD功能 创建管理Queue 提交Job Dispatch Group 管理Dispatch Object 信号量Semaphore 队里屏障Barrier Dispatch Source Queue Context数据 Dispatch I&#x2F;O Channel Dispatch Data 对象 GCD队列 主队列：任务在主线程执行 并行队列：任务会以先进先出的顺序入列和出列，但是因为多个任务可以并行执行，所以顺序是不一定的 串行队列：任务会以先进先出的顺序入列和出列，但是同一时刻只会执行一个任务 GCD-队列API Dispatch.main Dispatch.global DispatchQueue queue.label setTarget GCD 基本操作 sync 提交任务到当前队列里，并且直接任务执行完成，当前队列才会返回 async 调用一个任务去立即执行，但是不用等任务执行完当前队列就会返回 asyncAfter 调度一个任务多久之后去执行，但是不用等任务执行完当前队列就会返回 GCD 串行 &amp; 并行 串行和并行描述的是任务之间如何运行 串行任务每一个仅执行一个 并行任务可以多个同时执行 GCD 同步 &amp; 异步 GCD 使用 同步 12345678910let queue = DispatchQueue(label: &quot;myQueue&quot;,qos: DispatchQoS.default,attributes: DispatchQueue.Attributes.concurrent,autoreleaseFrequency: DispatchQueue.AutoreleaseFrequency.inherit,target: nil)queue.sync &#123; // 同步 sleep(1) print(&quot;in queue sync&quot;)&#125;print(&quot;after invoke queue method&quot;)======in queue syncafter invoke queue method 异步 123456789queue.async &#123; // 异步 sleep(1) print(&quot;in queue async&quot;)&#125;print(&quot;after invoke queue method&quot;)=====after invoke queue methodin queue async asyncAfter 12345678queue.asyncAfter(deadline: .now() + 1) &#123; print(&quot;in asyncAfter&quot;)&#125;print(&quot;after invoke queue method&quot;)=======after invoke queue methodin asyncAfter GCD 源码剖析 dispatch_sync 线程A在串行队里dq中执行task1的过程中，如果再向dq中投递串行任务task2，同时还要求必须阻塞当前线程，等待task2结束(sync投递task2)，那么这时候会发生死锁 因为这时候task1还没有结束，串行队列不会去执行task2，而我们又要在当前线程等待task2的结束才肯继续执行task1，即task1在等待task2，而task2也在等待task1，循环等待，形成死锁 123456789// 串行队列let queue = DispatchQueue(label: &quot;label&quot;)queue.async &#123; // 异步 print(&quot;in queue async&quot;) // 串行队列执行task1 queue.sync &#123; print(&quot;in queue sync&quot;) // 串行队列加入task2 &#125;&#125;// 死锁 临界区一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码 竟态条件 两个或多个线程读写某些数据，而最后的结果取决于线程运行的精确时序 Locks SpinLock 线程通过busy-wait-loop方式来获取锁，任何时刻只有一个线程能够获取锁，其他线程忙等待知道获取锁 临界区尽量简短，控制在100行代码以内，不要有限时或隐士的系统调用，调用的函数也尽量简短 保证访问锁的线程全部都处于同一优先级 @synchronized12345func synchronized(_ obj: Any, closure: ()-&gt;()) &#123; objc_sync_enter(obj) closure() objc_sync_exit(obj)&#125; 只有传同样的对象给synchronized，才能起到加锁的作用 如果传nil，无法起到加锁的作用 可以重入 synchronized不会持有传给它的对象 典型场景 一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面 实现一个多线程安全的Array的读和写 编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度 需要在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件 【场景一】：一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面【场景二】：实现一个多线程安全的Array的读和写一个队列加方法方法 1、首先是 并行队列，我们需要保持多线程并行操作 2、 sync 方法，封装读操作，读操作在调用读方法时能直接拿到返回值，而不是异步获取 3、async 方法使用 barrier flag，封装写操作，起到一个栅栏的作用，等待所有的 barrier flag 函数前操作执行完成后， barrier flag 函数之后的所有操作才执行 【场景三】：编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度【场景四】：需要 在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件Promise 多线程编程模式 所谓的 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成）、Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英文意思就是 承诺，表示其他手段无法改变 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 变为 Rejected，只要这两种情况发送，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发送了，你再对 Resolved 对象添加回调函数，也会立即得到这个结果。这与事件 Event 完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的 Pipeline 将一个任务分解为若干个阶段（State），前阶段的输出作为下阶段的输入，各个阶段由不同的工作者线程负责执行 各个任务的各个阶段是并行（Parallel）处理的 具体任务的处理是串行的，即完成一个任务要一次执行各个阶段，但从整体任务上看，不同任务的各个阶段的执行时并行的 Master&#x2F;Slave将一个任务分解为若干个语义等同的子任务，并由专门的工作者线程来并行执行这些子任务，既提高计算效率，又实现了信息隐藏","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习50：多态和类型转换","slug":"Swift课程/Swift学习50：多态和类型转换","date":"2023-03-12T14:36:21.000Z","updated":"2023-03-14T18:40:44.757Z","comments":true,"path":"2023/03/12/Swift课程/Swift学习50：多态和类型转换/","link":"","permalink":"https://www.bboyzj.cn/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A050%EF%BC%9A%E5%A4%9A%E6%80%81%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"向下类型转换 类型的常量或变量实际上是子类的实例，你可以用 as? 或 as! 向下类型转换至子类类型 向下类型转换可能失败，as？ 返回的值是 可选类型，as！ 返回的是 强制类型 12345678910111213141516171819202122232425262728293031323334// 基类class MediaItem &#123; var name: String init(name: String) &#123; self.name = name &#125;&#125;// 子类class Movie: MediaItem &#123; var director: String init(name: String, director: String) &#123; // 安全检查 self.director = director super.init(name: name) &#125;&#125;// 子类class Song: MediaItem &#123; var artist: String init(name: String,artist: String) &#123; self.artist = artist super.init(name: name) &#125;&#125;let arr = [Movie(name: &quot;1&quot;, director: &quot;2&quot;), Song(name: &quot;3&quot;, artist: &quot;4&quot;), Movie(name: &quot;5&quot;, director: &quot;6&quot;)]print(type(of: arr))for item in arr &#123; // 向下类型转换 if let realItem = item as? Movie &#123; print(realItem.director) &#125;&#125; Any 和 AnyObjectswift 为不确定的类型提供了两种特殊的类型别名： AnyObject：表示任何类类型 Any：表示任何类型，包括函数类型 嵌套类型 swift 中 类、结构体、枚举 可以进行嵌套 嵌套类型能够访问它外部的成员","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习42：初始化器","slug":"Swift课程/Swift学习42：初始化器","date":"2023-03-12T09:43:58.000Z","updated":"2023-03-14T19:28:40.472Z","comments":true,"path":"2023/03/12/Swift课程/Swift学习42：初始化器/","link":"","permalink":"https://www.bboyzj.cn/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A042%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8/","excerpt":"","text":"前言 类、枚举、结构体 可以引入 初始化器。初始化器使用 关键字init来声明 结构体、枚举、类 可以有任意数量的初始化器，但是 类 的初始化器不同 于结构体和枚举，类有两种初始化器，即指定初始化器和便捷初始化器。 存储属性的初始赋值 类 的 存储属性需要有默认值，而 结构体、枚举不需要 类设置默认值方式也有两种：一种是 定义存储属性时设置默认值（Optional），另一种是通过 初始化器为存储属性设置默认值 类的初始化器有两种，一种 指定初始化器，另一种 便捷初始化器 指定初始化器又分为两种：一种 初始化器 不带参数，另一种 自定义初始化器 带参数 默认值 可选类型 的存储属性，不需要设置默认值，因为它本身 可能有值 或 可能没有值，编译器会自动设置默认的初始化器 直接设置默认值 123456class Person &#123; // 1、声明一个 Optional 默认值 var name: String? // 2、直接设置默认值 var name: String = &quot;&quot;&#125; 也可以通过 闭包 设置默认值 123456class Person &#123; var name: String &#123; // 在这个闭包中给 name 创建一个默认值 return &quot;ZJ&quot; &#125;&#125; 指定初始化器为存储属性设置默认值 初始化器创建实例时被调用，最简答的形式是不带任何参数的实例方法，已关键字 init 命名，即 指定初始化器 可选类型的存储属性 123clas Person &#123; var name: String？&#125; 自定义初始化器设置默认值，带参数 可以通过 输入参数 来自定义初始化器 1234567891011121314151617181920212223class Person &#123; var name: String // 0.不带参数 init() &#123; self.name = &quot;ZJ&quot; &#125; // 1.实际参数和形式参数相同 init(name: String) &#123; self.name = name &#125; // 2.实际参数 和 形式参数 不同 init(to name: String) &#123; self.name = name &#125; // 3.通配符实际参数 init(_ name: String) &#123; self.name = name; &#125;&#125;let p = Person(name: &quot;ZJ&quot;)let p1 = Person(to: &quot;ZJ&quot;)let p2 = Person(&quot;ZJ&quot;) 注：指定初始化器分为两种：一种是不带参数，一种是带参数初始化器可以有任意数量 类的继承和构造类中的所有存储属性-&gt;包括继承父类的所有存储属性：都必须在构造过程中 设置默认值 1、swift 中为类提供了两种初始化器：指定初始化器 和 便捷初始化器 指定初始化器 类中主要的初始化器，设置类中所有属性默认值，并往上调用父类的初始化器设置所有属性的默认值 便捷初始化器 类中次要的、辅助型的初始化器，可以调用类中的指定初始化器，并提供默认值 2、指定初始化器和便捷初始化器语法 指定初始化器和简单初始化器一样 123init(parameters) &#123; statements&#125; 便捷初始化器，需要在 init 前放置 convenience 关键字 123456789101112131415class Person &#123; // 未设置默认值的存储属性 var name: String // 指定初始化器 用来给存储属性设置默认值 init(name: String) &#123; self.name = name &#125; // 便捷初始化器 convenience init() &#123; // 横向代理：必须调用一个指定的初始化器 self.init(name: &quot;ZJ&quot;) &#125;&#125;let p = Person()print(p.name) 类的初始化器代理规则1、指定初始化器必须调用其直接父类的指定初始化器2、便捷初始化器必须调从同类调用一个指定初始化器3、便捷初始化器最终必须调用一个指定初始化器 更方便的记忆方法1、指定初始化器必须总是向上代理2、便捷初始化器必须是横向代理 3、初始化器继承和重写 子类默认是 不继承 父类的初始化器，实际上是通过 重写 父类的初始化器，切需要带上 override 关键字 12345678910111213141516171819// 继承和重写class Person &#123; var name: String init(name:String) &#123; self.name = name &#125;&#125;class Student: Person &#123; // 重写父类的初始化器 override init(name: String) &#123; var newName = &quot;my name is \\(name)&quot; super .init(name: newName) &#125;&#125;let s = Student(name: &quot;ZJ&quot;)print(s.name)=======my name is ZJ 初始化器的自动继承 1、如果子类没有定义任何初始化器，它将自动继承父类的所有指定初始化器2、如果子类实现了继承自父类的指定初始化器，那么它将自动继承父类的便捷初始化器 示例 1234567891011121314151617181920212223242526272829303132class Person &#123; var name: String init(name:String) &#123; self.name = name &#125; convenience init() &#123; self.init(name: &quot;ZJ&quot;) &#125;&#125;let p = Person()print(p.name)// 打印结果 ZJ// 子类class Student: Person &#123; var age: Int // 本类的指定初始化器 init(name: String,age: Int) &#123; self.age = age // 实现父类的指定初始化器 super.init(name: name) &#125; convenience override init(name: String) &#123; self.init(name: name, age: 32) &#125;&#125;let s = Student()let s1 = Student(name: &quot;ZJ&quot;)let s2 = Student(name: &quot;ZJ&quot;, age: 32)print(s.age)// 打印结果 32 安全检查 子类指定初始化器向上委托父类初始化器前，子类的所有属性都要完成初始化 之类指定初始化器必须先向上委托父类初始化器，才能修改父类的所有属性 便捷初始化器必须先委托同类初始化器，才能为任意属性赋值 方法的调用在所有指定初始化器之后。 123456789101112131415161718192021222324252627282930313233343536373839// 安全检查class Person &#123; var name: String var age: Int // 指定初始化器 init(name: String, age: Int) &#123; self.name = name self.age = age &#125; convenience init()&#123; self.init(name: &quot;[Unnamed]&quot;, age: 0) &#125;&#125;class Teacher: Person &#123; // 工资 var salary: Int // 自己的指定初始化器 init(name: String, age: Int, salary: Int) &#123; // 1.先赋值自己的所有属性 self.salary = salary // 2.调用父类的指定初始化器 super.init(name: name, age: age) // 3.修改父类的所有属性 self.name = name + &quot;老师&quot; // 6.调用方法 test() &#125; func test() &#123; print(&quot;test&quot;) &#125; convenience init(salary: Int) &#123; // 4.必须调用本类的指定初始化器 self.init(name: &quot;ZJ&quot;, age: 32, salary: salary) // 5.调用本类的指定初始化器后，才能赋值本类的所有属性 self.salary = self.salary + 1000 &#125;&#125; 失败初始化器如果在构造过程有可能失败，则需要定义一个可失败的初始化器，在 init 关键字 后面 添加 ? 1234567891011121314class Person &#123; var age: Int init?(age: Int) &#123; if age &gt; 200 &#123; return nil &#125; age = age &#125;&#125;let p = Person(age: 300)print(p)=====nil 反初始化器 类实例 被释放时，反初始化器立即被调用。用 deinit 关键字写反初始化器。 反初始化器在 实例释放前自动被调用。不能自己调用。可以被子类继承。先子类 -&gt; 父类 每个类只能有一个 123deinit &#123; // perform the deinitialization&#125; 必要初始化器 在类的初始化器前加 required 修饰符表明所有该子类必须实现该初始化器 123456// 必要初始化器class SomeClass &#123; required init()&#123; // 初始化器的实现代码 &#125;&#125; 子类重写父类的必要初始化器时，子类的初始化器前也添加 required 关键字，表明可继承 1234567// 必要初始化器class SomeSubClass: SomeClass &#123; required init()&#123; // 初始化器的实现代码 &#125;&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习41：泛型","slug":"Swift课程/Swift学习41：泛型","date":"2023-03-10T20:40:24.000Z","updated":"2023-03-11T20:49:13.971Z","comments":true,"path":"2023/03/11/Swift课程/Swift学习41：泛型/","link":"","permalink":"https://www.bboyzj.cn/2023/03/11/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A041%EF%BC%9A%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"泛型 泛型代码能根据所定义的要求写出可以用于任何类型的灵活的、可复用的函数。可以编写出可复用、意图表达清晰、抽象的代码。 泛型 是Swift最强大的特性之一，很多Swift标准库 是基于 泛型 代码构建的。如，Swift 的 Array和Dictionary类型都是泛型集合；你也可以创建一个容纳 Int 值的数组，或者容纳 String 值的数组，甚至容纳任何 Swift 可以创建的其他类型的数组。同样，可以创建一个存储任何指定类型值的字典，而且类型没有限制。 泛型所解决的问题：代码的复用性和抽象能力。比如，交换两个值，这里的值可以是Int、Double、String。 123456//经典例子swap，使用泛型，可以满足不同类型参数的调用func swap&lt;T&gt;(_ a: inout T, _ b: inout T)&#123; let tmp = a a = b b = tmp&#125; 基础语法主要讲3点：类型约束、关联类型、Where语句 类型约束 在一个 类型参数后面放置协议或者是类，例如下面的例子，要求类型参数T遵循 Equatable 协议。 1234567func test&lt;T:Equatable&gt;(_ a: T, _ b: T) -&gt; Bool &#123; return a == b&#125;test(1, 2)// 打印结果 falsetest(&quot;A&quot;, &quot;a&quot;)// 打印结果 false Equatable协议：可以比较值相等的协议，即可以使用 == 比较 关联类型 在定义协议时，使用 关联类型 给 协议 中用到的 类型 起一个 占位符名称。关联类型 只能用于协议，并且是通过关键字 associatedtype 指定。 下面这个示例，仿写的一个栈的结构体： 1234567891011121314struct Stack &#123; var items = [Int]() // 入栈 mutating func push(_ item: Int) &#123; items.append(item) &#125; // 出栈 mutating func pop() -&gt; Int?&#123; if items.isEmpty &#123; return nil &#125; return items.removeLast() &#125;&#125; 该结构体中有个成员 item，是个只能存储 Int 类型的数组，如果想使用其他类型呢？ 可以通过协议来实现 ： 12345678910111213141516171819202122protocol StackProtocol &#123; // 协议中使用类型的占位符 associatedtype Item&#125;struct Stack: StackProtocol&#123; // 在使用时，需要指定具体的类型 typealias Item = Int var items = [Item]() // 入栈 mutating func push(_ item: Int) &#123; items.append(item) &#125; // 出栈 mutating func pop() -&gt; Int?&#123; if items.isEmpty &#123; return nil &#125; return items.removeLast() &#125;&#125; 我们在尝试用 泛型 实现上面的功能： 123456789101112131415// 泛型实现struct Stack&lt;T&gt; &#123; var items = [T]() // 入栈 mutating func push(_ item: T) &#123; items.append(item) &#125; // 出栈 mutating func pop() -&gt; T?&#123; if items.isEmpty &#123; return nil &#125; return items.removeLast() &#125;&#125; 泛型的优势和强大，暴露无疑 where where语句 主要用于 表明泛型需要满足的条件，即 限制形式参数的要求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// whereprotocol StackProtocol &#123; // 协议中使用类型的占位符 associatedtype Item // 实例属性 var itemCount: Int &#123; get &#125; // 出栈 mutating func pop() -&gt; Item? // 下标获取 func index(of index: Int) -&gt; Item&#125;struct Stack: StackProtocol &#123; // 在使用时，需要指定具体的类型 typealias Item = Int // 存储属性 var items = [Item]() // 计算属性 var itemCount: Int &#123; get &#123; return items.count &#125; &#125; // 入栈 mutating func push(_ item: Item)&#123; items.append(item) &#125; // 出栈 mutating func pop() -&gt; Item?&#123; if items.isEmpty &#123; return nil &#125; return items.removeLast() &#125; // 下标获取 func index(of index: Int) -&gt; Item&#123; return items[index] &#125;&#125;/* whrer语句 T1.Item == T2.Item 表示 T1和T2中的类型必须相等 T1.Item: Equatable 表示 T1的类型必须遵循Equatable协议，意味着T2也要尊徐Equatable协议 */func compare&lt;T1: StackProtocol, T2: StackProtocol&gt;(_ stack1: T1,_ stack2: T2) -&gt; Bool where T1.Item == T2.Item, T1.Item: Equatable &#123; // 如果数量相等，则遍历 guard stack1.itemCount == stack2.itemCount else &#123; return false &#125; // 遍历 for i in 0..&lt;stack1.itemCount &#123; if stack1.index(of: i) != stack2.index(of: i) &#123; return false &#125; &#125; return true&#125; 还可以这么写： 12// 扩展协议中的 Iem 遵循 Equatableextension StackProtocol where Item: Equatable &#123;&#125; 当希望 泛型指定类型 拥有特定功能，可以这么写，在上述写法的基础上 增加extension： 12// 扩展协议中 Item 指定具体类型extension StackProtocol where Item == Int &#123;&#125; 泛型函数123456789101112131415// 简单的泛型函数func testGen&lt;T&gt;(_ value: T) -&gt; T &#123; let tmp = value return tmp&#125;class Teacher &#123; var age: Int = 18 var name: String = &quot;ZJ&quot;&#125;// 传入Int类型testGen(10)// 传入元组testGen((1,2))// 传入实例对象testGen(Teacher()) 从以上代码可以看出，泛型函数 可以接受任何类型。 总结 泛型主要用于解决代码的 抽象能力，以及提升代码的 复用性 如果一个泛型 遵循了某个协议，则在使用时，要求具体的类型也是必须遵循某个协议的； 在定义协议时，可以使用 关联类型 给协议中用到的 类型 起一个 占位符名称； where语句 主要用于表明泛型需要满足的条件，即 限制形式参数的要求。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"OC学习20：UIViewController生命周期","slug":"OC学习/OC学习20：UIViewController生命周期","date":"2023-03-09T21:15:32.000Z","updated":"2023-03-09T21:47:29.431Z","comments":true,"path":"2023/03/10/OC学习/OC学习20：UIViewController生命周期/","link":"","permalink":"https://www.bboyzj.cn/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A020%EF%BC%9AUIViewController%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"UIViewController生命周期相关方法 (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil; 非storyBoard(xib或非xib)都走这个方法 (instancetype)initWithCoder:(NSCoder *)aDecoder; 如果连接了串联图storyBoard 走这个方法 (void)awakeFromNib; xib 加载 完成 +(void)load load 在代码加载的时候，对象还没有被初始化的时候就已经调⽤了，可以⽤来做⼀些全局的swizzle,只调⽤⼀次 +(void)initialize 类的初始化方法 -(instancetype)init 对象初始化方法 -(void)loadView 加载视图:当访问UIViewController的view属性时，view如果此时是nil，那么VC会自动调用loadView方法来初始化一个UIView并赋值给view属性。此方法用在初始化关键view，需要注意的是，在view初始化之前，不能先调用view的getter方法，否则将导致死循环（除非先调用了[super loadView];）如果没有重载loadView方法，则UIViewController会从nib或StoryBoard中查找默认的loadView，默认的loadView会返回一个空白的UIView对象。 -(void)viewDidLoad 视图加载完成 -(void)viewWillAppear:(BOOL)animated 将要展示:在view即将添加到视图层级中（显示给用户）且任意显示动画切换之前调用,此时self.view.superview为nil.这个方法中完成任何与试图显示相关的任务，例如改变视图方向、状态栏方向、视图显示样式等。 -(void)viewWillLayoutSubviews 将要布局子视图,self.view.superview为_UIParallaxDimmingView -(void)viewDidLayoutSubviews 已经布局子视图 -(void)viewDidAppear:(BOOL)animated 已经展示:在view被添加到视图层级中，显示动画切换之后调用（这时view已经添加到supperView中）。在这个方法中执行视图显示相关附件任务，如果重载了这个方法，必须在方法中调用[supper viewDidAppear];,此时self.view.superview为UIViewControllerWrapperView。 -(void)viewWillDisappear:(BOOL)animated 将要消失:view即将从supperView中移除，移除动画切换之后调用，此时已调用removeFromSuperview。此时self.view.superview还是superview为UIViewControllerWrapperView. -(void)viewDidDisappear:(BOOL)animated 已经消失:view从superView中移除，移除动画切换之后调用，此时已调用removeFromSuperview。此时self.view.superview还是superview为nil. -(void)dideMemoryWarning 内存警告 -(void)dealloc 销毁释放 声明周期 -[ViewController initWithCoder:]-[ViewController awakeFromNib]-[ViewController loadView]-[ViewController viewDidLoad]-[ViewController viewWillAppear:]-[ViewController viewWillLayoutSubviews]-[ViewController viewDidLayoutSubviews]-[ViewController viewDidAppear:]-[ViewController viewWillDisappear:]-[ViewController viewDidDisappear:]-[ViewController dealloc]-[ViewController didReceiveMemoryWarning]","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习19：UIView的生命周期","slug":"OC学习/OC学习19：UIView的生命周期","date":"2023-03-09T21:03:36.000Z","updated":"2023-03-09T21:38:16.025Z","comments":true,"path":"2023/03/10/OC学习/OC学习19：UIView的生命周期/","link":"","permalink":"https://www.bboyzj.cn/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A019%EF%BC%9AUIView%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"UIView生命周期相关函数 (instancetype)initWithFrame:(CGRect)frame; 构造方法,初始化时调用,不会调用init方法 -(instancetype)init 构造方法,内部会调用initWithFrame方法 (instancetype)initWithCoder:(NSCoder *)aDecoder; xib归档初始化视图后调用,如果xib中添加了子控件会在didAddSubview方法调用后调用 (void)awakeFromNib; 唤醒xib,可以布局子控件 -(void)willMoveToSuperview:(UIView *)newSuperview 父视图将要更改为指定的父视图,当前视图被添加到父视图时调用 -(void)didMoveToSuperview 父视图已更改时调用 -(void)willMoveToWindow:(UIWindow *)newWindow 其窗口对象将要更改时调用 -(void)didMoveToWindow 窗口对象已经更改时调用 -(void)layoutSubviews 布局子控件 -(void)drawRect:(CGRect)rect 绘制视图 -(void)dealloc 销毁 (void)didAddSubview:(UIView *)subview; 添加子控件时调用 (void)willRemoveSubview:(UIView *)subview; 将要移除子控件 init方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为: [NoXibView initWithFrame:][NoXibView init][NoXibView willMoveToSuperview:][NoXibView didMoveToSuperview][NoXibView willMoveToWindow:][NoXibView didMoveToWindow][NoXibView layoutSubviews] initWithFrame方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为: [NoXibView initWithFrame:][NoXibView willMoveToSuperview:][NoXibView didMoveToSuperview][NoXibView willMoveToWindow:][NoXibView didMoveToWindow][NoXibView layoutSubviews][NoXibView drawRect:] 移除销毁是调用顺序: [NoXibView willMoveToWindow:][NoXibView didMoveToWindow][NoXibView willMoveToSuperview:][NoXibView didMoveToSuperview][NoXibView removeFromSuperview][NoXibView dealloc] 添加子控件展示时调用顺序: [NoXibView initWithFrame:][NoXibView didAddSubview:][NoXibView willMoveToSuperview:][NoXibView didMoveToSuperview][NoXibView willMoveToWindow:][NoXibView didMoveToWindow][NoXibView layoutSubviews][NoXibView drawRect:] 添加子控件移除销毁时调用顺序: [NoXibView willMoveToWindow:][NoXibView didMoveToWindow][NoXibView willMoveToSuperview:][NoXibView didMoveToSuperview][NoXibView removeFromSuperview][NoXibView dealloc][NoXibView willRemoveSubview:] xib创建初始化视图, xib中不添加子控件时调用顺序: [XibView initWithCoder:][XibView awakeFromNib][XibView willMoveToSuperview:][XibView didMoveToSuperview][XibView willMoveToWindow:][XibView didMoveToWindow][XibView layoutSubviews][XibView layoutSubviews][XibView drawRect:] xib创建初始化视图, xib中添加子控件时调用顺序: [XibView didAddSubview:][XibView initWithCoder:][XibView awakeFromNib][XibView willMoveToSuperview:][XibView didMoveToSuperview][XibView willMoveToWindow:][XibView didMoveToWindow][XibView layoutSubviews][XibView layoutSubviews][XibView drawRect:] 移除销毁时调用顺序,有子控件: [XibView willMoveToWindow:][XibView didMoveToWindow][XibView willMoveToSuperview:][XibView didMoveToSuperview][XibView removeFromSuperview][NoXibView dealloc][NoXibView willRemoveSubview:]","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC面试题：Block","slug":"面试题/OC面试题：Block","date":"2023-03-09T18:31:11.000Z","updated":"2023-03-09T21:52:35.872Z","comments":true,"path":"2023/03/10/面试题/OC面试题：Block/","link":"","permalink":"https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ABlock/","excerpt":"","text":"Block的本质 block 的 本质 是 对象、函数、结构体，由于block函数没有名称，也被称为 匿名函数 Block的分类？ 分为 全局Block(_NSConcreteGlobalBlock)、栈Block(_NSConcreteStackBlock)、堆Block(_NSConcreteMallocBlock) 三种形式。 其中 栈Block存储在栈(stack)区，堆Block存储在堆(heap)区，全局Block存储在已初始化数据(.data)区。 堆：动态分配内存，需要程序员自己申请，程序员自己管理 栈：自动分配内存，自动销毁，先入后出，栈上的内容存在自动销毁的情况","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-面试题","slug":"OC-面试题","permalink":"https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC面试题：Runtime","slug":"面试题/OC面试题：Runtime","date":"2023-03-09T18:30:47.000Z","updated":"2023-03-09T19:50:38.374Z","comments":true,"path":"2023/03/10/面试题/OC面试题：Runtime/","link":"","permalink":"https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARuntime/","excerpt":"","text":"runtime如何通过selector找到对应的IMP地址？ class_getMethodImplementation(Class cls, SEL name); method_getImplementation(Method m) Runtime 如何实现 weak 属性?Runtime 对 注册的类，会进行 布局，会将 weak 对象放入一个 hash 表中。 用 weak 指向的 对象内存地址 作为 key，当此对象的引用计数为0的时候会调用对象的 dealloc 方法， 假设 weak 指向的对象内存地址是a，那么就会以a为key，在这个 weak hash表中搜索，找到所有以a为key的 weak 对象，从而设置为 nil。","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-面试题","slug":"OC-面试题","permalink":"https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC面试题：Runloop","slug":"面试题/OC面试题：Runloop","date":"2023-03-09T18:30:37.000Z","updated":"2023-03-09T19:51:04.231Z","comments":true,"path":"2023/03/10/面试题/OC面试题：Runloop/","link":"","permalink":"https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARunloop/","excerpt":"","text":"PerformSelector和runloop的关系？ 基础用法：默认在主线程的runloop，会执行，因为此方法是发送消息，objc_msgSend 1[self performSelector:@selector(name:) withObject:@“张建&quot;]; performSelector 在子线程默认不执行，需要加入到 runloop 中并开启","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-面试题","slug":"OC-面试题","permalink":"https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC面试题：算法","slug":"面试题/OC面试题：算法","date":"2023-03-09T18:22:53.000Z","updated":"2023-03-09T18:26:38.290Z","comments":true,"path":"2023/03/10/面试题/OC面试题：算法/","link":"","permalink":"https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%97%E6%B3%95/","excerpt":"","text":"冒泡排序1）依次比较相邻两个元素，顺序错误则交换位置；需要两层循环，外层循环控制趟数，内层循环控制比较次数 2）例子： 123456789101112NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;5&quot;,@&quot;4&quot;]]; // 外循环控制排序趟数,进行 array.count-1 趟 for (int i = 0; i &lt; arr.count; i ++) &#123; // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序 for (int j = 0; j &lt; arr.count - i - 1; j++) &#123; // 相邻元素比较，若逆序则交换 if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123; [arr exchangeObjectAtIndex:j withObjectAtIndex:j + 1]; &#125; &#125; &#125; 选择排序1）从第一个元素与其他元素比较找到最小值，重复操作，直到最后一位结束；需要两层循环，外层循环趟数，里层循环比较次数 2）例子 1234567891011NSMutableArray * arr = [NSMutableArray arrayWithObjects:@&quot;2&quot;,@&quot;1&quot;,@&quot;5&quot;,@&quot;3&quot;, nil];// 外循环控制排序趟数,进行 array.count-1 趟for (int i = 0; i &lt; arr.count; i ++) &#123; // 里循环获比较换位 for (int j = i + 1; j &lt; arr.count; j ++) &#123; if ([arr[i] intValue] &gt; [arr[j] intValue]) &#123; [arr exchangeObjectAtIndex:i withObjectAtIndex:j]; &#125; &#125;&#125;NSLog(@&quot;arr:%@&quot;,arr); 直接插入排序1） 始终定义第一个元素为 已排序 的，将剩余元素定义为 未排序 逐个插入到 已排序 的排列中；不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去 2）例子 12345678910111213141516171819NSMutableArray * arr = @[@2,@1,@3,@5,@4].mutableCopy;// 插入排序的原理：始终定义第一个元素为有序的，将元素逐个插入到有序的排列中// 其特点是：不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去for(int i = 0;i &lt; arr.count;i++)&#123; // 待排序值 NSNumber * temp = arr[i]; // 已排序下标 int j = i - 1; // 待排序与已排序比较，从后向前比较 while (j &gt;= 0 &amp;&amp; [arr[j] integerValue] &gt; [temp integerValue]) &#123; // 如果已排序的 &gt; 待排序的 往后移动一个位置 [arr replaceObjectAtIndex:(j + 1) withObject:arr[j]]; j --; &#125; // 空出来的位置插入新元素 [arr replaceObjectAtIndex:(j + 1) withObject:temp]; NSLog(@&quot;arr:%@&quot;,arr);&#125; 打印结果： 12345672022-12-13 10:26:19.242271+0800 插入排序[4184:77845] arr:( 1, 2, 3, 4, 5) 希尔排序1）希尔排序相当于 直接插入排序加强版，引入了 增量 的概念；直到增量为 1 时，再进行直接插入排序 2）例子 1234567891011121314151617181920212223NSMutableArray * arr = @[@7,@3,@8,@5,@2,@6,@1,@4].mutableCopy;// 其实间隔值设值为总数的一半int gap = arr.count/2;// 直到间隔小于1时结束while (gap &gt;= 1) &#123; // i 待排元素，以 步距 gap 从后向前扫描 for(int i = 0;i &lt; arr.count;i++)&#123; // 待排元素 NSNumber * temp = arr[i]; // 当前位置 int j = i; // 跳跃式比较 while (j &gt;= gap &amp;&amp; [arr[j - gap] integerValue] &gt; [temp integerValue] ) &#123; [arr replaceObjectAtIndex:j withObject:arr[j - gap]]; j -= gap; &#125; // 空出来位置，插入待排序 [arr replaceObjectAtIndex:j withObject:temp]; &#125; // 改变步长 gap = gap/2;&#125;NSLog(@&quot;arr:%@&quot;,arr); 打印结果： 123456789102022-12-13 10:22:41.910840+0800 插入排序[4124:74568] arr:( 1, 2, 3, 4, 5, 6, 7, 8) 斐波那契数列1）也就是 兔子数列，当前数是前两个数列之和 2）例子 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; NSInteger num = 10; NSInteger total = [self getTotalNum:num]; NSLog(@&quot;total:%ld&quot;,total);&#125;- (NSInteger)getTotalNum:(NSInteger)num&#123; if(num == 0)&#123; return 0; &#125; if(num == 1)&#123; return 1; &#125; return [self getTotalNum:num-2] + [self getTotalNum:num-1];&#125; 打印结果： 12022-12-13 10:28:32.672554+0800 斐波那契数列[4285:80606] total:89 二分查找1）有序的数组，将数组分割成两份，利用查找的值跟中间值进行比较，如果查找的值大于中间值，就在数组的右边进行查找；如果查找的值小于中间值，就在数组的左边进行查找。如此循环的执行下去，最终找到符合的值。 2）例子 123456789101112131415161718192021222324NSArray * arr = @[@(1),@(3),@(5),@(6),@(8),@(10)];int key = [@(5) intValue];int min = 0;int max = arr.count - 1;int mid;while (min &lt;= max) &#123; // 计算中间下标 mid = (min + max) / 2; // 如果目标值 &gt; 中间下标的中间值 if (key &gt; [arr[mid] intValue]) &#123; //最小变为中间下标+1 min = mid + 1; &#125; // 如果目标值 &lt; 中间下标的中间值 else if (key &lt; [arr[mid] intValue])&#123; //最大变为中间下标-1 max = max - 1; &#125; // 否则，正好 else &#123; NSLog(@&quot;key:%d&quot;,mid); break; &#125;&#125; 打印结果： 12022-12-13 10:33:18.661324+0800 二分查找[4607:86953] key:2 递归算法递归求和1+2+..+n? 1234567891011121314- (void)viewDidLoad &#123; [super viewDidLoad]; int sum = [self sum:4]; NSLog(@&quot;sum:%d&quot;,sum);&#125;- (int)sum:(int)n&#123; if (n == 1) &#123; return 1; &#125;else &#123; return [self sum:n-1] + n; &#125;&#125;","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-面试题","slug":"OC-面试题","permalink":"https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC面试题：多线程","slug":"面试题/OC面试题：多线程","date":"2023-03-09T18:22:02.000Z","updated":"2023-03-09T21:52:44.247Z","comments":true,"path":"2023/03/10/面试题/OC面试题：多线程/","link":"","permalink":"https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"你了解线程么？谈谈你对进程和线程的理解？ 进程是 系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是程序的实体。 线程是 独立调度和分派的基本单位，一条线程是进程中一个单一顺序的控制流。 同一进程中多条线程共享进程中的全部系统资源，一个进程有很多线程，一个进程可以并发多个线程。 iOS中，有哪些实现多线程的方式？ Pthread 特点：C语言。跨平台，可移植，使用难度大。生命周期：自己管理。NSThread 特点：OC语言。面向对象，简单易用，可直接操作线程。生命周期：自己管理。GCD 特点：替代NSThread，充分利用多核的技术。生命周期：系统管理。NSOperaton 特点：基于GCD的封装。比GCD多了一些简单实用的功能。生命周期：系统管理。 请说一下多线程中 GCD 和 NSOperation 的区别？GCD： 提供了一次性执行的代码 dispatch_once ，也就是说保证了一段代码在程序执行的过程中只被执行一次，并且是线程安全的！，实现的单例。 提供了 延迟执行 的简便方法 dispatch_after。 提供了 调度组 的使用，监听一些列异步方法之行结束之后，我们得到统一的通知 dispatch_group dispatch_group_async dispatch_group_notify dispatch_group_enter&#x2F;dispatch_group_leave 提供了 快速迭代的方式dispatch_apply。按照指定的次序将制定的任务追加到指定的队列中，并等待全部队列执行结束！ 提供了信号量 dispatch_semaphore_t，使用信号量可以实现安全的多线程！（加锁的一种方式） dispatch_semaphore_wait：信号量减1，阻塞当前线程 dispatch_semaphore_signal：信号量加1，释放当前线程 提供了栅栏函数 dispatch_barrier_async，使用栅栏函数 可以实现线程的多读单写！ ​​​​​​NSOpearion： NSOperatoin是对GCD更高层次的封装 NSOperation可以设置两个操作之间的依赖关系。 NSOperation是个抽象类，开发中使用它的两个子类，NSBlockOperation&#x2F;NSInvocationOperation。 使用KVO，观察NSOperation的各种状态（isExecuted是否正在执行，isFinished是否结束，isCancled是否取消）。无法判断GCD的状态。 NSOperation可以设置操作的优先级。 NSoperation可以方便的取消一个操作的执行 可以重写NSOperation的main和start函数。 dispatch_once 是怎么保证线程安全的？定义一个dispatch_once_t的静态变量，标识下面的diapatch_once的block是否执行过了，static修饰会默认将 onceToken其初始化为0，当值为0时才会 执行block代码块 里面的内容，此时onceToken不为0，当block执行完成，底层会将oneceToken设置为-1，以后再调用的话不会再走block代码块。 dispatch_after延迟执行，执行时间是准确的吗？dispatch_after的延迟执行时间不是准确的，因为dispatch_after是在指定时间之后将任务添加到主队列，并不是在指定时间之后开始执行处理！ 说说你对 dispatch_apply 的理解？ dispatch_apply 是GCD提供的一种 快速迭代的函数，按照指定的次数将指定的任务追加到指定的队列中，并等待全部任务结束。 如果用在串行队列，就和for循环一样，按顺序同步执行。 如果用在并发队列，追加到队列的任务会异步执行，并且等待全部任务结束！ 说说你对dispatch_group的理解？ GCD提供的队列组，有两种使用方式 dispatch_group_async 和 dispatch_group_enter/dispatch_group_leave，使用过程中要根据任务类型选择使用哪种方式。 如果任务类型是同步任务：使用 dispatch_group_async 和 dispatch_group_enter/dispatch_group_leave 是同样的，可以实现相同的功能。 如果任务类型是异步任务：比如（AF）网络请求，使用dispatch_group_async不能等到所有异步任务执行完成，就会去执行dispatch_group_notify中的代码，使用dispatch_group_enter&#x2F;dispatch_group_leave可以实现执行完添加的异步任务，最后执行dispatch_group_notify中的代码 如果你要实现这样一个功能，请求网络A和B,然后根据A&#x2F;B返回的内容去刷新页面，如果使用dispatch_group，那么只能使用 dispatch_grouo_enter/dispatch_grouo_leave！！！使用dispatch_group_async是不能实现这个功能的！ 说说你项目中的哪些功能使用了dispatch_semaphore_t，解决了什么问题？使用信号量 dispatch_semaphore_t 可以实现 异步任务的顺序执行（也就是 将异步任务转换为同步任务执行）不要阻塞主线程！。也是多线程加锁的一种实现方式，保证线程安全。 dispatch_semaphore_create(intptr_t value) 创建一个队列组，传入得值&gt;&#x3D;0，传入的值控制控制并发线程的数量！！！，如果我们传入2，那么就表示当前最多有两个线程同时执行。 dispatch_semaphore_signal(dispatch_semaphore_t dsema) 增加信号量，使信号量的值加1！ dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout) 等待当前线程，直到某个时间释放！！！ 说说你对NSOperation&#x2F;NSOperationQueue的使用和理解？ NSOperation&#x2F;NSOperationQueue 是系统提供的一套多线程实现方案。实际上NSOperation&#x2F;NSOperationQueue是基于GCD更高层次的封装，完全面向对象，比GCD简单易用，代码可读性更高。 使用步骤： 创建操作，将操作封装到NSOperation对象中,执行的顺序取决于操作之间的相对优先级，操作执行结束的顺序，取决于操作本身！ 创建队列 NSOperationQueue，将操作添加到队列中，一个队列中同时能并发执行的最大操作数由maxConcurrentOperationCount 决定，也就是一个操作队列中的操作是串行还是并发执行，由maxConcurrentOperationCount它决定！ maxConcurrentOperationCount &#x3D; -1，默认，并发执行 maxConcurrentOperationCount &#x3D; 1，串行执行 maxConcurrentOperationCount &#x3D; 3，并发执行 系统会将队列中的操作取出，在新线程中执行操作。 操作有几种状态 op1.isReady; 是否准备就绪 op1.isExecuting; 是否正在执行 op1.isCancelled; 是否已经取消 op1.isFinished; 是否执行完成 取消操作和队列 [op1 cancel]; 取消操作，实际上是标记isCancelled状态 [queue cancelAllOperations]; 取消队列 你是否在定义过NSOperation?自定义NSOperation可以通过重写main或者start方法。重写main方法，不需要管理操作的状态属性isExecuting和isFinished。重写start方法需要管理操作的状态属性。 【面试题】：如果在工作中有这样一个需求，使用AFNetworking请求A接口拿到A接口返回的id_a，用id_a作为参数去请求B接口，拿到B网络返回的name_b去查数据库，然后刷新页面。该怎么实现呢？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@property (nonatomic, assign) dispatch_semaphore_t semaphore;@property (nonatomic, assign) dispatch_queue_t queue; - (void)viewDidLoad&#123; [super viewDidLoad]; //：测试 [self semaphoreSync];&#125; - (void)semaphoreSync&#123; // 创建信号量，传入参数0 self.semaphore = dispatch_semaphore_create(0); // 创建队列，这里串行和并发并无区别 self.queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_SERIAL); // 开启一个新线程， // 这里之所以要创建一个新线程，而不是在当前（主线程）执行，是因为，AF的网络请求返回默认是在主线程中执行，如果我们在当前线程执行一下操作，会发生线程死锁的现象， dispatch_async(self.queue, ^&#123; // 任务A int ida = [self requestA]; // 任务B NSString *name = [self requestB:ida]; // 任务C NSDictionary *res = [self queryDB:name]; NSLog(@&quot;%@&quot;, res); dispatch_async(dispatch_get_main_queue(), ^&#123; // 刷新页面 &#125;); &#125;);&#125; - (int)requestA&#123; __block int ida = 0; // AF NSArray *paths = @[@(self.currentPage), @(pageNum), @(100)]; [[ZJNetWorkManager shareManager] GetWithUrlString:TC_API(GetCourseList) paths:paths successedBlock:^(BOOL successed, id _Nonnull jsonObject) &#123; ida = 1; // 释放信号量，信号量加1，释放当前线程，然后执行return操作 dispatch_semaphore_signal(self.semaphore); &#125; failedBlock:^(NSError * _Nonnull error) &#123; dispatch_semaphore_signal(self.semaphore); &#125;]; // 信号量减1，阻塞当前线程 dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER); return ida;&#125; - (NSString *)requestB:(int)ida&#123; __block NSString *name; NSArray *paths = @[@(self.currentPage), @(pageNum), @(100), @(ida)]; [[ZJNetWorkManager shareManager] GetWithUrlString:TC_API(GetCourseList) paths:paths successedBlock:^(BOOL successed, id _Nonnull jsonObject) &#123; name = @&quot;你好👋&quot;; dispatch_semaphore_signal(self.semaphore); &#125; failedBlock:^(NSError * _Nonnull error) &#123; dispatch_semaphore_signal(self.semaphore); &#125;]; dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER); return name;&#125; - (NSDictionary *)queryDB:(NSString *)name&#123; //查询数据库，返回结果 return @&#123;@&quot;name&quot;:@&quot;name&quot;&#125;;&#125; 【面试题】根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？dispatch_group_t + dispatch_group_enter + dispatch_group_leave + dispatch_group_notify 【面试题】请实现一个多读单写的功能？我们可以用 dispatch_barrier_async 实现 12345678910111213141516171819202122232425262728293031323334353637383940@interface TKReadWhiteSafeDic() &#123; // 定义一个并发队列 dispatch_queue_t concurrent_queue; // 用户数据中心, 可能多个线程需要数据访问 NSMutableDictionary *userCenterDic;&#125;@end// 多读单写模型@implementation TKReadWhiteSafeDic- (id)init &#123; self = [super init]; if (self) &#123; // 通过宏定义 DISPATCH_QUEUE_CONCURRENT 创建一个并发队列 concurrent_queue = dispatch_queue_create(&quot;read_write_queue&quot;, DISPATCH_QUEUE_CONCURRENT); // 创建数据容器 userCenterDic = [NSMutableDictionary dictionary]; &#125; return self;&#125;- (id)objectForKey:(NSString *)key &#123; __block id obj; // 同步读取指定数据 dispatch_sync(concurrent_queue, ^&#123; obj = [userCenterDic objectForKey:key]; &#125;); return obj;&#125;- (void)setObject:(id)obj forKey:(NSString *)key &#123; // 异步栅栏调用设置数据 dispatch_barrier_async(concurrent_queue, ^&#123; [userCenterDic setObject:obj forKey:key]; &#125;);&#125; 读操作为啥同步dispatch_sync 读的话通常都是直接想要结果，需要同步返回结果，如果是异步获取的话就根网络请求一样了。 写操作为啥异步dispatch_barrier_async 写操作是因为不需要等待写操作完成，所以用异步。","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-面试题","slug":"OC-面试题","permalink":"https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"Swift学习43：继承","slug":"Swift课程/Swift学习43：继承","date":"2023-03-09T12:33:59.000Z","updated":"2023-03-14T19:12:59.310Z","comments":true,"path":"2023/03/09/Swift课程/Swift学习43：继承/","link":"","permalink":"https://www.bboyzj.cn/2023/03/09/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A043%EF%BC%9A%E7%BB%A7%E6%89%BF/","excerpt":"","text":"前言 swift中，只有类支持继承 swift中 类没有统一的基类。 没有继承任何父类的类是基类，但其实它是有一个父类的，叫 _SwiftObject 被 final 修饰的 属性、方法、下标 禁止被 重写，禁止被 继承 定义基类 不继承任何类的类是 基类 没有指定特定的父类的类都以基类的形式创建 示例 1234567// 基类class Person &#123; var name: String = &quot;ZJ&quot; func test() &#123; print(&quot;hello&quot;) &#125;&#125; 子类 子类 是基于 父类 创建的新类 子类写在父类前面，用 : 分割 123class Teacher: Person &#123;&#125; 重写 子类可以定义自己的 属性、方法、下标 及其他的特征，可一级从 父类继承，就是所谓的 重写 子类可以 继承 父类的 属性、方法、下标，前面加 override 关键字 12345678910111213141516171819// 基类class Person &#123; var name: String = &quot;ZJ&quot; var desc: String&#123; return name &#125;&#125;// 子类class Student: Person &#123; // 重写 override var desc: String&#123; return super.desc + &quot;hello&quot; &#125;&#125;let s = Student()print(s.desc)=====ZJ hello 访问父类的 属性、方法、下标 通过使用 super 前缀访问父类的、属性、方法、下标脚本 super.someMethod() 重写父类的方法super.someProperty 重写父类的属性super[someIndex] 重写父类的下标脚本 重写方法12345678910111213141516171819// 父类class Person &#123; // 实例方法 func test() &#123; &#125;&#125;// 子类 Teacher 继承 Person 父类class Teacher: Person &#123; // 子类重写父类的 test() 方法，用 override 关键字 override func test() &#123; print(&quot;呜呼！&quot;) &#125;&#125;let t = Teacher()t.test()======呜呼！ 重写属性的getter和setter方法可以自定义一个gett或setter来重写父类继承的属性 123456789101112131415class Person &#123; var desc: String = &quot;ZJ&quot;&#125;class Teacher: Person &#123; var age: Int = 0 override var desc: String &#123; return super.desc + &quot;is \\(age)&quot; &#125;&#125;let t = Teacher()age = 32print(t.desc)======ZJ is 32 重写属性观察器 可以为继承的属性添加属性观察器 不可以为继承的 常量存储属性 或 只读的计算属性 添加属性观察器 不能为同一个属性同时提供重写 setter和属性观察器 禁止重写 可以用 final 关键字禁止被 继承 禁止继承属性： final var（变量属性）、final let（常量属性） 禁止继承方法：final func（实例方法）、final class（类方法）、 禁止继承下标：final subscribe（下标）","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习：swift中方法的调用","slug":"Swift/Swift学习：swift中方法的调用","date":"2023-03-09T08:29:57.000Z","updated":"2023-03-09T08:29:57.676Z","comments":true,"path":"2023/03/09/Swift/Swift学习：swift中方法的调用/","link":"","permalink":"https://www.bboyzj.cn/2023/03/09/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"性能优化03：Crash检测和优化方案","slug":"OC性能优化/性能优化03：Crash检测和优化方案","date":"2023-03-08T21:32:04.000Z","updated":"2023-03-09T19:15:28.122Z","comments":true,"path":"2023/03/09/OC性能优化/性能优化03：Crash检测和优化方案/","link":"","permalink":"https://www.bboyzj.cn/2023/03/09/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603%EF%BC%9ACrash%E6%A3%80%E6%B5%8B%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/","excerpt":"","text":"前言Crash原因Crash原因和解决 找不到方法的实现 unrecognized selector sent to instance 原因：找不到方法iOS系统抛出异常崩溃 解决方案：给NSObject添加一个分类，实现消息转发的几个方法 KVC造成的crash 原因：给不存在的key（包括key为nil）设置value 解决方法： 如果属性存在，利用iOS的反射机制来规避，NSStringFromSelector(@selector())将SEL反射为字符串作为key。这样在@selector()中传入方法名的过程中，编译器会有合法性检查，如果方法不存在或未实现会报黄色警告。 重写类的setValue:forUndefinedKey:和valueForUndefinedKey: KVO引起的崩溃 原因：添加了观察者，没有在正确的时机移除 解决方案：addObserver和removeObserver一定要成对出现 集合类相关崩溃 原因：越界、添加nil、越界、添加nil 解决方案： 给集合类添加category重写原来的方法，在内部做判段使用Runtime把原来的方法替换成自定义的安全方法 多线程中的崩溃 原因:子线程中更新UI 解决方案：主线程更新UI Crash收集检测方式 第三方框架：Bugly iTunes Store收集：上传App Store的app，苹果有帮我们收集，Xcode-&gt;Windows-&gt;Organizer NSSetUncaughtExceptionHandler：iOS SDK 中提供了一个现成的函数 优化方案","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习13：上传App Store所需各图标和图片尺寸","slug":"OC学习/OC学习13：上传App-Store所需各图标和图片尺寸","date":"2023-03-08T19:13:37.000Z","updated":"2023-03-08T20:50:44.306Z","comments":true,"path":"2023/03/09/OC学习/OC学习13：上传App-Store所需各图标和图片尺寸/","link":"","permalink":"https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A013%EF%BC%9A%E4%B8%8A%E4%BC%A0App-Store%E6%89%80%E9%9C%80%E5%90%84%E5%9B%BE%E6%A0%87%E5%92%8C%E5%9B%BE%E7%89%87%E5%B0%BA%E5%AF%B8/","excerpt":"","text":"App Icon 图标尺寸 型号 分辨率（pt） 像素（px） 图片后缀 iPhone 20 40x40 2x iPhone 20 60x60 3x iPhone 29 58x58 2x iPhone 29 87x87 3x iPhone 40 80x80 2x iPhone 40 120x120 3x iPhone 60 120x120 2x iPhone 60 180x180 2x iPad 20 20x20 1x iPad 20 40x40 2x iPad 29 29x29 1x iPad 29 58x58 2x iPad 40 40x40 1x iPad 40 80x80 2x iPad 76 76x76 1x iPad 76 152x152 2x iPad 83.5 167x167 2x App Store 1024 1024x1024 1x App Store 引导页图片尺寸 屏幕大小（英寸） 像素（px） 5.5 886x1920 6.5 1080x1920 12.9 1200x1600","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习12：HTTP状态码大全","slug":"OC学习/OC学习12：HTTP状态码大全","date":"2023-03-08T19:12:49.000Z","updated":"2023-03-08T21:20:21.570Z","comments":true,"path":"2023/03/09/OC学习/OC学习12：HTTP状态码大全/","link":"","permalink":"https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A012%EF%BC%9AHTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E5%85%A8/","excerpt":"","text":"前言HTTP状态码（HTTP Status Code）是用来表示网页服务器HTTP响应状态的3位数字代码。 类型所有状态码的第一个数字代表了响应的五种状态之一，其分类如下： 状态码 描述 1xx 信息，表示临时响应并需要请求者继续执行操作 2xx 成功，操作被成功接收并处理 3xx 表示要完成请求，需要进一步操作。通常这些代码用来重定向 4xx 客户端错误，请求包含语法错误或无法完成请求 5xx 这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错 状态码详解 1xx： 100：（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101：（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 102：由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。 2xx： 200：（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201：（已创建） 请求成功并且服务器创建了新的资源。 202：（已接受） 服务器已接受请求，但尚未处理。 203：（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204：（无内容） 服务器成功处理了请求，但没有返回任何内容。 205：（重置内容） 服务器成功处理了请求，但没有返回任何内容。 206：（部分内容） 服务器成功处理了部分 GET 请求。 208：（已经报告）一个DAV的绑定成员被前一个请求枚举，并且没有被再一次包括。 226：（IM Used）服务器已经满足了请求所要的资源，并且响应是一个或者多个实例操作应用于当前实 3xx： 300：（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301：（永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302：（临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303：（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304：（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305：（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307：（临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx： 400:（错误请求) 服务器不理解请求的语法。 401：(未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 402：该状态码是为了将来可能的需求而预留的。 403：（禁止) 服务器拒绝请求。 404：（未找到) 服务器找不到请求的网页。 405：（方法禁用) 禁用请求中指定的方法。 406：（不接受) 无法使用请求的内容特性响应请求的网页。 407：（需要代理授权) 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408：（请求超时) 服务器等候请求时发生超时。 409：（冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410：（已删除) 如果请求的资源已永久删除，服务器就会返回此响应。 411：（需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。 412：（未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。 413：（请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414：（请求的 URI 过长) 请求的 URI（通常为网址）过长，服务器无法处理。 415：（不支持的媒体类型) 请求的格式不受请求页面的支持。 416：（请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417：（未满足期望值) 服务器未满足”期望”请求标头字段的要求。 418：（我是一个茶壶）这个代码是在1998年作为传统的IETF April Fools‘ jokes被定义的在RFC2324，超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现。RFC指定了这个代码应该是由茶罐返回给速溶咖啡。 419：（认证超时）并不是HTTP标注的一部分，419认证超时表示以前的有效证明已经失效了。同时也被用于401未认证的替代选择为了从其它被拒绝访问的已认证客户端中指定服务器的资源。 420：（方法失效）不是HTTP的标准，但是被Spring定义在HTTP状态类中当方法失时使用。这个状态码已经不推荐在Spring中使用。 420：（提高你的耐心）也不是HTTP标准的一部分，但是被版本1的Twitter搜索和趋势APi返回当客户端的速率被限制的时候。其它的服务提供商可能会使用429太多的请求响应码来代替。 421：从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422：请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV） 424：由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV） 425：在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。 426：客户端应当切换到TLS&#x2F;1.0。（RFC 2817） 428：(需要前置条件)原始服务器需要有条件的请求。当客户端GET一个资源的状态的时候，同时又PUT回给服务器，与此同时第三方修改状态到服务器上的时候，为了避免丢失更新的问题发生将会导致冲突。 429：（过多请求）用户已经发送了太多的请求在指定的时间里。用于限制速率。 431：（请求头部字段太大）服务器由于一个单独的请求头部字段或者是全部的字段太大而不愿意处理请求。 440：（登陆超时（微软））一个微软的扩展，意味着你的会话已经超时。 444：（无响应）被使用在Nginx的日志中表明服务器没有返回信息给客户端并且关闭了连接（在威慑恶意软件的时候比较有用）。 449：（重试（微软））一个微软的扩展。请求应该在执行适当的动作之后被重试。 450：（被Windows家长控制阻塞（微软））一个微软的扩展。这个错误是当Windows家长控制打开并且阻塞指定网页的访问的时候被指定。 451：（由于法律原因而无效（因特网草稿））被定义在因特网草稿“一个新的HTTP状态码用于法律限制的资源”。被用于当资源的访问由于法律原因被禁止的时候。例如检查制度或者是政府强制要求禁止访问。一个例子是1953年dystopian的小说Fahrenheit 451就是一个非法的资源。 451：（重定向（微软））被用在Exchange ActiveSync中如果一个更有效的服务器能够被使用或者是服务器不能访问用户的邮箱。客户端会假定重新执行HTTP自动发现协议去寻找更适合的服务器。 494：（请求头太大（Nginx））Nginx内置代码和431类似，但是是被更早地引入在版本0.9.4（在2011年1月21日）。 495：（证书错误（Nginx））Nginx内置的代码，当使用SSL客户端证书的时候错误会出现为了在日志错误中区分它和4XX和一个错误页面的重定向。。 496：（没有证书（Nginx））Nginx内置的代码，当客户端不能提供证书在日志中分辨4XX和一个错误页面的重定向。 497：（HTTP到HTTPS（Nginx））Nginx内置的代码，被用于原始的HTTP的请求发送给HTTPS端口去分辨4XX在日志中和一个错误页面的重定向。 498：（令牌超时或失效（Esri））由ArcGIS for Server返回。这个代码意味着令牌的超时或者是失效。 499：（客户端关闭请求（Nginx））被用在Nginx日志去表明一个连接已经被客户端关闭当服务器仍然正在处理它的请求，是的服务器无法返货状态码。 499：（需要令牌（Esri））由ArcGIS for Server返回。意味着需要一个令牌（如果没有令牌被提交）。 5xx： 500：（服务器内部错误） 服务器遇到错误，无法完成请求。 501：（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502：（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503：（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504：（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505：（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 506：由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。 507：服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918) 508：（发现环路）服务器发现了一个无限的循环档处理请求的时候。 509：服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。 510：获取资源所需要的策略并没有没满足。（RFC 2774）。 511：（需要网络授权）客户端需要授权去火的网络的访问权限。一般用于代理交互中被用来进行网络的访问控制。 520：（未知错误）这个状态码也没有被指定在任何RFC中，并且只会被一些服务器返回，例如微软的Azure和CloudFlare服务器:”520错误。本质上是一个捕获全部的响应当原始服务器返回一些未知的或者一些不能被忍受或者被解释的(协议违反或者空响应)”。 598：（网络读取超时异常(未知)）这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络读取超时在一个客户端之前的代理的后面。 599：（网络连接超时异常(未知)）这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络连接超时在一个客户端之前的代理的后面。","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习11：Xcode 常用的快捷键大全","slug":"OC学习/OC学习11：Xcode-常用的快捷键大全","date":"2023-03-08T19:12:11.000Z","updated":"2023-03-08T20:26:04.054Z","comments":true,"path":"2023/03/09/OC学习/OC学习11：Xcode-常用的快捷键大全/","link":"","permalink":"https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A011%EF%BC%9AXcode-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/","excerpt":"","text":"通用快捷键 Command + A ：全选Command + C ：复制Command + V ：粘贴Command + X ：剪切Command + Z ：撤销Command + Shift + Z ： 撤销刚才的撤销 文件快捷键 Command + S ：保存Command + Shift + S ：另存为 项目快捷键 Command + Shift + N ：新建项目Command + N ：新建文件Command + O ：打开文件Command + D ：快速复制一段代码Optional + 单击 ：显示描述文件Command + 单击：跳转函数Command + Optional + 上&#x2F;下箭头 ：快速切换.h和.m文件 Command + 0 ：显示&#x2F;隐藏导航器面板Command + Optional + 0 ：显示&#x2F;隐藏工具面板Command + Shift + o ：快速搜索 注释快捷键 Command + Optional + &#x2F; ：快速注释Command + &#x2F; ：单行注释 折叠&#x2F;展开快捷键 Command + Optional + 左箭头 ：折叠代码Command + Optional + 右箭头 ：展开代码 文字快捷键 Command + - ：缩小文字Command + + ：放大文字 调试运行、停止 Command + B ：编译Command + R ：运行Command + . ：停止Command + Shift + K ：清理 移动代码块 Command + [ ：左移代码块Command + ] ：右移代码块 Command + Optional + [ ：上移代码块Command + Optional + ] ：下移代码块 移动光标快捷键 Command + 左&#x2F;右箭头 ：将光标移动至行首&#x2F;尾Command + 上&#x2F;下箭头 ：将光标移动至文档行首&#x2F;尾 Command + Shift + 左&#x2F;右箭头 ：向左&#x2F;右选择一个单词 Command + Shift + 左&#x2F;右箭头 ：选择到行首&#x2F;尾 调试快捷键 Command + \\ ：设置&#x2F;取消断点 窗口快捷键 Command + H ：隐藏Command + M ：最小化Command + P ：打印Command + Q ：退出项目Command + W ：关闭当前文件 窗口切换快捷键 Command + Tab ：程序间切换Command + ~ ：窗口间切换 屏幕快捷键 Command + Shift + F3 ：截图整个屏幕Command + Shift + F4 ：截取指定区域 系统快捷键 Command + Optional + ESC ：强制退出程序Command + Space ：切换语言Command + Shift + ？：帮助 编辑快捷键 Command + Delete ：删除Command + Shift + Delete ：清空垃圾桶Command + Shift + A ：打开应用程序目录Command + Shift + C ：打开 Computer 目录Command + Shift + H ：打开 Home 目录","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习10：iPhone各系列尺寸大全","slug":"OC学习/OC学习10：iPhone各系列尺寸大全","date":"2023-03-08T19:11:14.000Z","updated":"2023-03-08T21:07:28.498Z","comments":true,"path":"2023/03/09/OC学习/OC学习10：iPhone各系列尺寸大全/","link":"","permalink":"https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A010%EF%BC%9AiPhone%E5%90%84%E7%B3%BB%E5%88%97%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%85%A8/","excerpt":"","text":"iPhone手机尺寸大全 机型 屏幕尺寸 （英寸） 分辨率（pt） 像素（px） 图片后缀 安全区域（上&#x2F;下） iPhone4&#x2F;4s 3.5 320x480 640x960 @2x iPhone5&#x2F;5c&#x2F;5s&#x2F;SE 4 320x568 640x1136 @2x iPhone6&#x2F;6s&#x2F;7&#x2F;8 4.7 375x667 750x1334 @2x iPhone6&#x2F;6s&#x2F;7&#x2F;8 Plus 5.5 414x736 1080x1920 @3x iPhoneX&#x2F;iPhoneXS&#x2F;11Pro 5.8 375x812 1125x2436 @3x 44&#x2F;34 iPhoneXR&#x2F;11 6.1 414x896 828x1792 @2x 48&#x2F;34 iPhoneXSMax&#x2F;11ProMax 6.5 414x896 1242x2688 @3x 47&#x2F;34 iPhone12mini（&gt;&#x3D;iOS14） iPhone13mini（&gt;&#x3D;iOS15） 5.4 360x780 1080x2340 @3x 47&#x2F;34 iPhone12&#x2F;12Pro iPhone13&#x2F;13Pro 6.1 390x844 1170x2532 @3x 47&#x2F;34 iPhone12&#x2F;13ProMax 6.7 428x926 1284x2778 @3x 47&#x2F;34 iPhone14 （&gt;&#x3D;iOS16） 6.1 390x844 1170x2532 @3x 47&#x2F;34 iPhone14 Plus 6.7 428x926 1284x2778 @3x 47&#x2F;34 iPhone14 Pro 6.1 393x852 1179x2556 @3x 59&#x2F;34 iPhone14 Pro Max 6.7 430x932 1290x2796 @3x 59&#x2F;34","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习12：修改项目名称","slug":"OC学习/OC学习08：修改项目名称的流程","date":"2023-03-08T12:20:10.000Z","updated":"2023-03-12T16:49:06.467Z","comments":true,"path":"2023/03/08/OC学习/OC学习08：修改项目名称的流程/","link":"","permalink":"https://www.bboyzj.cn/2023/03/08/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A008%EF%BC%9A%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E7%9A%84%E6%B5%81%E7%A8%8B/","excerpt":"","text":"前言 如果我们在项目中集成三方库 SDwebImage 时，报错 Framework not found Pods_________，说明 工程名称用汉字了，这个时候就需要更改项目名 在开发过程中需求想更改项目名 修改名称Xcode 修改 工程名 打开 Xcode 的 Show the File Inspector，修改 Name 为 FirstFrameDemo 修改成 FirstFrameDemo 之后，回车， 这里 Xcode 列举了可以为我们做的更改的名称 点击 Rename -&gt; OK，Xcode 为我们重命名了一部分。 关闭项目工程，修改项目文件夹名称（由原工程名 -&gt; 修改成新的工程名） 修改前： 修改后： 修改项目文件名（右击选择包内容） 点击 project.phxproj 文件，将 获取视频的第一帧 替换成 FirstFrameDemo ，全部替换 All -&gt; Done 打开项目 FirstFrameDemo.xcworkspace ，项目内全局替换 获取视频的第一帧 -&gt; FirstFrameDemo 修改 Podfile 文件中项目名称 打开终端，切换到当前项目目录下，执行 pos intall 删除旧的 workspace 文件 至此项目名已经完全修改完成了","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习11：Pch文件","slug":"OC学习/OC学习09：Pch文件","date":"2023-03-08T11:43:38.000Z","updated":"2023-03-08T18:54:39.914Z","comments":true,"path":"2023/03/08/OC学习/OC学习09：Pch文件/","link":"","permalink":"https://www.bboyzj.cn/2023/03/08/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A009%EF%BC%9APch%E6%96%87%E4%BB%B6/","excerpt":"","text":"","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习10：UITableViw点击事件和页面上的手势冲突怎么解决？","slug":"OC学习/OC学习07：UITableViw点击事件和页面上的手势冲突怎么解决？","date":"2023-03-07T11:17:26.000Z","updated":"2023-03-08T11:41:42.465Z","comments":true,"path":"2023/03/07/OC学习/OC学习07：UITableViw点击事件和页面上的手势冲突怎么解决？/","link":"","permalink":"https://www.bboyzj.cn/2023/03/07/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A007%EF%BC%9AUITableViw%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%92%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/","excerpt":"","text":"举例说明下面以一个例子讲解 图中 superView 有两个 subView，分别是 testView 和 testBtn。我们在 superView 和 testView 都重载 touchsBegan:withEvent、touchsEnded:withEvent、 touchsMoved:withEvent、touchsCancelled:withEvent方法，并且在 superView 上添加单击手势 UITapGestureRecognizer，action名为tapAction，给testBtn绑定action名为testBtnClicked。 主要代码如下： SuperView 1234567891011121314151617181920212223242526- (void)initUI&#123; UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapAction)]; [self addGestureRecognizer:tap]; [self addSubview:self.testView]; [self addSubview:self.testBtn];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@&quot;=========&gt; superView touchs Began&quot;);&#125;- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@&quot;=========&gt; superView touchs Moved&quot;);&#125;- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@&quot;=========&gt; superView touchs Ended&quot;);&#125;- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@&quot;=========&gt; superView touchs Cancelled&quot;);&#125;- (void)tapAction &#123; NSLog(@&quot;=========&gt; single Tapped&quot;);&#125;- (void)clickBtn &#123; NSLog(@&quot;=========&gt; click btn&quot;);&#125; textView 12345678910111213//testView- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@&quot;=========&gt; testView touchs Began&quot;);&#125;- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@&quot;=========&gt; testView touchs Moved&quot;);&#125;- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@&quot;=========&gt; testView touchs Ended&quot;);&#125;- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@&quot;=========&gt; testView touchs Cancelled&quot;);&#125; 情景O：注释 手势 ，分别点击 superView 和 testView： 123452023-03-08 17:58:44.408166+0800 手势冲突[20427:1092257] =========&gt; superView touchs Began2023-03-08 17:58:44.544181+0800 手势冲突[20427:1092257] =========&gt; superView touchs Ended2023-03-08 17:58:54.666862+0800 手势冲突[20427:1092257] =========&gt; testView touchs Began2023-03-08 17:58:54.825938+0800 手势冲突[20427:1092257] =========&gt; testView touchs Ended 情景A：单击 superView ，输出结果： 1232023-03-08 17:32:44.983101+0800 手势冲突[20227:1064772] =========&gt; superView touchs Began2023-03-08 17:32:45.043310+0800 手势冲突[20227:1064772] =========&gt; single Tapped2023-03-08 17:32:45.043538+0800 手势冲突[20227:1064772] =========&gt; superView touchs Cancelled 情景B：单击 testView，输出结果： 1232023-03-08 17:43:16.370199+0800 手势冲突[20326:1077469] =========&gt; testView touchs Began2023-03-08 17:43:16.430723+0800 手势冲突[20326:1077469] =========&gt; single Tapped2023-03-08 17:43:16.430939+0800 手势冲突[20326:1077469] =========&gt; testView touchs Cancelled 情景C：单击 testBtn，输出结果： 12023-03-08 17:43:40.690096+0800 手势冲突[20326:1077469] =========&gt; click btn 情景D：按住 testView，过3秒后或更久释放，输出结果： 122023-03-08 17:43:50.678603+0800 手势冲突[20326:1077469] =========&gt; testView touchs Began2023-03-08 17:43:53.499119+0800 手势冲突[20326:1077469] =========&gt; testView touchs Ended 情景 O、A、B 分析开发文档可知： Gesture Recognizers Get the First Opportunity to Recognize a Touch. A window delays the delivery of touch objects to the view so that the gesture recognizer can analyze the touch first. During the delay, if the gesture recognizer recognizes a touch gesture, then the window never delivers the touch object to the view, and also cancels any touch objects it previously sent to the view that were part of that recognized sequence. Google翻译： 手势识别器获得识别触摸的第一个机会。 一个窗口延迟将触摸对象传递到视图，使得手势识别器可以首先分析触摸。 在延迟期间，如果手势识别器识别出触摸手势，则窗口不会将触摸对象传递到视图，并且还将先前发送到作为识别的序列的一部分的视图的任何触摸对象取消。 触摸事件首先传递到手势上，如果手势识别成功了，就会取消事件的继续传递，否则，事件还是会被响应链处理。系统维持了与响应链关联的所有手势，事件首先传递给手势，然后才传递给响应链。这样我们就解释A和B的场景了 情景 C 分析：iOS 开发文档里这样说： In iOS 6.0 and later, default control actions prevent overlapping gesture recognizer behavior. For example, the default action for a button is a single tap. If you have a single tap gesture recognizer attached to a button’s parent view, and the user taps the button, then the button’s action method receives the touch event instead of the gesture recognizer. This applies only to gesture recognition that overlaps the default action for a control, which includes: A single finger single tap on a UIButton, UISwitch, UISegmentedControl, UIStepper,and UIPageControl.A single finger swipe on the knob of a UISlider, in a direction parallel to the slider.A single finger pan gesture on the knob of a UISwitch, in a direction parallel to the switch. Google 翻译为： 在iOS 6.0及更高版本中，默认控制操作可防止重叠的手势识别器行为。 例如，按钮的默认操作是单击。 如果您有一个单击手势识别器附加到按钮的父视图，并且用户点击按钮，则按钮的动作方法接收触摸事件而不是手势识别器。 这仅适用于与控件的默认操作重叠的手势识别，其中包括： 单个手指单击UIButton，UISwitch，UISegmentedControl，UIStepper和UIPageControl.单个手指在UISlider的旋钮上滑动，在平行于滑块的方向上。在UISwitch的旋钮上的单个手指平移手势 与开关平行的方向。 因此，在情景C，点击testBtn的action，按钮获取了事件响应，不会把事件响应传递给父视图的supView 情景 C 分析： 长按testView已经不是单击事件了，tap手势就不会识别 实际开发中遇到的问题 父视图上先后添加了一个 UIGestureRecognizer 和一个 UITableView 我们发现在点击 UITableView 的 cell 的时候，并没有触发 -(void)tableView:(UITableView*)tableView didSelectRowAtIndexPath:(NSIndexPath*)indexPath; 方法。 分析由于 cell 继承 cell -&gt; UIView -&gt; UIResponder，是可以接收和处理事件的，但是添加了 tap 后会导致 cell 响应链无法正常响应，导致 手势冲突 解决方法在我们点击 cell 的时候，不让父视图的 手势 干扰子视图cell的点击事件或者说响应链正常传递，一般会重写 UIGestureRecognizerDelegate 中的 - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch方法。 12345678910111213- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch&#123; // 如果是UITableViewCell类或子类响应事件 if ([touch.view isKindOfClass:[UITableViewCell class]]) &#123; return YES; &#125; //默认都需要响应 return NO;&#125;=========2023-03-08 18:19:39.851593+0800 手势冲突[20552:1111844] -[ParentV tableView:didSelectRowAtIndexPath:]2023-03-08 18:19:40.583123+0800 手势冲突[20552:1111844] -[ParentV tableView:didSelectRowAtIndexPath:]...","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习06：截取视频文件第一帧的方法有哪些？","slug":"OC学习/OC学习06：截取视频文件第一帧的方法有哪些？","date":"2023-03-07T11:16:39.000Z","updated":"2023-03-08T18:53:13.543Z","comments":true,"path":"2023/03/07/OC学习/OC学习06：截取视频文件第一帧的方法有哪些？/","link":"","permalink":"https://www.bboyzj.cn/2023/03/07/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A006%EF%BC%9A%E6%88%AA%E5%8F%96%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E7%AC%AC%E4%B8%80%E5%B8%A7%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/","excerpt":"","text":"前言iOS 中获取视频第一帧有两种方式 第一种：使用AVFoundation获取将耗时的操作放在异步执行队列 dispatch_async，防止造成线程堵塞，刷新UI放在 主线程 123456789101112- (UIImage *)getFirstFrameFromVideoWithUrl:(NSURL *)url&#123; AVURLAsset *asset = [[AVURLAsset alloc] initWithURL:url options:nil]; AVAssetImageGenerator *assetGennerator = [[AVAssetImageGenerator alloc] initWithAsset:asset]; assetGennerator.appliesPreferredTrackTransform = YES; CMTime time = CMTimeMakeWithSeconds(0.0, 600); CMTime actualTime; NSError *error = nil; CGImageRef image = [assetGennerator copyCGImageAtTime:time actualTime:&amp;actualTime error:&amp;error]; UIImage *videoImg = [[UIImage alloc] initWithCGImage:image]; CGImageRelease(image); return videoImg;&#125; 第二种方式：使用SDWebImage获取，并缓存图片123456789101112131415161718192021222324252627282930313233343536373839404142- (void)method2&#123; NSURL *url = [NSURL URLWithString:@&quot;https://klxxcdn.oss-cn-hangzhou.aliyuncs.com/histudy/hrm/media/bg1.mp4&quot;]; NSString *urlKey = url.absoluteString; // 先从缓存中查找是否有图片 SDImageCache *imgCache = [SDImageCache sharedImageCache]; UIImage *memoryImg = [imgCache imageFromCacheForKey:urlKey]; if (memoryImg) &#123; self.imgV.image = memoryImg; &#125;else &#123; // 从磁盘中查找是否有图片 UIImage *diskImg = [imgCache imageFromDiskCacheForKey:urlKey]; if (diskImg) &#123; self.imgV.image = diskImg; &#125;else &#123; // 如果都不存在 // 开启异步线程下载图片 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; AVURLAsset *asset = [[AVURLAsset alloc] initWithURL:url options:nil]; NSParameterAssert(asset); AVAssetImageGenerator *assetGenerator = [[AVAssetImageGenerator alloc] initWithAsset:asset]; assetGenerator.appliesPreferredTrackTransform = YES; assetGenerator.apertureMode = AVAssetImageGeneratorApertureModeEncodedPixels; CGImageRef thumbImgRef = NULL; CFTimeInterval thumbImgTime = 1; NSError *thumbImgError = nil; thumbImgRef = [assetGenerator copyCGImageAtTime:CMTimeMake(thumbImgTime, 60) actualTime:NULL error:&amp;thumbImgError]; if (!thumbImgRef)&#123; NSLog(@&quot;thumbImgError:%@&quot;,thumbImgError); &#125; UIImage *thumbImg = thumbImgRef ? [[UIImage alloc] initWithCGImage:thumbImgRef] : nil; // 主线程显示UI dispatch_async(dispatch_get_main_queue(), ^&#123; SDImageCache *imgCache = [SDImageCache sharedImageCache]; [imgCache storeImage:thumbImg forKey:urlKey completion:^&#123; NSLog(@&quot;store Image success&quot;); &#125;]; self.imgV.image = thumbImg; &#125;); &#125;); &#125; &#125; &#125;","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习05：分类和扩展","slug":"OC学习/OC学习05：分类和扩展","date":"2023-03-06T13:50:50.000Z","updated":"2023-03-08T19:02:49.668Z","comments":true,"path":"2023/03/06/OC学习/OC学习05：分类和扩展/","link":"","permalink":"https://www.bboyzj.cn/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A005%EF%BC%9A%E5%88%86%E7%B1%BB%E5%92%8C%E6%89%A9%E5%B1%95/","excerpt":"","text":"分类 Category Category 的主要作用是为 已经存在的类添加(扩展)方法 已存在的类可以是 系统的类 或 自定义的类 不能定义 变量（成员变量或实例变量） 一般情况下也可以定义 属性，但是 不会实现 它的 set 和 get 方法，需要利用 runtime 机制去实现它的 set 和 get 方法。 分类文件有 .h 和 .m 两个文件，文件名 @interface 类名 (分类名) 创建 系统 分类 command + n 点击 Objective-C File 创建完成后会生成 系统文件名+Category.h 和 系统文件名+Category.m 两个文件 在分类中可以添加 实例方法和类方法 123456789101112131415@interface UIViewController (Cate)- (void)sayHello;+ (void)sayBye;@end==============@implementation UIViewController (Cate)- (void)sayHello&#123; NSLog(@&quot;hello&quot;);&#125;+ (void)sayBye&#123; NSLog(@&quot;bye&quot;);&#125;@end 在本类中调用，需要引入头文件 文件名+Category.h 12345678 // 分类[self sayHello];[ViewController sayBye];======Category[30386:1690552] bye2023-03-06 22:06:37.369596+0800 Category[30386:1690552] hello2023-03-06 22:06:37.369794+0800 Category[30386:1690552] bye 自定义的类 添加 分类 创建方式类似 与系统类类似，在 class 中选择自定义的类 Person 可以在 分类中声明并实现 两个方法，在本类中调用 分类中声明并实现 123456789101112131415@interface Person (Category)- (void)sayHello;+ (void)sayBye;@end---------@implementation Person (Category)- (void)sayHello&#123; NSLog(@&quot;%s&quot;,__func__);&#125;+ (void)sayBye&#123; NSLog(@&quot;%s&quot;,__func__);&#125;@end 本类中调用，编译运行，查看打印结果 123456789101112131415@implementation Person- (instancetype)init&#123; self = [super init]; if (self) &#123; // 本类中调用分类添加的方法 [self sayHello]; [Person sayBye]; &#125; return self;&#125;@end============2023-03-07 08:14:34.439456+0800 Category[3555:114948] -[Person(Category) sayHello]2023-03-07 08:14:34.439626+0800 Category[3555:114948] +[Person(Category) sayBye] 那么问题来了，既然本类中可以调用，那么在其他类中是否也可以调用呢？ 其他类中调用 分类 方法1234567891011121314// 自定义的类#import &quot;Person.h&quot;#import &quot;Person+Category.h&quot;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // 自定义的类 Person * p = [[Person alloc] init]; [p sayHello]; [Person sayBye];&#125;========2023-03-07 08:19:57.913133+0800 Category[3631:119871] -[Person(Category) sayHello]2023-03-07 08:19:57.913667+0800 Category[3631:119871] +[Person(Category) sayBye] 由打印结果可知，在VC中时可以调用的 那么问题又来了，如果本类中和分类中均实现了 同样的方法 会调用哪个？ 分类和本类实现了同样的方法 在 Person 类中实现一个 sayHello 123- (void)sayHello&#123; NSLog(@&quot;%s&quot;,__func__);&#125; 在 VC 中调用 sayHello 123456// 自定义的类Person * p = [[Person alloc] init];[p sayHello];============2023-03-07 08:24:09.821814+0800 Category[3670:122944] -[Person(Category) sayHello] 由打印结果可知，调用的是 分类 的方法，由此我们可以推断，本类的方法被分类替代了 扩展 Extension 是类的一部分，在编译器和头文件里的@interface一级实现文件里的@implement一起形成一个完整的类，它伴随着类的产生而产生，亦随之一起消亡 作用 声明 私有属性、私有方法、私有成员变量，想要被访问 @public 扩展不能为系统类添加扩展（必须有一个类的源码才能添加一个类的Extension），所以你无法为系统的类添加Extension 成员变量和实例变量是 私有的，不能被外界访问， 属性可以被外界访问，由于没有实现调用会 carsh 方法可以被外界访问，由于没有实现set和get方法，访问会 carsh 扩展只有一个 .h 文件，因此 所有的都是没办法调用 使用 创建 Extension 自定义类中的代码 12345678910111213@interface Person : NSObject@end========#import &quot;Person.h&quot;#import &quot;Person+Extension.h&quot;@implementation Person- (void)sayHello&#123; NSLog(@&quot;%s hello&quot;,__func__);&#125;@end 在 #import &quot;Person+Ext.h&quot; 中实现如下代码 123456789@interface UIViewController ()&#123; NSString * name; @public int age;&#125;@property (nonatomic,copy)NSString * sex;- (void)sayHello;+ (void)sayBye;@end 在 VC 中调用 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; Person * p = [Person new]; // 调用报错或崩溃// p-&gt;age = 30;// p-&gt;name = &quot;ZJ&quot;;// p.sex = @&quot;男&quot;;// [Person sayBye]; [p sayHello];&#125;=======2023-03-06 22:35:02.277867+0800 Extension[30580:1704777] -[Person sayHello] hello 如果只有声明没有实现，则调用会 Crash 分类 和 扩展的区别 category 在运行时决议。extension 在编译时决议。所以扩展中的方法没有被实现编译器会报警告，分类中没有被实现编译器不会警告 分类原则上只能添加方法，不能添加属性（因为没有实现属性的seter和getter方法，可以通过runtime添加）。扩展能添加方法、实例变量，默认是@private类型的，且只能作用于自身类 分类有自己的实现部分。扩展没有实现部分，只能依托对应的类的实现部分。 分类可以为系统添加分类。扩展不能为系统添加分类。","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习04：JSON和XML数据解析","slug":"OC学习/OC学习04：JSON和XML数据解析","date":"2023-03-06T06:09:53.000Z","updated":"2023-03-07T12:01:51.659Z","comments":true,"path":"2023/03/06/OC学习/OC学习04：JSON和XML数据解析/","link":"","permalink":"https://www.bboyzj.cn/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A004%EF%BC%9AJSON%E5%92%8CXML%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/","excerpt":"","text":"前言 在 iOS 开发中，常见的数据传输格式有两种：JSON和XML。 服务器返回客户端的数据，一般都是 JSON格式或XML格式（文件下载除外） JSON 由于 体积小、传输快速 等优点，逐渐成为了 主流的数据传输格式。 JSON在 iOS 中，常见解析方案有以下几种： 第三方框架：JSONKit、SBJson、TouchJSON（性能从左到右，越来越差） 性能最好的是使用 苹果原生的框架： NSJSONSerialization JSON格式很像OC中的数组和字典，key必须用双引号 1&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:22&#125;、[&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:22&#125;,&#123;&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:22&#125;] JSON格式 JSON 转 OC 第一个参数：要解析的JSON数据，是NSData类型也就是二进制数据 第二个参数：解析JSON的可选配置参数 NSJSONReadingMutableContainers 解析出来的字典和数组是可变的 NSJSONReadingFragmentsAllowed 解析出来的对象中的字符串是可变的 NSJSONReadingMutableLeaves 被解析的数据如果既不是字典也不是数组，那么就使用这个 第三个参数：错误信息 1NSDictionary * dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&amp;error]; OC 转 JSON 第一个参数：要转换成JSON数据的OC对象，这里是一个字典 第二个参数：NSJSONWritingPrettyPrinted 对转换之后的JSON对象进行排版，无意义 第三个参数：错误信息 1NSData *data = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;error]; XML XML 可扩展标记语言，是一种数据交互格式，也叫XML文档 XML 被设计用来传输和存储数据 构成常见的XML文档由三部分组成 文档声明 在XML文档最前面，必须编写一个文档声明，用来声明XML文档的类型 12345// 最简单的声明&lt;?xml version=&quot;1.0&quot; ?&gt;// 用encoding属性说明文档的字符编码&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; 元素 一个元素包括了 开始标签和结束标签， 有内容的元素 &lt;name&gt;Tom&lt;/name&gt;；没内容的元素 &lt;from&gt;&lt;/from&gt;，可简写成 &lt;from/&gt; 元素可嵌套其他元素，不可出现交叉嵌套 属性 一个元素最多可以拥有多个属性，属性值必须用双引号 &quot; &quot; 或 单引号 &#39; &#39; 括住 示例 123456&lt;root&gt; &lt;person id=&quot;p1&quot;&gt; &lt;name&gt;Tom&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;/person&gt;&lt;/root&gt; XML 解析的方法要想从XML中提取信息，就得解析XML，目前针对XML的解析有两种方式： SAX：从根元素开始，按照顺序一个元素一个元素的往下解析，可用于解析大、小文件 DOM：一次性将整个XML文档加载到内存中，适合较小的文件 iOS 中解析 XML 有两种： 苹果原生：使用 NSXMLParse，SAX方式解析，使用简答 第三方框架：libxml2、GDataXML libxml2 纯 c 语音，默认包含在iOS SDK中，同时支持DOM和SAX方式解析 GDataXMLDOM 解析，由 google 基于 libxml2 开发 解析XML大文件建议用：NSXMLParse、libxml2解析XML小文件上述三种都可以 NSXMLParse 使用 添加NSXMLParserDelegate协议 获取XML文件，初始化NSXMLParser，并开启解析 实现协议中的方法 XMLElement 文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@interface XMLElement : NSObject// 元素名称@property (nonatomic,strong)NSString *name;//元素节点文本@property (nonatomic,strong)NSMutableString *text;@property (nonatomic,strong)NSDictionary *attribute;@property (nonatomic,strong)XMLElement *parent;@property (nonatomic,strong)NSMutableArray&lt;XMLElement *&gt; *childElement;@end🔽#import &quot;XMLElement.h&quot;@implementation XMLElement- (instancetype)init&#123; self = [super init]; if (self) &#123; _text=[[NSMutableString alloc]init]; &#125; return self;&#125;- (NSMutableArray&lt;XMLElement *&gt; *)childElement&#123; if (!_childElement) &#123; _childElement = [[NSMutableArray alloc]init]; &#125; return _childElement;&#125;- (NSString *)description&#123; NSDictionary *dic = [self convertToDic]; if ([NSJSONSerialization isValidJSONObject:dic]) &#123; NSError *error; NSData *jsonData=[NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;error]; if (error) &#123; return @&quot;&#123;&#125;&quot;; &#125; if (jsonData) &#123; @try &#123; NSString *jsonStr = [[NSString alloc]initWithData:jsonData encoding:NSUTF8StringEncoding]; return jsonStr; &#125; @catch (NSException *exception) &#123; &#125; &#125; &#125; return @&quot;&#123;&#125;&quot;; &#125;- (NSDictionary *)convertToDic&#123; NSMutableDictionary *dic = [[NSMutableDictionary alloc] init]; if (self.name) &#123; dic[self.name]=self.text; &#125; if (self.attribute &amp;&amp; self.attribute.count &gt; 0) &#123; [dic addEntriesFromDictionary:self.attribute]; &#125; if (self.childElement &amp;&amp; self.childElement.count &gt; 0) &#123; NSMutableArray *child=[[NSMutableArray alloc]init]; for (XMLElement *element in self.childElement) &#123; NSDictionary *childDic = [element convertToDic]; if (element.childElement &amp;&amp; element.childElement.count &gt; 0) &#123; [child addObject:childDic]; &#125;else&#123; [dic addEntriesFromDictionary:childDic]; &#125; &#125; if (child.count &gt; 0) &#123; dic[@&quot;child&quot;]=child; &#125; &#125; return dic;&#125;@end XMLParserManager 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#import &lt;Foundation/Foundation.h&gt;#import &quot;XMLElement.h&quot;NS_ASSUME_NONNULL_BEGINtypedef void(^ParserXMLCompletion) (BOOL success, XMLElement * _Nullable data,NSError * _Nullable error);@interface XMLParserManager : NSObject@property(nonatomic,copy)ParserXMLCompletion completion;- (void)parserXMLWithUrl:(NSURL *)url completion:(ParserXMLCompletion)completion;@end🔽#import &quot;XMLParserManager.h&quot;@interface XMLParserManager()&lt;NSXMLParserDelegate&gt;@property (nonatomic,strong)NSXMLParser *parser;@property (nonatomic,strong)XMLElement *rootElement;@property (nonatomic,strong)XMLElement *currentElement;@end@implementation XMLParserManager- (void)parserXMLWithUrl:(NSURL *)url completion:(ParserXMLCompletion)completion&#123; if (url) &#123; self.completion = completion; __weak typeof(self) weakSelf = self; NSInputStream *fileInput=[[NSInputStream alloc] initWithURL:url]; // 创建一个解析器 _parser = [[NSXMLParser alloc] initWithStream:fileInput]; // 设置代理 _parser.delegate = self; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^&#123; __strong typeof(weakSelf) strongSelf = weakSelf; // 开始解析 [strongSelf.parser parse]; // 解析错误 if (weakSelf.parser.parserError) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (completion) &#123; completion(NO,nil,strongSelf.parser.parserError); &#125; &#125;); &#125; &#125;); &#125;&#125;// 文档开始-(void)parserDidStartDocument:(NSXMLParser *)parser&#123; self.rootElement = nil; self.currentElement = nil;&#125;/* 开始解析某个节点 parser xml对象 elementName 标签 namespaceURI 命名控件指向的链接 qName 命名控件名称 attributeDict 节点的所有属性 */-(void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary&lt;NSString *,NSString *&gt; *)attributeDict&#123; if (!self.rootElement) &#123; self.rootElement = [[XMLElement alloc]init]; self.currentElement = self.rootElement; &#125;else&#123; XMLElement *element = [[XMLElement alloc]init]; // 父节点 element.parent = self.currentElement; // 当前元素的子节点 [self.currentElement.childElement addObject:element]; element.name = elementName; // 更换当前元素 self.currentElement = element; &#125; // 元素名和属性 self.currentElement.name = elementName; self.currentElement.attribute = attributeDict;&#125;// 当解析器找到开始标记和结束标记之间的字符时，调用这个方法解析当前节点的所有字符- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string&#123; // 获取当前元素的内容 [self.currentElement.text appendString:string];&#125;// 结束解析-(void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName&#123; self.currentElement = self.currentElement.parent;&#125;// 文档结束-(void)parserDidEndDocument:(NSXMLParser *)parser&#123; __weak typeof(self) weakSelf = self; if (self &amp;&amp; self.completion) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; __strong typeof(weakSelf) strongSelf = weakSelf; strongSelf.completion(YES, strongSelf.rootElement, nil); &#125;); &#125;&#125;// 解析失败- (void)parser:(NSXMLParser *)parser validationErrorOccurred:(NSError *)validationError&#123; if (self.completion) &#123; __weak typeof(self) weakSelf = self; dispatch_async(dispatch_get_main_queue(), ^&#123; __strong typeof(weakSelf) strongSelf = weakSelf; strongSelf.completion(NO, nil,validationError); &#125;); &#125;&#125;@end VC 调用 1234567891011121314151617181920212223242526272829303132#import &quot;ViewController.h&quot;#import &quot;XMLParserManager.h&quot;@interface ViewController ()@property (nonatomic,strong)XMLParserManager *manager;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; &#125;-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [self parserXML];&#125;-(void)parserXML&#123; NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;xmlText&quot; ofType:@&quot;xml&quot;]; NSURL *url = [NSURL fileURLWithPath:path]; _manager=[[XMLParserManager alloc]init]; [_manager parserXMLWithUrl:url completion:^(BOOL success, XMLElement * _Nullable data, NSError * _Nullable error) &#123; if (success) &#123; NSLog(@&quot;%@&quot;,data); &#125;else&#123; NSLog(@&quot;error = %@&quot;,error); &#125; &#125;]; NSLog(@&quot;start == &quot;); &#125;@end GDataXML 使用 GDataXMLDocument：xml解析入口 GdataXMLElement：保存查找的数据 GdataXMLNode：保存解析的数据 第一步：集成 GDataXML-HTML 123456789target &#x27;XML文件解析&#x27; do # Comment the next line if you don&#x27;t want to use dynamic frameworks use_frameworks! pod &#x27;GDataXML-HTML&#x27;, &#x27;~&gt; 1.4.1&#x27; # Pods for XML文件解析end 第二步：项目中配置 pod 安装 GDataXML 选中target -&gt; Build Settings -&gt; Link Binary With Libraried，搜索添加 libxml2 Header Search Paths 添加 /usr/include/libxml2 Other Linker Flags 添加 -lxml2 引入头文件使用 123456789101112131415161718- (void)GDataParserXML&#123; // 加载xmlwen文件 NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;xmlText&quot; ofType:@&quot;xml&quot;]; NSURL *url = [NSURL fileURLWithPath:path]; NSData *data = [NSData dataWithContentsOfURL:url]; NSError *error= nil; GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithData:data error:&amp;error]; // 拿到根元素，得到根元素下所有子孙元素 NSArray * elementList =[doc.rootElement elementsForName:@&quot;book&quot;]; for (GDataXMLElement *element in elementList) &#123; NSString *title=((GDataXMLElement *)[[element elementsForName:@&quot;title&quot;] firstObject]).stringValue; NSString *author=((GDataXMLElement *)[[element elementsForName:@&quot;author&quot;] firstObject]).stringValue; NSString *year=((GDataXMLElement *)[[element elementsForName:@&quot;year&quot;] firstObject]).stringValue; NSString *price=((GDataXMLElement *)[[element elementsForName:@&quot;price&quot;] firstObject]).stringValue; NSLog(@&quot;title = %@ author = %@ year = %@ price = %@&quot;,title,author,year,price); &#125;&#125;","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"Swift学习45：扩展","slug":"Swift课程/Swift学习45：扩展","date":"2023-03-05T09:05:03.000Z","updated":"2023-03-12T09:08:48.298Z","comments":true,"path":"2023/03/05/Swift课程/Swift学习45：扩展/","link":"","permalink":"https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A045%EF%BC%9A%E6%89%A9%E5%B1%95/","excerpt":"","text":"前言本篇将详细总结介绍Swift扩展的用法： 扩展就是 为现有的类、结构体、枚举类型或者协议类型添加新功能 扩展和 Objective-C 中的 category 类似，与 Objective-C 不同的是扩展 没有名字 extension 的能力 可以添加 计算型实例属性 和 计算型类型属性。 可以添加 实例方法和类型方法 可以添加 新的初始化器 可以添加 下标脚本 可以使现有的 类型遵循某协议 定义和使用 新内嵌类型 扩展 可以向一个类型添加新的方法，但是不能重写已有的方法 使用注意： 不可以添加 存储属性，也不可以为已有属性添加属性观察器 扩展中不能为 类 添加 新的构造器，因为 新的构造器和结构器 必须由原始的类来实现 添加计算属性 扩展 不可以添加存储型属性，也不可以为已有属性添加属性观察器 1234extension Double&#123; // 注意：扩展不能扩展存储型属性 // var km: Double = 0.0 //报错&#125; 扩展可以添加新的计算型属性 123456789101112131415extension Double &#123; // 注意：扩展不能添加存储属性 // var km: Double = 0.0 // 计算属性 var km: Double &#123; return self * 1_000.0&#125; var m: Double &#123; return self &#125; var cm: Double &#123; return self / 100.0 &#125; var mm: Double &#123; return self / 1_000.0 &#125; var ft: Double &#123; return self / 3.28084 &#125;&#125;let oneInch = 25.4print(&quot;one inch is \\(oneInch) meters&quot;)=====one inch is 25.4 meters 添加初始化器 扩展能为 已有的类型添加新的初始化器 扩展能为 类添加新的便捷初始化器，不能为类添加 指定初始化器或反初始化器，指定初始化器或反初始化器 必须由原来的类实现提供 123456789101112131415161718192021struct Size &#123; var width = 0.0, height = 0.0&#125;struct Point &#123; var x = 0.0,y = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size()&#125;extension Rect&#123; // 新的初始化器 init(center:Point, size:Size) &#123; let origin_x = center.x - size.width/2 let origin_y = center.y - size.height/2 // 新的初始化器必须调用指定初始化器 self.init(origin:Point(x: origin_x, y: origin_y),size:size) &#125;&#125;let rect3 = Rect(center: Point(x:200, y:200), size: Size(width: 100, height: 100)) 添加方法 扩展可以为 已有的类型 添加新的 实例方法和类方法 12345678910111213141516171819// 添加方法extension Int &#123; // 实例方法 func repetions(task: () -&gt; Void) &#123; for _ in 0..&lt;self &#123; task() &#125; &#125;&#125;3.repetions &#123; print(&quot;hello&quot;)&#125;======hellohellohello 添加异变方法 通过 mutationg 关键字，可以 修改(或异变)实例方法本身 struct 和 enum 在修改self或本身属性时必须标记实例方法为 mutating 1234567891011extension Int &#123; mutating func square() &#123; self = self * self &#125;&#125;var someInt = 3someInt.square()print(someInt)=======9 添加下标 扩展可以为已有类型添加新下标脚本。 被除数 ➗ 除数 &#x3D; 商 …. 余数示例：获取 12345 的第 3 位数推导过程：被除数 ➗ 10^位数次方 &#x3D; 商（前面的几位数）… 余数（剩下的几位数），如 12345 ➗ 10^3 &#x3D; 123 …. 45被除数 ➗ 10 &#x3D; 第 3 位数，123 ➗ 10 &#x3D; 12 …. 3 余数是3 123456789101112131415161718extension Int &#123; subscript(index: Int) -&gt; Int &#123; var base = 1 for i in 0..&lt;index &#123; base *= 10 &#125; return (self / base) % 10 &#125;&#125;print(746381295[0])print(746381295[1])print(746381295[2])=============592 添加内嵌类型 扩展可以为已有的 类、结构体和枚举添加新的内嵌类型。 1234567891011121314151617181920212223// 添加内嵌类型extension Int &#123; enum Kind &#123; // 负数 0 正数 case neg,zero,pos &#125; var kind: Kind &#123; switch self &#123; case 0: return .zero case let x where x &gt; 0: return .pos default: return .neg &#125; &#125;&#125;print(8.kind)print(0.kind)=======poszero 通过扩展集合类型Collection给的元素添加限制示例 123456789101112131415161718192021// 协议扩展添加约束条件extension Collection where Element: Equatable &#123; func allEqual() -&gt; Bool &#123; for element in self &#123; if element != self.first &#123; return false &#125; &#125; return true &#125;&#125;let equalNumbers = [100, 100, 100, 100, 100]let differentNumbers = [100, 100, 200, 100, 200]print(equalNumbers.allEqual())print(differentNumbers.allEqual())========truefalse","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习46：协议和扩展","slug":"Swift课程/Swift学习46：协议和扩展","date":"2023-03-05T09:05:03.000Z","updated":"2023-03-10T06:21:53.451Z","comments":true,"path":"2023/03/05/Swift课程/Swift学习46：协议和扩展/","link":"","permalink":"https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A046%EF%BC%9A%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%89%A9%E5%B1%95/","excerpt":"","text":"在扩展里添加协议遵循 你可以扩展一个 已存在的类 来遵循一个新的协议 扩展可以添加新的 属性、方法和下标 到已存在的类型，并且允许你添加协议的任何需要 123456789protocol TextRepresentable &#123; var textDesc: String &#123; get &#125;&#125;// 扩展已存在类遵循新协议extension Dice: TextRepresentable &#123; var textDesc: String &#123; return &quot;zhangjian&quot; &#125;&#125; 有条件的遵循协议 泛型 可能只在某些情况下满足一个 协议 的要求 当 类 的 泛型形式参数 遵循协议时。你可以通过 扩展 列出限制 泛型 有条件的遵循某协议。在协议名字后面写泛型 where 关键字 1 使用扩展声明协议 如果一个 类型（类、结构体、枚举） 已经遵循了协议的所有需求，但还没有 声明它采纳这个协议，你可以通过 扩展来让它声明并采纳 这个协议 定义协议： 1234// 定义协议protocol TextRepresentable &#123; var textDesc: String &#123; get &#125;&#125; 定义结构体类型： 1234567struct Hamster &#123; var name: String // 实现了 遵循协议的所有要求 var textDesc: String &#123; return &quot;a hamster named \\(name)&quot; &#125;&#125; 可以通过 扩展 来让 Hamster 遵循 协议： 1extension Hamster: TextRepresentable &#123;&#125; 协议本身扩展 协议可以通过 扩展 来提供 属性、方法，即 协议本身支持扩展 示例： 【第一步】：定义一个随机数协议 1234// 定义协议protocol RandomNumberGenerator &#123; func random() -&gt; Double&#125; 【第二步】：生成随机数 1234567891011// 生成随机数class LinearCongruentialGenerator: RandomNumberGenerator &#123; var lastRandom = 42.0 let m = 139968.0 let a = 3877.0 let c = 29573.0 func random() -&gt; Double &#123; lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m)) return lastRandom / m &#125;&#125; 【第三步】：让协议本身扩展 123456// 协议本身支持扩展extension RandomNumberGenerator &#123; func randomBool() -&gt; Bool &#123; return random() &gt; 0.5 &#125;&#125; 【最后】：调用 1234567let generator = LinearCongruentialGenerator()print(&quot;here is random number \\(generator.random())&quot;)print(&quot;and here is random bool \\(generator.randomBool())&quot;)==========here is random number 0.3746499199817101and here is random bool true 提供默认实现 可以使用 协议扩展 给协议的 属性或方法 提供默认实现。 如果遵循协议的 类型 提供了自己的实现，会 替代协议扩展中的实现 给集合类和其中的元素添加 协议扩展1234567891011121314151617181920212223242526// 有条件的遵循协议protocol TextRepresentable &#123; var textDesc: String &#123; get &#125;&#125;// 定义一个结构体 Personstruct Person &#123; var name:String = &quot;&quot;&#125;// 扩展 Person 遵循协议extension Person: TextRepresentable&#123; var textDesc: String &#123; return &quot;name \\(name)&quot; &#125;&#125;// 扩展数组元素都遵循协议extension Array: TextRepresentable where Element: TextRepresentable &#123; var textDesc: String &#123; let items = self.map &#123; $0.textDesc &#125; return items.joined(separator: &quot;,&quot;) &#125;&#125;let array = [Person(name: &quot;zj&quot;),Person(name: &quot;wxy&quot;)]print(array.textDesc)==========name zj,name wxy 给 协议扩展 添加限制 在 扩展协议后 面用 where 来写这些限制 将上面的 Array 改成 Collection协议，查看打印结果 12345678910// 扩展数组元素都遵循协议extension Collection where Iterator.Element: TextRepresentable &#123; var textDesc: String &#123; let items = self.map &#123; $0.textDesc &#125; return items.joined(separator: &quot;,&quot;) &#125;&#125;==========name zj,name wxy 总结 除了可以给具体的 类、结构体 扩展以外，还可以 扩展协议本身","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习44：协议","slug":"Swift课程/Swift学习44：协议","date":"2023-03-05T09:04:54.000Z","updated":"2023-03-14T19:03:27.789Z","comments":true,"path":"2023/03/05/Swift课程/Swift学习44：协议/","link":"","permalink":"https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A044%EF%BC%9A%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"前言熟悉Objective-C语言的同学们肯定对协议都不陌生，在Swift中苹果将 protocol 这种语法发扬的更加深入和彻底。Swift中的 protocol 不仅能定义方法还能定义属性，配合 extension 扩展的使用还能提供一些方法的默认实现，而且不仅类可以遵循协议，现在的 枚举和结构体 也能遵循协议了。基于此本文从: 1、协议中定义属性和方法2、协议的继承、组合、关联类型，3、协议的扩展，4、Swift标准库中常见的协议5、为什么要使用协议 介绍 协议 规定了用来实现某一特定功能所必须的属性和方法，这个属性指 实例属性或类型属性，而不用指定是 存储属性或计算属性 类、结构体、枚举 都可以遵循协议，提供具体的实现 来完成协议定义的 属性和方法 协议的语法 自定义类声明协议时，协议名放在类名的冒号 : 之后，多个协议用逗号分开 若是一个类拥有父类，应该将父类名放在遵循的协议名之前，以逗号分隔。 定义协议： 1234// 单个协议protocol SomeProtocol &#123; // dosomething&#125; 遵守协议： 1234// 多个协议protocol SomeStruct: FirstProtocol,AnotherProtocol &#123; // structure definition&#125; 当一个类既有父类，有遵守其他协议时，将父类名写在遵守协议的前面 1234// 继承父类class SomeClass: SomeSuperClass,FirstProtocol,AnotherProtocol &#123; // class definition&#125; 定义属性协议可以要求遵循协议的类型提供特定名称和类型的 实例属性或类型属性。协议不具体说明属性是存储属性还是计算属性，它只具体要求 属性有特定的名称和类型。 协议同时要求一个 属性 必须 明确 是 可读的/可读可写 的，类型声明后加上 &#123; set get &#125; 来表示属性是 可读可写 的； 协议要求 属性 为 变量类型 ，用 var 修饰，而不是let 1234protocol SomeProtocol &#123; var mustBeSettable: Int &#123; get set &#125; // 可读可写 var doesNotNeedToBeSettable: Int &#123; get &#125; // 可读&#125; 协议定义 类型属性 时，前面添加 static 关键字。当类的实现使用 class 或 static 关键字声明属性时，这个规则仍适用 123protocol AnotherProtocol &#123; static var someTypeProperty: Int &#123; get set &#125;&#125; 示例： 12345678protocol Student &#123; // 定义一个可读可写的 name 属性 var name: String &#123; get set &#125; // 定义一个可读的 birthPlace 属性 var birthPlace: String &#123; get &#125; // 定义一个类属性 record static var qualification: String &#123;get&#125;&#125; 和定义方法一样，我们只需要确定该属性具体是什么类型并且添加对应的关键字，不需要具体的实现，更不能为他们赋上初始值（类似于计算属性）。定义好属性之后，我们就可以利用属性来做点事情了。 123456struct Puple: Student &#123; static var qualification: String = &quot;小学&quot; var name: String var birthPlace: String = &quot;北京&quot;&#125;var p1 = Puple(name: &quot;小明&quot;, birthPlace: &quot;上海&quot;) 定义一个 Puple 结构体遵循 Student 协议，该结构体中必须存在协议要求声明的三个属性 matrikelnummer、name、birthPlace, static 修饰的 类型属性 必须被有初始值或者存在 get、set 方法。对于普通的实例属性协议并不关心是计算型属性还是存储型属性。实例中的属性同样可以被修改： 12var p1 = Puple(name: &quot;小明&quot;, birthPlace: &quot;上海&quot;)Puple.qualification = &quot;中学&quot; 看到这里有的同学可能有些疑问，birthPlace、qualification 明明只有 get 方法为什么却可以修改赋值呢？其实协议中的“只读”属性修饰的是协议这种“类型”的实例，例如下面的例子： 12var s1: Student = p1s1.birthPlace = &quot;广州&quot; 虽然我们并不能像创建类的实例那样直接创建协议的实例，但是我们可以通过“赋值”得到一个协议的实例。将 p1 的值赋值给 Student 类型的变量 s1,修改 s1 的 birthPlace 属性时编译器就会报错：birthPlace 是一个只读的属性，不能被修改。如果 Puple 中还存在 Student 没有的属性，那么在赋值过程中 s1 将不会存在这样的属性，尽管这样做的意义并不大，但是我们从中知道了协议中 get、set 的具体含义。 定义方法 协议可以定义 实例方法和类方法，书写方式与正常的 实例方法和类方法相同。协议定义 类方法 时，添加 static 关键字，当类的实现使用 class 或 static 关键字声明属性时，这个规则仍适用。方法的参数 不能有默认值（Swift认为默认值也是一种变相的实现），在遵守该协议的类型中具体实现方法的细节，通过类或实例调用 123protocol SomeProtocol &#123; static func someTypeMethod()&#125; 示例： 123456789101112131415161718protocol Student &#123; //类方法 static func study() //实例方法 func changeName()&#125;struct CollageStudent: Student &#123; //类方法实现 static func study() &#123; &#125; //实例方法实现 func changeName() &#123; &#125;&#125;//方法的调用CollageStudent.study()var c1 = CollageStudent()c1.changeName() 注意：当我们在结构体中的方法修改到属性的时候需要在方法前面加上关键字 mutating 表示该属性能够被修改（如果是类不需要添加mutating 关键字）,这样的方法叫做：异变方法，和 “在实例方法中修改值类型” 的处理是一样的。 12345678910protocol Student &#123; mutating func changeName()&#125;struct CollageStudent: Student &#123; mutating func changeName() &#123; self.name = &quot;小明&quot; &#125;&#125;var c1 = CollageStudent()c1.changeName() 定义 mutating 异变方法 在协议中，可变实例方法使用关键字 mutating 作前缀。在类中实现该方法时不需要写 mutating 关键字。mutating关键字仅供 结构体和枚举使用。 123456789101112131415161718192021// mutatingprotocol Togglable &#123; mutating func toggle()&#125;enum OnOffSwitch: Togglable &#123; case off,on mutating func toggle() &#123; switch self &#123; case .on: self = .on default: self = .off &#125; &#125;&#125;var lightSwitch = OnOffSwitch.offlightSwitch.toggle()print(lightSwitch)========off 定义初始化 协议允许定义 指定的初始化器，和一般初始化器一样，只是不用写大括号也就是初始化器的实体 123protocol SomeProtocol &#123; init(someParameter: Int)&#125; 你可以通过实现 指定的初始化器或便捷初始化器 来使遵循该协议的 类 满足协议的初始化器要求。 在这两种情况下，你必须使用 required 关键字修饰初始化器的实现 123456789protocol Pet &#123; init(name: String)&#125;class Cat: Pet &#123; var name: String = &quot;Cat&quot; required init(name: String) &#123; self.name = name &#125;&#125; Cat 由于遵循了 Pet 协议，应该用 required 关键字修饰初始化器的具体实现。如果一个 类 既继承了某个类，而且遵循了一个或多个协议，我们应该将父类放在最前面，然后依次用逗号排列。 12class SomeClass: OneProtocol, TwoProtocol &#123;&#125; 这是因为Swift中类的继承是单一的，但是类可以遵守多个协议，因此为了突出其单一父类的特殊性，我们应该将继承的父类放在最前面，将遵守的协议依次放在后面。 注意：在使用 final关键字修饰的类，不需要使用 required关键字 标记协议构造器的实现。 如果 子类重写了父类的一个指定初始化器，并且 遵循协议 实现了初始化器要求，那么就要为这个初始化器的实现添加 required 和 override 两个修饰符 12345678910111213141516171819// 协议protocol SomeProtocol &#123; init()&#125;// 父类class SomeSuperClass &#123; init() &#123; &#125;&#125;// 子类class SomeClass: SomeSuperClass,SomeProtocol &#123; init() &#123; // &#125; required override init() &#123; // initializer ... &#125;&#125; 多个协议重名方法调用冲突 由于在Swift中并没有规定不同的协议内方法不能重名（这样的规定也是不合理的）。因此我们在自定义多个协议中方法重名的情况是可能出现的，比如存在TextOne、TextTwo两个协议，定义如下： 123456protocol TextOne &#123; func text() -&gt; Int&#125;protocol TextTwo &#123; func text() -&gt; String&#125; 这两个协议中的 text() 方法名相同返回值不同，如果存在一个类型 Person 同时遵守了 TextOne 和 TextTwo，在Person实例调用方法的时候就会出现歧义。 1234567891011121314struct Person: TextOne, TextTwo &#123; func text() -&gt; Int &#123; return 10 &#125; func text() -&gt; String &#123; return &quot;hello&quot; &#125;&#125;let p1 = Person()// 尝试调用返回值为Int的方法let num = p1.text()// 尝试调用返回值为String的方法let string = p1.text() 上面的调用肯定是无法通过的，因为编译器无法知道同名 text() 方法到底是哪个协议中的方法，那么出现这种情况的根本原因在于调用哪个协议的 text() 不确定，因此我们需要指定调用特定协议的text() 方法，改进后的代码如下： 1234// 尝试调用返回值为Int的方法let num = (p1 as TextOne).text()// 尝试调用返回值为String的方法let string = (p1 as TextTwo).text() 也可以理解为在进行调用前将 p1 常量进行 类型转换。 将协议作为类型 作为 函数、方法或者初始化器的形式参数类型或返回类型 作为 常量、变量或者属性的类型 作为 数组、字典或者其他存储器的元素的类型 首先，以下代码，通过继承基类实现的方式，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Shape&#123; // 计算属性 var area: Double&#123; get&#123; return 0 &#125; &#125;&#125;class Circle: Shape&#123; // 半径 var radius: Double // 构造器 init(_ radius: Double) &#123; self.radius = radius &#125; // 重写父类的属性 override var area: Double&#123; get&#123; return radius * radius * 3.14 &#125; &#125;&#125;class Rectangle: Shape&#123; var width, height: Double init(_ width: Double, _ height: Double) &#123; self.width = width self.height = height &#125; override var area: Double&#123; get&#123; return width * height &#125; &#125;&#125;var circle: Shape = Circle.init(10.0)var rectangle: Shape = Rectangle.init(10.0, 20.0)var shapes: [Shape] = [circle, rectangle]for shape in shapes&#123; print(shape.area)&#125;============314.0200.0 改为协议的方式实现，如下： 12345// 1. 将Shape改为protocol类型// 2. 删除实现该协议的类的协议方法前缀overrideprotocol Shape &#123; var area: Double &#123; get &#125;&#125; 协议继承官方文档说明： 协议可以继承一个或者多个其他协议并且可以在它继承的基础之上添加更多要求。协议继承的语法与类继承的语法相似，选择列出多个继承的协议，使用逗号分隔。 1234567protocol OneProtocol &#123; &#125;protocol TwoProtocol &#123;&#125;// 定义一个继承子OneProtocol 和 TwoProtocol协议的新的协议: ThreeProtocolprotocol ThreeProtocol: OneProtocol, TwoProtocol &#123;&#125; 如上所示，任何遵守了 ThreeProtocol 协议的类型都应该同时实现 OneProtocol 和 TwoProtocol 的要求 必须实现的方法或属性。 类专属的协议 通过添加 AnyObject 关键字到协议的继承列表，你就可以 限制协议只能被类类型采用（并且不是结构体或枚举） 123protocol SomeClassOnlyProtocol: AnyObject,SomeProtocol &#123; // structure definition&#125; 协议组合日常开发中要求一个类型同时遵守多个协议是很常见的，除了使用协议的继承外我们还可以使用形如 OneProtocol &amp; TwoProtocol 的形式实现 协议聚合（组合） 复合多个协议到一个要求里。 12345// 协议聚合成临时的类型typealias Three = TwoProtocol &amp; OneProtocol// 协议聚合成为参数的类型func text(paramter: OneProtocol &amp; TwoProtocol) &#123;&#125; 例如： 12345678910111213141516171819202122232425// 协议组合protocol Named &#123; var name: String &#123; get &#125;&#125;protocol Aged &#123; var age: Int &#123; get &#125;&#125;struct Person: Named,Aged &#123; // 如果这个地方不定义属性会报错 // name属性是可读可写的，满足协议可读的要求 var name: String var age: Int&#125;let p = Person(name: &quot;ZJ&quot;, age: 30)// 满足了两个协议的要求，才能传递 参数func wish(to: Named &amp; Aged) &#123; print(&quot;name \\(to.name) age \\(to.age)&quot;)&#125;wish(to: p)======name ZJ age 30 继承和聚合在使用上的区别： 善于思考的同学可以发现，要实现上面的 “paramter参数的类型是遵守OneProtocol 和 TwoProtoco” 的效果，完全可以使用协议的继承，新定义一个协议ThreeProtocol继承自OneProtocol 和TwoProtocol，然后指定paramter参数的类型是ThreeProtocol类型。那么这两种方法有何区别呢？ 首先协议的继承是定义了一个全新的协议，我们是希望它能够“大展拳脚”得到普遍使用。而协议的聚合不一样，它并没有定义新的固定协议类型，相反，它只是定义一个临时的拥有所有聚合中协议要求组成的局部协议，很可能是“一次性需求”，使用协议的聚合保持了代码的简洁性、易读性，同时去除了定义不必要的新类型的繁琐，并且定义和使用的地方如此接近，见明知意，也被称为匿名协议聚合。但是使用了匿名协议聚合能够表达的信息就少了一些，所以需要开发者斟酌使用。 可选协议要求 当协议中 某些方法或属性不需要遵守协议 的类型实现时，使用关键字 optional 来指明； 协议和可选需求都必须用 @objc 属性标记； @objc 协议只能被继承自 Objective-C 类或其他 @objc 类使用，不能被结构体或枚举采纳 示例： 12345678910111213141516171819202122232425262728293031// 可选@objc protocol CounterDataSource &#123; // 可选方法 @objc optional func increment(forCount count: Int) -&gt; Int // 可选属性 @objc optional var fixedIncrement: Int &#123; get &#125;&#125;// 继承自NSObject类使用class ThreeSource: NSObject, CounterDataSource &#123; // 可选属性 let fixedIncrement = 3&#125;class TowardsZeroSource: NSObject, CounterDataSource &#123; // 可选方法 func increment(_ count: Int) -&gt; Int &#123; if count &gt; 0 &#123; return count &#125;else &#123; return 0 &#125; &#125;&#125;var threeSource = ThreeSource()print(threeSource.fixedIncrement)var towardsSource = TowardsZeroSource()print(towardsSource.increment(5))=======35 检查协议一致性 可以使用 is 和 as 操作符来检查协议的一致性，并强制转换到特定的协议。如果一个实例符合协议，则 is 操作符返回 true，否则返回 false。 123456struct Person: OneProtocol &#123;&#125;let p1 = Person()if (p1 is OneProtocol)&#123; // 可以理解为：p1 是一个遵守了OneProtocol协议类型的实例 print(&quot;yes&quot;)&#125; 如何让定义的协议只能被 类 遵守？：使用关键字 class，该关键字修饰之后表示协议只能被 类 遵守，如果有枚举或结构体尝试遵守会报错。 12345678// 只能被类遵守的协议protocol FourProtocol: class ,ThreeProtocol &#123;&#125;// 此处报错struct Person: FourProtocol &#123;&#125;class Perple: FourProtocol &#123;&#125; as? 操作符返回协议类型的可选值，如果实例不符合该协议，则该值为nil。 as! 操作符将强制转换为协议类型，并在转换失败时触发运行时错误。 12345678910111213141516171819202122232425262728293031323334353637protocol HasArea &#123; var area: Double &#123; get &#125;&#125;class Circle: HasArea &#123; let pi = 3.1415927 var radius: Double var area: Double &#123; return pi * radius * radius &#125; init(radius: Double) &#123; self.radius = radius &#125;&#125;class Country: HasArea &#123; var area: Double init(area: Double) &#123; self.area = area &#125;&#125;class Animal &#123; var legs: Int init(legs: Int) &#123; self.legs = legs &#125;&#125;let objects: [AnyObject] = [ Circle(radius: 2.0), Country(area: 243_610), Animal(legs: 4)]for object in objects &#123; if let objectWithArea = object as? HasArea &#123; print(&quot;Area is \\(objectWithArea.area)&quot;) &#125; else &#123; print(&quot;Something that doesn&#x27;t have an area&quot;) &#125;&#125;==============Area is 12.5663708Area is 243610.0Something that doesn&#x27;t have an area 关联类型协议的关联类型指的是根据使用场景的变化，如果协议中某些属性存在 “逻辑相同的而类型不同” 的情况，可以使用关键字 associatedtype 来为这些属性的类型声明“关联类型”。 12345protocol WeightCalculable &#123; // 为weight 属性定义的类型别名 associatedtype WeightType var weight: WeightType &#123; get &#125;&#125; WeightCalculable 是一个“可称重”协议，weight 属性返回遵守该协议具体类型的实例的重量。这里我们使用 associatedtype 为该属性的类型定义了一个别名 WeightType，换言之在WeightCalculable 中并不关心 weight 的类型是 Int 还是 Double 或者是其他类型,他只是简单的告诉我们返回的类型是 WeightType，至于 WeightType 到底是什么类型由遵守该协议的类中自己去定义。那么这样做的好处是什么呢？ 123456789101112// 定义手机结构体struct MobilePhone: WeightCalculable &#123; typealias WeightType = Double var weight: WeightType&#125;let iPhone7 = MobilePhone(weight: 0.138)// 定义汽车结构体struct Car: WeightCalculable &#123; typealias WeightType = Int var weight: WeightType&#125;let truck = Car(weight: 3000_000) 如上所示：MobilePhone、Car 类型都遵守了 WeightCalculable 协议，都能被称重，但是手机由于结构精密、体型小巧，小数点后面的数字对于称重来说是必不可少的，所以使用了 Double 类型，返回 0.138千克 即 138克，但是对于汽车这样的庞然大物在称重时如果还计较小数点后面的数字就显得没有意义了，所以使用 Int 类型，表示 3000 千克也就是 3吨。 从上面的例子可以很好的看出由于 MobilePhone、Car 称重时逻辑是一样的，但是对于 weight 属性的返回值要求不一样，如果仅仅因为返回值类型的不同定义两个类似的协议一个是 Int 类型另外一个是 Double 类型，这样做显然是重复的、不合适的。所以 associatedtype 在这种情况下就发挥出作用了，他让开发者在遵守协议时根据需求去定义返回值的类型，而不是在协议中写死。唯一要注意的是：一定要在遵守该协议的类型中使用 typealias 规定具体的类型。不然编译器就报错了。 协议的扩展协议的扩展是协议中很重要的一部分内容，主要体现在以下两个方面： 扩展协议的属性和方法 我们通过一个常见的例子说明一下： 12345protocol Score &#123; var math: Int &#123; get set&#125; var english: Int &#123;get set&#125; func mathPercent() -&gt; Double&#125; 首先定义一个 Score 协议，里面有两个 Int 类型的属性 math、english 和一个计算数学所占分数的比例的方法 mathPercent。 1234567struct Puple: Score &#123; var math: Int var english: Int func mathPercent() -&gt; Double &#123; return Double(math) / Double(math + english) &#125;&#125; 定义 Puple 遵守该协议，实现了必要的属性和方法。 12let p1 = Puple(math: 90, english: 80)s1.mathPercent() 通过上面的代码可以计算出 s1 中数学所占的比例，但是设想一下如果还有很多个类似 Puple 结构体的类型都需要遵守该协议，都需要默认实现 mathPercent 方法计算出自己的数学分数所占的比例，还是按照上面的写法代码量就很大而且很冗杂了。问题的关键在于：任何遵守 Score 协议类型的mathPercent 计算逻辑是不变的，而且需要默认实现。那么我们如何轻松的实现这样的效果呢，答案是：为 Score 添加方法的扩展。 12345extension Score &#123; func mathPercent() -&gt; Double &#123; return Double(math) / Double(math + english) &#125;&#125; 将 mathPercent 的具体实现写在协议的扩展里面，就能为所有的遵守 Score 的类型提供mathPercent 默认的实现。 123456struct CollageStudent: Score &#123; var math: Int var english: Int&#125;let c1 = CollageStudent(math: 80, english: 80)c1.mathPercent() 如此就能起到 不实现mathPercent方法也能计算出数学所占分数的比例 的效果了。此语法在Swift中有一个专业术语叫做：default implementation 即 默认实现。包括 计算属性和方法 的默认实现，但是 不支持存储属性，如果遵循类型给这个协议的要求提供了它自己的实现，那么它就会替代扩展中提供的默认实现。通过这样的语法，我们不仅能为自定义的协议提供扩展，还能为系统提供的协议添加扩展，例如，为 CustomStringConvertible 添加一个计算属性默认实现的扩展： 12345extension CustomStringConvertible &#123; var customDescription: String &#123; return &quot;ZJ&quot; + description &#125;&#125; 为存在的类型添加协议遵守 官方文档说明： 扩展一个已经存在的类型来采纳和遵循一个新的协议，无需访问现有类型的源代码。扩展可以添加新的属性、方法和下标到已经存在的类型，并且因此允许你添加协议需要的任何需要。 简单的来说我们可以对存在的类型（尤其是系统的类型）添加协议遵守。尽管这更像是对“类型的扩展”，但是官方文档将这部分放在了协议的扩展中。 1234extension Double : CustomStringConvertible &#123; /// A textual representation of the value. public var description: String &#123; get &#125;&#125; 上面的代码就是 Swift 标准库中对于 Double 类型添加的一个协议遵守。除了添加系统协议的遵守，我们还可以添加自定义的协议的遵守，其方法都是一样的，这里就不太赘述了。 总结 通过 协议的扩展 提供协议中某些属性和方法的默认实现，将公共的代码和属性统一起来极大的增加了代码的复用，同时也增加了协议的灵活性和使用范围，这样的协议不仅仅是一系列接口的规范，还能提供相应的逻辑，是面向协议编程的基础。 Swift标准库中常见的协议学习完协议的基础语法，我们大致熟悉一下Swift标准库中提供的协议。 Swift标准库为我们提供了55种协议，他们的命名很有特点，基本是以”Type”、“able”、“Convertible” 结尾，分别表示该协议“可以被当做XX类型”、“具备某种能力或特性”、“能够进行改变或变换”。因此在自定义协议时应该尽可能遵守苹果的命名规则，便于开发人员之间的高效合作。下面介绍一下常见的几种协议： Equatable Equatable 是和比较相关的协议，遵守该协议表示实例能够用于相等的比较，需要重载 == 运算符。 12345678struct Student: Equatable &#123; var math: Int var english: Int&#125;// 重载 == 运算符func == (s1: Student, s2: Student) -&gt; Bool &#123; return s1.math == s2.math &amp;&amp; s1.english == s2.english&#125; Student遵守 Equatable 并且重载了 == 运算符后就能直接比较两个学生的成绩是否相等了。 123let s1 = Student(math: 80, english: 60)let s2 = Student(math: 70, english: 90)s1 == s2 //false 值得注意的是，由于重载 == 运算符是遵守 Equatable 协议后要求我们实现的，因此重载方法应该紧跟在遵守该协议的类型定义后，中间不能有其他的代码，否则就报错了。 Comparable Comparable 是和比较相关的第二个协议，遵守该协议表示实例能够进行比较，需要重载 &lt; 运算符。 1234567891011struct Student: Comparable&#123; var math: Int var english: Int&#125;// 重载 &lt; 运算符func &lt; (s1: Student, s2: Student) -&gt; Bool &#123; return (s1.math + s1.english) &lt; (s2.math + s2.english)&#125;let s1 = Student(math: 80, english: 60)let s2 = Student(math: 70, english: 90)s1 &lt; s2 //true CustomStringConvertible CustomStringConvertible 提供了一种用文本表示一个对象或者结构的方式,可以在任何遵守该协议的类型中自定义表示结构的文本，需要覆盖 description 属性。 123456789struct Student: CustomStringConvertible&#123; var math: Int var english: Int var description: String &#123; return &quot;Your math:&quot; + String(math) + &quot;, english:&quot; + String(english) &#125;&#125;let s1 = Student(math: 80, english: 60)print(s1) // Your math:80, english:60 ExpressibleByArrayLiteral ExpressibleByArrayLiteral 提供了使用数组文本初始化的类型的能力，具体来说使用逗号分隔的值、实例、字面值列表，方括号以创建数组文本。遵守该协议需要实现 init(arrayLiteral elements: Person.Element...) 方法。 1234567891011121314struct Person: ExpressibleByArrayLiteral &#123; var name: String = &quot;&quot; var job: String = &quot;&quot; typealias Element = String init(arrayLiteral elements: Person.Element...) &#123; if elements.count == 2 &#123; name = elements[0] job = elements[1] &#125; &#125;&#125;let p1: Person = [&quot;jack&quot;, &quot;teacher&quot;]print(p1.name) //jackprint(p1.job) //teacher 上面的代码用到了之前关联类型，通过遵守 ExpressibleByArrayLiteral，现在的 Person 就可以使用数组直接创建实例了。 类似的协议还有： ExpressibleByDictionaryLiteral、ExpressibleByStringLiteral、ExpressibleByBooleanLiteral 、ExpressibleByIntegerLiteral 等等，相信大家通过名称就能大概猜出具体作用，由于篇幅有限这里就不再赘述了。 为什么要使用协议 协议可以作为类型使用 协议作为一种类型是苹果在Swift中提出的，并且在官方文档中还为我们具体指出了可以将协议当做类型使用的场景： 1，在函数、方法或者初始化器里作为形式参数类型或者返回类型；2，作为常量、变量或者属性的类型；3，作为数组、字典或者其他存储器的元素的类型。 协议可以解决面向对象中一些棘手的问题","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习38：类","slug":"Swift课程/Swift学习38：类","date":"2023-03-05T09:04:46.000Z","updated":"2023-03-12T13:16:09.287Z","comments":true,"path":"2023/03/05/Swift课程/Swift学习38：类/","link":"","permalink":"https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A038%EF%BC%9A%E7%B1%BB/","excerpt":"","text":"类 Swift 类 是构建代码的 一种 通用的 构造体 swift 也是一种 面向对象（OOP） 的编程语言 swift中 类 可以定义 属性(常量、变量)和方法 Swift 中 类 是 引用类型 的，存储在 堆区 类和结构体对比Swift 中类和结构体有很多共同点： 定义 属性 用于 存储值 定义 方法 用于 提供功能 定义 下标脚本 用于访问值 定义 初始化器 用于 生成初始化值 通过 扩展 以 增加默认实现的功能 符合 协议 以 对某类提供标准功能 与结构体相对，类还有如下的 附加 功能： class 定义 属性，必须赋值或包装成Optional。struct 定义属性不需要要赋值 class 是 引用类型，浅拷贝。struct 是 值类型，深拷贝。 class 可以继承。struct 不能继承。 class 有 引用计数，可以 多次引用。struct 没有引用计数 class 有 类型转换，允许在 运行时检查和解释一个类实例的类型。struct 没有 class 有 解构器 允许一个 类实例释放任何其所被分配的资源 struct 分配在 栈 中，系统分配是否内存。class 分配在 堆 中，动态分配释放内存 struct 比 class 更轻量级，栈 只访问一次拿到数据，堆 访问两次拿到数据（第一次获取指针，第二次获取数据） 类的属性 存储属性：存储实例的常量和变量 计算属性：通过某种方式计算出来的属性 { set {} get{} } 类型属性：与整个自身相关的属性，用 static 关键字修饰 类的定义我们使用 class 关键字在 swift 中创建一个类。例如： 没有父类 123class 类名 &#123; // 定义属性和方法等&#125; 有父类 123class 类名 : SuperClass&#123; // 定义属性和方法等&#125; 总结：定义的类，可以没有父类，也可以有父类通常情况下，定义类时，继承自 _SwiftObject 定义存储属性 存储属性 要么是 变量存储属性（由 var 关键字引入），要么是 常量存储属性（由 let 关键字引入） 定义 属性 必须 赋值或包装成Optional 示例： 123456// 存储属性class Person &#123; // 定义属性时，需要赋值或包装Optional，否则报错 let age: Int = 30 var name: String?&#125; 实例化类123456// 实例化let p = Person()p.age = 32 // Cannot assign to property: &#x27;age&#x27; is a &#x27;let&#x27; constantp.name = &quot;ZJ&quot;print(p.age)print(p.name!) 注：常量存储属性不能修改 修改后： 123456789101112131415class Person &#123; // 定义属性时，需要赋值或包装Optional，否则报错 let age: Int = 30 var name: String?&#125;// 实例化let p = Person()//p.age = 32p.name = &quot;ZJ&quot;print(p.age)print(p.name!)======30ZJ 延迟存储属性延迟属性，即，使用 lazy修饰 的存储属性。特点： 第一次访问的时候才被赋值。 不能保证线程安全 lazy 修饰的属性，必须要初始化，不能包装Optiaonal 示例： 123456class Manager &#123; // lazy lazy var name:String?&#125;let m = Manager()print(m.name) 编译运行，报错 修改成： 12345// lazylazy var name:String = &quot;ZJ&quot;======ZJ 计算属性 除了 存储属性，类 还能定义 计算属性，而它实际 并不是存储值。 相反，它提供一个 读取器 和一个 可选的设置器 来间接得到和设置其它的 属性和值。类似于 OC 的 set/get 方法去设值和取值 1234567891011121314151617181920212223242526272829// 定义计算属性struct Point &#123; var x = 0.0,y = 0.0&#125;struct Size &#123; var width = 0.0,height = 0.0&#125;struct Rect &#123; // 存储属性 var origin = Point() var size = Size() // 计算属性：可以通过origin 和 size 计算出来 var center: Point &#123; get &#123; let centerX = origin.x + size.width/2.0 let centerY = origin.y + size.height/2.0 return Point(x:centerX, y:centerY) &#125; set(newCenter) &#123; origin.x = newCenter.x - size.width/2.0 origin.y = newCenter.y - size.height/2.0 &#125; &#125;&#125;let rect = Rect(origin: Point(x: 0,y: 0),size: Size(width: 100,height: 100))print(rect.center)=============Point(x: 50.0, y: 50.0) 简写 setter 如果一个 计算属性 的 设置器 没有为将要被设置的值定义一个名字，那么它将被默认命名为 newValue 1234set &#123; origin.x = newCenter.x - size.width/2.0 origin.y = newCenter.y - size.height/2.0&#125; 简写 getter 如果整个 getter 的函数体是一个 单一的表达式，那么 getter 隐士返回这个表达式 1234// 简写 getget &#123; CGPoint(x: p.x + s.w/2.0, y: p.y + s.h/2.0)&#125; 只读计算属性 一个 有读取器 但是 没有设置器 的 计算属性 就是所谓的 只读计算属性。只读计算属性返回一个值，也可以通过 点语法 访问，但是不能被修改为另一个值 你必须用 var关键字 定义计算属性（包括只读计算属性）为变量属性，因为它的 值不是固定的。let关键字 只能用于常量属性，用于明确哪些值一旦作为实例初始化就不能更改 1234567891011// 只读计算属性class Rect &#123; var p = Point() var s = Size() // 计算属性 var center: CGPoint &#123; get &#123; return CGPoint(x: p.x + s.w/2.0, y: p.y + s.h/2.0) &#125; &#125;&#125; 属性观察者 willSet 会在 该值被存储之前被调用 didSet 会在 一个新值被存储之后被调用 如果你实现了一个 willSet 观察者，新的属性值会以常量形式参数传递。你可以再你的 willSet 实现中为这个参数定义名字。如果你没有为它命名，那么它会使用默认值的名字 newValue 如果你实现了一个 didSet 观察者，一个包含旧属性值的常量形式参数将会被传递。你可以为它命名，也可以使用默认值的形式参数名 oldValue。如果你在属性自己的 disSet 观察者里给自己赋值，你赋值的新值就会取代刚刚设置的值。 12345678910111213141516171819202122232425// 属性观察器class StepCount &#123; var totalStep: Int = 0 &#123; // 值被存储前调用 willSet(newValue) &#123; print(newValue) &#125; // 值被存储后调用 didSet(oldValue) &#123; // 如果 存储后的值 &gt; 存储前的值 if totalStep &gt; oldValue &#123; print(&quot;步数增加： \\(totalStep - oldValue)&quot;) &#125; &#125; &#125;&#125;let step = StepCount()step.totalStep = 100step.totalStep = 200============100步数增加： 100200步数增加： 100 全局和局部变量 观察属性的能力同样对全局变量和局部变量有效。全局变量 是定义在 任何函数、方法、闭包或者类之外的变量。局部变量 是定义在 函数、方法或闭包环境之中的变量。 123456789101112131415161718// 全局变量class Sum &#123; var count: Int = 0 &#123; willSet &#123; print(&quot;count : \\(newValue)&quot;) &#125; didSet &#123; print(&quot;did change count from \\(oldValue) to \\(count)&quot;) &#125; &#125;&#125;let sum = Sum()sum.count = 10 // 全局变量print(sum.count)==============count : 10did change count from 0 to 10 类型属性 使用 static 关键字来定义 类型属性。 123456789// 类型属性class SuperClass &#123; // 类型属性 static var name: String = &quot;ZJ&quot;&#125;print(SuperClass.name)=======ZJ 你也可以使用 class 关键字来定义 类型属性 12345678910111213// 重写父类的实现class SubClass: SuperClass &#123; // 类型属性 class var newName: String &#123; get &#123; return &quot;New ZJ&quot; &#125; &#125;&#125;print(SubClass.newName)======New ZJ 定义实例方法 实例方法 是属于 特定类实例、结构体实例或枚举实例的函数，提供 访问和修改实例属性的方法 每一个类的实例都隐含一个叫做 self 的属性，它完全与实例本身相等。你可以用 self 属性在当前实例中调用自身的方法 实际上，你不需要经常在代码中写 self。如果你没有显示地写出 self，swift 会在你方法中使用已知属性或方法的时候假定你调用了当前实例中的属性或者方法 例外就是当一个实例方法的形式参数名与实例中某个属性拥有相同的名字的时候。在这种情况下，形式参数名具有优先权，并且调用属性的时候使用更加严谨的方式就很有必要了。你可以使用 self 属性来 区分形式参数名和属性名 123456789101112131415// 定义方法class PrintInfo &#123; var x = 0.0, y = 0.0 // 实例方法 func printInfo() &#123; print(&quot;x is \\(x),y is \\(y)&quot;) &#125;&#125;var printInfo = PrintInfo()printInfo.x = 10printInfo.y = 20printInfo.printInfo()=======x is 10.0,y is 20.0 实例方法 self1234567891011121314151617// selfclass SomePoint &#123; var x = 0.0 // 实例方法 self func isToTheRightOf(x: Double) -&gt; Bool &#123; // self 访问 属性 return self.x &gt; x &#125;&#125;let somePoint = SomePoint()somePoint.x = 4if somePoint.isToTheRightOf(x: 1.0) &#123; print(&quot;the point is x \\(somePoint.x)&quot;)&#125;=======the point is x 4.0 在实例方法中修改属性类 是 引用类型的，允许修改属性 12345678910111213// 修改属性class ChangeName &#123; var name: String = &quot;ZZ&quot; func change() &#123; name = &quot;ZJ&quot; print(name) &#125;&#125;let name = ChangeName()name.change()===========ZJ 类型方法 类 通过在 func 关键字前用 class 关键字来明确一个 类型方法。 12345678910111213// 类型方法class PointClass &#123; // 类型方法 static func pringInfo(newX: Double) &#123; print(&quot;x is \\(newX)&quot;) &#125;&#125;var pc = PointClass()// 类型方法用 类 调用PointClass.pringInfo(newX: 10)=======x is 10 定义初始化器12345678910111213// 定义初始化器class Name &#123; var name: String init(name: String) &#123; // 初始化值 self.name = &quot;my name is \\(name)&quot; &#125;&#125;let name = Name(name: &quot;ZJ&quot;)print(name.name)=======my name is ZJ 定义下标脚本 类、结构体和枚举 可以定义 下标，它可以作为访问集合、列表或序列号成员元素的快捷方式。你可以使用下标通过索引值来设置或检索值而不需要为设置和检索分别使用实例方法 你可以为一个类型 定义多个下标，并且下标会基于传入的索引值的类型选择合适的下标重载使用。下标没有限制单个维度，你可以使用多个输入形参来定义下标以满足自定义类型的需求 下标脚本 允许你通过在实例名后面的方括号内写一个或多个值对该类的实例进行查询。它的语法类似于实例方法和计算属性。使用关键字 subscript 来定义下标，并且指定一个或多个输入形式参数和返回类型，与实例方法一样。与实例方法不同的是，下标可以是读写也可以是只读的 下标脚本的访问用 [] 123456789101112131415// 定义下标脚本class Grade &#123; subscript(num: Int) -&gt;String &#123; if num &lt; 60 &#123; return &quot;不及格&quot; &#125;else &#123; return &quot;及格&quot; &#125; &#125;&#125;let grade = Grade()print(grade[99])=======及格","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习39：结构体","slug":"Swift课程/Swift学习39：结构体","date":"2023-03-05T09:04:39.000Z","updated":"2023-03-12T13:22:49.800Z","comments":true,"path":"2023/03/05/Swift课程/Swift学习39：结构体/","link":"","permalink":"https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A039%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"","text":"结构体 Swift 结构体 是 构建代码 所用的 一种 通用且灵活的 构造体 Swift 结构体 是 值类型，通过 复制 的方式在代码中 传递，因此它的值是不可修改的 类和结构体对比Swift 中类和结构体有很多共同点： 定义 属性 用于 存储值 定义 方法 用于 提供功能 定义 下标脚本 用于访问值 定义 初始化器 用于 生成初始化值 通过 扩展 以 增加默认实现的功能 符合 协议 以 对某类提供标准功能 与结构体相对，类还有如下的 附加 功能： class 定义 属性，必须赋值或包装成Optional。struct 定义属性不需要要赋值 class 是 引用类型，浅拷贝。struct 是 值类型，深拷贝。 class 可以继承。struct 不能继承。 class 有 引用计数，可以 多次引用。struct 没有引用计数 class 有 类型转换，允许在 运行时检查和解释一个类实例的类型。struct 没有 class 有 解构器 允许一个 类实例释放任何其所被分配的资源 struct 分配在 栈 中，系统分配是否内存。class 分配在 堆 中，动态分配释放内存 struct 比 class 更轻量级，栈 只访问一次拿到数据，堆 访问两次拿到数据（第一次获取指针，第二次获取数据） 作用结构体可以 定义属性(常量let、变量var） 和 添加方法，从而 扩展结构体的功能 语法通过关键字 struct 来定义结构体： 123struct 结构体名 &#123; // 定义 属性和方法等&#125; 定义存储属性struct 定义存储属性，允许不设置默认值 12345struct Person &#123; // 存储属性 let age: Int var name: String&#125; 实例化12345678// 实例化let p = Person(age: 32, name: &quot;ZJ&quot;)print(p.age)print(p.name)=======32ZJ 延迟存储属性 延迟存储属性的初始值在第一次使用时才进行计算。 声明前面标注 lazy 关键字来表示一个 延迟存储属性 lazy 修饰的属性，必须要初始化 示例： 12345678910// 延迟存储属性struct Manager &#123; // lazy 必须被初始化 lazy var name:String = &quot;&quot;&#125;var m = Manager(name: &quot;ZJ&quot;)print(m.name)=======ZJ 定义计算属性 除了 存储属性，类 还能定义 计算属性，而它实际 并不是存储值。 相反，它提供一个 读取器 和一个 可选的设置器 来间接得到和设置其它的 属性和值。类似于 OC 的 set/get 方法去设值和取值 123456789101112131415161718192021222324252627// 计算属性struct Point &#123; var x = 0.0,y = 0.0&#125;struct Size &#123; var width = 0.0,height = 0.0&#125;struct Rect &#123; // 存储属性 var origin = Point() var size = Size() // 计算属性：可以通过origin 和 size 计算出来 var center: Point &#123; get &#123; let centerX = origin.x + size.width/2.0 let centerY = origin.y + size.height/2.0 return Point(x:centerX, y:centerY) &#125; set(newCenter) &#123; origin.x = newCenter.x - size.width/2.0 origin.y = newCenter.y - size.height/2.0 &#125; &#125;&#125;=============Point(x: 50.0, y: 50.0) 简写 setter 如果一个 计算属性 的 设置器 没有为将要被设置的值定义一个名字，那么它将被默认命名为 newValue 1234set &#123; origin.x = newCenter.x - size.width/2.0 origin.y = newCenter.y - size.height/2.0&#125; 简写 getter 如果整个 getter 的函数体是一个 单一的表达式，那么 getter 隐士返回这个表达式 1234// 简写 getget &#123; Point(x:origin.x + size.width/2.0, y:origin.y + size.height/2.0)&#125; 只读计算属性 一个 有读取器 但是 没有设置器 的 计算属性 就是所谓的 只读计算属性。只读计算属性返回一个值，也可以通过 点语法 访问，但是不能被修改为另一个值 你必须用 var关键字 定义计算属性（包括只读计算属性）为变量属性，因为它的 值不是固定的。let关键字 只能用于常量属性，用于明确哪些值一旦作为实例初始化就不能更改 1234567891011121314// 只读计算属性struct Rect &#123; // 存储属性 var origin = Point() var size = Size() // 计算属性：可以通过origin 和 size 计算出来 var center: Point &#123; get &#123; let centerX = origin.x + size.width/2.0 let centerY = origin.y + size.height/2.0 return Point(x:centerX, y:centerY) &#125; &#125;&#125; 属性观察者 willSet 会在 该值被存储之前被调用 didSet 会在 一个新值被存储之后被调用 如果你实现了一个 willSet 观察者，新的属性值会以常量形式参数传递。你可以再你的 willSet 实现中为这个参数定义名字。如果你没有为它命名，那么它会使用默认值的名字 newValue 如果你实现了一个 didSet 观察者，一个包含旧属性值的常量形式参数将会被传递。你可以为它命名，也可以使用默认值的形式参数名 oldValue。如果你在属性自己的 disSet 观察者里给自己赋值，你赋值的新值就会取代刚刚设置的值。 12345678910111213141516171819202122// 属性观察器struct StepCount &#123; var totalStep: Int = 0 &#123; // 值被存储前调用 willSet(newValue) &#123; print(newValue) &#125; // 值被存储后调用 didSet(oldValue) &#123; // 如果 存储后的值 &gt; 存储前的值 if totalStep &gt; oldValue &#123; print(&quot;步数增加： \\(totalStep - oldValue)&quot;) &#125; &#125; &#125;&#125;var step = StepCount()step.totalStep = 100============100步数增加： 100 全局和局部变量 观察属性的能力同样对全局变量和局部变量有效。全局变量 是定义在 任何函数、方法、闭包或者类之外的变量。局部变量 是定义在 函数、方法或闭包环境之中的变量。 123456789101112131415161718// 全局变量struct Sum &#123; var count: Int = 0 &#123; willSet &#123; print(&quot;count : \\(newValue)&quot;) &#125; didSet &#123; print(&quot;did change count from \\(oldValue) to \\(count)&quot;) &#125; &#125;&#125;var sum = Sum()sum.count = 10 // 全局变量print(sum.count)==============count : 10did change count from 0 to 10 类型属性 struct、enum 中使用 static 关键字来定义 类型属性。 123456789// 类型属性class SuperClass &#123; // 类型属性 static var name: String = &quot;ZJ&quot;&#125;print(SuperClass.name)=======ZJ struct、enum 中 不允许 使用 class 关键字来定义 类型属性 定义实例方法 实例方法 是属于 特定类实例、结构体实例或枚举实例的函数，提供 访问和修改实例属性的方法 每一个类的实例都隐含一个叫做 self 的属性，它完全与实例本身相等。你可以用 self 属性在当前实例中调用自身的方法 实际上，你不需要经常在代码中写 self。如果你没有显示地写出 self，swift 会在你方法中使用已知属性或方法的时候假定你调用了当前实例中的属性或者方法 例外就是当一个实例方法的形式参数名与实例中某个属性拥有相同的名字的时候。在这种情况下，形式参数名具有优先权，并且调用属性的时候使用更加严谨的方式就很有必要了。你可以使用 self 属性来 区分形式参数名和属性名 123456789101112131415// 定义方法struct PrintInfo &#123; var x = 0.0, y = 0.0 // 实例方法 func printInfo() &#123; print(&quot;x is \\(x),y is \\(y)&quot;) &#125;&#125;var printInfo = PrintInfo()printInfo.x = 10printInfo.y = 20printInfo.printInfo()=======x is 10.0,y is 20.0 实例方法 self1234567891011121314151617// selfstruct SomePoint &#123; var x = 0.0 // 实例方法 self func isToTheRightOf(x: Double) -&gt; Bool &#123; // self 访问 属性 return self.x &gt; x &#125;&#125;var somePoint = SomePoint()somePoint.x = 4if somePoint.isToTheRightOf(x: 1.0) &#123; print(&quot;the point is x \\(somePoint.x)&quot;)&#125;=======the point is x 4.0 在实例方法中修改属性 struct、enum 是 值类型的，默认情况下，值类型属性不能被修改 你可以选择在 func 关键字前放一个 mutating(异变方法) 关键字来 指定可以修改属性 1234567891011121314// 修改属性struct ChangeName &#123; var name: String // struct 中 使用 mutating 修改属性 mutating func change() &#123; name = &quot;ZJ&quot; print(name) &#125;&#125;var name = ChangeName(name: &quot;&quot;)name.change()===========ZJ 在 mutating 方法中赋值给 self mutating 方法可以指定整个实例给隐含的 self 属性 1234567891011121314151617// selfstruct SomePoint &#123; var x = 0.0 // 实例方法 self func isToTheRightOf(x: Double) -&gt; Bool &#123; // self 访问 属性 return self.x &gt; x &#125;&#125;var somePoint = SomePoint()somePoint.x = 4if somePoint.isToTheRightOf(x: 1.0) &#123; print(&quot;the point is x \\(somePoint.x)&quot;)&#125;=======the point is x 4.0 类型方法 struct、enum 通过在 func 关键字前用 static 关键字来明确一个 类型方法。 12345678910111213// 类型方法struct PointClass &#123; var x = 0.0, y = 0.0 // 类型方法 static func pringInfo() &#123; print(&quot;pringInfo&quot;) &#125;&#125;// 类型方法用 类 调用PointClass.pringInfo()=====pringInfo struct、enum 不允许既有 static 又有 mutating 定义初始化器12345678910111213// 定义初始化器struct Name &#123; var name: String init(name: String) &#123; // 初始化值 self.name = &quot;my name is \\(name)&quot; &#125;&#125;let name = Name(name: &quot;ZJ&quot;)print(name.name)=======my name is ZJ 成员初始化器如果结构体中没有定义任何初始化器，它会自动获得一个 成员初始化器 1234struct Size &#123; var width = 0.0, height = 0.0&#125;let s = Size(width: 2.0,height: 2.0) 初始化器委托初始化器可以调用其他初始化器，避免了多个初始化器里冗余代码 1234567891011struct Name &#123; var name: String init(name: String) &#123; // 初始化值 self.name = &quot;my name is \\(name)&quot; &#125; init(age: String,name: String) &#123; let newName = name + age self.init(name:newName) &#125;&#125; 定义下标脚本 类、结构体和枚举 可以定义 下标，它可以作为访问集合、列表或序列号成员元素的快捷方式。你可以使用下标通过索引值来设置或检索值而不需要为设置和检索分别使用实例方法 你可以为一个类型 定义多个下标，并且下标会基于传入的索引值的类型选择合适的下标重载使用。下标没有限制单个维度，你可以使用多个输入形参来定义下标以满足自定义类型的需求 下标脚本 允许你通过在实例名后面的方括号内写一个或多个值对该类的实例进行查询。它的语法类似于实例方法和计算属性。使用关键字 subscript 来定义下标，并且指定一个或多个输入形式参数和返回类型，与实例方法一样。与实例方法不同的是，下标可以是读写也可以是只读的 下标脚本的访问用 [] 123456789101112131415// 定义下标脚本struct Grade &#123; subscript(num: Int) -&gt;String &#123; if num &lt; 60 &#123; return &quot;不及格&quot; &#125;else &#123; return &quot;及格&quot; &#125; &#125;&#125;let grade = Grade()print(grade[99])=======及格","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习40：枚举","slug":"Swift课程/Swift学习40：枚举","date":"2023-03-05T09:04:28.000Z","updated":"2023-03-13T21:24:36.045Z","comments":true,"path":"2023/03/05/Swift课程/Swift学习40：枚举/","link":"","permalink":"https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A040%EF%BC%9A%E6%9E%9A%E4%B8%BE/","excerpt":"","text":"枚举 枚举 是一种 数据类型，只包含自定义的特定数据 枚举 是一组有共同特性的数据集合，使你可以在你的代码中以 类型安全 的方式来使用这些值。 作用在 OC 相比，枚举只支持 整数型；而在 Swift 中枚举有很多功能： 可以定义 成员类型，支持 Int、Double、String等基础类型，也有 默认枚举值 可以 定义构造函数（initializers）来提供一个初始成员值，可以在原始的实现基础上扩展他们的功能 可以 关联枚举值 可以遵守协议（protocol） 来 提供标准化功能。 可以 嵌套枚举 枚举的语法 用 enum 关键字来定义一个枚举，然后将其所有的定义内容放在一个大括号 &#123;&#125; 中 多个成员值可以出现在同一行中，用逗号隔开 每个枚举都定义了一个全新的类型。正如swift中其它类型那样，它的名称（例如： ComP）需要首字母大写。给枚举类型起一个单数的而不是复数的名字，从而使得他们能够顾名思义 123456789101112131415161718192021222324252627282930313233// 写法一// 不需要逗号隔开enum ComP &#123; case east case south case west case north&#125;// 写法二// 也可以直接一个case，然后逗号隔开enum ComP2 &#123; case east, south, west, north&#125;// 定义一个枚举变量var comp = ComP.east/*String类型的enum- =左边的值是枚举值，例如 MON- =右边的值在swift中称为 RawValue（原始值），例如 &quot;MON&quot;- 两者的关系为：case 枚举值 = rawValue原始值*/enum Week: String &#123; case MON = &quot;MON&quot; case TUE = &quot;TUE&quot; case WED = &quot;WED&quot; case THU = &quot;THU&quot; case FRI = &quot;FRI&quot; case SAT = &quot;SAT&quot; case SUN = &quot;SUN&quot;&#125; 如果不想写枚举后的字符串，也可以使用 隐士RawValue 分配 12345678enum Week: String&#123; case MON, TUE, WED, THU, FRI, SAT, SUN&#125;var w = Week.MON.rawValueprint(w)=======MON 使用 Switch 语句来匹配枚举值 你可以用 switch 语句来匹配每一个单独的枚举值 123456789101112131415161718192021// switch 访问枚举let week = Week.MONswitch week &#123;case .TUE: print(&quot;TUE&quot;)case .WED: print(&quot;WED&quot;)case .THU: print(&quot;TUE&quot;)case .FRI: print(&quot;FRI&quot;)case .SAT: print(&quot;SAT&quot;)case .SUN: print(&quot;SUN&quot;)case .MON: print(&quot;MON&quot;)&#125;======MON CaseIterable协议 通常用于没有关联值的枚举，只需要遵守 CaseIterable 协议来 允许枚举被遍历，写法：在枚举名后面写 :CaseIterable，然后通过 allCases 获取所有枚举值，如下： 123456789101112131415161718// 遍历枚举enum Direction : CaseIterable&#123; case east case south case west case north&#125;for direction in Direction.allCases &#123; print(direction)&#125;或 高阶函数Direction.allCases.map &#123; print($0) &#125;=========eastsouthwestnorth string 类型 123456789101112// string 类型enum Direction2: String &#123; case east, south, west, north&#125;extension Direction2: CaseIterable &#123;&#125;Direction2.allCases.map&#123; print( $0 ) &#125;=======eastsouthwestnorth 枚举 关联值 和 枚举值枚举中有两个很容易混淆的概念：原始值(raw value)、关联值(associated value)，两个词听起来比较模糊，下面简单介绍一下： 原始值(raw value) 枚举成员可以用相同类型的默认值预先填充，这样的值我们称为 原始值(raw value) 下面的 StudentType 中三个成员分别被 Int 类型的 10 、15、 20 填充表示不同阶段学生的年龄。注意：Int 修饰的是 StudentType 成员原始值的类型而不是 StudentType 的类型，StudentType类型从定义开始就是一个全新的枚举类型。 12345enum StudentType: Int&#123; case pupil = 10 case middleSchoolStudent = 15 case collegeStudents = 20&#125; 定义好StudentType成员的原始值之后，我们可以使用枚举成员的 rawValue 属性来访问成员的原始值，或者是使用原始值初始化器来尝试创建一个枚举的新实例 12345678910// 常量student1值是 10let student1 = StudentType.pupil.rawValue// 变量student2值是 15var student2 = StudentType.middleSchoolStudent.rawValue// 使用成员rawValue属性创建一个`StudentType`枚举的新实例let student3 = StudentType.init(rawValue: 15)// student3的值是 Optional&lt;Senson&gt;.Typetype(of: student3)// student4的值是nil，因为并不能通过整数30得到一个StudentType实例的值let student4 = StudentType.init(rawValue: 30) 使用原始值初始化器这种方式初始化创建得到 StudentType 的实例 student4 是一个StudentType 的可选类型，因为并不是给定一个年龄就能找到对应的学生类型，比如在StudentType 中给定年龄为30就找不到对应的学生类型（很可能30岁的人已经是博士了）。所以原始值初始化器是一个可失败初始化器。 总结一句：原始值是为枚举的成员们绑定了一组类型必须相同值不同的固定的值（可能是整型，浮点型，字符类型等等）。这样很好解释为什么提供原始值的时候用的是等号。 枚举的关联值(associated value) 如果希望用枚举表示复杂的含义，关联更多的信息，就需要使用关联值了。 他与普通类型的枚举不同：没有rawValue，没有rawValue的getter方法；没有初始化init方法。 关联值更像是为枚举的成员们绑定了一组类型，不同的成员可以是不同的类型(提供关联值时用的是括号)。例如下面的代码： 123456789// 关联值// 注：当使用了关联值后，就没有RawValue了// 因为：case可以用一组值来表示，而rawValue是单个的值// 定义一个表示学生类型的枚举类型 StudentType，他有三个成员分别是pupil、middleSchoolStudent、collegeStudentsenum StudentType &#123; case pupil(String) case middleSchoolStudent(Int, String) case collegeStudents(Int, String)&#125; 这里我们并没有为 StudentType 的成员提供具体的值，而是为他们绑定了不同的类型，分别是pupil 绑定 String 类型，middleSchoolStudent 和 collegeStudents 绑定 （Int， String） 元祖类型。接下来就可以创建不同 StudentType 枚举实例并为对应的成员赋值了。 123456// student1 是一个StudentType类型的常量，其值为pupil（小学生），特征是&quot;have fun&quot;（总是在玩耍）let student1 = StudentType.pupil(&quot;have fun&quot;)// student2 是一个StudentType类型的常量，其值为middleSchoolStudent（中学生），特征是 7, &quot;always study&quot;（一周7天总是在学习）let student2 = StudentType.middleSchoolStudent(7, &quot;always study&quot;)// student3 是一个StudentType类型的常量，其值为collegeStudent（大学生），特征是 7, &quot;always LOL&quot;（一周7天总是在撸啊撸）let student3 = StudentType.middleSchoolStudent(7, &quot;always LOL&quot;) 这个时候如果需要判断某个 StudentType 实例的具体的值就需要这样做了： 12345678switch student3 &#123; case .pupil(let things): print(&quot;is a pupil and \\(things)&quot;) case .middleSchoolStudent(let day, let things): print(&quot;is a middleSchoolStudent and \\(day) days \\(things)&quot;) case .collegeStudent(let day, let things): print(&quot;is a collegeStudent and \\(day) days \\(things)&quot;) &#125; 控制台输出：is a collegeStudent and 7 days always LOL，看到这你可能会想，是否可以为一个枚举成员提供原始值并且绑定类型呢，答案是不能的！因为首先给成员提供了固定的原始值，那他以后就不能改变了；而为成员提供关联值(绑定类型)就是为了创建枚举实例的时候赋值。这不是互相矛盾吗。 模式匹配enum 中的模式匹配其实就是 匹配case枚举值，根据枚举类型，分为2种： 1、简单类型 的枚举的模式匹配；2、自定义类型 的枚举（关联值）的模式匹配。 简单enum的模式匹配 注：swift中的enum 模式匹配需要将所有情况都列举，或者使用 default 表示默认情况，否则会报错 12345678910111213// 模式匹配enum Week: String&#123; case MON, TUE, WED, THU, FRI, SAT, SUN&#125;var current: Week?switch current &#123; case .MON: print(Week.MON.rawValue) case .TUE: print(Week.TUE.rawValue) default: print(&quot;unknow day&quot;)&#125;======unknow day 关联值类型的模式匹配 关联值类型的模式匹配有两种方式： 1、switch - case， 匹配所有case；2、if - case， 匹配单个case switch - case 定义关联值枚举： 1234enum Shape&#123; case circle(radius: Double) case rectangle(width: Int, height: Int)&#125; 可以 let、var 修饰关联值的入参： 1234567891011121314151617181920212223242526272829/ 定义关联值枚举enum Shape&#123; // case枚举值后括号内的就是关联值，如 radius case circle(radius: Double) case rectangle(width: Int,height: Int)&#125;// 定义枚举变量let shape = Shape.circle(radius: 10.0)switch shape &#123; // 关联外部 case let .circle(radius): print(&quot;circle radius: \\(radius)&quot;) // 关联内部 case .rectangle(let width,var height): height += 1 print(&quot;rectangle width: \\(width) height: \\(height)&quot;)&#125;let shape2 = Shape.rectangle(width: 1, height: 2)switch shape2 &#123; case let .circle(radius): print(&quot;circle radius: \\(radius)&quot;) case .rectangle(let width,var height): height += 10 print(&quot;rectangle width: \\(width) height: \\(height)&quot;)&#125;=======circle radius: 10.0rectangle width: 1 height: 12 通过 if-case 匹配单个case，如下： 12345678// 单个匹配let circle = Shape.circle(radius: 5.0)if case let Shape.circle(radius) = circle &#123; print(&quot;circle radius: \\(radius)&quot;)&#125;=====circle radius: 5.0 如果我们只关心 不同case的相同关联值(即关心不同case的某一个值)，需要使用 同一个参数。例如，案例中的x，如果分别使用x、y, 编译器会报错： 123456789101112131415enum Shape&#123; case circle(radius: Double) case rectangle(width: Double, height: Double) case square(width: Double, height: Double)&#125;let shape = Shape.circle(radius: 10)switch shape&#123; case let .circle(x), let .square(20, x): print(x) default: break&#125;====10.0 也可以使用 通配符_（表示匹配一切） 的方式： 123456789101112131415enum Shape&#123; case circle(radius: Double) case rectangle(width: Double, height: Double) case square(width: Double, height: Double)&#125;let shape = Shape.rectangle(width: 2.0, height: 2.0)switch shape &#123;case let .rectangle(x, _), let .square(_,x): print(&quot;square：\\(x * x)&quot;)default: break&#125;=========square：4.0 注：枚举使用过程中 不关心某一个关联值，可以使用 通配符_ 表示。OC 只能调用 swift 中 Int类型 的枚举。 属性 &amp; 函数 enum 中可以包含 成员类型、计算属性、类型属性，不能包含 存储属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950enum Direct: Int &#123; // 成员类型 case up case down case left case right // 计算属性 var desc: String &#123; switch self &#123; case .up: return &quot;up&quot; case .down: return &quot;down&quot; default: return &quot;这是self&quot; &#125; &#125; // 存储属性：编译器报错，Enums must not contain stored properties // var radius: Double // 类型属性 static let height = 20.0 // 函数 func printSelf() &#123; print(desc) &#125; // 异变函数 mutating func nextDay() &#123; if self == .up &#123; self = Direct(rawValue: 1)! &#125;else &#123; self = Direct(rawValue: self.rawValue+1)! &#125; &#125;&#125;Direct.down.printSelf()// 打印结果：downvar direct = Direct.leftdirect.nextDay()// 打印结果是 rightdirect.printSelf()// 打印结果是 right 为什么 struct 或 class 中可以放 存储属性，而 enum 不可以？struct 中可以包含存储属性，是因为其大小就是 存储属性的大小。而 enum 是不一样的（请查阅后文的enum大小讲解），enum枚举的大小是取决于case的个数的，如果没有超过255，enum的大小就是1字节（8位） 可以在 enum 中定义 实例方法、static修饰的方法 12345678910111213141516171819enum Week: Int &#123; case MON, TUE, WED, THU, FRI, SAT, SUN // 实例方法 mutating func nextDay() &#123; if self == .SUN &#123; self = Week(rawValue: 0)! &#125;else &#123; self = Week(rawValue: self.rawValue+1)! &#125; &#125;&#125;// 使用var w = Week.MONw.nextDay()print(w)=========TUE 可以在 enum 中定义 下标脚本，用于获取值 1234567891011// 定义下标脚本enum Direct &#123; case east, south, west, north // 下标 subscript(index: Int) -&gt; Int&#123; return index &#125;&#125;var direct = Direct.eastprint(direct[4]) 定义 构造器 用于 初始化值 枚举与结构体和类的构造方法最大的不同在于，枚举的构造方法需要将隐式的 self 属性设置为正确的 case 1234567891011121314// 定义初始化器enum Num&#123; // 成员类型 case Small, Medium, Big, Huge // 定义初始化器 init(number n: Int) &#123; if n &lt; 10 &#123; self = .Small &#125; else if n &lt; 20 &amp;&amp; n &gt;= 10 &#123; self = .Medium &#125; else if n &lt; 30 &amp;&amp; n &gt;= 20 &#123; self = .Big &#125; else &#123; self = .Huge &#125; &#125;&#125;let num = Num(number: 30)print(num) 枚举的嵌套枚举的嵌套主要用于以下场景：1、枚举嵌套枚举：一个复杂枚举是由一个或多个枚举组成；2、结构体嵌套枚举：enum是不对外公开的，即是 私有 的。 enum 嵌套 enum 1234567891011121314enum CombineDirect &#123; // 枚举中嵌套枚举 enum BaseDirect &#123; case up,down,lett,right &#125; // 通过内部枚举组合的枚举值 case leftUp(baseDirect1: BaseDirect,baseDirect2: BaseDirect) case leftDown(baseDirect1: BaseDirect,baseDirect2: BaseDirect) case rightUp(baseDirect1: BaseDirect,baseDirect2: BaseDirect) case rightDown(baseDirect1: BaseDirect,baseDirect2: BaseDirect)&#125;// 使用let direct = CombineDirect.leftUp(baseDirect1: CombineDirect.BaseDirect.lett, baseDirect2: CombineDirect.BaseDirect.up)print(direct) 结构体 嵌套 enum 12345678910111213141516171819struct Skill &#123; // 结构体嵌套枚举 enum KeyType &#123; case up,down,lett,right &#125; // 存储属性 let key: KeyType // 函数 func launchSkill() &#123; switch key &#123; case .lett, .right: print(&quot;left,right&quot;) case .up, .down: print(&quot;up,down&quot;) &#125; &#125;&#125; 枚举的递归 枚举的递归：indirect 递归枚举 是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。你可以在枚举成员前加上 indirect 来表示该成员可递归。 12345678910111213// 一、用枚举表示链表结构enum List&lt;T&gt; &#123; case end // 表示case是用引用来存储 indirect case node(T,next: List&lt;T&gt;)&#125;// 二、也可以将indirect放在enum前// 表示整个enum是用引用来存储indirect enum List&lt;T&gt;&#123; case end case node(T, next: List&lt;T&gt;)&#125; 第一种写法，如果没有关键字 indirect，编译报错。原因是使用该枚举时，enum的大小需要case来确定，而case的大小又需要使用到enum大小。所以无法计算enmu的大小，于是报错！根据编译器提示，需要使用 关键字indirect，意思就是将该枚举标记位递归，同时也支持标记单个case。 indirect关键字 其实就是通知编译器，我当前的enum是递归的，大小是不确定的，需要 分配一块堆区的内存空间，用来存放enum。 swift 和 oc 混编 enum在 Swift 中 enum 非常强大，而在 OC 中，enum 仅仅只是一个 整数型。因此，OC调用Swift枚举，必须具备2个条件：①、用@objc关键字标记enum；②、当前enum应该是Int类型。 OC 中使用 Swift 枚举 12345678910111213// 枚举@objc enum Weak: Int &#123; case MON, TUE, WED, THU, FRI, SAT, SUN&#125;// OC 使用// 1. 用@objc关键字标记enum,当前enum应该是Int类型。// 2. 导入头文件 xxx-Swift.h- (void)testEnum&#123; Weak mon = WeakMON; NSLog(@&quot;mon:%ld&quot;,(long)mon); // 打印结果 0&#125; Swift 使用 OC 枚举，OC 中的枚举会自动转换成 swift中的enum 12345678910111213141516171819// OC定义1：NS_ENUMNS_ENUM(NSInteger,ENUM_OC_TYPE)&#123; Value1, Value2&#125;;// OC定义2：typedef enumtypedef enum&#123; Num1, num2&#125;OCEnumType;// Swift 中使用 OC 枚举// 1. 将OC头文件导入桥接文件 xxx-Bridging-Header.h#import &quot;xxx.h&quot;// 2. 使用let ocEnum1 = ENUM_OC_TYPE.Value1.rawValue;let ocEnum2 = OCEnumType.init(rawValue: 0)print(&quot;\\(ocEnum1)\\n\\(ocEnum2.rawValue)&quot;)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"OC组件化06：Github-Desktop管理工具使用","slug":"OC组件化/OC组件化06：Github-Desktop管理工具使用","date":"2023-03-04T15:47:00.000Z","updated":"2023-03-04T15:55:05.157Z","comments":true,"path":"2023/03/04/OC组件化/OC组件化06：Github-Desktop管理工具使用/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9606%EF%BC%9AGithub-Desktop%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言GitHub Desktop 简单说就是 图形界面 版的 Git，不需要命令行的操作 通过 GitHub官网 可以下载、安装使用 准备工作 注册你的 GitHub 账号，已注册 GitHub 账号的，跳过 在 GitHub Desktop 登录你的账号 创建仓库：File -&gt; new repository 创建分支：branch -&gt; new branch 创建一个开发的分支 zj_feature 克隆仓库到 GitHub Desktop File -&gt; Clone Repository 切换分支 修改工程代码，将 0.2.0 版本代码完成，并提交到新分支 zj_feature Summary：必填 0.2.0 Description：描述 0.2.0 版本的内容 Commit to zj_feature push origin 合并分支： 先切换到 main 主分支 合并分支：branch菜单 -&gt; merge into current branch 提交 main 分支 删除分支：菜单branch -&gt; delete 删除分支 版本回滚 还未提交代码：文件右键 -&gt; Discard Changes 放弃更改 已经提交代码：文件右键选择 -&gt; Revert This Commit 恢复到当前提交 使用 打开项目代码：Show in Finder 所有 新增代码 可以在工程项目中实时修改，并可以运行查看效果 在 GitHub Desktop 上可以看到实时的修改 修改完记得修改一下版本号 提交代码到 本地mian 分支 提交代码到 远程main 分支 终端搜索 ZJWeakProxy 库mac@bogon ~ % pod search ZJWeakProxy 【问题：】未搜索到自己创建的组件库 解决方法：更新本地Pod的索引文件 12mac@bogon ~ % rm ~/Library/Caches/CocoaPods/search_index.jsonmac@bogon ~ % pod repo update 如果还是搜索不到： 12mac@bogon ~ % sudo gem install -n /usr/local/bin cocoapods --pre mac@bogon ~ % pod setup 再次搜索","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"OC组件化05：【方案二】cocoapods组件化","slug":"OC组件化/OC组件化05：【方案二】cocoapods组件化","date":"2023-03-04T15:30:55.000Z","updated":"2023-03-04T15:45:45.042Z","comments":true,"path":"2023/03/04/OC组件化/OC组件化05：【方案二】cocoapods组件化/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9605%EF%BC%9A%E3%80%90%E6%96%B9%E6%A1%88%E4%BA%8C%E3%80%91cocoapods%E7%BB%84%E4%BB%B6%E5%8C%96/","excerpt":"","text":"背景 随着公司业务的不断发展，应用的代码体积将会越来越大，业务代码耦合也越来越多，代码量也是急剧增加 如果仅仅完成代码拆分还不足以解决业务之间的代码耦合，而组件化是一种能够解决代码耦合、业务工程能够独立运行的技术 这篇文章主要介绍远程私有库的创建和管理以及本地索引库的使用 本文以创建 公有库 为例 查看本地索引库 我们用 cocoaPods 的时候，默认使用的是cocoaPods自带的索引库终端中使用命令 $ pod repo 1234567891011cocoapods- Type: git (remotes/origin/master)- URL: https://github.com/CocoaPods/Specs.git- Path: /Users/mac/.cocoapods/repos/cocoapodstrunk- Type: CDN- URL: https://cdn.cocoapods.org/- Path: /Users/mac/.cocoapods/repos/trunk2 repos 组件化分类 公有库：所有人都能使用 私有库：公司内部拥有特殊权限才能使用 framework：公私都有，动态库静态库。只能看到.h文件。 准备工作 GitHub 账号一个：上传组件工程用 安装 CocoaPods：创建并验证 pod 用 安装 Git 命令行 ：首次上传组件工程用 安装 Github Desktop 或者 SourceTree：后续更新组件用的，Git命令使用熟练者忽略此项 创建公有库 首先在 Github 创建一个新的 Repository，你的 pods 最终要托管在 Github 平台上的，所以在 Github 上创建一个空的 Repository 注意：库名 = 项目前缀 + 组件名称 ，如 ZJWeakProxy &#x3D; 解决循环引用组件库 创建完成后的信息如下： 注册 cocoapods 账户 先安装 cocoapods，这个很简单，可以百度搜索自行安装 想要创建一个开源 pod 库，首先我们需要注册 cocoapods账户，基于 cocoapods 已经安装好的前提下，这里直接使用 trunk 去注册 cocopods账户，在终端执行： 12pod trunk register 邮箱地址 &#x27;用户名&#x27; --verbosemac@bogon ~ % pod trunk register 13718004742@163.com &#x27;BboyZJ&#x27; --verbose 邮箱地址：一般会使用 GitHub邮箱用户名：随便 注册之后，在邮箱会受到确认邮件 注册成功之后可以在终端 验证是否注册成功： 123// 验证是否注册成功mac@bogon ~ % pod trunk me 查看注册信息，以后可以使用该开源pod库发布工具，也可以通过此方式查看已经发布过的pods： 123456789101112mac@bogon ~ % pod trunk me - Name: BboyZJ - Email: 13718004742@163.com - Since: October 20th, 2021 19:20 - Pods: - ZJSDKDemo - ZJSDK_iOS - Sessions: - October 20th, 2021 19:20 - March 31st, 2022 04:01. IP: 114.253.15.66 Description: imac - February 27th, 02:33 - July 5th, 02:37. IP: 114.252.233.188 在本地创建pod库 利用pod命令创建名为 ZJWeakProxy 的 pod 库 注：这个名字要和 GitHub 创建的 Repository 名一致 1234# cd 到桌面文件夹(组件文件夹)ZJComponent目录下，这个不强制随意mac@bogon ~ % cd ZJComponent # 执行 pod lib create ZJWeakProxymac@bogon ~ % pod lib create ZJWeakProxy 出现 fatal: unable to access ‘https://github.com/CocoaPods/pod-template.git/‘: HTTP&#x2F;2 stream 1 was not closed cleanly before end of the underlying stream 报错 原因分析：一般这是因为服务器的 SSL 证书没有经过第三方机构的签署，所以才报错 解决办法：解除 SSL 验证，再次执行 1mac@bogon ZJComponent % git config --global http.sslVerify false 执行完上述命令后，会问你几个问题，按需求填写即可 123456789101112131415161718# 你想使用哪个平台？1、What platform do you want to use?? [ iOS / macOS ]iOS# 库语言选择？2、What language do you want to use?? [ Swift / ObjC ]ObjC# 是否需要一个demo工程，用于调试Pod？3、Would you like include a demo application with your library? [ Yes / No ]Yes# 你要使用哪个测试框架？4、Which testing frameworks will you use? [ Specta / Kiwi / None ]None# 是否要UI测试？5、Would you like to do view based testing? [ Yes / No ]NO# 类名前缀？6、What is your class prefix?ZJ 到这里 pod 库就创建完成了，它会自己打开刚才创建的pod库 工程目录介绍 目录结构如下： 【第1部分】：主要是用来编辑pod相关配置元数据区【第2部分】：主要是用来验证pod效果区【第3部分】：主要是用来 提供给别人使用暴露出来的pod，ReplaceMe空的可以删除，是提示我们可以添加自己的类 配置 podspec 本地索引文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445Pod::Spec.new do |s| # 库名称 s.name = &#x27;ZJWeakProxy&#x27; # 版本号 s.version = &#x27;0.1.0&#x27; # 库简短介绍 s.summary = &#x27;A short description of ZJWeakProxy.&#x27;# This description is used to generate tags and improve search results.# * Think: What does it do? Why did you write it? What is the focus?# * Try to keep it short, snappy and to the point.# * Write the description between the DESC delimiters below.# * Finally, don&#x27;t worry about the indent, CocoaPods strips it! # 开源库描述 s.description = &lt;&lt;-DESCTODO: Add long description of the pod here. DESC # 开源库地址，或者是博客、社交地址等 s.homepage = &#x27;https://github.com/BboyZJ/ZJWeakProxy&#x27; # s.screenshots = &#x27;www.example.com/screenshots_1&#x27;, &#x27;www.example.com/screenshots_2&#x27; # 开源协议 s.license = &#123; :type =&gt; &#x27;MIT&#x27;, :file =&gt; &#x27;LICENSE&#x27; &#125; # 开源库作者 s.author = &#123; &#x27;BboyZJ&#x27; =&gt; &#x27;13718004742@163.com&#x27; &#125; # 开源库资源文件 s.source = &#123; :git =&gt; &#x27;https://github.com/BBoyZJ/ZJWeakProxy.git&#x27;, :tag =&gt; s.version.to_s &#125; # 社交网址 # s.social_media_url = &#x27;https://twitter.com/&lt;TWITTER_USERNAME&gt;&#x27; # 开源库最低支持 s.ios.deployment_target = &#x27;10.0&#x27; # 开源库源文件 s.source_files = &#x27;ZJWeakProxy/Classes/**/*&#x27; # 添加图片等资源文件 # s.resource_bundles = &#123; # &#x27;ZJWeakProxy&#x27; =&gt; [&#x27;ZJWeakProxy/Assets/*.png&#x27;] # &#125; # s.public_header_files = &#x27;Pod/Classes/**/*.h&#x27; # 依赖系统库 多个用逗号隔开 # s.frameworks = &#x27;UIKit&#x27;, &#x27;MapKit&#x27; # 引入第三方依赖库 # s.dependency &#x27;AFNetworking&#x27;, &#x27;~&gt; 2.3&#x27;end 【s.dependency】：设置依赖三方库或其他组件，多个库可以分开写多次 需要注意如图： Readme 主要是介绍这个组件的用途和使用，可以随时编辑。目前就确认一下自己的名字和邮箱就可以了 协议文件，也是确认一下自己的名字和邮箱就可以了 添加自己的类 打开pod库目录，删除ReplaceMe 创建 ZJWeakProxy 简单类，声明一个打印函数，方便后续测试 注：创建类文件一定要放到 Classes 目录下 .h 文件下 12345#import &quot;ZJWeakProxy.h&quot;@interface ZJWeakProxy : NSProxy- (void)printZJWeakProxy;@end .m 文件下 1234567#import &quot;ZJWeakProxy.h&quot;@implementation ZJWeakProxy- (void)printZJWeakProxy&#123; NSLog(@&quot;%s&quot;,__func__);&#125;@end 此时 cd 到 Example 路径下执行 pod install 命令，看看是否能将刚刚添加的库文件引入到工程中 12mac@bogon ~ % cd /Users/mac/Desktop/ZJComponent/ZJWeakProxy/Example mac@bogon Example % pod install 如果成功会在Pods中看到： 可以到项目中导入头文件简单使用一下 证明是可用的 【注】：CocoaPods 工具的另外一个优点就是，多个组件依赖同一个组件时，它会自动帮你检测安装，而 不会重复导入。 项目上传与发布 cd到你的项目路径下，将项目上传到GitHub中（即刚刚创建的ZJWeakProxy公有库中），依次使用下列命令行，不要遗漏 123456789101112# cd 到 组件ZJWeakProxy路径下mac@bogon Example % cd /Users/mac/Desktop/ZJComponent/ZJWeakProxy# 添加github项目路径mac@bogon ZJWeakProxy % git remote add origin https://github.com/BboyZ/ZJWeakProxy.git# 添加文件mac@bogon ZJWeakProxy % git add .# 将暂存区里的改动提交到本地的版本库mac@bogon ZJWeakProxy % git commit -m &quot;first commit&quot;# 创建分支mainmac@bogon ZJWeakProxy % git branch -M main# 提交版本号并push到main分支mac@bogon ZJWeakProxy % git push -u origin main 在执行 git push -u origin main 时，如果遇到需要输入用户名和密码： 12Username for &#x27;https://github.com&#x27;: BboyZJPassword for &#x27;https://BboyZJ@github.com&#x27;: 【注意】：这个 密码 不是你 GitHub 的登录密码，而是需要生成一个 access tokens 生成 access token 需要在 GitHub 个人设置页 -&gt; Settings -&gt; Developer Settings -&gt; Personal access tokens 中创建一个 token Generate new token 生成新的 token 设置 token 的有效期 按需设置，访问权限等 选择要授予令牌token的范围或权限 要使用token从命令行访问仓库，请选择repo 要使用token从命令行删除仓库，请选择delete_repo 其他根据需要进行勾选 点击 Generate token 生成 token ghp_VcqgAmF...ZPJ2IGxu0 【注】：记得把这个 token 保存下来，因为下次再刷新这个页面的时候，你会看不到了 在命令行输入完 token 密码 123456789101112Username for &#x27;https://github.com&#x27;: BboyZJPassword for &#x27;https://BboyZJ@github.com&#x27;: Enumerating objects: 91, done.Counting objects: 100% (91/91), done.Delta compression using up to 4 threadsCompressing objects: 100% (83/83), done.Writing objects: 100% (91/91), 29.35 KiB | 2.45 MiB/s, done.Total 91 (delta 23), reused 0 (delta 0), pack-reused 0remote: Resolving deltas: 100% (23/23), done.To https://github.com/BboyZJ/ZJWeakProxy.git * [new branch] main -&gt; mainbranch &#x27;main&#x27; set up to track &#x27;origin/main&#x27;. 由上面看代表上传成功了 打开浏览器 https://github.com/BboyZJ/ZJWeakProxy ，就可以看到你的pod库已经push上去了 打 tag 并发布到 Cocoapods至此，我们已经成功将本地的仓库关联并推送到远程仓库，现在我们需要发布一个可用的组件 首先我们要给当前项目打一个 tag 版本号，在 podspec 中： 1s.version = &#x27;0.1.0&#x27; 指定的版本号是 0.1.0 ，那么我们就同样打个 0.1.0 的 tag 1234// 打 tag mac@bogon ZJWeakProxy % git tag 0.1.0// 推送到远程mac@bogon ZJWeakProxy % git push --tags 打 tag 默认在当前分支上，这里只有 master ，所以不用切换分支 发布到 cocoapods 我们创建的项目以及标签版本号都是沿用了 podspec 文件中的信息，因此可以直接验证 podspec 文件信息是否可以通过验证，podspec 文件的版本号一定要和 tag 保持一致 1mac@bogon ZJWeakProxy % pod spec link 如果通过验证，那么你会看到类似下面的提示，绿色的 passed validation 首先要通过 trunk 注册生成一条会话： 12// pod trunk register 邮箱 用户名 描述mac@bogon ZJWeakProxy % pod trunk register 13718004742@163.com BboyZJ --description=ZJWeakProxy组件 然后去邮箱进行验证，验证成功会出现下面页面： 现在，就可以将 podspec 提交给 CocoaPods 了。这个文件将是别人搜索你的组件的索引。 1mac@bogon ZJWeakProxy % pod trunk push ZJWeakProxy.podspec --allow-warnings pod search 组件名 上传完成之后，接可以通过 pod search ZJWeakProxy 搜索到自己的组件了，如果搜索不到，删除本地的搜索文件，命令 ： 1mac@bogon ZJWeakProxy % rm ~/Library/Caches/CocoaPods/search_index.json 重新 search 产生新的搜索文件，发布新版本则需要打新的 tag，重新编辑 podspec 文件，然后再次提交给 CocoaPods。 集成到宿主工程经过上面的操作我们已经完成了组件的创建和发布，也支持了 Cocoapods 的集成。现在我们需要将该组件集成到宿主工程中去，使用方式和集成三方库是一样的。 新建个带 pod 的项目 Demo，把我们做好的 ZJWeakProxy 加入 podfile 文件 12345678910111213# Uncomment the next line to define a global platform for your projectplatform :ios, &#x27;10.0&#x27;target &#x27;ZJWeakProxy-Demo&#x27; do # Comment the next line if you don&#x27;t want to use dynamic frameworks use_frameworks! # ZJWeakProxy pod &#x27;ZJWeakProxy&#x27;,:git =&gt;&quot;https://github.com/BboyZJ/ZJWeakProxy.git&quot; # Pods for ZJWeakProxy-Demoend 执行 pod install mac@bogon ZJWeakProxy-Demo % pod install 【问题1】安装报错：[!] Unable to find a specification for ZJWeakProxy 解决办法： mac@bogon ZJWeakProxy-Demo % pod repo update --verbose 【问题2】：HTTP&#x2F;2 stream 1 was not closed cleanly before end of the underlying stream 解决办法：更改默认通信协议 mac@bogon ZJWeakProxy-Demo % git config --global http.version HTTP/1.1 引入头文件并打印结果 版本更新与维护 现在的 ZJWeakProxy 库已经在GitHub上托管了，以后维护这个项目就可以了（开始本地创建的ZJWeakProxy项目就可以删除了），管理GitHub仓库，有两种方案： 可以使用命令行 git clone https://github.com/BboyZJ/ZJWeakProxy 也可以使用 GitHub Desktop 下载 GitHub Desktop 登录你的用户名和密码，File -&gt; Responsitory 其实 GitHub Desktop 更加可视化一些，上面History就是刚才git命令行的记录 总结终于写完了，哇哦😮！","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"OC组件化04：【方案一】本地组件化","slug":"OC组件化/OC组件化04：【方案一】本地组件化","date":"2023-03-04T15:27:35.000Z","updated":"2023-03-04T15:31:43.723Z","comments":true,"path":"2023/03/04/OC组件化/OC组件化04：【方案一】本地组件化/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9604%EF%BC%9A%E3%80%90%E6%96%B9%E6%A1%88%E4%B8%80%E3%80%91%E6%9C%AC%E5%9C%B0%E7%BB%84%E4%BB%B6%E5%8C%96/","excerpt":"","text":"前言 本地组件化：主要是通过在 工程中创建library，利用 cocoapods 的 workspec 进行本地管理，不需要将项目上传git，而是直接在本项目中以 framework 的方法进行调用 创建主工程 首先创建一个名为 Modularization 的工程 集成 cocoapods，进行本地管理 1234zhangjian@zhangjiandeMBP ~ % cd /Users/zhangjian/Desktop/Modularization zhangjian@zhangjiandeMBP Modularization % pod initIgnoring ffi-1.13.1 because its extensions are not built. Try: gem pristine ffi --version 1.13.1zhangjian@zhangjiandeMBP Modularization % pod install 创建组件假设有以下几个模块 主工程：承载主要的表层业务代码 Core：独立存在，应用加密、接口请求等敏感代码 Base：基类封装，拓展，基本的数据处理 Service：服务层，封装业务工具类，例如网络层服务、持久化服务等 Pods：三方依赖 其中，各个模块间的关系如下图 下面，我们来进行模块的创建，以 Core 模块为例： 选择 File -&gt; new -&gt; project -&gt; iOS -&gt; Framework，新建一个 ZJCore 模块 选择正确的 Group 和 WorkSpace（这里注意：创建的 library 最好放在 主工程根目录下，否则后续的 podfile 执行 pod install 会报错） 创建成功后，看到的结果如下： 将创建的 library 的 Build Settings -&gt; Mach-O Type 修改为静态库 Static Library 主工程调用Library 在 ZJCore 中新建一个文件，并添加如下代码 1234567@interface ZJCoreSetting : NSObject// 声明属性@property (nonatomic,copy)NSString * name;@end@implementation ZJCoreSetting@end 在 Build Phases -&gt; Headers -&gt; Public 中将新建的文件拖拽到 Puclic 中，这样主工程才能访问该文件 在ZJCore文件中添加引用 在主工程中，选择 target -&gt; Frameworks,Libraries,and Embedded Content -&gt; + 号 -&gt; 添加 ZJCore，只需要build主工程，library能够自动联编 使用首先 #import &lt;ZJCore/ZJCoreSetting.h&gt;，然后使用 这里需要注意的是，子library之间的互相调用，与主工程调用library类似，主需要添加依赖、暴露header即可","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"OC组件化03：面向协议Protocol Class的使用","slug":"OC组件化/OC组件化03：面向协议Protocol-Class的使用","date":"2023-03-04T08:16:42.000Z","updated":"2023-03-04T14:56:27.815Z","comments":true,"path":"2023/03/04/OC组件化/OC组件化03：面向协议Protocol-Class的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AEProtocol-Class%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"面向协议 Protocol Class 在 URL Scheme路由 和 target-action 方案中，都存在 硬编码、参数不明确问题：URL 、Target_ 、 Action_ 的硬编码，参数都是通过字典的形式传递，类型不明确。 面向接口 的方式能够很好的解决这两个问题。 实现方式 中间件先注册 Protocol 和 Class 对应关系，将 protocol 和 对应的类 进行 字典 匹配 中间件返回 Protocol 对应的 Class，然后动态创建实例 优点 面向协议编程 安全性高 模块解耦 缺点 无法多端通用 需要进行协议的注册 示例 创建 ZJProtocol.h 协议类文件 12345678910// 将各个模块的协议统一放在一个文件中 ，在各个模块中依赖这个文件，实现其协议@protocol OneMoudleProtocol &lt;NSObject&gt;@required // 返回模块one+ (UIViewController *)oneMoudleVC;@end@protocol OneDetailMoudleProtocol &lt;NSObject&gt;@required+ (UIViewController *)oneDetailMoudleVCWithParas:(NSDictionary *)paras;@end 创建 ZJMediator 协议管理类 ZJMediator.h 文件下： 12345678@interface ZJMediator : NSObject// 单例+ (instancetype)shareManager;// 注册绑定- (void)registerProtocol:(Protocol *)protocol class:(Class)cls;// 获取类- (Class)classFromProtocol:(Protocol *)protocol;@end ZJMediator.m 文件下： 1234567891011121314151617181920212223242526272829303132#import &quot;ZJMediator.h&quot;@interface ZJMediator ()@property (nonatomic,strong)NSMutableDictionary * protocolCache;@end@implementation ZJMediator+ (instancetype)shareManager&#123; static ZJMediator * mediator; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; mediator = [[ZJMediator alloc] init]; &#125;); return mediator;&#125;// 注册绑定- (void)registerProtocol:(Protocol *)protocol class:(Class)cls&#123; if (protocol &amp;&amp; cls) &#123; [self.protocolCache setObject:cls forKey:NSStringFromProtocol(protocol)]; &#125;&#125;// 获取类- (Class)classFromProtocol:(Protocol *)protocol&#123; return [self.protocolCache objectForKey:NSStringFromProtocol(protocol)];&#125;// 懒加载- (NSMutableDictionary *)protocolCache&#123; if (!_protocolCache) &#123; _protocolCache = @&#123;&#125;.mutableCopy; &#125; return _protocolCache;&#125;@end 创建 OneDetailMoudleEntry 模块 123456789101112131415161718#import &quot;OneDetailMoudleEntry.h&quot;#import &quot;ZJOneDetailViewController.h&quot;@interface OneDetailMoudleEntry ()&lt;OneDetailMoudleProtocol&gt;@end@implementation OneDetailMoudleEntry+ (void)load&#123; [[ZJMediator shareManager] registerProtocol:@protocol(OneDetailMoudleProtocol) class:[self class]];&#125;// 继承+ (UIViewController *)WithParas:(NSDictionary *)paras&#123; ZJOneDetailViewController * detailVC = [[ZJOneDetailViewController alloc] init]; detailVC.name = paras[@&quot;name&quot;]; detailVC.age = params[@&quot;age&quot;]; return detailVC;&#125;@end 在任何地方调用 1234567//下一页的点击事件- (void)next:(UIButton *)sender&#123; Class cls = [[ZJMediator shareManager] classFromProtocol:@protocol(OneDetailMoudleProtocol)]; UIViewController * detailVC = [cls oneDetailMoudleVCWithParas:@&#123;@&quot;name&quot;:@&quot;ZJ&quot;,@&quot;age&quot;:30&#125;]; [self.navigationController pushViewController:detailVC animated:YES];&#125;","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"OC组件化03：基于RuntTime的target-action的使用","slug":"OC组件化/OC组件化03：基于RuntTime的target-action的使用","date":"2023-03-04T08:16:13.000Z","updated":"2023-03-04T15:12:11.241Z","comments":true,"path":"2023/03/04/OC组件化/OC组件化03：基于RuntTime的target-action的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E5%9F%BA%E4%BA%8ERuntTime%E7%9A%84target-action%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言target action 是利用 Runtime 的 performSelector:withObject: 方法调用，无需注册 优缺 优点：无需注册路由，避免了load里注册影响启动速度 不用维护全局路由表，避免了查找对应路由 统一了路由入口 进行了一定的安全处理 缺点 缺点：不能多端使用同一套路由H5，Android 增加了文件，同时在获取target，sel时存在一定的硬编码 示例：","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"OC组件化02：基于URL Scheme的使用","slug":"OC组件化/OC组件化02：基于URL-Scheme的使用","date":"2023-03-04T08:15:30.000Z","updated":"2023-03-04T15:02:44.049Z","comments":true,"path":"2023/03/04/OC组件化/OC组件化02：基于URL-Scheme的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9602%EF%BC%9A%E5%9F%BA%E4%BA%8EURL-Scheme%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"URL Scheme 路由 使 URL Scheme 处理本地的跳转 通过中间层进行注册 &amp; 调用（load方法里面把被调用者注册到中间层） 命名规范12//协议://主机名[:端口]/路径/[?参数]#fragment@&quot;lstest://lsapp:11111/china/ls.com?a=1&amp;b=2&quot; lstest：协议名 lsapp：主机名，为了区分 不同的app 端口号：可以将端口号作为 模块ID china&#x2F;ls.com：路径，可以是跳转到模块的 指定页面 a&#x3D;1&amp;b&#x3D;2：参数，跳转的参数 解析 优缺点 优点：实现简单 缺点：存在硬编码问题，参数都是通过字典的形式传递，类型不明确 URL Scheme 路由示例思路：B组件使用URL将Block注册给路由，路由以URL为key，将Block存储起来。 A组件通过URL调用路由的方法，找到对应的Block，完成对A的调用 创建路由 123456789101112131415161718192021222324252627282930313233#import &quot;ZJRouter.h&quot;@interface ZJRouter ()@property (strong,nonatomic)NSMutableDictionary * blockDic;@end@implementation ZJRouter// 参数 @&#123;@&quot;&quot;:...&#125;+ (instancetype)shareInstance&#123; static ZJRouter * router = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; router = [[self alloc] init]; router.blockDic = @&#123;&#125;.mutableCopy; &#125;); return router;&#125;// 注册- (void)registerUrl:(NSString *)url block:(ZJRouterBlock)block&#123; if (!url || !block) return; if (block) &#123; self.blockDic[url] = [block copy]; &#125;&#125;// 执行- (void)excuteBlockWithUrl:(NSString *)key params:(NSDictionary *)params&#123; if (!key) return; ZJRouterBlock block = self.blockDic[key]; if (!block) return; block(params);&#125;@end B 组件中注册 12345+ (void)load &#123; [[ZJRouter shareInstance] registerUrl:@&quot;A:aTestAction&quot; block:^(NSDictionary * _Nonnull dic) &#123; NSLog(@&quot;dic:%@&quot;,dic); &#125;];&#125; A 组件中调用 1[[ZJRouter shareInstance] excuteBlockWithUrl:@&quot;A:aTestAction&quot; params:@&#123;@&quot;text&quot;:@&quot;文字&quot;&#125;];","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"OC组件化01：组件化介绍","slug":"OC组件化/OC组件化01：组件化介绍","date":"2023-03-04T06:05:40.000Z","updated":"2023-03-04T15:26:25.315Z","comments":true,"path":"2023/03/04/OC组件化/OC组件化01：组件化介绍/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9601%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"什么组件化 组件化其实就是 将模块单独抽离、分层，并指定模块间的 通讯 方式，从而实现 解耦 的一种方式，主要运用与团队开发 组件化开发就是将一个臃肿的、单一的项目，根据 功能/业务/技术 等进行拆分，形成一个个独立的功能组件，然后借助 Cocoapods 管理工具将其任意组合，集成一个完整的项目。 你可以将 AFNetworking、SDWebImage、Bugly、MLeaksFinder 等三方库理解为工程的一部分，属于 基础组件模块，我们要做的就是将项目划分多个独立功能模块，再集成一个完整的项目。 为什么要组件化？主要有以下四个原因 模块间解耦 模块重用 提高团队协作开发效率 单元测试 当项目因为各种需求，模块越来越多时，如果此时的各个模块之间是互相调用的，即 你中有我，我中有你 这种情况时，会造成 高耦合 的情况，一旦我们需要对某一模块代码进行 修改 时，就会 牵一发而动全身，导致项目难以维护 其问题主要体现在以下几个方面： 修改某个功能时，同时需要修改其他模块的代码，因为在其他模块中有该模块的引用，可以理解为 高耦合导致代码修改困难 模块对外接口不明确，甚至暴露了本不该暴露的私有接口，修改时费时费力。可以理解为 接口不固定导致的接口混乱 高耦合代码产生的后果就是会影响团队其他成员的开发，产生 代码冲突 当模块需要重用到其他项目时，难以单独抽离 模块间耦合的忌口导致接口和依赖关系混乱，无法进行单元测试 所以为了解决以上问题，我们需要采用更规范的方式来 降低模块 间的 耦合度，这就是 组件化，也可以理解为 模块化 但是，这里还需要说明一点，因为组件化也是需要一定成本的，需要花费时间设计接口、分离代码等，所以并不是所有的项目都需要组件化。如果你的项目有以下这些特征就 不需要组件化： 项目较小，模块间交互简单，耦合少 项目没有被多个外部模块引用，只是一个单独的小模块 模块不需要重用，代码也很少被修改 团队规模很小 不需要编写单元测试 如果你的有以下特性，说明你就必须要 考虑进行组件化 了： 模块逻辑复杂，多个模块之间频繁互相引用 项目规模逐渐变大，修改代码变的越来越困难（这里可以理解为：修改一处代码，需要同时修改其他多个地方） 团队人数变多，提交代码经常和其他成员冲突 项目编译耗时较大 模块的单元测试经常由于其他模块的修改而失败 组件化方案组件化方案的8条指标： 一个项目经过组件化后如何来评判，主要有以下几个 标准： 模块之间没有耦合，模块内部的修改不会影响其他模块 模块可以单独编译 模块间数据传递明确 模块对外接口清晰且易维护 当模块接口改变时，此模块的外部代码能够被高效重构 尽量用最少的修改和代码，让现有项目实现模块化 支持OC和Swift，以及混编 前4条主要用于 衡量一个模块是否真正解耦，后4条主要用于衡量在项目中 实践中的易用程序 组件化原则 一个项目主要分为3层：业务层、通用层 以及 基础层，在进行组件化时，有以下几点说明 只能上层对下层依赖，不能下层对上层依赖，因为下层是对上层的抽象 项目公共代码资源下沉 横向的依赖尽量减少，最好下层至通用模块，或者基础模块 组件化和非组件化区别组件化能够帮助我们将大部分项目拆解成数个小组件，开发者只需要关注组件所依赖的其他组件，而无需关心完整项目的其他部分，每个组件可以自己采取所习惯的架构模式：MVC、MVVM等，就行开发一款个人独立的App那样自由 非组件化： 代码高耦合度、高依赖 项目复杂、臃肿、编译时间过长（影响调试） 难以融合、集成其他产品 … 组件化： 代码复用性提高，可方便集成到其他项目 项目可配置，方便集成和功能回退 方便组件并行开发 可方便单元测试 … 组件化分层项目组件化，最难的就是 粒度 问题，需要开发者根据自己的经验把控。这里给出个人认为的层次划分： 【基础组件】：宏定义&#x2F;常量&#x2F;自定义工具类，如常用的自定义分类【功能组件】：项目中常用的功能，如地图&#x2F;消息推送&#x2F;分享&#x2F;登录等【业务组件】：项目中的模块&#x2F;业务，如文章详情&#x2F;个人中心等【中间组件】：负责项目中的路由&#x2F;消息通知&#x2F;传参&#x2F;回调等【宿主工程】：项目容器，用来集成组件，调整各个组件之间的消息传递容器 中间层几种方案在组件化中，中间层是各个组件的通信桥梁，中间层在组件化过程中扮演着非常重要的角色。 中间层的三种方式： 基于 URL Scheme 的 路由 基于 Runtime 的 target-action 面向接口 的 Protocol - Class 基于 URL Scheme 的三方库iOS 中支持的 URL Scheme 让我们能够在 应用之间、应用内部传递消息。 JLRoutes routable-ios HHRouter 具体怎么使用，可以自行去探索 基于 Runtime 的 target-action相比 url scheme 的提前注册、实现服务，CTMediator 借助 OC 运行时的特性，现实组件之间服务的自动发现，无需提前注册即可实现组件间的调用，因此，这种方案的可维护性、可读性、扩展性相对较高。 CTMediator 面向接口 Protocol - Class Protocol - Class 面向接口的方案通常由两部分组成，一个是用来管理接口协议的类（ProtocolManager），一个是具体的接口协议（ComponentProtocol） 组件化的核心工具 组件化工程，需要一个宿主工程，负责集成所有的组件。每个组件都是一个单独的工程，通过 Git 私有仓库来管理。 所有组件都上传到 Git 仓库并支持 cocoapods 集成。主工程通过配置 Podfile 文件，然后一键 pod update 即可。使用 Cocoapods 来管理组件主要因为其本身功能强大，方便的集成整个项目，解放对依赖库的管理。使用组件化的集成方式，可以很好的避免传统项目中的代码冲突问题。 组件化的核心工具就是 CocoaPods ，我们要做的就是将组件项目上传到 Gitee码云 或者 Gitlab极狐，编写项目的 podSpec 文件让组件支持 CocoaPods 集成即可。","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"Swift学习37：对象","slug":"Swift课程/Swift学习37：面向对象编程","date":"2023-03-03T16:37:01.000Z","updated":"2023-03-09T08:36:50.781Z","comments":true,"path":"2023/03/04/Swift课程/Swift学习37：面向对象编程/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A037%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","excerpt":"","text":"swift面向对象概述面向对象的三大特性 继承 封装 多态 基本单元 枚举 结构体 类 协议 扩展 面向对象概述 从整体功能上看 swift 的枚举、结构体、类三者具有完全平等的地位 swift 的类、结构体、枚举中都可以定义（属性、方法、下标、构造体、嵌套类型） 在swift中，枚举和结构体 是 值类型，类 是 引用类型 类和结构体的相似点 定义属性用来存储值 定义方法用来提供功能 定义下标脚本用来允许使用下标语法访问值 定义初始化器用来初始化状态 可以被扩展来默认所没有的功能 遵循协议来针对特定类型提供标准功能 类和结构体不同点 继承允许一个类继承另一个类的特性 类型转换允许你再运行检查和解释一个类实例的类型 反初始化器允许一个类实例释放任何其被分配的资源 引用计数器允许不止一个类对实例的引用","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习36：函数式编程","slug":"Swift课程/Swift学习36：函数式编程","date":"2023-03-03T14:56:24.000Z","updated":"2023-03-09T07:24:47.862Z","comments":true,"path":"2023/03/03/Swift课程/Swift学习36：函数式编程/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A036%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"范式转换-函数式读入一个文本，确定所有单词的使用频率并从高到低排序，打印出所有单词及其频率的排序列表 命令式编程 风格尝尝迫使我们出于性能考虑，把不同的任务交织起来，以便能够用一次循环来完成多个任务 123456789101112131415161718192021222324252627282930let words = &quot;&quot;&quot;This rectangle defines the size and position of the view in its superview’s coordinate system.&quot;&quot;&quot;let NON_WORDS = [&quot;e&quot;,&quot;of&quot;,&quot;end&quot;,&quot;on&quot;]func wordFrep(words: String) -&gt; [String:Int] &#123; var wordDict: [String:Int] = [:] // 分割成一个数组 let wordList = words.split(separator: &quot; &quot;) // 遍历数组 for word in wordList &#123; // 数组每个元素转小写 let lowercaseWord = word.lowercased() // 不包含元素 if !NON_WORDS.contains(lowercaseWord) &#123; // 有count if let count = wordDict[lowercaseWord] &#123; wordDict[lowercaseWord] = count + 1 &#125;else &#123; // 无count wordDict[lowercaseWord] = 1 &#125; &#125; &#125; return wordDict&#125;print(wordFrep(words:words))============[&quot;and&quot;: 1, &quot;superview’s&quot;: 1, &quot;system.&quot;: 1, &quot;view&quot;: 1, &quot;defines&quot;: 1, &quot;its&quot;: 1, &quot;coordinate&quot;: 1, &quot;in&quot;: 1, &quot;the&quot;: 2, &quot;rectangle&quot;: 1, &quot;this&quot;: 1, &quot;size&quot;: 1, &quot;position&quot;: 1] 而 函数式编程 用 map()、filter() 这些高级函数把我们解法出来，让我们站在更高的抽象层次上去考虑问题，把问题看的更清楚 1234567891011121314151617// 函数式写法func wordFrep2(words: String) -&gt; [String:Int] &#123; var wordDict: [String:Int] = [:] // 分割成一个数组 let wordList = words.split(separator: &quot; &quot;) // map：尾随闭包的方式 wordList.map &#123; $0.lowercased() &#125; .filter &#123; !NON_WORDS.contains( $0 ) &#125; .forEach &#123; wordDict[$0] = (wordDict[$0] ?? 0) + 1 &#125; return wordDict&#125;print(wordFrep2(words:words))=============[&quot;view&quot;: 1, &quot;its&quot;: 1, &quot;and&quot;: 1, &quot;defines&quot;: 1, &quot;in&quot;: 1, &quot;the&quot;: 2, &quot;size&quot;: 1, &quot;this&quot;: 1, &quot;position&quot;: 1, &quot;coordinate&quot;: 1, &quot;superview’s&quot;: 1, &quot;system.&quot;: 1, &quot;rectangle&quot;: 1] 函数式编程-简洁 函数式编程简洁，面向对象编程 通过 封装不确定因素 来使代码能够被人理解，函数式编程 通过 尽量减少少不确定因素 来使代码能够被人理解 在面向对象的命令式编程语言里，重用的单元是类和类之间沟通用的消息 函数式编程语言实现重用的思路很不一样。函数式语言提倡在有限的几种关键数据结果（如：list、set、map）上运用针对这些数据结构高度优化过的操作，以此构建成基本的运转机构。开发者再根据具体用途，插入自己的数据结构和高阶函数去调整机构的运转方式 比起以为创建新的类结构体系，把封装的元素降低到函数级别，更有利达到细粒度的、基础层面的重用 函数式程序员喜欢用少数几个核心数据结构，围绕它们去建立一套充分优化的运转机构。面向对象程序员喜欢不断的创建新的数据结构和附属的操作，因为压倒一切的面向对象编程范式就是建立新的类和类间的消息。把所有的数据结构封装成类，一方面压制了方法层面的重用，另一方面鼓励了大粒度的框架式重用。函数式编程的程序结构方便我们在比较细小的层面上重用代码 业务需求 假设我们有一个名字列表，其中一些条目由单个字符组成。现在的任务是，将除去单字符条目之外的列表内容，放在一个逗号分割的字符串里返回，且每个名字的首字母都要大写 命令式解法 命令式编程是按照 程序是一系列改变状态的命名 来建模的一种编程风格。传统的 for 循环是命令式风格的句号例子 12345678910111213141516let names = [&quot;neal&quot;,&quot;s&quot;,&quot;stu&quot;,&quot;h&quot;,&quot;rich&quot;]func cleanNames(names: Array&lt;String&gt;) -&gt; String &#123; var cleanedNames = &quot;&quot; for name in names &#123; if name.count &gt; 1 &#123; cleanedNames += name.capitalized + &quot;,&quot; &#125; &#125; // 去掉最后一个, cleanedNames.remove(at: cleanedNames.index(before: cleanedNames.endIndex)) return cleanedNames&#125;print(cleanNames(names: names))==========Neal,Stu,Rich 函数式解法 函数式编程将程序描述为 表达式和变换，以数学方程的形式建立模型，并且尽量避免可变的状态。 12345678910111213141516// 函数式解法let names = [&quot;neal&quot;,&quot;s&quot;,&quot;stu&quot;,&quot;h&quot;,&quot;rich&quot;]// 过滤let cleanedNames = names.filter &#123; $0.count &gt; 1 &#125;print(cleanedNames)// 首字母大写let cleanedNames2 = cleanedNames.map &#123; $0.capitalized &#125;print(cleanedNames2)// 拼接let cleanedNames3 = cleanedNames2.joined(separator: &quot;,&quot;)print(cleanedNames3)=========[&quot;neal&quot;, &quot;stu&quot;, &quot;rich&quot;][&quot;Neal&quot;, &quot;Stu&quot;, &quot;Rich&quot;]Neal,Stu,Rich 上面的方式还可以简写： 12345678// 简写let cleanedName = names.filter &#123; $0.count &gt; 1 &#125; .map &#123; $0.capitalized &#125; .joined(separator: &quot;,&quot;)print(cleanedName)========Neal,Stu,Rich 具有普遍意义的基本构造单元 筛选：filter 映射：map 折叠&#x2F;化约：foldLeft/reduce 等 swift 的劣势-并行 不是线程安全的 123456789101112131415161718192021222324252627282930// 函数式let names = [&quot;neal&quot;,&quot;s&quot;,&quot;stu&quot;,&quot;h&quot;,&quot;rich&quot;,&quot;ff&quot;,&quot;sag&quot;]let cleanedName = names.filter &#123; $0.count &gt; 1 &#125; .map &#123; $0.capitalized &#125; .joined(separator: &quot;,&quot;)print(cleanedName)// 数组的扩展extension Array where Element : Any &#123; // 函数 public func currentMap&lt;T&gt;(_ transform: (Element) -&gt; T) -&gt; [T] &#123; let n = self.count if n == 0 &#123; return [] &#125; var result = Array&lt;T&gt;() // 初始化一个数组 result.reserveCapacity(n) DispatchQueue.concurrentPerform(iterations: n) &#123; i in result.append(transform(self[i])) &#125; return result &#125;&#125;// 并行写法let cleanedName2 = names.filter &#123; $0.count &gt; 1 &#125; .currentMap &#123; $0.capitalized &#125; .joined(separator: &quot;,&quot;)print(cleanedName2)========Neal,Stu,Rich,Ff,SagStu,Neal,Rich,Ff,Sag 有结果可知：打印的顺序不同，或者会少，说明线程不安全","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习34：闭包","slug":"Swift课程/Swift学习34：闭包","date":"2023-03-03T14:56:01.000Z","updated":"2023-03-13T21:00:02.844Z","comments":true,"path":"2023/03/03/Swift课程/Swift学习34：闭包/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A034%EF%BC%9A%E9%97%AD%E5%8C%85/","excerpt":"","text":"闭包的概念 闭包是 可以在你的代码中被传递和引用的功能性独立代码块 闭包能够 补获和存储上下文的常量和变量。这就是所谓的闭合并包裹哪些常量和变量，因此称为 闭包，Swift能够为你处理所有关于补获的内存管理操作 全局和内嵌函数，实际上是 特殊的闭包。闭包符合以下三种形式的一种 全局函数：是一个 有名字但不会补获任何值 的 闭包 内嵌函数：是一个 有名字且能从其上下层函数补获值 的 闭包 闭包表达式：是一个轻量级语法所写的 可以补获其上下文中常量和变量值的没有名字的闭包 闭包的作用 闭包可以作为函数的 参数 也可以作为函数的 返回值 闭包可以像 oc 中用于 回调和反向传值 设置属性默认值 闭包 可以为 存储属性 设置默认值 1234567891011// 通过闭包设置默认值class Person &#123; var name: String &#123; return &quot;ZJ&quot; &#125;&#125;let p = Person()print(p.name)=====ZJ 全局函数 全局函数： 是一种特殊的闭包，定义一个全局函数，只是当前的全局函数并不捕获值。 1234// 有名字但不会补获值的闭包func test()&#123; print(&quot;test&quot;)&#125; 内嵌函数： 全局函数： 是一种特殊的闭包，可以捕获值的闭包。函数中的 incrementer 是一个 内嵌函数，可以从 makeIncrementer 中捕获变量 runningTotal。 123456789101112func makeIncrementer() -&gt; () -&gt; Int&#123; var runningTotal = 10 // 内嵌函数，有名字会从上下层函数补获值的闭包 func incrementer() -&gt; Int&#123; runningTotal += 1 return runningTotal &#125; return incrementer&#125;let incre = makeIncrementer()print(incre() 闭包表达式 闭包表达式 &#x2F; 匿名函数：下面是一个 闭包表达式，即一个 匿名函数，而且可以 从上下文中捕获变量和常量。 1234// 闭包表达式：没有名字能从上下文补获值的闭包&#123; (参数列表) -&gt; 返回值类型 in // 主体内容&#125; 参数可以有多个，用 , 号隔开 参数的 () 可以省略 返回值类型也可以省略 当没有参数时 in 可以省略 in 可以看做是一个分隔符，将主体内容和前面的参数、返回值分割开 闭包表达式特点：是一个 匿名函数，所有代码都在花括号 &#123;&#125; 内，参数和返回值类型 在 in关键字 之前，in关键字 之后是 主体内容(类似方法体)。 1、有参数、有返回值 123456// 声明一个闭包 赋值 给常量 testlet test: (String,String) -&gt; String = &#123; (str1,str2) -&gt; String in return str1 + str2&#125;print(test(&quot;Z&quot;,&quot;J&quot;))// 打印结果 ZJ : 的右边是闭包的类型，&#x3D; 右边就是一个闭包表达式，也可以理解为一个闭包&#x3D; 右边是严格按照了闭包表达式来写的，有参数，有括号，有返回值。下面看一下闭包表达式的简写： 12345// 简写let test = &#123; str1,str2 -&gt; String in return str1 + str2&#125;print(test(&quot;Z&quot;,&quot;J&quot;)) 实际上和上面是等价的，闭包表达式省去了参数的括号。：右边的闭包类型省去了是因为swift编译器能自动根据 &#x3D; 右边去判断类型 2、无参无返回值 123456// 无参无返回值let test: () -&gt; Void = &#123; () -&gt; Void in print(&quot;ZJ&quot;)&#125;test()// 打印结果 ZJ 因为无返回值，我们可以直接调用查看打印结果下面看一下闭包表达式简写： 12345// 简写let test = &#123; print(&quot;ZJ&quot;)&#125;test() 因为没有参数也没有返回值都可以省略 闭包是引用类型 在swift中，函数和闭包都是引用类型 无论是什么时候赋值给 函数或闭包 一个 常量或变量，实际上都是将常量和变量设置为对函数和闭包的 引用 如果类实例的 属性 是一个 闭包，并且闭包通过引用该实例或者它的成员来捕获实例，你将在闭包和实例间会产生 循环引用 闭包作为函数的参数1234567func exec(fn: (Int,Int) -&gt; Int, v1: Int, v2: Int) &#123; /* fn: (Int,Int) -&gt; Int = &#123;a,b -&gt; Int in return a + b&#125; print(fn(1,2)) */ print(fn(v1,v2))&#125; 这个函数有 3 个参数：第一个参数是个闭包下面是exec函数的调用 12345678910func exec(fn: (Int,Int) -&gt; Int, v1: Int, v2: Int) &#123; /* fn: (Int,Int) -&gt; Int = &#123;a,b -&gt; Int in return a + b&#125; print(fn(1,2)) */ print(fn(v1,v2)) // 打印结果 2&#125;exec(fn: &#123; a, b in return a + b&#125;, v1: 1, v2: 2) exec函数调用时，{} 里就是一个闭包表达式，可以看做是函数第一个参数的实现这样的函数调用形式看起来很不友好，如果闭包表达式有很多行的话，会更加不友好，不利于代码的阅读。swift提供了一个 尾随闭包 的概念 尾随闭包 当函数的最后一个参数是函数时，在函数调用时可以把闭包表达式写在 () 外面 尾随闭包是一个书写在函数 () 之后的闭包表达式 如果将一个很长的闭包表达式作为函数的最后一个实参，使用闭包可以增强函数的可读性 123func exec(v1: Int, v2: Int, fn: (Int, Int) -&gt; Int) &#123; print(fn(v1,v2))&#125; 这次把exec函数的第一个参数fn放到了最后，下面可以看下调用方式和上次的有什么不同 123exec(v1: 1, v2: 2) &#123; a, b in return 1 + 2&#125; 根上一次的函数对比，这次是把闭包写在了函数 () 之后，增强了代码的可读性，这就是 尾随闭包 可以使用 高阶函数 简化参数名，如 $0,$1(从0开始，表示第i个参数…) 123exec(v1: 1, v2: 2) &#123; return $0 + $1&#125; 还有很多简写方式就不一一举例了，太简写也不利于代码阅读 如果闭包表达式是函数的唯一实参，而且使用了尾随闭包的语法，可以将函数名后边的 () 省略 1234567// 只有一个闭包为实参func exec(fn: (Int,Int) -&gt; Int) &#123; print(fn(1,2))&#125;exec &#123; a, b in return a + b&#125; array.sorted 就是一个尾随闭包，且这个函数就 只有一个参数，如下所示： 12345678910111213141516171819202122232425// array.sorted就是一个尾随闭包var arr = [1,2,3]// 1.完整写法arr.sorted &#123; (item1: Int,item2: Int) -&gt; Bool in return item1 &gt; item2&#125;// 2.省略参数类型：通过arr中的参数推断类型arr.sort &#123; (item1,item2) -&gt; Bool in return item1 &gt; item2&#125;// 3.省略参数类型 + 返回值类型：通过return推断返回值类型arr.sorted &#123; (item1,item2) in return item1 &gt; item2&#125;// 4.省略参数类型 + 返回值类型 + return关键字：单表达式可以隐士表达，即省略return关键字arr.sorted &#123; (item1, item2) in item1 &lt; item2 &#125;// 5.参数名称简写arr.sorted &#123; return $0 &lt; $1 &#125;// 6.参数名称简写 + 省略return关键字arr.sorted &#123; $0 &lt; $1 &#125;// 7.最简：直接传比较符号arr.sorted (by: &lt;) 闭包的优点：1、利用上下文推断参数和返回类型；2、单表达式可以隐式返回，省略return关键字；3、参数名称可以直接使用简写(如$0,$1,元组的$0.0)；4、尾随闭包可以更简洁的表达。 逃逸闭包 如果一个闭包作为一个函数的参数，并且在函数执行完之后才被执行，那么这种情况下的闭包就是 逃逸闭包 在参数名 : 号后面加 @escaping 修饰符说明 逃逸闭包 逃逸闭包的使用场景，①异步线程网络请求，延迟方法，②作为属性存储，在后面进行调用。 1、在 延迟方法 中调用逃逸闭包 123456789101112131415161718192021222324252627282930313233343536// 闭包作为属性class Animal &#123; // 函数参数使用@escaping修饰，表示允许函数返回之后调用 func getData(amount: Int,handler: @escaping (String) -&gt; Void) &#123; // 延迟5s DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 5) &#123; // 假设是请求得到的数据 var str: String = &quot;my is data&quot; // 5s后调用 handler(&quot;\\(str) : \\(amount)&quot;) &#125; print(&quot;函数执行完了&quot;) &#125; // 返回数据 func backData(success: @escaping (String) -&gt; Void) &#123; // 请求数据 getData(amount: 10) &#123; data in // 拿到数据 success(&quot;success：\\(data)&quot;) &#125; &#125; deinit &#123; print(&quot;Animal deinit&quot;) &#125;&#125;var t = Animal()// 拿到数据t.backData &#123; data in print(data)&#125;========函数执行完了success：my is data : 10 当前方法执行的过程中不会等待闭包执行完成后再执行，而是直接返回，所以 当前闭包的生命周期要比方法长。 2、闭包作为属性： 当闭包作为存储属性时，主要有以下几点说明：1、定义一个闭包属性；2、在方法中对闭包属性进行赋值；3、在合适的时机调用（与业务逻辑相关）。 逃逸闭包 vs 非逃逸闭包 区别 1、非逃逸闭包：一个接受 闭包作为参数 的函数，闭包是在这个 函数结束前 被调用，即可以理解为闭包是在函数作用域结束前被调用。1.1不会产生循环引用，因为闭包的作用域在函数作用域内，在函数执行完成后，就会释放闭包捕获的所有对象；1.2针对非逃逸闭包，编译器会做优化：省略内存管理调用；1.3非逃逸闭包捕获的上下文保存在 栈上，而不是堆上（官方文档说明）。 2.逃逸闭包：一个接受 闭包作为参数 的函数，逃逸闭包可能会在 函数返回之后 才被调用，即闭包逃离了函数的作用域。2.1可能会 产生循环引用，因为逃逸闭包中需要 显式 的引用 self（猜测其原因是为了提醒开发者，这里可能会出现循环引用了），而self可能是持有闭包变量的（与 OC中block 的的循环引用类似）；2.2一般用于异步函数的返回，例如网络请求。 3.使用建议：如果没有特别需要，开发中使用非逃逸闭包是 有利于内存优化的，所以苹果把闭包区分为两种，特殊情况时再使用逃逸闭包。 4.总结：主要区别就是 调用时机和内存管理不同。 自动闭包 在参数名的 : 后面加 @autoclosure 修饰符来说明 自动闭包 @autoclosure 只支持 ()-&gt; T 格式的参数 @autoclosure 会自动将 10 封装成闭包 {20} @autoclosure 并非只支持最后 1 个参数 有@autoclosure和无@autoclosure构成了函数重载 空合并运算符 ?? 使用了@autoclosure技术 先分析为什么会有自动闭包，自动闭包能实现什么作用先看下面的一个函数 1234567func getInt(_ a: Int, _ b: () -&gt; Int) -&gt; Int &#123; return a &gt; 0 ? a : b()&#125;getInt(1) &#123; return 2&#125;// 打印结果是 1 getInt函数调用时使用了一个尾随闭包，当参数满足 ()-&gt; T 这个格式时可以写成 自动闭包，会使代码阅读起来更直观 12345func getInt(_ a: Int, _ b: @autoclosure () -&gt; Int) -&gt; Int &#123; return a &gt; 0 ? a : b()&#125;getInt(1, 2)// 打印结果是 1 需要注意的是 自动闭包 会有 延迟执行 的特点，会在函数内部调用时才会执行 123456789func getInt(_ a: Int, _ b: @autoclosure () -&gt; Int) -&gt; Int &#123; return a &gt; 0 ? a : b()&#125;func exec() -&gt; Int &#123; print(&quot;执行了exec&quot;) return 20&#125;getInt(1, exec())// 打印结果是 1 getInt(1, exec()) 函数调用时，很容易误以为 exec() 就已经调用了函数 exec，其实并没有，exec 内部没有执行。这是因为 自动闭包有延迟执行的特点。getInt(1, exec()) 函数内部因为 a&gt;0 返回的结果是 a 的值，并没有调用到 b()，所以 exec 函数没有执行。只有当 getInt(1, exec()) 函数内部调用到了 b()，exec 函数才会被执行 闭包对变量的捕获 闭包可以对外部函数的 变量/常量 进行捕获 闭包捕获的时机是在函数执行完，return时再去捕获 当函数里有多个闭包时，只会对 变量/常量 捕获一次，多个闭包对捕获的 变量/常量 共享 闭包不会对全局变量进行捕获 下面由几份代码来说明这个结论 1234567891011121314// 变量捕获// MARK:局部变量捕获typealias fn = (Int) -&gt; Voidfunc exec() -&gt; fn &#123; var num = 0 return &#123; a in num += a print(num) &#125;&#125;let res = exec()res(1)res(2)res(3) res(1)、res(2)、res(3) 输出的结果分别是 1、3、6这是一个函数中返回的闭包，在闭包里对 num 进行了累加并输出结果 1、第一次调用res时，num为0，0加上参数1&#x3D;12、第二次调用res时，闭包里的num的值是第一次res里的累加结果1，1加上参数2&#x3D;33、第三次调用res时，闭包里num是第二次res里累加的结果3，3加上参数3&#x3D;6从三次调用res来看，闭包里num都是保存了上次调用后num的值，这是因为闭包捕获了外部的num，并重新在 堆 上 分配了内存，实际上是修改 堆区中的value值，当执行let res &#x3D; exec()时，把闭包的内存地址给了res,所以每次调用res都是调用的同一块内存，同一个闭包，闭包里有保存中捕获后的num的内存地址，所以每次调用都是同一个num 可以把闭包想象成是一个类的实例对象，内存在堆空间，捕获的 局部变量/常量 就是对象的成员(存储属性)，组成闭包的函数就是类内部定义的方法 1234let res1 = exec()res1(1)let res2 = exec()res2(1) 将上面的代码稍微改一下，将exec分别赋值给res1和res2，输出的结果为1和1。这个为什么不是跟上面一样累加呢，因为exec分别赋值给了res1和res2，res1和res2指向的是两个不一样的地址，当每调用一次exec()函数，num会初始化为0 12345678910111213typealias fn = (Int) -&gt; Voidfunc exec() -&gt; fn &#123; var num = 0 func plus(a: Int) -&gt; Void&#123; num += a print(num) &#125; num = 6 return plus&#125;let res = exec()res(1) 上面这份代码输出的num又是多少呢？答案是7 这还是一个局部变量捕获的问题，闭包会在函数执行完，return的时候才会去捕获num，此时num已经由0变为6，所以执行res(1)输出结果为7 12345678910111213141516171819typealias fn = (Int) -&gt; Voidfunc exec() -&gt; (fn, fn) &#123; var num = 0 func plus(a: Int) &#123; num += a print(&quot;plus:&quot;, num) &#125; func minus(a: Int) &#123; num -= a print(&quot;minus:&quot;, num) &#125; return (plus, minus)&#125;let (p, m) = exec()p(5)m(4) 这份代码函数返回了一个元祖，元祖里是两个闭包，两个闭包里面都调用了num，输出的结果为：plus: 5minus: 1 因为当函数里有多个闭包时，只会对变量&#x2F;常量捕获一次，多个闭包对捕获的变量&#x2F;常量共享 因为当函数里有多个闭包时，只会对变量&#x2F;常量捕获一次，多个闭包对捕获的变量&#x2F;常量共享。在调用m(4)时，前面已经调用过p(5)，此时num已经变为5，所以当调用m(4)，输出结果为1。 typedef 为闭包类型定义别名这里先介绍一下 typealias 的使用 : typealias 是Swift中用来为已经存在的类型重新定义名字的关键字（类似于OC语法中的 typedef），重新命名的新名字用来替代之前的类型，并且能够使代码变得更加清晰简单容易理解。typealias 的用法很简单，直接用 = 赋值就可以了： 1typealias &lt;type name&gt; = &lt;type expression&gt; 这里我们可以用 typealias 来为看似较为复杂的闭包类型定义别名，这样以后我们就可以用别名直接去声明这样类型的闭包了，例子如下： 1234567891011// 为没有参数也没有返回值的闭包类型起一个别名typealias Nothing = () -&gt; () // 如果闭包的没有参数和返回值，那么我们还可以这样写，typealias Anything = () -&gt; Void // 为接受一个 Int类型的参数 不返回任何值的闭包类型 定义一个别名：PrintNumbertypealias PrintNumber = (Int) -&gt; () // 为接受两个Int类型的参数并且返回一个Int类型的值的闭包类型 定义一个别名：Addtypealias Add = (Int, Int) -&gt; (Int) 闭包是否接受参数、接受几个参数、返回什么类型的值完全取决于你的需求。 闭包的创建、赋值、调用闭包表达式语法能够使用常量形式参数、变量形式参数和输入输出形式参数，但不能提供默认值。可变形式参数也能使用，但需要在形式参数列表的最后面使用。元组也可被用来作为形式参数和返回类型。在闭包的中会用到一个关键字in，in 可以看做是一个分割符，他把该闭包的类型和闭包的函数体分开，in前面是该闭包的类型，in后面是具体闭包调用时保存的需要执行的代码。表示该闭包的形式参数类型和返回类型定义已经完成，并且闭包的函数体即将开始执行。这里总结了一下可能用到的几种形式实现闭包的创建、赋值、调用的过程。例子如下: 方式一：利用typealias最完整的创建 12345678910// 为(_ num1: Int, _ num2: Int) -&gt; (Int) 类型的闭包定义别名：Addtypealias Add = (_ num1: Int, _ num2: Int) -&gt; (Int)// 创建一个 Add 类型的闭包常量：addCloser1let addCloser1: Add// 为已经创建好的常量 addCloser1 赋值addCloser1 = &#123; (_ num1: Int, _ num2: Int) -&gt; (Int) in return num1 + num2&#125;// 调用闭包并接受返回值let result = addCloser1(20, 10) 形式二：闭包类型声明和变量的创建合并在一起 12345678// 创建一个 (_ num1: Int, _ num2: Int) -&gt; (Int) 类型的闭包常量：addCloser1let addCloser1: (_ num1: Int, _ num2: Int) -&gt; (Int)// 为已经创建好的常量 addCloser1 赋值addCloser1 = &#123; (_ num1: Int, _ num2: Int) -&gt; (Int) in return num1 + num2&#125;// 调用闭包并接受返回值let result = addCloser1(20, 10) 形式三：省略闭包接收的形参、省略闭包体中返回值 12345678// 创建一个 (Int, Int) -&gt; (Int) 类型的闭包常量：addCloser1let addCloser1: (Int, Int) -&gt; (Int)// 为已经创建好的常量 addCloser1 赋值addCloser1 = &#123; (num1, num2) in return num1 + num2&#125;// 调用闭包并接受返回值let result = addCloser1(20, 10) 在形式三的基础上进一步精简 123456// 创建一个 (Int, Int) -&gt; (Int) 类型的闭包常量：addCloser1 并赋值let addCloser1: (Int, Int) -&gt; (Int) = &#123; (num1, num2) in return num1 + num2&#125; // 调用闭包并接受返回值let result = addCloser1(20, 10) 形式五：如果闭包没有接收参数省略in 123456// 创建一个 () -&gt; (String) 类型的闭包常量：addCloser1 并赋值let addCloser1: () -&gt; (String) = &#123; return &quot;这个闭包没有参数，但是有返回值&quot;&#125;// 调用闭包并接受返回值let result = addCloser1() 形式六：简写的实际参数名 123456// 创建一个 (String, String) -&gt; (String) 类型的闭包常量：addCloser1 并赋值let addCloser1: (String, String) -&gt; (String) = &#123; return &quot;闭包的返回值是:\\($0),\\($1)&quot;&#125;// 调用闭包并接受返回值let result = addCloser1(&quot;Hello&quot;, &quot;Swift!&quot;) 说明： 得益于Swift的 类型推断机制，我们在使用闭包的时候可以省略很多东西，而且Swift自动对行内闭包提供简写实际参数名，你也可以通过 $0, $1, $2 这样的语法来引用闭包的实际参数值。如果你在闭包表达式中使用这些简写实际参数名，那么你可以在闭包的实际参数列表中忽略对其的定义，并且简写实际参数名的数字和类型将会从期望的函数类型中推断出来。in关键字也能被省略，$0 和 $1 分别是闭包的第一个和第二个 String类型的 实际参数（引自文档翻译）。 闭包常见的几种使用场景场景一：利用闭包传值 开发过程中常常会有这样的需求：一个页面的得到的数据需要传递给前一个页面使用。这时候使用闭包可以很简单的实现两个页面之间传值。 场景再现：第一个界面中有一个用来显示文字的UILabel和一个点击进入到第二个界面的UIButton,第二个界面中有一个文本框UITextField和一个点击返回到上一个界面的UIButton,现在的需求是在第二个界面的UITextField中输入完文字后，点击返回按钮返回到第一个界面并且将输入的文字显示在第一个界面（当前页面）的UILabel中。 实现代码:首先在第二个界面的控制器中定义一个 (String) -&gt; () 可选类型的闭包常量 closer 作为SecondViewController的属性。closer接收一个String类型的参数（就是输入的文字）并且没有返回值。然后在返回按钮的点击事件中传递参数执行闭包。 123456789101112131415import UIKitclass SecondViewController: UIViewController &#123; // 输入文本框 @IBOutlet weak var textField: UITextField! // 为创建一个(String) -&gt; () 的可选类型的闭包变量作为控制器的属性 var closer: ((String) -&gt; ())? // 返回按钮的点击事件 @IBAction func backButtonDidClick(_ sender: AnyObject) &#123; // 首先判断closer闭包是否已经被赋值，如果已经有值，直接调用该闭包，并将输入的文字传进去。 if closer != nil &#123; closer!(textField.text!) &#125; navigationController?.popViewController(animated: true) &#125;&#125; 这里有一个注意点：我们在为 SecondViewController 定义变量闭包属性的时候需要将类型声明为可选类型，闭包可选类型应该是 ((String) -&gt; ())? 而不是 (String) -&gt; ()? 的，后者指的是闭包的返回值是可选类型。回到第一个界面的控制器中，我们需要拿到UILabel的控件，然后重写 prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; &#125; 方法，在这个跳转方法中拿到跳转的目标控制器SecondVC 并为他的闭包属性赋值，当然如果你的跳转按钮的点击事件是自己处理的，直接在按钮的点击事件中这样做就OK了。 123456789101112131415import UIKitclass FirstViewController: UIViewController &#123; // 显示文字的label @IBOutlet weak var label: UILabel! // 重写这个方法 override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; // 拿到跳转的目标控制器 let secondVC = segue.destination as! SecondViewController // 为目标控制器的闭包属性赋值 secondVC.closer = &#123; // 将闭包的参数(输入的文本内容)显示在label上 self.label.text = $0 &#125; &#125;&#125; 经过上面的处理，我们就可以实现两个页面之间的传值了（是不是很简单呢），当然在具体的开发中很可能不是传递文本内容这么简单，当需要传递更复杂的值时，我们可以将传递的值包装成一个模型，直接用闭包传递模型就好了。 场景二：闭包作为函数的参数 在OC语法中block可以作为函数的参数进行传递，在Swift中同样可以用闭包作为函数的参数，还记得上面利用 typealias 关键字定义别名吗，定义完的别名就是一个闭包类型，可以用它申明一个闭包常量或变量当做参数进行传递。一个最简单的闭包作为函数参数例子如下： 123456// 为接受一个Int类型的参数并且返回一个Int类型的值的闭包类型定义一个别名：Numbertypealias Number = (num1: Int) -&gt; (Int)// 定义一个接收Number类型的参数没有返回值的方法func Text(num: Number) &#123; // code&#125; 闭包在作为函数的参数进行传递的时候根据函数接收参数的情况有很多种不同的写法。这里我们主要介绍一下尾随闭包的概念。首先看一下一般形式的闭包作为函数的参数传递： 12345678// 拼接两个字符串和一个整数func combine(handle:(String, String) -&gt; (Void), num: Int) &#123; handle(&quot;hello&quot;, &quot;world \\(num)&quot;)&#125;// 方法调用combine(handle: &#123; (text, text1) -&gt; (Void) in print(&quot;\\(text) \\(text1)&quot;)&#125;, num: 2016) 可以看到上面的combine方法在主动调用的时候依旧是按照 func(形参: 实参) 这样的格式。当我们把闭包作为函数的最后一个参数的时候就引出了尾随闭包的概念。 一，尾随闭包 尾随闭包是指当需要将一个很长的闭包表达式作为函数最后一个实际参数传递给函数时，一个书写在函数形式参数的括号外面（后面）的闭包表达式： 123456func combine1(num:Int, handle:(String, String)-&gt;(Void)) &#123; handle(&quot;hello&quot;, &quot;world \\(num)&quot;)&#125;combine1(num: 2016) &#123; (text, text1) -&gt; (Void) in print(&quot;\\(text) \\(text1)&quot;)&#125; 进一步：如果闭包表达式被用作函数唯一的实际参数并且你把闭包表达式用作尾随闭包，那么调用这个函数的时候函数名字的（）都可以省略： 123456func combine2(handle:(String, String)-&gt;(Void)) &#123; handle(&quot;hello&quot;, &quot;world&quot;)&#125;combine2 &#123; (text, text1) -&gt; (Void) in print(&quot;\\(text) \\(text1)&quot;)&#125; 二，逃逸闭包如果一个闭包被作为一个参数传递给一个函数，并且在函数return之后才被唤起执行，那么我们称这个闭包的参数是“逃出”这个函数体外，这个闭包就是逃逸闭包。此时可以在形式参数前写 @escaping 来明确闭包是允许逃逸的。闭包可以逃逸的一种方法是被储存在定义于函数外的变量里。比如说，很多函数接收闭包实际参数来作为启动异步任务的回调。函数在启动任务后返回，但是闭包要直到任务完成——闭包需要逃逸，以便于稍后调用。用我们最常用的网络请求举例来说： 12345678910111213141516func request(methodType:RequestMethodType, urlString: String, parameters: [String : AnyObject], completed: @escaping (AnyObject?, NSError?) -&gt; ()) &#123; // 1.封装成功的回调 let successCallBack = &#123; (task : URLSessionDataTask?, result : Any?) -&gt; Void in completed(result as AnyObject?, nil) &#125; // 2.封装失败的回调 let failureCallBack = &#123; (task : URLSessionDataTask?, error : Error?) -&gt; Void in completed(nil, error as NSError?) &#125; // 判断是哪种请求方式 if methodType == .get &#123; get(urlString, parameters: parameters, success: successCallBack, failure: failureCallBack) &#125; else &#123; post(urlString, parameters: parameters, success: successCallBack, failure: failureCallBack) &#125; &#125; 使用闭包可能引起的循环强引用Swift中不当的使用闭包可能会引起循环强引用，之所以称之为“强”引用，是因为它会将实例保持住，只要强引用还在，实例是不允许被销毁的。循环强引用会一直阻止类实例的释放，这就在你的应用程序中造成了内存泄漏。举个例子： 1234567891011121314151617181920import UIKitclass ThirdViewController: UIViewController &#123; var callBack: ((String) -&gt; ())? override func viewDidLoad() &#123; super.viewDidLoad() printString &#123; (text) in print(text) // 闭包中捕获了self self.view.backgroundColor = UIColor.red &#125; &#125; func printString(callBack:@escaping (String) -&gt; ()) &#123; callBack(&quot;这个闭包返回一段文字&quot;) // 控制器强引用于着callBack self.callBack = callBack &#125; deinit &#123; print(&quot;ThirdViewController---释放了&quot;) &#125;&#125; 当你在定义printString这个方法时执行 self.callBack = callBack 代码实际上是self对callBack闭包进行了强引用，到这里其实并没有产生循环引用，但是当你在调用printString方法的闭包里面又访问了self.view.backgroundColor属性，此时强引用就发生了，即self引用了callBack,而callBack内部又引用着self,谁都不愿意松手，我们就说这两者之间产生了循环强引用。 使用闭包何时会出现循环强引用 ：当你把一个闭包分配给类实例属性的时候，并且这个闭包中又捕获了这个实例。捕获可能发生于这个闭包函数体中访问了实例的某个属性，比如 self.someProperty ，或者这个闭包调用了一个实例的方法，例如 self.someMethod() 。这两种情况都导致了闭包捕获了 self ，从而产生了循环强引用。 闭包循环引用的本质是：闭包中循环强引用的产生，是因为闭包和类相似（还有一种两个类实例之间的循环强引用），都是引用类型。当你把闭包赋值给了一个属性，你实际上是把一个引用赋值给了这个闭包。两个强引用让彼此一直有效。 如何解决闭包的循环强引用： 方式一：类似于Objective-C中使用 __weak 解决block的循环引用，Swift中支持使用 weak 关键字将类实例声明为弱引用类型（注意，弱引用类型总是 可选类型），打破类实例对闭包的强引用，当对象销毁之后会自动置为 nil，对 nil 进行任何操作不会有反应。 12345678910111213141516171819202122import UIKitclass ThirdViewController: UIViewController &#123; var callBack: ((String) -&gt; ())? override func viewDidLoad() &#123; super.viewDidLoad() // 将self声明明为弱引用类型，打破循环引用 weak var weakSelf = self printString &#123; (text) in print(text) // 闭包中铺捕获了self weakSelf?.view.backgroundColor = UIColor.red &#125; &#125; func printString(callBack:@escaping (String) -&gt; ()) &#123; callBack(&quot;这个闭包返回一段文字&quot;) // 控制器强引用于着callBack self.callBack = callBack &#125; deinit &#123; print(&quot;ThirdViewController---释放了&quot;) &#125;&#125; 方式二：作为第一种方式的简化操作，我们可以在闭包的第一个大括号后面紧接着插入这段代码 [weak self] ，后面的代码直接使用 self？ 也能解决循环引用的问题。 12345678910111213141516171819import UIKitclass ThirdViewController: UIViewController &#123; var callBack: ((String) -&gt; ())? override func viewDidLoad() &#123; super.viewDidLoad() printString &#123; [weak self] (text) in print(text) self?.view.backgroundColor = UIColor.red &#125; &#125; func printString(callBack: @escaping (String) -&gt; ()) &#123; callBack(&quot;这个闭包返回一段文字&quot;) // 控制器强引用于着callBack self.callBack = callBack &#125; deinit &#123; print(&quot;ThirdViewController---释放了&quot;) &#125;&#125; 方式三：在闭包和捕获的实例总是互相引用并且总是同时释放时，可以将闭包内的捕获定义为 无主引用unowned。 12345678910111213141516171819import UIKitclass ThirdViewController: UIViewController &#123; var callBack: ((String) -&gt; ())? override func viewDidLoad() &#123; super.viewDidLoad() printString &#123; [unowned self] (text) in print(text) self?.view.backgroundColor = UIColor.red &#125; &#125; func printString(callBack:@escaping (String) -&gt; ()) &#123; callBack(&quot;这个闭包返回一段文字&quot;) // 控制器强引用于着callBack self.callBack = callBack &#125; deinit &#123; print(&quot;ThirdViewController---释放了&quot;) &#125;&#125; 注意：unowned 是Swift中另外一种解决循环引用的申明无主引用类型的关键字，类似于Objective-C中的 __unsafe_unretained；大家都知道 __weak 和 __unsafe_unretained 的相同点是可以将该关键字修饰的对象变成弱引用解决可能存在的循环引用。不同点在于前者修饰的对象如果发现被销毁，那么指向该对象的指针会立即指向nil，而__unsafe_unretained 修饰的对象如果发现被销毁，指向该对象的指针依然指向原来的内存地址，如果此时继续访问该对象 很容易产生坏内存访问/野指针/僵尸对象访问。 说明：同样的道理Swift中也是一样的。和弱引用类似，无主引用不会牢牢保持住引用的实例。但是不像弱引用，总之，无主引用假定是永远有值的。因此，无主引用总是被定义为非可选类型。你可以在声明属性或者变量时，在前面加上关键字 unowned 表示这是一个无主引用。由于无主引用是非可选类型，你不需要在使用它的时候将它展开。无主引用总是可以直接访问。不过 ARC 无法在实例被释放后将无主引用设为 nil ，因为非可选类型的变量不允许被赋值为 nil 。如果此时继续访问已经被释放实例很容易产生坏内存访问&#x2F;野指针&#x2F;僵尸对象访问。所以Swift建议我们如果被捕获的引用永远不为 nil ，应该用 unowned 而不是 weak，相反，如果你不确定闭包中捕获的引用是不是存在为nil 的可能，你应该使用 weak。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习33：函数","slug":"Swift课程/Swift学习33：函数","date":"2023-03-03T14:54:55.000Z","updated":"2023-03-11T16:52:29.230Z","comments":true,"path":"2023/03/03/Swift课程/Swift学习33：函数/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A033%EF%BC%9A%E5%87%BD%E6%95%B0/","excerpt":"","text":"Swift中如何定义和使用函数基本概念 函数是一个独立的代码块，用来执行特定的任务。通过给函数一个 名字 来定义它的功能，并且在需要的时候，通过这个名字来 调用 函数执行它的任务 Swift统一的函数语法十分灵活。可以从简单的无形式参数到复杂的每个形式参数都带有局部和外部形式参数名。形式参数提供一个默认值来简化函数的调用，可被当做输入输出形式参数被传递，在函数执行完成时修改传递进来的变量。 Swift中每一个函数都有类型，由函数的形式参数类型和返回类型组成 。可以像swift中其它类型来使用它。可以将函数当一个形式参数传递到另外一个函数中。也可以在一个函数中返回另一个函数。同时也可以写在其他函数内部在内嵌范围封装有用的功能。 函数是 引用类型 的，不是值类型的 定义和调用函数 当你定义一个函数时，可以选择定义一个或多个形式参数类型，也可以定义返回类型 每个函数都有函数名，描述执行的任务。 使用函数可通过 函数名 并且 传入 函数的 实际参数 （即形式参数类型的输入值 ）来 调用函数。 实际参数顺序必须符合形式参数的列表顺序 无形式参数的函数 函数不要求必须传入一个参数，可以没有形式参数 函数定义需要在名字的后面加一个圆括号，即使没有形式参数也得加 调用函数的时候也要在函数的名字后面加一个圆括号 多形式参数的函数 函数可以输入多个形式参数，写在圆括号内，用逗号分割 123func manyPara(a:Int,b:Int) &#123; pring(&quot;\\(a) \\(b)&quot;)&#125; 无返回值的函数 函数定义可以没有返回类型，即没有返回箭头 -&gt; 或返回类型 严格上，函数还是有一个返回类型的，尽管没有定义返回值，实际上返回一个特殊的类型 void。它是一个空的元组，作用相当于没有元素的元组，写作() 123func manyTuple() -&gt; void &#123; return nil&#125; 多返回值的函数 可以让函数返回多个值作为一个复合的返回值，你可以使用元组类型作为返回类型 123func manyTuple() -&gt; (a:Int,b:String) &#123; return (1,&quot;aaa&quot;)&#125; 可选元组返回类型 如果在函数返回类型中元组可能 没有值，可以用可选元组说明元组可能是 nil 写法是可选元组圆括号后面加一个问号 ？，例如 (Int,Int)? 或 (String,Int,Bool)? 示例： 1234567891011121314151617181920212223// 返回元组func minMax(arr: [Int]) -&gt; (min:Int,max:Int)? &#123; if arr.isEmpty &#123; return nil &#125; var minValue = arr[0] var maxValue = arr[0] for value in arr &#123; if value &lt; minValue &#123; minValue = value &#125; if value &gt; maxValue &#123; maxValue = value &#125; &#125; return (minValue,maxValue)&#125;// 绑定if let minMaxValue = minMax(arr: [1,3,4,2,5]) &#123; print(&quot;min is \\(minMaxValue.min),max is \\(minMaxValue.max)&quot;)&#125; 编译运行，查看打印结果： 1min is 1,max is 5 隐士返回函数 如果整个函数体是一个单一的表达式，那么函数隐士返回这个表达式 1234func greet(person: String) -&gt; String&#123; &quot;Hello,&quot; + person + &quot;!&quot;&#125;print(&quot;\\(greet(person: &quot;World&quot;))&quot;) 打印结果 1Hello,World! Swift形式参数和返回值实参标签和形参名 每一个函数的形式参数都包含实际参数标签和形式参数名。 形式参数必须有唯一的名字，有助于代码易读 1234func someFunc(firstParamName:Int,secondParamName:Int)&#123; // 形式参数 firstParamName secondParamName&#125;someFunc(firstParamName: 1, secondParamName: 2) 指定实际参数标签 形式参数名之前写实际参数标签，用 空格 分割 如果你为 形式参数 定义了 实际参数标签，那么在调用函数的时候必须使用 实际参数标签 实际参数标签能够让函数的调用更加明确，更像自然语言，更可读，更清晰表达你的意图 12345// 实际参数标签 homefunc greet(person: String, from home: String) -&gt; String &#123; return &quot;Hello \\(person)! my home is \\(home)&quot;&#125;print(greet(person: &quot;ZJ&quot;,from: &quot;BeiJing&quot;)) 打印结果： 1Hello ZJ! my home is BeiJing 省略实际参数标签 可以利用下划线 _ 替代显示的实际参数标签 1234func greet(_ person: String, _ home: String) -&gt; String &#123; return &quot;Hello \\(person)! my home is \\(home)&quot;&#125;print(greet(person: &quot;ZJ&quot;,from: &quot;BeiJing&quot;)) 默认形式参数值 可以在形式参数类型后，给类型定义一个默认值 如果定义了默认值，你就可以在调用的时候省略这个形式参数 123456789func someFunc(paramDefault: Int = 10) &#123; print(&quot;\\(paramDefault)&quot;)&#125;someFunc(paramDefault: 6)someFunc()===========610 可变形式参数 一个可变的形式参数可以接受零或多个特定类型的值。 通过在形式参数类型名后插入三个点符号 ... 来书写可变形式参数。 传入到可变参数中的值在函数的主体中被当做是对应类型的 数组。 1234567891011func changeFunc(_ numbers: Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total / Double(numbers.count)&#125;changeFunc(1,2,3,4,5)=============3 输入输出形式参数 可变形式参数只能在函数的内部做改变。如果你想函数能修改一个形式参数的值，而且这些改变在函数结束之后依然生效，那么就需要将形式参数定义为输入输出形式参数 输入输出形式参数：在形式参数前边加 inout 关键字。 只能把 变量 作为输入输出形式参数的 实际参数，在将变量作为实际参数传入给输入输出形式参数时，在它前边添加一个符号 &amp; 来明确可以被函数修改 输入输出形式参数不能有默认值，可变形式参数不能被标记为 inout 12345678910111213// 输入输出形式参数func swapTwoInt(_ a: inout Int, _ b: inout Int) &#123; let temp = a a = b b = temp&#125;var one = 10var two = 20swapTwoInt(&amp;one,&amp;two)print(&quot;\\(one) \\(two)&quot;)=========20 10 函数类型和内嵌函数函数类型 每一个函数都有一个特定的函数类型，它由形式参数类型，返回类型组成 12345678func addTwo(_ a:Int,_ b:Int) -&gt; Int &#123; return a + b&#125;let c = addTwo(1,2)print(&quot;\\(c)&quot;)========3 和 (Int,Int) -&gt; Int 相关 使用函数类型 你可以像使用Swift中的其他类型一样使用函数类型。例如：你可一个常量或变量定义一个函数类型，并且未变量指定一个相应的函数 12345678func addTwo(_ a:inout Int,_ b:inout Int) -&gt; Int &#123; return a + b&#125;var mathFunc:(inout Int,inout Int) -&gt; Int = addTwoprint(mathFunc(2,3))============5 函数类型作为形式参数类型 你可以将 函数 作为 其他函数的形式参数 12345678910func addTwo(_ a:Int,_ b:Int) -&gt; Int &#123; return a + b&#125;func printResult(_ mathFunc:(Int,Int) -&gt; Int,_ a:Int,_ b:Int) &#123; print(&quot;Result:\\(mathFunc(a,b))&quot;)&#125;printResult(addTwo,2,3)==========5 函数类型作为返回类型 可以利用函数的类型作为另一个函数的返回类型。写法在函数的返回箭头后写一个完整的函数类型 123456func backF(_ input:Int) -&gt; Int&#123; return input - 1&#125;func chooseFunc(back: Bool) -&gt; (Int) -&gt; Int &#123; return backF&#125; 内嵌函数 可以在函数内定义另外一个函数。这就是内嵌函数 内嵌函数默认是被隐藏起来的，但仍然可以通过包裹他们的函数来调用他们。 包裹的函数也可以返回它内部的一个内嵌函数来在另外的返回里使用 1234567891011121314func chooseFunc(back: Bool) -&gt; (Int) -&gt; Int &#123; func stepForward(step:Int) -&gt; Int &#123; return step + 1&#125; func stepBackward(step:Int) -&gt; Int &#123; return step - 1&#125; return back ? stepBackward : stepForward&#125;var current = -4let stepFunc = chooseFunc(back: current &gt; 0)while current != 0 &#123; current = stepFunc(current)&#125;print(current)=======0","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习32：Dictionary字典底层实现探索","slug":"Swift课程/Swift学习32：Dictionary字典底层实现探索","date":"2023-03-03T14:54:19.000Z","updated":"2023-03-09T07:24:35.724Z","comments":true,"path":"2023/03/03/Swift课程/Swift学习32：Dictionary字典底层实现探索/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A032%EF%BC%9ADictionary%E5%AD%97%E5%85%B8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习32：Dictionary字典","slug":"Swift课程/Swift学习32：Dictionary字典","date":"2023-03-03T14:54:00.000Z","updated":"2023-03-09T07:24:33.560Z","comments":true,"path":"2023/03/03/Swift课程/Swift学习32：Dictionary字典/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A032%EF%BC%9ADictionary%E5%AD%97%E5%85%B8/","excerpt":"","text":"","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习31：Set底层实现探究","slug":"Swift课程/Swift学习31：Set底层实现探究","date":"2023-03-03T14:53:34.000Z","updated":"2023-03-09T07:24:31.511Z","comments":true,"path":"2023/03/03/Swift课程/Swift学习31：Set底层实现探究/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A031%EF%BC%9ASet%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%A9%B6/","excerpt":"","text":"","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习30：Set集合","slug":"Swift课程/Swift学习30：Set集合","date":"2023-03-03T14:52:43.000Z","updated":"2023-03-09T07:24:27.936Z","comments":true,"path":"2023/03/03/Swift课程/Swift学习30：Set集合/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A030%EF%BC%9ASet%E9%9B%86%E5%90%88/","excerpt":"","text":"","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习29：如何用数组来实现栈和队列","slug":"Swift课程/Swift学习29：如何用数组来实现栈和队列","date":"2023-03-03T14:51:03.000Z","updated":"2023-03-09T07:24:25.385Z","comments":true,"path":"2023/03/03/Swift课程/Swift学习29：如何用数组来实现栈和队列/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A029%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"","text":"","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习28：数组的底层实现","slug":"Swift课程/Swift学习28：数组的底层实现","date":"2023-03-03T14:50:24.000Z","updated":"2023-03-09T07:24:23.130Z","comments":true,"path":"2023/03/03/Swift课程/Swift学习28：数组的底层实现/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A028%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习27：访问和操作数组","slug":"Swift课程/Swift学习27：访问和操作数组","date":"2023-03-03T14:49:55.000Z","updated":"2023-03-09T07:24:11.998Z","comments":true,"path":"2023/03/03/Swift课程/Swift学习27：访问和操作数组/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A027%EF%BC%9A%E8%AE%BF%E9%97%AE%E5%92%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84/","excerpt":"","text":"","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习26：创建数组的几种方式","slug":"Swift课程/Swift学习26：创建数组的几种方式","date":"2023-03-03T14:49:30.000Z","updated":"2023-03-09T07:24:19.626Z","comments":true,"path":"2023/03/03/Swift课程/Swift学习26：创建数组的几种方式/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A026%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"OC三方框架01：bugly搜集Crash","slug":"OC性能优化/性能优化03.1：bugly搜集Crash","date":"2023-03-03T08:17:48.000Z","updated":"2023-03-08T23:00:23.065Z","comments":true,"path":"2023/03/03/OC性能优化/性能优化03.1：bugly搜集Crash/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603.1%EF%BC%9Abugly%E6%90%9C%E9%9B%86Crash/","excerpt":"","text":"Bugly 介绍为了能够快速并准确的定位用户 App 发生 Crash 的代码位置，Bugly 使用 符号表文件 对发生 Crash 的程序 堆栈 进行 解析和还原 举例： Bugly 上传方式 Bugly 已不再支持直接上传dSYM文件，需要 下载工具包手动上传 本文主要介绍 下载工具包手动上传 安装java运行环境 终端查看是否已安装 1234zhangjian@zhangjiandeMBP ~ % java -versionjava version &quot;1.8.0_291&quot;Java(TM) SE Runtime Environment (build 1.8.0_291-b10)Java HotSpot(TM) 64-Bit Server VM (build 25.291-b10, mixed mode) 上面的显示表示已安装 未安装的情况如下： 到 Java官网 下载 jdk，如下图： 下载完成之后打开 dmg，安装、一路下一步即可安装成功。 在终端输入 java -version 可以查看 java 版本，如果输出信息和上面类似，表示安装成功 获取 dSYM 文件 什么是 dSYM 文件？ 在 iOS 平台中，dSYM文件是指 具有调试信息的目标文件，文件名通常为 xxx.app.dSYM 【注】：为了方便找回 Crash 对应的 dSYM文件 和 还原堆栈，建议每次 构建或发布App版本 时，备份好 dSYM文件 获取 dSYM 方式 我们可以配置 Edit Scheme -&gt; Archives 打包 Debug 和 Release 两种环境，去获取 dSYM文件，本文以 Release 发布环境为例 配置打包环境 Release Show in Finder -&gt; 显示包内容，找到 dSYM文件 最后，在桌面或任意位置，新建一个文件夹如 appdSYM ，将 xxx.app.dSYM 拷贝进来 至此，获取 dSYM文件 完成 工具手动上传符号表 下载 Bugly iOS 符号表 上传工具，如下图： 我们需要用到的是 buglySymboliOS.jar 文件，单独放在一个新建的空文件夹如 buglySymboliOS 里面 下载后得到 buglyqq-upload-symbol 文件，解压里面 jar包，得到 buglySymboliOS.jar 包 通过终端命令行上传 1java -jar buglyqq-upload-symbol.jar -appid c4f4e4dc67 -appkey cb791b15-dbe1-44d9-bd33-b3fe558b773b -bundleid cn.epod.srsf -version 1.6.2 -platform IOS -inputSymbol /Users/mac/Desktop/appdSYM/中图云书房.app.dSYM 【参数说明】： -addid ：在 bugly 上对应的 appid c4f4e4dc67-appkey ：在 bugly 上对应的 appkey-bundleid ： iOS平台的 bundle id cn.epod.srsf-version ：版本号 1.6.2-platform ：平台（注意大小写）IOS Android-inputSymbol ：dSYM调试文件 &#x2F;Users&#x2F;mac&#x2F;Desktop&#x2F;appdSYM&#x2F;中图云书房.app.dSYM 项目中使用 项目需要集成cocoapods三方依赖管理工具，用cocoapods集成 Bugly SDK 12345678910111213141516171819202122232425platform :ios, &#x27;9.0&#x27;# 忽略所有警告inhibit_all_warnings!target &#x27;SRSF&#x27; do # Comment the next line if you don&#x27;t want to use dynamic frameworks use_frameworks! # Pods for SRSF # 官方提示：三方动态库最好最多是6个 # Bugly pod &#x27;Bugly&#x27; target &#x27;SRSFTests&#x27; do inherit! :search_paths # Pods for testing end target &#x27;SRSFUITests&#x27; do # Pods for testing endend 使用 1234567#pragma mark -Bugly- (void)startBugly&#123; BuglyConfig * config = [[BuglyConfig alloc] init]; config.debugMode = YES; // Debug信息开关 config.reportLogLevel = BuglyLogLevelWarn; // 设置为BuglyLogLevelWarn，则在崩溃时会上报Warn、Error接口打印的日志 [Bugly startWithAppId:@&quot;AppId&quot; config:config];&#125;","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-三方框架","slug":"OC-三方框架","permalink":"https://www.bboyzj.cn/tags/OC-%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"性能优化02：卡顿检测","slug":"OC性能优化/性能优化02：卡顿检测和优化方案","date":"2023-03-02T15:32:46.000Z","updated":"2023-03-08T21:34:00.621Z","comments":true,"path":"2023/03/02/OC性能优化/性能优化02：卡顿检测和优化方案/","link":"","permalink":"https://www.bboyzj.cn/2023/03/02/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602%EF%BC%9A%E5%8D%A1%E9%A1%BF%E6%A3%80%E6%B5%8B%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/","excerpt":"","text":"","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"性能优化01：内存泄漏检测","slug":"OC性能优化/性能优化01：内存泄漏检测和优化方案","date":"2023-03-02T15:32:21.000Z","updated":"2023-03-08T21:33:57.542Z","comments":true,"path":"2023/03/02/OC性能优化/性能优化01：内存泄漏检测和优化方案/","link":"","permalink":"https://www.bboyzj.cn/2023/03/02/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/","excerpt":"","text":"","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习03：内存管理","slug":"OC学习/OC学习03：内存管理","date":"2023-03-02T10:51:48.000Z","updated":"2023-03-03T08:09:37.000Z","comments":true,"path":"2023/03/02/OC学习/OC学习03：内存管理/","link":"","permalink":"https://www.bboyzj.cn/2023/03/02/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A003%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"前言本文主要介绍 内存的五大区 、函数栈 和 内存管理 内存五大区在iOS中，内存主要分为 栈区、堆区、全局区、常量区、代码区 五个区域，如下图所示： 栈区定义 栈是 系统数据结构，其对应的 进程或者线程是唯一的 栈是 向低地址扩展 的数据结构 栈是一块 连续的内存区域，遵循 先进后出（FILO） 原则 栈区一般在 运行时 分配 存储 栈区是由 编译器自动分配并释放的，主要用来存储 局部变量 函数的参数，例如函数的隐藏参数（id self, SEL _cmd） 优缺点 优点：因为栈是由 编译器自动分配并释放 的，不会产生内存碎片，所以 快速高效 确定：栈的 内存大小有限制，数据不灵活 iOS主线程大小是1MB 其他线程是 512KB MAC 只有 8MB 以上内存大小的说明，在Threading Programming Guide中有相关说明，如下图： 堆区定义 堆是 向高地址扩展 的数据结构 堆是 不连续的内存区域，类似于 链表结构（便于增删，不便于查询），遵循 先进先出（FIFO）原则 堆的 地址空间 在iOS中是是动态的 堆区的分配一般是以在 运行时分配 存储 堆区是 由程序员动态分配和释放 的，如果程序员不释放，程序结束后，可能由操作系统回收，主要用于存放： OC 中使用 alloc 、 new 开辟空间创建 对象 ，或者 block经过copy后 C 语言中使用 malloc、calloc、realloc 分配的空间，需要 free 释放 一般一个 new/alloc 就要对应一个 release，在 ARC 下编译器会自动在合适位置为 OC 对象添加 release 操作，会在当前 线程Runloop退出或休眠时销毁这些对象。MRC 则需程序员手动释放。 优缺点 优点：灵活方便，数据适应面广泛 缺点：需 手动管理、速度慢，容易产生内存碎片 当需要访问堆中数据时，一般需要 先通过对象读取到栈区的指针地址，然后通过 指针地址访问堆区 全局区（静态区，即.bss &amp; .data）全局区是 编译时分配 的内存空间，在程序运行过程中，此内存中的数据一直存在，程序结束后由系统释放，主要存放： 未初始化的全局变量和静态变量，即BSS区（.bss） 已初始化的全局变量和静态变量，即DATA区（.data） 其中，全局变量 是指变量值可以在 运行时被动态修改，而 静态变量 是 static 修饰的变量，包含 静态局部变量 和 静态全局变量 常量区（即.rodata）常量区是 编译时分配 的内存空间，在 程序结束后由系统释放，主要存放： 已经使用了的，且没有指向的 字符串常量 字符串常量因为可能在程序中被多次使用，所以在程序运行之前就会提前分配内存 代码区（即.text）代码区是 由编译时分配，主要用于存放 程序运行时的代码，代码会被编译成 二进制存进内存 的 内存五大区验证运行下面的一段代码，看看变量在内存中是如何分配的： 1234567891011121314int a = 10; // 全局区（已初始化的全局变量）char * b; // 全局区(未初始化的全局变量)- (void)test&#123; NSInteger i = 123; // 栈区（局部变量） NSLog(@&quot;i的内存地址：%p&quot;, &amp;i); NSString *string = @&quot;ZJ&quot;; // 常量区（字符串常量） NSLog(@&quot;string的内存地址：%p&quot;, string); NSLog(@&quot;&amp;string的内存地址：%p&quot;, &amp;string); NSObject *obj = [[NSObject alloc] init]; // 堆区（alloc对象） NSLog(@&quot;obj的内存地址：%p&quot;, obj); NSLog(@&quot;&amp;obj的内存地址：%p&quot;, &amp;obj); &#125; 运行结果如下： 123452022-03-11 14:34:25.438913+0800 内存五大区[70321:4340509] i的内存地址：0x16f6f5a182022-03-11 14:34:25.438976+0800 内存五大区[70321:4340509] string的内存地址：0x1007100982022-03-11 14:34:25.438997+0800 内存五大区[70321:4340509] &amp;string的内存地址：0x16f6f5a102022-03-11 14:34:25.439014+0800 内存五大区[70321:4340509] obj的内存地址：0x280fa0bc02022-03-11 14:34:25.439031+0800 内存五大区[70321:4340509] &amp;obj的内存地址：0x16f6f5a08 对于 局部变量i， 存放在栈区 对于 字符串对象string，分别打印了 string得对象地址 和 string对象的指针地址 string的 对象地址 是是存放在 常量区 string 对象的指针地址，是存放在 栈区 对于 alloc创建的对象obj，分别打印了 obj得对象地址 和 obj对象的指针地址 obj的 对象地址 是存放在 堆区 obj 对象的指针地址 是存放在 栈区 函数栈 函数栈 又称为 栈区，在内存中从高地址往低地址分配，与堆区相对，具体图示请看上面 栈帧 是指 函数（运行中且未完成）占用的一块独立的连续内存区域 应用中新创建的 每个线程都有专用的栈空间，栈可以在线程期间自由使用，而线程中有千千万万的函数调用，这些函数 共享 进程的这个 栈空间。每个函数所使用的栈空间是一个栈帧，所有栈帧就组成了这个线程完成的栈 函数调用是发生在栈上 的，每个 函数的相关信息（例如局部变量、调用记录等）都 存储在一个栈帧 中，每执行一次 函数调用，就会生成一个与其相关的栈帧，然后将其 栈帧压入函数栈，而当函数 执行结束，则将此函数对应的 栈帧出栈并释放掉 如下图所示，是经典图- ARM的栈帧布局方式 其中 main stack frame 为调用函数的栈帧 func1 stack frame 为当前 当前函数（被调用者）的栈帧 栈底 在 高 地址，栈向下增长 FP 就是 栈基址，它指向函数的 栈帧起始地址 SP 则是函数的 栈指针，它指向 栈顶 的位置 ARM压栈 的 顺序 很是规则（也比较容易被黑客攻破），依次为 当前函数指针PC、返回指针LR、栈指针SP、栈基址FP、传入参数个数及指针、本地变量 和 临时变量。如果函数准备调用另一个函数，跳转之前临时变量区先要保存另一个函数的参数 ARM 也可以 用栈基址和栈指针明确标示栈帧的位置，栈指针SP一直移动，ARM的特点是，两个栈空间内的地址（SP+FP）前面，必然有两个代码地址（PC+LP）明确标示着调用函数位置内的某个地址 堆栈溢出一般情况下应用程序是不需要考虑堆和栈的大小的，但是事实上堆和栈不是无上限的，过多的递归会导致栈溢出，过多的alloc变量会导致堆溢出 所以 预防堆栈溢出 的方法： 避免层次过深 的 递归 调用 不要使用过多的局部变量，控制局部变量的大小 避免分配 占用空间 太大的对象，并 及时释放 实在不行，适当的情景下 调用系统API修改线程的堆栈大小 栈帧示例描述下面代码的栈帧变化 栈帧程序示例 1234567891011int Add(int x,int y) &#123; int z = 0; z = x + y; return z;&#125;int main() &#123; int a = 10; int b = 20; int ret = Add(a, b);&#125; 程序执行时，栈区中栈帧的变化如下图所示： 内存管理概述 在iOS中开发中，我们或多或少都听说过内存管理。iOS的内存管理一般指的是OC对象的内存管理，因为OC对象分配在堆内存，堆内存需要程序员自己去动态分配和回收；基础数据类型(非OC对象)则分配在栈内存中，超过作用域就会由系统检测回收。如果我们在开发过程中，对内存管理得不到位，就有可能造成内存泄露。 我们通常讲的内存管理，实际上从发展的角度来说，分为两个阶段：MRC和ARC。 MRC指的是 手动内存管理，在开发过程中需要开发者手动去编写内存管理的代码； ARC指的是 自动内存管理，在此内存管理模式下由LLVM编译器和OC运行时库生成相应内存管理的代码。 引用计数 在 OC 中，使用 引用计数 来 进行内存管理。 每个对象都有一个与其相对应的引用计数器，当持有一个对象，这个对象的引用计数就会递增；当这个对象的某个持有被释放，这个对象的引用计数就会递减。当这个对象的引用计数变为0，那么这个对象就会被系统回收。 当一个对象使用完没有释放，此时其引用计数永远大于1。该对象就会一直占用其分配在堆内存的空间，就会导致内存泄露。内存泄露到一定程度有可能导致内存溢出，进而导致程序崩溃。 MRC 简介 全称 Manual Reference Counting，管理通过使用 retain, release, 以及 autorelease 的消息发送来实现。 retain: 持有（拥有）对象，对象引用数加 1 release: 释放对象，对象引用数减 1 autorelease: 通知系统，在 @autoreleasepool 代码块结束时，对对象调用 release 管理原则 自己创建的对象，自己获得拥有权 在苹果规定中，使用 alloc/new/copy/mutableCopy 创建返回的对象归调用者所有，例如以下 1234/* NSMutableArray类对象A */NSMutableArray *array = [[NSMutableArray alloc] init]; NSLog(@&quot;%p&quot;, array);[array release]; // 释放 由于对象 A 由 alloc 生成，符合苹果规定，指针变量array指向并持有对象A，引用计数器会加 1。另外，array在使用完对象A后需要对其进行释放。当调用release后，释放了其对对象A的引用，计数器减1。对象A此时引用计数值为零，所以对象A被回收。不能访问已经被回收的对象，会发生崩溃。 别人创建的对象，可以通过 retain 来获得拥有权 123456789// 例如已有 fooArray, 通过 array 方法获得其引用NSArray *bar = [fooArray array];// 不可以直接调用 release，因为没有拥有权// [bar release];// 需要先 retain 来获得拥有权，然后才能释放[bar retain];[bar release]; 你所拥有的对象不再需要使用时，必须将其释放 不能释放你不拥有的对象 retain retain和属性 我们可以通过属性来保存对象，如果一个属性为强引用，我们就可以通过属性的实例变量和存取方法来对某个对象进行操作，例如某个属性的setter方法如下： 12345678910- (void)setPerson:(Person *)person &#123; [person retain]; [_person release]; _person = person; &#125; 我们通过 retain新值，release旧值，再给实例变量更新值。 需要注意的一点是：需要先retain新值，再release旧值。因为如果新旧值是同一个对象的话，先release就有可能导致该对象被系统回收，再去retain就没有任何意义了。例如下面这个例子： 123456789101112131415161718192021222324252627282930#import &quot;ViewController.h&quot;#import &quot;Person.h&quot;@interface ViewController ()@property (nonatomic, strong)Person *person;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // 实例变量持有Person类对象(P对象)。这样赋值不会调用set方法 _person = [[Person alloc] init]; // 调用set方法 self.person = _person; &#125;- (void)setPerson:(Person *)person &#123; // release释放对P对象的引用，P对象引用计数值变为零，则P对象被系统回收 [_person release]; // 由于P对象已经被回收，再去retain就容易出问题 [person retain]; _person = person;&#125;@end 由于P对象被回收，对应其所分配的内存被置于 可用内存池 中。如果该内存未被覆写，那么P对象依然有效；如果内存被覆写，那么实例变量_person就会指向一个被覆写的未知对象的指针，那么实例变量就变成一个 悬挂指针。 retain和数组 如果我们把一个对象加入到一个数组中，那么该数组的addObject方法会对该对象调用retain方法。例如以下代码： 12345678// person获得并持有P对象，P对象引用计数为1Person *person = [[Person alloc] init]; // Person类对象生成的P对象 NSMutableArray *array = [NSMutableArray array]; // person被加入到数组，对象P引用计数值为2[array addObject:person]; 此时，对象P被person和array两个变量同时持有。 release 自己持有的对象自己释放 当我们持有一个对象，如果在不需要继续使用该对象，我们需要对其进行释放(release)。例如以下代码： 12345678// array获得并持有NSArray类对象NSArray *array = [[NSArray alloc] init]; // 当不再需要使用该对象时，需要释放[array release]; // obj获得但不持有该对象id obj = [NSArray array]; 非自己持有的对象不要释放 当我们不持有某个对象，却对该对象进行释放，应用程序就会崩溃。 12345678// 获得并持有A对象Person *p = [[Person alloc] init]; // Person类对象A // 对象A引用计数为零，所以对象A被回收[p release];// 释放非自己持有的对象[p release]; 另外，我们也不能访问某个已经被释放的对象，该对象所占的堆空间如果被覆写就会发生崩溃的情况。 autorelease autorelease 指的是自动释放，当一个对象收到 autorelease 的时候，该 对象就会被注册到当前处于栈顶的自动释放池（autorelease pool）。如果没有主动生成自动释放池，则当前自动释放池对应的是主运行循环的自动释放池。在当前线程的RunLoop进入休眠前，就会对被注册到该自动释放池的所有对象进行一次release操作。 autorelease和release的区别是： release：是马上释放对某个对象的强引用； autorelease：是延迟释放某个对象的生命周期。 12345678910111213141516171819202122232425&#123; // 外部调用 Person *p = [Person person]; NSLog(@&quot;%p&quot;, p); //使用无须retain // 持有则需要retain [p retain]; _person = p; [_person release];&#125;// Person类内部定义+ (id)person &#123; //创建的Person类对象由person获得并持有 Person *person = [[Person alloc] init]; // [person release]; // 将 person 对象放入自动释放池 [person autorelease]; return person;&#125; 在外部调用，从方法名person知道，创建的对象由p指针变量获得但不持有。在函数内部，person获得并持有了Person类对象，所返回的person对象的引用计数加1。换句话说，调用者需要额外处理这多出来的一个持有操作。另外，我们不能在函数内部调用release，不然对象还没返回就已经被系统回收。这时候使用autorelease就能很好地解决这个问题。 只要把要返回的对象调用autorelease方法，注册到自动释放池就能延长person对象的生命周期，使其在 autorelease pool销毁(drain)前依然能够存活。 另外，person对象在返回时调用了 autorelease方法。该对象已经在自动释放池中，我们可以直接使用对象p，无须再通过[p retain]访问；不过，如果要用实例变量持有该对象，则需要对变量p进行一次retain操作，实例变量使用完该对象需要释放该对象。 autorelease pool autorelease pool 和 RunLoop(运行循环) 当应用程序启动，系统默认会 开启一条线程，该线程就是 主线程。主线程也有一个与之对应的自动释放池。 每条线程都包含一个与其对应的自动释放池，当某条线程被终止的时候，对应该线程的自动释放池会被销毁。同时，处于该自动释放池的对象将会进行一次 release 操作。 ，例如我们常见的 ARC 下的 main.h 文件： 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 该自动释放池用来释放在主线程下注册到该自动释放池的对象。 需要注意的是，当我们 开启一条子线程，并且在该线程 开启RunLoop 的时候，需要为其增加一个autorelease pool，这样有助于保证内存的安全。 autorelease pool和降低内存峰值 当我们执行一些复杂的操作，特别是如果这些复杂的操作要被循环执行，那么中间会免不了会产生一些临时变量。当被加到主线程自动释放池的对象越来越来多，却没有得到及时释放，就会导致内存溢出。这个时候，我们可以手动添加自动释放池来解决这个问题。如以下例子所示： 123456789101112for (int i = 0; i &lt; largeNumber; i++) &#123; // 创建自动释放池 NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init]; // 产生许多被注册到自动释放池的临时对象 id obj = [Person personWithComplexOperation]; // 释放池中对象 [pool drain]; &#125; 如上述例子所示，我们执行的循环次数是一个非常大的数字。并且调用personWithComplexOperation方法的过程中会产生许多临时对象，所产生的临时对象有可能会被注册到自动释放池中。我们通过手动生成一个自动释放池，并且在每次循环结束前把该自动释放池的对象执行release操作释放掉，这样就能有效地降低内存的峰值了。 ARC 概述 Automatic Reference Counting，自动引用计数，即 ARC，WWDC2011 和 iOS5 所引入的最大的变革和最激动人心的变化。ARC是新的LLVM 3.0编译器的一项特性，使用ARC，可以说举解决了广大iOS开发者所憎恨的手动内存管理的麻烦。 此处的 A 就是 automatic。其实 ARC 只是比 MRC 多了一步，就是在 编译时编译器自动帮开发者添加 retain, release 以及 autorelease 的调用，底层的内存管理机制还是和 MRC 一样。 在 ARC 模式下，我们通常在对象变量的声明里用 属性标记符 来指引 ARC 机制来管理我们的对象变量，它们是：strong, retain, weak, copy, assign。默认标记是 strong 标记符的区别 strong: 顾名思义，就是 强引用，对应 MRC 下的 retain，即引用数加 1 retain: 同 strong weak: 弱引用，不增加引用数，引用的对象被释放后变为 nil copy: 对对象进行 copy 后再赋值，因此对象必须遵循 NSCopying 协议。如： 123@property(copy)Foo *foo;...self.foo = bar; // 相当于 self.foo = [bar copy]; assign: 一般用于原始数据类型（primitive type）的赋值。可以用于对象，效果相当于 weak，可是有一个坑是当对象被释放后，assign 属性的变量不会变成 nil，而是成为 野指针（dangling pointer），因此不建议使用在对象上。 借助以上的属性标记符，我们可以在对象声明的时候集中制定它们的内存管理策略，清晰明了。 ARC的判断原则 ARC判断一个对象是否需要释放不是通过引用计数来进行判断的，而是通过强指针来进行判断的。那么什么是强指针? 强指针 默认所有对象的指针变量都是强指针 被__strong修饰的指针 12Person *p1 = [[Person alloc] init];__strong Person *p2 = [[Person alloc] init]; 弱指针 被 __weak 修饰的指针 1__weak Person *p = [[Person alloc] init]; ARC如何通过强指针来判断？ 只要还有一个强指针变量指向对象，对象就会保持在内存中 ARC的使用 123456int main(int argc, const char * argv[]) &#123; // 不用写release, main函数执行完毕后p会被自动释放 Person *p = [[Person alloc] init]; return 0;&#125; ARC的注意点 不允许调用对象的 release方法 不允许调用 autorelease方法 重写父类的dealloc方法时，不能再调用 [super dealloc]; ARC下单对象内存管理 局部变量释放对象随之被释放 12345678int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *p = [[Person alloc] init]; &#125; // 执行到这一行局部变量p释放 // 由于没有强指针指向对象, 所以对象也释放 return 0;&#125; 清空指针对象随之被释放 12345678int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *p = [[Person alloc] init]; p = nil; // 执行到这一行, 由于没有强指针指向对象, 所以对象被释放 &#125; return 0;&#125; 默认清空所有指针都是强指针 123456789int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // p1和p2都是强指针 Person *p1 = [[Person alloc] init]; __strong Person *p2 = [[Person alloc] init]; &#125; return 0;&#125; 弱指针需要明确说明 注意: 千万不要使用弱指针保存新创建的对象 12345678int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // p是弱指针, 对象会被立即释放 __weak Person *p1 = [[Person alloc] init]; NSLog(@&quot;%@&quot;,p); &#125; return 0;&#125; 打印结果： 12020-07-31 18:02:51.021697+0800 iOS-OC之ARC[2134:984503] (null) ARC下多对象内存管理 ARC和MRC一样, 想拥有某个对象必须用强指针保存对象, 但是不需要在dealloc方法中release 1234567@interface Person : NSObject// MRC写法//@property (nonatomic, retain) Dog *dog;// ARC写法@property (nonatomic, strong) Dog *dog;@end 自动释放池 概述 AutoreleasePool（自动释放池）是 OC 中的一种 内存自动回收机制。 当向一个对象发送 autorelease 消息时，会将对象加入到自动释放池，这个对象不会立即释放，而是等到 runloop休眠或超出autoreleasepool作用域 之后进行 释放。 MRC 下使用自动释放池 在MRC环境中使用自动释放池需要用到 NSAutoreleasePool 对象，其生命周期就相当于C语言变量的作用域。对于所有调用过 autorelease方法的对象，在废弃NSAutoreleasePool对象时，都将调用release实例方法。用源代码表示如下： 12345678910111213// MRC环境下的测试：// 第一步：生成并持有释放池NSAutoreleasePool对象;NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];// 第二步：调用对象的autorelease实例方法;id obj = [[NSObject alloc] init];[obj autorelease];// 第三步：废弃NSAutoreleasePool对象;[pool drain]; // 向pool管理的所有对象发送消息，相当于[obj release]// obj已经释放，再次调用会崩溃(Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT))NSLog(@&quot;打印obj：%@&quot;, obj); ARC 下使用自动释放池 ARC环境不能使用NSAutoreleasePool类也不能调用autorelease方法，代替它们实现对象自动释放的是 @autoreleasepool块。 12345// ARC环境下的测试：@autoreleasepool &#123; id obj = [[NSObject alloc] init]; NSLog(@&quot;打印obj：%@&quot;, obj); &#125; ARC 下 AutoReleasePool 内部实现使用@autoreleasepool{}我们在main函数中写入自动释放池相关的测试代码如下： 123456int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125; 为了探究释放池的底层实现，我们在终端使用 clang -rewrite-objc + 文件名命令将上述OC代码转化为 C++ 源码： 123456789int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_d37e0d_mi_0); &#125; // 大括号对应释放池的作用域 return 0;&#125; 在经过编译器 clang 命令转化后，我们看到的所谓的 @autoreleasePool块，其实对应着__AtAutoreleasePool的结构体。 分析结构体 __AtAutoreleasePool 的具体实现在源码中找到 __AtAutoreleasePool结构体 的实现代码，具体如下： 12345678extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; void * atautoreleasepoolobj;&#125;; __AtAutoreleasePool结构体包含了：构造函数、析构函数和一个对象； 构造函数内部调用：objc_autoreleasePoolPush() 方法，返回对象atautoreleasepoolobj 析构函数内部调用：objc_autoreleasePoolPop() 方法，传入对象atautoreleasepoolobj 分析main函数中 __autoreleasepool结构体实例的生命周期是这样的： __autoreleasepool是一个自动变量，其构造函数是在程序执行到声明这个对象的位置时调用的，而其析构函数则是在程序执行到离开这个对象的作用域时调用。所以，我们可以将上面main函数的代码简化如下： 12345678int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; void *atautoreleasepoolobj = objc_autoreleasePoolPush(); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kb_06b822gn59df4d1zt99361xw0000gn_T_main_d39a79_mi_0); objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; return 0;&#125; objc_autoreleasePoolPush 与 objc_autoreleasePoolPop进一步观察自动释放池构造函数与析构函数的实现，其实它们都只是对AutoreleasePoolPage 对应静态方法 push 和 pop 的封装： 1234567void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; 理解 AutoreleasePoolPageAutoreleasePoolPage 是一个 C++ 中的类，打开Runtime的源码工程，在NSObject.mm文件中可以找到它的定义，摘取其中的关键代码如下： 123456789101112131415161718192021class AutoreleasePoolPage &#123;# define EMPTY_POOL_PLACEHOLDER ((id*)1) // 空池占位# define POOL_BOUNDARY nil // 即哨兵对象 static pthread_key_t const key = AUTORELEASE_POOL_KEY; static uint8_t const SCRIBBLE = 0xA3; // 0xA3A3A3A3 after releasing static size_t const SIZE = #if PROTECT_AUTORELEASEPOOL PAGE_MAX_SIZE; // must be multiple of vm page size#else PAGE_MAX_SIZE; // size and alignment, power of 2#endif static size_t const COUNT = SIZE / sizeof(id); magic_t const magic; // 校验AutoreleasePagePoolPage结构是否完整 id *next; // 指向新加入的autorelease对象的下一个位置，初始化时指向begin() pthread_t const thread; // 当前所在线程，AutoreleasePool是和线程一一对应的 AutoreleasePoolPage * const parent; // 指向父节点page，第一个结点的parent值为nil AutoreleasePoolPage *child; // 指向子节点page，最后一个结点的child值为nil uint32_t const depth; // 链表深度，节点个数 uint32_t hiwat; // 数据容纳的一个上限 //......&#125;; AutoreleasePoolPage 中拥有 parent 和 child 指针，分别指向上一个和下一个 page；当前一个page的空间被占满(每个AutorelePoolPage的大小为4096字节)时，就会新建一个AutorelePoolPage对象并连接到链表中，后来的Autorelease对象也会添加到新的page中；另外，当next&#x3D;&#x3D; begin()时，表示AutoreleasePoolPage为空；当next &#x3D;&#x3D; end()，表示AutoreleasePoolPage已满。 理解 哨兵对象(POOL_BOUNDARY)的作用，而它的作用事实上也就是为了 起到一个标识的作用。 每当自动释放池初始化调用 objc_autoreleasePoolPush 方法时，总会通过 AutoreleasePoolPage 的 push 方法，将 POOL_BOUNDARY 放到当前 page 的栈顶，并且返回这个对象 atautoreleasepoolobj； 而在自动释放池释放调用 objc_autoreleasePoolPop 方法时，又会将 atautoreleasepoolobj对象 以参数传入，这样自动释放池就会向释放池中对象发送release消息，直至找到第一个边界对象为止。 理解 objc_autoreleasePoolPush 方法经过前面的分析，objc_autoreleasePoolPush 最终调用的是 AutoreleasePoolPage 的 push 方法，该方法的具体实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static inline void *push() &#123; return autoreleaseFast(POOL_BOUNDARY);&#125;static inline id *autoreleaseFast(id obj)&#123; AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123; return page-&gt;add(obj); &#125; else if (page) &#123; return autoreleaseFullPage(obj, page); &#125; else &#123;1. return autoreleaseNoPage(obj); &#125;&#125;// 压栈操作：将对象加入AutoreleaseNoPage并移动栈顶的指针id *add(id obj) &#123; id *ret = next; *next = obj; next++; return ret;&#125;// 当前hotPage已满时调用static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123; do &#123; if (page-&gt;child) page = page-&gt;child; else page = new AutoreleasePoolPage(page); &#125; while (page-&gt;full()); setHotPage(page); return page-&gt;add(obj);&#125;// 当前hotpage不存在时调用static id *autoreleaseNoPage(id obj) &#123; AutoreleasePoolPage *page = new AutoreleasePoolPage(nil); setHotPage(page); if (obj != POOL_SENTINEL) &#123; page-&gt;add(POOL_SENTINEL); &#125; return page-&gt;add(obj);&#125; 观察上述代码，每次调用 push 其实就是 创建一个新的AutoreleasePoolPage，在对应的AutoreleasePoolPage中插入一个 POOL_BOUNDARY ，并且返回插入的 POOL_BOUNDARY 的内存地址。自动释放池最终都会通过 page-&gt;add(obj) 方法 将对象添加到page中，而这一过程被分为三种情况： * 当前page存在且不满，调用 `page-&gt;add(obj)` 方法将 `对象` 添加至page的栈中，即next指向的位置 * 当前page存在但是已满，调用 autoreleaseFullPage 初始化一个新的 page，调用page-&gt;add(obj)方法将对象添加至page的栈中 * 当前page不存在时，调用 autoreleaseNoPage 创建一个 hotPage，再调用page-&gt;add(obj) 方法将对象添加至page的栈中 理解 objc_autoreleasePoolPop 方法 AutoreleasePool 的释放调用的是 objc_autoreleasePoolPop 方法，此时需要传入 atautoreleasepoolobj 对象作为参数。 同理，我们找到 objc_autoreleasePoolPop 最终调用的方法，即 AutoreleasePoolPage 的pop方法，该方法的具体实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041static inline void pop(void *token) // POOL_BOUNDARY的地址&#123; AutoreleasePoolPage *page; id *stop; page = pageForPointer(token); // 通过POOL_BOUNDARY找到对应的page stop = (id *)token; if (DebugPoolAllocation &amp;&amp; *stop != POOL_SENTINEL) &#123; // This check is not valid with DebugPoolAllocation off // after an autorelease with a pool page but no pool in place. _objc_fatal(&quot;invalid or prematurely-freed autorelease pool %p; &quot;, token); &#125; if (PrintPoolHiwat) printHiwat(); // 记录最高水位标记 page-&gt;releaseUntil(stop); // 向栈中的对象发送release消息，直到遇到第一个哨兵对象 // memory: delete empty children // 删除空掉的节点 if (DebugPoolAllocation &amp;&amp; page-&gt;empty()) &#123; // special case: delete everything during page-per-pool debugging AutoreleasePoolPage *parent = page-&gt;parent; page-&gt;kill(); setHotPage(parent); &#125; else if (DebugMissingPools &amp;&amp; page-&gt;empty() &amp;&amp; !page-&gt;parent) &#123; // special case: delete everything for pop(top) // when debugging missing autorelease pools page-&gt;kill(); setHotPage(nil); &#125; else if (page-&gt;child) &#123; // hysteresis: keep one empty child if page is more than half full if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125; &#125;&#125; 【总结】【结构】： 自动释放池的压栈和出栈，通过结构体的构造函数和析构函数实现： 压栈：调用 objc_autoreleasePoolPush() 函数，内部调用的是 AutoreleasePoolPage 的 push() 方法，返回 atautoreleasepoolobj 对象 出栈：调用 objc_autoreleasePololPop() 函数，内部调用的是 AutoreleasePoolPage 的 pop() 方法，传入 atautoreleasepoolobj 对象 【容量】： 池页大小为4096字节，每一页都包含56字节的成员变量，但一个自动释放池中，只会压栈一个哨兵对象，占8字节 【原理】： 自动释放池的本质是 __AtAutoreleasePool 结构体，包含构造函数和析构函数 结构体声明，触发构造函数，调用 objc_autoreleasePoolPush() 函数，对象压栈 如果存在page，并且没有存满，调用add函数 将对象压栈 如果存在page，但存储已满，调用autoreleaseFullPage函数 遍历链表，找到最后一个空白的子页面 对其进行创建新页 设置为热页面 添加对象 否则，不存在page，调用autoreleaseNoPage函数 通过父类AutoreleasePoolPageData进行初始化 begin：获取对象压栈的起始位置 objc_thread_self：通过tls获取当前线程 链接双向链表 设置为热页面 pushExtraBoundary为YES，哨兵对象压栈 对象压栈 结构体出作用域，触发析构函数，调用 objc_autoreleasePoolPop() 函数，对象出栈 调用popPage函数，传入stop为哨兵对象的位置 当前页中对象出栈，到stop位置停止 调用kill函数，销毁当前页面 AutoreleasePool在主线程上的释放时机 分析主线程RunLoop管理自动释放池并释放对象的详细过程，我们在如下Demo中的主线程中设置断点，并执行lldb命令：po [NSRunLoop currentRunLoop]，具体效果如下： 我们看到主线程RunLoop中有两个与自动释放池相关的Observer,对应CFRunLoopActivity的类型如下: 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), //0x1，启动Runloop循环 kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //0xa0，即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), kCFRunLoopExit = (1UL &lt;&lt; 7), //0xa0，退出RunLoop循环 kCFRunLoopAllActivities = 0x0FFFFFFFU &#125;; 结合RunLoop监听的事件类型，分析主线程上自动释放池的使用过程如下： App启动后，苹果在主线程RunLoop里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler(); 第一个Observer监视的事件 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。 第二个Observer监视了两个事件 : BeforeWaiting(准备进入休眠) 时调用 _objc_autoreleasePoolPop() 和_objc_autoreleasePoolPush() 释放旧的池并创建新池； Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄漏，开发者也不必显示创建AutoreleasePool了; 之后的时机 程序启动到加载完成后，主线程对应的RunLoop会停下来等待用户交互 用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。 RunLoop检测到事件后，就会创建自动释放池; 所有的延迟释放对象都会被添加到这个池子中; 在一次完整的运行循环结束之前，会向池中所有对象发送release消息，然后自动释放池被销毁; AutoreleasePool子线程上的释放时机子线程默认不开启RunLoop，那么其中的延时对象该如何释放呢？其实这依然要从Thread和AutoreleasePool的关系来考虑： 就是说，每一个线程都会维护自己的 Autoreleasepool栈，所以子线程虽然默认没有开启RunLoop，但是依然存在AutoreleasePool，在 子线程退出 的时候会去释放autorelease对象。 前面讲到过，ARC会根据一些情况进行优化，添加__autoreleasing修饰符，其实这就相当于对需要延时释放的对象调用了autorelease方法。从源码分析的角度来看，如果子线程中没有创建AutoreleasePool ，而一旦产生了Autorelease对象，就会调用autoreleaseNoPage方法自动创建hotpage，并将对象加入到其栈中。所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。 AutoreleasePool需要手动添加的情况 尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建 AutoreleasePool，而其中的延时对象将在当前释放池的作用域结束时释放。苹果文档中说明了三种情况，我们可能会需要手动添加自动释放池： 编写的不是基于UI框架的程序，例如命令行工具； 通过循环方式创建大量临时对象； 使用非Cocoa程序创建的子线程； 而在ARC环境下的实际开发中，我们最常遇到的也是第二种情况，以下面的代码为例： 1234567- (void)viewDidLoad &#123; [super viewDidLoad]; for (int i = 0; i &lt; 1000000; i++) &#123; NSObject *obj = [[NSObject alloc] init]; NSLog(@&quot;打印obj：%@&quot;, obj); &#125; &#125; 上述代码中，obj因为离开作用域所以会被加入最近一次创建的自动释放池中，而这个释放池就是主线程上的RunLoop管理的；因为for循环在当前线程没有执行完毕，Runloop也就没有完成当前这一次的迭代，所以导致大量对象被延时释放。释放池中的对象将会在viewDidAppear方法执行前就被销毁。在此情况下，我们就有必要通过手动干预的方式及时释放不需要的对象，减少内存消耗；优化的代码如下： 123456789- (void)viewDidLoad &#123; [super viewDidLoad]; for (int i = 0; i &lt; 1000000; i++) &#123; @autoreleasepool&#123; NSObject *obj = [[NSObject alloc] init]; NSLog(@&quot;打印obj：%@&quot;, obj); &#125; &#125; &#125;","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习02：文件导入#include,#import,@class区别","slug":"OC学习/OC学习02：文件导入#include,#import,@class区别","date":"2023-03-02T08:39:08.000Z","updated":"2023-03-02T10:13:48.926Z","comments":true,"path":"2023/03/02/OC学习/OC学习02：文件导入#include,#import,@class区别/","link":"","permalink":"https://www.bboyzj.cn/2023/03/02/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A002%EF%BC%9A%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5#include,#import,@class%E5%8C%BA%E5%88%AB/","excerpt":"","text":"前言 #include 、 #import 和 @class 都是用来 包含头文件 C/C++ 只能用 #include 包含头文件，没有 #import 和 @class OC 中 #include 、 #import 和 @class 都可以用 那么问题来了，三种包含头文件方式在 OC 中有什么区别呢？ include、import #include 会重复导入头文件，重复导入会报重复定义的错误；#import 不会重复导入头文件，允许交叉编译 #include &lt;xxx.h&gt; 或 #import &lt;xxx.h&gt; ：用于导入 系统自带文件，在 系统文件目录下查找 #include “xxx.h” 或 #import “xxx.h” ：用于导入 用户自定义的文件，查找顺序：用户文件目录 -&gt; 安装文件目录 -&gt; 系统文件目录，所以 “xxx.h” 一般用来导入用户自定义的文件 class @class XXXClassName ： 用于声明一个类，用于解决互相引用的问题（A引用B，B引用A） include 示例 A文件导入两次B文件：报重复定义错误 12345678910#import &lt;UIKit/UIKit.h&gt;// include 不允许重复导入两次#include &quot;VB.h&quot;#include &quot;VB.h&quot;NS_ASSUME_NONNULL_BEGIN@interface VA : UIView@end command + b 编译报错： A引用B，B引用C，A再引用C：同样 报重复定义错误，相当于A引用了两次C import 示例 导入两次A文件，不报错 123// 导入两次A文件#import &quot;A.h&quot;#import &quot;A.h&quot; class 使用场景 A类引用B类，B类引用A：互相引用报错 A.h文件 12345#import &lt;UIKit/UIKit.h&gt;#import &quot;B.h&quot;@interface A : UIView@property (nonatomic,strong)B * b;@end B.h文件 12345#import &lt;UIKit/UIKit.h&gt;#import &quot;A.h&quot;@interface B : UIView@property (nonatomic,strong)A * a;@end 可以用 @class 方式进行引用，一个用@class或者两个都用 @class 1234//#import &quot;A.h&quot;// class声明A@class A;","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"Blog-05：Picgo+Gitee图床","slug":"Blog搭建/Blog-05：Picgo-Gitee图床","date":"2023-03-01T11:25:22.000Z","updated":"2023-03-15T14:11:58.370Z","comments":true,"path":"2023/03/01/Blog搭建/Blog-05：Picgo-Gitee图床/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-05%EF%BC%9APicgo-Gitee%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"背景最近发现上传到 GitHub 上的图片大部分不能使用了，然后上网查了一下，应该是 DNS 的问题，网上也有很多解决方案，有兴趣的可以去网上找找，本文主要介绍 Picgo + Gitee 做图床。 警告：Gitee 最近不让做图床了，还是赶紧改回去吧，啊啊啊啊啊啊啊！！！！！ Picgo 介绍picgo 是一款功能实用、操作简捷的图床工具，图床工具简单来说就是本地图片上传自动转换成链接的一款工具。 picgo 本体支持如下图床： 七牛图床 v1.0 腾讯云 COS v4\\v5 版本 v1.1 &amp; v1.5.0 又拍云 v1.2.0 GitHub v1.5.0 SM.MS V2 v2.3.0-beta.0 阿里云 OSS v1.6.0 Imgur v1.6.0 Tips: 本体不再增加默认的图床支持。你可以自行开发第三方图床插件。 特色功能 支持拖拽图片上传 支持快捷键上传剪贴板里第一张图片 Windows 和 macOS 支持右键图片文件通过菜单上传 (v2.1.0+) 上传图片后自动复制链接到剪贴板 支持自定义复制到剪贴板的链接格式 支持修改快捷键，默认快速上传快捷键：command+shift+p（macOS） | control+shift+p（Windows\\Linux） 支持插件系统，已有插件支持 Gitee、青云等第三方图床 Tips: 请确保你安装了 Node.js， 并且版本 &gt;&#x3D; 8。 默认上传图床为 SM.MS。picgo 上传之后，会自动将上传成功的 URL复制到你的剪贴板，支持5种复制格式。 Mini窗口只支持Windows（圆形）和Linux（方形），macOS可以使用顶部栏图标。（因为Windows和Linux的任务栏不支持拖拽事件） 准备 nodejs 环境 picgo 客户端 picgo 的 Gitee 上传插件 git、Gitee 账号和一个公开仓库 安装 nodejs官网 安装 点击链接下载安装 nodejs，安装完成后，查看版本 12345mac@bogon ~ % node -vv18.14.2mac@bogon ~ % npm -vmac@bogon ~ % npm -v9.5.0 安装 picgo 客户端 picgo安装链接 如果电脑是 Intel 就选 x64，如果电脑是 M1 就选 arm64 安装 git Mac 默认是已经安装好了 git 注册&#x2F;登录 Gitee 账号 Gitee 首页按要求自行注册&#x2F;登录即可 新建一个 Gitee 仓库 仓库名：随意，如 Picgo私有创建 将仓库 开源 由于创建仓库的时候只能 私有，所以此步配置 开源 操作如下： 进入仓库 -&gt; 管理 -&gt; 基本信息 -&gt; 开源（空仓库不允许） -&gt; 保存 生成 Token Token 用于 picgo 操作 Gitee repository： 点击头像 -&gt; 设置 -&gt; 私人令牌 -&gt; 生成新令牌 -&gt; 提交 复制你生成的令牌，只显示一次，再次刷新则看不见了，因此你要保存好 配置 picgo 启动 picgo -&gt; 插件设置 -&gt; 搜索 Gitee -&gt; 点击插件图标 安装 即可，本文使用 gitee 2.0.5 插件来进行演示 Tips： 插件装完后，重启生效 配置 Gitee 插件进入 图床设置 -&gt; gitee， 依次填入相关配置如下所示，填写如下： repo： 用户名&#x2F;仓库名（必填）， bboy-zhang-jian/picgo path: 上传路径，仓库里的图片保存路径（非必填） token: 私人令牌（必填），刚才保存的 token message: 提交消息（非必填） path: 上传路径，仓库里的图片保存路径（非必填） customPath: 定制路径（非必填） customUrl: 图片定制URL（非必填） 将仓库开源头像 -&gt; 仓库 -&gt; 管理 -&gt; 公开 -&gt; 仓库公开须知全部 勾选 上传图片 将图片拖动到 上传区 里 快捷键 Ctrl + shift + p ERROR Plugin load failed: hexo-renderer-scss1mac@bogon Blog % npm install hexo-renderer-scss 出现 Error: Cannot find module ‘node-sass’1mac@bogon Blog % npm install node-sass 不用管了，版本不一致导致的 Github层图床 解决GitHub的raw.githubusercontent.com无法连接问题 今天访问 http://raw.githubusercontent.com/ 时，提示无法访问，可能是因为某些众所周知的原因导致 DNS 污染，最终通过修改 host 解决问题。 解决方案 查询真实 IP，通过 [IPAddressIPAddress.comss.com) 查询http://raw.githubusercontent.com/ 的真实 IP， 可知其真实 IP 为 185.199.108.133 修改 hosts CentOS 及 macOS 直接在终端输入 1sudo vi /etc/hosts 编辑 hosts 文件，新增下列内容 185.199.108.133 raw.githubusercontent.com 保存即可 CDN加速https://gcore.jsdelivr.net/gh/GitHub用户名/仓库名 总结但是由于 GitHub 和 Gitee 图床要不慢，要不不污染严重，最后考虑花点小钱去 阿里云OSS 存储了","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"OC学习01：事件传递链和响应链","slug":"OC学习/OC学习01：事件传递链和响应链","date":"2023-03-01T09:30:34.000Z","updated":"2023-03-02T08:54:15.933Z","comments":true,"path":"2023/03/01/OC学习/OC学习01：事件传递链和响应链/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/","excerpt":"","text":"前言在 iOS 中只有继承 UIResponder 的 对象 才能够接收并处理事件，UIResponder 是所有响应对象的 基类。继承关系如下： UIApplication -&gt; UIResponder -&gt; NSObject UIViewController -&gt; UIResponder -&gt; NSObject UIWindow -&gt; UIViww -&gt; UIResponder -&gt; NSObject UIButton -&gt; UIControl -&gt; UIView -&gt; UIResponder -&gt; NSObject UIView -&gt; UIResponder -&gt; NSObject 事件链 传递链：由系统向离用户最近的view传递。顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; RootViewController -&gt; subViews 响应链：由离用户最近的view向系统传递。顺序： superViews –&gt; RootViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate 传递链 事件传递的两个核心方法 1234// 返回哪个视图进行事件响应- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event; // 判断某一个点击的位置是否在视图范围内- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event; 其中 UIView 不接受事件处理的情况有 hidden &#x3D; YES 视图被隐藏 userInteractionEnabled &#x3D; NO 不接受响应事件 alpha &lt;&#x3D; 0.01,透明视图不接收响应事件 子视图超出父视图范围 需响应视图被其他视图盖住 是否重写了其父视图以及自身的hitTest方法 是否重写了其父视图以及自身的pointInside方法 流程描述 当iOS程序发生触摸事件后，系统会利用 Runloop 将事件加入到 UIApplication 的任务队列中 UIApplication 分发触摸事件到 UIWindow 然后 UIWindow 依次向下分发给 UIView UIView 调用 hitTest:withEvent: 方法返回一个最终响应的视图 在 hitTest:withEvent: 方法中就会去调用 pointInside: withEvent: 去判断当前点击的 point 是否在 UIView 范围内，如果是的话，就会去 逆序遍历 它的子视图来查找最终响应的 子视图 遍历的方式是使用 倒序 的方式来遍历子视图，也就是说最后添加的子视图会最先遍历，在每一个视图中都会去调用它的 hitTest:withEvent: 方法，可以理解为是一个 递归调用 最终会返回一个响应视图，如果返回视图有值，那么这个视图就作为最终响应视图，结束整个事件传递；如果没有值，那么就会将UIView作为响应者 响应链响应者链的事件传递过程 如果 view 的控制器存在，就传递给控制器处理；如果控制器不存在，则传递给它的 父视图 在视图层次结构的最顶层，如果也不能处理收到的事件，则将事件传递给 UIWindow 对象进行处理 如果 UIWindow 对象也不处理，则将事件传递给 UIApplication 对象 如果 UIApplication 也不能处理该事件，则将该事件丢弃 面试题 实现一个按钮的点击范围扩大效果 思路：自定义一个按钮，重写 poinstInSide 方法，增大内边距，返回一个新的bounds 1234567891011#import &quot;ZJBtn.h&quot;@implementation ZJBtn- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; // 当前btn大小 CGRect btnBounds = self.bounds; // 扩大按钮的点击范围，增大内边距 btnBounds = CGRectInset(btnBounds, -50, -50); // 若点击的点在新的bounds里，返回YES return CGRectContainsPoint(btnBounds, point);&#125;@end 子视图超过父视图部分仍然能响应 思路：正常情况下子视图超出部分是不能响应事件的，需重写 hitTest:withEvent 方法，指定 子视图 可点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#import &quot;VA.h&quot;@interface VA ()@property (nonatomic,strong)UIButton * btn;@end@implementation VA- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; [self addSubview:self.btn]; &#125; return self;&#125;- (void)clickBtn&#123; NSLog(@&quot;%s&quot;,__func__);&#125;- (UIButton *)btn&#123; if (!_btn) &#123; _btn = [[UIButton alloc] initWithFrame:CGRectMake(-50, 20, self.frame.size.width + 100, 100)]; _btn.backgroundColor = [UIColor blueColor]; [_btn addTarget:self action:@selector(clickBtn) forControlEvents:UIControlEventTouchUpInside]; &#125; return _btn;&#125;/* 子视图超过父视图部分，需要点击超出范围的部分也有相应 */- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // 判断btn能否接收事件 if (self.btn.userInteractionEnabled == NO || self.btn.hidden == YES || self.btn.alpha &lt;= 0.01) &#123; return nil; &#125; // 把当前点转换成btn坐标系上的点 CGPoint btnP = [self convertPoint:point toView:self.btn]; // 当触摸点在btn上时，才让按钮相应事件 if ([self.btn pointInside:btnP withEvent:event]) &#123; NSLog(@&quot;%@&quot;,NSStringFromCGPoint(btnP)); return self.btn; &#125; NSLog(@&quot;父视图相应&quot;); return [super hitTest:point withEvent:event];&#125;@end","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"iOS面试题：Swift","slug":"面试题/Swift面试题：总结","date":"2023-03-01T08:57:50.000Z","updated":"2023-03-14T19:27:15.217Z","comments":true,"path":"2023/03/01/面试题/Swift面试题：总结/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/%E9%9D%A2%E8%AF%95%E9%A2%98/Swift%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%80%BB%E7%BB%93/","excerpt":"","text":"swift 和 oc 的区别？ swift 是 静态语言，有 类型判断。OC 是 动态语言。 swift 语法简单易读、代码少，清晰、易于维护。 swift 可以面向 函数、协议、对象 编程；OC 以面向 对象 编程为主。 Swift 是 类型安全 的语言。OC 类型不安全的语言。 Swift 大部分都是 值类型，少部分是 引用类型。OC 有的是 值类型，有的是 指针类型。 静态语言：静态类型语言，数据类型是在编译期间检查的语言动态语言：动态类型语言，数据类型是在运行期间检查的语言 Optional是什么？ Object-C 中用 nil 表示 指向不存在对象的指针，其他地方用 NSNotFound 表示 值缺失 Swift 中用 可选（Optional）类型 表示 值缺失，只有可选类型才能设置为 nil Optional 含有两种枚举，None 和 Some(T)，用来 表示可能有值或可能没有值。 Swift 中只有 Optional 才能设置为 nil，用 ? 或 Optional&lt;数据类型&gt; 如何使用 Optional？ 强制解包：! 或 数据类型 != nil 可选绑定：if 赋值给常量或变量 隐士解包：直接 ! 初始化值 swift类型？Swiift 值类型 和 引用类型的区别？特点？ swift的类型分为 值类型 和 引用类型。 值类型：如 struct、enum、Int、Float、Bool、String、Array、Dictionary、String 等都是 值类型。 引用类型： 如 class类型、closure闭包、函数 等为 引用类型 区别 值类型：传递和存储 是一个 副本，使用过程中 不会影响源数据，存储在 栈区，访问一次拿到数据 引用类型：传递和存储 是 本身（内存地址），使用过程中会 影响源数据，存储在 堆区，访问两次拿到数据 什么是函数？ 函数是 一个独立的代码块，由 名字、参数、返回值 组成。 函数类型由 形式参数类型和返回类型 决定 全局函数和内嵌函数时 特殊的闭包 函数是 引用类型，存储在堆区 什么是闭包？代码中可以 被传递和引用的功能性独立的代码块 闭包作用？ 闭包 可以 捕获和存储上下文的常量和变量，闭包 实现上是一个 结构体 闭包 可以作为函数 参数，也可以作为函数的 返回值 闭包可以像 oc 中用于 回调和反向传值 闭包的几种类型？ 尾随闭包：闭包作为函数最后一个参数 逃逸闭包：函数返回之后调用 @escaping 自动闭包：延迟执行 @autoclosure 什么是枚举？oc 与 swift 枚举有啥区别？ 枚举 是一种 数据类型，只包含自定义的特定数据，值类型，存储在 栈区 OC ，枚举只支持 整数型，很鸡肋 Swift 中枚举有很多功能： 可以定义 成员类型、计算属性、类型属性（不能定义存储属性）、方法 可以定义 下标脚本 用于 获取值 可以定义 初始化器 用于 生成初始化值 可以 扩展 增加默认实现的功能 可以 遵守协议（protocol） 来 提供标准化功能。 可以 嵌套枚举、递归枚举 什么是类？什么是结构体？struct 和 class 都是 构建代码的一种通用且灵活的构造体。 struct 和 class 区别？ struct、class 共同点： 定义 属性 用于 存储值 定义 方法 用于 提供功能 定义 下标脚本 用于访问值 定义 初始化器 用于 生成初始化值 通过 扩展 以 增加默认实现的功能 符合 协议 以 提供标准功能 struct、class 不同点： class 定义 属性，必须赋值或包装成Optional。struct 定义属性不需要要赋值 class 是 引用类型，浅拷贝。struct 是 值类型，深拷贝。 class 可以继承。struct 不能继承。 class 有 引用计数，可以 多次引用。struct 没有引用计数 class 有 类型转换，允许在 运行时检查和解释一个类实例的类型。struct 没有 class 有 反初始化器 deinit 用于 释放资源 class 分配在 堆 中，动态分配释放内存，struct 分配在 栈 中，系统分配是否内存 struct 比 class 更轻量级，栈 只访问一次拿到数据，堆 访问两次拿到数据（第一次获取指针，第二次获取数据） 方法的调用？ struct&#x2F;enum&#x2F;extension：值类型，方法调用是 静态派发，直接调用 地址 class：引用类型，方法调用是 动态派发，也叫 函数表调度 什么是协议？作用？ 协议 规定了用来实现某一特定功能所必须的属性和方法，这个属性指 实例属性或类属性，而不用指定是 存储属性或计算属性 类、结构体、枚举 都可以遵循协议，提供具体的实现 来完成协议定义的 属性和方法 swift 协议 和 oc 协议有啥区别？swift 协议： 协议可以定义 属性和方法， 定义 属性 必须明确是 可读的/可读可写 &#123; set get &#125; 协议可以 继承 其他协议 协议可以 扩展协议 协议可以定义 指定初始化器或便捷初始化器 协议可以用于 类、结构体、枚举 oc 协议： 受限于委托代理，多用于不同类之间的传值和回调 什么是扩展？作用？1、扩展可以向一个已有的 类型、结构体、枚举、协议 添加新的功能， 2、作用： 可以添加 计算型实例属性 和 计算型类型属性。 可以添加 实例方法和类型方法 可以添加 新的初始化器 可以添加 下标脚本 可以使现有的 类型遵循某协议 定义和使用 新内嵌类型 扩展 可以向一个类型添加新的方法，但是不能重写已有的方法 使用注意： 不可以添加 存储属性，也不可以为已有属性添加属性观察器 泛型的作用？解决代码的复用性和抽象能力 associatedtype 关键字作用？ 关联类型：给 协议 中用到的 某个类型 起一个 占位符名称 final 关键字作用？ final：只能用于 类 中， final 声明的 类 不能被继承，final 声明的 属性、方法不能被重写。 inout 关键字作用？ inout： 输入输出形式参数，用来 修改形式参数的值，函数结束后仍然生效，因为函数的参数是 值类型 @objc 关键字作用？ @objc：用于 OC 访问 swift，类 需要继承 NSObject dynamic 关键字作用？ dynamic ：让方法具有动态性，用于 method-swizzling， 需要 类 继承 NSObject @objc + dynamic ：用来实现消息发送 mutaing 关键字作用？ mutaing：结构体内嵌函数修改存储属性， Swift的静态派发和动态派发 OC 中的 方法 都是 动态派发(方法调用)，wift 中的 方法 分为 静态派发和动态派发。 动态派发：指的是方法在 运行时才找具体实现。Swift 中的动态派发和 OC 中的动态派发是一样的. 静态派发：静态派发是指在 运行时调用方法不需要查表，直接跳转到方法的代码中执行 静态派发的特点: 静态派发更 高效，因为静态派发免去了查表操作。 静态派发的条件是方法内部的代码必须对编译器透明，且在运行时不能被更改，这样编译器才能帮助我们. Swift 中的 值类型 不能被继承，也就是说 值类型的方法实现不能被修改或者被复写，因此 值类型的方法满足静态派发. swift 是面向对象还是函数式编程？ swift 既是面向对象也是面向函数式编程 swift面向对象，是因为swift支持 类的封装、继承、多态 swift面向函数式编程，是因为swift支持 map、reduce、filter、flatmap 这类去除中间状态、数学函数式方法，更加强调运算结果而不是中间过程。 权限修饰符 open：修饰的属性或者方法在其他作用域既可以被访问，也可以被继承或重载 override。 public ：修饰的属性或者方法可以在 其他作用域允许被访问 ，但不能被重载，也不能在继承的 Extension 中被访问。 internal：被修饰的属性和方法只能在 模块内 部可以访问，超出模块内部就不可被访问了。（默认） fileprivate ：其修饰的属性或者方法只能在当前的 源文件 里可以访问。 private ：只允许在 当前类 中调用，Extension 中不能访问 从高到低排序如下： open &gt; public &gt; interal &gt; fileprivate &gt; private dynamic framework 和 static framework 的区别是什么？ 静态库和动态库, 静态库是每一个程序单独打包一份, 而动态库则是多个程序之间共享. 静态库和动态库是相对编译期和运行期的：静态库在程序编译时会被链接到目标代码中，程序运行时将不再更改静态库；而动态库在程序编译时并不会被链接到目标代码中，只是在程序运行时才被载入。 静态库在链接时，会被完整的 复制 到可执行文件中，如果多个App都使用了同一个静态库，那么每个App都会拷贝一份，缺点是 浪费内存. 动态库不会复制，只有一份，程序运行时动态加载到内存中，系统只会加载一次，多个程序共用一份，节约了内存. Swift 中的 KVC 和 KVO KVC：要继承 NSObject KVO：由于 Swift 为了效率, 默认禁用了 动态派发, 因此 Swift 要实现 KVO, 除了要继承自 NSObject 外还要将观测的对象标记为 dynamic(让 swift 代码也能有 Objective-C 中的动态机制) swift中高阶函数map、filter、reduce map 用于映射, 可以将一个列表转换为另一个列表 12[1, 2, 3].map&#123;&quot;\\($0)&quot;&#125;// 数字数组转换为字符串数组[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] filter 用于过滤, 可以筛选出想要的元素 12[1, 2, 3].filter&#123;$0 % 2 == 0&#125; // 筛选偶数// [2] reduce 合并 12[1, 2, 3].reduce(&quot;&quot;)&#123;$0 + &quot;\\($1)&quot;&#125;// 转换为字符串并拼接// &quot;123&quot; map 与 flatmap 的区别？ map 可以对一个集合类型的所有元素做一个映射操作. flatMap 第一个作用和map一样,对一个集合类型的所有元素做一个映射操作,且可以过滤为nil的情况. 12345let array = [1,2,5,6,7,nil]let array_map = array.map &#123; $0 &#125;//[Optional(1), Optional(2), Optional(5), Optional(6), Optional(7), nil]let array_flatmap = array_map.flatMap &#123; $0 &#125;//[1, 2, 5, 6, 7] 第二种情况可以进行 降维 操作 12345let array = [[&quot;1&quot;, &quot;2&quot;],[&quot;3&quot;, &quot;4&quot;]]let array_map = array.map &#123; $0 &#125;//[[&quot;1&quot;, &quot;2&quot;], [&quot;3&quot;, &quot;4&quot;]]let array_flatmap = array_map.flatMap &#123; $0 &#125;//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;] 一个函数的参数类型只要是数字（Int、Float）都可以，要怎么表示。Int、Float 都有一个协议 Numeric ，或者 ExpressibleByIntegerLiteral 协议也行 123func myMethod&lt;T&gt;(_ value: T) where T: Numeric &#123; print(value + 1)&#125; 常用的三方框架 Alamofire：网络加载 HandyJson：JSON数据解析 R.swift：使用资源文件 Snapkit：自动布局 Kingfisher：网络图片加载和缓存","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-面试题","slug":"Swift-面试题","permalink":"https://www.bboyzj.cn/tags/Swift-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"OC面试题：总结","slug":"面试题/OC面试题：总结","date":"2023-03-01T08:57:33.000Z","updated":"2023-03-09T22:00:13.767Z","comments":true,"path":"2023/03/01/面试题/OC面试题：总结/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%80%BB%E7%BB%93/","excerpt":"","text":"算法👁 OC面试题：算法 多线程👁 OC面试题：多线程 Runloop👁 OC面试题：Runloop Runtime👁 OC面试题：Runtime Block👁 OC面试题：链表 链表👁 OC学习：链表 二叉树👁 OC学习：二叉树 什么是野指针？是一个没有指向 任何内存 的 指针，尝试使用它会导致 应用程序崩溃 什么是内存泄漏？一个 对象 没有被释放，会 内存泄漏，内存泄漏会导致应用程序占用的内存会越来越大，直到应用程序无内存可用时，会导致 应用程序崩溃 iOS 关键词有哪些？各有什么作用？ 重点 readwrite 可读可写 特性，同时生成get方法和set方法的声明和实现 readonly 只读 特性，只会生成get方法的声明和实现，不希望属性在类外改变 retain 持有 特性，retaincount 会 +1,用于 MRC nonatomic 非原子 特性 atomic 原子 特性，默认属性 atomic不是绝对线程安全的，只是对 setter/getter 方法使用了 自旋锁(spinlock_t)，内部使用 互斥锁(os_unfair_lock)，保证了 读/写 安全。 atomic并不能保证 整个对象 是线程安全的，需要对 整个对象 进行 加锁 来保证线程安全： * NSLock（互斥锁） * dispathch_semaphore（信号量） * @synchronized（互斥递归锁） assign 可以修饰 基本数据类型和对象。 通常用于修饰 基本数据类型，如Int、CGFloat、Double等，这是因为 基本数据类型放在栈区，栈由编译器自动分配和释放内存，栈先进后出，基本数据类型出栈后，assign修饰的基本数据类型就不存在了，不会出现 野指针 修饰对象，如NSString、实例对象等，引用计数不会增加，但 assign 修饰对象释放后，指针 不会被系统置为nil，会产生 野指针 或 EXC_BAD_ACCESS 错误。 strong 强引用，只修饰对象，属性默认修饰符 指向并持有该对象，其修饰的对象引用计数会 +1，引用计数不为 0 则不会被销毁，需要将其置为 nil 可以销毁。否则会出现 内存泄漏。 weak 弱引用，只修饰对象。 指向但并不拥有该对象，引用计数不增加。该对象自动在内存中销毁。 copy 用于修饰 不可变的对象。 比如NSString、NSDictionary、NSArray等。 浅拷贝和深拷贝 重点 浅拷贝 浅拷贝，拷贝了一个新的指针，与原对象指针指向同一块内存，引用计数 + 1；(A,CopyA &#x3D; [A copy]，A 变化，CopyA 的值也变化) 深拷贝 深拷贝，拷贝了一个新的对象，指向新的内存，新对象的 引用计数为 1，源对象引用计数不变；(A,MutableA &#x3D; [A mutbleCopy]，A 变化，MutableA 的值不变)。 NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？重点 对于不可变NSString&#x2F;NSArray&#x2F;NSDictionary，copy浅拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝) 对于可变NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary，copy深拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝) 自定义对象的copy和mutableCopy？ 重点 copy和mutableCopy都是深拷贝(属性：浅拷贝） 属性用copy还是strong？ 重点 对于不可变属性，推荐用copy，目的是为了 让本属性不受外界影响，无论给我传入可变还是不可变对象，我本身持有的就是一个不可变的副本，被set时，改变的是这个副本。 对于可变属性，推荐用strong，因为copy修饰后，会变成不可变对象，再调用可变对象函数时会 crash 一个APP是如何唤醒另一个APP的？ 重点URL Scheme：iOS有一个特性就是将 自身绑定 到一个自定义的 URL Scheme 上，该 scheme 用于从 浏览器或其他应用中启动本应用。 UIView和CALayer UIView和CALayer的关系？ 1）UIView继承UIReponder，CALayer继承NSObject。2）UIView响应事件，CALayer绘制UI。3）UIView是CALayer的代理。 UIWindow和UIView的关系？ 1）UIWindow继承自UIView。2）UIWindow提供一个区域用来显示UIView。 单例的写法和作用？ 重点单例模式的作用：可以保证程序运行过程中，一个类只返回一个实例，供外界访问；static保证类只分配一次内存；dispatch_once方法保证调用一次，并自动加锁，线程安全 123456789101112static id _instance = nil; // 定义static全局变量，保证只分配一次内存+ (id)shareInstance&#123; return [[self alloc] init];&#125;+ (id)copyWithZone:(struct _NSZone *)zone&#123; static dispatch_once_t onceToken; // 声明一个静态的GcD单次任务 // 保证只执行一次 dispatch_once(&amp;onceToken,^&#123; // _instance = [super allocWithZone:zone]; &#125;); return p;&#125; 这么写可以保证下面两种方式返回同一个实例： 123Single * p1 = [Single shareInstance];Single * p2 = [[Single alloc] init];NSLog(@&quot;%d&quot;,p1==p2); // 1 常用的数据存储方式有哪些？各自的优缺点？ plist：plist文件是将某些特定的类，通过 XML文件 的方式保存在目录中。 NSUserdefault：归档 数据库：适合储存数据量较大的数据,一般使用FMDB和CoreData来实现. Keychain：用于 本地重要数据的存储，将数据加密后存储在本地。如：密码,秘钥,序列号 等,当你 删除APP后Keychain存储的数据不会删除，所以在重装App后，Keychain里的数据还能使用。 沙盒写入：存储非机密数据 Application：存放程序源文件，上架前经过数字签名，上架后不可修改。 Documents: 保存应⽤运行时生成的需要持久化的数据。iTunes 同步设备时会 备份 该目录。 tmp: 保存应⽤运行时所需的临时数据，使⽤完毕后再将相应的文件从该目录删除。iTunes 同步设备时 不会备份 该目录。 Library&#x2F;Caches: 保存应用运行时⽣成的需要持久化的数据。 iTunes 同步设备时 不会备份 该目录。 Library&#x2F;Preference: 保存应用的所有偏好设置。iTunes 同步设备时会 备份 该目录。 加密方式有哪些？各自的加密算法哪些？ 对称加密：又称公开密钥加密，加密和解密 都会用到 同一个密钥。常见的对称加密算法有 DES、3DES、AES、Blowfish、IDEA、RC5、RC6。 非对称加密：非对称加密又称 共享密钥加密，使用 一对非对称的密钥，一把叫做 私有密钥，另一把叫做 公有密钥；公钥加密只能用私钥来解密，私钥加密只能用公钥来解密。常见的有：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法。 成员变量和实例变量区别？ 成员变量：在文件中@interface下{}内的均统称为 成员变量 实例变量：实例变量是 类定义 的变量 区别： 去除基本数据类型int,float…等，其他类型的变量均叫做 实例变量 成员变量 = 实例变量 + 基本数据类型 @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的? @property &#x3D; _ivar + getter + setter; property（属性）&#x3D; _ivar（实例变量）+ setter（存方法）+ getter（取方法） 属性引用self.name与_name的区别？ self.name是对属性的访问，&#x3D; 左侧是调用setter方法，&#x3D; 右侧是调用getter方法，可以在类外使用，_name不能在类外使用。 _name是对 局部变量 的访问，直接调用变量，不通过getter方法 frame 和 bounds 区别？ frame：参考系是父视图坐标 bounds：参考系是自身坐标 常见的状态码？ 2xx 成功：200表示请求正常。 3xx 重定向：302是请求重定向。解决方法 NSURLConnetion 和 NSURLSession 进行拦截 4xx 客户端错误：400客户端请求的语法错误，404Not Found 找不到&#x2F;请求失败 5xx 服务器错误：500 Internal Server Error 服务器的内部错误 HTTPS和HTTP的区别？ 重点 HTTP：超文本传输协议，信息明文传输；端口号80；响应速度快（使用TCP三次握手，客户端和服务端需要交换3个包）； HTTPS：是由 HTTP+SSL&#x2F;TLS 加密传输；端口号443；响应速度慢（除了使用TCP三个包，还要加上SSL握手的9个包）；需要到CA申请证书 TCP 和 UDP 区别? 重点 都是 传输层 协议 TCP协议是 面向连接的可靠的传输层协议。UDP协议是 面向非连接的传输层协议 TCP需要 建立连接和断开连接。UDP不需要连接。 TCP传 输数据没有大小限制。UDP 传输数据有大小限制。 TCP会 处理数据丢包重发。UDP不会处理。 HTTP和socket区别？ 重点 HTTP 应用层协议；socket 不属于协议范畴，而是一个接口（API），是对TCP&#x2F;IP协议的封装 HTTP 是基于 请求-响应 形式 短连接，即客户端发送一次请求，服务端响应后立即 断开连接；socket 是基于TCP协议的 长链接，理论上 客户端和服务端一旦建立连接将不会主动断开 HTTP 传输慢，数据量大，安全差；socket 数据可自定义，数据量小，安全性高，适合信息实时交互（推送、聊天等） staitc 和 const 的区别？ 重点 const：表示 只读 的意思 const 放在 类型 前：可以改变指针的指向，可以改变指针指向的内容 const 放在 变量 前：不可以改变指针的指向，不可以改变指针指向的内容 static： 静态变量，可修饰 局部变量和全局变量，可修饰方法 static 可修饰 局部/全局变量，称为 局部静态变量和全局静态变量，只初始化一次，只分配一次内存，生命周期被改变，不再是作用域内 static 修饰的 方法，可以在不同文件下重名，互不影响运行 通用链接（Universal Links）重点 服务端配置 HTTPS 证书 和添加 apple-app-site-association 地址关联文件 移动端在plist添加 Associated Domains 关联域权限 简述GET和POST请求的区别？ 重点 GET 传输数据 有缓存；POST 传输数据 没有缓存 GET的 参数 放在 URL 的后面，并且第一个参数用 ? 号拼接，后面的从第二个参数开始，直到最后一个，用 &amp; 分割；POST的 参数 放在 请求体 里面，并且第一个参数用 , 号拼接，后面从第二开始，直到最后用 &amp; 分割; GET一般用于 获取数据；POST一般用于 向服务器提交数据 GET 的参数是暴漏在 地址栏 的，不安全；POST 的参数隐藏在 请求体 里面，相对安全一点; iOS中几种常见的设计模式？ 重点 代理模式 一对一的依赖关系，当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。 观察者模式 KVO机制 和 Notification通知机制 单例模式 保证程序运行过程中，一个类只返回一个实例，供外界访问 工厂模式 通过一个类方法，根据已有模板批量生产对象。 MVC模式 Model即数据模型 view即视图 controller即控制器 RunLoop是什么？ 重点 概念 RunLoop 又叫 运行循环，内部就是一个 do-while循环，在这个循环内部不断 处理各种任务，保证程序持续运行。 目的 RunLoop存在的目的： 就是当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，提高程序性能，节省CPU资源，该做事的时候做事，该休息的时候休息 RunLoop的作用？ 重点 保持程序持续运行。 App一启动就会开启主线程，主线程在开启的时候就会开启主线程对应的RunLoop，RunLoop能保证线程不被销毁，主线程不销毁，程序就会持续运行。 处理App中各类事件。 事件响应、手势识别、界面刷新、AutoreleasePool自动释放池、NSTimer等事件处理。 节省CPU资源，提高程序性能。 如概述所述，当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，提高程序性能，节省资源，该做事的时候做事，该休息的时候休息。 可以用Runloop实现什么功能？ 重点 tableView 滚动时图片不加载 SDWebImage + Runloop，图片延迟加载，滑动不加载图片 线程保活 往 runloop 中添加 [[NSPort alloc] init] 事件， 解决NSTimer在滑动时停止工作的问题 default 模式改为 common 模式 检测卡顿 displaylink + runloop 进行卡顿检测，将数值和页面绑定上传到服务器 RunLoop接收几种输入源，系统默认定义了几种模式？ 重点 输入源有两种基于 端口 的输入源（port）自定义 的输入源（custom） 系统定义的RunLoop模式有五种，最常用的有三种，如下所示：NSDefaultRunLoopMode默认模式，主线程中默认是NSDefaultRunLoopModeUITrackingRunLoopMode视图滚动模式，RunLoop会处于该模式下NSRunLoopCommonModes并不是真正意义上的Mode，是一个占位用的“Mode”，默认包含了NSDefaultRunLoopMode和UITrackingRunLoopMode两种模式 RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？ 重点 每一个线程都有一个runloop，主线程的runloop默认启动。子线程的runloop默认不启动 mode：主要用来指定事件在运行时循环的优先级 作用：保持程序的持续运行、随时处理各种事件、节省cpu资源(没事件休息释放资源)，提高程序的性能。 怎么理解Objective-C是动态运行时语言。 重点主要是 将数据类型的确定和函数的调用由编译时推迟到了运行时。这个问题其实浅涉及到两个概念，运行时和多态。 运行时：简单来说，运行时机制使我们 直到运行时才去确定数据类型和要调用的函数。 多态：不同对象以自己的方式响应相同的消息的能力 叫做多态。 runtime项目中具体应用？ 重点 方法交换。 给 分类添加属性。 动态添加方法。 字典转模型。 数组越界。 动态获取成员属性、成员变量、实例方法 KVC是什么？重点KVC 全程 Key Value Coding，中文 键值编码，是由 NSKeyValueCoding 非正式协议启动的一种机制，对象 采用该协议来 间接访问对象的属性。 12345- (nullable id)valueForKey:(NSString *)key; - (nullable id)valueForKeyPath:(NSString *)keyPath; - (void)setValue:(nullable id)value forKey:(NSString *)key;- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; KVC底层原理： KVO是什么？重点KVO 全程 Key Value Observing，中文 键值观察，它 用于监听实例对象属性的变化。 KVO的实现原理？(KVO的本质是什么？) 重点当一个 实例对象 的 属性注册了KVO，实例对象 isa指针 的指向在注册KVO观察者之后，由 原有类 改为 中间类(NSKVONotifing_类名)；中间类 重写了 属性setter方法、class、dealloc、_isKVOA 方法；dealloc 方法中，移除 KVO 观察者之后，实例对象isa 指向由 中间类 更改为 原有类;中间类 从创建后就 一直存在内存中，不会被销毁。 KVO实际应用 重点 观察 实例对象 的 属性 变化 观察 实例对象 的 容器 变化 观察容器用： mutableArrayValueForKey KVO底层原理： category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？重点 category 原则上它 只能增加方法，不能增加成员（实例）变量。可以添加属性，但是不会自动生成实例变量_name和setter和getter方法。可以添加方法 扩展 主要用来为一个类添加额外的原来没有的 实例变量、方法和属性。extension常用的形式并不是以一个单独的.h文件存在，而是寄生在类的.m文件中。 类扩展中： 123456@interface Person ()&#123; int age; //实例变量&#125;@property (nonatomic,copy)NSString * name;//属性- (void)run;//方法@end load、initialize的区别，以及它们在category重写的时候的调用的次序？ 区别在于 调用方式和调用时刻 调用方式： load是根据 函数地址 直接调用，initialize是通过 objc_msgSend 调用 调用时刻： load 是 runtime加载类、分类的时候调用 initialize 是 类第一次接收到消息的时候调用 调用顺序： 父类的load &gt; 类load &gt; 分类中load(多个分类：先编译的分类优先调用load方法)。 先调父类initialize -&gt; 再调子类initialize。 如果有分类：父类initialize -&gt; 分类initialize，分类覆盖类的+initialize。 super的本质？ [self class] : 返回实例对象的类 [self superclass] : 返回实例对象的父类 [super class] : 编译指示器(标识符)，底层会被编译成 objc_msgSendSuper() 方法，返回实例对象的类 [super superclass] : 返回父类 简述下Objective-C中调用方法的过程？Objective-C是动态语言，每个方法在 运行时 会被动态转为 消息发送，即：objc_msgSend(receiver, selector)，整个过程介绍如下：person实例对象发送一条test消息： 消息发送阶段： 负责从 类及父类的缓存列表及方法列表查找方法。每当调用方法的时候，会先去cache中查找是否有缓存的方法，如果没有缓存，在去类对象方法列表中遍历查找，如果方法不在列表里面；就会通过superclass找到父类的类对象，在去父类cache中查找是否有缓存的方法，如果没有缓存，去父类对象方法列表里面遍历查找，以此类推直到找到方法之后，就会将方法直接存储在cache中，下一次在调用这个方法的时候，就会在类对象的cache里面找到这个方法，直接调用了。 动态方法解析 如果消息发送阶段没有找到方法，则会进入动态解析阶段，负责动态的添加方法实现。 动态解析对象方法时，会调用：+(BOOL)resolveInstanceMethod 动态解析类方法时，会调用：+(BOOL)resolveClassMethod:(SEL)sel。 快速转发阶段 如果也没有实现动态解析方法，则会进行消息转发阶段，将消息转发给可以处理消息的接受者来处理。以处理消息的接受者来处理。- (id)forwardingTargetForSelector:由上述代码可以看出，当本类没有实现方法，并且没有动态解析方法，就会调用forwardingTargetForSelector函数，进行消息转发，我们可以实现forwardingTargetForSelector函数，在其内部将消息转发给可以实现此方法的对象。 慢速转发阶段 方法签名：返回值类型、参数类型- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector 如果forwardingTargetForSelector函数返回为nil或者没有实现的话，就会调用methodSignatureForSelector方法，用来返回一个方法签名，这也是我们正确跳转方法的最后机会。 NSInvocation 封装了一个方法调用，包括：方法调用者，方法，方法的参数- (void)forwardInvocation:(NSInvocation *)anInvocation 如果methodSignatureForSelector方法返回正确的方法签名就会调用forwardInvocation方法，forwardInvocation方法内提供一个NSInvocation类型的参数，NSInvocation封装了一个方法的调用，包括方法的调用者，方法名，以及方法的参数。在forwardInvocation函数内修改方法调用对象即可。如果methodSignatureForSelector返回的为nil，就会来到doseNotRecognizeSelector:方法内部，程序crash提示无法识别选择器unrecognized selector sent to instance。 如果消息转发也没有实现，就会报方法找不到的错误，无法识别消息，unrecognzied selector sent to instance 循环引用的几种情况和解决方式？ 重点 Block 原因： self 强引用了 block，而 block 内部又调用了 self解决： 使用 Weak-Strong Dance Delegate 原因：委托者和被委托人之间的相互强引用问题 strong解决：用 weak 进行弱引用 或者 通过中间对象(代理对象)的方式来解决(效率更加高的中间对象NSProxy：不需要进行发送消息和动态解析，直接进行消息转发) NSTimer 原因：self → timer → self(target) 的循环持有链解决：在适当的时机销毁 12[_timer invalidate];_timer = nil; OC 如何进行内存管理的？ 重点 手动内存管理 MRC 自动内存管理 ARC LLVM + Runtime 会为我们代码自动插入 retain 和 release 以及 autorelease等代码,不需要我们手动管理 自动释放池 自动释放池原理 重点 自动释放池的本质是 __AtAutoreleasePool 结构体，包含构造函数和析构函数 结构体声明，触发构造函数，调用 objc_autoreleasePoolPush() 函数，对象压栈 结构体出作用域，触发析构函数，调用 objc_autoreleasePoolPop() 函数，对象出栈 内存优化 重点 cell复用 绘制的话：用CAShaperLayer，渲染快，内存使用高效 按需加载：懒加载 合理利用缓存：比如三方图片压缩缓存 尽量使用透明View：控件有背景色增大内存消耗 启动优化 重点 pre-main 阶段：二进制重排 尽量 少用外部动态库，苹果官方建议自定义的动态库最好 不要超过6个，如果超过6个，需要 合并 动态库 减少 OC 类，因为类越多，越耗时 将不必须在 +load 方法中做的事情延迟到 +initialize 中，尽量不要用 C++ 虚函数 main 阶段：mian -&gt; didFinishLaunching 减少启动初始化的流程，能懒加载的懒加载，能延迟的延迟，能放后台初始化的放后台，尽量少占用主线程的启动时间 优化代码逻辑，去除非必须的代码逻辑，减少每个流程的消耗时间 启动阶段能 使用多线程 来初始化的，就使用多线程 尽量 使用纯代码 来进行UI框架的搭建，尤其是主UI框架，例如 UITabBarController，尽量避免使用Xib或者SB，相比纯代码而言，这种更耗时 删除废弃类、方法 卡顿监听 重点主要是用 displayLink + Runloop 进行FPS监测 主要从减轻 CPU 和 GPU 消耗入手，保证写一个 VSync 到来时，CPU 和 GPU 能够写作完成下一帧的渲染并缓存到帧缓冲区 卡顿优化在 CPU 层面： 1）尽量用轻量级的对象，比如 用不到事件处理 的地方，可以考虑使用 CALayer 取代 UIView2）不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改3）尽量 提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性4）图片的 size 最好刚好跟 UIImageView 的 size 保持一致5）控制一下线程的最大并发数量6）尽量把 耗时的操作放到子线程：如text宽高获取等 卡顿优化在 GPU层面： 1）GPU能处理的 最大纹理 尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸2）尽量 减少视图数量和层次3）减少透明的视图（alpha&lt;1），不透明的就设置 opaque 为 YES4）尽量 避免出现离屏渲染：圆角、阴影、遮罩等 tableView卡顿优化 重点 最常用的就是cell的复用， 注册复用标识符 避免cell的重新布局，初始化时就布局好 提前计算并缓存cell的高度 减少cell中控件的数量，少动态添加 view 避免背景透明 能使用局部更新 的就使用 局部更新 加载网络数据，下载图片，使用异步加载，并缓存 按需加载cell：cell滚动很快时，只加载范围内的cell 不要实现无用的代理方法，tableView只遵守两个协议 网络优化 重点 DNS优化：即域名解析优化，缓存 ip 资源优化： 图片webp，比png&#x2F;jpg小 数据传输用ProtocolBuffer代替json，数据小，序列化和反序列化也简单 请求压缩、请求合并 数据缓存 网络环境监测 针对性请求重试 TCP三次握手，四次挥手过程？重点 为什么是三次握手，而不是二次握手？ 三次握手是为了建立一个可靠的数据传输通道： 刚开始客户端和服务端处于关闭状态，而且服务端B一直处于监听状态，时刻监听是否有建立连接的请求 当客户端需要建立连接的时候就会发送一个 请求连接 的报文，此报文是 同步报文SYN=1，并且会生成一个 随机的序号seq=x，这是第一次握手 当服务端接收到请求连接报文时，会发送一个 确认连接 的报文，此报文是 同步报文SYN=1，并且 确认报文ACK=1，同时服务端也会生成一个 随机的序号seq=y，并且将 确认报文确认号ack=x+1，回传给客户端，这是第二次握手 当客户端接收到服务端的 ACK确认报文后，会回复一个 ACK确认报文，用于确认确认报文已经收到，此报文 ACK=1，seq=x+1，ack=y+1，这是第三次握手 四次挥手 四次挥手则是为了保证数据传输完成接收再关闭连接。 客户端断开连接时会发送一个 请求断开连接 的报文，此报文是 FIN=1，并且会生成一个 随机的序号seq=u，发送给服务端，这是第一次挥手 服务端接收到请求断开连接 FIN报文 后，回复一个 确认断开连接 报文 ACK=1,seq=v,ack=u+1，这是第二次挥手 当服务端数据发送完后，再发送一个FIN报文给客户端，通知客户端，服务端准备关闭连接，此报文 FIN=1,ACK=1,ack=u+1,seq=w，这是第三次挥手 当客户端收到 FIN确认报文，再发送一个FIN确认报文 ACK=1,seq=u+1,ack=w+1，并进入 TIME-WAIT 等待，等待 2MSL 后关闭连接，这是第四次挥手 事件链 重点OC学习01：事件传递链和响应链 传递链：由系统向离用户最近的view传递。顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; ViewController -&gt; subViews 响应链：由离用户最近的view向系统传递。顺序： superViews –&gt; ViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate 事件传递的两个核心方法？ 重点1234// 返回最适合处理事件的视图- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event; // 判断点是否在这个View内部- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event; 第一个方法返回的是一个 UIView，是用来寻找最终哪一个视图来响应这个事件 第二个方法是用来判断某一个点击的位置是否在视图范围内，如果在就返回YES 实现一个按钮的点击范围扩大效果 重点自定义一个按钮，继承UIButton，重写 pointInside:withEvent: 方法， 12345678- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; // 当前btn大小 CGRect btnBounds = self.bounds; // 扩大按钮的点击范围，增大内边距 btnBounds = CGRectInset(btnBounds, -10, -10); // 若点击的点在新的bounds里，返回YES return CGRectContainsPoint(btnBounds, point);&#125; 子视图超过父视图部分仍然能响应 重点重写 hitTest:withEvent 方法，让 子视图 去相应事件 123456789101112131415- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // 判断btn能否接收事件 if (self.btn.userInteractionEnabled == NO || self.btn.hidden == YES || self.btn.alpha &lt;= 0.01) &#123; return nil; &#125; // 把当前点转换成btn坐标系上的点 CGPoint btnP = [self convertPoint:point toView:self.btn]; // 当触摸点在btn上时，才让按钮相应事件 if ([self.btn pointInside:btnP withEvent:event]) &#123; NSLog(@&quot;%@&quot;,NSStringFromCGPoint(btnP)); return self.btn; &#125; NSLog(@&quot;父视图相应&quot;); return [super hitTest:point withEvent:event];&#125; SDWebImage流程 入口 setImageWithURL:placeholderImage:options:会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。 进入 SDWebImageManagerdownloadWithURL:delegate:options:userInfo:，交给 SDImageCache 从缓存查找图片是否已经下载queryDiskCacheForKey:delegate:userInfo: 先从内存图片 缓存查找 是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate 会调用 imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。 SDWebImageManagerDelegate 会调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache 等前端展示图片。 如果 内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从 硬盘查找 图片是否已经缓存。 根据 URLKey 在硬盘缓存目录下尝试 读取图片文件，这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate。 如果上一操作 从硬盘读取到了图片，将 图片添加到内存缓存 中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调imageCache:didFindImage:forKey:userInfo:，进而回调展示图片。 如果从 硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要 下载图片，回调 imageCache:didNotFindImageForKey:userInfo:。 共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。 图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。 connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果。 connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。 图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。 在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader。 imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。 通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。 将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。 SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。19）SDWebImage 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache，方便使用。20）SDWebImagePrefetcher 可以预先下载图片， 缓存策略： 它的底层是用 NSCache 在实现的，NSCache 是 Foundation框架 提供的缓存类的实现，它是线程安全的。在内存不足时NSCache会自动释放存储的对象。key是不会重复的。 SDWebImage的缓存策略：缓存有关的一共有四个文件 SDImageCacheConfig和SDImageCache，SDImageCacheConfig配置类，保存一些缓存策略的信息（压缩图片-YES、iCloud备份-关闭、内存做缓存-YES、最长时间默认1周、缓存占用最大的空间-字节）， SDImageCache通过 url作为key，UIImage作为value存到内存。并开启异步串行队列将图片编码存储到磁盘中defalut文件下，key为url做了MD5加密并拼接defalut路径为绝对路径。 AFNetworkingAFNetworking 底层原理分析：AFNetworking主要是对 NSURLSession 的封装,其中主要有以下类: AFHTTPSessionManager：内部封装是 NSURLSession, 负责发送⽹络请求，使⽤最多的⼀个类。 AFNetworkReachabilityManager：实时监测⽹络状态的⼯具类。当前的⽹络环境发⽣改变之后,这个⼯具类就可以检测到。 AFSecurityPolicy：⽹络安全的⼯具类, 主要是针对 HTTPS 服务。 AFURLRequestSerialization：序列化⼯具类 AFURLResponseSerialization：反序列化⼯具类 AFJSONResponseSerializer：JSON解析器，默认的解析器. AFHTTPResponseSerializer：万能解析器， JSON和XML之外的数据类型，直接返回⼆进制数据，对服务器返回的数据不做任何处理. MJEetension主要作用是将 json -&gt; Model，主要分为三步 创建模型 为模型中的属性赋值 返回模型 原理： 使用 Runtime 动态获取模型的类和其所有父类的所有的 属性名（包括继承链的所有属性，MJExtension对模型的属性做了 缓存，下次转换时自己使用，空间换时间） 将服务器返回的 json数据转为字典，并根据属性名在数据字典中获取对应的 值 将取出的值使用 KVC（setValue:forKey）设置给 Model 即可 主要是用runtime API是实现的数据解析，将字典转模型 MJRefresh下拉刷新的基本原理：大部分的下拉刷新控件，都是用 contentInset 实现的。大部分的下拉刷新控件，都是将自己放在 UIScrollView 的上方，起始y设置成负数，所以平时不会显示出来，只有下拉的时候才会出现，放开又会弹回去。然后在loading的时候，临时把contentInset增大，相当于把UIScrollView往下挤，于是下拉刷新的控件就会显示出来，然后刷新完成之后，再把contentInset改回原来的值，实现回弹的效果 通过 UIScrollView+MJRefresh 里的一个category，为UIScrollView增加了属性header和footer。 通过 KVO 监听UIScrollView的contentOffset和contentSize实现状态监听 下拉的时候临时增大contentInset，令header保留在屏幕上。上拉同理。 项目面试题直播功能怎么实现的？直播间是通过集成金山云SDK实现的，分为两端 主播 和 观众 主播 通过 推流 创建直播间，通过 摄像头和麦克风 获取 音视频流 ，设置 推流参数，主要是 视频编码器和音频编码率的设置，设置完推流参数之后，将流媒体推送服务器 观众 进入直播间，初始化播放器，从服务器获取播放拉流的数据 直播间的聊天IM实现？ 聊天功能是使用的融云SDK，通过加入聊天室实现的。 融云SDK实现了私聊的功能 自己写的聊天页面，通过 融云接口 传入参数 会话类型：单聊、群组。聊天室等，目标会话ID），消息数量，获取某个会话的内容。发送文本消息、图片消息，监听消息，刷新列表 面试官问还有什么想问的？ 重点技术面不问薪资待遇，人事面问薪资待遇 问岗位： 在这个岗位上，会直接 接触到哪些类型的项目？ 这个岗位的主要职责是什么？主要的KPI是什么？ 这个岗位如何评估绩效，试用期需要达到什么指标？ 这个岗位的最大挑战是什么？ 问团队： 团队的基本情况？ 这个团队在公司的角色是什么？ 可以跟我介绍一下我的领导吗？ 问公司 公司的文化氛围是什么样的？ 员工的晋升机制是什么样的？我这个岗位的晋升机会如何？ 这个岗位所在的团队如何支持公司目标的实现？","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-面试题","slug":"OC-面试题","permalink":"https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"Blog-04：主题完善","slug":"Blog搭建/Blog-04：主题完善","date":"2023-03-01T02:54:01.000Z","updated":"2023-03-01T17:50:03.426Z","comments":true,"path":"2023/03/01/Blog搭建/Blog-04：主题完善/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-04%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/","excerpt":"","text":"前言我们以 Snippet 主题问例 下载安装1mac@bogon Blog % $ git clone git://github.com/shenliyang/hexo-theme-snippet.git themes/hexo-theme-snippet 安装主题插件1mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S 部署主题具体部署看下面的链接：1、2、3步骤可省略 Snippet","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"Blog-03：Github域名绑定阿里云域名","slug":"Blog搭建/Blog-03：Github域名绑定阿里云域名","date":"2023-03-01T02:17:25.000Z","updated":"2023-03-09T07:08:25.789Z","comments":true,"path":"2023/03/01/Blog搭建/Blog-03：Github域名绑定阿里云域名/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-03%EF%BC%9AGithub%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/","excerpt":"","text":"注册域名去 阿里云 注册账号、并购买域名，具体流程这里就不一一介绍了 域名解析 在终端 ping 一下之前配置的静态页面地址,可以获取到对应的ip地址: 123456mac@bogon ~ % ping BboyZJ.github.ioPING bboyzj.github.io (185.199.109.153): 56 data bytes64 bytes from 185.199.109.153: icmp_seq=0 ttl=50 time=261.217 ms64 bytes from 185.199.109.153: icmp_seq=1 ttl=50 time=337.547 ms64 bytes from 185.199.109.153: icmp_seq=2 ttl=50 time=260.716 ms... @解析 记录类型：A主机记录：@解析请求来源：默认记录值：185.199.109.153TTL：10分钟 点击确定 www解析 记录类型：CNAME主机记录：www解析线路来源：默认记录值：BboyZJ.github.ioTTL：10分钟 点击确定 配置项目 CNAME 在 Blog/source 目录下，新建 CNAME 文件，内容输入阿里云申请的域名 www.bboyzj.cn 12mac@bogon ~ % cd /Users/mac/Desktop/Blog/source mac@bogon source % touch CNAME 配置 Blog 目录下 _config.yml 文件，URL 模块 123456789# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://www.bboyzj.cnroot: /BboyZJ.github.io/permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks 执行 123mac@bogon ~ % hexo cleanmac@bogon ~ % hexo gmac@bogon ~ % hexo d 提交陈成功后，就可以在 GitHub 和 www.bboyzj.cn 个人域名绑定上了","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"Blog-02：部署博客到GitHub","slug":"Blog搭建/Blog-02：部署博客到GitHub","date":"2023-03-01T01:12:01.000Z","updated":"2023-03-14T22:15:16.916Z","comments":true,"path":"2023/03/01/Blog搭建/Blog-02：部署博客到GitHub/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-02%EF%BC%9A%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0GitHub/","excerpt":"","text":"注册GitHub账号前往 Github 网站，注册一个新用户。用邮箱注册的一定前往邮箱去验证邮件。 部署到 GitHub 上 新建 reponsity 仓库 仓库名设置成 用户名.github.io ，比如我的是 BboyZJ.github.io，选择 Public，勾选 Add a README file ，最后 Create respository 配置秘钥 查看秘钥 123$ cd ~/.ssh$ ls$ cat id_rsa.pub 添加SSH秘钥：头像 -&gt; Setting -&gt; SSH and GPG keys Title 随意写，Key 需要填写刚才复制的 秘钥 文本内容 添加完成，验证链接 123mac@bogon ~ % ssh -T git@github.comHi BboyZJ! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 上传文件到 GitHub 配置 Blog 下 _config.yml 中的 Deployment 模块 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repository: https://github.com/BboyZJ/BboyZJ.github.io.git branch: master 安装部署插件 通过 Hexo 发布到 GitHub，需要安装部署插件 1mac@bogon ~ % npm install hexo-deployer-git --save 部署 123mac@bogon ~ % cd /Users/mac/Desktop/Blogmac@bogon ~ % hexo gmac@bogon ~ % hexo d 访问 这时我们的 GitHub 域名 https://BboyZJ.github.io 就可以看到 Hexo 网站了，如果没显示出来就 刷新 一下","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"Blog-01：Hexo个人博客搭建","slug":"Blog搭建/Blog-01：Hexo个人博客搭建","date":"2023-02-28T23:39:40.000Z","updated":"2023-03-14T22:15:01.662Z","comments":true,"path":"2023/03/01/Blog搭建/Blog-01：Hexo个人博客搭建/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-01%EF%BC%9AHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Hexo 什么是Hexo？ 简介：Hexo 是一个快速、简洁且高效的博客框架。想要详细的了解 Hexo，去官网学习。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提 检查是否安装 homebrew 12345mac@bogon ~ % brew -vHomebrew 3.6.21-28-ge6548a8Homebrew/homebrew-core (git revision 5434c8344e8; last commit 2023-02-09)Homebrew/homebrew-cask (git revision 15c2c1fa53; last commit 2023-02-09)mac@bogon ~ % 如果顺利显示版本号，说明homebrew已经安装。否则，输入以下命令进行安装： 1mac@bogon ~ % ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装过程如果出现下面的问题 1curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused 解决: 1mac@bogon ~ % /usr/bin/ruby -e &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)&quot; 安装 Node.js 123mac@bogon ~ % brew install nodemac@bogon ~ % node -vv18.14.2 安装GitMac系统默认已经安装好了，所以不需要再安装 安装Hexo如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往安装 Hexo 步骤。 使用npm完成 hexo 安装 12345678910111213141516171819202122mac@bogon ~ % npm install -g hexo-climac@bogon ~ % hexo -vhexo-cli: 4.1.0os: Darwin 21.6.0 darwin x64node: 12.16.1v8: 7.8.279.23-node.31uv: 1.34.0zlib: 1.2.11brotli: 1.0.7ares: 1.15.0modules: 72nghttp2: 1.40.0napi: 5llhttp: 2.0.4http_parser: 2.9.3openssl: 1.1.1dcldr: 35.1icu: 64.2tz: 2019cunicode: 12.1mac@bogon ~ % 建站 桌面新建 Blog 文件夹，打开终端，cd到 Blog 下，执行: 123456789101112mac@bogon ~ % cd /Users/mac/Desktop/Blog mac@bogon Blog % hexo initINFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO Install dependenciesnpm notice npm notice New major version of npm available! 7.3.0 -&gt; 9.5.1npm notice Changelog: https://github.com/npm/cli/releases/tag/v9.5.1npm notice Run npm install -g npm@9.5.1 to update!npm notice INFO Start blogging with Hexo!mac@bogon Blog % 【目录文件】： _config.landscape.yml：网站本地配置信息_config.yml：网站的配置信息，可以在此配置大部分的参数source–posts：存放 md 文件themes：主题文件夹，常用主题 会放入这里public：Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 hexo 测试 生成静态页面 1mac@bogon Blog % hexo g 会在根目录 Blog\\ 下生成 public 文件夹，里面包含相应的 html 页面。 启动服务器 1mac@bogon Blog % hexo s 打开浏览器，输入网址: http://localhost:4000 ，即可看到hexo生成的静态页面。 停止服务器 Ctrl + C 主题hexo提供了很多主题可以参考，下面以 hexo-theme-casual 主题为例 安装主题插件 hexo-theme-redefine 1无 hexo-theme-casual 1mac@bogon Blog % $ npm install --save hexo-renderer-jade hexo-renderer-scss hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-generator-search hexo-theme-snippet 1mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S hexo-theme-butterfly 12mac@bogon Blog % $ git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterflymac@bogon Blog % $ npm install hexo-renderer-pug hexo-renderer-stylus 下载主题 进入主题的 github 下载页，点击 code -&gt; clone，复制 https 下载链接，进入 博库Blog目录，运行下面的命令： 123mac@bogon Blog % cd /Users/mac/Desktop/Blog mac@bogon Blog % cd themes mac@bogon themes % git clone https://github.com/littlewin-wang/hexo-theme-casual.git 【注】：主题存放的目录是 Blog/themes，为了方便管理，每一个下载的主题都建一个单独的目录，我这个主题的目录是 hexo-theme-casual，可以下载多个主题: 主题应用 找到 博客Blog 目录下的配置文件 _config.yml，找到 Extensions 模块，修改 theme 字段： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-casual 启动本地服务器 1234567891011mac@bogon Blog % hexo sINFO Validating configINFO Start processingINFO Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.[Browsersync] Access URLs: ---------------------------------- UI: http://localhost:3001 ---------------------------------- UI External: http://localhost:3001 ---------------------------------- 查看效果 通过 http://localhost:4000/ 查看修改后的效果 主题更新 这一步不是必须的，如果主题有优化，我们需要在本地同步更新一下 12mac@bogon Blog % /Users/mac/Desktop/Blog/themes/casual mac@bogon Blog % git pull 其他命令 清除旧的内容 hexo clean 生成静态发布页面 hexo g 发布页面 hexo d","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"OC架构00：MVVM双向数据绑定","slug":"OC学习/OC学习00：MVVM双向数据绑定","date":"2023-02-27T13:57:46.000Z","updated":"2023-03-08T22:48:12.050Z","comments":true,"path":"2023/02/27/OC学习/OC学习00：MVVM双向数据绑定/","link":"","permalink":"https://www.bboyzj.cn/2023/02/27/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A000%EF%BC%9AMVVM%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","excerpt":"","text":"MVVM 是什么？MVVM 包含三部分： Model：模型层，主要是存放数据 View：视图层，UI 绘制 ViewModel：业务逻辑处理层，将 Model 和 View 分开，可以取出 Model 的数据，同时处理 View 要展示的内容涉及的业务逻辑 MVVM 采用双向数据绑定： MVVM 优劣 优势 代码清晰：ViewModel 分离大部分 VC 代码 方便测试：可对 ViewModel 构造单元测试 开发解耦：一位开发者负责逻辑实现，一位开发者负责 UI 实现 劣势 代码量多，需要对每个 Controller 实现绑定 实战思路 VC 下代码 123456789101112131415161718#import &quot;ZJTwoViewController.h&quot;#import &quot;ZJTwoViewModel.h&quot;@interface ZJTwoViewController ()@property (nonatomic,strong)UIButton * btn;@property (nonatomic,strong)ZJTwoViewModel * viewModel;@end@implementation ZJTwoViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor];; // 绑定VC self.viewModel = [[ZJTwoViewModel alloc] initWithVC:self];&#125; Model下代码 1234567@interface ZJTwoModel : NSObject@property (nonatomic,copy)NSString * name;@end@implementation ZJTwoModel@end View 下代码 12345678910111213@protocol ZJTwoViewDelegate &lt;NSObject&gt;- (void)doSomethings;@end@interface ZJTwoView : UIView// 有用VM@property (nonatomic,weak)ZJTwoViewModel * viewModel;// 设置代理@property (nonatomic,weak)id&lt;ZJTwoViewDelegate&gt;delegate;// 自身控件@property (nonatomic,strong)UILabel * label;@end .m 文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344#import &quot;ZJTwoView.h&quot;@implementation ZJTwoView- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; [self addSubview:self.label]; &#125; return self;&#125;#pragma mark -lazy- (UILabel *)label&#123; if (!_label) &#123; _label = [[UILabel alloc] initWithFrame:CGRectMake(20, 40, self.frame.size.width - 40, self.frame.size.height - 80)]; _label.backgroundColor = [UIColor orangeColor]; _label.textAlignment = NSTextAlignmentCenter; &#125; return _label;&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // 代理 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(doSomethings)]) &#123; [self.delegate doSomethings]; &#125;&#125;// 重写 setter 方法，监听来自 viewModel 的数据- (void)setViewModel:(ZJTwoViewModel *)viewModel&#123; // 获取数据 _viewModel = viewModel; /* 实现监听 比如 RAC（好多公司都使用MVVM+RAC两者搭配） */ RACSignal * signal = [viewModel rac_valuesForKeyPath:@&quot;name&quot; observer:self]; [signal subscribeNext:^(NSString * name) &#123; NSLog(@&quot;name=%@&quot;,name); &#125;];&#125;@end ViewModel 下代码 .h 文件 123456789#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface ZJTwoViewModel : NSObject// 入口方法- (instancetype)initWithVC:(UIViewController *)controller;@end .m 下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#import &quot;ZJTwoViewModel.h&quot;#import &quot;ZJTwoView.h&quot;#import &quot;ZJTwoModel.h&quot;@interface ZJTwoViewModel ()&lt;UITextFieldDelegate,ZJTwoViewDelegate&gt;// VC@property (nonatomic,weak)UIViewController * vc;// Model@property (nonatomic,strong)ZJTwoModel * model;// View@property (nonatomic,strong)ZJTwoView * view;// TF@property (nonatomic,strong)UITextField * tf;// model.name绑定的name@property (nonatomic,copy)NSString * name;@end@implementation ZJTwoViewModel// 入口方法：绑定一个 VC 并实现业务逻辑- (instancetype)initWithVC:(UIViewController *)controller&#123; if (self = [super init]) &#123; // 绑定控制器 self.vc = controller; // 初始化UI [self initUI]; // 初始化RAC [self initRAC]; &#125; return self;&#125;#pragma mark -initUI- (void)initUI&#123; // 添加视图 [self.vc.view addSubview:self.view]; // View和ViewModel双向绑定 self.view.viewModel = self; // 代理 self.view.delegate = self; // 模型 self.model = [ZJTwoModel new]; self.model.name = @&quot;ZJ&quot;; // 核心思想 V/M 能够拥有VC，但两者独立，互不影响 // 将Model绑定到VM上 self.name = self.model.name; // 验证监听：动态检测文本内容 [self.vc.view addSubview:self.tf];&#125;#pragma mark -监听- (void)initRAC&#123; // 监听视图出现的事件 [[self.vc rac_signalForSelector:@selector(viewWillAppear:)] subscribeNext:^(id x) &#123; NSLog(@&quot;viewWillAppear&quot;); &#125;];&#125;#pragma mark -&lt;UITextFieldDelegate&gt;// 动态检测文本框内容- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string&#123; [textField addTarget:self action:@selector(textFieldDidChange:) forControlEvents:UIControlEventEditingChanged]; return YES;;&#125;// 动态文本- (void)textFieldDidChange:(id)sender&#123; UITextField * tf = (UITextField *)sender; // 变更数据：// self.name = tf.text; // 直接改变模型 self.model.name = tf.text; // 更新UI self.view.label.text = self.model.name;&#125;#pragma mark -ZJTwoViewDelegate- (void)doSomethings&#123; NSLog(@&quot;doSomethings&quot;);&#125;#pragma mark -lazy- (ZJTwoView *)view&#123; if (!_view) &#123; _view = [[ZJTwoView alloc] initWithFrame:CGRectMake(30, 80, kScreenWidth - 60, 200)]; _view.backgroundColor = [UIColor redColor]; &#125; return _view;&#125;- (UITextField *)tf&#123; if (!_tf) &#123; _tf = [[UITextField alloc] initWithFrame:CGRectMake(50, 500, kScreenWidth - 100, 50)]; _tf.clearButtonMode = UITextFieldViewModeWhileEditing; _tf.textColor = [UIColor whiteColor]; _tf.placeholder = @&quot;点击更改&quot;; _tf.backgroundColor = [UIColor redColor]; _tf.delegate = self; &#125; return _tf;&#125;@end","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC底层原理15.5：dyld发展史","slug":"OC进阶/OC底层原理15-2：dyld发展史","date":"2023-02-25T20:30:55.000Z","updated":"2023-02-25T20:42:34.497Z","comments":true,"path":"2023/02/26/OC进阶/OC底层原理15-2：dyld发展史/","link":"","permalink":"https://www.bboyzj.cn/2023/02/26/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8615-2%EF%BC%9Adyld%E5%8F%91%E5%B1%95%E5%8F%B2/","excerpt":"","text":"dyld简介 dyld全名 The dynamic link editor； 是苹果的动态链接器； 是苹果操作系统的一个重要组成部分； 在应用被编译打包成可执行文件之后（即Mach-O），将其交由dyld负责链接，加载程序。 dyld贯穿了App启动的过程，包含加载依赖库、主程序，如果我们需要进行性能优化、启动优化等，不可避免的需要和dyld打交道 且dyld是开源的，我们可以在官网下载它的源码来阅读理解 dyld 1.0（1996-2004） dyld 1包含在NeXTStep 3.3中，在此之前的NeXT使用静态二进制数据。作用并不是很大， dyld 1是在系统广泛使用C++动态库之前编写的，由于C++有许多特性，例如其初始化器的工作，在静态环境工作良好，但是在动态环境中可能会降低性能。因此大型的C++动态库会导致dyld需要完成大量的工作，速度变慢 在发布macOS 10.0和Cheetah前，还增加了一个特性，即Prebinding预绑定。我们可以使用Prebinding技术为系统中的所有dylib和应用程序找到固定的地址。dyld将会加载这些地址的所有内容。如果加载成功，将会编辑所有dylib和程序的二进制数据，来获得所有预计算。当下次需要将所有数据放入相同地址时就不需要进行额外操作了，将大大的提高速度。但是这也意味着每次启动都需要编辑这些二进制数据，至少从安全性来说，这种方式并不友好。 dyld 2（2004-2017） dyld 2从2004年发布至今，已经经过了多个版本迭代，我们现在常见的一些特性，例如ASLR、Code Sign、share cache等技术，都是在dyld 2中引入的 dyld 2.0（2004-2007） 2004年在macOS Tiger中推出了dyld 2 dyld 2是dyld 1完全重写的版本，可以正确支持C++初始化器语义，同时扩展了mach-o格式并更新dyld。从而获得了高效率C++库的支持。 dyld 2具有完成的dlopen和dlsym（主要用于动态加载库和调用函数）实现，且具有正确的语义，因此弃用了旧版的API dlopen：打开一个库，获取句柄 dlsym：在打开的库中查找符号的值 dlclose：关闭句柄。 dlerror：返回一个描述最后一次调用dlopen、dlsym，或 dlclose 的错误信息的字符串。 dyld 的 设计目标 是 提升启动速度。因此仅进行有限的健全性检查。主要是因为以前的恶意程序比较少 同时dyld也有一些安全问题，因此对一些功能进行了改进，来提高dyld在平台上的安全性 由于启动速度的大幅提升，因此我们可以减少Prebinding的工作量。与编辑程序数据的区别在于，在这里我们仅编辑系统库，且可以仅在软件更新时做这些事情。因此在软件更新过程中，可能会看到“优化系统性能”类似的文字。这就是在更新时进行Prebinding。现在dyld用于所有优化，其用途就是优化。因此后面有了dyld 2 dyld 2.x（2007-2017） 在2004-20017这几年间进行了大量改进，dyld 2的性能显著提高 首先，增加了大量的基础架构和平台。 自从dyld 2在PowerPC发布之后，增加了x86、x86_64、arm、arm64和许多的衍生平台。 还推出了iOS、tvOS和watchOS，这些都需要新的dyld功能 通过多种方式增加安全性 增加 codeSigning代码签名、 ASLR（Address space layout randomization）地址空间配置随机加载：每次加载库时，可能位于不同的地址 bound checking边界检查：mach-o文件中增加了Header的边界检查功能，从而避免恶意二进制数据的注入 增强了性能 可以消除Prebinding，用share cache共享代码代替 ASLR ASLR是一种防范内存损坏漏洞被利用的计算机安全技术，ASLR通过随机放置进程关键数据区域的地址空间来防止攻击者跳转到内存特定位置来利用函数 Linux已在内核版本2.6.12中添加ASLR Apple在Mac OS X Leopard 10.5（2007年十月发行）中某些库导入了随机地址偏移，但其实现并没有提供ASLR所定义的完整保护能力。而Mac OS X Lion 10.7则对所有的应用程序均提供了ASLR支持。 Apple在iOS 4.3内导入了ASLR。 bounds checking 边界检查 对mach-o header中的许多内容添加了重要的边界检查功能，从而可以避免恶意二进制数据的注入 share cache 共享代码 share cache最早实在iOS3.1和macOS Snow Leopard中被引入，用于完全取代Prebinding share cache是一个单文件，包含大多数系统dylib，由于这些dylib合并成了一个文件，所以可以进行优化。 重新调整所有文本段（_TEXT）和数据段（_DATA），并重写整个符号表，以此来减小文件的大小，从而在每个进程中仅挂载少量的区域。允许我们打包二进制数据段，从而节省大量的RAM 本质是一个dylib预链接器，它在RAM上的节约是显著的，在普通的iOS程序中运行可以节约500-1g内存 还可以预生成数据结构，用来供dyld和Ob-C在运行时使用。从而不必在程序启动时做这些事情，这也会节约更多的RAM和时间 share cache在macOS上本地生成，运行dyld共享代码，将大幅优化系统性能 dyld 2 工作流程dyld 2是纯粹的in-process，即在程序进程内执行的，也就意味着只有当应用程序被启动时，dyld 2才能开始执行任务 以下是dyld 2的工作流程图示 1、dyld的初始化，主要代码在dyldbootstrap::start，接着执行dyld::_main，dyld::_main代码较多，是dyld加载的核心部分； 2、检查并准备环境，例如获取二进制路径、检查环境配置，解析主二进制的image header等信息 3、实例化主二进制的image loader，校验主二进制和dyld的版本是否匹配 4、检查share cache是否已经map，如果没有则需要先执行map share cache操作 5、检查DYLD_INSERT_LIBRARIES，如果有则加载插入的动态库（即实例化image loader） 6、执行link操作，会先递归加载依赖的所有动态库（会对依赖库进行排序，被依赖的总是在前面），同时在这阶段将执行符号绑定，以及rebase，binding操作； 7、执行初始化方法，OC的+load和C的constructor方法都会在这个阶段执行； 8、读取Mach-o的LC_MAIN段获取程序的入口地址，调用main函数 简化版 解析 mach-o 文件，找到其依赖的库，并且递归的找到所有依赖的库，形成一张动态库的依赖图。iOS 上的大部分 app 都依赖几百个动态链接库（大部分是系统的动态库），所以这个步骤包含了较大的工作量。 匹配 mach-o 文件到自身的地址空间 进行符号查找（perform symbol lookups） rebase和binding：由于 app 需要让地址空间配置随机加载，所以所有的指针都需要加上一个基地址 运行初始化程序，之后运行 main() 函数 dyld 3（2017-至今） dyld 3是2017年WWDC推出的全新的动态链接器，它完全改变了动态链接的概念，且将成为大多数macOS系统程序的默认设置。2017 Apple OS平台上的所有系统程序都会默认使用dyld 3. dyld 3最早是在2017年的iOS 11中引入，主要用来优化系统库。 而在iOS 13系统中，iOS全面采用新的dyld 3来替代之前的dyld 2，因为dyld 3完全兼容dyld 2，其API接口也是一样的，所以，在大部分情况下，开发者并不需要做额外的适配就能平滑过渡。 为什么需要重新设计dyld 2，形成新的dyld 3 ？重新设计dyld，主要从以下几方面进行考虑 重新设计dyld，主要从以下几方面进行考虑 性能：想要尽可能的提高启动速度 安全性：在dyld 2中增加了安全特性，但是很难跟随现实情形，虽然做了很多工作，但是难以实现这个目标 可靠性和可测试性：为此Apple发布了很多不错的测试框架，例如XCTest，但是这些测试框架依赖于动态链接器的底层功能，然后将测试框架的库插入进程中，所以不能用于测试现有的dyld代码，且难以测试安全性和性能水平 如何将 dyld 2 改进和优化为 dyld 3？改进和优化建议 从上面的dyld 2的工作流程中，我们了解了dyld 2的执行流程，可以从以下两个方面来改进和优化： 确定安全敏感的部分 Parse mach-o headers解析mach-o 和 Find dependencies找到依赖库，是安全敏感部分，即最大的安全隐患之一； 恶意撰改mach-o头部，可以进行某些攻击； 如果App使用了 @rpaths 即搜索路径，可以通过恶意撰改路径或者将一些库插入到特定的位置，来达到破坏程序的目的； 确定大量占用资源的部分（即可缓存部分） Perform symbol lookups符号查找就是其中一个，因为在一个特定的库中，除非进行软件更新或者在磁盘上更改库，不然符号将始终位于库中的相同的偏移位置（即符号偏移量固定）； dyld 2 改进和优化 以下是dyld 2 向 dyld 3 的一些改变，主要是将安全敏感的部分 和 占用大量资源的部分移动到上层，然后将一个closure写入磁盘进行缓存，然后我们在程序进程中使用closure。以下是图示 dyld 3 组成部分&#x2F;工作流程 dyld 3的工作流程主要分为3部分，如下所示 第一部分：out-of-process ：mach-o parser 进程外的mach-o分析器和编译器，是普通的后台程序，用于提高测试基础架构的性能。 第一部分主要在App进程之外做以下工作： 解析所有搜索路径@rpath、环境变量，因为它们会影响启动速度 分析 mach-o二进制数据 执行符号查找 利用这些结果创建launch clourse 第二部分：in-process ：engine 进程内的引擎，这部分常驻在内存中，且在dyld 3不再需要分析mach-o文件头或者执行符号查找就可以启动应用，因为分析mach-o和执行符号查找都是耗时操作，所以极大的提高了程序启动速度。 第二部分主要在App进程中做以下工作： 检查launch closure是否正确 映射到dylib中，再跳转main函数 第三部分：launch closure ：cache 启动闭包launch closure缓存服务。其中大多数程序启动都会使用缓存，而不需要调用进程外 mach-o分析器和编译器。且launch closure比mach-o更简单，因为launch closure是内存映射文件，不需要用复杂的方法进行分析，我们可以进行简单的校验，目的是为了提高速度 系统应用的launch closure直接加入到共享缓存 share cache 对于第三方应用，我们将在应用安装或者更新期间构建launch closure，因为此时 system library已发生更改 默认情况下，在iOS，tvOS和watchOS上，这些操作都将在运行之前为您预先构建。 在macOS上，由于可以侧向加载应用程序(这里应该是指非App Store安装的应用)，因此如果需要，in-process engine可以在首次启动时RPC(Remote Procedure Call)到out to the daemon，然后，它就可以使用缓存的closure了。 所以综上所述，dyld 3 把很多耗时的查找、计算和 I&#x2F;O 操作都预先处理好了，使得启动速度有了很大的提升。即dyld 3把很多耗时的操作都提前处理好了，极大提升了启动速度。 启动闭包（launch closure）这是一个新引入的概念，指的是 app 在启动期间所需要的所有信息。比如这个 app 使用了哪些动态链接库，其中各个符号的偏移量，代码签名在哪里等等。 dyld 3符号缺失问题 dyld 2中默认采取的是lazy symbol的符号加载方式 dyld 3中，在app启动之前，符号解析的结果已经在launch closure内了，所以lazy symbol就不再需要了。 如果此时，如果有符号缺失的情况，dyld 2 和 dyld 3的表现是不同的 dyld 2中，首次调用缺失符号时App会crash 在dyld 3中，缺失符号会导致App一启动就会crash 总结dyld 2工作流程 解析mach-o头部 查找依赖库 映射mach-o文件，放入地址空间中 执行符号查找 使用ASLR进行rebase和bind绑定 运行所有初始化器 执行main函数 dyld 3工作流程 进程外：将dyld 2中的mach-o头部解析、符号查找移到了进程外执行，且将其执行结果放入启动闭包，存储到磁盘中 进程内：验证启动闭包正确性，并映射dylib，执行main函数 启动闭包缓存服务","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理14-1：objc-msgSend缓存查找(快速查找)汇编分析","slug":"OC进阶/OC底层原理14-1：objc-msgSend缓存查找(快速查找)汇编分析","date":"2023-02-25T10:38:26.000Z","updated":"2023-02-25T18:30:49.495Z","comments":true,"path":"2023/02/25/OC进阶/OC底层原理14-1：objc-msgSend缓存查找(快速查找)汇编分析/","link":"","permalink":"https://www.bboyzj.cn/2023/02/25/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8614-1%EF%BC%9Aobjc-msgSend%E7%BC%93%E5%AD%98%E6%9F%A5%E6%89%BE(%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE)%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90/","excerpt":"","text":"前言我们得出结论：消息发送objc-msgSend 内部先进行 快速查找 即 缓存（CacheLookup）查找 本文主要继上一章 objc_msgSend 引申，objc_msgSend 是用汇编写的，因为性能好、速度快 汇编的特性：快 + 动态性（不确定） objc_msgSend 汇编查找流程分析在 objc4-781源码 中，搜索 objc_msgSend，由于我们日常开发的都是架构 arm64，所以需要找到 objc-msgSend-arm64.s 文件， objc_msgSend 源码实现的入口是在 ENTRY _objc_msgSend 这个文件下，发现是 汇编实现。 objc_msgSend 汇编源码 objc_msgSend 是消息发送的源码的入口，其使用 汇编 实现的，_objc_msgSend 源码实现如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 消息发送 -&gt; 汇编入口 -&gt; _objc_msgSend主要是拿到接收者的isa信息ENTRY _objc_msgSend // 无窗口 UNWIND _objc_msgSend, NoFrame /* p0和空对比，即判断receiver是否存在 其中p0（消息接收者）是objc_msgSend的第一个参数 */ cmp p0, #0 // nil check and tagged pointer check// 是否支持 tagged pointers 小对象类型#if SUPPORT_TAGGED_POINTERS // le-小于， 小对象或空判断 b.le LNilOrTagged // (MSB tagged pointer looks negative)#else // 否则 // eq-等于，p0等于0时，直接返回空 b.eq LReturnZero#endif // p0即receiver肯定存在的流程 // 根据对象拿出isa，即从x0寄存器指向的地址 取出 isa，存入p13寄存器 ldr p13, [x0] // p13 = isa // 在ram64架构下通过 p16 = isa（p13）&amp; ISA_MASK，拿出shiftcls信息，得到class信息 GetClassFromIsa_p16 p13 // p16 = class// 获取isa完毕LGetIsaDone: // calls imp or objc_msgSend_uncached // 开启缓存查找流程，即快速查找流程 CacheLookup NORMAL, _objc_msgSend#if SUPPORT_TAGGED_POINTERS// 小对象或者空判断LNilOrTagged: // 直接返回空 b.eq LReturnZero // nil check // tagged adrp x10, _objc_debug_taggedpointer_classes@PAGE add x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF ubfx x11, x0, #60, #4 ldr x16, [x10, x11, LSL #3] adrp x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE add x10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF cmp x10, x16 b.ne LGetIsaDone // ext tagged adrp x10, _objc_debug_taggedpointer_ext_classes@PAGE add x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF ubfx x11, x0, #52, #8 ldr x16, [x10, x11, LSL #3] b LGetIsaDone// SUPPORT_TAGGED_POINTERS#endifLReturnZero: // x0 is already zero mov x1, #0 movi d0, #0 movi d1, #0 movi d2, #0 movi d3, #0 ret END_ENTRY _objc_msgSend 主要有以下几个步： 【第一步】判断 objc_msgSend 方法的第一个参数 receiver 是否为空 如果支持 tagged pointer 小对象，跳转至 LNilOrTagged 如果 小对象 为空，则直接返回空，即 LReturnZero 如果 小对象 不为空，则处理小对象的 isa，走到【第二步】 如果 既不是小对象，receiver 也不为空，有以下两步 从 receiver 中取出 isa 存入 p13 寄存器 通过 GetClassFromIsa_p16 中，arm64 架构下通过 isa &amp; ISA_MASK 获取 shiftcls 位域的类信息，即 class，GetClassFromIsa_p16 的汇编实现如下，然后走到【第二步】 【第二步】如果获得 isa 指针 如果有 isa，走到 CacheLookup，即缓存查找流程，也就是所谓的 sel-imp 快速查找流程 123456789101112131415161718192021222324252627282930313233.macro GetClassFromIsa_p16 /* src */// 此处用于watchOS#if SUPPORT_INDEXED_ISA // Indexed isa // 将isa的值存入p16寄存器 mov p16, $0 // optimistically set dst = src // 判断是否是 non-pointer isa tbz p16, #ISA_INDEX_IS_NPI_BIT, 1f // done if not non-pointer isa // isa in p16 is indexed // 将_objc_indexed_classes 所在的页的基址 读入到x10寄存器 adrp x10, _objc_indexed_classes@PAGE // x10 = x10 + _objc_indexed(page中的偏移量) -x10基址根据偏移量进行内存偏移 add x10, x10, _objc_indexed_classes@PAGEOFF // 从p16的第ISA_INDEX_SHIFT位开始，提取 ISA_INDEX_BITS位到p16寄存器，剩余的高位用0补充 ubfx p16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS // extract index ldr p16, [x10, p16, UXTP #PTRSHIFT] // load class from array1:// 用于64位系统#elif __LP64__ // 64-bit packed isa // p16 = class = isa &amp; ISA_MASK（位运算 &amp; 即获取isa中的shiftcls信息） and p16, $0, #ISA_MASK#else // 32-bit raw isa // 用于32位系统 mov p16, $0#endif.endmacro objc_msgSend 缓存（CacheLookup）查找汇编流程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170.macro CacheLookup // // Restart protocol: // // As soon as we&#x27;re past the LLookupStart$1 label we may have loaded // an invalid cache pointer or mask. // // When task_restartable_ranges_synchronize() is called, // (or when a signal hits us) before we&#x27;re past LLookupEnd$1, // then our PC will be reset to LLookupRecover$1 which forcefully // jumps to the cache-miss codepath which have the following // requirements: // // GETIMP: // The cache-miss is just returning NULL (setting x0 to 0) // // NORMAL and LOOKUP: // - x0 contains the receiver // - x1 contains the selector // - x16 contains the isa // - other registers are set as per calling conventions //LLookupStart$1: // p1 = SEL, p16 = isa，#define CACHE（2 * __SIZEOF_POINER__），其中__SIZEOF_POINTER__表示pointer的大小 ，即 2*8 = 16 // p11 = mask | buckets，从x16（即isa）中平移16字节，取出cache存入p11寄存器，isa距离cache正好16字节：isa（8字节），superClass（8字节），cache（mask高16位 + buckets低48位） ldr p11, [x16, #CACHE] // 64位真机#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16 // p11(cache) &amp; 0x0000ffffffffffff ，mask高16位抹零，得到buckets 存入p10寄存器，即去掉mask，留下buckets and p10, p11, #0x0000ffffffffffff // p10 = buckets /* 1）先将p11(cache)右移48位，得到mask(即p11 存储mask) 2）mask &amp; p1（msgSend的第二个参数 cmd-sel），得到sel-imp的下表index(即搜索下标) 3）存入p12(cache insert写入时的哈希下标计算是 通过 sel &amp; mask，读取时也要用这种方式) */ and p12, p1, p11, LSR #48 // x12 = _cmd &amp; mask // 非64位真机#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4 and p10, p11, #~0xf // p10 = buckets and p11, p11, #0xf // p11 = maskShift mov p12, #0xffff lsr p11, p12, p11 // p11 = mask = 0xffff &gt;&gt; p11 and p12, p1, p11 // x12 = _cmd &amp; mask#else#error Unsupported cache mask storage for ARM64.#endif /* 1) p12是下标，p10是buckets数组首地址，下标 * 1&lt;&lt;4(即16)得到实际内存的偏移量，通过buckets的首地址偏移，获取bucket存入p12寄存器 2) LSL #(1+PTRSHIFT) 实际含义就是得到一个bucket占用内存大小，相当于mask = occupied - 1，_cmd &amp; mask，取余数 */ add p12, p10, p12, LSL #(1+PTRSHIFT) // p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT)) // 从x12（即p12）中取出bucket，分别将imp和sel存入 p17（存储imp） 和 p9（存储sel） ldp p17, p9, [x12] // &#123;imp, sel&#125; = *bucket // 比较 sel 和 p1（唇乳的参数cmd）1: cmp p9, p1 // if (bucket-&gt;sel != _cmd) // 如果不相等，即没有找到，请跳转至2f b.ne 2f // scan more // 如果相等，即CacheHit 缓存命中，直接返回 imp CacheHit $0 // call or return imp 2: // not hit: p12 = not-hit bucket // 如果一直都找不到，因为是normal，跳转至__objc_msgSend_uncached CheckMiss $0 // miss if bucket-&gt;sel == 0 // 判断p12（下标对应的bucket）是否等于p10（buckets数组第一个元素），如果等于则跳转至3f cmp p12, p10 // wrap if bucket == buckets // 定位到最后一个元素（即第一个bucket） b.eq 3f // 从x12（即p12 buckets首地址），实际需要平移的内存大小BUCKET_SIZE,得到第二个bucket元素，imp-sel分别存入p17-p9，即向前查找 ldp p17, p9, [x12, #-BUCKET_SIZE]! // &#123;imp, sel&#125; = *--bucket // 挑战至第1步，继续对比 sel与cmd b 1b // loop3: // wrap: p12 = first bucket, w11 = mask#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16 /* 1) 人为设值到最后一个元素 2) p11(mask)右移44位，相当于mask左移4位，直接定位到buckets的最后一个元素，缓存查找顺序是向前查找 */ add p12, p12, p11, LSR #(48 - (1+PTRSHIFT)) // p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4 add p12, p12, p11, LSL #(1+PTRSHIFT) // p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)#else#error Unsupported cache mask storage for ARM64.#endif // Clone scanning loop to miss instead of hang when cache is corrupt. // The slow path may detect any corruption and halt later. // 再查找一遍缓存（） // 拿到x12(即p12) bucket中的 imp-sel 分别存入 p17-p9 ldp p17, p9, [x12] // &#123;imp, sel&#125; = *bucket// 比较 sel 与 p1（传入的参数cmd）1: cmp p9, p1 // if (bucket-&gt;sel != _cmd) // 如果不相等，即走到第二步 b.ne 2f // scan more // 如果相等，即命中，直接返回imp CacheHit $0 // call or return imp 2: // not hit: p12 = not-hit bucket // 如果一直找不到，则CheckMiss CheckMiss $0 // miss if bucket-&gt;sel == 0 // 判断p12（下标对应的bucket）是否等于p10（buckets数组第一个元素），表示前面已经没有了，但是还是没有找到 cmp p12, p10 // wrap if bucket == buckets // 如果等于，跳转至第3步 b.eq 3f // 从x12（即p12 buckets首地址），实际需要平移的内存大小BUCKET_SIZE，得到第二个bucket元素，imp-sel分别存入p17-p9，即向前查找 ldp p17, p9, [x12, #-BUCKET_SIZE]! // &#123;imp, sel&#125; = *--bucket // 跳转至第1步，继续对比 sel与imp b 1b // loopLLookupEnd$1:LLookupRecover$1:3: // double wrap // 跳转至JumpMiss 因为是normal，跳转至__objc_msgSend_uncached JumpMiss $0.endmacro// 以下是最后跳转的汇编函数.macro CacheHit.if $0 == NORMAL TailCallCachedImp x17, x12, x1, x16 // authenticate and call imp.elseif $0 == GETIMP mov p0, p17 cbz p0, 9f // don&#x27;t ptrauth a nil imp AuthAndResignAsIMP x0, x12, x1, x16 // authenticate imp and re-sign as IMP9: ret // return IMP.elseif $0 == LOOKUP // No nil check for ptrauth: the caller would crash anyway when they // jump to a nil IMP. We don&#x27;t care if that jump also fails ptrauth. AuthAndResignAsIMP x17, x12, x1, x16 // authenticate imp and re-sign as IMP ret // return imp via x17.else.abort oops.endif.endmacro.macro CheckMiss // miss if bucket-&gt;sel == 0.if $0 == GETIMP // 如果为GETIMP，跳转至LGetImpMiss cbz p9, LGetImpMiss.elseif $0 == NORMAL // 如果为NORMAL，跳转至__objc_msgSend_uncached cbz p9, __objc_msgSend_uncached.elseif $0 == LOOKUP // 如果为LOOKUP，跳转至__objc_msgLookup_uncached cbz p9, __objc_msgLookup_uncached.else.abort oops.endif.endmacro.macro JumpMiss.if $0 == GETIMP b LGetImpMiss.elseif $0 == NORMAL b __objc_msgSend_uncached.elseif $0 == LOOKUP b __objc_msgLookup_uncached.else.abort oops.endif.endmacro 主要分为以下几步： 【第一步】通过 cache 首地址平移 16 字节（因为在objc_class中），首地址 距离 cache 正好 16 字节，即 isa首地址 占 8 字节，superClass占 8 字节），获取 cache，cache中 高16位存mask，低48位存buckets，即 p11 = cache。 【第二步】从cache中分别取出 buckets和mask,并由mask根据哈希算法计算出哈希下标 通过 cache 和 掩码（即0x0000ffffffffffff）的 &amp; 运算，将 高16位mask抹零，得到buckets指针地址，即 p10 = buckets 将 cache 右移 48 位，得到 mask，即 p11 = mask 将 objc_msgSend 的参数 p1 (即第二个参数_cmd) &amp; mask，通过 哈希算法，得到需要查找存储 sel-imp 的 bucket下标index，即 p12 = index = _cmd &amp; mask，为什么通过这种方式呢？因为在 存储sel-imp时，也是通过同样 哈希算法计算哈希下标进行存储，所以 读取 也需要通过同样的方式读取，如下所示： 1234567// Class points to cache. SEL is key. Cache buckets store SEL+IMP.// Caches are never built in the dyld shared cache.static inline mask_t cache_hash(SEL sel, mask_t mask) &#123; return (mask_t)(uintptr_t)sel &amp; mask;&#125; 【第三步】根据所得的 哈希下标Index 和 buckets首地址，取出哈希下标对应的 bucket 其中 PTRSHIFT 等于 3，左移 4 位（即2^4 &#x3D; 16字节）的目的是计算出一个 bucket 实际占用的大小，结构体 bucket_t 中 sel 占 8 字节，imp 占 8 字节 根据计算的哈希下标 index乘以单个bucket占用的内存大小 ，得到 buckets 首地址在 实际内存中的偏移量 通过 首地址+实际偏移量，获取哈希下标index对应的 bucket 【第四步】根据获取的 bucket，取出其中的 imp 存入 p17，即 p17 = imp，取出 sel 存入 p9，即 p9 = sel 【第五步】第一次递归循环 比较获取的 bucket 中 sel 与 objc_msgSend 的第二个参数的 _cmd(即p1) 是否相等 如果相等，则直接跳转至 CacheHit，即 缓存命中，返回 imp 如果不相等，有以下两种情况 如果一直都找不到，直接跳转至 CheckMiss，因为 $0 是 normal，会跳转至 __objc_msgSend_uncached，即进入 慢速查找流程 如果 根据index获取的bucket 等于 buckets的第一个元素，则 人为 的将 当前bucket设置为buckets的最后一个元素（通过 buckets首地址+mask右移44位（等同于左移4位）直接 定位到bucker的最后一个元素），然后继续进行递归循环（第一个 递归循环嵌套 第二个 递归循环），即【第六步】 如果 当前bucket 不等于 buckets的第一个元素，则继续 向前查找，进入 第一次递归循环 【第六步】第二次递归循环：重复【第五步】的操作，与【第五步】中唯一区别是，如果 当前的bucket还是等于 buckets的第一个元素，则直接跳转至 JumpMiss，此时的 $0 是 normal，也是直接跳转至 __objc_msgSend_uncached，即进入 慢速查找流程 以下是整个 快速查找 过程 值的变化 过程 objc_msgSend通过伪代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;// 查找 imp imp存储在 cache 的 bucket 下[person sayNB] -&gt; imp ( cache -&gt; bucket (sel imp))// 获取当前的对象id person = 0x10000// 获取isaisa_t isa = 0x000000// isa -&gt; class -&gt; cachecache_t cache = isa + 16字节// arm64// mask|buckets 在一起的buckets = cache &amp; 0x0000ffffffffffff// 获取maskmask = cache LSR #48// 下标 = mask &amp; selindex = mask &amp; p1// bucket 从 buckets 遍历的开始 (起始查询的bucket)bucket = buckets + index * 16 (sel imp = 16)int count = 0// CheckMiss $0do&#123; if ((bucket == buckets) &amp;&amp; (count == 0))&#123; // 进入第二层判断 // bucket == 第一个元素 // bucket人为设置到最后一个元素 bucket = buckets + mask * 16 count++; &#125;else if (count == 1) goto CheckMiss // &#123;imp, sel&#125; = *--bucket // 缓存的查找的顺序是: 向前查找 bucket--; imp = bucket.imp; sel = bucket.sel; &#125;while (bucket.sel != _cmd) // // bucket里面的sel 是否匹配_cmd// CacheHit $0return impCheckMiss: CheckMiss(normal) 结尾 在 缓存（CacheLookup）查找 过程中，如果没有找到方法实现，无论是走到 CheckMiss 还是 JumpMiss，最终都会走到 __objc_msgSend_uncached 汇编函数 CheckMiss源码 123456789101112.macro CheckMiss // miss if bucket-&gt;sel == 0.if $0 == GETIMP cbz p9, LGetImpMiss.elseif $0 == NORMAL cbz p9, __objc_msgSend_uncached.elseif $0 == LOOKUP cbz p9, __objc_msgLookup_uncached.else.abort oops.endif.endmacro JumpMiss源码 1234567891011.macro JumpMiss.if $0 == GETIMP b LGetImpMiss.elseif $0 == NORMAL b __objc_msgSend_uncached.elseif $0 == LOOKUP b __objc_msgLookup_uncached.else.abort oops.endif.endmacro 在 objc-msg-ram64.s 文件中查找 __objc_msgSend_uncached 的汇编源码，发现其核心是 MethodTableLookup(即查询方法列表) ，因此如果 缓存（CacheLookup）查找 没有找到，就去 MethodTableLookup（即方法列表中查找） ，下一章我们介绍 __objc_msgSend_uncached源码 12345678910STATIC_ENTRY __objc_msgSend_uncached UNWIND __objc_msgSend_uncached, FrameWithNoSaves // THIS IS NOT A CALLABLE C FUNCTION // Out-of-band p16 is the class to search // 方法列表查找 MethodTableLookup TailCallFunctionPointer x17","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理14-0：方法调用的本质objc_msgSend消息发送","slug":"OC进阶/OC底层原理14-0：方法调用的本质objc_msgSend消息发送","date":"2023-02-25T08:41:30.000Z","updated":"2023-02-25T11:11:50.608Z","comments":true,"path":"2023/02/25/OC进阶/OC底层原理14-0：方法调用的本质objc_msgSend消息发送/","link":"","permalink":"https://www.bboyzj.cn/2023/02/25/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8614-0%EF%BC%9A%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8objc_msgSend%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/","excerpt":"","text":"前言我们先得出结论：方法调用的本质是 objc_msgSend消息发送 本文主要目的是理解 objc_msgSend 的 方法查找 流程 在上一篇文章中 OC底层原理13：cache-t底层原理分析 中，分析了 cache的写入流程，在写入流程之前，还有一个 cache读取流程，即 objc_msgSend 和 cache_getImp 在分析之前，首先了解什么是 Runtime Runtime介绍runtime成为运行时，它区别于编译时： 运行时 是 代码跑起来，被装载到内存中 的过程，如果此时出错，则程序会崩溃，是一个 动态 阶段 编译时 是 源代码编译成机器能识别的代码 的过程，主要是对语言进行最基本的检查报错，即 词法分析、语法分析 等，是一个 静态 的阶段 runtime 的 使用 有以下三种方式，其中三种实现方式与编译层和底层的关系如下所示： 通过 OC代码，例如 [person sayNB] 通过 Framework&amp;Service，例如 isKindOfClass 通过 Runtime API，例如 class_getInstanceSize complier 就是我们了解的 编译器，即 LLVM，例如 OC 的 alloc 对应底层的 objc_alloc runtime system library 就是 Runtime 底层库。 可以通过 command + shift + 0 打开官方文档 探索方法的本质方法的本质 在 OC底层原理08：isa和类关联探索 文章中，通过 clang 编译的源码，理解了 oc对象的本质，同样的，使用clang 编译 main.m -&gt; main.cpp 文件，通过查看main函数中方法调用的实现，如下所示 mian.m 内实现如下代码： 1234// 👇main.m中ZJPerson * person = [ZJPerson alloc];[person sayNB];[person sayHello]; 终端 clang 编译 miam.m -&gt; main.cpp 后的代码 1234// 👇clang编译后的底层实现ZJPerson * person = ((ZJPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;ZJPerson&quot;), sel_registerName(&quot;alloc&quot;));((void (*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(&quot;sayNB&quot;));((void (*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(&quot;sayHello&quot;)); 总结： 通过上述代码可以看出，方法的本质 就是 objc_msgSend消息发送 验证方法本质方法：消息（消息的接受者，消息主体） 为了验证，通过 objc_msgSend 方法来完成 [person sayNB] 的调用，查看其打印是否一致 1234注：👇 objc_msgSend 消息发送流程是在 &lt;objc/message.h&gt; 系统库中1、直接调用 `objc_msgSend`，导入头文件 `#import&lt;objc/message.h&gt;`2、需要将 target --&gt; Build Setting --&gt; 搜索msg --&gt; 将 enable strict checking of objc_msgSend calls 由 YES 改为 NO，将严厉的检查机制关掉，否则 `objc_msgSend` 的参数会报错3. `sel_registerName = @selector() = NNSelectorFromString()` 再次编译运行 command + R 123ZJPerson * person = [ZJPerson alloc];[person sayNB];objc_msgSend(person,sel_registerName(&quot;sayNB&quot;)); 其打印结果如下，发现是一致的，所以 [person sayNB] 等价于 objc_msgSend(person,sel_registerName(&quot;sayNB&quot;)) 子类对象方法调用-执行父类的实现 首先我们定义两个类 子类ZJStudent 和 父类ZJPerson 1234567891011121314151617// 父类 ZJPerson@interface ZJPerson : NSObject- (void)sayNB;@end@implementation ZJPerson- (void)sayNB&#123; NSLog(@&quot;666&quot;);&#125;@end// ZJStudent 继承父类 ZJPerson@interface ZJStudent : ZJPerson- (void)sayNB;@end@implementation ZJStudent@end 在 main.m 中让子类调用 sayNB 方法，查看是否能输出结果 123456ZJPerson * person = [ZJPerson alloc];ZJStudent * student = [ZJStudent alloc]; // 消息的接收者还是自己 - 父类 - 请你直接找我的父亲要[student sayNB];objc_msgSend(student,sel_registerName(&quot;sayNB&quot;)); 运行程序，查看结果 由打印结果可知,子类方法的调用，可以 执行父类方法的实现 那么子类是如何调用父类的方法实现的呢？我们往下探索 子类调用父类方法的原理我们先说结论：我们还可以尝试让 person 的调用执行父类中的实现，通过 objc_msgSendSuper 实现 在 main.m 函数中的调用 12345678910ZJPerson * person = [ZJPerson alloc];ZJStudent * student = [ZJStudent alloc]; struct objc_super zjsuper;zjsuper.receiver = person; // 消息的接收者还是personzjsuper.super_class = [ZJPerson class]; // 告诉父类是谁 // 消息的接收者还是自己 - 父类 - 请你直接找我的父亲要[student sayNB];objc_msgSendSuper(&amp;zjsuper, sel_registerName(&quot;sayNB&quot;)); 进入objc_msgSendSuper内，查看一下结构 由上图可知 objc_msgSendSuper 方法中有两个参数 （结构体，sel），其结构体类型是 objc_super 定义的结构体对象，且需要指定 receiver 和 super_class 两个属性 运行程序，查看打印结果： 1232023-02-25 16:31:22.959805+0800 msg_seng继承父类[53476:1503775] 6662023-02-25 16:31:22.961094+0800 msg_seng继承父类[53476:1503775] 666Program ended with exit code: 0 由打印结果，我们发现不论是 [person sayHello] 还是 objc_msgSendSuper 都执行的是 父类 中的 sayHello 的实现，所以这里，我们可以可以猜想：方法调用、首先是在类中查找，如果类中没有找到，会到父类中查找。 总结 由上面的结论我们知道 方法的调用 实际上是 消息发送objc_msgSend 在 c 中，可以直接调用 函数 在 OC 中，方法调用是消息发送，消息发送objc_smgSend是通过 sel方法编号 找到 imp函数指针地址 ，进而找到 内容","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"Swift学习25：Swift中的模式和模式匹配","slug":"Swift课程/Swift学习25：Swift中的模式和模式匹配","date":"2023-02-23T13:36:05.000Z","updated":"2023-03-09T07:24:03.834Z","comments":true,"path":"2023/02/23/Swift课程/Swift学习25：Swift中的模式和模式匹配/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A025%EF%BC%9ASwift%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/","excerpt":"","text":"模式 模式代表 单个值或复合值 的 结构， 可以用模式来匹配各种各样的值，例如：(x,y) 匹配 元组(1,2) 可以从复合值中取出部分或全部值，然后把值绑定一个常量或变量，例如：(let x,y) 提取 (1,2) 模式分类Swift 中模式分为两类： 一种能成功匹配任何类型的值；另一种在运行时匹配某个特定值可能会失败 第一种模式用于解构简单的常量、变量和可选绑定中的值 第二种模式用于全模式匹配。 模式分类： 通配符模式（Wildcard Pattern） 标识符模式（Identifier Pattern） 值绑定模式（Value-Binding Pattern） 元组模式（Tuple Pattern） 枚举用例模式（Enumeratinal Case Pattern） 可选项模式（Optional Pattern） 类型转换模式（Type-Casting Pattern） 表达式模式（Expression Pattern） 通配符模式（Wildcard Pattern） 通配符模式（Wildcard Pattern） 用一个下划线 _ 构成，用于匹配并忽略任何职 123for _ in 1...3 &#123;&#125; 标识符模式（Identifier Pattern） 标识符模式匹配任何值，并将匹配的值和一个变量或常量绑定起来 1let someValue = 42 值绑定模式（Value-Binding Pattern） 把匹配到的值绑定给一个 变量let或常量var 123456let point = (2,3)switch point &#123;// 将 point 中的元素绑定到 x 和 ycase let (x,y): print(&quot;\\(x),\\(y)&quot;)&#125; 元组模式（Tuple Pattern） 元组模式由逗号分割，具有零个或多个模式的列表，由一对圆括号括起来。 1234let points = [(0,0),(0,1),(1,1)]for (x,0) in points &#123; print(&quot;&quot;)&#125; 枚举用例模式（Enumeratinal Case Pattern） 匹配现有某个枚举类型的某个用例，体现在 switch 中 case 标签中，及 if、while、guard 和 for in 的 case 中 可选项模式（Optional Pattern） 匹配 Optional&lt;Wrapped&gt; 枚举在 some&lt;Wrapped&gt; 中包装的值 可选项模式为 for in 语句提供了一种迭代数组的简便方式，只为数组中的非 nil 元素执行循环体 12345678let someNum: Int? = 10if case .some(let x) = someNum &#123; print(x)&#125;if case let x? = someNum &#123; print(x)&#125; 类型转换模式（Type-Casting Pattern） 有两种：is模式 和 as模式，is 模式只出现在 switch 语句 case 标签中 is 类型：仅当一个值类型在运行时和 is模式 右边指定的类型一致，或子类下，才匹配值，没有返回类型 模式 as 类型：仅当一个值类型在运行时和 as模式 右边指定的类型一致，或子类下，才匹配值，如果匹配成功，被转换成 as模式右边指定的类型 12345678910111213141516171819202122232425262728protocol Animal &#123; var name:String &#123; get &#125;&#125;struct Dog:Animal &#123; var name:String &#123; return &quot;dog&quot; &#125; var runSpeed:Int&#125;struct Bird:Animal &#123; var name:String&#123; return &quot;bird&quot; &#125; var flightHeight:Int&#125;let animals:[Any] = [Dog(runSpeed:40),Bird(flightHeight:500)]for animal in animals &#123; switch animal&#123; case let dog as Dog: print(&quot;\\(dog.name) run at \\(dog.runSpeed)&quot;) case let bird as Bird: print(&quot;\\(bird.name) swip at \\(bird.flightHeight)&quot;) default: break &#125;&#125; 表达式模式（Expression Pattern） 表达式模式代表表达式的值，只出现在 switch 语句中的 case 标签中 可重载 ~= 运算符来提供自定义的表达式匹配行为 自定义类或结构体类型 默认也是无法进行表达式模式匹配的，也需要重载 ~= 运算符 123456789101112131415struct Employee&#123; var salary:Int&#125;func ~= (left:ClosedRange&lt;Int&gt;,right:Employee) -&gt; Bool&#123; return left.contains(right.salary)&#125;var e: Employee = Employee(salary:2000)switch e&#123;case 0...1000: print(&quot;吃不饱&quot;)case 1000...5000: print(&quot;勉强度日&quot;)default: break&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习24：如何在Swift里面进行控制转移","slug":"Swift课程/Swift学习24：如何在Swift里面进行控制转移","date":"2023-02-23T13:35:34.000Z","updated":"2023-03-09T07:24:01.145Z","comments":true,"path":"2023/02/23/Swift课程/Swift学习24：如何在Swift里面进行控制转移/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A024%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8Swift%E9%87%8C%E9%9D%A2%E8%BF%9B%E8%A1%8C%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB/","excerpt":"","text":"控制转移 continue break fallthrough return throw continue continue 告诉我不再继续当前循环遍历了，再次从头开始下一次遍历 break break 会立即结束整个控制流语句，即跳出整个循环 fallthrough 你确定要贯穿行为，你可以在 switch 每个 case 末尾 使用 fallthrough 关键字 12345678910let num = 5var des = &quot;the num \\(num) is&quot;switch num &#123;case 2,3,5,7: des += &quot;a prime number&quot; fallthroughdefault: des += &quot; also a int&quot;&#125;print(des) 语句标签 可以用 k 来给循环语句或条件语句做标记。 配合 break 或 continue 来结束被标记的语句 12345678910111213141516171819var num = 10whileLoop: while num &gt; 0 &#123; switch num &#123; case 9: print(&quot;9&quot;) case 10: var sum = 0 for i in 0...10 &#123; sum += i if i == 9 &#123; print(sum) break whileLoop &#125; &#125; default: print(&quot;default&quot;) &#125; num -= 1&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习23：更加强大的switch","slug":"Swift课程/Swift学习23：更加强大的switch","date":"2023-02-23T13:35:07.000Z","updated":"2023-03-09T07:23:56.957Z","comments":true,"path":"2023/02/23/Swift课程/Swift学习23：更加强大的switch/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A023%EF%BC%9A%E6%9B%B4%E5%8A%A0%E5%BC%BA%E5%A4%A7%E7%9A%84switch/","excerpt":"","text":"swift switch 语句会将一个值与多个可能匹配的模式匹配，然后基于第一个成功匹配的模式来执行合适的代码块 switch 语句一定得是全面的。给定类型里的每一个值都得匹配到一个 switch 的 case。你可以定义一个默认匹配的 case 来匹配所有未明确的值，用关键字 default 标记 OC 中 switch 语句不全面，仍然可以运行 1234567let c:Character = &quot;z&quot;switch c &#123;case &quot;a&quot;: print(&quot;the first letter is alphabet&quot;)case &quot;z&quot;: print(&quot;the last letter is alphabet&quot;)&#125; 修改 123456789let c:Character = &quot;z&quot;switch c &#123;case &quot;a&quot;: print(&quot;the first letter is alphabet&quot;)case &quot;z&quot;: print(&quot;the last letter is alphabet&quot;)default: print(&quot;other&quot;)&#125; 没有隐私贯穿 相比 OC 和 C ，Swift 里的 Switch 不会默认从匹配的 case 末尾 贯穿到下一个 case 里 相反，整个 Switch 在匹配到第一个 case 执行完毕之后退出，不再需要显示 break 每一个 case 的函数体必须包含至少一个可执行的语句 在一个 Switch 的 case 中匹配多个值可以用 逗号分割，并且可以写成多行 123456789let c = &quot;a&quot;switch c &#123;case &quot;a&quot;,&quot;e&quot;,&quot;i&quot;: print(&quot;元音字母&quot;)case &quot;b&quot;,&quot;c&quot;: print(&quot;符印字母&quot;)default: print(&quot;其他字符&quot;)&#125; 区间匹配 Switch 的 case 的值可以再一个区间中匹配 123456789101112let count = 43switch count&#123;case 0: print(&quot;none&quot;)case 1...25: print(&quot;1~25&quot;)case 26..&lt;51: print(&quot;26~50&quot;)default: print(&quot;other&quot;)&#125; 元组匹配 你可以使用元组来在一个 switch 中测试有多个值 使用下划线 _ 来表明匹配所有可能的值 1234567891011121314let point = (1,1)switch point&#123;case (0,0): print(&quot;point at origin&quot;)case (_,0): print(&quot;point at x&quot;)case (0,_): print(&quot;point at y&quot;)case (-2...2,-2...2): print(&quot;point at box&quot;)default: print(0,0)&#125; 值绑定 switch 的 case 可以将匹配到的值临时 绑定 到一个 常量或变量，来给 case 的函数体使用 如果使用 var 关键字，临时的变量就会以合适的值来创建并初始化。对这个变量的任何改变都只会在 case 的函数体内有效 123456789let point = (1,0)switch point&#123;case (let x,0): print(&quot;x is \\(x) when y is 0&quot;)case (0,let y): print(&quot;y is \\(y) when x is 0&quot;)default: print(&quot;other&quot;)&#125; where 语句 switch case 可以使用 where 语句来检查是否符合特定的约束 123456789let point = (1,-1)switch point&#123;case (let x,let y) where x == y: print(&quot;x == y&quot;)case (let x,let y) where x == -y: print(&quot;x == -y&quot;)default: print(&quot;other&quot;)&#125; 复合匹配 case 后可以写多个模式来复合，在每个模式间用 , 号分割 复合匹配 - 值绑定 复合匹配同样可以包含 值绑定。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习22：如何在Swift里进行循环控制","slug":"Swift课程/Swift学习22：如何在Swift里进行循环控制","date":"2023-02-23T13:34:50.000Z","updated":"2023-03-09T07:23:54.581Z","comments":true,"path":"2023/02/23/Swift课程/Swift学习22：如何在Swift里进行循环控制/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A022%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8Swift%E9%87%8C%E8%BF%9B%E8%A1%8C%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6/","excerpt":"","text":"for in 循环 使用 for in 循环来遍历序列，比如一个范围的数字，数组中元素或者字符串中的字符 如果你不需要序列的每一个值，你可以使用下划线 _ 来取代遍历名 123456789101112131415// 遍历for i in 0...3&#123; print(i)&#125;// 遍历字符串for c in &quot;hello,world&quot; &#123; print(c)&#125;// 遍历数组let letter = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]for str in letter &#123; print(str)&#125; for in 遍历字典 当遍历字典时，每一个元素都返回一个 (key,value) 元组，你可以在 for in 循环体中使用显示命名常量来分解 (key,value) 元组成员 1234567let nums = [&quot;age&quot;:&quot;30&quot;,&quot;sex&quot;:&quot;男&quot;]for (key,value) in nums &#123; print(&quot;key is \\(key),value is \\(value)&quot;)&#125;for t in nums &#123; print(&quot;key is \\(t.0),value is \\(t.1)&quot;)&#125; for in 分段区间 使用 stride(from:to:by) 函数来跳过不想要的标记（开区间） 123for i in stride(from: 0, to: 50, by: 10) &#123; print(i)&#125; 闭区间 也同样适用，使用 stride(from:through:by:) 即可 123for i in stride(from: 0, through: 50, by: 10) &#123; print(i)&#125; while 循环 repeat-while 循环 （oc 中是 do-while）","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习21：如何在swift中自定义运算符","slug":"Swift课程/Swift学习21：如何在swift中自定义运算符","date":"2023-02-22T20:03:04.000Z","updated":"2023-03-09T07:23:52.087Z","comments":true,"path":"2023/02/23/Swift课程/Swift学习21：如何在swift中自定义运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A021%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8swift%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"自定义运算符 除了实现标准的运算符，在 swift 当中还可以声明和实现自定义运算符（custom operators） 新的运算符要在全局作用域内，使用 operator 关键字进行声明，同时还要指定 prefix、infix 或者 postfix 限定符 【示例1】：一元运算符 123456789101112131415struct Vector2D &#123; var x = 0.0,y = 0.0&#125;// 声明一元运算符prefix operator +++// 扩展extension Vector2D &#123; static prefix func +++ (vector: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: vector.x + vector.x,y: vector.y + vector.y) &#125;&#125;let vectorToDouble = Vector2D(x: 1.0,y: 2.0)let doubleVector = +++vectorToDoubleprint(&quot;\\(doubleVector.x) \\(doubleVector.y)&quot;) 编译运行，查看打印结果 12.0 4.0 【示例2】： 1234567891011121314// 中缀运算符struct Vector2D &#123; var x = 0.0,y = 0.0&#125;infix operator +-: AdditionPrecedenceextension Vector2D &#123; static func +- (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x,y: left.y - right.y) &#125;&#125;let firstVector = Vector2D(x: 1.0,y: 3.0)let secondVector = Vector2D(x: 2.0,y: 5.0)let result = firstVector +- secondVectorprint(&quot;\\(result.x) \\(result.y)&quot;) 编译运行，查看打印结果： 13.0 -2.0 【示例3】： 1234567891011121314// 中缀运算符struct Vector2D &#123; var x = 0.0,y = 0.0&#125;infix operator *^: MultiplicationPrecedenceextension Vector2D &#123; static func *^ (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x * right.x,y: left.y * left.y + right.y * right.y) &#125;&#125;let firstVector = Vector2D(x: 1.0,y: 3.0)let secondVector = Vector2D(x: 2.0,y: 5.0)let result = firstVector *^ secondVectorprint(&quot;\\(result.x) \\(result.y)&quot;) 编译运行，查看打印结果： 12.0 34.0 自定义中缀运算符的优先级和结合性 自定义 中缀（infix） 运算符也可以指定优先级和结核性 每一个自定义的中缀运算符都属于一个 优先级组 优先级组指定了自定义中缀运算符和其他中缀运算符的关系 【示例】： 123456789101112131415161718192021// 优先级和结合性struct Vector2D &#123; var x = 0.0,y = 0.0&#125;infix operator +-: AdditionPrecedenceextension Vector2D &#123; static func +- (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x,y: left.y - right.y) &#125;&#125;infix operator *^: MultiplicationPrecedenceextension Vector2D &#123; static func *^ (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x * right.x,y: left.y * left.y + right.y * right.y) &#125;&#125;let firstVector = Vector2D(x: 1.0,y: 2.0)let secondVector = Vector2D(x: 2.0,y: 3.0)let thirdVector = Vector2D(x: 3.0,y: 4.0)let result = firstVector +- secondVector *^ thirdVectorprint(&quot;\\(result.x) \\(result.y)&quot;) 编译运行，查看打印结果： 17.0 -23.0 【注】：先计算 *^ 优先级组，再计算 +- 优先级组 x: 2 * 3 &#x3D; 6 + 1 &#x3D; 7.0y: 3 * 3 + 4 * 4 &#x3D; 2 - 25 &#x3D; -23 接下来我们自己定义一个优先级组 123456789101112131415161718192021222324252627282930// 自定义优先级和结合性struct Vector2D &#123; var x = 0.0,y = 0.0&#125;infix operator +-: AdditionPrecedenceextension Vector2D &#123; static func +- (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x,y: left.y - right.y) &#125;&#125;infix operator *^: MyPrecedencegroup// 我的优先级组precedencegroup MyPrecedencegroup &#123; // 结合性 associativity: left // 优先级 lowerThan: AdditionPrecedence&#125;extension Vector2D &#123; static func *^ (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x * right.x,y: left.y * left.y + right.y * right.y) &#125;&#125;let firstVector = Vector2D(x: 1.0,y: 2.0)let secondVector = Vector2D(x: 2.0,y: 3.0)let thirdVector = Vector2D(x: 3.0,y: 4.0)let result = firstVector +- secondVector *^ thirdVectorprint 编译运行，查看打印结果： 19.0 17.0 【注】：先计算 *^ 优先级组，再计算 +- 优先级组 x：1 + 2 &#x3D; 3 * 3 &#x3D; 9.0y：2 - 3 &#x3D; -1 * -1 + 4 * 4 &#x3D; 17.0","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习20：如何为类和结构体自定义运算符","slug":"Swift课程/Swift学习20：如何为类和结构体自定义运算符","date":"2023-02-22T20:02:46.000Z","updated":"2023-03-09T07:23:46.686Z","comments":true,"path":"2023/02/23/Swift课程/Swift学习20：如何为类和结构体自定义运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A020%EF%BC%9A%E5%A6%82%E4%BD%95%E4%B8%BA%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"运算符重载 类和结构体 可以为现有的运算符提供自定义的实现，称为 运算符重载 1234567struct Vector2D &#123; var x = 0.0,y = 0.0&#125;let vector = Vector2D(x: 1.0,y: 2.0)let anotherVertor = Vector2D(x: 3.0,y: 1.0)let thirdVertor = vector + anotherVertor 运算符重载 1234567891011121314struct Vector2D &#123; var x = 0.0,y = 0.0&#125;extension Vector2D &#123; static func + (left:Vector2D,right:Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x,y: left.y + right.y) &#125;&#125;let vector = Vector2D(x: 1.0,y: 2.0)let anotherVertor = Vector2D(x: 3.0,y: 1.0)let thirdVector = vector + anotherVertorprint(&quot;x is \\(thirdVector.x),y is \\(thirdVector.y)&quot;) 编译运行，查看打印结果： 1x is 4.0,y is 3.0 一元运算符的重载 类和结构体 也能提供 标准一元运算符 的实现 要实现 前缀 或者 后缀 运算符，需要在声明运算符函数的时候在 func 关键字之前指定 prefix 或者 postfix 限定符 1234567891011struct Vector2D &#123; var x = 0.0,y = 0.0&#125;extension Vector2D &#123; static prefix func - (vector:Vector2D) -&gt; Vector2D &#123; return Vector2D(x: -vector.x,y: -vector.y) &#125;&#125;let vector = Vector2D(x: 1.0,y: 2.0)let vector2 = -vectorprint(&quot;x is \\(vector2.x),y is \\(vector2.y)&quot;) 编译运行，查看打印结果： 1x is -1.0,y is -2.0 组合赋值运算符重载 组合赋值运算符将赋值运算符 = 与其他运算符进行结合 在实现的时候，需要把运算符的左参数设置成 inout 类型，因为这个参数的值会在运算符函数内直接被修改 123456789extension Vector2D &#123; static func += (left: inout Vector2D,right:Vector2D) &#123; left = Vector2D(x: left.x + right.x,y: left.y + right.y) &#125;&#125;var vector3 = Vector2D(x: 1.0, y: 2.0)let vector4 = Vector2D(x: 2.0,y: 3.0)vector3 += vector4print(&quot;x is \\(vector3.x),y is \\(vector3.y)&quot;) 编译运行，查看打印结果： 1x is 3.0,y is 5.0 等价运算符重载 自定义类和结构体不接收等价运算符的默认实现，也就是所谓的 等于 运算符 == 和 不等于 运算符 != 要使用等价运算符来检查你自己类型的等价，需要和其他 中缀运算符 一样提供一个 等于 运算符重载，并且遵循标准库的 Equatable 协议 swift 为一下自定义类型提供等价运算符合成实现 只有遵循 Equatable 协议存储属性的 结构体 只拥有遵循 Equatable 协议关联类型的 枚举 没有关联类型的枚举 123456789101112// 等价运算符struct Vector2D &#123; var x = 0.0,y = 0.0&#125;extension Vector2D: Equatable &#123; static func == (left:Vector2D,right:Vector2D) -&gt; Bool &#123; return (left.x == right.x) &amp;&amp; (left.y == right.y) &#125;&#125;var vector1 = Vector2D(x: 1.0, y: 2.0)let vector2 = Vector2D(x: 2.0,y: 3.0)print(vector1 == vector2) 编译运行，查看打印结果： 1false 自定义中缀运算符的优先级和结合性 自定义的中缀 infix 运算符也可以指定优先级和结合性 每一个自定义的中缀运算符都属于一个优先级组 优先级组指定了自定义中缀运算符和其他中缀运算符的关系","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习19：运算符优先级和结合性","slug":"Swift课程/Swift学习19：运算符优先级和结合性","date":"2023-02-22T20:02:16.000Z","updated":"2023-03-09T07:23:43.977Z","comments":true,"path":"2023/02/23/Swift课程/Swift学习19：运算符优先级和结合性/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A019%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7/","excerpt":"","text":"运算符优先级和结合性 运算符的优先级使得一些运算符优先于其他运算符，高优先级的运算符会先被计算 结合性定义了具有相同优先级的运算符是如何结合（或关联）的 一一 是左边结合为一组，还是与右边结合为一组。可以这样理解：它们是与左边的表达式结合的 或者 它们是与右边的表示式结合的 运算符优先级-显示括号 2 + 3 % 4 * 5 等价于 2 + ((3 % 4) * 5) swift 语言中逻辑运算符 &amp;&amp; 和 || 是左相关的，这意味着多个逻辑运算符组合的表达式会首先计算最左边的","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习18：运算符应用举例","slug":"Swift课程/Swift学习18：运算符应用举例","date":"2023-02-22T17:32:43.000Z","updated":"2023-03-09T07:23:41.153Z","comments":true,"path":"2023/02/23/Swift课程/Swift学习18：运算符应用举例/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A018%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/","excerpt":"","text":"两个数字交换 不借助临时变量，交换两个变量的值 1234567var a = 1var b = 2a = a ^ bb = a ^ ba = a ^ bprint(a)print(b) 求无符号整数二进制中 1 的个数 给定一个无符号整型 UInt 变量，求其二进制表中 1 的个数，要求算法执行效率尽可能的高 思路：看一个八位整数 10 100 001 ，先判断最后一位是否为 1 ，而 与 操作可以达到目前。可以把这个 八位数字 与 00 0000 01 进行 与 操作，如果结果为 1，则表示当前八位数的最后一位为 1，否则为 0 。怎么判断第 二 位呢？向右移位，再延续前面的判断即可 12345678910111213// 有几个 1func countsOfOnes(num:UInt) -&gt; UInt &#123; var count:UInt = 0 var temp = num while temp != 0 &#123; // 如果都是位 1 才累加 count += temp &amp; 1 // 右移 temp = temp &gt;&gt; 1 &#125; return count&#125;countsOfOnes(num: 8) 如果整数的二进制中有较多的 0，那么我们每一次右移做判断会很浪费，怎么改进前面的算法呢？有没有办法让算法的复杂度只有与 1 的个数有关？ 思路：为了简化这个问题，我们考虑只有高位 1 的情况。例如：11 000 000，如何跳过前面低位的 6 个 0 ，而直接判断第 七 位的 1？我们可以设计 11 000 000 和 10 111 111（也就是 11 000 000 - 1）做 与 操作，消去最低位的 1。如果得到的结果为 0，说明我们已经找到或消去里面最后一个 1，如果不为 0，那么说明我们消去了最低位的 1，但是二进制中还有其他的 1，我们的计数器需要加 1，然后继续上面的操作 计数器 count &#x3D; 0 步骤一：整数不为0，说明二进制里面肯定有1，count &#x3D; 1 11 000 000 &amp; 10 111 111 &#x3D; 10 000 000 (消去第7位的1) 步骤二：结果不为 0，说明二进制里还有 1，count &#x3D; 2 10 000 000 &amp; 01 111 111 &#x3D; 0（消去第8位的1） 12345678910func countsOfOnes2(num:UInt) -&gt; UInt &#123; var count:UInt = 0 var temp = num while temp != 0 &#123; count += 1 temp = temp &amp; (temp - 1) &#125; return count&#125;countsOfOnes2(num: 3) 引申：如果判断一个征收为2的整数次幂 给定一个无符号整型 UInt 变量，判断是否为 2 的整数次幂 思路：一个整数如果是 2 的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位都是 0，根据前面的分析，把这个整数减去 1 后再和它自己做 &amp; 运算，这个整数中唯一的 1 就变成 0 了，也就是得到的结果是 0 12345// 2的整数次幂func isPowerTwo(num:UInt) -&gt; Bool &#123; return (num &amp; (num - 1)) == 0&#125;isPowerTwo(num: 18) 缺失的数字 很多成对出现的正整数保存在磁盘文件中，注意成对数字不一定是相邻的，如果 2、3、4、3、4、2、..，由于意外有一个数字消失了，如何尽快找到是哪个数字消失了？ 思路：考虑 ^ 异或操作的定义，当两个操作的数对应位不相同时，改数的对应位就为1。也就是说如果是相等的两个数 ^异或，得到的结果就是 0，而 0 与任何数字 ^异或，得到的是那个数字本身。所以我们考虑将所有的数字做 ^异或操作，因为只有一个数字消失，那么其他俩俩出现的数字 ^异或后为0，0与仅有的一个的数字做 ^异或，我们就得到了消失的数字是哪个？ 123456789// 缺失的数字func findLostNum(nums:[UInt]) -&gt; UInt &#123; var lostNum:UInt = 0 for num in nums &#123; lostNum = lostNum ^ num &#125; return lostNum&#125;findLostNum(nums: [1,3,2,4,2,1,3]) 如果有两个数字意外丢失了（丢失的不是相等的数字），改如何找到丢失的两个数字？ 思路：假设题目中这两个只出现1次的数字分别是A和B，如果能将A，B分开到二个数组中，那显然符合 异或 解法的关键点了，因此这个题目的关键点事将A和B分开到二个数组中。由于A，B肯定是不相等的，因此在二进制上肯定有一位是不同的。根据这一位是 0 还是 1 可以将A和B分开到A组合B组。而这个数组中其它数字那么就属于A组，要么就属于B组。再对A组 和 B组 分别执行 异或 解法，就可以得到A,B了。而要判断A，B在哪一位上不相同，只要根据 A ^ B 的结果就可以知道了，这个结果在二进制上为 1 的位都说明 A，B在这一位上是不同的 12345678910111213141516171819202122232425// 丢失的两个不同数func findTwoLostNum(nums:[UInt]) -&gt; (UInt,UInt) &#123; var lostNum1:UInt = 0 var lostNum2:UInt = 0 var temp:UInt = 0 // 计算两个数的异或结果 for num in nums &#123; temp = temp ^ num &#125; // 找到第一个为 1 的位 var flag:UInt = 1 while ((flag &amp; temp) == 0) &#123; flag = flag &lt;&lt; 1 &#125; // 找到两个丢失的数字 for num in nums &#123; if (num &amp; flag) == 0 &#123; lostNum1 = lostNum1 ^ num &#125;else &#123; lostNum2 = lostNum2 ^ num &#125; &#125; return (lostNum1,lostNum2)&#125;findTwoLostNum(nums: [1,2,3,4,2,1])","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习17：位运算符","slug":"Swift课程/Swift学习17：位运算符","date":"2023-02-22T17:32:26.000Z","updated":"2023-03-09T07:23:37.782Z","comments":true,"path":"2023/02/23/Swift课程/Swift学习17：位运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A017%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"位取反运算符 位取反运算符 ~ 是对所有位的数字进行取反操作 123let n1:UInt8 = 255let n2 = ~n1print(n2) 位与运算符 位与运算符 &amp; 可以对两个数的比特位进行合并，它会返回一个新的数，只有当这两个数都是 1 时才能返回 1 123456let n1:UInt8 = 255let n2 = ~n1let n3 = n1 &amp; n2let n4 = n1 | n2print(n3)print(n4) 位或运算符 位或运算符 | 可以对两个比特位进行比较，然后返回一个新的数，只要两个操作位任意一个为 1 时，那么对应的位数就为 1 位异或运算符 位异或运算符，或者说 互斥或 ^ 可以对两个数的比特位进行比较，它返回一个新的数，当两个操作数的对应位不同时，该数的对应位就为 1 1234let n1:UInt8 = 255let n2 = ~n1let n5 = n1 ^ n2print(n5) 位左移和右移运算符 位左移运算符 &lt;&lt; 和位右移运算符 &gt;&gt; 可以把所有位数的数字向左或向右移动一个确定的位数 位 左移和右移 具有给 整数乘以或除以二 的效果，将一个数 左移 一位相当于把这个 数翻倍，将一个数 右移 相当于把这个数 减半 无符号整数的位移操作 已经存在的比特位按指定的位数进行左移和右移 任何移动超出整型存储边界的位都会被丢弃 用 0 来填充向左或向右移动后产生的空白位 有符号整数的位移操作 有符号整数使用它的第一位（所谓的符号位）来表示这个整数是正数还是负数，符号位 0 表示 正数，1 表示 负数 其余的位数（所谓的数值位）存储了实际的值，有符号正整数和无符号数的存储方式是一样的，都是从 0 开始算起 但是负数的存储方式略有不同，它存储的是 2 的 n 次方减去它的绝对值，这里的 n 为数值位的位数 示例： 123let n6: Int = 8print(n6 &lt;&lt; 1)print(n6 &gt;&gt; 1) 补码表示的优点 首先，如果想给 -4 加个 -1，只需要将这两个数的全部 8 个比特位相加（包括符号位），并且将计算结果中超出的部分丢掉 其次，使用二进制补码可以使负数位的位左移和右移操作得到根正数同样的效果，即每向左移一位就将自身的数值 乘以2 ，每向右移一位就将自身的数值 除以2，要达到此目的，对 有符号的整数 的右移有一个额外的规则：当对整数进行位右移操作时，遵循与无符号整数相同的规则，但是对于位移产生的空白位使用符号进行填充，而不是 0","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习16：区间运算符","slug":"Swift课程/Swift学习16：区间运算符","date":"2023-02-22T17:32:10.000Z","updated":"2023-03-09T07:23:34.627Z","comments":true,"path":"2023/02/23/Swift课程/Swift学习16：区间运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A016%EF%BC%9A%E5%8C%BA%E9%97%B4%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"闭区间运算符 闭区间运算符 a...b 定义了从 a 到 b 的一组范围，并且包含 a 和 b ，a 的值不能大于 b 12345// 闭区间let range = 0...5for index in range &#123; print(index)&#125; 半开区间运算符 半开区间运算符 a..&lt;b 定义了从 a 到 b 但不包括 b 的区间 12345// 半开半闭区间let range = 0..&lt;5for index in range &#123; print(index)&#125; 如同闭区间运算符，a 的值也不能大于 b ，如果 a 与 b 的值相等，那返回的区间将会是空的 单侧区间 闭区间运算符有另外一种形式来让区间朝一个方向尽可能的远，这种区间叫做单侧区间 12345// 单侧闭区间let names = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]for name in names[...2] &#123; print(name)&#125; 半开区间运算符同样可以有单侧形式，只需要写它最终的值 12345// 单侧半开半闭区间let names = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]for name in names[..&lt;2] &#123; print(name)&#125; 比如说，一个包含数组所有元素的区间，从索引 2 到数组的结束，在这种情况下，你可以省略区间运算符一侧的值 123for name in names[2...] &#123; print(name)&#125; 单侧区间可以再其他上下文中使用，不仅仅是下标 不能变量省略了第一个值的单侧区间，因为遍历根本不知道该从哪里开始，你可以遍历省略了最终值的单侧区间 字符串索引区间 字符串范围可以使用区间运算符 12345// 字符串索引区间var str = &quot;hello,world&quot;let range = str.startIndex...str.index(str.endIndex, offsetBy: -6)str.removeSubrange(range)print(str) 倒叙索引 通过 reversed() 方法，我们可以将一个正序循环变成逆序循环 1234// 逆序for i in (0...4).reversed() &#123; print(i)&#125; Comparable 区别 区间运算符可以作用在 Comparable 类型上，返回闭区间和半闭区间 1234567var str = &quot;hello,world&quot;let range = &quot;a&quot;...&quot;z&quot;for c:Character in str &#123; if !range.contains(String(c)) &#123; print(&quot;\\(c) 不是小写字符&quot;) &#125; &#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习15：为了Optional，合并空置运算符","slug":"Swift课程/Swift学习15：为了Optional，合并空置运算符","date":"2023-02-22T17:31:50.000Z","updated":"2023-03-09T07:23:29.080Z","comments":true,"path":"2023/02/23/Swift课程/Swift学习15：为了Optional，合并空置运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A015%EF%BC%9A%E4%B8%BA%E4%BA%86Optional%EF%BC%8C%E5%90%88%E5%B9%B6%E7%A9%BA%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"合并空值运算符 合并空值运算符 a ?? b 如果可选项 a 有值则展开，如果没有值是 nil，则返回默认值 b 表达式 a 必须是一个可选类型，表达式 b 必须与 a 的存储类型相同 实际上是 三元运算符 作用到 Optional 上的缩写 a != nil ? a : b 如果 a 的值是非空的，b 的值将不会被考虑，也就是合并空值运算符是短路的 可选值为nil时，不能强制解包 可以用 if 判断实现 123456789101112131415161718let a:Int? = nillet b = 2func sum(x:Int?,y:Int?) -&gt; Int&#123;// return x! + y! if x != nil &#123; if y != nil &#123; return x! + y! &#125;else &#123; return x! &#125; &#125;else &#123; if y != nil &#123; return y! &#125;else &#123; return 0 &#125; &#125;&#125; 也可以用 ?? 来实现 1return (a ?? 0) + b","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习14：在Swift里如何处理算术结果溢出","slug":"Swift课程/Swift学习14：在Swift里如何处理算术结果溢出","date":"2023-02-22T17:31:22.000Z","updated":"2023-03-09T07:23:25.105Z","comments":true,"path":"2023/02/23/Swift课程/Swift学习14：在Swift里如何处理算术结果溢出/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A014%EF%BC%9A%E5%9C%A8Swift%E9%87%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%AE%97%E6%9C%AF%E7%BB%93%E6%9E%9C%E6%BA%A2%E5%87%BA/","excerpt":"","text":"溢出运算符 在默认情况下，当向一个整数赋超出它容量的值时，swift 会报错而不是生成一个无效的数，给我们操作过大或过小的数时提供了额外的安全性 同时提供三个算术溢出运算符来让系统支持整数溢出运算 溢出加法 &amp;+ 溢出减法 &amp;- 溢出乘法 &amp;* 值溢出 数值可以出现向上溢出或向下溢出 溢出也会发生在有符号整型数值上 对于无符号与有符号整型数值来说，当出现溢出时，它们会从数值所能容纳的最大数变成最小的数，同样的，当发生下溢时，它们会从所能容纳的最小数变成最大的数 代码示例 上溢出 下溢出","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习13：赋值和算术运算符","slug":"Swift课程/Swift学习13：赋值和算术运算符","date":"2023-02-22T17:30:48.000Z","updated":"2023-03-09T07:23:22.923Z","comments":true,"path":"2023/02/23/Swift课程/Swift学习13：赋值和算术运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A013%EF%BC%9A%E8%B5%8B%E5%80%BC%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"基本概念 一元运算符对一个目标进行操作。一元前缀运算符（如!b），一元后缀运算符（b!） 二元运算符对两个目标进行操作（a+b）同时因为它们出现在两个目标之间，所以是中缀 三元运算符操作三个目标，swift 语言也仅有一个 三元运算符，三元条件运算符（a?b:c） swift 运算符的改进 swift在支持 c 中的大多数标准运算符的同时也增加了一些排除常见代码错误的能力 赋值符号 = 不会返回值，以防止它被无用于等于符号 == 算术符号 +、-、*、/、% 以及其他可以监测并阻止值溢出，以避免你在操作比存储类型允许的范围更大或更小的数字时得到各种奇怪的结果 赋值运算符 赋值运算符将一个值赋值给另外一个值 如果赋值符号右侧是拥有多个值的元组，它的元素将会一次性地拆分成常量或者变量 Swift 的赋值符号自身不会返回值 算术运算符-标准运算符 标准算术运算符 + - * / 算术运算符同时也支持 String 的拼接 swift 算术运算符默认不允许值溢出 算术运算符 - 余数运算符 余数运算符 a%b 可以求出多少个 b 的倍数能够刚好放进 a 中并且返回剩下的值（就是我们所谓的余数） 当 a 是负数时也适用相同的方法来进行计算 当 b 为负数时它的正负号被忽略掉。这意味着 a%b 与 a%-b 能够获得相同的答案 12345678let c = 9 % 4print(c)let d = 9 % -4print(d)let e = -9 % 4print(e) 算术运算符 - 一元 数字值的正负号可以用前缀 - 来切换，我们称之为一元减号运算符 一元减号运算符 - 直接在要进行操作的值前边放置，不加任何空格 一元加号运算符 + 直接返回它操作的值，不会对其进行任何的修改","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习12：获取子串和字符串比较","slug":"Swift课程/Swift学习12：获取子串和字符串比较","date":"2023-02-21T18:59:39.000Z","updated":"2023-03-09T07:23:19.900Z","comments":true,"path":"2023/02/22/Swift课程/Swift学习12：获取子串和字符串比较/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A012%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AD%90%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/","excerpt":"","text":"子字符串 使用下标或者类似 prefix(_:) 的方法得到的子字符串是 Substring 类型 Substring 拥有 String 的大部分方法 Substring 可以转成 String 类型 1234let str = &quot;hello,world&quot;let index = str.firstIndex(of: &quot;,&quot;) ?? str.endIndexlet begin = str[..&lt;index]let new = String(begin) 子字符串重用一部分原字符串的内存 修改字符串或子字符串之前都不需要花费拷贝内存的代价 String 和 Substring 都遵循 StringProtocol 协议，也就是说它基本上都能很方便的兼容所有接受 StringProtocol 值的字符串操作函数 字符串的比较 字符串和字符相等性 == 和 != 前缀相等性 hasPrefis(_:) 后缀相等性 hasSubffix(_:) 12345var str1 = &quot;1&quot;var str2 = &quot;2&quot;print(str1 == str2)print(str1.hasPrefix(&quot;1&quot;))print(str2.hasSuffix(&quot;2&quot;))","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习11：索引访问和修改字符串","slug":"Swift课程/Swift学习11：索引访问和修改字符串","date":"2023-02-21T18:59:05.000Z","updated":"2023-03-09T07:23:17.616Z","comments":true,"path":"2023/02/22/Swift课程/Swift学习11：索引访问和修改字符串/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A011%EF%BC%9A%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串索引 每一个 String 值都有相关的索引类型，String.Index，他相当于每个 Character 在字符串中的位置 startIndex 属性来访问 String 中第一个 Character 的位置。endIndex 属性就是 String 中最后一个字符串的位置 endIndex 属性并不是字符串下标脚本的合法实际参数 如果 String 为空，则 startIndex 与 endIndex 相等 使用 index(before:) 和 index(after:) 方法来访问给定索引的前后 要访问给定索引更远的索引，你可以使用 index(_:offetBy:) 使用 indices 属性来访问字符串中每个字符的索引 123456var greeting = &quot;Hello, playground&quot;greeting[greeting.startIndex]greeting[greeting.index(before: greeting.endIndex)]greeting[greeting.index(after: greeting.startIndex)]let index = greeting.index(greeting.startIndex, offsetBy: 7)greeting[index] 插入 插入字符，使用 insert(_:at:) 方法 插入到另一个字符串的内容到特定的索引，使用 insert(contentsOf:at:) 方法 1234var str = &quot;hello&quot;str.insert(&quot;!&quot;, at: str.endIndex)str.insert(contentsOf: &quot; world&quot;, at: str.firstIndex(of: &quot;!&quot;)!)print(str) 删除 移除字符，使用 remove(at:) 方法 12var str = &quot;hello&quot;str.remove(at: str.index(before: str.endIndex)) 移除一小段特定范围的字符串，使用 removeSubrange(_:) 方法 123var str = &quot;hello&quot;let range = str.index(str.endIndex, offsetBy: -str.count)..&lt;str.endIndexstr.removeSubrange(range)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习10：字符串常见操作","slug":"Swift课程/Swift学习10：字符串常见操作","date":"2023-02-21T18:58:45.000Z","updated":"2023-03-09T07:23:15.658Z","comments":true,"path":"2023/02/22/Swift课程/Swift学习10：字符串常见操作/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A010%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/","excerpt":"","text":"字符串的可变性 var 指定的可以修改 let 指定的不可修改 对比 Object-C (NSString 和 NSMutableString) 字符串是 值类型 String 值在传递给方法或函数的时候会被复制过去 赋值给常量或变量的时候也是一样 Swift 编译器优化了字符串使用的资源，实际上拷贝只会在确实需要的时候才进行 123456var str1 = &quot;hello&quot;var str2 = str1print(str1 == str2)str1.append(&quot;,world&quot;)print(str1)print(str2) 操作字符 for in 循环遍历 String 中的每一个独立的 Character Character 类型 String 值可以通过传入 Character 数组来构造 1234var str = &quot;hello&quot;for c in str&#123; print(c)&#125; 字符串的拼接 使用加运算符 + 创建新字符串 使用 + 赋值符号 += 在已经存在的 String 值末尾追加一个 String 值 使用 String 类型的 append() 方法来可以给一个 String 变量的末尾追加 Character 值 字符串插值 字符串插值是一种从混合常量、变量、字面量和表达式的字符串字面量构造新 String 值的方法 每一个你插入到字符串字面量的元素都要被一对圆括号包裹，然后使用反斜杠前缀 \\() 类似于 NSString 的 stringWithFormat 方法，但是更加简便，更强大 可以在扩展字符串分割符中创建一个包含在其他情况下会被当做字符串插值的字符 要在使用扩展分隔符的字符串中使用字符串插值，在反斜杠后使用匹配首尾井号数量的井号 12let str = &quot;6 * 7 = \\(6 * 7)&quot;print(str)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习09：字符串创建和使用","slug":"Swift课程/Swift学习09：字符串创建和使用","date":"2023-02-21T18:58:24.000Z","updated":"2023-03-09T07:23:11.756Z","comments":true,"path":"2023/02/22/Swift课程/Swift学习09：字符串创建和使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A009%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"初始化空串 字面量 初始化器语法 isEmpty 检查是否为空串 123456var emptyString = &quot;&quot;var anotherEmptyString = String()if emptyString.isEmpty &#123; print(&quot;Nothing to see here&quot;)&#125; 字面量 字符串字面量是被双引号 “” 包裹的固定顺序文本字符 Swift 会为 str 常量推断类型为 String 1let str = &quot;some string&quot; 多行字面量 多行字符串字面量是用三个双引号引起来的一系列字符 多行字符串字面量把所有行包括在引号内，开始和结束默认不会有换行符 如果为了书写美观而不换行在后面加 \\ 12345678let someStr = &quot;&quot;&quot;1\\2\\345&quot;&quot;&quot;print(someStr) 要让多行字符串字面量起始或结束于换行，就在第一或最后一行写一个空行 多行字符串可以 缩进 以匹配周围的代码。双引号（”””）前的空格会告诉Swift其他行前应该有多少空白是需要忽略的 如果你在某行的空格超过了结束的双引号（”””），那么这些空格会被包含 12345678 let someStr = &quot;&quot;&quot; 1 2 3 4 5 &quot;&quot;&quot;print(someStr) 字符串里的特殊字符 转义特殊字符 \\o（空字符）,\\（反斜杠），\\t（水平制表符），\\n（换行符），\\r（回车符），\\”（双引号）以及 &#39;（单引号） 任意的 Unicode 标量，写作 \\u&#123;&#125;n，里边的 n 是一个 1-8 位的16进制数字，其值是合法 Unicode 值 1let str = &quot;\\u&#123;24&#125;&quot; 可以在多行字符串字面量中包含双引号（”）而不需要转义。要在多行字符串中包含文本 “”””””，转义至少一个双引号 扩展字符串分隔符(Raw String) 在字符串字面量中放置扩展分隔符来使 包含特殊字符的字符串 不让他们真的生效 把字符串放在双引号 (“) 内并由 (#) 包裹 12let str = #&quot;1\\n2\\n3\\n&quot;#print(str) 如果字符串里面有 &quot;# 则首尾需要两个 ## 12let str = ##&quot;1\\&quot;#n2\\#n3\\#n&quot;##print(str) 如果你需要字符串中某个特殊符号的效果，使用匹配你包裹的 # 号数量的 # 号，并在前面写转义符号 \\ 12let str = #&quot;1\\#n2\\#n3\\#n&quot;#print(str)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习08：Optional的使用Optional实现原理探索","slug":"Swift课程/Swift学习08：Optional的使用Optional实现原理探索","date":"2023-02-21T18:56:00.000Z","updated":"2023-03-09T07:23:09.481Z","comments":true,"path":"2023/02/22/Swift课程/Swift学习08：Optional的使用Optional实现原理探索/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A008%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8Optional%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"Optional-实现探究 Optional 其实是一个标准库里的一个 public 的 enum 类型，而且是 泛型 的，泛型的类型是 Wrapped 用标准库实现语言特性的典型 Optional.none 就是 nil Optional.some 则包装了实际的值 12345var str:Optional&lt;String&gt; = &quot;abc&quot;if let actualStr = str &#123; let count = actualStr.count print(count)&#125; Optional-解包实现 泛型属性 unsafelyUnwrapped 理论上我我们可以直接调用 unsafelyUnwrapped 获取可选项的值 123var str:String? = &quot;abc&quot;let count = str.unsafelyUnwrapped.countprint(count)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习07：Optional的使用","slug":"Swift课程/Swift学习07：Optional的使用","date":"2023-02-21T18:55:20.000Z","updated":"2023-03-11T16:39:05.504Z","comments":true,"path":"2023/02/22/Swift课程/Swift学习07：Optional的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A007%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"为什么需要 Optional？ Object-C 中用 nil 表示 指向不存在对象的指针，其他地方用 NSNotFound 表示 值缺失 Swift 中用 可选（Optional） 类型表示 值缺失，只有可选类型才能设置为 nil Optional 含有两种枚举，None 和 Some(T)，用来表示可能有值或可能没有值。 示例 12var optionalInteger: Int?var optionalInteger: Optional&lt;Int&gt; Optional 通过在 变量类型 后面加 ? 表示这里有一个值，它等于 x，或者这里根本没有值 你可以通过给可选变量赋值一个 nil 来将之设置为没有值 在 Object-C 中 nil 是一个 指向不存在对象的指针 在 Swift 中，nil 不是指针，它是 值缺失的一种特殊类型，任何类型的可选项都可以设置成 nil 而不仅仅是对象 只有 可选类型 才能设置为 nil 12var str: String = nilvar str1: String? = nil Optional-If 语句以及强制解包 可选类型 是没法直接使用的 需要用 ! 号 强制解包 后才能使用（意思是我知道这个可选项里面有值，使用吧） 12var str: String? = &quot;abc&quot;let count = str.count 需要改成如下代码，才能正确执行 12var str: String? = &quot;abc&quot;let count = str!.count 或 1234var str: String? = &quot;abc&quot;if str != nil &#123; let count = str!.count&#125; Optional-绑定 可以使用 可选绑定 来判断可选项是否包含值，如果包含就把赋值给一个临时的 常量或变量 可选绑定可以与 if 和 while 的语句使用来检查可选项内部的值，并赋值给一个变量或常量 同一个 if 语句中包含多可选项绑定，用逗号分割即可。如果任一可选绑定结果是 nil 或者 布尔值 为 false ，那么整个 if 判断会被看做 false 12345var str:String? = &quot;abc&quot;if let actualStr = str &#123; let count = actualStr.count print(count)&#125; Optional - 隐士解包 有些可选项一旦被设定值之后，就会一直拥有值，在这种情况下，就可以去掉检查的需求，也不必每次访问的时候都进行解包 通过有 声明的类型后边添加一个叹号（String!）而非问号（String?）来书写 隐士解包 可选项 123var str:String! = &quot;abc&quot;let count = str.countprint(count) 隐士解包可选项主要被用在Swift 类 的初始化过程中 Optional-可选链 可选项后面加问号 如果可选项不为nil，返回一个可选项结果，否则为nil 123var str:String? = &quot;abc&quot;let count = str?.countlet lastIndex = count - 1 将上面的代码改为： 1234567var str:String? = &quot;abc&quot;let count = str?.count//let lastIndex = count - 1if count != nil &#123; let lastIndex = count! - 1 print(lastIndex)&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习06：Tuple元组","slug":"Swift课程/Swift学习06：Tuple元组","date":"2023-02-21T18:54:43.000Z","updated":"2023-03-09T07:23:00.125Z","comments":true,"path":"2023/02/22/Swift课程/Swift学习06：Tuple元组/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A006%EF%BC%9ATuple%E5%85%83%E7%BB%84/","excerpt":"","text":"Tuple 元组 把多个值合并成单一的复合型的值 元组 内的值可以是任何类型，而且可以不必是统一类型 123let error = (1,&quot;没有权限&quot;)print(error.0)print(error.1) 元素命名 元组中的每一个元素可以指定对应的元素名称 123let error = (errorCode:1,errorMessage:&quot;没有权限&quot;)print(error.errorCode)print(error.errorMessage) 如果没有指定名称的元素也可以使用下标的方式来引用 123let error = (1,&quot;没有权限&quot;)print(error.0)print(error.1) Tuple 修改 用 var 定义的元组就是可变元组，let 定义的元组就是不可变元组 不管是可变还是不可变元组，元组在创建后就不能增加和删除元素 可以对可变元组的元素进行修改，但是不能改变其类型 123var error = (errorCode:1,errorMessage:&quot;没有权限&quot;)error.errorCode = 2error.errorMessage = &quot;2&quot; any 类型可以改为任何类型 12345var error: (Any,String) = (1,&quot;没有权限&quot;)error.0 = 2print(error)error.0 = &quot;abc&quot;print(error) Tuple 分解 将一个元组的内容分解成单独的常量或变量 1234let error = (1,&quot;没有权限&quot;)let (errorCode,errorMessage) = errorprint(errorCode)print(errorMessage) 如果只需要使用其中的一部分数据，不需要的数据可以用下划线 _ 代替 123let error = (1,&quot;没有权限&quot;)let (_,errorMessage) = errorprint(errorMessage) 作为函数返回值 使用 Tuple 为函数返回多个值 返回值的 Tuple 可以再函数的返回类型部分被命名 12345func writeToFile(content:String) -&gt; (errorCode:Int,errorMessage:String) &#123; return (1,&quot;没有权限&quot;)&#125;let error = writeToFile(content: &quot;&quot;)print(error)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习05：数值类型","slug":"Swift课程/Swift学习05：数值类型","date":"2023-02-21T18:53:56.000Z","updated":"2023-03-09T07:22:36.488Z","comments":true,"path":"2023/02/22/Swift课程/Swift学习05：数值类型/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A005%EF%BC%9A%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"整数 Swift 提供了 8，16，32，64 位编码的有符号和无符号整数 命名方式：例如 8位无符号整数的类型是 UInt8，32位有符号整数的类型是 Int32 通过 min 和 max 属性来访问每个整数类型的最小值和最大值 Swift 提供了一个额外的整数类型：Int，它拥有与当前平台的原生字相同的长度 同时 Swift 也提供 UInt 类型，来表示平台长度相关的无符号整型 建议在用到证书的地方都使用 Int 浮点类型 Double：64位浮点数，至少有 15 位数字的精度 Float：32位浮点数，至少有 6 为数字的精度 在两种类型都可以的情况下，推荐使用 Double 类型 数值范围 123let a = 8let b: UInt8 = 240print(&quot;UInt8 min \\(UInt8.min),UInt8 max \\(UInt8.max)&quot;) Bool Bool：true 和 false Swift 的类型安全机制会阻止你用一个非布尔量的值替换掉 Bool 1234let i = 1if i &#123; print(i)&#125; 我们修改一下 类型别名 类型别名是一个为 已存在类型 定义的一个 可选择的名字 你可以用关键字 typealias 定义一个类型的别名 当你想通过在一个在上下文中看起来更合适可具有表达行的名字来引用一个已存在的类型时，这时别名就非常有用了 123// 音频采样率typealias AudioSample = UInt8let sample:AudioSample = 32","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习04：变量和常量","slug":"Swift课程/Swift学习04：变量和常量","date":"2023-02-21T18:12:27.000Z","updated":"2023-03-09T07:22:31.262Z","comments":true,"path":"2023/02/22/Swift课程/Swift学习04：变量和常量/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A004%EF%BC%9A%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/","excerpt":"","text":"声明变量和常量 使用关键字 let 声明常量 12let a = 1a = 2 由于 x 是常量，不能给常量赋值，会报错 使用关键字 var 声明变量 12var b = 1b = 2 可以在一行中声明多个变量和常量，用逗号分割 1var x = 0.0,y = 1.0,z = 2.0 类型标注 在声明一个变量或常量时提供类型标注，来明确变量或常量能够存储值的类型 添加 类型标注 的方法是在 变量或常量 的名字后面加一个 冒号，再跟一个 空格，最后加上使用的 类型名称 可以在一行中定义多个相关的变量为相同的类型，用 逗号 分割，只要在最后的变量名字后加上类型标注 123var a: Stringa = &quot;hello&quot;a = 10 常量和变量命名 常量和变量的名字几乎可以使用任何字符，甚至包括 Unicode 字符 常量和变量的名字不能包含 空白字符、数学符号、箭头、保留的（或者无效的）Unicode码位、连线和制表符。也不能以 数字 开头，尽管数字几乎可以使用在名字其他的任何地方 123let π = 3.1415let 你好 = &quot;你好世界&quot;let 🐶🐂 = &quot;dog,cow&quot; 打印常量和变量 print(_:separator:teminator) 字符串插入 用 \\() 来插入 123456let π = 3.1415let 你好 = &quot;你好世界&quot;let 🐶🐂 = &quot;dog,cow&quot;print(π)print(&quot;\\(你好)&quot;)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习03：Playgorund使用","slug":"Swift课程/Swift学习03：Playground使用","date":"2023-02-21T16:41:59.000Z","updated":"2023-03-09T07:22:28.309Z","comments":true,"path":"2023/02/22/Swift课程/Swift学习03：Playground使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A003%EF%BC%9APlayground%E4%BD%BF%E7%94%A8/","excerpt":"","text":"简介 Swift 的 Playgorund 是为了让人人都能愉快的学习 swift 编程 但发展至今，这个工具越来越强大 Playgorund 使用 创建一个 Playgorund 应用 Next，默认名 MyPlayground 可以通过 New -&gt; Playground Page 创建多个 Playground 来学习 注：快捷键 command + option + n 创建 Playground Page command + shift + enter 快速运行程序 简单使用 写一个求和的函数 12345678// 求和函数func sum(a:Int,b:Int) -&gt; Int &#123; return a+b&#125;// 调用求和函数 赋值给 常量 clet c = sum(a: 1, b: 2)// 打印常量 cprint(c)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习02：REPL交互式解释器","slug":"Swift课程/Swift学习02：REPL交互式解释器","date":"2023-02-21T16:41:38.000Z","updated":"2023-03-09T07:21:52.642Z","comments":true,"path":"2023/02/22/Swift课程/Swift学习02：REPL交互式解释器/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A002%EF%BC%9AREPL%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%99%A8/","excerpt":"","text":"介绍 xcode 6.1 引进了另外一种以交互式的方式来体验 Swift 的方法 Read Eval PrintLoop，简称REPL 使用REPL 除了可以 定义常量和变量 外，还是可 定义函数 打开终端输入 12mac@bogon ~ % swiftmac@bogon ~ % swift repl 定义变量 定义函数 REPL 其他命令 退出：:quit 帮助：:help 将光标移动到当前行的开始处：Control + A 将光标移动到当前行的结束处：Control + E","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习01：Swift编译流程","slug":"Swift课程/Swift学习01：Swift编译过程","date":"2023-02-21T15:49:55.000Z","updated":"2023-03-09T07:21:48.350Z","comments":true,"path":"2023/02/21/Swift课程/Swift学习01：Swift编译过程/","link":"","permalink":"https://www.bboyzj.cn/2023/02/21/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A001%EF%BC%9ASwift%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","excerpt":"","text":"编译器架构Swift编译过程和OC基本类似，仅仅是前端编译器不一样。 OC/C 前端编译器是 Clang Swift 先解析成 Swift AST（抽象语法树），通过 swiftc 这个命令行参数，编译成 Swift IL OC 和 Swift 最后均编译成 LLVM IR 中间层表示 OC 和 Swift 最终通过 后端编译器 LLVM compiler ，编译成最终的在具体地址上可以执行的二进制，包括x86、arm和other 详细编译流程 Swift 先解析成 AST（抽象语法树） 经过一系列工具编程 Swift 的 SIL(中间语言) 再经过 分析、IR工具 转成 LLVM IR(中间表示层) 最终通过 后端编译器 LLVM compiler 编译成 .o 目标文件 命令行流程使用终端创建一个简单的 main.swift 文件 12mac@bogon ~ % cd Desktopmac@bogon Desktop % touch main.swift 此时你可以在桌面看到一个 main.swift 文件 在该文件下写下两个数相加的一个函数 123456func sum(a:Int,b:Int) -&gt; Int &#123; return a + b&#125;let value = sum(a: 1, b: 2)print(value) 打开命令行工具 mac@bogon ~ % cd Desktop 生成 AST 抽象语法树 mac@bogon ~ % swiftc main.swift -dump-ast 生成 SIL 中间语言 mac@bogon ~ % swiftc main.swift -emit-sil 生成 LLVM IR 中间表示层 mac@bogon ~ % swiftc main.swift -emit-ir 生成 Assembly Language 汇编语言 mac@bogon ~ % swiftc main.swift -emit-assembly 生成二进制文件 mac@bogon ~ % swiftc -o main.out main.swift 命令行输入： 1234mac@bogon ~ % cd /Users/mac/Desktop/01swift编译流程 mac@bogon 01swift编译流程 % swiftc -o main.out main.swiftmac@bogon 01swift编译流程 % ./main.out3","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习：单例模式","slug":"Swift/Swift学习：单例模式","date":"2023-02-21T14:08:53.000Z","updated":"2023-03-08T22:10:19.559Z","comments":true,"path":"2023/02/21/Swift/Swift学习：单例模式/","link":"","permalink":"https://www.bboyzj.cn/2023/02/21/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"简介单例模式（Singleton Pattern） 最 swift 开发中常见的 设计模式之一。 特点 保证一个类只有一个实例，并提供一个全局的访问点 减少内存开销，解决了一个类全局使用时频繁的创建和销毁 实现 static 声明一个常量实例对象shared，只分配一次内存 private 私有化构造函数 init，放止外部创建新实例 12345678910111213class MySingleton &#123; // 声明静态变量实例，只初始化一次，值分配一次内存 static let shared = MySingleton() // 私有构造函数，防止从外部创建新的实例 private override init () &#123; super.init() &#125; // 函数 func doSomething() &#123; print(&quot;do something&quot;) &#125;&#125; 使用单例对象 1MySingleton.shared.doSomething();","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"SwiftUI学习12：List列表和ForEach循环的使用","slug":"SwiftUI课程/SwiftUI学习12：List列表和ForEach循环的使用","date":"2023-02-20T09:27:34.000Z","updated":"2023-03-08T22:30:08.818Z","comments":true,"path":"2023/02/20/SwiftUI课程/SwiftUI学习12：List列表和ForEach循环的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A012%EF%BC%9AList%E5%88%97%E8%A1%A8%E5%92%8CForEach%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}],"tags":[{"name":"SwiftUI-学习篇","slug":"SwiftUI-学习篇","permalink":"https://www.bboyzj.cn/tags/SwiftUI-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}]},{"title":"SwiftUI学习11：Path路径的使用","slug":"SwiftUI课程/SwiftUI学习11：Path路径的使用","date":"2023-02-20T09:26:54.000Z","updated":"2023-03-08T22:30:02.506Z","comments":true,"path":"2023/02/20/SwiftUI课程/SwiftUI学习11：Path路径的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A011%EF%BC%9APath%E8%B7%AF%E5%BE%84%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}],"tags":[{"name":"SwiftUI-学习篇","slug":"SwiftUI-学习篇","permalink":"https://www.bboyzj.cn/tags/SwiftUI-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}]},{"title":"SwiftUI学习10：State和Binding绑定的使用","slug":"SwiftUI课程/SwiftUI学习10：State和Binding绑定的使用","date":"2023-02-20T09:26:17.000Z","updated":"2023-03-08T22:37:23.238Z","comments":true,"path":"2023/02/20/SwiftUI课程/SwiftUI学习10：State和Binding绑定的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A010%EF%BC%9AState%E5%92%8CBinding%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言在本章节中，你将学会如何使用 State 和 Binding 绑定，监听属性值的变化，和根据 Binding 绑定关系，改变一个属性值同时影响另一个属性值的变化 举例： 当我们在听音乐或看视频时，点击 播放 按钮，播放 按钮变成 暂停 按钮，同时视频开始播放 这就用到了 @State属性包装器 和 @Binding包装器 尝试完成下面的设计稿： 分析 首先我们准备好图片素材，未选中的图片和选中的图片，放到Assets中 定义一个@State变量存放状态，通过点击来切换状态 创建按钮通过状态变量判断显示图片 注：定义的变量放在struct下面，body上面 具体代码的实现知识点： 1.toggle() 切换按钮状态 完成代码： 12345678910111213141516171819struct ContentView: View &#123; // 定义变量 @State var isSelect:Bool = false var body: some View &#123; // 按钮 Button &#123; print(&quot;点击了按钮&quot;) self.isSelect.toggle() &#125; label: &#123; Image(systemName: isSelect ? &quot;checkmark.circle.fill&quot; : &quot;circle&quot;) .font(.system(size: 150)) .foregroundColor(isSelect ? Color(red: 112/255, green: 182/255, blue: 3/255) : Color(red: 170/255, green: 170/255, blue: 170/255)) &#125; &#125;&#125; Binding绑定以上面的代码为例，如果我们在按钮下面添加一个文本Text 按钮关闭时，title文字为：未开启 按钮打开时，title文字为：已开启 我们实现一下代码： 1234567891011121314151617181920212223242526272829303132struct ContentView: View &#123; // 定义变量 @State var isSelect:Bool = false var body: some View &#123; // 按钮 VStack &#123; Button &#123; print(&quot;点击了按钮&quot;) self.isSelect.toggle() &#125; label: &#123; Image(systemName: isSelect ? &quot;checkmark.circle.fill&quot; : &quot;circle&quot;) .font(.system(size: 150)) .foregroundColor(isSelect ? Color(red: 112/255, green: 182/255, blue: 3/255) : Color(red: 170/255, green: 170/255, blue: 170/255)) &#125; // 文本 titleView() &#125; &#125;&#125;struct titleView: View &#123; var body: some View &#123; Text(&quot;未开启&quot;) .font(.system(size: 25)) .fontWeight(.bold) .padding() &#125;&#125; 此时如果我们想通过 isSelect 来关联 Text文字，会报错，因为找不到，不在一个视图下 因此，我们这里引入了 Binding绑定 概念，Binding共享了State定义的状态，State状态改变时，Binding绑定的参数会一起改变 定义绑定变量 isSelect 12// 定义绑定@Binding var isSelect:Bool 绑定状态用$ 12// 文本titleView(isSelect: $isSelect) 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; ContentView() &#125;&#125;struct ContentView: View &#123; // 定义变量 @State var isSelect:Bool = false var body: some View &#123; // 按钮 VStack &#123; Button &#123; print(&quot;点击了按钮&quot;) self.isSelect.toggle() &#125; label: &#123; Image(systemName: isSelect ? &quot;checkmark.circle.fill&quot; : &quot;circle&quot;) .font(.system(size: 150)) .foregroundColor(isSelect ? Color(red: 112/255, green: 182/255, blue: 3/255) : Color(red: 170/255, green: 170/255, blue: 170/255)) &#125; // 文本 titleView(isSelect: $isSelect) &#125; &#125;&#125;struct titleView: View &#123; // 绑定状态 @Binding var isSelect:Bool var body: some View &#123; Text(self.isSelect ? &quot;已开启&quot; : &quot;未开启&quot;) .font(.system(size: 25)) .fontWeight(.bold) .padding() &#125;&#125;","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}],"tags":[{"name":"SwiftUI-学习篇","slug":"SwiftUI-学习篇","permalink":"https://www.bboyzj.cn/tags/SwiftUI-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}]},{"title":"SwiftUI学习09：Gradient渐变色的使用","slug":"SwiftUI课程/SwiftUI学习09：Gradient渐变色的使用","date":"2023-02-20T09:25:43.000Z","updated":"2023-03-08T22:29:55.357Z","comments":true,"path":"2023/02/20/SwiftUI课程/SwiftUI学习09：Gradient渐变色的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A009%EF%BC%9AGradient%E6%B8%90%E5%8F%98%E8%89%B2%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"介绍如果我们想要做渐变色背景，我们需要使用SwiftUI框架内置的渐变色代码 左右渐变 1 上下渐变 1 简单描述下参数的意思： 1234LinerGradient()：线性渐变gradient：渐变色，通常用颜色数组 [Color.blue,Color.green]，也就是开始颜色蓝色，结束颜色 是绿色startPoint：开始位置，通常使用.leading .trailing .top .botton 左右上下endPoint：结束位置，通常使用.leading .trailing .top .botton 左右上下 按钮样式协议如果按钮很多，切样式都可以复用的情况下，复制一大串代码不符合 优雅代码的目标 这里我们科普一个新的概念，叫做 ButtonStyles，也就是按钮样式协议，继承这个协议，我们就可以实现样式 它的代码结构如下： 123456struct GradientBackgroundStyle:ButtonStyle&#123; func makeBody(configuration: Configuration) -&gt; some View &#123; configuration.label // Button样式 &#125;&#125; 样式使用方式 12// 样式引用方式.buttonStyle(GradientBackgroundStyle()) 完整代码和效果123456789101112131415161718192021222324252627282930313233struct ContentView: View &#123; var body: some View &#123; Button &#123; print(&quot;登录成功&quot;) &#125; label: &#123; Text(&quot;微信登录&quot;) .font(.system(size: 14)) &#125; // 样式引用方式 .buttonStyle(GradientBackgroundStyle()) &#125;&#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; ContentView() &#125;&#125;// ButtonStylestruct GradientBackgroundStyle:ButtonStyle&#123; func makeBody(configuration: Configuration) -&gt; some View &#123; configuration.label // 按钮修饰符 .frame(minWidth: 0,maxWidth: .infinity,minHeight: 0,maxHeight: 50) .foregroundColor(.white) .background(LinearGradient(gradient: Gradient(colors: [Color(&quot;8FD3F4&quot;),Color(&quot;84FAB0&quot;)]), startPoint: .leading, endPoint: .trailing)) .cornerRadius(5) .padding(.horizontal,20) &#125;&#125;","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}],"tags":[{"name":"SwiftUI-学习篇","slug":"SwiftUI-学习篇","permalink":"https://www.bboyzj.cn/tags/SwiftUI-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}]},{"title":"SwiftUI学习08：UIButton按钮的使用","slug":"SwiftUI课程/SwiftUI学习08：UIButton按钮的使用","date":"2023-02-20T08:25:53.000Z","updated":"2023-03-08T22:35:57.085Z","comments":true,"path":"2023/02/20/SwiftUI课程/SwiftUI学习08：UIButton按钮的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A008%EF%BC%9AUIButton%E6%8C%89%E9%92%AE%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言在本章节中，我们将学会如何使用Button按钮这个基本控件 由于Button组件在不同场景下应用不同，我们分成3个部分 简单文字按钮 简单图片按钮 图片+文字按钮 创建按钮swiftUI中创建按钮代码很简单，代码如下： 12345Button &#123; // 操作 &#125; label: &#123; // 按钮样式 &#125; 第一个注释：点击了按钮后，系统执行什么操作 第二个注释：按钮的样式，这个按钮是什么 举个例子： 1234567891011struct ContentView: View &#123; var body: some View &#123; Button &#123; // 操作 print(&quot;登录成功&quot;) &#125; label: &#123; // 按钮样式 Text(&quot;微信登录&quot;) &#125; &#125;&#125; Text常用方法 .frame：尺寸，.infinity 自适应屏幕宽高 .padding：边距，在按钮外面撑开一块面积，上下左右都留边距 用Button实现下面的UI效果图如下 思路：创建 Button 按钮，并将其 提取 成子视图，插入到 垂直分布中 简单文字按钮1234567891011121314151617181920// 按钮视图struct ButtonView: View &#123; // 定义变量 var title:String? var bgColor:Color? var body: some View &#123; Button &#123; // 操作 print(&quot;\\(title!)成功&quot;) &#125; label: &#123; // 按钮样式 Text(title!) .frame(minWidth: 0,maxWidth: .infinity,minHeight: 0,maxHeight: 40) .background(bgColor) .font(.system(size: 14)) .foregroundColor(.white) .cornerRadius(5) .padding(.horizontal,50) // 水平居中，左右边距50 &#125; &#125;&#125; 简单图片按钮123456789101112131415// 图片按钮struct ImgButton: View &#123; var body: some View &#123; Button &#123; print(&quot;登录成功&quot;) &#125; label: &#123; Image(&quot;wechat&quot;) .resizable() .aspectRatio(contentMode: .fit) .frame(minWidth: 0,maxWidth: 50,minHeight: 0,maxHeight: 50) &#125; &#125;&#125; 图片+文字按钮12345678910111213141516171819202122// 图片文字按钮struct ImgTextButton: View &#123; var body: some View &#123; Button &#123; print(&quot;登录成功&quot;) &#125; label: &#123; HStack &#123; Image(systemName: &quot;applelogo&quot;) .font(.title) Text(&quot;Apple登录&quot;) .fontWeight(.semibold) .font(.title) &#125; .frame(minWidth: 0,maxWidth: .infinity,minHeight: 0,maxHeight: 70) .background(Color(red: 51/255, green: 51/255, blue: 51/255)) .foregroundColor(.white) .cornerRadius(40) .padding(.horizontal,20) &#125; &#125;&#125; 最后呈现的代码12345678910111213141516struct ContentView: View &#123; var body: some View &#123; VStack &#123; // 微信登录 ButtonView(title: &quot;微信登录&quot;,bgColor: .green) // Apple登录 ButtonView(title: &quot;Apple登录&quot;,bgColor: .black) // 图片按钮 ImgButton() // 图片+文字按钮 ImgTextButton() &#125; &#125;&#125;","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}],"tags":[{"name":"SwiftUI-学习篇","slug":"SwiftUI-学习篇","permalink":"https://www.bboyzj.cn/tags/SwiftUI-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}]},{"title":"SwiftUI学习07：ScrollView滚动视图使用","slug":"SwiftUI课程/SwiftUI学习07：ScrollView滚动视图使用","date":"2023-02-20T08:25:30.000Z","updated":"2023-03-08T22:34:01.346Z","comments":true,"path":"2023/02/20/SwiftUI课程/SwiftUI学习07：ScrollView滚动视图使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A007%EF%BC%9AScrollView%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言在本章中，你将学会如何使用 代码分组 和 代码复用 的方式创建 ScrollView 滚动视图 以微信公众号为例，我们试试完成下面的UI设计图 分析由UI可知，文章是由图片Image和Text组成，而且是 纵向排列 因此，我们实现的步骤如下： 准备一些图片素材，放入到 Assets.xcassets 文件中 先完成基础的 单个卡片的代码，并将其 纵向分布 将卡片 提取成子视图，嵌入到 ScrollView 中 代码实现 将图片素材，放入到 Assets.xcassets 文件中 基础卡片的实现 Image图片的常用方法: 12.resizabl ：调节大小，调整图片显示的大小.aspectRatio() ：宽高比，.aspectRatio(contentMode: ContentMode.fit)让图片适应屏幕，并保持原有的宽高比 Text文本常用的方法： 1234.font()：字体，.font(.system(size:17))，系统17号字.fontWeight()：字重，.fontWeight(.blod)，加粗.foregroundColor()：字体颜色，.foregroundColor(.black)，系统黑色.padding()：边距，四周留开边距 单个卡片实现的代码： 123456789101112VStack &#123; // 图片 Image(&quot;book1&quot;) .resizable() // 调整图片显示的大小 .aspectRatio(contentMode: ContentMode.fit) // 宽高比 // 文字 Text(&quot;你的能力是否在全世界通用，如果不能，那么需求重新评估你的能力&quot;) .font(.system(size: 17)) .fontWeight(.bold) .foregroundColor(.black) .padding() &#125; 给整个 卡片 加边框，通过 .overlay() 修饰符 覆盖 上去： 12345.cornerRadius(10).overlay( RoundedRectangle(cornerRadius: 10) .stroke(Color(red: 150/255, green: 150/255, blue: 150/255,opacity: 0.1),lineWidth: 1)) 给 卡片 设置一个边距，用到了 .padding() 修饰符，且是它的 高级用法： 1.padding([.top,.horizontal]) 顶部，水平居中 将卡片提取成子视图 12345678910111213141516171819202122232425262728// 卡片视图struct CardView: View &#123; // 定义变量 var img:String? // 图片 var title:String? // 标题 var body: some View &#123; VStack &#123; // 图片 Image(img!) .resizable() // 调整图片显示的大小 .aspectRatio(contentMode: ContentMode.fit) // 宽高比 // 文字 Text(title!) .font(.system(size: 17)) .fontWeight(.bold) .foregroundColor(.black) .padding() &#125; .cornerRadius(10) .overlay( RoundedRectangle(cornerRadius: 10) .stroke(Color(red: 150/255, green: 150/255, blue: 150/255,opacity: 0.1),lineWidth: 1) ) .padding([.top,.horizontal]) &#125;&#125; 将多张卡片添加到ScrollView中 123456789101112131415struct ContentView: View &#123; var body: some View &#123; ScrollView&#123; VStack &#123; // 卡片视图 CardView(img: &quot;book1&quot;,title: &quot;你的能力是否能在全世界通用，如果不能,那么需求重新评估你的能力。&quot;) CardView(img: &quot;book2&quot;,title: &quot;当你判断你的想法是正确的，那么就在今天完成吧。&quot;) CardView(img: &quot;book3&quot;,title: &quot;当你判断你的想法是正确的，那么就在今天完成吧。&quot;) CardView(img: &quot;book4&quot;,title: &quot;将自身所学的回馈社会，不也是意见幸福的事儿么&quot;) CardView(img: &quot;book2&quot;,title: &quot;成功的秘诀，绝对不要和别人做相同的事儿&quot;) &#125; &#125; &#125;&#125; 最终呈现的结果如下：","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}],"tags":[{"name":"SwiftUI-学习篇","slug":"SwiftUI-学习篇","permalink":"https://www.bboyzj.cn/tags/SwiftUI-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}]},{"title":"SwiftUI学习06：定义变量","slug":"SwiftUI课程/SwiftUI学习06：定义变量","date":"2023-02-20T07:25:50.000Z","updated":"2023-03-08T22:31:57.581Z","comments":true,"path":"2023/02/20/SwiftUI课程/SwiftUI学习06：定义变量/","link":"","permalink":"https://www.bboyzj.cn/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A006%EF%BC%9A%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F/","excerpt":"","text":"定义变量由上一章的案例，我们发现，除了 定价方案的标题不同（连续包月，1个月，12个月），不同定价方案价格不同（￥18、￥30、￥228）、背景颜色不同，其他都一样，我们将这三个属性定义成变量 12345678910struct priceView: View &#123; // 定义变量 var title: String? var price: String? var bgColor: Color? var body: some View &#123; HStack &#123; // 连续包月 VStack &#123; 给变量赋予真正的值 将价格视图改成可以传递变量的通用函数 1234567891011121314151617181920212223242526272829303132// 价格struct priceView: View &#123; // 定义变量 var title: String? var price: String? var bgColor: Color? var body: some View &#123; ZStack &#123; VStack()&#123; Text(title!) .font(.system(size: 17)) .fontWeight(.bold) .foregroundColor(Color(red: 190/255, green: 188/255, blue: 184/255)) Text(price!) .fontWeight(.bold) .font(.system(size: 30)) .foregroundColor(Color(red: 239 / 255, green: 129 / 255, blue: 112 / 255)) &#125; // 最大宽度自适应 .frame(minWidth: 0, maxWidth: .infinity, minHeight: 90) .padding(20) .background(Color(&quot;faf7f3&quot;)) .cornerRadius(4) .overlay( // 覆盖 RoundedRectangle(cornerRadius: 4) .stroke(Color(red: 202 / 255, green: 169 / 255, blue: 106 / 255),lineWidth: 2)) &#125; &#125;&#125; 此时，你可以传递4个参数，来生成 垂直分布的 视图 连续创建三个视图并添加到 水平分布中 123456789101112131415161718import SwiftUIstruct ContentView: View &#123; var body: some View &#123; HStack &#123; // 连续包月 priceView(title: &quot;连续包月&quot;,price: &quot;$18&quot;,bgColor: Color(&quot;faf7f3&quot;)) // 1个月 priceView(title: &quot;1个月&quot;,price: &quot;$30&quot;,bgColor: Color(red: 244/255, green: 244/255, blue: 245/255)) // 12个月 priceView(title: &quot;12个月&quot;,price: &quot;$228&quot;,bgColor: Color(red: 244/255, green: 244/255, blue: 245/255)) &#125; .padding(10) &#125;&#125; 由于连续包月上还有一个首月特惠，所以需要 插入到 叠加分布 中 12345678910111213// 连续包月ZStack &#123; priceView(title: &quot;连续包月&quot;,price: &quot;$18&quot;,perPrice: &quot;&quot;,bgColor: Color(&quot;faf7f3&quot;)) // 首月特惠 Text(&quot;首月特惠&quot;) .font(.system(size: 14)) .fontWeight(.bold) .foregroundColor(.white) .background(Color(red: 202 / 255, green: 169 / 255, blue: 106 / 255)) .cornerRadius(4) .padding(10) .offset(x:0,y:-65)&#125; 最后将 首月特惠 提取子视图 12345678910111213// 首月特惠struct FirstSpecial: View &#123; var body: some View &#123; Text(&quot;首月特惠&quot;) .font(.system(size: 14)) .fontWeight(.bold) .foregroundColor(.white) .background(Color(red: 202 / 255, green: 169 / 255, blue: 106 / 255)) .cornerRadius(4) .padding(10) .offset(x:0,y:-65) &#125;&#125;","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}],"tags":[{"name":"SwiftUI-学习篇","slug":"SwiftUI-学习篇","permalink":"https://www.bboyzj.cn/tags/SwiftUI-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}]},{"title":"SwiftUI学习05：代码分组管理","slug":"SwiftUI课程/SwiftUI学习05：代码分组管理","date":"2023-02-19T15:14:49.000Z","updated":"2023-03-08T22:31:25.786Z","comments":true,"path":"2023/02/19/SwiftUI课程/SwiftUI学习05：代码分组管理/","link":"","permalink":"https://www.bboyzj.cn/2023/02/19/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A005%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%88%86%E7%BB%84%E7%AE%A1%E7%90%86/","excerpt":"","text":"为什么要分组管理当我们 body 中代码越来越多，会显得很臃肿，不易读取，那么我们可以将其每个 独立 的部分 提取 出来 提取子视图 将鼠标移动到 HStack分布视图 上，按住 command，选中 Extract SubView，这个操作是提取子视图 点击后我们就可以把标题提取出来了 系统自动创建了一个 ExtractedView()，这个就是还未重新命名的 定价方案视图 为了方便定位代码，我们对每个子视图命名，点击鼠标右键，选择Refactor，选择Rename 命名为 priceView，最好遵循 【驼峰命名法】 代码折叠Xcode -&gt; Preference -&gt; Text Editing -&gt; Code folding ribbon","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}],"tags":[{"name":"SwiftUI-学习篇","slug":"SwiftUI-学习篇","permalink":"https://www.bboyzj.cn/tags/SwiftUI-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}]},{"title":"SwiftUI学习04：VStack,HStack,ZStack视图排列使用","slug":"SwiftUI课程/SwiftUI学习04：VStack-HStack-ZStack视图排列使用","date":"2023-02-19T13:38:18.000Z","updated":"2023-03-08T22:29:31.031Z","comments":true,"path":"2023/02/19/SwiftUI课程/SwiftUI学习04：VStack-HStack-ZStack视图排列使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/19/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A004%EF%BC%9AVStack-HStack-ZStack%E8%A7%86%E5%9B%BE%E6%8E%92%E5%88%97%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言在一个页面中，经常会看到许多UI控件，在不同的位置摆放，在 SwiftUI 中分为： VStack垂直摆放 HStack水平摆放 ZStack掩盖摆放 三种摆放图示 创建一个新工程Stack，了解不同分布 垂直分布 12345678910111213141516171819202122232425// 垂直分布VStack(alignment: .center)&#123; // 居中对齐 Text(&quot;View1&quot;) .font(.system(size: 20)) .foregroundColor(.blue) .frame(width: 300, height: 100, alignment: .center) .background(Color.green) .padding(10) Text(&quot;View2&quot;) .font(.system(size: 20)) .foregroundColor(.blue) .frame(width: 300, height: 100, alignment: .center) .background(Color.green) .padding(10) Text(&quot;View3&quot;) .font(.system(size: 20)) .foregroundColor(.blue) .frame(width: 300, height: 100, alignment: .center) .background(Color.green) .padding(10)&#125; 预览视图如下： 水平分布 同理 覆盖分布 同理 写一个简单的案列案列图 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677struct ContentView: View &#123; var body: some View &#123; // 定价方案 HStack &#123; // 连续包月 VStack &#123; ZStack &#123; VStack()&#123; Text(&quot;连续包月&quot;) .font(.system(size: 17)) .fontWeight(.bold) .foregroundColor(Color(red: 190/255, green: 188/255, blue: 184/255)) Text(&quot;¥18&quot;) .fontWeight(.bold) .font(.system(size: 30)) .foregroundColor(Color(red: 239 / 255, green: 129 / 255, blue: 112 / 255)) &#125; // 最大宽度自适应 .frame(minWidth: 0, maxWidth: .infinity, minHeight: 90) .padding(20) .background(Color(&quot;faf7f3&quot;)) .cornerRadius(4) .overlay( // 覆盖 RoundedRectangle(cornerRadius: 4).stroke(Color(red: 202 / 255, green: 169 / 255, blue: 106 / 255),lineWidth: 2)) // 首月特惠 Text(&quot;首月特惠&quot;) .font(.system(size: 14)) .fontWeight(.bold) .foregroundColor(.white) .background(Color(red: 202 / 255, green: 169 / 255, blue: 106 / 255)) .cornerRadius(4) .padding(10) .offset(x:0,y:-65) &#125; &#125; //1个月 VStack &#123; Text(&quot;1个月&quot;) .fontWeight(.bold) .font(.system(size: 17)) .foregroundColor(Color(red: 190 / 255, green: 188 / 255, blue: 184 / 255)) Text(&quot;¥30&quot;) .fontWeight(.bold) .font(.system(size: 30)) .foregroundColor(Color(red: 239 / 255, green: 129 / 255, blue: 112 / 255)) &#125; .frame(minWidth: 0, maxWidth: .infinity, minHeight: 90) .padding(20) .background(Color(red: 244 / 255, green: 244 / 255, blue: 245 / 255)) .cornerRadius(10) // 12个月 VStack()&#123; Text(&quot;12个月&quot;) .font(.system(size: 17)) .fontWeight(.bold) .foregroundColor(Color(red: 190/255, green: 188/255, blue: 184/255)) Text(&quot;¥288&quot;) .fontWeight(.bold) .font(.system(size: 30)) .foregroundColor(Color(red: 239 / 255, green: 129 / 255, blue: 112 / 255)) Text(&quot;¥19.00/月&quot;) .fontWeight(.bold) .font(.system(size: 17)) .foregroundColor(Color(red: 190 / 255, green: 188 / 255, blue: 184 / 255)) &#125; .frame(minWidth: 0, maxWidth: .infinity, minHeight: 90) .padding(20) .background(Color(red: 244 / 255, green: 244 / 255, blue: 245 / 255)) .cornerRadius(10) &#125; .padding(10) &#125;&#125; .padding ： 设置边距 command + VStack&#x2F;HStack&#x2F;ZStack 可以在最外层嵌入 分布 Embed in VStack：嵌入水平分布 要调整位置，我们可以使用 .offset 修饰符，设置偏移量 X，Y分别对应坐标轴位置，X轴正数为右移，负数为左移，Y轴正数下移，负数上移。 .frame(minWidth: 0, maxWidth: .infinity, minHeight: 90) 最小宽度0，.infinity 最大宽度自适应 swiftUI 修饰符有顺序，先切圆角，再加边框 1.overlay(RoundedRectangle(cornerRadius: 6).stroke(Color(red: 202 / 255, green: 169 / 255, blue: 106 / 255),lineWidth: 2)) RoundedRectangle()：圆角矩形stroke：描边lineWidth：线宽cornerRadius：圆角度数 导入色彩的办法点击Assets，在底部点击“+”按钮，挑选 New Color Set，选择 Show Color Panel","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}],"tags":[{"name":"SwiftUI-学习篇","slug":"SwiftUI-学习篇","permalink":"https://www.bboyzj.cn/tags/SwiftUI-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}]},{"title":"SwiftUI学习03：Text文字和Image图片的使用","slug":"SwiftUI课程/SwiftUI学习03：Text文字和Image图片的使用","date":"2023-02-19T11:44:43.000Z","updated":"2023-03-08T22:26:52.105Z","comments":true,"path":"2023/02/19/SwiftUI课程/SwiftUI学习03：Text文字和Image图片的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/19/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A003%EF%BC%9AText%E6%96%87%E5%AD%97%E5%92%8CImage%E5%9B%BE%E7%89%87%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Text 文字的使用 在ContentView.swift文件中，我们实现如下代码 12345678910111213141516171819202122232425struct ContentView: View &#123; var body: some View &#123; // 初始化一个文本 Text(&quot;Hello World&quot;) // 背景颜色 .background(Color.red) // 设置字重：字体加粗 .fontWeight(.bold) // 字体大小 .font(.system(size: 20)) // 字体颜色 .foregroundColor(.blue) // 阴影 .shadow(color: .black, radius: 1) // 边距 .padding(10) &#125;&#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; ContentView() &#125;&#125; 更多参数设置如下: Image 图片的使用在 Assets.xcassets 文件中，可以导入 本地图片素材，也可以设置颜色 上面我们导入了一张图片，回到代码： 12345678910111213141516171819// 初始化一张图片Image(&quot;test&quot;) // 缩放图片（拉伸缩放） .resizable() // 等比例缩放 .scaledToFit() // 调整图片尺寸 .frame(width: 300) // 裁剪图片 .clipShape(Circle()) // 透明度 .opacity(0.8) // 覆盖一层视图 .overlay( Text(&quot;编辑&quot;) .fontWeight(.bold) .font(.system(size: 20)) .foregroundColor(.white) ) 最后在预览中呈现的样式如下： 知识点：Image除了可以展示 本地图片，还可以展示 网络图片 和 系统图标 官方符号Apple 官方提供了 3000 个新符号供开发者使用，开发者几乎无需自己收集常用图标 Apple官方图标 使用方式 123// 使用系统图标Image(systemName: &quot;square.and.arrow.up&quot;) .font(.system(size: 50)) 安全区我们看到模拟器预留了 顶栏 和 底栏 两块区域，这是 安全区域 如果想忽略安全区域，把视图撑开整个屏幕，通过设置 .edgesIgnoringSafeArea 修饰： 1.edgesIgnoringSafeArea(.all)","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}],"tags":[{"name":"SwiftUI-学习篇","slug":"SwiftUI-学习篇","permalink":"https://www.bboyzj.cn/tags/SwiftUI-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}]},{"title":"SwiftUI学习02：搭建一个新项目","slug":"SwiftUI课程/SwiftUI学习02：搭建一个新项目","date":"2023-02-19T11:03:33.000Z","updated":"2023-03-08T22:24:33.708Z","comments":true,"path":"2023/02/19/SwiftUI课程/SwiftUI学习02：搭建一个新项目/","link":"","permalink":"https://www.bboyzj.cn/2023/02/19/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A002%EF%BC%9A%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"前言在本章中，你将学会如何使用Xcode创建一个SwiftUI项目 创建你的第一个SwiftUI项目首先，启动Xcode，在顶栏选择 File -&gt; New -&gt; Project 在 iOS 类目下，选择 App，选择 Next，继续下一个屏幕 choose options for your new project：完善项目的基本信息 Product：项目名称，最好是英文 Team：开发者账号（个人、公司、企业） Organization Name：组织名称 Organization Identifier：应用程序的唯一标识符，反向DNS表示法，电子邮件反地址或公司地址颠倒 Bundle Identifier：组织唯一标识.项目名称 Interface：用户界面，SwiftUI 或 Storyboard Language：语言，Swift 或 Objective-C Use Core Data：面向对象的数据库，不选 Include Tests：测试，不选 点击 Next ，选择文件保存目录后，我们成功创建一个SwiftUI项目 默认情况下，Xcode自动根据 ContentView.swift 内容生成 SwiftUI 示例代码 可以根据顶部路径切换模拟器型号，然后单击预览区 Resume 按钮，查看实时预览效果 Xcode界面 中间：主编辑窗口，分两部分 代码区 预览区 左侧：文件导航器 右侧：实用程序窗口 下面：调试器，控制台输出 预览区 Live ： 模拟一个实际的真实互动情况 Selectable： 选择模式，选中画面内容 找到 对应的代码 Variants： 快读比较一下不同的情景，但并不生效 Color Scheme Variants：颜色方案 Light（浅色） Dark（深色）Orientation Variants：方向 竖向（Portrait） 横向（Landscape）Dynamic Type Variants：动态类型 使用者选择的字体大小（从最小的XS -&gt; 最大的 AX5） Device Setting ： 设置上面的3个不同情景并生效 Preview on Device： 在具体的设备预览 App入口123456789101112// @main 代表的就是这个App的入口@mainstruct FirstDemoApp: App &#123; // body属性设计一个Scene的类型 var body: some Scene &#123; // 视窗 WindowGroup &#123; // 最底层的画面 ContentView() &#125; &#125;&#125; 一个App基本的架构就是，App里面会有一个 视窗Scene，视窗Scene 里面会有 View，你只要设定一个遵循 Protocol 规范的类型，就可以拿到对应的功能，App需要知道视窗Scene是什么，scene需要知道view Assets包在这个 target 中的档案，如图片、icon、color Preview Content存放一些开发时用到的 图片和资料等，在打包的时候回自动被排除。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}],"tags":[{"name":"SwiftUI-学习篇","slug":"SwiftUI-学习篇","permalink":"https://www.bboyzj.cn/tags/SwiftUI-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}]},{"title":"SwiftUI学习01：Swift入门","slug":"SwiftUI课程/SwiftUI学习01：SwiftUI入门","date":"2023-02-19T07:05:11.000Z","updated":"2023-03-08T22:19:55.868Z","comments":true,"path":"2023/02/19/SwiftUI课程/SwiftUI学习01：SwiftUI入门/","link":"","permalink":"https://www.bboyzj.cn/2023/02/19/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A001%EF%BC%9ASwiftUI%E5%85%A5%E9%97%A8/","excerpt":"","text":"什么是SwiftUI？ SwiftUI 它是一个用来设计所有 Apple所有平台（如：Watch应用、Apple TV、Mac应用）App 的 framework SwiftUI 支持 面向对象编程，也面向 函数式编程 或 面向协议编程。 swiftUI特点 framework：帮我们快速的架构UI、处理使用者互动和资料管理 宣告式语法（declarative）：简洁、好上手、快速开发 支持所有 Apple 平台：iOS 14.0+、iPad 14.0+、macOS 10.15+、Mac Catelyst 14.0+、tvOS 14.0+、watchOS 6.0+ 6个平台 注：它有版本的限制，因为是一个相对新的framework，最少需要iOS14才能支持","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}],"tags":[{"name":"SwiftUI-学习篇","slug":"SwiftUI-学习篇","permalink":"https://www.bboyzj.cn/tags/SwiftUI-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://www.bboyzj.cn/categories/SwiftUI/"}]},{"title":"C语言学习19：数据类型","slug":"C学习/C语言学习19：数据类型","date":"2023-02-18T08:41:06.000Z","updated":"2023-03-01T13:51:51.657Z","comments":true,"path":"2023/02/18/C学习/C语言学习19：数据类型/","link":"","permalink":"https://www.bboyzj.cn/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A019%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"数据类型 基本类型 数值类型： 整数类型：短整型 short、整型 int、长整型 long 浮点类型：单精度型 float、双精度型 double 字符类型：char 构造类型 数组 结构体：struct 共用体：union 枚举类型：enum 指针类型 空类型 void 注意： c 语言中没有字符串类型，使用 字符数组char[] 表示字符串 不同操作系统，数据类型 占用字节长度不一样 基本数据类型 sizeof运算符 用于 获取数据类型或表达式的长度，长度以 字节 表示 signed 和 unsigned signed：有符号，第一个位代表正负，剩余代表大小。 unsigned：无符号，所有位都为大小，没有负数。 基本数据类型的取值范围 比特位 CPU能读懂的最小单位是：比特位，bit，b。每个比特位只能存放二进制数，即0和1。 字节 内存机构最小寻址单位：字节，Byte，B 1Byte &#x3D; 8 bit","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习18：常量","slug":"C学习/C语言学习18：常量","date":"2023-02-18T08:14:14.000Z","updated":"2023-03-01T13:51:44.295Z","comments":true,"path":"2023/02/18/C学习/C语言学习18：常量/","link":"","permalink":"https://www.bboyzj.cn/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A018%EF%BC%9A%E5%B8%B8%E9%87%8F/","excerpt":"","text":"C 常量 常量是固定值，在执行期间不会改变，这些固定值，又叫做 字面量 常量可以是任何的 基本数据类型。 常量 就是常规的变量，只不过在定义后不能进行修改。 定义常量 使用 #define 预处理器 #define LENGTH 10 使用 const 关键字 const type variable = value;","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习17：typedef","slug":"C学习/C语言学习17：typedef","date":"2023-02-18T05:58:49.000Z","updated":"2023-03-01T13:51:40.382Z","comments":true,"path":"2023/02/18/C学习/C语言学习17：typedef/","link":"","permalink":"https://www.bboyzj.cn/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A017%EF%BC%9Atypedef/","excerpt":"","text":"typedefC 语言提供了关键字 typedef ，可以用它为 类型 取一个新的名字。 例如：为无符号字符定义一个名称 UChar typedef unsigned char UChar; 例如：为结构体定义一个名称 MyBook 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;string.h&gt;typedef struct Book&#123; char title[50]; int book_id;&#125;MyBook;int main(int argc, const char * argv[]) &#123; // typedef前// struct Book myBook; // typedef后 MyBook book; strcpy(book.title,&quot;ZJ&quot;); book.book_id = 12; printf(&quot;标题：%s\\n&quot;,book.title); printf(&quot;书 ID:%d\\n&quot;,book.book_id); return 0;&#125; 当上面的代码 编译和运行 时，产生的结果 123标题：ZJ书 ID:12Program ended with exit code: 0 typedef 和 #define 区别 typedef 仅限于为 类型 定义名称；#define 不仅可以为 类型 定义别买，也可以为 数值 定义 typedef由编译器 执行 解释；#define由编译器 预处理 处理","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习16：enum(枚举)","slug":"C学习/C语言学习16：enum-枚举","date":"2023-02-18T05:58:37.000Z","updated":"2023-03-01T13:51:36.445Z","comments":true,"path":"2023/02/18/C学习/C语言学习16：enum-枚举/","link":"","permalink":"https://www.bboyzj.cn/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A016%EF%BC%9Aenum-%E6%9E%9A%E4%B8%BE/","excerpt":"","text":"enum(枚举)枚举在 C 中是一种 基本数据类型，它可以让数据 更简洁、更易读 枚举语法定义格式： enum 枚举名 &#123;枚举元素1,枚举元素2,...&#125; 一个星期的例子： 123enum DAY&#123; MON=1,TUE,WED,THU,FRI,SAT,SUN&#125;; 枚举变量的定义 先定义枚举类型，再定义枚举变量 123456789101112// 定义枚举类型enum DAY&#123; MON=1,TUE,WED,THU,FRI,SAT,SUN&#125;;int main(int argc, const char * argv[]) &#123; // 定义枚举变量 enum DAY day; printf(&quot;%d\\n&quot;,day=WED); return 0;&#125; 定义枚举类型的同时，定义枚举变量 1234// 定义枚举类型和变量enum DAY&#123; MON=1,TUE,WED,THU,FRI,SAT,SUN&#125;day; 省略枚举名称，直接定义枚举变量 1234// 省略枚举名称，直接定义枚举变量enum &#123; MON=1,TUE,WED,THU,FRI,SAT,SUN&#125;day; 实例，遍历枚举 1234567891011// 省略枚举名称，直接定义枚举变量enum &#123; MON=1,TUE,WED,THU,FRI,SAT,SUN&#125;day;int main(int argc, const char * argv[]) &#123; for (day = MON; day&lt;=SUN; day++) &#123; printf(&quot;%d\\n&quot;,day); &#125; return 0;&#125; 当上面的代码 编译和运行 时，产生结果 123456781234567Program ended with exit code: 0","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习15：递归","slug":"C学习/C语言学习15：递归","date":"2023-02-18T05:58:13.000Z","updated":"2023-03-01T13:51:32.643Z","comments":true,"path":"2023/02/18/C学习/C语言学习15：递归/","link":"","permalink":"https://www.bboyzj.cn/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A015%EF%BC%9A%E9%80%92%E5%BD%92/","excerpt":"","text":"递归递归指： 函数中使用函数自身的方法 C 语言中支持递归，即 一个函数可以调用自身，在使用递归时，程序员要注意函数的 退出条件，否则会进入死循环 数的阶乘1234567891011121314double factorial(unsigned int i)&#123; if (i&lt;=1)&#123; return 1; &#125; return i * factorial(i-1);&#125;int main(int argc, const char * argv[]) &#123; int i = 5; printf(&quot;%d 的阶乘是：%f\\n&quot;,i,factorial(i)); return 0;&#125; 当上面的代码被 编译和运行 时，产生的结果： 125 的阶乘是：120.000000Program ended with exit code: 0 斐波那契额数列当前数是前两个数之和 12345678910111213141516171819int fibonaci(int i)&#123; if (i == 0) &#123; return 0; &#125; if (i == 1) &#123; return 1; &#125; return fibonaci(i-1) + fibonaci(i-2);&#125;int main(int argc, const char * argv[]) &#123; for (int i = 0; i &lt; 10; i++)&#123; printf(&quot;%d\\t\\n&quot;, fibonaci(i)); &#125; return 0;&#125; 当上面的代码 编译和运行时，产生的结果： 12345678910110 1 1 2 3 5 8 13 21 34 Program ended with exit code: 0","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"OCRunloop02：Runloop线程保活","slug":"OCRuntime&Runloop/OCRunloop02：Runloop线程保活","date":"2023-02-16T09:17:17.000Z","updated":"2023-02-16T11:44:13.032Z","comments":true,"path":"2023/02/16/OCRuntime&Runloop/OCRunloop02：Runloop线程保活/","link":"","permalink":"https://www.bboyzj.cn/2023/02/16/OCRuntime&Runloop/OCRunloop02%EF%BC%9ARunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB/","excerpt":"","text":"创建线程类12345678910111213141516171819202122232425#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface ZJThread : NSThread@endNS_ASSUME_NONNULL_END//// ZJThread.m// Runloop-线程保活//// Created by Mac on 2023/2/16.//#import &quot;ZJThread.h&quot;@implementation ZJThread- (void)dealloc&#123; NSLog(@&quot;%s&quot;,__func__);&#125;@end 12345678910111213141516171819202122232425262728#import &quot;NextViewController.h&quot;@interface NextViewController ()@end@implementation NextViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // NSThread 频繁创建线程 ZJThread * thread = [[ZJThread alloc]initWithTarget:self selector:@selector(test) object:nil]; [thread start];&#125;// 子线程需要执行的任务- (void)test&#123; NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]);&#125;- (void)dealloc&#123; NSLog(@&quot;%s&quot;,__func__);&#125;@end Run 起来之后 我们发现每次点击，都会去执行任务: ZJThread 频繁创建线程 12342023-02-16 19:06:19.752652+0800 Runloop-频繁创建线程[16937:1026536] -[NextViewController test] &lt;ZJThread: 0x28150ce80&gt;&#123;number = 6, name = (null)&#125;2023-02-16 19:06:19.753833+0800 Runloop-频繁创建线程[16937:1026536] -[ZJThread dealloc]2023-02-16 19:06:20.309051+0800 Runloop-频繁创建线程[16937:1026537] -[NextViewController test] &lt;ZJThread: 0x28152ca00&gt;&#123;number = 7, name = (null)&#125;2023-02-16 19:06:20.309697+0800 Runloop-频繁创建线程[16937:1026537] -[ZJThread dealloc] 可以看到任务一完成，线程就释放，并且这样 频繁的创建线程，很消耗资源 我们可以用Runloop来延长线程的生命周期，不让线程挂掉12345678// 子线程需要执行的任务- (void)test&#123; NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]); [[NSRunLoop currentRunLoop] run]; NSLog(@&quot;%s ----end----&quot;, __func__);&#125; 运行一下： 12345678// 子线程需要执行的任务- (void)test&#123; NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]); [[NSRunLoop currentRunLoop] run]; NSLog(@&quot;%s ----end----&quot;, __func__);&#125; 结果：发现线程执行完成任务还是会结束线程 [ZJThread dealloc]，这是因为 run 方法底层调用的是 - (BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate; 方法，这个方法会把 runloop 加入到 NSDefaultRunLoopMode 模式下，而 Model 下没有任何 Source0，Source1，Timer，Observe，Runloop，会立马退出，所以我们需要往 Runloop 中添加任务 往 runloop 中添加任务，任何任务都行1234567891011// 子线程需要执行的任务- (void)test&#123; NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]); NSLog(@&quot;🏌🏌🏌🏌🏌🏌🏌🏀🏀🏀🏅🏅🏅&quot;); // 往RunLoop里面添加Source\\Timer\\Observer [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] run]; NSLog(@&quot;%s ----end----&quot;, __func__);&#125; Run： 122023-02-16 19:15:08.021488+0800 Runloop-频繁创建线程[16991:1030153] -[NextViewController test] &lt;ZJThread: 0x281b95a40&gt;&#123;number = 22, name = (null)&#125;2023-02-16 19:15:08.021835+0800 Runloop-频繁创建线程[16991:1030153] 🏌🏌🏌🏌🏌🏌🏌🏀🏀🏀🏅🏅🏅 在运行线程就不会执行完任务就挂掉，而是执行完任务就休眠 每点击一次屏幕，都是创建了 ZJThread * thread = [[ZJThread alloc]initWithTarget:self selector:@selector(test) object:nil]; 经过 [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode]; 和 [[NSRunLoop currentRunLoop] run]; 线程进入休眠，导致我们没办法唤醒线程和执行线程任务，继续修改 把 thread 改成局部变量1self.thread = [[ZJThread alloc] initWithTarget:self selector:@selector(run) object:nil]; 上面的写法：self 会引用 thread，thread 会引用 self，造成循环引用 用block实现1234567891011121314151617181920- (void)viewDidLoad &#123; [super viewDidLoad]; //如果使用如下方式创建thread，self会引用thread，thread会引用self，会造成循环引用。 //[[MJThread alloc] initWithTarget:self selector:@selector(run) object:nil]; self.thread = [[MJThread alloc] initWithBlock:^&#123; NSLog(@&quot;%@----begin----&quot;, [NSThread currentThread]); // 往RunLoop里面添加Source\\Timer\\Observer [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode]; //线程会一直阻塞这这一行，永远不会销毁 [[NSRunLoop currentRunLoop] run]; //当把NSRunLoop停掉之后，代码就会从下一行往下走，这时候任务执行完成，线程该死的时候就会死了。 NSLog(@&quot;%@----end----&quot;, [NSThread currentThread]); &#125;]; [self.thread start];&#125; run 方法：Runloop 无法停止，它专门用于开启一个永不销毁的线程 替换 run1[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; Runloop 的启动和退出启动： run：无条件 runUntilDate：设定时间限制 runMode:beforeDate：在特定模式下 停止： CFRunLoopStop(CFRunLoopGetCurrent()) 实现线程保活ZJThread.h 中： 1234567#import &quot;ZJThread.h&quot;@implementation ZJThread- (void)dealloc&#123; NSLog(@&quot;%s&quot;,__func__);&#125;@end NextVC 中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#import &quot;NextViewController.h&quot;#import &quot;ZJThread.h&quot;@interface NextViewController ()@property (nonatomic,strong)ZJThread * thread;@property (nonatomic,assign)BOOL isStop;@property (nonatomic,strong)UIButton * stopBtn;@end@implementation NextViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; // 停止按钮 [self.view addSubview:self.stopBtn]; /* 创建线程有两种方式: target：会造成循环引用 block：不会造成循环引用 */ [self blockCreatThread];&#125;- (void)blockCreatThread&#123; __weak typeof(self) weakSelf = self; self.isStop = NO; // 未停止 self.thread = [[ZJThread alloc] initWithBlock:^&#123; NSLog(@&quot;%@---begin---&quot;,[NSThread currentThread]); // 往runloop中添加Source\\Timer\\Observer [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode]; while (weakSelf &amp;&amp; !weakSelf.isStop) &#123; [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; &#125; NSLog(@&quot;%@---end---&quot;, [NSThread currentThread]); /* run方法无法停止，它专门用于开启一个永不销毁的线程 [[NSRunLoop currentRunLoop] run]; */ &#125;]; [self.thread start];&#125;// 点击- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];&#125;// 子线程要执行的任务- (void)test&#123; NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]); NSLog(@&quot;🏌🏌🏌🏌🏌🏌🏌🏀🏀🏀🏅🏅🏅&quot;);&#125;// 停止- (void)stop&#123; if (!self.thread) return; // 停止子线程 [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:YES]; &#125;- (void)stopThread&#123; // 标记停止 self.isStop = YES; // 停止 CFRunLoopStop(CFRunLoopGetCurrent()); self.thread = nil; NSLog(@&quot;%@---end---&quot;, [NSThread currentThread]);&#125;- (void)dealloc&#123; NSLog(@&quot;%s&quot;,__func__); // 停止子线程 [self stop];&#125;//- (UIButton *)stopBtn&#123; if (!_stopBtn) &#123; _stopBtn = [[UIButton alloc] initWithFrame:CGRectMake(100, 100, 100, 100)]; _stopBtn.backgroundColor = [UIColor greenColor]; [_stopBtn setTitle:@&quot;stop&quot; forState:UIControlStateNormal]; [_stopBtn setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal]; [_stopBtn addTarget:self action:@selector(stop) forControlEvents:UIControlEventTouchUpInside]; &#125; return _stopBtn;&#125;@end","categories":[{"name":"OC-Runloop探索篇","slug":"OC-Runloop探索篇","permalink":"https://www.bboyzj.cn/categories/OC-Runloop%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-Runloop探索篇","slug":"OC-Runloop探索篇","permalink":"https://www.bboyzj.cn/categories/OC-Runloop%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"Flutter面试题：Flutter","slug":"面试题/Flutter面试题：总结","date":"2023-02-15T17:21:00.000Z","updated":"2023-03-08T21:39:32.273Z","comments":true,"path":"2023/02/16/面试题/Flutter面试题：总结/","link":"","permalink":"https://www.bboyzj.cn/2023/02/16/%E9%9D%A2%E8%AF%95%E9%A2%98/Flutter%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%80%BB%E7%BB%93/","excerpt":"","text":"什么是flutter？原理是什么？ flutter 是 google 推出并 开源的移动应用开发框架，通过 dart 语言开发APP，一套代码可以同时运行在 iOS 和 Android 平台。 flutter 底层使用 skia 作为 2D渲染引擎，通过自己的渲染引擎来 绘制widget(组件)，dart 语言借鉴了 Java 和 JavaScript 同时加入了一些 现代编程语言 特性。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://www.bboyzj.cn/categories/Flutter/"}],"tags":[{"name":"Flutter-面试题","slug":"Flutter-面试题","permalink":"https://www.bboyzj.cn/tags/Flutter-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"Flutter","slug":"Flutter","permalink":"https://www.bboyzj.cn/categories/Flutter/"}]},{"title":"C语言学习14：内存管理","slug":"C学习/C语言学习14：内存管理","date":"2023-02-14T16:14:03.000Z","updated":"2023-03-01T13:51:28.902Z","comments":true,"path":"2023/02/15/C学习/C语言学习14：内存管理/","link":"","permalink":"https://www.bboyzj.cn/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A014%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"内存管理C 语言为内存 分配和管理 提供了几个函数，这些函数都在 &lt;stdlib.h&gt; 头文件中 动态内存分配 全局变量 分配在内存中的 静态存储区 局部变量 分配在内存中的 动态存储区，存放在 栈（stack） 区。 临时数据 分配在内存中的 动态存储区，存放在 堆（heap） 区 用 malloc 函数开辟动态存储区 void * malloc(unsigned int size); 在内存动态存储区分配一个长度为size的连续空间，形参size类型为无符号整型 malloc(100)：开辟100字节的临时分配域，其值为第一个字节的地址 用 calloc 函数开辟动态存储区 void * calloc(unsigned n,unsigned int size); 内存中分配n个长度为size的连续空间 用 recalloc 函数重新分配动态存储区 void * recalloc(void *p,unsigned int size); 如果已经用 malloc 和 calloc 函数获取了，想改变大小，用 recalloc 重新分配 recalloc(p,50); &#x2F;&#x2F; 将p所指向的已分配的动态内存改为50字节 用 free 函数释放动态存储区 void free(void *p); 其作用是释放指针变量p所指向的动态空间。","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习13：文件","slug":"C学习/C语言学习13：文件","date":"2023-02-14T16:13:49.000Z","updated":"2023-03-01T13:51:25.322Z","comments":true,"path":"2023/02/15/C学习/C语言学习13：文件/","link":"","permalink":"https://www.bboyzj.cn/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A013%EF%BC%9A%E6%96%87%E4%BB%B6/","excerpt":"","text":"打开文件FILE * fopen(const char * filename,const * mode); filename:文件名mode：样式 关闭文件int fclose(int c,FILE *fp); fclose()函数返回零：关闭成功fclose()韩式返回EOF：关闭失败 注：EOF 是一个定义在头文件&lt;stdio.h&gt;中的常量 写入文件 把字符写入到流中 int fputc(char c,FILE *fp); 把字符串写入到流中 int fputs(const char *s,FILE *fp); 或 int fprintf(FILE *fp,const char *format,...); 注：请确保您有可用的tmp目录 读取文件 读取一个字符 int fgetc(FILE *fp); 读取 字符串 char * fgets(char *buf,int n,FILE *fp); 读取 n-1 个字符，读取到的字符串复制到缓冲区buf，并追加一个 null 字符；如果读取到 \\n或EOF 结束 或 int fscanf(FILE *fp, const char *format, ...); 读取字符串，遇到 空格或换行符 停止 二进制 I&#x2F;O 函数二进制输入和输出 12345size_t fread(void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file); size_t fwrite(const void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file);","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习12：预处理器","slug":"C学习/C语言学习12：预处理器","date":"2023-02-14T16:13:38.000Z","updated":"2023-03-01T13:51:21.761Z","comments":true,"path":"2023/02/15/C学习/C语言学习12：预处理器/","link":"","permalink":"https://www.bboyzj.cn/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A012%EF%BC%9A%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/","excerpt":"","text":"C 预处理器预处理器 不是 编译器的组成部分，是编译过程的一个单独的步骤。简言之，C预处理器是一个 文本替换工具，它会指示编译器在实际编译前完成所需的 预处理；我们把 C 预处理器(C Preprocessor) 简写成(CPP) 所有的预处理器都是以 # 开头，非空字符，为增加可读性，从第一列开始，下面列出了所有的预处理命令： 预处理实例#define MAX_LENGTH 20 这个指令告诉 CPP 把所有的 MAX_LENGTH 定义为 20，使用 #define 定义常量来增强可读性 12#include &lt;stdio,h&gt;#include &quot;myheader.h&quot; 这个指令告诉 CPP 从 系统库 中读取 stdio.h，并添加到 当前源文件 中；下一行告诉 CPP 从 本地目录 中获取 myheader.h，并添加到 当前源文件中 12#undef FILE_SIZE#define FILE_SIZE 30 这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 30 123#ifndef MESSAGE #define MESSAGE &quot;You wish!&quot;#endif 这个指令告诉 CPP 只要当 MESSAGE 未定义时，才定义 MESSAGE 123#ifdef DEBUG /*debug here*/#endif 这个指令告诉 CPP ，如果定义了 DEBUG,则执行语句。 预定义宏ANSI C 定义了许多宏 1234567891011#include &lt;stdio.h&gt; main()&#123; printf(&quot;File :%s\\n&quot;, __FILE__ ); printf(&quot;Date :%s\\n&quot;, __DATE__ ); printf(&quot;Time :%s\\n&quot;, __TIME__ ); printf(&quot;Line :%d\\n&quot;, __LINE__ ); printf(&quot;ANSI :%d\\n&quot;, __STDC__ ); &#125; 当上面的代码在 main.c 中编译和执行时，它会产生下列结果： 123456File :/Users/mac/Desktop/预处理器/预处理器/main.mDate :Feb 18 2023Time :13:22:02Line :16ANSI :1Program ended with exit code: 0 预处理器运算符 宏延续运算符 () 一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用 宏延续运算符（\\）。例如： 12#define msg(a,b) \\ printf(#a &quot;and&quot; #b &quot;\\n&quot;) 字符串常量化运算符（#） 在宏定义中，把一个 宏参数 转为 字符串常量 在 main.c 中 编译和运行上面的代码，得到下面的结果 11and&#x27;a&#x27; 标记粘贴运算符（##） 宏定义内标记粘贴运算符（##）会合并两个参数 参数化宏#define square(x) (x*x) 12#define max(x,y) \\ printf(&quot;%d\\n&quot;,x&gt;y?x:y);","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习11：基本语法","slug":"C学习/C语言学习11：基本语法","date":"2023-02-14T16:13:29.000Z","updated":"2023-03-01T13:51:18.607Z","comments":true,"path":"2023/02/15/C学习/C语言学习11：基本语法/","link":"","permalink":"https://www.bboyzj.cn/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A011%EF%BC%9A%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"C 的令牌（Token）C 程序由各种令牌组成，令牌可以是 关键字、常量、字符串或一个符号。 分号;分号是语句 结束符 注释 单行注释 // 单行注释 多行注释 123456/* 单行注释*//* 多行注释 多行注释 ...*/ 关键字 auto：声明自动变量 const：定义常量，如果一个变量被const修饰，那么它的值就不能被改变 extern：声明变量或函数可以被其他文件使用 register：声明寄存器变量 typedef：给数据类型起别名","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习10：共用体","slug":"C学习/C语言学习10：共用体","date":"2023-02-14T16:13:03.000Z","updated":"2023-03-01T13:51:14.889Z","comments":true,"path":"2023/02/15/C学习/C语言学习10：共用体/","link":"","permalink":"https://www.bboyzj.cn/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A010%EF%BC%9A%E5%85%B1%E7%94%A8%E4%BD%93/","excerpt":"","text":"共用体共用体 是一种特殊的数据类型，允许您在 相同的内存位置存储不同的数据类型。 定义共用体必须用 union 语句，方式与结构体类型。 12345union MyData&#123; int i; float j; char k[5];&#125;data; 当上面的代码被 编译和运行时，产生的结果 12内存占用：8Program ended with exit code: 0 说明：共用体占用的内存应足够存储共用体中最大的成员，因为内存对齐，4的整数倍&#x3D;8 访问共用体我们使用 成员访问运算符(.)。 1234567891011121314int main(int argc, const char * argv[]) &#123; union MyData data; printf(&quot;内存占用：%lu\\n&quot;,sizeof(data)); data.i = 1; data.j = 3.14; strcpy(data.k, &quot;ZJ&quot;); printf(&quot;i:%d\\n&quot;,data.i); printf(&quot;j:%f\\n&quot;,data.j); printf(&quot;k:%s\\n&quot;,data.k); return 0;&#125; 当上面的代码编译和运行是，产生的结果： 12345内存占用：8i:1073760858j:2.004538k:ZJProgram ended with exit code: 0","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习09：结构体","slug":"C学习/C语言学习09：结构体","date":"2023-02-14T16:12:43.000Z","updated":"2023-03-01T13:51:02.563Z","comments":true,"path":"2023/02/15/C学习/C语言学习09：结构体/","link":"","permalink":"https://www.bboyzj.cn/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A009%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"","text":"声明结构体1234struct st&#123; int a; char ch[4];&#125; 定义结构体1234struct st&#123; int a; char ch[4];&#125;t1; 注：t1：结构体变量名 初始化结构体1struct test t1 = &#123;5&#125;; 结构体数组1struct test arr[3] = &#123;1,2,3&#125;; 结构体指针struct 结构体名 *变量名； 12345678910111213141516#include &lt;stdio.h&gt;struct test&#123; int a; char c; char arr[5];&#125;t1;int main(int argc, const char * argv[]) &#123; // 初始化结构体 struct test t1 = &#123;.a=1,.c=&#x27;a&#x27;,.arr=&quot;abc&quot;&#125;; printf(&quot;%d %c %s\\n&quot;,t1.a,t1.c,t1.arr); return 0;&#125; 结构体指针获取成员变量 (*ptr).structMenber ptr-&gt;structMenber 注：.运算符 高于 * ，所以(*ptr)括号不能少 字节对齐#pragma pack(n)：指定按照n字节对齐规则进行存储 字节对齐的原因 计算机内存以字节为单位划分，CPU通过 地址总线 来访问内存，一次能处理几个字节，地址总线就读取几个字节。32位一次读取4个字节。64位一次读取8个字节。 内存对齐原因：避免存取效率的损失 总结 结构体不占内存空间，是一个创建变量的 模板 结构体 成员变量 需要开辟内存空间","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习08：字符串","slug":"C学习/C语言学习08：字符串","date":"2023-02-14T16:07:57.000Z","updated":"2023-03-01T13:51:06.835Z","comments":true,"path":"2023/02/15/C学习/C语言学习08：字符串/","link":"","permalink":"https://www.bboyzj.cn/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A008%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串的输入和输出 scanf(格式控制,地址列表(变量前加&amp;)) printf(格式控制,地址列表) gets(字符数组) puts(字符数组) 区别： gets() 和 puts() ： 只能输入或输出一个字符串 scanf() 和 printf() ：可以输出多个字符串 字符串连接strcat(字符数组1,字符数组2) 字符串复制函数strcpy(字符数组1,字符串2或字符数组名) strncpy(字符数组1,字符串2或字符数组名,n) 字符串比较函数strcmp(字符数组1,字符串2或字符数组) 字符串长度函数strlen(字符串或字符串数组) 字符串转换大小写函数大写转小写：strlwr(字符数组) 小写转大写：strupr(字符数组)","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习07：指针","slug":"C学习/C语言学习07：指针","date":"2023-02-13T12:37:03.000Z","updated":"2023-03-01T13:50:58.640Z","comments":true,"path":"2023/02/13/C学习/C语言学习07：指针/","link":"","permalink":"https://www.bboyzj.cn/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A007%EF%BC%9A%E6%8C%87%E9%92%88/","excerpt":"","text":"定义指针变量类型名 * 指针变量名 星号 是用来指定一个 变量是指针。 什么是指针？指针 就是 内存地址，指针变量 是用来 存放内存地址的变量。 指针的声明： 12int *ip; // 一个整型的指针char *cp; // 一个字符型的指针 如何使用指针12345678910111213141516int main(int argc, const char * argv[]) &#123; int var=20; // 实际变量的声明 int *ip; // 指针变量的声明 ip = &amp;var; // 在 指针变量中存储 var 的地址 printf(&quot;var 变量的地址：%p\\n&quot;,&amp;var); /* 在指针变量中存储的地址 */ printf(&quot;ip 变量存储的地址: %p\\n&quot;,ip); /* 使用指针访问值 */ printf(&quot;*ip 变量的值: %d\\n&quot;,*ip); return 0;&#125; 当上面的代码被 编译和运行 时，产生的结果 1234var 变量的地址：0x7ff7bfeff45cip 变量存储的地址: 0x7ff7bfeff45c*ip 变量的值: 20Program ended with exit code: 0 注：&amp;取地址运算符。&amp;a是变量a的地址。 指针数组指向整数类型的指针数组 123456789101112131415161718// 常量const int MAX = 3;int main(int argc, const char * argv[]) &#123; // 数组 int var[] = &#123;10,100,200&#125;; int i,*ptr[MAX]; for (i=0; i&lt;MAX; i++) &#123; // 赋值为整数的地址 ptr[i] = &amp;var[i]; &#125; for (i=0; i&lt;MAX; i++) &#123; printf(&quot;value of var[%d]=%d\\n&quot;,i,*ptr[i]); &#125; return 0;&#125; 当上面的代码被 编译和运行 时，结果 1234value of var[0]=10value of var[1]=100value of var[2]=200Program ended with exit code: 0 指向指针的指针指向指针的指针是一个 指针链，第一个指针指向第二个指针的 地址，第二个指针指向 实际值的位置。 12345678910111213141516171819202122int main(int argc, const char * argv[]) &#123; int v; int *p1; int **p2; v=100; // 获取v的地址 p1=&amp;v; // 获取p1的地址 p2=&amp;p1; // 打印值 printf(&quot;var=%d\\n&quot;,v); printf(&quot;p1=%p\\n&quot;,p1); printf(&quot;*p1=%d\\n&quot;,*p1); printf(&quot;p2=%p\\n&quot;,p2); printf(&quot;**p1=%d\\n&quot;,**p2); return 0;&#125; 当上面的代码被 编译和运行 时，结果： 123456var=100p1=0x7ff7bfeff3bc*p1=100p2=0x7ff7bfeff3b0**p1=100Program ended with exit code: 0 传递指针给函数C 语言允许传递 指针给 函数，只需要简单的声明函数参数为指针即可 示例 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; // 函数的声明 void exchange(int *a,int *b,int *c); int a,b,c; printf(&quot;请输入 a b c:&quot;); scanf(&quot;%d,%d,%d&quot;,&amp;a,&amp;b,&amp;c); exchange(&amp;a, &amp;b, &amp;c); printf(&quot;order:%d,%d,%d\\n&quot;,a,b,c); return 0;&#125;void exchange(int *a,int *b,int *c)&#123; // 函数的声明 void swap(int *x,int *y); // 交换 if (*a &gt; *b) swap(a, b); if (*a &gt; *c) swap(a, c); if (*b &gt; *c) swap(b, c);&#125;void swap(int *x,int *y)&#123; int temp; temp = *x; *x = *y; *y = temp;&#125; 从函数中返回指针必须 声明一个返回指针的函数，C 语言不支持调用函数时，返回局部变量的地址，除非定义局部变量的 static 变量 实例 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX 5;// 函数定义int * getRandom(void)&#123; static int r[10]; for (int i=0; i&lt;MAX; i++) &#123; r[i]=rand(); printf(&quot;%d\\n&quot;,r[i]); &#125; return r;&#125;int main(int argc, const char * argv[]) &#123; int *p; p=getRandom(); for (int i=0; i&lt;MAX; i++) &#123; printf(&quot;*(p+[%d]):%d\\n&quot;,i,*(p+i)); &#125; return 0;&#125; 当上面的代码 编译和运行 时，产生的结果 12345678910111680728247524916226500739849436581144108930*(p+[0]):16807*(p+[1]):282475249*(p+[2]):1622650073*(p+[3]):984943658*(p+[4]):1144108930Program ended with exit code: 0","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习06：数组","slug":"C学习/C语言学习06：数组","date":"2023-02-13T12:36:53.000Z","updated":"2023-03-07T04:06:59.576Z","comments":true,"path":"2023/02/13/C学习/C语言学习06：数组/","link":"","permalink":"https://www.bboyzj.cn/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A006%EF%BC%9A%E6%95%B0%E7%BB%84/","excerpt":"","text":"一维数组 数组创建 type_t arr_name[const_n] type_t : 数组元素的类型 arr_name : 数组名称 const_n : 是一个常量表达式，用来执行数组的大小 数组初始化 int arr[10] &#x3D; {0}; &#x2F;&#x2F; 数组的不完全初始化 int sz &#x3D; sizeof(arr)&#x2F;sizeof(arr[0]); &#x2F;&#x2F; 计算数组的元素个数 数组在内存中的存储是连续的 123456789101112#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; // 数组不完成初始化 int arr[10] = &#123;0&#125;; int sz = sizeof(arr)/sizeof(arr[0]); for (int i=0; i&lt;sz; i++) &#123; printf(&quot;&amp;arr[%d]=%p\\n&quot;,i,&amp;arr[i]); &#125; return 0;&#125; 查看打印结果 1234567891011&amp;arr[0]=0x7ff7bfeff3c0&amp;arr[1]=0x7ff7bfeff3c4&amp;arr[2]=0x7ff7bfeff3c8&amp;arr[3]=0x7ff7bfeff3cc&amp;arr[4]=0x7ff7bfeff3d0&amp;arr[5]=0x7ff7bfeff3d4&amp;arr[6]=0x7ff7bfeff3d8&amp;arr[7]=0x7ff7bfeff3dc&amp;arr[8]=0x7ff7bfeff3e0&amp;arr[9]=0x7ff7bfeff3e4Program ended with exit code: 0 二维数组 二维数组创建 123int arr[行][列]int arr[3][4] = &#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;; 二维数组的使用 12345678910int main(int argc, const char * argv[]) &#123; int arr[3][4] = &#123;&#123;1,2,3&#125;,&#123;5,6,7,8&#125;&#125;; for (int i=0; i&lt;2; i++) &#123; for (int j=0; j&lt;2; j++) &#123; printf(&quot;%d\\n&quot;,arr[i][j]); &#125; &#125; return 0;&#125; 二维数组在内存的存储 内存是连续的 数组作为形式参数有三种方式告诉编译器将要接收一个 整型指针 形式参数是一个指针 123void myFunc(int *param)&#123; ...&#125; 形式参数是一个已定大小的数组 123void myFunc(int param[10])&#123;...&#125; 形式参数是一个未定义大小的数组 123void myFunc(int param[])&#123;...&#125; 从函数返回数组C 语言不允许返回一个完成的数组，可以通过 声明一个返回指针的函数 123int * myFunc&#123;...&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习05：函数与程序结构","slug":"C学习/C语言学习05：函数与程序结构","date":"2023-02-13T12:36:40.000Z","updated":"2023-03-01T13:50:51.098Z","comments":true,"path":"2023/02/13/C学习/C语言学习05：函数与程序结构/","link":"","permalink":"https://www.bboyzj.cn/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A005%EF%BC%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/","excerpt":"","text":"函数的声明和定义 在C语言中，函数的定义顺序是有讲究的：默认情况下，只有后面定义的函数才可以调用前面定义过的函数 如果想把函数的定义写在main函数后面，而且main函数能正常调用这些函数，那就必须在main函数的前面进行函数的声明 函数的声明： 返回值类型 函数名(参数1,参数2,…) 注：如果只有函数的声明，没有函数的定义，那么链接时会出错 多个源文件项目大，如果都放在一个.c文件源代码会非常多，因此需要创建新的.c文件存放不同的代码 1234567891011main.cint main()&#123; int c = sum(1,2); return 0;&#125;sum.cint sum(int a,int b)&#123; return a+b;&#125; include 作用 include 是 C 语言 预处理 指令之一，后面跟一个文件名，会根据文件名去查找文件，并把这个文件的内容包含到当前文件中。 include&lt;&gt; 和 include“”区别 “”：从父文件夹搜索，找不到去父的父文件夹搜索，找不到去编译器设置的inlcude路径内搜索，找不到则在系统的INCLUDE环境变量内搜索 &lt;&gt;：编译器设置的include路径内搜索，找不到则在系统的INCLUDE环境变量内搜索 头文件.h 和 源文件 .c的分工 函数的声明写在 .h 文件中 函数的定义卸载 .c 源文件中 函数的参数 形式参数 形参 在定义时编译系统不分配内存，只有在调用函数时才分配内存。调用结束内存被释放。 实际参数 实参 出现在主函数中，当函数调用时，函数把实参的值传递给函数的形参，从而实现函数间的传递。 传递的方式有两种：值传递 和 地址传递 局部变量和全局变量 局部变量：首先是一个变量，其次是这个变量在程序的 局部范围有效 书写：首字母小写 全局变量：首先是变量，其次在 定义处以下才有效 书写：首字母大写 头文件 include作用： include：把头文件里的内容原封不动的复制到引用该头文件的地方。 头文件的格式说明 123456#ifndef 头文件名 // 头文件名的格式是&quot;_头文件名_&quot;，注意要大写#define 头文件名头文件内容#endif 示例代码：头文件main.h 12345678910#ifndef _MATH_H_ // 如果没有定义main.h，则执行下面的代码。这是防止重复定义#define _MATH_H_ // 定义头文件// 下面的代码是头文件内容#include&lt;stido.h&gt; // 头文件#define ADD 1 // 宏定义extern int x; // 全局变量void swap(int a,int b); // 函数声明#endif // 表示头文件结束 内部函数和外部函数 外部函数：可以被其他源文件调用的函数 在函数声明处添加 extern关键字，可省略 内部函数：只在定义的源文件中有效 在函数的返回值类型前面添加 static关键字，也称 静态函数 练习 形参和实参 输入两个正整数m和n，求从m加到n的和（m&lt;&#x3D;n），并输出 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;int sum(int a,int b);void swap(int *a,int *b);int main(int argc, const char * argv[]) &#123; int m,n,total; printf(&quot;请输入两个整数：&quot;); scanf(&quot;%d,%d&quot;,&amp;m,&amp;n); if (m&gt;n)&#123; swap(&amp;m, &amp;n); &#125; total = sum(m, n); printf(&quot;a=%d,b=%d\\n&quot;,m,n); printf(&quot;total=%d\\n&quot;,total); return 0;&#125;int sum(int a,int b)&#123; for (int i = a+1; i &lt;= b; i++) &#123; a += i; &#125; return a;&#125;void swap(int *a,int *b)&#123; int temp = *a; *a = *b; *b = temp;&#125; 定义选择排序和使用选择排序分别在不同的文件中 main.c 1234567891011121314151617181920#include &lt;stdio.h&gt;#define ARR_LEN 10void select_sort(int arr[],int len);void print_arr(int arr[],int len);int main(int argc, const char * argv[]) &#123; int arr[ARR_LEN] = &#123;8,1,4,10,3,6,2,7,9,5&#125;; printf(&quot;排序前：\\n&quot;); print_arr(arr, ARR_LEN); select_sort(arr, ARR_LEN); printf(&quot;排序后：\\n&quot;); print_arr(arr, ARR_LEN); return 0;&#125; ssort.c 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;// 交换static void swap(int *a,int *b)&#123; int temp = *a; *a = *b; *b = temp;&#125;// 打印数组extern void print_arr(int arr[],int len)&#123; for (int i = 0; i &lt; len; i++) &#123; printf(&quot;%d&quot;,arr[i]); &#125; printf(&quot;\\n&quot;);&#125;// 选择排序extern void select_sort(int arr[],int len)&#123; int i,j; for (i = 0; i &lt; len; i ++) &#123; for (j = i+1; j &lt; len; j++) &#123; if (arr[i] &gt; arr[j])&#123; swap(&amp;arr[i], &amp;arr[j]); &#125; &#125; &#125;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习04：语句和控制块","slug":"C学习/C语言学习04：语句和控制块","date":"2023-02-13T04:58:15.000Z","updated":"2023-03-01T13:50:46.354Z","comments":true,"path":"2023/02/13/C学习/C语言学习04：语句和控制块/","link":"","permalink":"https://www.bboyzj.cn/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A004%EF%BC%9A%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%8E%A7%E5%88%B6%E5%9D%97/","excerpt":"","text":"输入输出语句 printf(格式控制,输出表列) %d格式符：输出有符号十进制整数。 c格式符：输出一个字符。 s格式符：输出一个字符串。 f格式符：%f-实数部分全部输出，小数部分输出6位。%m.nf-m表示包括小数在内的整个浮点数长度，n表示小数点保留几位。 p格式符：用来输出地址。 scanf 一般形式为 scanf(格式控制,地址表列) 正则 需要通过 #include &lt;regex.h&gt; 库 %[abc]：读取a&#x2F;b&#x2F;c任意一员 %[^a-z]：读取不在a-z之间的字符串 %[^&#x3D;]：读取字符串直到碰到&#x3D;号 %[^&#x3D;]：前面号表示不保存变量 字符输入输出 putchar(c)：用于输出字符c c &#x3D; getchar()：用于输入一个字符，返回的不是char类型，而是 int 类型 一般用法 while(c&#x3D;getchar() &amp;&amp; a!&#x3D;EOF) { } EOF：指检测文件尾，宏定义值为-1 判断语句 if(…){} if(…){} else{} if(…){} else if(…){} … else{…} switch(表达式){case 常量1:语句1;case 常量2:语句2;…;case 常量n:语句n;default:语句n+1} 循环语句 while while (表达式) { 语句} do…while：至少会执行一次 do 语句while (表达式); for for (表达式1,表达式2,表达式3) 语句 循环打断 break 或 goto continue continue 不跳出循环，而是将程序执行跳转到末尾处 练习题 循环打印字符串 123456789101112#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; char str[] = &quot;Hello World!&quot;; size_t len = sizeof(str)/sizeof(char); printf(&quot;%zu\\n&quot;,len); for (int i = 0; i&lt;len; i++) &#123; printf(&quot;%c\\n&quot;,str[i]); &#125; return 0;&#125; 判断字符 12345678910111213141516171819202122232425262728293031323334// 声明void judge_char(char ch);int main(int argc, const char * argv[]) &#123; char ch; printf(&quot;请输入一个字符：&quot;); scanf(&quot;%c&quot;,&amp;ch); judge_char(ch); return 0;&#125;// 定义void judge_char(char ch)&#123; /* getchar和putchar 专门用于字符的输入和输出 getchar()写法上要为 变量 = getchar(); putchar()写法上要为 putchar(变量) getchar(&#x27;\\n&#x27;)输出一个控制符 putchar(&#x27;字母/字符&#x27;);输出一个字母/字符 */// ch = getchar(); if (ch &lt; 31) &#123; printf(&quot;这是一个控制字符或通讯专用字符!\\n&quot;); &#125;else if (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123; printf(&quot;这是一个数字!&quot;); &#125;else if (ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;) &#123; printf(&quot;这是一个大写字母!\\n&quot;); &#125;else if (ch &gt;= &#x27;a&#x27; &amp;&amp; ch &lt;= &#x27;z&#x27;) &#123; printf(&quot;这是一个小写字母!\\n&quot;); &#125;else &#123; printf(&quot;这是其他字符!\\n&quot;); &#125;&#125; 任意输入3个整数，使用if语句对这3个语句从小到大升序排序。 123456789101112131415161718192021222324252627// 交换x,yvoid swap(int *x,int *y)&#123; int temp = *x; *x = *y; *y = temp;&#125;int main(int argc, const char * argv[]) &#123; int a,b,c; printf(&quot;请输入a,b,c:\\n&quot;); scanf(&quot;%d,%d,%d&quot;,&amp;a,&amp;b,&amp;c); if (a&gt;b)&#123; swap(&amp;a, &amp;b); &#125; if (a&gt;c)&#123; swap(&amp;a, &amp;c); &#125; if (b&gt;c)&#123; swap(&amp;b, &amp;c); &#125; printf(&quot;升序排序结果：\\n&quot;); printf(&quot;%d,%d,%d\\n&quot;,a,b,c); return 0;&#125; 九九乘法表 1234567891011int main(int argc, const char * argv[]) &#123; int i = 0; int j = 0; for (i = 1; i &lt;= 9; i++) &#123; for (j = 1; j &lt;= 9; j++) &#123; printf(&quot;%d*%d=%2d\\t&quot;,i,j,i*j); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 使用goto语句模拟循环，求10以内整数之和。 1234567891011121314#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; int sum = 0; int i = 0; LOOP: if (++i &lt;= 10) &#123; sum += i; goto LOOP; &#125; printf(&quot;10以内的正整数之和为：%d\\n&quot;,sum); return 0;&#125; while循环：最大公约数 和 最小公倍数 公约数：几个自然数共有的约数，为他们的公约数最大公约数：公约数中的最大一个 公倍数：能够被一个整数整除额整数成为其倍数最小公倍数：两个或多个整数的公倍数最小的一个 问：使用while循环，求两个正整数的最大公约数和最小公倍数 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; int a,b,m,c; printf(&quot;请输入两个数：&quot;); scanf(&quot;%d,%d&quot;,&amp;a,&amp;b); // 给两个整数排序 if (a&lt;b)&#123; int temp = a; a = b; b = temp; &#125; m = a*b; c = a%b; while (c != 0) &#123; a = b; // 最大公约数 b = c; c = a%b; &#125; printf(&quot;最大公约数是：%d\\n&quot;,b); printf(&quot;最小公倍数是：%d\\n&quot;,m/b); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习03：运算符和表达式","slug":"C学习/C语言学习03：运算符和表达式","date":"2023-02-12T18:10:04.000Z","updated":"2023-03-07T05:14:48.910Z","comments":true,"path":"2023/02/13/C学习/C语言学习03：运算符和表达式/","link":"","permalink":"https://www.bboyzj.cn/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A003%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"测试题 判断正整数的位数 1234567891011121314151617181920212223#include &lt;stdio.h&gt;// 声明void IntCount(int num);// 入口函数int main(int argc, const char * argv[]) &#123; // 判断正整数的位数 int num; printf(&quot;请输入一个正整数：&quot;); scanf(&quot;%d&quot;,&amp;num); IntCount(12345); return 0;&#125;// 判断正整数的位数void IntCount(int num) &#123; int count = 0; // 位数 while (num &gt; 0) &#123; num = num/10; count += 1; &#125; printf(&quot;%d\\n&quot;, count);&#125; 打印100以内（包含100）能被10整除的正整数 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; // 打印100以内被10整除的正整数 int i = 1; while (i &lt; 100) &#123; if (i % 10 == 0) &#123; printf(&quot;%d\\n&quot;,i); &#125; i ++; &#125; return 0;&#125;==========102030405060708090 输入两个闭区间，并判断两个区间是否重叠？ 1234567891011121314151617181920#define MAX(a,b) ((a&gt;b) ? a:b)#define MIN(a,b) ((a&lt;b) ? a:b)int main(int argc, const char * argv[]) &#123; int start_1,end_1; int start_2,end_2; printf(&quot;请输入第一个闭区间(逗号分割)：&quot;); scanf(&quot;%d,%d&quot;,&amp;start_1,&amp;end_1); printf(&quot;请输入第二个闭区间(逗号分割)：&quot;); scanf(&quot;%d,%d&quot;,&amp;start_2,&amp;end_2); if (MIN(end_1, end_2) &lt; MAX(start_1, start_2)) &#123; printf(&quot;不重叠&quot;); &#125;else &#123; printf(&quot;重叠&quot;); &#125; return 0;&#125; 输入任意年份的正整数n，判断该年份是否为闰年？ 闰年的定义：能被400整除的年份为闰年；能被4整除同时不能被100整除的年份是闰年 闰年一年有366天，2月份有29天平年一年有365天，2月份有28天 1234567891011121314151617// 判断闰年void is_leap_year(int year)&#123; if (year%400==0 || (year%4==0 &amp;&amp; year%100!=0)) &#123; printf(&quot;%d年是闰年\\n&quot;,year); &#125;else&#123; printf(&quot;%d年不是闰年\\n&quot;,year); &#125;&#125;int main(int argc, const char * argv[]) &#123; // 判断闰年 int year; printf(&quot;请输入年份：&quot;); scanf(&quot;%d&quot;,&amp;year); is_leap_year(year); return 0;&#125; 打印邮费价格表，输出20kg以内物品的邮费价格表，邮费计算规则如下： 1kg以内6元 超过1kg,每增加1kg加收2元 注：逗号运算符与表达式小知识 1.逗号运算符的优先级是所有运算符中最低的 2.整个逗号表达式的值为其中最后一个子表达式的值 3.逗号运算符常用在for循环头部初始化或递增多个变量 123456789101112#define FIRST_COST 6#define NEXT_COST 2int main(int argc, const char * argv[]) &#123; int weight,cost; printf(&quot;重量\\t价格\\t\\n&quot;); for (weight=1,cost=FIRST_COST;weight&lt;=10;++weight,cost=FIRST_COST+(weight-1)*NEXT_COST) &#123; printf(&quot;%d\\t￥%d\\n&quot;,weight,cost); &#125; return 0;&#125; 输入三个整数，求出最大值并输出？ 123456789int main(int argc, const char * argv[]) &#123; int a,b,c,max; printf(&quot;请输入3个整数：&quot;); scanf(&quot;%d,%d,%d&quot;,&amp;a,&amp;b,&amp;c); max = c&gt;((a&gt;b)?a:b) ? c:((a&gt;b)?a:b); printf(&quot;3个数中的最大值是：%d\\n&quot;,max); return 0;&#125; 定义并初始化一个整型数组（未显示指定数组长度），循环输出数组中每个元素。在完成以上任务的过程中，为了得到数组的长度，需要借助sizeof运算符？ 小知识： 1.sizeof在使用的时候看上去像是一个函数（因为后面有一对小括号），但他是一个运算符。它的使用方法有以下三种： a)sizeof(变量名) b)sizeof(数据类型名) c)sizeof 变量名 2. sizeof的返回值类型是size_t 12345678910int main(int argc, const char * argv[]) &#123; int arr[]=&#123;1,2,3,4,5&#125;; size_t len = sizeof(arr)/sizeof(arr[0]); size_t i; for (i=0; i&lt;len; ++i) &#123; printf(&quot;%d\\n&quot;,arr[i]); &#125; return 0;&#125; 根据运算符优先级及求职顺序，使程序输出结果为2，3，1 12345678910int main(int argc, const char * argv[]) &#123; int x,y,z; printf(&quot;请输入2个整数：&quot;); scanf(&quot;%d,%d&quot;,&amp;x,&amp;y); z=x++,++y,y++; printf(&quot;%d,%d,%d\\n&quot;,x,y,z); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习02：变量的类型","slug":"C学习/C语言学习02：变量","date":"2023-02-12T16:52:46.000Z","updated":"2023-03-07T04:49:39.109Z","comments":true,"path":"2023/02/13/C学习/C语言学习02：变量/","link":"","permalink":"https://www.bboyzj.cn/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A002%EF%BC%9A%E5%8F%98%E9%87%8F/","excerpt":"","text":"变量 什么是变量？ 变量表示 内存中的一个存储区域（不同的数据类型，占用的空间大小不一样） 为什么需要变量？ 答：变量是其程序的 基本组成单位 定义变量type variable_list; type：变量类型 variable_list：一个或多个标识符组成，多个用逗号分割 1int i, j, k; 变量的声明变量的声明有两种： 一种是需要建立存储空间。 int i; &#x2F;&#x2F; 声明，也是定义 另一种是不需要建立存储空间的，用 extern关键字 声明的。 extern int i; &#x2F;&#x2F; 声明，不是定义","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C语言学习01：C语言概述","slug":"C学习/C语言学习01：C语言概述","date":"2023-02-12T16:32:23.000Z","updated":"2023-03-07T04:03:58.139Z","comments":true,"path":"2023/02/13/C学习/C语言学习01：C语言概述/","link":"","permalink":"https://www.bboyzj.cn/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A001%EF%BC%9AC%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/","excerpt":"","text":"C语言特点C 语言是一门过程性语言，C 语言可以 代替机器语言或汇编语言编写运行速度快的程序。 语言简洁，使用方便灵活 可移植性好 表达能力强 表达方式灵活 可进行结构化程序设计 可以直接操作计算机硬件 生成的目标代码质量高 编程机制C 语言程序从源代码到二进制程序都经历了哪些过程？ 预处理(Preprocession) 预处理用于将所有的 #include头文件及宏定义 替换成 真正的内容test.c 到 test.i 编译(Complication) 编译过程将 预处理之后的程序 转换成特定的 汇编代码(Assemble Code)test.i 到 test.s 汇编(Assemble) 汇编过程将 汇编代码 转换成 机器码(machine code)，这一步产生的文件叫 目标文件，每一个 源文件 都会产生一个 目标文件test.s 到 test.o 链接(Linking) 链接过程将 多个目标文件及所需的库文件 链接成最终的 可执行文件(executable file)","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-探索篇","slug":"C-探索篇","permalink":"https://www.bboyzj.cn/tags/C-%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"C面试题：C","slug":"面试题/C面试题：算法","date":"2023-02-11T16:06:03.000Z","updated":"2023-03-08T22:45:06.638Z","comments":true,"path":"2023/02/12/面试题/C面试题：算法/","link":"","permalink":"https://www.bboyzj.cn/2023/02/12/%E9%9D%A2%E8%AF%95%E9%A2%98/C%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%97%E6%B3%95/","excerpt":"","text":"汽水瓶某商店规定：三个空汽水瓶可以换一瓶汽水，允许向老板借空汽水瓶（但是必须要归还）。小张手上有n个空汽水瓶，她想知道自己最多可以喝到多少瓶汽水。数据范围：输入的正整数满足1 ≤ n ≤ 100 注意：本题存在多组输入。输入的 0 表示输入结束，并不用输出结果。 示例1：输入例子：310810输出例子：1540例子说明：样例 1 解释：用三个空瓶换一瓶汽水，剩一个空瓶无法继续交换样例 2 解释：用九个空瓶换三瓶汽水，剩四个空瓶再用三个空瓶换一瓶汽水，剩两个空瓶，向老板借一个空瓶再用三个空瓶换一瓶汽水喝完得一个空瓶还给老板 123456789101112131415161718192021222324252627#import &lt;Foundation/Foundation.h&gt;int main(int argc, char* argv[]) &#123; NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init]; // 定义空气水平为num，最多可喝到ret int num,ret; while (scanf(&quot;%d&quot;, &amp;num) != EOF) &#123; // 汽水瓶可以是0，这里跳出循环 // 初始值 ret = 0; if (num &gt; 0) &#123; // 如果空瓶 &gt;= 3 那么一直可置换 while (num &gt;= 3) &#123; // 汽水 = 汽水 + 空瓶3个换一瓶汽水 ret = ret + num/3; // 空瓶3个换1个空瓶 + 剩余未置换的空瓶 num = num/3 + num%3; &#125; // 如果还剩2个空瓶，则还能置换一瓶汽水 if (num == 2) &#123; ret ++; &#125; printf(&quot;%d&quot;,ret); &#125; &#125; [pool drain]; return 0;&#125; 明明的随机数明明生成了N个1到500之间的随机整数。请你删去其中重复的数字，即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数从小到大排序，按照排好的顺序输出。数据范围： 1≤n≤1000 ，输入的数字大小满足 1≤val≤500 输入描述：第一行先输入随机整数的个数 N 。接下来的 N 行每行输入一个整数，代表明明生成的随机数。具体格式可以参考下面的”示例”。 示例1：输入例子：3221输出例子：12例子说明：输入解释：第一个数字是3，也即这个小样例的N&#x3D;3，说明用计算机生成了3个1到500之间的随机整数，接下来每行一个随机数字，共3行，也即这3个随机数字为：221所以样例的输出为：12 c 语言实现： 1234567891011121314151617181920212223242526272829303132333435#import &lt;Foundation/Foundation.h&gt;int main(int argc, char* argv[]) &#123; NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init]; int n; // 个数 int arr[1001]; // 数组 int j,k; //定义循环因子，嵌套双层循环 while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; // 生成随机数并添加到数组中 for (int i = 0; i &lt; n; i ++) &#123; int r = rand()%1000; arr[i] = r; &#125; // 冒泡排序 for(j=0; j&lt;n-1; j++) //设置循环后界 &#123; for(k=0; k&lt;n-j-1; k++) //不断向后进行比较 &#123; if(arr[k]&gt;arr[k+1]) //比较相邻的元素 &#123; int temp=arr[k]; //三杯水交换法 arr[k]=arr[k+1]; arr[k+1]=temp; &#125; &#125; &#125; /* 输出数组中每个元素的值 */ for (int m = 0; m &lt; n; m++ )&#123; printf(&quot;Element[%d] = %d\\n&quot;, m, arr[m] ); &#125; &#125; [pool drain]; return 0;&#125; 进制转换16进制转10进制 12345678910111213141516171819202122232425262728293031#import &lt;Foundation/Foundation.h&gt;#include&lt;stdlib.h&gt;int main(int argc, char* argv[]) &#123; char a[] = &quot;1c&quot;; func(a); printf(&quot;%d\\n&quot;,func(a)); return 0;&#125;int func(char a[])&#123; // 长度 long len = strlen(a); int i,j,num=0; for (i = 0; i &lt; len; i ++) &#123; if (a[i] == &#x27;A&#x27;) num += 10 * pow(16, len - i - 1); //pow() 函数用来求 x 的 y 次方的值。 else if (a[i] == &#x27;B&#x27;) num += 11 * pow(16, len - i - 1); else if (a[i] == &#x27;C&#x27;) num += 12 * pow(16, len - i - 1); else if (a[i]==&#x27;D&#x27;) num += 13 * pow(16, len - i - 1); else if (a[i] == &#x27;E&#x27;) num += 14 * pow(16, len - i - 1); else num += 15 * pow(16, len - i - 1); &#125; return num;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}],"tags":[{"name":"C-面试题","slug":"C-面试题","permalink":"https://www.bboyzj.cn/tags/C-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.bboyzj.cn/categories/C/"}]},{"title":"Swift学习：Kingfisher使用","slug":"Swift/Swift学习：Kingfisher使用","date":"2023-02-09T04:39:18.000Z","updated":"2023-03-08T22:17:17.288Z","comments":true,"path":"2023/02/09/Swift/Swift学习：Kingfisher使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/09/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9AKingfisher%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言Kingfisher 是一个 下载、缓存 网络图片的轻量级纯swift库，在swift中是一个SDWebImage的升级版 特征 异步下载和缓存图片 提供图片处理器和过滤器 内存和磁盘的多层缓存 扩展UIImageView&#x2F;UIButton来设置图片，内置过渡动画 基本使用 直接设置一张url图片 123if let url = URL(string: &quot;http://mvimg2.meitudata.com/55fe3d94efbc12843.jpg&quot;) &#123; imgView.kf.setImage(with: url)&#125; 注：kingfisher 首先尝试从缓存中去取，如果没有，直接下载图片并且缓存下来备用；此外，kingfisher 默认使用 url 作为 cacheKey 以方便再次加载该图片时去缓存中根据 cacheKey 查找 指定给一个 cacheKey 缓存图片 12let imageResource = ImageResource(downloadURL: url, cacheKey: &quot;Custom_cache_key&quot;)imageView.kf.setImage(with: imageResource) 设置占位图片 123if let url = URL(string: &quot;http://mvimg2.meitudata.com/55fe3d94efbc12843.jpg&quot;) &#123; imageView.kf.setImage(with: url, placeholder: placeholder_image, options: nil, progressBlock: nil, completionHandler: nil)&#125; 下载完成回调 12345678910111213141516if let url = URL(string: &quot;http://mvimg2.meitudata.com/55fe3d94efbc12843.jpg&quot;) &#123; imageView.kf.setImage(with: url, placeholder: nil, options: nil, progressBlock: nil, completionHandler: &#123; (image, error, cacheType, imageUrl) in image // 为 nil 时，表示下载失败 error // 为 nil 时，表示下载成功， 非 nil 时，就是下载失败的错误信息 cacheType // 缓存类型，是个枚举，分以下三种： // .none 图片还没缓存（也就是第一次加载图片的时候） // .memory 从内存中获取到的缓存图片（第二次及以上加载） // .disk 从磁盘中获取到的缓存图片（第二次及以上加载） imageUrl // 所要下载的图片的url &#125;)&#125; 加载菊花 12345678910public enum IndicatorType &#123; /// 默认没有菊花 case none /// 使用系统菊花 case activity /// 使用一张图片作为菊花，支持gif图 case image(imageData: Data) /// 使用自定义菊花，要遵循Indicator协议 case custom(indicator: Indicator)&#125; 使用系统菊花 12imageView.kf.indicatorType = .activityimageView.kf.setImage(with: url) 使用gif图作为加载菊花 1234let path = Bundle.main.path(forResource: &quot;myImage&quot;, ofType: &quot;gif&quot;)!let data = try! Data(contentsOf: URL(fileURLWithPath: path))imageView.kf.indicatorType = .image(imageData: data)imageView.kf.setImage(with: url) 自定义菊花，遵循 Indicator协议 12345678910111213141516171819202122let myIndicator = CustomIndicator()imageView.kf.indicatorType = .custom(indicator: myIndicator)imageView.kf.setImage(with: url)struct CustomIndicator: Indicator &#123; var view: IndicatorView = UIView() func startAnimatingView() &#123; view.isHidden = false &#125; func stopAnimatingView() &#123; view.isHidden = true &#125; init() &#123; view.backgroundColor = UIColor.magenta &#125;&#125; 根据实时下载图片的数据做进度条加载或者菊花加载（灵活，比例为：图片已下载数据 &#x2F; 图片总数据） 123456789imageView.kf.setImage(with: url, placeholder: nil, options: nil, progressBlock: &#123; (receivedData, totolData) in let percentage = (Float(receivedData) / Float(totolData)) * 100.0 print(&quot;downloading progress is: \\(percentage)%&quot;) // 这里用进度条或者绘制view都可以，然后根据 percentage% 表示进度就行了&#125;, completionHandler: nil) …","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"OC性能优化08：启动优化","slug":"OC性能优化/OC性能优化08：启动优化","date":"2023-02-08T09:49:41.000Z","updated":"2023-02-08T09:56:30.788Z","comments":true,"path":"2023/02/08/OC性能优化/OC性能优化08：启动优化/","link":"","permalink":"https://www.bboyzj.cn/2023/02/08/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9608%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/","excerpt":"","text":"","categories":[{"name":"OC-性能优化探索篇","slug":"OC-性能优化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-性能优化探索篇","slug":"OC-性能优化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC性能优化07：耗电优化","slug":"OC性能优化/OC性能优化07：耗电优化","date":"2023-02-08T09:48:39.000Z","updated":"2023-02-08T09:55:24.327Z","comments":true,"path":"2023/02/08/OC性能优化/OC性能优化07：耗电优化/","link":"","permalink":"https://www.bboyzj.cn/2023/02/08/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9607%EF%BC%9A%E8%80%97%E7%94%B5%E4%BC%98%E5%8C%96/","excerpt":"","text":"耗电的主要来源 cpu处理 网络 定位 图像 耗电解决方案 cpu层面的优化 尽量降低CPU、GPU功耗 少使用定时器 优化I&#x2F;O操作 写入数据最好一次性写入 读取数据最好使用GCD异步操作 数据流比较大，建议使用数据库 网络请求层面的优化 减少、压缩网络数据 如果多次请求的结果是相同的，尽量使用缓存 使用断点续传，否则网络不稳定时可能多次传输相同的内容 网络不可用时，不要尝试执行网络请求 让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间 批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载 定位层面优化 如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电 如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务 尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest 需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新 尽量不要使用startMonitoringSignificantLocationChanges，优先考虑startMonitoringForRegion: 硬件检测优化(不常用) 用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件","categories":[{"name":"OC-性能优化探索篇","slug":"OC-性能优化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-性能优化探索篇","slug":"OC-性能优化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC性能优化06：Leaks内存泄漏探索","slug":"OC性能优化/OC性能优化06：Leaks内存泄漏探索","date":"2023-02-08T08:34:17.000Z","updated":"2023-02-11T03:12:01.539Z","comments":true,"path":"2023/02/08/OC性能优化/OC性能优化06：Leaks内存泄漏探索/","link":"","permalink":"https://www.bboyzj.cn/2023/02/08/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606%EF%BC%9ALeaks%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"前言在 XCode 中，提供两种工具帮助查找泄漏点 Analyze 静态分析工具 通过 Product -&gt; Analyze，快捷键 CMD + Shift + b: 逻辑错误：访问空指针或未初始化的变量等 内存管理错误：如内存泄漏等 声明错误：从未使用过的变量 API调用错误：未包含使用的库和框架 Instruments 动态分析工具 CMD + i 打开 打开界面的介绍 在 instruments 中，选择了 Leaks 模板，默认情况下也会添加 Allocations 模板，基本上凡是内存分析都会使用 Allocations 模板，它可以 监控内存分布情况： 选中 Allocations 模板即图1区域，3区域会显示随着时间变化内存使用的折线图，图4显示内存使用的详细信息以及对象分配情况 选中 Leask 模板即图2区域，可以查看内存泄漏情况，如果 3区域有 红X 出现，则 内存泄漏，4区域显示内存泄漏的对象 打开 leaks 进行监测 点击泄漏对象可以看到他们的内存地址，占用字节，所属框架和响应方法等信息，打开扩展视图，可以看到右边的跟踪堆栈信息 监测结果分析 Allocations 内存分布版面介绍","categories":[{"name":"OC-性能优化探索篇","slug":"OC-性能优化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-性能优化探索篇","slug":"OC-性能优化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"Swift学习：判断是否是Debug环境","slug":"Swift/Swift学习：判断是否是Debug环境","date":"2023-02-07T03:09:34.000Z","updated":"2023-03-08T22:10:33.366Z","comments":true,"path":"2023/02/07/Swift/Swift学习：判断是否是Debug环境/","link":"","permalink":"https://www.bboyzj.cn/2023/02/07/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AFDebug%E7%8E%AF%E5%A2%83/","excerpt":"","text":"build setting 配置target -&gt; builf setting -&gt; swift flags -&gt; other swift flags 下 点击 debug 添加 -D DEBUG，注意 release 下不添加 调用12345#if DEFBU // debug#else // release#endif","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习：RxSwift使用","slug":"Swift/Swift学习：RxSwift使用","date":"2023-02-07T03:02:45.000Z","updated":"2023-03-09T10:38:38.597Z","comments":true,"path":"2023/02/07/Swift/Swift学习：RxSwift使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/07/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9ARxSwift%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言OC 响应式编程一般使用 ReactiveCocoa，而 Swift 响应式编程一般使用 RxSwift，RxSwift 本质是 观察者模式，目的是让 数据/事件流和异步任务 能够更方便的序列化处理。 RxSwift 引入Podfile文件中添加如下，并 pod update 123# 响应式编程库pod &#x27;RxSwift&#x27;pod &#x27;RxCocoa&#x27; RxSwift 使用 Target Action 12345lazy var bag: DisposeBag = DisposeBag()btn.rx.tap.subscribe &#123; event in print(&quot;点击按钮&quot;)&#125;.disposed(by: bag); 监听输入框文字变化 12345lazy var bag: DisposeBag = DisposeBag()tf.rx.text.subscribe(onNext: &#123;string in print(&quot;输入变化：\\(string!)&quot;);&#125;).disposed(by: bag) 输入框文字绑定到label上 123lazy var bag: DisposeBag = DisposeBag()tf.rx.text.bind(to:label.rx.text).disposed(by: bag) 通知 12345lazy var bag: DisposeBag = DisposeBag()NotificationCenter.default.rx.notification(.NSExtensionHostWillEnterForeground).subscribe(onNext: &#123; notification in print(&quot;Application will enter foreground&quot;);&#125;).disposed(by: bag) 监听属性改变 1234567label.rx.observe(String.self, &quot;text&quot;).subscribe &#123; event in print(&quot;文本改变：\\(event.element!!)&quot;)&#125;.disposed(by: bag)label.rx.observe(CGRect.self, &quot;frame&quot;).subscribe &#123; event in print(&quot;frame改变：\\(event.element!!)&quot;)&#125;.disposed(by: bag) 监听滚动偏移 123scrollView.rx.contentOffset.subscribe &#123; point in print(&quot;滚动偏移：\\(point.element!)&quot;)&#125;.disposed(by: bag)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习：swift中typealias使用","slug":"Swift/Swift学习：swift中typealias使用","date":"2023-02-05T07:01:41.000Z","updated":"2023-03-08T22:11:34.384Z","comments":true,"path":"2023/02/05/Swift/Swift学习：swift中typealias使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/05/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%ADtypealias%E4%BD%BF%E7%94%A8/","excerpt":"","text":"简介typealias：类型别名 使用 第一种方式 12345678910// 定义闭包typealias SuccessCallBack = (_ code:String,_ message:String) -&gt; void// 声明闭包var customCallBack : SuccessCallBack?// 使用if let call = customCallBack &#123; call(&quot;你是谁&quot;,&quot;你管我是谁&quot;);&#125; 第二种方式 12345678// 定义闭包var callBack:((_ code:String,_ message:String) -&gt; Void)?// 使用if let call = callBack &#123; call(&quot;我是谁&quot;,&quot;我也不知道我是谁&quot;);&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习：HandyJSON的使用","slug":"Swift/Swift学习：HandyJSON的使用","date":"2023-02-04T04:03:43.000Z","updated":"2023-03-08T22:10:23.318Z","comments":true,"path":"2023/02/04/Swift/Swift学习：HandyJSON的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/04/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9AHandyJSON%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言HandyJSON 是阿里巴巴开源的一个用于Swift语言中的 JSON序列化/反序列化库，可以很方便进行 json和model 的转换，以及常用的 字典和模型 的互相转换 JSON转Model只需要在定义时，实现HandyJSON协议，这个协议只要求实现一个空的init()函数 定义 BaseModel 1234567891011import HandyJSONclass BaseModel: HandyJSON &#123; // 返回的数据 var data : Any? // 业务码 var code : Int? // 提示信息 var msg : String? required init() &#123;&#125;&#125; 转换 123if let baseModel = BaseModel.deserialize(from:jsonString)&#123; print();&#125; model 转 json1JSONSerializer.serializeToJson(object:xxx)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习：swift中extension使用","slug":"Swift/Swift学习：swift中extension使用","date":"2023-02-04T03:12:04.000Z","updated":"2023-03-08T22:11:29.147Z","comments":true,"path":"2023/02/04/Swift/Swift学习：swift中extension使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/04/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%ADextension%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言swift 中的 扩展Extension，类似 OC 中的 分类Category 作用 扩展可以为 枚举、结构体、类、协议 添加新功能 添加方法、计算属性、下标、初始化器、嵌套类型、协议等 扩展不能办到的事 不能覆盖原有的功能 OC是允许覆盖的，但swift是安全的，是不允许覆盖的 不能添加存储属性 因为属性会改变内存结构，但扩展是不允许改变原有的内存结构 不能向已有的属性添加属性观察值 不能添加父类 不能扩展后面书写冒号继承父类（Extension Car:Person），因为继承有可能改变原有类的结构 不能添加指定初始化器，不能添加反初始化器 required初始化器不能在扩展中，只能在原有类中 实用 扩展方法 123456789101112131415161718extension ViewController &#123; // MARK：- 实例方法 // 声明无参数无返回值的实例方法 func run() &#123; print(&quot;run&quot;); &#125; // MARK：类方法 // 声明私有类方法 private class func eat() &#123; print(&quot;eat&quot;); &#125; // MARK：静态方法（属于特殊的类方法） static func speak() &#123; print(&quot;speak&quot;); &#125;&#125; 扩展协议 123456789extension ViewController: UITableViewDataSource， UITableViewDelegate &#123; func tableView(_ tableView: UITableView， numberOfRowsInSection section: Int) -&gt; Int &#123; return 5 &#125; func tableView(_ tableView: UITableView， cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; return UITableViewCell() &#125;&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习：swift中方法的声明","slug":"Swift/Swift学习：swift中方法的声明","date":"2023-02-04T02:52:19.000Z","updated":"2023-03-08T22:13:10.471Z","comments":true,"path":"2023/02/04/Swift/Swift学习：swift中方法的声明/","link":"","permalink":"https://www.bboyzj.cn/2023/02/04/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E5%A3%B0%E6%98%8E/","excerpt":"","text":"实例方法12345678910111213141516171819202122232425// MARK：实例方法// 声明无参数无返回值的实例方法func run() &#123; print(&quot;run&quot;);&#125;// 声明带参的实例方法，其中：dest 被称为参数标签，可以使用 “_” 代替func run(dest distance: Int) &#123; print(distance);&#125;// 声明带多个参数的实例方法func run(dest distance: Int,sour position:Int) &#123; print(distance+position);&#125;// 声明带参数有返回值的实例方法func run(dest distance: Int) -&gt; Bool &#123; return true;&#125;// 声明带参数有多个返回值的实例方法func run(dest distance: Int) -&gt; (Bool,Int) &#123; return (true,10);&#125;// 声明私有实例方法，其中 private 可更换其他访问权限的关键字private func cry(content value:String)&#123; print(value);&#125; 类方法12345678// 声明类方法class func walk()&#123; print(&quot;walk&quot;);&#125;// 声明私有类方法private class func eat() &#123; print(&quot;eat&quot;);&#125; 静态方法123456789// MARK：静态方法（属于特殊的类方法）static func speak() &#123; print(&quot;speak&quot;);&#125;// 私有静态方法private static func see() &#123; print(&quot;see&quot;);&#125; 注：实例方法由实例对象调用；类方法和静态方法用类对象调用","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习：swift中guard语句","slug":"Swift/Swift学习：swift中guard语句","date":"2023-02-03T11:54:25.000Z","updated":"2023-03-08T22:11:31.845Z","comments":true,"path":"2023/02/03/Swift/Swift学习：swift中guard语句/","link":"","permalink":"https://www.bboyzj.cn/2023/02/03/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%ADguard%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"前言123guard 条件 else &#123; // do something&#125; 当 guard 语句条件为 false 时，执行大括号里面的代码 当 guard 语句条件为 true 时，跳过guard语句 列子1234567891011func login(_ info:[String:String])&#123; guard let username = info[&quot;username&quot;] else &#123; print(&quot;请输入用户名&quot;); return; &#125; guard let password = info[&quot;password&quot;] else &#123; print(&quot;请输入密码&quot;); return; &#125; print(&quot;用户名：\\(username)&quot;,&quot;密码：\\(password)&quot;);&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习08：swift中@available和#available","slug":"Swift/Swift学习：swift中@available和#available","date":"2023-02-03T11:54:08.000Z","updated":"2023-02-04T03:30:33.504Z","comments":true,"path":"2023/02/03/Swift/Swift学习：swift中@available和#available/","link":"","permalink":"https://www.bboyzj.cn/2023/02/03/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD@available%E5%92%8C#available/","excerpt":"","text":"前言对于 函数、类、协议等，可以使用 @available 声明这些类型的声明周期依赖于特定的平台和操作系统版本。而 #available 用在判断语句中，在不同平台上做不同的逻辑 @available1234@available(iOS 9,*)func myMethod()&#123; // do something&#125; iOS 9 : 表示在 iOS 9 版本以上才可用 星号 * : 表示包含了所有平台 #availble#availble 用于条件语句代码块中，判断不同的平台下，做不通的逻辑处理 1234567if #availble(iOS 9,*) &#123; // iOS 9 及以上系统运行&#125;guard #availble(iOS 9,*) else &#123; // iOS 9 以下系统运行&#125;","categories":[{"name":"swift-学习篇","slug":"swift-学习篇","permalink":"https://www.bboyzj.cn/categories/swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"iOS-Swift","slug":"iOS-Swift","permalink":"https://www.bboyzj.cn/tags/iOS-Swift/"}],"keywords":[{"name":"swift-学习篇","slug":"swift-学习篇","permalink":"https://www.bboyzj.cn/categories/swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}]},{"title":"Swift学习：swift中as、as！、as？号的使用","slug":"Swift/Swift学习：swift中as、as！、as？号的使用","date":"2023-02-03T11:27:15.000Z","updated":"2023-03-15T12:56:07.361Z","comments":true,"path":"2023/02/03/Swift/Swift学习：swift中as、as！、as？号的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/03/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%ADas%E3%80%81as%EF%BC%81%E3%80%81as%EF%BC%9F%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"关于 as 将子类转换为基类 1234class Auto &#123;&#125;class Car : Auto &#123;&#125;let car = Car()let truck = car as Auto 数值类型的转换 1let n1 = 56 as Int 模式匹配 1234567swich Auto &#123; case let car as Car: print(&quot;这里是Car类型对象&quot;); case let truck as Truck: print(&quot;这里是Truck类型对象&quot;); default: break&#125; as!向下强制类型转换，如果转换失败会报错 1234class Auto &#123;&#125;class Car: Auto &#123;&#125;let auto: Auto = Car()let car = auto as! Car as?向下强制类型转换，如果转换失败会返回nil 1234567let auto: Auto = Car()if let car = auto as? Car &#123; print(&quot;这是Car&quot;)&#125;else &#123; print(&quot;这不是Car&quot;)&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习：swift中？、！、？？号的使用","slug":"Swift/Swift学习：swift中？、！、？？号的使用","date":"2023-02-03T11:06:43.000Z","updated":"2023-03-15T12:54:32.602Z","comments":true,"path":"2023/02/03/Swift/Swift学习：swift中？、！、？？号的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/03/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%EF%BC%9F%E3%80%81%EF%BC%81%E3%80%81%EF%BC%9F%EF%BC%9F%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言swift 中 ? 是 可选 的意思，! 是 强制解包 的意思，?? 是用于判断 变量/常量 数值是否为 nil ？号的使用声明一个 Optional 变量或常量时，在数据类型后面加上 ？ 号即可 12// 名字var name : String? !号的使用！ 号用于解包，一般只有在保证 变量/常量 有值，才能进行 强行解包 123var a : Int?a = 5;print(a!); ?? 号?? 号用于判断 变量/常量 数值是否为 nil，为nil则使用 ?? 号后面的值替代 12var a : Int?print(a ?? 0);","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习：Alamofire网络请求封装","slug":"Swift/Swift学习：Alamofire网络请求封装","date":"2023-02-03T02:11:52.000Z","updated":"2023-03-08T22:10:25.571Z","comments":true,"path":"2023/02/03/Swift/Swift学习：Alamofire网络请求封装/","link":"","permalink":"https://www.bboyzj.cn/2023/02/03/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9AAlamofire%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85/","excerpt":"","text":"前言Alamofire 是一个使用 swift 开发的网络请求框架，开发团队是 AFNetworking 的原团队。语法简洁，采用 链式编程 的思想，本质是基于 NSURLSession 进行封装。在实际项目中一般要进行 二次封装。 根据后台返回的数据定义 BaseModel 定义 BaseModel 1234567891011import HandyJSONclass BaseModel: HandyJSON &#123; // 返回的数据 var data : Any? // 业务码 var code : Int? // 提示信息 var msg : String? required init() &#123;&#125;&#125; BaseModel 建立后，就可以正式开始准备搭建网络请求工具了","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习：lazy探索","slug":"Swift/Swift学习：lazy探索","date":"2023-02-02T15:43:25.000Z","updated":"2023-03-08T22:17:10.502Z","comments":true,"path":"2023/02/02/Swift/Swift学习：lazy探索/","link":"","permalink":"https://www.bboyzj.cn/2023/02/02/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Alazy%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"前言 lazy 的本质是 声明并执行的闭包，或一个有返回值的函数调用，只执行一次 lazy属性 就是 初始值 直到 第一次使用的时候 才执行的属性 lazy 属性必须是变量（var修饰符）,因为常量属性（let修饰符）必须在初始化之前就有值，所以常量属性不能定义为lazy OC中的延迟加载12345678@property (nonatomic,strong)UILabel * label;- (UILabel *)label&#123; if (!_label)&#123; _label = [[UILabel alloc] init]; NSLog(@&quot;只在首次访问输出&quot;) &#125; return _label;&#125; Swift 延迟加载1234567lazy var myL: UILabel = &#123; var myL = UILabel(frame: CGRectZero); myL.backgroundColor = UIColor.green; myL.text = &quot;我&quot;; print(&quot;只在首次访问输出&quot;); return myL;&#125;() 相比 OC 的实现，lazy 简单多了。 lazy var label: UILabel = UILabel() 控件懒加载12345lazy var btn = &#123; () -&gt; UIButton in // () -&gt; UIButton in 可以省略前提是已指定类型 // 执行类型不可省略 return UIButton(type: .custom);&#125;() 常见写法 12345lazy var btn: UIButton = &#123; // () -&gt; UIButton in 可以省略前提是已指定类型 // 执行类型不可省略 return UIButton(type: .custom);&#125;()","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习：swift中宏定义替代方案","slug":"Swift/Swift学习：swift中宏定义替代方案","date":"2023-02-02T13:52:08.000Z","updated":"2023-03-08T22:12:48.616Z","comments":true,"path":"2023/02/02/Swift/Swift学习：swift中宏定义替代方案/","link":"","permalink":"https://www.bboyzj.cn/2023/02/02/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%E5%AE%8F%E5%AE%9A%E4%B9%89%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/","excerpt":"","text":"简介swift中没有宏定义，苹果简介用 let 或 get 属性来替代宏定义值 第一种：获取的值不会变可以直接使用 let KnavBarHeight = 44.0; 第二种：获取的值会变let 定义的是常量，如果后面的值会变可以使用 函数 123func StatusBar_height() -&gt; CGFloat&#123; return UIApplication.shared.statusBarFrame.size.height;&#125; 通过 StatusBar_height() 获取状态栏的高度 第三种：输入有参数123func RGB_COLOR(r:CGFloat,g:CGFloat,b:CGFloat) -&gt; UIColor&#123; return UIColor(red:r,green:g,blue:b,alpha:1);&#123; 注：func 也可以用 var 代替 使用 创建 Common.swift 文件存放 创建 SRSF-Swift-Bridging-Header 存放三方库","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Flutter学习01:Mac环境搭建","slug":"Flutter学习/Flutter学习01：Mac环境搭建","date":"2023-01-08T11:04:34.000Z","updated":"2023-03-08T21:42:43.753Z","comments":true,"path":"2023/01/08/Flutter学习/Flutter学习01：Mac环境搭建/","link":"","permalink":"https://www.bboyzj.cn/2023/01/08/Flutter%E5%AD%A6%E4%B9%A0/Flutter%E5%AD%A6%E4%B9%A001%EF%BC%9AMac%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"下载Flutter 方式一： 下载 flutter SDK：https://flutter.io/sdk-archive/#macos 将文件解压到目标路径 12mac@192 ~ % cd 目标文件路径mac@192 ~ % unzip ~/Downloads/flutter_macos_3.3.10-stable.zip 配置 flutter 的 PATH 环境变量 1mac@192 ~ % export PATH=&quot;$PATH:`pwd`/flutter/bin&quot; pwd：是 flutter 下 bin 的文件路径 方式二： 直接从 Github 上下载： 1mac@192 ~ % git clone https://github.com/flutter/flutter.git -b stable 环境变量设置 进入根目录 mac@192 ~ % cd ~ 创建 .bash_profile mac@192 ~ % touch .bash_profile 编辑 .bash_profile mac@192 ~ % open -e .bash_profile 设置环境变量 1234# Flutterexport PUB_HOSTED_URL=https://pub.flutter-io.cn # 国内镜像export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn # 国内镜像export PATH=&quot;$PATH:/Users/mac/Desktop/Flutter/flutter/bin&quot; 注：export PATH=&quot;$PATH:【flutter的bin目录】 保存 .bash_profile mac@192 ~ % command+s 更新 mac@192 ~ % source .bash_profile 验证是否成功 mac@192 ~ % flutter doctor 如果终端显示如下，证明成功了，如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344Downloading Darwin x64 Dart SDK from Flutter engine 3316dd8728419ad3534e3f6112aa6291f587078a... % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 202M 100 202M 0 0 5622k 0 0:00:36 0:00:36 --:--:-- 6859kBuilding flutter tool...Flutter assets will be downloaded from https://storage.flutter-io.cn. Make sureyou trust this source!Downloading Material fonts... 1,526msDownloading Gradle Wrapper... 262msDownloading package sky_engine... 473msDownloading flutter_patched_sdk tools... 1,162msDownloading flutter_patched_sdk_product tools... 638msDownloading darwin-x64 tools... 5.5sDownloading libimobiledevice... 78msDownloading usbmuxd... 75msDownloading libplist... 75msDownloading openssl... 249msDownloading ios-deploy... 88msDownloading darwin-x64/font-subset tools... 255msDoctor summary (to see all details, run flutter doctor -v):[✓] Flutter (Channel stable, 3.3.10, on macOS 12.6.1 21G217 darwin-x64, locale zh-Hans-CN)[!] Android toolchain - develop for Android devices (Android SDK version 30.0.0) ✗ cmdline-tools component is missing Run `path/to/sdkmanager --install &quot;cmdline-tools;latest&quot;` See https://developer.android.com/studio/command-line for more details. ✗ Android license status unknown. Run `flutter doctor --android-licenses` to accept the SDK licenses. See https://flutter.dev/docs/get-started/install/macos#android-setup for more details.[!] Xcode - develop for iOS and macOS (Xcode 14.1) ! CocoaPods 1.10.1 out of date (1.11.0 is recommended). CocoaPods is used to retrieve the iOS and macOS platform side&#x27;s plugin code that responds to your plugin usage on the Dart side. Without CocoaPods, plugins will not work on iOS or macOS. For more info, see https://flutter.dev/platform-plugins To upgrade see https://guides.cocoapods.org/using/getting-started.html#installation for instructions.[✓] Chrome - develop for the web[!] Android Studio (not installed)[✓] VS Code (version 1.73.1)[✓] Connected device (3 available)[✓] HTTP Host Availability 针对 CocoaPods 1.10.1 out of date (1.11.0 is recommended) 我们只需要下载安装就可以了： mac@192 ~ % sudo gem install -n /usr/local/bin cocoapods 通过 pod --version 查看最新版本 针对 cmdline-tools component is missing 错误 打开 Android studio 下 tools--&gt;SDK manager 中进入 SDK tools 中： 找到 Android SDK 点击 Apply 进行下载 再次 flutter doctor 运行，出现如下，则代表成功 123456789101112Doctor summary (to see all details, run flutter doctor -v):[✓] Flutter (Channel stable, 3.3.10, on macOS 12.6.1 21G217 darwin-x64, locale zh-Hans-CN)[✓] Android toolchain - develop for Android devices (Android SDK version 30.0.0)[✓] Xcode - develop for iOS and macOS (Xcode 14.1)[✓] Chrome - develop for the web[✓] Android Studio (version 2021.1)[✓] VS Code (version 1.73.1)[✓] Connected device (3 available)[✓] HTTP Host Availability• No issues found! 打开 Android studio 程序，安装 flutter： 安装 dart 安装完成，重新启动 Android studio，就可以开发 flutter 了 升级 flutter flutter SDK 所有分支 beat&#x2F;dev&#x2F;master&#x2F;stable，其中stable为稳定分支，dev和master为开发分支，运行 flutter channel 查看所有分支 12345mac@bogon ~ % flutter channelFlutter channels: master beta* stable “*” 号本地的flutter SDK 跟踪分支，切换分支 flutter channel beta 和 flutter channel master 升级 flutter sdk 和 依赖包 1flutter upgrade 该命令会同时更新 Flutter SDK 和 flutter依赖包，如果只想更新依赖包： 12flutter packages get 获取项目所有的依赖包flutter packages upgrade 获取项目所有依赖包的最新版本 IDE配置和使用Flutter 建议使用 Android Studio 和 VS Code 之一开发体验，通过 IDE和插件 可获得代码补全、语法高亮、widget编辑辅助、运行和调试等功能，帮助我们极大的提高开发效率 Android Studio VS Code Flutter官网 连接到 ios 真机设备Flutter官网 如果出现如下： flutter真机运行 无法打开“iproxy”,因为无法验证开发者 执行以下命令： 1234sudo xattr -d com.apple.quarantine sudo xattr -d com.apple.quarantine sudo xattr -d com.apple.quarantinesudo xattr -d com.apple.quarantine /Users/mac/Desktop/Flutter/flutter/bin/cache/artifacts/usbmuxd/iproxy 其中 /Users/mac/Desktop/Flutter/flutter 是你桌面flutter的路径","categories":[{"name":"Flutter-学习篇","slug":"Flutter-学习篇","permalink":"https://www.bboyzj.cn/categories/Flutter-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://www.bboyzj.cn/tags/Flutter/"}],"keywords":[{"name":"Flutter-学习篇","slug":"Flutter-学习篇","permalink":"https://www.bboyzj.cn/categories/Flutter-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}]},{"title":"OC数据结构00：入门","slug":"OC数据结构和算法/OC数据结构00：入门","date":"2022-11-23T00:55:26.000Z","updated":"2023-03-07T04:47:05.090Z","comments":true,"path":"2022/11/23/OC数据结构和算法/OC数据结构00：入门/","link":"","permalink":"https://www.bboyzj.cn/2022/11/23/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8400%EF%BC%9A%E5%85%A5%E9%97%A8/","excerpt":"","text":"概述 数据结构概念： 我们把现实中 大量复杂的问题 以特定的数据类型和特定的存储结构保存到 主存储器（内存）中，在此基础上实现某个功能（排序等）的操作叫 算法。 数据结构 &#x3D; 元素 + 元素关系 算法 &#x3D; 对数据结构的操作 算法：解决问题的方法和步骤 衡量标准： 时间复杂度：算法要执行的次数，非执行时间 空间复杂度：算法执行过程 大概要占用的最大内存 指针定义 地址 地址是内存单元的编号，其编号从 0 开始的非负整数，范围：0 – 0xFFFFFFFF x64平台下最大内存地址为 2^64 - 1 指针 指针就是地址，地址就是指针 即 * = &amp;，指针变量 是存放 内存单元地址 的变量，它内部保存的值是对应的 地址， 地址就是内存单元编号。 例子： 123456int i = 10; // 定义一个 整形变量 i 初始值 10int *p = i; // 定义一个 整形的指针变量p，变量p 指向 i的地址// 这两行等于上面两行int *p; *p = &amp;i; 结构体结构体是用户根据自己的实际需要，自定义的复合数据类型 12345678910// 学生类型typedef struct Student &#123; // 结构体定义 int age; char *name;&#125;myStudent;// 直接传递 只占用 4 byte 的指针，省时效率也高&lt;推荐用法&gt;void func(struct Student *p)&#123; print(&quot;age = %d&quot;,p)&#125; 有两种结构体的使用方式： 直接使用 1struct Student stu = &#123;12,&quot;xiaojian&quot;&#125;; 通过指针使用 12struct Student *p = &amp;stu;p -&gt; age = 31;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.bboyzj.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"OC-数据结构探索篇","slug":"OC-数据结构探索篇","permalink":"https://www.bboyzj.cn/tags/OC-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.bboyzj.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Python3学习02：运行Python方式","slug":"Python学习/Python3学习02：运行Python方式","date":"2022-07-22T07:43:10.000Z","updated":"2023-03-08T23:05:19.236Z","comments":true,"path":"2022/07/22/Python学习/Python3学习02：运行Python方式/","link":"","permalink":"https://www.bboyzj.cn/2022/07/22/Python%E5%AD%A6%E4%B9%A0/Python3%E5%AD%A6%E4%B9%A002%EF%BC%9A%E8%BF%90%E8%A1%8CPython%E6%96%B9%E5%BC%8F/","excerpt":"","text":"前言运行 Python 有三种方式： 1、交互式解析器 1$ python # Unix/Linux 2、命令行脚本 1$ python script.py # Unix/Linux 注：在执行脚本时，请检查脚本是否有可执行权限 3、集成开发环境（IDE：Integrated Development Environment）: PyCharm） PyCharm 是由 JetBrains 打造的一款 Python IDE，支持 macOS、 Windows、 Linux 系统。 PyCharm 功能 : 调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制等 PyCharm 下载地址 : https://www.jetbrains.com/pycharm/download/ PyCharm 安装教程地址 : https://www.w3cschool.cn/python3/python3-l4i738c3.html Python IDE 安装教程地址：https://www.w3cschool.cn/python/python-ide.html","categories":[{"name":"Python","slug":"Python","permalink":"https://www.bboyzj.cn/categories/Python/"}],"tags":[{"name":"Python-学习","slug":"Python-学习","permalink":"https://www.bboyzj.cn/tags/Python-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://www.bboyzj.cn/categories/Python/"}]},{"title":"Python3学习01：Mac安装Python3","slug":"Python学习/Python3学习01：Mac安装Python3","date":"2022-07-22T06:50:53.000Z","updated":"2023-03-08T23:05:08.788Z","comments":true,"path":"2022/07/22/Python学习/Python3学习01：Mac安装Python3/","link":"","permalink":"https://www.bboyzj.cn/2022/07/22/Python%E5%AD%A6%E4%B9%A0/Python3%E5%AD%A6%E4%B9%A001%EF%BC%9AMac%E5%AE%89%E8%A3%85Python3/","excerpt":"","text":"下载安装包打开 python官网 ，选择下面稳定版本的最新的包进行下载安装 安装 Python3按照安装的提示，一直下一步即可 安装配置 pip什么是 pip？ pip 这个包是 python 强大的模组下载必备工具包 打开终端输入下面的代码： 1% curl https://bootstrap.pypa.io/get-pip.py | python3 安装成功后，如下： Python3 环境变量配置想让Mac OS系统内默认的 python 版本为新安装的 python 3.10，按照下面的步骤进行配置： 1、终端输入以下命令： 12% which Python3/Library/Frameworks/Python.framework/Versions/3.10/bin/Python3 然后把第二行的路径复制下来，保存到一个地方 2、在终端输入如下命令： 1% vim ~/.bash_profile 敲击键盘上的 i 按键，进入插入模式，界面最左下方出现 INSERT 几个字母 3、使用键盘上的方向键，将白色的光标移动到随便一个空白行，输入以下命令： 12345# Setting PATH for Python 3.10 （这两行应该是注释，但是本小白不敢删）# The original version is saved in .bash_profile.pysave （这两行应该是注释，但是本小白不敢删）PATH=&quot;/Library/Frameworks/Python.framework/Versions/3.10/bin:$&#123;PATH&#125;&quot;export PATHalias python=&quot;/Library/Frameworks/Python.framework/Versions/3.10/bin/python3&quot; 引号里面的路径是刚才执行 步骤 1 保存下来的路径，然后 PATH= 后面的命令，请务必按照以上的格式删减几个字母，只保留到 bin （看清楚啊，后面没有斜杠）就可以！！！ 4、保存退出 输入结束后敲击键盘左上角的 ESC 按键，INSERT 消失，此时，按住 shift + ：键，接着输入 wq 如下图所示，然后敲击 回车键 页面会自动关闭。 5、输入下面的命令 1% source ~/.bash_profile 显示进程完成即可 6、输入下面的命令 1% vim ~/.zshrc 输入步骤3中的内容，操作类似 7、关闭终端页面，重新打开，输入下面的命令 1% python 出现下面的内容即配置环境变量成功","categories":[{"name":"Python","slug":"Python","permalink":"https://www.bboyzj.cn/categories/Python/"}],"tags":[{"name":"Python-学习","slug":"Python-学习","permalink":"https://www.bboyzj.cn/tags/Python-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://www.bboyzj.cn/categories/Python/"}]},{"title":"OC逆向05：汇编总结","slug":"OC逆向/OC逆向05：汇编总结","date":"2022-04-20T07:53:47.000Z","updated":"2022-04-21T05:27:51.000Z","comments":true,"path":"2022/04/20/OC逆向/OC逆向05：汇编总结/","link":"","permalink":"https://www.bboyzj.cn/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9105%EF%BC%9A%E6%B1%87%E7%BC%96%E6%80%BB%E7%BB%93/","excerpt":"","text":"","categories":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC逆向04：OC反汇编（下）","slug":"OC逆向/OC逆向04：OC反汇编（下）","date":"2022-04-20T07:53:33.000Z","updated":"2022-04-21T05:27:47.000Z","comments":true,"path":"2022/04/20/OC逆向/OC逆向04：OC反汇编（下）/","link":"","permalink":"https://www.bboyzj.cn/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9104%EF%BC%9AOC%E5%8F%8D%E6%B1%87%E7%BC%96%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC逆向04：OC反汇编（上）","slug":"OC逆向/OC逆向04：OC反汇编（上）","date":"2022-04-20T07:53:16.000Z","updated":"2022-04-21T05:27:41.000Z","comments":true,"path":"2022/04/20/OC逆向/OC逆向04：OC反汇编（上）/","link":"","permalink":"https://www.bboyzj.cn/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9104%EF%BC%9AOC%E5%8F%8D%E6%B1%87%E7%BC%96%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC逆向03：循环选择指针（下）","slug":"OC逆向/OC逆向03：循环选择指针（下）","date":"2022-04-20T07:52:26.000Z","updated":"2022-04-21T05:27:14.000Z","comments":true,"path":"2022/04/20/OC逆向/OC逆向03：循环选择指针（下）/","link":"","permalink":"https://www.bboyzj.cn/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9103%EF%BC%9A%E5%BE%AA%E7%8E%AF%E9%80%89%E6%8B%A9%E6%8C%87%E9%92%88%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC逆向03：循环选择指针（上）","slug":"OC逆向/OC逆向03：循环选择指针（上）","date":"2022-04-20T07:52:08.000Z","updated":"2022-04-21T05:27:33.000Z","comments":true,"path":"2022/04/20/OC逆向/OC逆向03：循环选择指针（上）/","link":"","permalink":"https://www.bboyzj.cn/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9103%EF%BC%9A%E5%BE%AA%E7%8E%AF%E9%80%89%E6%8B%A9%E6%8C%87%E9%92%88%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC逆向02：函数本质（下）","slug":"OC逆向/OC逆向02：函数本质（下）","date":"2022-04-20T07:51:43.000Z","updated":"2022-05-06T03:37:14.000Z","comments":true,"path":"2022/04/20/OC逆向/OC逆向02：函数本质（下）/","link":"","permalink":"https://www.bboyzj.cn/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9102%EF%BC%9A%E5%87%BD%E6%95%B0%E6%9C%AC%E8%B4%A8%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"前言本文主要是讲解函数的 参数、返回值、局部变量 在汇编中是如何存储的，以及 CPSR 标志寄存器 函数的参数和返回值 arm64下，函数的 参数 是存放在 x0-x7（w0-w7） 这8个寄存器里面的，如果超过 8 个参数，就会入栈 如果自定义函数时，参数最好不要超过6个（因为有两个隐藏参数 self,_cmd） 如果函数需要多个参数，可以传入数组、结构体、指针等类型 函数的 返回值 放在 x0寄存器 中 如果返回值 大于8个 字节，就会 利用内存传递 查看系统的参数汇编下面通过系统中对函数的汇编来查看系统对参数、返回值是如何操作的 1234567int sum(int a, int b)&#123; return a + b;&#125;- (void)viewDidLoad&#123; [super viewDidLoad]; sum(10, 20);&#125; 查看汇编，在跳转到sum函数之前，已经将参数存入 w0、w1 在sum函数中，读取w0、w1，放入w8、w9。然后将相加后的结果放入w0（即返回值在w0寄存器） 自己优化实现sum运行发现，其结果与sum函数是一致的，结果都是30 1234567891011121314151617&lt;!--asm.s--&gt;.text.global _suma_suma: add x0, x0, x1 ret &lt;!--调用--&gt;int suma();- (void)viewDidLoad&#123; [super viewDidLoad]; printf(&quot;%d&quot;,suma(10, 20));&#125;&lt;!--查看打印结果--&gt;30 编译器优化来看一下代码的汇编 12345678int test(int a, int b, int c, int d, int e, int f, int g, int h, int i)&#123; return a + b + c + d + e + f + g + h + i;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; test(1, 2, 3, 4, 5, 6, 7, 8, 9);&#125; test函数断住，查看汇编 以下是 viewDidLoad 栈空间的存入分析过程 以下是 test 函数的汇编分析 编译器优化 将debug模式改成release模式，此时再来查看汇编代码，发现没有test函数，被优化掉了 如果非要执行 test，可以这样写 1234- (void)viewDidLoad&#123; [super viewDidLoad]; printf(&quot;%d&quot;, test(1, 2, 3, 4, 5, 6, 7, 8, 9));&#125; 汇编代码如下，发现优化后的test函数在汇编中，其本质是一个 数，也就是 test函数的返回值（相当于将 printf(&quot;%d&quot;, test(1, 2, 3, 4, 5, 6, 7, 8, 9)); 直接优化成了 printf(&quot;%d&quot;, 45);) 通过汇编实现函数 定义函数声明及调用 1234567int funcA(int a, int b);- (void)viewDidLoad &#123; [super viewDidLoad]; int a = funcA(10, 20); printf(&quot;%d&quot;, a);&#125; 汇编实现 funcA 12345678910111213141516171819202122&lt;!--sam中--&gt;.text.global _funcA, _sum_funcA: sub sp, sp, #0x10 stp x29, x30, [sp] // 保护lr bl _sum ldp x29, x30, [sp] add sp, sp, #0x10 ret_sum: add x0, x0, x1 ret&lt;!--vc中--&gt;int funcA();- (void)viewDidLoad&#123; [super viewDidLoad]; printf(&quot;%d&quot;,funcA(10,20));&#125; 运行结果如下 130 【说明】： 关于b指令：只是跳转，不改变lr寄存器 拉伸空间和参数个数有没有关系？ 有关系，参数越多时，如果寄存器放不下，就需要用到内存。就会将栈空间放大，影响栈空间的不仅仅是参数个数，还有局部变量 函数的返回值如果返回值是 一个结构体，一个寄存器放不下，这是什么情况？ 有以下代码，运行查看其汇编： 123456789101112131415161718192021222324struct str &#123; int a; int b; int c; int d; int f; int g;&#125;;struct Str getStr(int a, int b, int c, int d, int f, int g)&#123; struct Str str1; str1.a = a; str1.b = b; str1.c = c; str1.d = d; str1.f = f; str1.g = g; return str1;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; struct Str str2 = getStr(1, 2, 3, 4, 5, 6);&#125; 断点运行，以下是 viewDidLoad 函数的汇编","categories":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC逆向02：函数本质（上）","slug":"OC逆向/OC逆向02：函数本质（上）","date":"2022-04-20T07:51:12.000Z","updated":"2022-04-29T08:15:49.000Z","comments":true,"path":"2022/04/20/OC逆向/OC逆向02：函数本质（上）/","link":"","permalink":"https://www.bboyzj.cn/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9102%EF%BC%9A%E5%87%BD%E6%95%B0%E6%9C%AC%E8%B4%A8%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"前言本文的主要目的是理解 函数栈 以及涉及的相关 指令 在讲函数的本质之前，首先需要讲下以下几个概念 栈、SP、FP 常识栈 栈：是一种 具有特殊的访问方式的存储空间（即 后进先出 Last In First Out，LIFO） 高地址往低地址存数据（存：高--&gt;低） 栈空间开辟：往低地址开辟（开辟：高--&gt;低） SP和FP寄存器 SP寄存器：在任意时刻会 保存我们栈顶的地址 FP寄存器（也称为 x29 寄存器）：属于通用寄存器，但是在某些时刻（例如函数嵌套调用时）可以 利用它保存栈底的地址 1234注意：* arm64开始，取消了32位的LDM、STM、PUSH、POP指令，取而代之的是ldr/ldp、str/stp（r和p的区别在于处理的寄存器个数，r表示处理1个寄存器，p表示处理两个寄存器）* arm64中，对栈的操作是 16字节对齐 的 以下是arm64之前和arm64之后的一个对比 在arm64之前，栈顶指针是压栈时一个数据移动一个单元 在arm64开始，首先是 从高地址往低地址开辟一段空间（由编译器决定），然后再放入数据，所以不存在push、pop操作。这种情况可以通过内存读写指令（ldr/ldp、str/stp）对其进行操作 函数调用栈以下是常见的函数调用 开辟（sub） 以及 恢复栈空间（add） 的汇编代码 123456789// 开辟栈空间sub sp, sp, #0x40 ; 拉伸（开辟）0x40（64字节）空间stp x29, x30, [sp, #0x30] ; x29\\x30 寄存器入栈保护add x29, sp, #0x30 ; x29指向栈帧的底部... ldp x29, x30, [sp, #0x30] ; 恢复x29/x30 寄存器的值// 恢复栈空间add sp, sp, #0x40 ; 栈平衡ret 内存读写指令注意： 读/写数据 都是往 高地址 读/写 写数据：先拉伸栈空间，在拿sp进行写数据，即 先申请空间再写数据 str（store register）指令： 将数据从寄存器中读出来，存到 内存 中（即一个寄存器是 8字节=64位） ldr（load register）指令： 将数据从内存中读出来，存到 寄存器 中 此时 ldr 和 str 的变种 ldp和stp 还可以操作 2个 寄存器（即 16字节=128位） 堆栈练习使用32个字节空间作为这段程序的栈空间，然后利用栈将x0和x1的值进行交换 12345sub sp, sp, #0x20 ;拉伸栈空间32个字节stp x0, x1, [sp, #0x10] ;sp往上加16个字节（两个8字节的寄存器），存放x0和x1ldp x1, x0, [sp, #0x10] ;将sp偏移16个字节的值从取出来，放入x1和x0，内存是temp（寄存器里面的值进行交换了）add sp, sp, #0x20 ;栈平衡ret ;返回 栈的操作如下图所示： 调式查看栈 在 asm文件中写入如下代码： 123456789.text.global _A,_B_B: sub sp, sp, #0x20 stp x0, x1, [sp, #0x10] ldp x1, x0, [sp, #0x10] add sp, sp, #0x20 ret 在 VC 中调用 1234567891011121314@interface ViewController ()@end@implementation ViewController// 函数的声明int B();- (void)viewDidLoad &#123; [super viewDidLoad]; B(); &#125; 断点到 sub sp, sp, #0x20： 进行调试，如下图 由上图可知，sp的初始地址是 0x000000016f491a80，正常由高地址往低地址 拉伸（开辟） #0x20个地址后，sp的最新地址为 0x000000016f491a80 - 0x20 = 0x000000016f491a60 按住 control Step into，往下走一步查看结果 此时 x0，x1 的默认地址如下图 stp x0, x1, [sp, #0x10]：将 sp 的偏移 #0x10 写入 x0，x1，结果如下图： ldp x1, x0, [sp, #0x10]：将 sp 的内存地址加上 #0x10，读取 x0，x1 的数据并交换结果如下； add sp, sp, #0x20：走到栈平衡，最后将 sp 指针地址加上 #0x20，即 sp恢复了，此时的a和b仍然在内存中，等待着下一轮栈拉伸后数据的写入覆盖。如果此时读取，读取到的是垃圾数据 如果上面默认的地址不方便看，你可以重写 register write x0 0xa 和 register write x1 0xb 的来断点调试，如下图： 疑问：栈空间不断开辟，死循环，会不会崩溃？ 在这里我们将会处理上篇 OC逆向01：初始汇编 文章中文末遗留的问题 下面我们通过一个汇编代码来演示 123456789101112131415161718&lt;!--asm.s--&gt;.text.global _B_B: sub sp,sp,#0x20 stp x0,x1,[sp,#0x10] ldp x1,x0,[sp,#0x10];寄存器里面的值进行交换 bl _B add sp,sp,#0x20 ret &lt;!--调用--&gt;int B();int main(int argc, char * argv[]) &#123; B();&#125; 运行结果发现：死循环会崩溃，会导致 堆栈溢出 bl、ret指令bl标号 b：转到标号处执行指令（即b） 将 下一条指令的地址 放入通用寄存器 lr（x30） 中 等到B函数ret时，通过lr获取回家的路（注：lr就是保存回家的路） ret 默认使用 lr(x30)寄存器 的值，通过底层指令提示CPU此处作为下条指令地址 arm64平台的特色指令，它面向硬件做了优化处理的 练习下面通过汇编代码来演示 bl、ret指令 asm文件下代码如下 123456789101112.text.global _A, _B_A: mov x0, #0xaaaa bl _B mov x0, #0xaaaa ret_B: mov x0, #0xbbbb ret vc中执行如下代码 1234567891011// 函数的声明int A();int B();- (void)viewDidLoad &#123; [super viewDidLoad]; printf(@&quot;A&quot;); A(); printf(@&quot;B&quot;);&#125; 断点 mov x0，#0xaaaa 运行：发现 lr 保存了下一条指令的地址是 1f78 往下执行 bl _B ：此时 x0 的地址为 0xaaaa 继续执行 bl _B，跳转到 B，此时的 lr 会变成 A 中 bl 的下一条指令的地址 1f20 执行完B中的 mov x0, #0xbbbb，x0 变成 bbbb 执行 B 中的 ret，lr 会回到 A 中 1f20 继续执行 A 中的 ret，会再次回到 1f20 走到这里，发现 死循环了，主要是因为 lr 一直是 1f20，ret 只会看 lr。 其中 pc 是指 接下来要执行的内存地址，ret 是指让CPU将 lr 作为接下来执行的地址（相当于将lr赋值给pc） 疑问1：此时B回到A没问题，那么A回到viewDidLoad怎么回事呢？ 需要在A的bl之前 保护lr寄存器 疑问2：是否可以保存到其他寄存器上？ 答案是 不可以，原因是不安全，因为你不确定这个寄存器会在什么时候被别人使用 正确做法：lr保存到栈区 系统中函数嵌套是如何返回的？ 下面我们来看一下系统是如何操作的，例如：d -&gt; c -&gt; viewDidLoad 123456789101112void d()&#123;&#125;void c()&#123; d(); return;&#125;- (void)viewDidLoad&#123; [super viewDidLoad]; printf(&quot;A&quot;); c(); printf(&quot;B&quot;);&#125; 查看汇编，断点在 c() 函数 stp x29,x30,[sp,#-0x10]：边开辟栈，边写入，其中 x29就是fp（栈底），x30是lr，! 的含义是，将[]中计算的结果给sp，即 sp-=0x10 ldp x29, x30, [sp], #0x10：读取sp执行地址的数据，放入x29、x30；[sp], #0x10 表示 sp=sp+0x10，以此保证 栈平衡 【结论】：当有函数嵌套调用时，将上一个函数的地址通过 lr（即x30） 放在栈中保存，保证可以找到回家的路，如下图所示 自定义汇编代码完善：_A中保存回家的路所以根据系统的函数嵌套操作，最终在_A中增加了如下汇编代码，用于保存回家的路 123456789101112131415161718&lt;!--导致死循环的汇编代码--&gt;_A: mov x0. #0xaaaa bl _B mov x0, #0xaaaa ret &lt;!--增加lr保存：可以找到回家的路--&gt;_A: sub sp, sp, #0x10 // 拉伸 str x30, [sp] // 存 mov x0, #0xaaaa // 保护lr寄存器，存储到栈区域 bl _B mov x0, #0xaaa ldr x30, [sp] // 修改lr，用于A找到回家的路 add sp, sp, #0x10 // 栈平衡 ret 修改_A、_B：改成简写形式 其中lr是x30的一个别名 12345678910111213141516171819202122232425262728293031_A: sub sp, sp, #0x10 // 拉伸 str x30, [sp] // 存 mov x0, #0xaaaa // 保护lr寄存器，存储到栈区域 bl _B mov x0, #0xaaa ldr x30, [sp] // 修改lr，用于A找到回家的路 add sp, sp, #0x10 // 栈平衡 ret_B: mov x0, #0xbbbb ret &lt;!--改成简写形式--&gt;_A: sub sp, sp, #0x10 // 拉伸 str x30, [sp] // 存 mov x0, #0xaaaa // 保护lr寄存器，存储到栈区域 bl _B mov x0, #0xaaa // ldr x30, [sp] // 修改lr，用于A找到回家的路 // add sp, sp, #0x10 // 栈平衡 ldr x30, [sp], #0x10 // 将sp的值读取出来，给到x30，然后sp += 0x10 ret_B: mov x0, #0xbbbb ret 【断点调试】: str x30, [sp, #-0x10]：查看此时 sp寄存器 的地址 sp = 0x000000016b411a80，lr 的地址 lr = 0x00000001003d9f90 执行到 mov x0, #0xaaaa：sp变了，lr未变 执行 mov x0, #0xaaaa，x0 为 aaaa 执行A中的 bl _B：跳转到B，此时 lr = 0x0000000100929f40，x0 变成 bbbb，sp = 0x000000016f4d9a70 执行B的ret：从B回到A，此时lr还是 lr = 0x0000000100929f40 执行A中的 ldr x30, [sp], #0x10，发现此时 lr变了为 lr = 0x0000000100929f90，sp也变了为 sp = 0x000000016f4d9a80。从这里可以看出，A找到了回家的路 x30寄存器 x30 寄存器 存放 的是 函数的返回地址，当ret指令执行时刻，会寻找x30寄存器保存的地址值 注意：在函数嵌套调用时，需要将x30入栈 lr 是 x30 的别名 sp 栈里面的操作必须是 16字节对齐，崩溃是在栈的操作时挂的 总结 栈：是一种具有特殊的访问方式的存储空间（先进后出，Last In First Out，FIFO） ARM64里面对 栈的操作 是 16字节对齐 的 SP和FP寄存器 SP寄存器在任意时刻会 保存栈顶的地址 FP寄存器也称为 x29寄存器，属于 通用寄存器，但是在某些时刻利用它 保存栈底的地址 栈的读写指令 读：ldr（load register）指令 LDR、LDP 写：str（store register）指令 STR、STP 汇编练习 指令 sub sp，sp，$0x10：拉伸栈空间 16 字节 stp x0，x1，[sp]：sp所在位置存放x0、x1 bl 指令 跳转指令：bl 标号，表示程序执行到标号处。将下一条指令的地址保存到lr寄存器 B 代表着 跳转 L 表示 lr（x30）寄存器 ret 指令 类似函数的 return 让CPU执行lr寄存器所指向的指令 避免嵌套函数无法回去：需要保护bl（即 lr寄存器，存放回家的路 ），保存在当前函数自己的栈空间","categories":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC逆向01：初始汇编","slug":"OC逆向/OC逆向01：初始汇编","date":"2022-04-20T07:50:53.000Z","updated":"2022-04-29T01:15:48.000Z","comments":true,"path":"2022/04/20/OC逆向/OC逆向01：初始汇编/","link":"","permalink":"https://www.bboyzj.cn/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9101%EF%BC%9A%E5%88%9D%E5%A7%8B%E6%B1%87%E7%BC%96/","excerpt":"","text":"前言在逆向开发中，非常重要的一个环节就是 静态分析，众所周知，手机上安装 APP 其本质是一个 二进制文件，因为iPhone手机本质上执行的指令是二进制，是由手机上的 CPU 执行的；而静态分析是建立在分析二进制上面的。所以在学习逆向之前，需要提前了解相关的汇编知识 汇编语言的发展机器语言是由 0和1 组成的机器指令，表示特定的功能，如下所示： 1234加：0100 0000减：0100 1000乘：1111 0111 1110 0000除：1111 0111 1111 0000 汇编语言（assembly language）由于使用机器语言表示时不方便记忆，于是开始使用 助记符 来代替机器语言，例如下面使用助记符表示的 加减乘除 1234加：INC EAX 通过编译器 0100 0000减：DEC EAX 通过编译器 0100 1000乘：MUL EAX 通过编译器 1111 0111 1110 0000除：DIV EAX 通过编译器 1111 0111 1111 0000 高级语言（High-level programming language）在后期，为了更加高效的编程，在汇编语言的基础上有了更高级的语言，例如：C/C++/Java/OC/Swift 等，这些语言更加接近人类的自然语言，例如C语言表示加减乘除 1234加：A+B 通过编译器 0100 0000减：A-B 通过编译器 0100 1000乘：A*B 通过编译器 1111 0111 1110 0000除：A/B 通过编译器 1111 0111 1111 0000 最终的代码在终端设备上显示的过程如下： 【说明】： 汇编语言 与 机器语言 是 --对应 的关系，每一条机器指令都有与之对应的汇编指令 汇编语言 可以通过 编译 得到 机器语言，机器语言 可以通过 反编译 得到 汇编语言 高级语言 可以通过 编译 得到 汇编语言/机器语言，但 汇编汇演/机器语言 几乎不可能还原成高级语言 不同的 高级语言 可以得到 同样的 汇编语言，但是同一个 汇编语言 无法推断出用什么高级语言 不同的 CPU架构，而CPU架构对应不同的 指令集 汇编语言的特点汇编语言主要有以下几个特点： 可以 直接访问、控制 各种硬件设备，比如 存储器、CPU等，能最大限度地发挥硬件的功能 能够不受编译器的限制，对生成的二进制代码进行完全的控制 目标代码简短，占用内存少，执行速度快 汇编指令是机器指令的 助记符，同机器指令一一对应，每一种CPU都有自己的机器指令&#x2F;汇编指令集 知识点过多，要求过高，需要开发者对CPU等硬件结构有所了解，不易于编写、调式，以及维护 不区分大小写，例如mov和MOV是一样的 汇编语言的用途（哥 我学了能干啥？）按理说，汇编这么难，为什么还要学呢？以及学了能干什么？ 汇编学习的目的任何高级语言最终都会被编译汇编，学习了汇编的相关知识，可以更好的日常开发，学习探索中帮助我们更好的排查问，理解底层运行的机制，大致分为以下几点： 是理解整个计算机系统的最佳起点和最有效途径 为编写高效代码打下基础 理解代码的本质，例如： 函数的本质是什么？ ++a底层是如何执行的？ 编译器在底层到底帮我们做了哪些工作？ DEBUG模式和RELEASE模式到底有哪些地方是不同的？以及被我们忽略的？ 汇编使用的场景 可以 编写驱动程序、操作系统，例如Linux内核的某些关键字 对性能要求极高的程序或代码片段，可 与高级语言混合使用（称为内联汇编） 用于 软件安全方面 病毒的分析与防治 逆向、加壳、脱壳、破解、外挂、免杀、加解密、黑客等 所以综上所述，汇编时所有👨🏻‍💻都需要了解的一门非常重要的语言，这也是为什么大学生中计算机相关专业学生的必修课，就好比修房子，地基稳了，高楼才能平地起 汇编语言的种类目前讨论比较多的汇编语言有： 8086汇编（8086处理器是16bit的CPU） Win32汇编 Win64汇编 ARM汇编（嵌入式、Mac、iOS） … 我们iPhone里面用到的是 ARM汇编，但是不同的设备也有差异，因CPU的架构不同 必备常识想要学好汇编，需要有以下几个常识： 1、首先需要了解CPU等硬件的架构 2、APP&#x2F;程序的执行过程 可执行文件：程序&#x2F;APP在本地磁盘的文件 image（镜像文件）：可执行文件被装载到内存的文件（在早起，其本质与可执行文件是一模一样的） 内存中除了 指令，还有 数据，但都是 0和1 组合，CPU是如何区分的？是通过CPU上的部件CPU寄存器来区分 3、硬件相关最为重要的是CPU&#x2F;内存 4、在汇编中，大部分指令都是和CPU和内存相关的 总线总线 是CPU和内存之间的桥梁，如下图所示，是iPhoneX上的A11（CPU芯片） 从图中可以看出：每一个CPU芯片都有很多管脚，这些管脚和总线相连，CPU通过总线跟外部件进行交互 总线：是一根根导线的集合 总线的分类总线主要分为三类，如下图所示： 1、地址总线：CPU是通过地址总线来指定存储单元的 2、数据总线：CPU与内存&#x2F;其他部件之间的数据传送通道 3、控制总线：CPU通过控制总线对外部器件进行控制 举例：CPU从内存的3号单元读取数据 1、CPU想操作内存中的数据，首先需要找到内存地址：CPU通过地址总线，将3这个地址传递给内存你，即寻址到内存的3号单元 2、需要操作3号单元的数据，还需要确定是读还是写：CPU通过控制总线告诉内存需要进行的操作，假设是读 3、内存知道了CPU想要进行的操作：内存将3号单元的数据通过数据线传递给CPU 地址总线 它的宽度决定了 CPU的寻址能力，即地址总线决定了CPU所能访问的最大内存空间的大小，例如：10根地址线 能访问的最大内存是 2^10 = 1024 位二进制数据（即 1KB ） 地址总线是地址线数量之和 8086 的 地址总线 宽度是 20，所以寻址能力是 1M（即2^20） 内存地址的单元是 字节byte（简写B），每个字节里面可以放 8位（即bit），以下是内存条的图示： 注意区分 数量单位 和 容量单位 数量单位：1M = 1024K，1K = 1024 容量单位：字节byte（B） 1024B = 1KB，1024KB = 1MB，IBM银行的独立系统是以2字节为一个单位，常用的电脑是以1字节为一个单位 网络宽带 100M=100Mbps（比特位，每秒传输 100/8 = 12.5MB/s） 数据总线 它的宽度决定了 CPU的单次数据传送量（即吞吐量），也就是 数据传送速度 即CPU和外界数据的传送速度 每条数据线一次只能传输一位二进制数据，例如：8根 数据线 一次 可传送 一个8位 二进制数据（即一个字节的数据） 数据总线是数据线数量之和 8086 的 数据总线 总宽度是 16，所以单次最大传送 2个字节 的数据 我们常说的32位（4字节）、64位（8字节）CPU，这里的32、64指的就是数据吞吐量 控制总线 它的宽度决定了 CPU对其他器件的控制能力，能有多少中控制，即CPU对外部器件的控制能力 控制总线是控制线数量之和 小练习 一个CPU的寻址能力为8KB，那么它的地址总线的宽度为 2^13 答：我们知道 10根 -&gt; 2^0 -&gt; 1KB，所以，8KB -&gt; 2^3 -&gt; 13根 内存 CPU是通过 总线 和硬件设备连接的 内存有RAM主存储器、RAM主存储器（内存条） 下图是按照物理地址划分的内存，有 主存储器、显存地址、显卡地址、网卡地址、系统地址 其中内存中的 低地址 是给 用户用的，高地址 是给 系统用的，如下所示： 内存地址空间的大小受CPU地址总线宽度的限制，8086的地址总线宽度为20，可以定位2^20个不同的内存单元（内存地址范围0x00000~0xFFFFF），所以8086的内存空间大小为1MB 0x00000~0x9FFFF：主存储器，可读可写 0xA0000~0xBFFFF：向显存中写入数据，这些数据会被显卡输出到显示器，可读可写 0xC0000~0xFFFFF：存储各种硬件&#x2F;系统信息，只读 进制很多人学不好进制，原因是总以十进制为依托去考虑其他进制，需要运算的时候也总是先转换为十进制，在转换为其他进制，其实这种方式是错的 我们为什么一定要转换成十进制呢？仅仅是因为我们对十进制最熟悉，所以才转换 每一种进制都是完美的，想学号进制首先要忘掉十进制，也要忘掉进制间的转换 进制的定义 八进制由8个符号组成：0 1 2 3 4 5 6 7 逢八进一 十进制由10个符号组成：0 1 2 3 4 5 6 7 8 9 逢十进一 N进制就是由N个符号组成：逢N进一 123456789&lt;!--练习--&gt;1+1在___情况下等于3&lt;!--答案--&gt;十进制由10个符号组成: 0 1 3 2 8 A B E S 7 逢十进一如果这样定义十进制：1+1等于3&lt;!--目的--&gt;传统定义的十进制和自定义的十进制不一样，如果不告诉别人符号表，别人是无法拿到具体的数据的。这样的应用场景主要是用于加密 进制的运算八进制八进制加法表 1234567891011120 1 2 3 4 5 6 7 10 11 12 13 14 15 16 1720 21 22 23 24 25 26 27...1+1 = 2 1+2 = 3 2+2 = 4 1+3 = 4 2+3 = 5 3+3 = 61+4 = 5 2+4 = 6 3+4 = 7 4+4 = 10 1+5 = 6 2+5 = 7 3+5 = 10 4+5 = 11 5+5 = 121+6 = 7 2+6 = 10 3+6 = 11 4+6 = 12 5+6 = 13 6+6 =141+7 = 10 2+7 = 11 3+7 = 12 4+7 = 13 5+7 = 14 6+7 =15 7+7 = 16 八进制乘法表 123456780 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27...1*1 = 1 1*2 = 2 2*2 = 4 1*3 = 3 2*3 = 6 3*3 = 11 1*4 = 4 2*4 = 10 3*4 = 14 4*4 = 201*5 = 5 2*5 = 12 3*5 = 17 4*5 = 24 5*5 = 311*6 = 6 2*6 = 14 3*6 = 22 4*6 = 30 5*6 = 36 6*6 = 441*7 = 7 2*7 = 16 3*7 = 25 4*7 = 34 5*7 = 43 6*7 = 52 7*7 = 61 做个练习 2 + 3 &#x3D; ___，2 * 3 &#x3D; ___，4 + 5 &#x3D; ___，4 * 5 &#x3D; ___ 277 + 333 &#x3D; ___，276 * 54 &#x3D; ___， 237 - 54 &#x3D; ___ ，234&#x2F;4 &#x3D; ___ 第一排的计算，我们可以很好的得出结论但是第二排涉及数据较大，如何计算呢？下面以 277 + 333 为例，计算过程如下： 1234实际上是以加法表为基本的每个位置相加 277 最后一位相加 倒数第二位相加 第一位相加+ 333 -&gt; 7+3=12 -&gt; 7+3=12 -&gt; 2+3=5 -&gt; 所以最后的结果是632 保留2进1 保留2+1=3，进1 保留5+1=6 二进制二进制的简写形式 12345 二进制: 1 0 1 1 1 0 1 1 1 1 0 0三个二进制一组: 101 110 111 100 八进制: 5 6 7 4四个二进制一组: 1011 1011 1100 十六进制: b b c 使用二进制从0到1111：0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 发现这样使用二进制太麻烦，所以将其改为更简单一点的符号 0 1 2 3 4 5 6 7 8 9 A B C D E F 这就是十六进制了 数据的宽度数学上的数字是没有大小限制的，可以无限大 但是在计算机中，由于硬件的制约，数据都是有长度限制的（称为 数据宽度），超过最多宽度的数据会被丢弃 1234567891011121314#import &lt;UIKit/UIKit.h&gt;#import &quot;AppDelegate.h&quot;int test()&#123; int cTemp = 0x1FFFFFFFF; return cTemp;&#125;int main(int argc, char * argv[]) &#123; printf(&quot;%x\\n&quot;,test()); @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 打断点在 int cTemp 处和 return cTemp 处，调试结果发现 0 溢出了： 也可以此处通过获取的地址，然后在 Debug-Debug Workflow-ViewMemory 中输入地址（0x000000016d82f70c） 查看 计算机中常见的数据宽度 位（bit）：1个位 就是 1个二进制，即 0或1 字节（byte）：1个字节 由 8个bit 组成，内存中的最小单元byte 字（Word）：1个字 由 两个字节 组成（16位），第2个字节分别称为 高字节和低字节 双字（DoubleWork）：1个双字由两个字组成（32位） 那么计算机存储数据它分为 有符号数和无符号数，如下图所示： 无符号数，直接换算 有符号数，符号放在第1位，第1位是0即 正数，为1即 负数： 正数：0 1 2 3 4 5 6 7 负数：F E D C B A 9 8-1 -2 -3 -4 -5 -6 -7 -8 自定义进制符号【练习1】 现在有10进制数10个符号分别为：2，9，1，7，6，5，4，8，3，A 逢10进1，那么： 123 + 234 &#x3D; （AA6） 12345678910111213141516171819202122十进制: 0 1 2 3 4 5 6 7 8 9自定义: 2 9 1 7 6 5 4 8 3 A(十进制10)92 99 91 97 96 95 94 98 93 9A 12 19 11 17 16 15 14 18 13 1A 72 79 71 77 76 75 74 78 73 7A 62 69 61 67 66 65 64 68 63 6A 52 59 51 57 56 55 54 58 53 5A 42 49 41 47 46 45 44 48 43 4A 82 89 81 87 86 85 84 88 83 8A 32 39 31 37 36 35 34 38 33 3A 922 (00)2 (01)9 (02)1 (03)7 (04)6 (05)5 (06)4 (07)8 (08)3 (09)A(10)92 (11)99 (12)91 (13)97 (14)96 (15)95 (16)94 (17)98 (18)93 (19)9A(20)12 (21)19 (22)11 (23)17 (24)16 (25)15 (26)14 (27)18 (28)13 (29)1A(30)72 (31)79 (32)71 (33)77 (34)76 (35)75 (36)74 (37)78 (38)73 (39)7A(40)62 (41)69 (42)61 (43)67 (44)66 (45)65 (46)64 (47)68 (48)63 (49)6A(50)52 59 51 57 56 55 54 58 53 5A(60)42 49 41 47 46 45 44 48 43 4A(70)82 89 81 87 86 85 84 88 83 8A(80)32 39 31 37 36 35 34 38 33 3A(90)922 刚才通过10进制运算可以转换，然后查表，但是如果是其他进制，就不能转换，要学会直接查表。 【练习2】 现在有9进制数9个符号，分别是：2，9，1，7，6，5,4，8，3 逢9进1，那么：123 + 234 &#x3D; （9926） 12345678910111213141516171819202122十进制: 0 1 2 3 4 5 6 7 8 自定义: 2 9 1 7 6 5 4 8 3 92 99 91 97 96 95 94 98 93 12 19 11 17 16 15 14 18 13 72 79 71 77 76 75 74 78 73 62 69 61 67 66 65 64 68 63 52 59 51 57 56 55 54 58 53 42 49 41 47 46 45 44 48 43 82 89 81 87 86 85 84 88 83 32 39 31 37 36 35 34 38 33 922 (00)2 (01)9 (02)1 (03)7 (04)6 (05)5 (06)4 (07)8 (08)3 (10)92 (11)99 (12)91 (13)97 (14)96 (15)95 (16)94 (17)98 (18)93 (20)12 19 11 17 16 15 14 18 13 (30)72 79 71 77 76 75 74 78 73 (40)62 69 61 67 66 65 64 68 63 (50)52 59 51 57 56 55 54 58 53 (60)42 49 41 47 46 45 44 48 43 (70)82 89 81 87 86 85 84 88 83 (80)32 39 31 37 36 35 34 38 33 (90)922 ... CPU和寄存器内部部件之间是由 总线 连接，如下图所示： CPU除了有 控制器、运算器，还有 寄存器，其中寄存器的作用就是 运行数据的临时存储 CPU的运算速度是非常快的，为了性能 CPU 在内部 开辟了一小块临时存储区域，并在进行运算时先将数据从内存中 复制 到这一小块临时区域中，运算就在这一小块临时存储区进行，称这一小块临时存储区域为 寄存器 【针对arm64的CPU来说】 如果寄存器以 x 开头，则表明是一个 64位（84/8=8字节）的寄存器z。 如果寄存器以 w 开头，则表明是一个 32位（32/8=4字节） 的寄存器 在系统中没有提供16位和32位的寄存器供访问和使用，其中 32位的寄存器是64位寄存器的低32位的部分，并不是独立存在的 对于程序来说，CPU中最主要的部件是 寄存器，可以通过改变寄存器的内容来实现对CPU的控制 不同CPU，寄存器的个数和结构是不相同的 查看寄存器默认情况下是不显示的，如下图： 选中后，会出现三种寄存器，如下图： 浮点和向量寄存器因为浮点数的存储以及其运算的特殊性，CPU中专门提供 浮点寄存器 来处理浮点数 浮点寄存器 64位：D0-D31 32位：S0-S31 现在 CPU支持向量运算（向量运算在图形处理相关的领域用的非常多），为了支持向量计算，系统也提供了众多的向量寄存器 向量寄存器 128 位：V0 - V31 通用寄存器 通用寄存器也称为 数据地址寄存器。通常用来 做数据计算的临时存储、累加、计数、地址保存等功能。定义这些寄存器的作用主要是用于在CPU指令中保存操作数，在CPU中当做一些常规变量来使用 ARM64中 64位：x0-x30，XZR(寄存器) 32位：W0-W30,WZR(零寄存器) arm64拥有 32个64位的通用寄存器X0-X30，以及XZR（零寄存器）。这些通用寄存器有时也有特定用途 那么 w0-w28 这些32位的，因为64位CPU可以兼容32位，所以可以只使用64位寄存器的低32位 例如 w0就是x0的低32位 1注意：了解过8086汇编的一定知道，还有一种特殊的寄存器段寄存器：CS、DS、SS 、ES。这四个寄存器主要用来保存这些段的基地址，是属于Intel架构的CPU的，在arm中并没有 通常，CPU会先将内存中的数据存储到通用寄存器中，然后再对寄存器中的数据进行运算 例子：假设内存中有块红色内存空间的值是3，现在想把它的值加1，并将结果存储到蓝色内存空间，如何做呢？ CPU首先会将红色内存空间的值放到X0寄存器中：mov X0，红色内存空间 然后让X0寄存器与1相加：add X0,1 最后将值赋值给内存空间：mov 蓝色内存空间，X0 PC寄存器 为 指令指针寄存器，它 指示了CPU当前要读取指令的地址 在内存&#x2F;磁盘中，指令和数据没有任何区别，都是二进制信息 CPU在工作时，将有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义 例如 1110 0000 0000 0011 0000 1000 1010 1010 可以当做数据 0xE003008AA 也可以当做指令 mov x0,x8 CPU根据什么将内存中的信息看作指令呢？ CPU将pc指向的内存单元的内容看作指令 如果内存中的某段内容曾经被CPU执行过，那么它所在的内存单元必然被pc指向过 寄存器的案例分析下面通过以下代码的例子来分析 1234567891011121314#import &lt;UIKit/UIKit.h&gt;#import &quot;AppDelegate.h&quot;int test()&#123; int cTemp = 0x1FFFFFFFF; return cTemp;&#125;int main(int argc, char * argv[]) &#123; printf(&quot;%x\\n&quot;,test()); @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 以下是demo的汇编图示 pc寄存器调式 打印 pc 寄存器，现在是 d613c 按住 control+Setp into，继续打印 除了读还可以写: register write pc 0x1025d6134 register read pc 此时是读不出来的，因为断点断住了，如果step into ，此时断点断在哪里？ 高速缓存iPhoneX上搭载的arm处理器 A11，它的1级缓存的容量是64Kb，2级缓存的容量是8M CPU每执行一条指令前都需要从内存中将指令读取到CPU内存并执行，而寄存器的运行速度相比内存读写要快很多，为了性能，CPU还集成了一个 高速缓存区域。当程序运行时，先将要执行的指令代码以及数据复制到高速缓存中（由操作系统完成），然后CPU直接从高速缓存依次读取指令来执行 bl指令 CPU从何处执行指令，是由pc中的内容决定的，可以 通过改变pc的内容来控制CPU执行目标指令 arm64提供了一个 mov指令（传送指令），可以用来改变大部分寄存器的值，例如 mov x0,#10、mov x1,#20 但是，mov指令并不能用于设置pc的值，arm64没有提供这样的功能 arm64提供了另外的指令来 修改pc的值，这些指令统一称为 转移指令，其中最简单的是 bl指令 bl指令练习现在有两段代码，假设程序先执行A，请写出指令执行顺序，最终寄存器x0的值是多少？ 1234567891011121314151617181920212223242526_A: mov x0,#0xa0 mov x1,#0x00 add x1, x0, #0x14 mov x0,x1 bl _B mov x0,#0x0 ret_B: add x0, x0, #0x10 ret // 分析流程流程： mov x0,#0xa0 -- x0：0xa0 mov x1,#0x00 -- x1：0x00 add x1, x0, #0x14 -- x1：0xa0+0x14=0xb4 mov x0,x1 -- x0：0xb4 bl _B -- 跳转到B add x0, x0, #0x10 -- x0：0xb4+0x10=0xc4 ret -- 回到bl跳转的下一行 mov x0,#0x0 -- x0：0x00// 结果x0的值：0x00 汇编代码验证下面来写一段汇编代码验证（command + n -&gt; empty -&gt; asm.s）（汇编代码文件，会编译成源码） 如何执行呢？ 在VC中定义函数的声明 在 mov x0,#0xa0 执行处加断点，并执行程序，开启汇编调试 按住 control+step into，进入A的具体汇编 继续 control+step into，到 bl _B 处 按住 control+step into，进入汇编代码B 执行到A的ret 疑问： 发现走到这里死循环了，这是为什么呢？预知后事如何，请看下一篇 总结 1、汇编概述 使用 助记符代替机器指令 的一种编程语言 汇编和机器指令是 一一对应 的关系，拿到二进制就可以反汇编 由于汇编和CPU的指令集是对应的，所以汇编不具备移植性 2、总线：是由一堆导线的集合 地址总线：其宽度决定了寻址能力 数据总线：其宽度决定了CPU数据的吞吐量 控制总线：其宽度决定了CPU对其他器件的控制能力 3、进制 任意进制都是由对应个数的符号组成的，符号可以自定义 2&#x2F;8&#x2F;16是相对完美的进制，他们之间的关系 3 个二进制使用一个 8进制 标识 4 个二进制使用一个 16进制 标识 两个16进制可以标识一个字节，即8位 数量单位 1024 &#x3D; 1k，1024k &#x3D; 1M，1024M &#x3D; 1G 容量单位 1024 &#x3D; 1KB，1024KB &#x3D; 1MB，1024MB &#x3D; 1GB 数据的宽度 计算机中的数据是有宽度的，超过了就会溢出 4、寄存器：CPU为了性能，自内部开辟了一小块临时存储区域 浮点向量寄存器：用于浮点数&#x2F;向量的存储及运算 异常状态寄存器 通用寄存器：除了存放数据有时也有特殊的用途 ARM64拥有32个64位的通用寄存器 X0-X30 以及XZR（零寄存器） 为了兼容32位，所以arm64位拥有 W0-W28 以及WZR 30个32位寄存器 32位寄存器并不是独立存在的，例如 W0是X0的低32位 PC寄存器：指令指针寄存器 PC寄存器里面的值保存的就是CPU接下来需要执行的指令地址 改变PC的值可以改变程序的执行流程 mov指令不能更改PC寄存器的值，需要通过bl跳转指令来改变PC寄存器的值","categories":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC逆向11：代码注入（下）","slug":"OC逆向/OC逆向11：代码注入（下）","date":"2022-02-08T08:04:13.000Z","updated":"2022-02-08T08:23:24.000Z","comments":true,"path":"2022/02/08/OC逆向/OC逆向11：代码注入（下）/","link":"","permalink":"https://www.bboyzj.cn/2022/02/08/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9111%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC逆向11：代码注入（上）","slug":"OC逆向/OC逆向11：代码注入（上）","date":"2022-02-08T08:03:52.000Z","updated":"2022-02-08T09:11:19.000Z","comments":true,"path":"2022/02/08/OC逆向/OC逆向11：代码注入（上）/","link":"","permalink":"https://www.bboyzj.cn/2022/02/08/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9111%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"前言本文主要讲解代码注入的两种方式： Framework注入、dylib注入 代码注入一般修改原始的程序，是 利用代码注入 的方式，注入代码就会选择利用 Framework 或者 dylib 等三方库的方式注入 查看Mach-O文件 在了解注入前，我们首先需要了解 ipa包 中的静态库是如何注入的，有以下两种方式查看Mach-O可执行文件 * 终端命令：otool -l Demo * MachOView 二进制文件分析工具（注：分析时可能出现无法分析的情况，可以通过CMD + O打开） Mach-O 文件中主要看 load Commands（即加载命令集），从这里可以看出动态库的加载等，其中大部分格式为：LC_LOAD_DYLIB（xxx），是在指定路径下加载xxx，如下所示 所以，综上所述，如果需要注入代码，是 以动态库的形式注入 方式一：Framework手动注入 第一步：动态库进入App包，即Framework注入 创建一个 Framework，命令为ZJHook（创建位置：target -&gt; + -&gt; ios -&gt; Framework） 在 ZJHook中创建 inject 文件，在声明周期方法load函数中写注入代码 123+(void)load&#123; NSLog(@&quot;CJLHook ------ 注入成功&quot;);&#125; 编译工程Demo（注：这里的工程依然需要重签名），然后查看工程的可执行文件Demo，查找其中的Frameworks，从这里可以看到ZJHook，但是此时并不会执行其中的load函数 load不会执行的原因：查看此时的Mach-O文件中的 Load Commands，并没有发现ZJHook，随意此时是不会执行其中的load函数的 第二步：yololib手动注入，修改Mach-O字段 通过yololib工具修改Mach-O字段：.&#x2F;yololib Demo Frameworks&#x2F;ZJHook.framework&#x2F;ZJHook（注：需要将Demo可执行文件拷贝过来） 方式2：dylib注入准备工作：创建一个空工程，并进行Demo的重签名，可以参考这篇文件iOS逆向10：应用重签名（下） dylib注入 选择 target -&gt; + &gt; mac os -&gt; Library ，命名为 ZJHook 在 Build Setting 中配置 ZJHook Base SDK 改为 ios Code Signing identify 改为 iOS Developer 当前工程拷贝 lib","categories":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC逆向12：Mach-O文件（下）","slug":"OC逆向/OC逆向12：Mach-O文件（下）","date":"2022-01-25T01:34:11.000Z","updated":"2022-02-08T08:22:22.000Z","comments":true,"path":"2022/01/25/OC逆向/OC逆向12：Mach-O文件（下）/","link":"","permalink":"https://www.bboyzj.cn/2022/01/25/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9112%EF%BC%9AMach-O%E6%96%87%E4%BB%B6%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"前言本文主要介绍Mach-O的结构演示 Mach-O内部结构因为Mach-O文件本身是一种文件格式，所以我们一定需要了解其文件内部结构，其内部结构如下图所示： Mach-O 的组成结构主要分为 三部分 Header 包含该 二进制文件的一般信息 字节顺序、结构类型、加载指令的数量等 使得可以快速确认一些信息，比如当前文件用于32位还是64位，对应的处理器是什么？文件类型是什么？ Load commands （加载命令）一张包含很多内容的表 内容包括 区域的位置、符号表、动态符号表 等 Data（数据）通常是对象文件中最大的部分 包含 Segment 的具体 数据，首先是 分段，然后段中 分节 终端命令：otool在终端中，我们通过 otool 查看Mach-O的一些指令 123456789101112131415161718192021222324252627282930313233343536 % otoolUsage: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool [-arch arch_type] [-fahlLDtdorSTMRIHGvVcXmqQjCP] [-mcpu=arg] [--version] &lt;object file&gt; ... -f print the fat headers -a print the archive header -h print the mach header -l print the load commands -L print shared libraries used -D print shared library id name -t print the text section (disassemble with -v) -x print all text sections (disassemble with -v) -p &lt;routine name&gt; start dissassemble from routine name -s &lt;segname&gt; &lt;sectname&gt; print contents of section -d print the data section -o print the Objective-C segment -r print the relocation entries -S print the table of contents of a library (obsolete) -T print the table of contents of a dynamic shared library (obsolete) -M print the module table of a dynamic shared library (obsolete) -R print the reference table of a dynamic shared library (obsolete) -I print the indirect symbol table -H print the two-level hints table (obsolete) -G print the data in code table -v print verbosely (symbolically) when possible -V print disassembled operands symbolically -c print argument strings of a core file -X print no leading addresses or headers -m don&#x27;t use archive(member) syntax -B force Thumb disassembly (ARM objects only) -q use llvm&#x27;s disassembler (the default) -Q use otool(1)&#x27;s disassembler -mcpu=arg use `arg&#x27; as the cpu for disassembly -j print opcode bytes -P print the info plist section as strings -C print linker optimization hints --version print the version of /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool 查看Mach-O的header信息：otool -f Demo 1234567891011121314151617181920212223242526% cd /Users/zhangjian/Library/Developer/Xcode/DerivedData/Demo-edwjvapoqaffzeeiyzyhfryhfrsr/Build/Products/Release-iphoneos/Demo.app zhangjian@zhangjiandeMBP Demo.app % otool -f DemoFat headersfat_magic 0xcafebabenfat_arch 3architecture 0 cputype 12 cpusubtype 9 capabilities 0x0 offset 16384 size 79280 align 2^14 (16384)architecture 1 cputype 12 cpusubtype 11 capabilities 0x0 offset 98304 size 79280 align 2^14 (16384)architecture 2 cputype 16777228 cpusubtype 0 capabilities 0x0 offset 180224 size 80000 align 2^14 (16384) MachOView 软件 首先 Show in finder 找到Demo.app程序包 -&gt; 右键显示包内容 -&gt; 找打exex可执行文件 将demo拖拽到 MachOView 查看 Mach-O 文件 验证 ARM-V7 与 ARM_V7S 之间是否是分页？ * ARM_V7 与 ARM_V7S 的差值：16384 + 79280 - 98304 = -2640 * ARM_V7 的大小：-2640 - 79280 = -81920，查看这个值是否 pageSize(4096)的倍数 * 是否是PageSize的倍数：91920/4096 = -20（MacOs中），但是由于是iOS，所以 20/4 = 5页，说明是分页了，即按页对齐 两者对比 otool 与 MachOView 查看的Mach-O进行对比 MachOView演示通过 MachOView 查看Mach-O结构，分为三部分：Header、Load Commands、Data 查看 arm64 下 Mach-O 的header 查看 Load Commands * VM Addr：虚拟内存地址 * VM Size：虚拟内存大小，在运行时，在内存中的大小，4g * 64位地址：0x12345678a2345678 * 32位地址：0x12345678 * File offset：数据在文件中偏移量 * File size：数据在文件中的大小 Section 中分为两大类：__TEST（代码）、__DATA（数据） Header 的数据结构 在 CMD + shift + O 搜索 loader.h，找到 Mach_Header_64（arm64架构）的数据结构如下所示，与 mach_header 相比，只是多了一个 reverse 12345678910111213141516171819202122// 1.mach_headerstruct mach_header &#123; uint32_t magic; /* 魔数，快速定位属于64位还是32位 */ cpu_type_t cputype; /* cpu类型 */ cpu_subtype_t cpusubtype; /* cpu具体类型 */ uint32_t filetype; /* 文件类型 */ uint32_t ncmds; /* Load commands的条数 */ uint32_t sizeofcmds; /* Load commands的大小 */ uint32_t flags; /* 标志位标识二进制文件支持的功能，主要是和系统加载、链接有关 */&#125;;// 2.mach_header_64struct mach_header_64 &#123; uint32_t magic; /* 魔数，快速定位属于64位还是32位 */ cpu_type_t cputype; /* cpu类型 */ cpu_subtype_t cpusubtype; /* cpu具体类型 */ uint32_t filetype; /* 文件类型 */ uint32_t ncmds; /* Load commands的条数 */ uint32_t sizeofcmds; /* Load commands的大小 */ uint32_t flags; /* 标志位标识二进制文件支持的功能，主要是和系统加载、链接有关 */ uint32_t reserved; /* reserved */&#125;; 查看filetype种类 OC文件：#define MH_OBJECT 0x1 可执行文件：#define MH_EXECUTE 0x2 … Load CommandsLoad Commands 中的相关字段含义如下所示： LC_SEGMENT_64：将文件中（32位或64位）的段映射到进程地址空间中，主要分为__TEXT、__DATA、LINKEDIT几大块 LC_DYLD_INFO_ONLY：动态链接相关信息 LC_SYMTAB：符号地址 DYSYMTAB：动态符号表地址 LC_LOAD_DYLINKER：使用谁加载，我们使用dyld LC_UUID：Mach-O文件的唯一标识UUID LC_VERSION_MIN_MACOSX：支持最低的操作系统版本 LC_SOURCE_VERSION：源代码版本 LC_MAIN：设值程序主线程的入口地址和栈大小 LC_ENCRYPTION_INFO_64：加密信息 LC_LOAD_DYLIB：依赖库的路径，包含三方库 LC_FUNCTION_STARTS：函数起始地址表 LC_CODE_SIGNATURE：代码签名 演示 LC_SEGMENT_64 中 __TEXT、__DATA、LINKERDIT 的对应关系如下图所示 查看 LC_DYLD_INFO_ONLY 动态链接信息 其中 Rebase 是重定向，重定向过程简述如下： 代码段 放入Mach-O文件，在编译时期，会生成一个 偏移地址 在运行时期，mach-o文件放入虚拟内存，其内存也是随机变化的(由系统分配 -ASLR) 所以之前的代码段在mach-o中偏移值就不能使用了，需要通过 ASLR + Rebase Info Offset 重定向，主要改变的是汇编代码 查看 LC_SYMTAB 符号地址 查看 LC_LOAD_DYLINKER ，使用谁链接，这里使用的是dyld 查看 LC_UUID，mach-o文件识别的唯一标识 查看 LC_VERSION_MIN_MACOSX，支持的最低版本信息 查看 LC_SOURCE_VERSION，代码版本 查看 LC_MAIN，入口函数 作用：用于你想时找不到切入点时（例如：做了防护，运行就闪退），可以从这里找到 查看 LC_ENCRYPTION_INFO_64 ，此时 Crypt ID 为 0，表示还没有加密 Data 如果我们想快速定位代码段，需要通过 LC_SEGMENT_64(__TEXT) 中的 VM Adress 查看 代码段 的 起始位置 也可以通过 objdump 命令来查看： objdump –macho -d Demo 从这里看出，正好与Mach-O文件中的对应 查看stub、stub_helper：主要是用于符号绑定，这里的 0x10006574 全是指向的 00006574 偏移，且前面6句汇编都是在做 符号绑定 查看外部符号表（即 调用外部函数，只有在运行时才绑定），有两个：懒加载、非懒加载 这里是先 绑定 专门 用来绑定外部的函数，在用这个函数去绑定其他函数 总结 Mach-O 内部结构 header ：用于快速确定该文件的CPU类型、文件类型 Load Commands：指示加载器如何设置并加载二进制数据 Data：存放数据，例如代码、数据、字符串常量、类、方法等。 Section 中分为两大类：__TEXT(代码)、__DATA（数据） 可以通过 otool 命令查看Mach-O信息，例如查看header信息：otool -f Demo 可以通过 objump 命令来查看代码段： objump --macho -d Demo","categories":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC逆向12：Mach-O文件（上）","slug":"OC逆向/OC逆向12：Mach-O文件（上）","date":"2022-01-25T01:33:32.000Z","updated":"2022-02-08T08:11:08.000Z","comments":true,"path":"2022/01/25/OC逆向/OC逆向12：Mach-O文件（上）/","link":"","permalink":"https://www.bboyzj.cn/2022/01/25/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9112%EF%BC%9AMach-O%E6%96%87%E4%BB%B6%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"前言本文主要介绍 Mach-O文件格式 以及 通用二进制文件 Mach-O 文件概述 Mach-O其实是 Mach Object 文件格式的缩写，是 Mac 以及 iOS 上 可执行文件的格式，类似于 Window 上的 PE格式（Portable Executable），linux 上的 elf格式（Executable And LinkingFormat）。 Mach-O 是一种 用于可执行文件、目标代码、动态库的文件格式，作为 a.out格式 的替代，Mach-O 提供了更强的扩展性 Mach-O 文件格式常见的 Mach-O格式 有以下几种： 目标文件 .o 库文件，细分主要有以下几种： .a .dylib .framework 可执行文件 dyld dsym 我们可以通过终端的 file 指令来查看文件的类型 12$cd 文件目录$file 文件 目标文件 .o 新建一个 .c 文件 12% cd Desktop % touch demo.c 在 .c 文件中实现如下 123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;test\\n&quot;); return 0;&#125; 通过 clang 命令编译 .c 文件 123456789101112131415% clang -c demo.c% file demo.odemo.o: Mach-O 64-bit object x86_64% clang demo.o% lsa.out demo.c demo.o % file a.out a.out: Mach-O 64-bit executable x86_64% ./a.out test ls：查看当前文件夹 clang -c demo.c ： 将 .c文件 编译成 .o文件（OC在后端中使用的是LLVM编译，而前端使用的工具是 clang，即理解为 LLVM包含clang） file demo.o ： 查看文件类型 Mach-O文件、64位、x86_64架构 clang demo.o ： 将 .o文件 编译成 可执行文件 ./a.out ： 执行可执行文件 也可以通过一行命令将 .c文件 编译成可执行文件 ： clang -o demo2 demo.c 1234567% clang -o demo2 demo.c% lsdemo.c demo2% ./demo2test 重复4 的操作，再次生成一个可执行文件 demo3，此时问题来了，这三个可执行文件（即 a、demo2、demo3）是否是一样的？我们可以通过 md5 验证，如果hash值一样，则说明一样的，反之不一样 12345678% md5 a.outMD5 (a.out) = 922bae326e46b2ac90f5ad4bf2ed031c% md5 demo2MD5 (demo2) = 922bae326e46b2ac90f5ad4bf2ed031c% md5 demo3MD5 (demo3) = 922bae326e46b2ac90f5ad4bf2ed031c 中间产物 .o文件其中 .c 和 .out 文件的区别是中间多了一个 .o 文件。而在我们的实际开发中，其实是由多个源码的，所以最终的 可执行文件是由多个源码 生成的，如下所示，将 两个.o 文件编译成 一个可执行文件 新建两个 .c 文件 test.c 代码如下： 123456789101112131415#include &lt;stdio.h&gt;// 函数外定义变量 x 和 yint x;int y;int addtwonum()&#123; // 函数内声明变量 x 和 y 为外部变量 extern int x; extern int y; // 给外部变量（全局变量）x 和 y 赋值 x = 1; y = 2; return x+y;&#125; test1.c 代码如下： 12345678910#include &lt;stdio.h&gt;int main()&#123; int result; result = 1; printf(&quot;result 为: %d&quot;,result); return 0;&#125; 通过 clang 将 两个.c文件 生成 两个.o文件：clang -c test1.c test.c 123% clang -c test1.c test.c% lstest1.o test.c test.o test1.c 通过 clang 将 两个.o文件 编译成 两个可执行文件：clang -o demo test1.o test.o 1% clang -o demo test1.o test.o 如果出现如下报错 123456% clang -o demo test1.o test.oduplicate symbol &#x27;_main&#x27; in: test1.o test.old: 1 duplicate symbol for architecture x86_64clang: error: linker command failed with exit code 1 (use -v to see invocation) 说明: text.c 和 test1.c 中的 代码相同，需要将其中一个中的代码删除即可，即保证 test1.c 和 test.c 内代码不同 如果此时换一下链接顺序呢？例如： clang -o demo1 test.o test1.o 多个源码一次性生成可执行文件： clang -o demo2 test1.c test.c 对比上述生成三个可执行文件，是否是同一个？这里我们也通过 md5 生成的 hash值 进行对比： 123456% md5 demoMD5 (demo) = 4be533adc572558230adcbd067379fea% md5 demo1MD5 (demo1) = a3ff882d7d541fe3bc2a11538bc2e031% md5 demo2MD5 (demo2) = 4be533adc572558230adcbd067379fea 结论：通过对比发现，如果改变了 .o文件的 连接顺序，那么 Mach-O 也会发生改变 这里可以通过 objdump --macho -d demo 查看 Mach-O 链接顺序，如下： 1234567891011121314151617181920212223242526272829% objdump --macho -d demodemo:(__TEXT,__text) section_main:100003f30: 55 pushq %rbp100003f31: 48 89 e5 movq %rsp, %rbp100003f34: 48 83 ec 10 subq $16, %rsp100003f38: c7 45 fc 00 00 00 00 movl $0, -4(%rbp)100003f3f: c7 45 f8 01 00 00 00 movl $1, -8(%rbp)100003f46: 8b 75 f8 movl -8(%rbp), %esi100003f49: 48 8d 3d 56 00 00 00 leaq 86(%rip), %rdi ## literal pool for: &quot;result \\344\\270\\272: %d&quot;100003f50: b0 00 movb $0, %al100003f52: e8 2d 00 00 00 callq 0x100003f84 ## symbol stub for: _printf100003f57: 31 c0 xorl %eax, %eax100003f59: 48 83 c4 10 addq $16, %rsp100003f5d: 5d popq %rbp100003f5e: c3 retq100003f5f: 90 nop_addtwonum:100003f60: 55 pushq %rbp100003f61: 48 89 e5 movq %rsp, %rbp100003f64: 48 8d 0d a9 40 00 00 leaq _y(%rip), %rcx100003f6b: 48 8d 05 9e 40 00 00 leaq _x(%rip), %rax100003f72: c7 00 01 00 00 00 movl $1, (%rax)100003f78: c7 01 02 00 00 00 movl $2, (%rcx)100003f7e: 8b 00 movl (%rax), %eax100003f80: 03 01 addl (%rcx), %eax100003f82: 5d popq %rbp100003f83: c3 retq 源文件链接顺序是 main + addtwonum 这里可以通过 objdump --macho -d demo1 查看 Mach-O 链接顺序，如下： 12345678910111213141516171819202122232425262728293031323334353637383940% objdump --macho -d demo1demo1:(__TEXT,__text) section_addtwonum:100003f20: 55 pushq %rbp100003f21: 48 89 e5 movq %rsp, %rbp100003f24: 48 8d 0d e9 40 00 00 leaq _y(%rip), %rcx100003f2b: 48 8d 05 de 40 00 00 leaq _x(%rip), %rax100003f32: c7 00 01 00 00 00 movl $1, (%rax)100003f38: c7 01 02 00 00 00 movl $2, (%rcx)100003f3e: 8b 00 movl (%rax), %eax100003f40: 03 01 addl (%rcx), %eax100003f42: 5d popq %rbp100003f43: c3 retq100003f44: 90 nop100003f45: 90 nop100003f46: 90 nop100003f47: 90 nop100003f48: 90 nop100003f49: 90 nop100003f4a: 90 nop100003f4b: 90 nop100003f4c: 90 nop100003f4d: 90 nop100003f4e: 90 nop100003f4f: 90 nop_main:100003f50: 55 pushq %rbp100003f51: 48 89 e5 movq %rsp, %rbp100003f54: 48 83 ec 10 subq $16, %rsp100003f58: c7 45 fc 00 00 00 00 movl $0, -4(%rbp)100003f5f: c7 45 f8 01 00 00 00 movl $1, -8(%rbp)100003f66: 8b 75 f8 movl -8(%rbp), %esi100003f69: 48 8d 3d 32 00 00 00 leaq 50(%rip), %rdi ## literal pool for: &quot;result \\344\\270\\272: %d&quot;100003f70: b0 00 movb $0, %al100003f72: e8 09 00 00 00 callq 0x100003f80 ## symbol stub for: _printf100003f77: 31 c0 xorl %eax, %eax100003f79: 48 83 c4 10 addq $16, %rsp100003f7d: 5d popq %rbp100003f7e: c3 retq 源文件的链接顺序是 addtwonum + main 这里可以通过 objdump --macho -d demo2 查看 Mach-O 链接顺序，如下： 123456789101112131415161718192021222324252627282930% objdump --macho -d demo2demo2:(__TEXT,__text) section_main:100003f30: 55 pushq %rbp100003f31: 48 89 e5 movq %rsp, %rbp100003f34: 48 83 ec 10 subq $16, %rsp100003f38: c7 45 fc 00 00 00 00 movl $0, -4(%rbp)100003f3f: c7 45 f8 01 00 00 00 movl $1, -8(%rbp)100003f46: 8b 75 f8 movl -8(%rbp), %esi100003f49: 48 8d 3d 56 00 00 00 leaq 86(%rip), %rdi ## literal pool for: &quot;result \\344\\270\\272: %d&quot;100003f50: b0 00 movb $0, %al100003f52: e8 2d 00 00 00 callq 0x100003f84 ## symbol stub for: _printf100003f57: 31 c0 xorl %eax, %eax100003f59: 48 83 c4 10 addq $16, %rsp100003f5d: 5d popq %rbp100003f5e: c3 retq100003f5f: 90 nop_addtwonum:100003f60: 55 pushq %rbp100003f61: 48 89 e5 movq %rsp, %rbp100003f64: 48 8d 0d a9 40 00 00 leaq _y(%rip), %rcx100003f6b: 48 8d 05 9e 40 00 00 leaq _x(%rip), %rax100003f72: c7 00 01 00 00 00 movl $1, (%rax)100003f78: c7 01 02 00 00 00 movl $2, (%rcx)100003f7e: 8b 00 movl (%rax), %eax100003f80: 03 01 addl (%rcx), %eax100003f82: 5d popq %rbp100003f83: c3 retq 源文件的链接顺序是 main + addtwonum 上述所说的链接顺序，对应到我们日常开发中是指工程中的 target -&gt; Build Phase -&gt; Compiles Sources，这里就是对应源文件的 编译顺序，如果源文件的顺序发生了变化，生成的可执行文件是不一样的 库 文件 什么是库？ 主要是程序代码的集合，即将N个文件组织起来，是共享程序代码的一种方式， 库的分类 开源库（公有库）：源码是公开的，可以看到每个文件的实现，例如Github中的AFNetworking、SDWebImage等 闭源库（私有库）：源码未公开，是经过编译后的二进制文件，看不到具体的实现，再细分又分为 静态库 和 动态库。 静态库 &amp; 动态库 静态库：静态库的存在形式主要有两种（建议用.framework）：.a + .framework .a 是一个 纯二进制文件，.a 不能直接使用，至少需要.h文件配合，可能还会需要资源文件 .framework 中除了有二进制文件外，还有资源文件，且可以 直接使用 两者的关系： .a + .h + sourceFile = .frmework 优势：方便共享代码，便于合理使用 实现iOS的模块化，即将固定业务模块化为静态库 共享代码，但不希望被看到代码的具体实现 动态库：动态库的存在形式也是两种：.dylib + .framework .framework 为什么即是静态库又是动态库？ 系统的 .framework 是动态库 自定义的 .framework 是静态库 静态库和动态库的区别 静态库 在 链接 时会被完整的拷贝到项目中，如果有多个APP都是用了同一个静态库，会拷贝多份，浪费内存 动态库 不会复制，只有一份，在程序运行时 动态加载 到内存中，多个APP共用一份，节约内存 验证 .a .dylib 是否是 Mach-O文件1$ cd 项目根目录下 验证 .a 在项目中，通过find命令查找到 .a 文件: 终端输入 find /usr -name &quot;*.a&quot; 随机查看一个 .a 文件，是一个 dynamically 类型： file .a文件路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354zhangjian@zhangjiandeMBP SRSF % find /usr -name &quot;*.a&quot;find: /usr/sbin/authserver: Permission denied/usr/local/lib/libbrotlidec-static.a/usr/local/lib/libev.a/usr/local/lib/libjemalloc.a/usr/local/lib/libnghttp2.a/usr/local/lib/libevent_extra.a/usr/local/lib/libevent.a/usr/local/lib/libevent_core.a/usr/local/lib/libprotobuf.a/usr/local/lib/liblz4.a/usr/local/lib/libprotoc.a/usr/local/lib/libprotobuf-lite.a/usr/local/lib/libbrotlienc-static.a/usr/local/lib/libbrotlicommon-static.a/usr/local/lib/libuv.a/usr/local/lib/libzstd.a/usr/local/lib/libevent_openssl.a/usr/local/lib/libmysqlservices.a/usr/local/lib/libjemalloc_pic.a/usr/local/lib/libmysqlclient.a/usr/local/lib/libevent_pthreads.a/usr/local/Cellar/nghttp2/1.43.0/lib/libnghttp2.a/usr/local/Cellar/mysql-client/8.0.25/lib/libmysqlclient.a/usr/local/Cellar/libuv/1.41.0/lib/libuv.a/usr/local/Cellar/jemalloc/5.2.1_1/lib/libjemalloc.a/usr/local/Cellar/jemalloc/5.2.1_1/lib/libjemalloc_pic.a/usr/local/Cellar/brotli/1.0.9/lib/libbrotlidec-static.a/usr/local/Cellar/brotli/1.0.9/lib/libbrotlienc-static.a/usr/local/Cellar/brotli/1.0.9/lib/libbrotlicommon-static.a/usr/local/Cellar/icu4c/69.1/lib/libicui18n.a/usr/local/Cellar/icu4c/69.1/lib/libicutest.a/usr/local/Cellar/icu4c/69.1/lib/libicuio.a/usr/local/Cellar/icu4c/69.1/lib/libicudata.a/usr/local/Cellar/icu4c/69.1/lib/libicuuc.a/usr/local/Cellar/icu4c/69.1/lib/libicutu.a/usr/local/Cellar/lz4/1.9.3/lib/liblz4.a/usr/local/Cellar/zstd/1.5.0/lib/libzstd.a/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlservices.a/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlclient.a/usr/local/Cellar/libevent/2.1.12/lib/libevent_extra.a/usr/local/Cellar/libevent/2.1.12/lib/libevent.a/usr/local/Cellar/libevent/2.1.12/lib/libevent_core.a/usr/local/Cellar/libevent/2.1.12/lib/libevent_openssl.a/usr/local/Cellar/libevent/2.1.12/lib/libevent_pthreads.a/usr/local/Cellar/openssl@1.1/1.1.1k/lib/libcrypto.a/usr/local/Cellar/openssl@1.1/1.1.1k/lib/libssl.a/usr/local/Cellar/libev/4.33/lib/libev.a/usr/local/Cellar/protobuf/3.17.3/lib/libprotobuf.a/usr/local/Cellar/protobuf/3.17.3/lib/libprotoc.a/usr/local/Cellar/protobuf/3.17.3/lib/libprotobuf-lite.a% file /usr/local/Cellar/protobuf/3.17.3/lib/libprotobuf-lite.a/usr/local/Cellar/libevent/2.1.12/lib/libevent_openssl.a: current ar archive random library 这个.a库是看不出来是 dynamically类型 验证 .dylib 在项目中通过 find 查找 .dylib文件： find /usr -name &quot;*.dylib&quot; 查看 .dylib 文件： file .dylib文件路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164find: /usr/sbin/authserver: Permission denied/usr/local/Homebrew/Library/Homebrew/test/support/fixtures/mach/fat.dylib/usr/local/Homebrew/Library/Homebrew/test/support/fixtures/mach/i386.dylib/usr/local/Homebrew/Library/Homebrew/test/support/fixtures/mach/x86_64.dylib/usr/local/lib/libmysqlrouter_http_auth_backend.1.dylib/usr/local/lib/libmysqlharness_stdx.1.dylib/usr/local/lib/libevent_pthreads-2.1.7.dylib/usr/local/lib/libbrotlidec.1.dylib/usr/local/lib/libuv.dylib/usr/local/lib/libbrotlicommon.1.dylib/usr/local/lib/liblz4.1.9.3.dylib/usr/local/lib/libcares.dylib/usr/local/lib/libmysqlharness.1.dylib/usr/local/lib/libbrotlienc.dylib/usr/local/lib/libprotobuf-lite.dylib/usr/local/lib/libevent_openssl-2.1.7.dylib/usr/local/lib/libevent_extra.dylib/usr/local/lib/libbrotlienc.1.dylib/usr/local/lib/libuv.1.dylib/usr/local/lib/libevent_extra-2.1.7.dylib/usr/local/lib/libprotoc.28.dylib/usr/local/lib/libprotobuf.28.dylib/usr/local/lib/libmysqlharness_tls.1.dylib/usr/local/lib/libevent.dylib/usr/local/lib/libcares.2.dylib/usr/local/lib/libcares.2.4.2.dylib/usr/local/lib/libbrotlienc.1.0.9.dylib/usr/local/lib/libmysqlclient.21.dylib/usr/local/lib/libev.dylib/usr/local/lib/libprotoc.dylib/usr/local/lib/libzstd.1.5.0.dylib/usr/local/lib/libevent-2.1.7.dylib/usr/local/lib/libevent_pthreads.dylib/usr/local/lib/liblz4.dylib/usr/local/lib/libmysqlrouter_io_component.1.dylib/usr/local/lib/libmysqlrouter_http.1.dylib/usr/local/lib/libjemalloc.2.dylib/usr/local/lib/libnghttp2.14.dylib/usr/local/lib/libprotobuf.dylib/usr/local/lib/libmysqlclient.dylib/usr/local/lib/libevent_openssl.dylib/usr/local/lib/liblz4.1.dylib/usr/local/lib/libmysqlrouter_http_auth_realm.1.dylib/usr/local/lib/libbrotlicommon.dylib/usr/local/lib/libnghttp2.dylib/usr/local/lib/libzstd.1.dylib/usr/local/lib/libbrotlidec.dylib/usr/local/lib/libmysqlrouter.1.dylib/usr/local/lib/libbrotlidec.1.0.9.dylib/usr/local/lib/libevent_core.dylib/usr/local/lib/libbrotlicommon.1.0.9.dylib/usr/local/lib/libev.4.dylib/usr/local/lib/libzstd.dylib/usr/local/lib/libjemalloc.dylib/usr/local/lib/libprotobuf-lite.28.dylib/usr/local/lib/libevent_core-2.1.7.dylib/usr/local/Cellar/nghttp2/1.43.0/lib/libnghttp2.14.dylib/usr/local/Cellar/nghttp2/1.43.0/lib/libnghttp2.dylib/usr/local/Cellar/mysql-client/8.0.25/lib/libssl.dylib/usr/local/Cellar/mysql-client/8.0.25/lib/libssl.1.1.dylib/usr/local/Cellar/mysql-client/8.0.25/lib/plugin/libssl.1.1.dylib/usr/local/Cellar/mysql-client/8.0.25/lib/plugin/libcrypto.1.1.dylib/usr/local/Cellar/mysql-client/8.0.25/lib/libmysqlclient.21.dylib/usr/local/Cellar/mysql-client/8.0.25/lib/libcrypto.dylib/usr/local/Cellar/mysql-client/8.0.25/lib/libmysqlclient.dylib/usr/local/Cellar/mysql-client/8.0.25/lib/libcrypto.1.1.dylib/usr/local/Cellar/libuv/1.41.0/lib/libuv.dylib/usr/local/Cellar/libuv/1.41.0/lib/libuv.1.dylib/usr/local/Cellar/jemalloc/5.2.1_1/lib/libjemalloc.2.dylib/usr/local/Cellar/jemalloc/5.2.1_1/lib/libjemalloc.dylib/usr/local/Cellar/brotli/1.0.9/lib/libbrotlidec.1.dylib/usr/local/Cellar/brotli/1.0.9/lib/libbrotlicommon.1.dylib/usr/local/Cellar/brotli/1.0.9/lib/libbrotlienc.dylib/usr/local/Cellar/brotli/1.0.9/lib/libbrotlienc.1.dylib/usr/local/Cellar/brotli/1.0.9/lib/libbrotlienc.1.0.9.dylib/usr/local/Cellar/brotli/1.0.9/lib/libbrotlicommon.dylib/usr/local/Cellar/brotli/1.0.9/lib/libbrotlidec.dylib/usr/local/Cellar/brotli/1.0.9/lib/libbrotlidec.1.0.9.dylib/usr/local/Cellar/brotli/1.0.9/lib/libbrotlicommon.1.0.9.dylib/usr/local/Cellar/icu4c/69.1/lib/libicui18n.69.dylib/usr/local/Cellar/icu4c/69.1/lib/libicuio.69.1.dylib/usr/local/Cellar/icu4c/69.1/lib/libicuio.dylib/usr/local/Cellar/icu4c/69.1/lib/libicuuc.69.dylib/usr/local/Cellar/icu4c/69.1/lib/libicutest.dylib/usr/local/Cellar/icu4c/69.1/lib/libicudata.dylib/usr/local/Cellar/icu4c/69.1/lib/libicudata.69.dylib/usr/local/Cellar/icu4c/69.1/lib/libicutu.69.1.dylib/usr/local/Cellar/icu4c/69.1/lib/libicui18n.69.1.dylib/usr/local/Cellar/icu4c/69.1/lib/libicuuc.dylib/usr/local/Cellar/icu4c/69.1/lib/libicutu.dylib/usr/local/Cellar/icu4c/69.1/lib/libicui18n.dylib/usr/local/Cellar/icu4c/69.1/lib/libicutest.69.dylib/usr/local/Cellar/icu4c/69.1/lib/libicudata.69.1.dylib/usr/local/Cellar/icu4c/69.1/lib/libicutest.69.1.dylib/usr/local/Cellar/icu4c/69.1/lib/libicuuc.69.1.dylib/usr/local/Cellar/icu4c/69.1/lib/libicuio.69.dylib/usr/local/Cellar/icu4c/69.1/lib/libicutu.69.dylib/usr/local/Cellar/lz4/1.9.3/lib/liblz4.1.9.3.dylib/usr/local/Cellar/lz4/1.9.3/lib/liblz4.dylib/usr/local/Cellar/lz4/1.9.3/lib/liblz4.1.dylib/usr/local/Cellar/c-ares/1.17.1/lib/libcares.dylib/usr/local/Cellar/c-ares/1.17.1/lib/libcares.2.dylib/usr/local/Cellar/c-ares/1.17.1/lib/libcares.2.4.2.dylib/usr/local/Cellar/zstd/1.5.0/lib/libzstd.1.5.0.dylib/usr/local/Cellar/zstd/1.5.0/lib/libzstd.1.dylib/usr/local/Cellar/zstd/1.5.0/lib/libzstd.dylib/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlrouter_http_auth_backend.1.dylib/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlharness_stdx.1.dylib/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlharness.1.dylib/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlharness_tls.1.dylib/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlclient.21.dylib/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlrouter_io_component.1.dylib/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlrouter_http.1.dylib/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlclient.dylib/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlrouter_http_auth_realm.1.dylib/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlrouter.1.dylib/usr/local/Cellar/libevent/2.1.12/lib/libevent_pthreads-2.1.7.dylib/usr/local/Cellar/libevent/2.1.12/lib/libevent_openssl-2.1.7.dylib/usr/local/Cellar/libevent/2.1.12/lib/libevent_extra.dylib/usr/local/Cellar/libevent/2.1.12/lib/libevent_extra-2.1.7.dylib/usr/local/Cellar/libevent/2.1.12/lib/libevent.dylib/usr/local/Cellar/libevent/2.1.12/lib/libevent-2.1.7.dylib/usr/local/Cellar/libevent/2.1.12/lib/libevent_pthreads.dylib/usr/local/Cellar/libevent/2.1.12/lib/libevent_openssl.dylib/usr/local/Cellar/libevent/2.1.12/lib/libevent_core.dylib/usr/local/Cellar/libevent/2.1.12/lib/libevent_core-2.1.7.dylib/usr/local/Cellar/openssl@1.1/1.1.1k/lib/libssl.dylib/usr/local/Cellar/openssl@1.1/1.1.1k/lib/libssl.1.1.dylib/usr/local/Cellar/openssl@1.1/1.1.1k/lib/libcrypto.dylib/usr/local/Cellar/openssl@1.1/1.1.1k/lib/engines-1.1/padlock.dylib/usr/local/Cellar/openssl@1.1/1.1.1k/lib/engines-1.1/capi.dylib/usr/local/Cellar/openssl@1.1/1.1.1k/lib/libcrypto.1.1.dylib/usr/local/Cellar/libev/4.33/lib/libev.dylib/usr/local/Cellar/libev/4.33/lib/libev.4.dylib/usr/local/Cellar/protobuf/3.17.3/lib/libprotobuf-lite.dylib/usr/local/Cellar/protobuf/3.17.3/lib/libprotoc.28.dylib/usr/local/Cellar/protobuf/3.17.3/lib/libprotobuf.28.dylib/usr/local/Cellar/protobuf/3.17.3/lib/libprotoc.dylib/usr/local/Cellar/protobuf/3.17.3/lib/libprotobuf.dylib/usr/local/Cellar/protobuf/3.17.3/lib/libprotobuf-lite.28.dylib/usr/lib/libobjc-trampolines.dylib/usr/lib/libLeaksAtExit.dylib/usr/lib/libstdc++.6.dylib/usr/lib/libpython2.7.dylib/usr/lib/libhunspell-1.2.0.dylib/usr/lib/libMTLCapture.dylib/usr/lib/system/libsystem_pthread.dylib/usr/lib/system/introspection/libsystem_pthread.dylib/usr/lib/system/introspection/libdispatch.dylib/usr/lib/system/libsystem_kernel.dylib/usr/lib/system/libsystem_platform.dylib/usr/lib/libgmalloc.dylib/usr/lib/swift/libswiftRemoteMirror.dylib/usr/lib/swift/libswiftCreateML.dylib/usr/lib/libiodbc.2.dylib/usr/lib/libffi-trampolines.dylib/usr/lib/ssh-keychain.dylib/usr/lib/libpython.dylib/usr/lib/libiodbcinst.2.dylib% file /usr/lib/libpython.dylib/usr/lib/libpython.dylib: Mach-O universal binary with 2 architectures: [x86_64:Mach-O 64-bit dynamically linked shared library x86_64] [arm64e]/usr/lib/libpython.dylib (for architecture x86_64): Mach-O 64-bit dynamically linked shared library x86_64/usr/lib/libpython.dylib (for architecture arm64e): Mach-O 64-bit dynamically linked shared library arm64e 可执行文件 这里的可执行文件，即一般是指日常项目中，编译后生成的可执行文件，可以通过 file 查看其文件类型 12% file /Users/zhangjian/Desktop/demo1 /Users/zhangjian/Desktop/demo1: Mach-O 64-bit executable x86_64 dyld dyld（the dynamic link editor）是苹果的 动态连接器，是苹果操作系统一个重要的组成部分，在系统内核做好程序准备工作之后，交由dyld负责余下的工作，而且它是开源的，任何人可以通过苹果官网下载它的源码来阅读理解它的运作方式，了解系统加载动态库的细节。 共享缓存机制 在iOS系统中，每个程序依赖的动态库都需要通过dyld（位于&#x2F;usr&#x2F;lib&#x2F;dyld）一个一个 加载到内存，然而，很多系统库几乎是每个程序都会用到的，如果在每个程序运行的时候都重复的去加载一次，势必造成运行缓慢，为了优化启动速度和提高程序性能，共享缓存机制就应运而生。所有默认的动态链接库被合并成一个大的缓存文件，放到/System/Library/Caches/com.apple.dyld/目录下，按照不同的架构分别保存着 验证dyld 查找Mac中的dyld 12345678910111213141516171819202122zhangjian@zhangjiandeMBP ~ % cd /usr/lib zhangjian@zhangjiandeMBP lib % lscharset.alias libstdc++.6.dylibcron logdsc_extractor.bundle pamdtrace pkgconfigdyld python2.7groff rpcsvclibLeaksAtExit.dylib rubylibMTLCapture.dylib sasl2libffi-trampolines.dylib sqlite3libgmalloc.dylib ssh-keychain.dyliblibhunspell-1.2.0.dylib swiftlibiodbc.2.dylib systemlibiodbcinst.2.dylib updaterslibobjc-trampolines.dylib xpclibpython.dylib zshlibpython2.7.dylibzhangjian@zhangjiandeMBP lib % ls dylddyld 查看 dyld的文件类型： file dyld，是一个 动态链接器，其本身也是一个Mach-O文件 12345zhangjian@zhangjiandeMBP lib % file dylddyld: Mach-O universal binary with 3 architectures: [i386:Mach-O dynamic linker i386] [x86_64:Mach-O 64-bit dynamic linker x86_64] [arm64e]dyld (for architecture i386): Mach-O dynamic linker i386dyld (for architecture x86_64): Mach-O 64-bit dynamic linker x86_64dyld (for architecture arm64e): Mach-O 64-bit dynamic linker arm64e dsym文件 dsym介绍 Xcode编译项目后，我们会看到一个同名的 dSYM文件，dSYM是 保存16进制函数地址映射信息的中转文件，我们调试的 symbols 都会包含在这个文件中，并且每次编译项目的时候都会生成一个新的 dSYM文件，位于/Users/&lt;用户名&gt;/Library/Developer/Xcode/Archives目录下，所以对于每一个发布版本我们都很有必要保存对应的 Archives 文件。 当我们软件 release 模式打包或上线后，不会像我们在xcode中那样直观的看到 崩溃 的错误日志，这个时候我们就需要 分析crash report文件了，iOS设备中会有日志文件保存我们每个应用出错的函数内存地址，通过 xcode 的 organizer 可以将iOS设备中的 deviceLog 导出成 crash文件，这个时候我们就可以 通过出错的函数地址去 查询dSYM 文件中程序对应的函数和文件名，但前提是我们需要有软件版本对应的dSYM文件，这也是为什么我们很有必要保存每个发布版本的 Archives 文件了 验证 .dSYM文件 程序 真机+release 编译时，有一个 .dSYM文件 .dSYM 也是一个 mach-o 文件，是一个 符号表，主要用于出现崩溃后可以通过这个文件 取符号，方便 查询问题 通用二进制文件mac系统所支持的cpu及硬件平台发生了很大的变化，为了解决软件在多个平台硬件平台上的 兼容性 问题，苹果开发了一个 通用的二进制文件格式（Universal Binary），又称 胖二进制（Fat Binary） 苹果公司提出的一种程序代码，能同时 适用多种架构的二进制文件 同一个程序包中同时为多种架构提供最理想的性能。 因为需要存储多种代码，通用二进制应用程序通常比单一平台二进制的程序要大 但是由于两种架构有 共通的非执行资源（代码以外的），所以并不会达到单一版本的两倍之多 而且由于执行中只调用一部分代码，运行起来也不需要额外的内存 演示 在日常开发的项目中，可以通过Build Setting -&gt; Mach-O type，指定 Mach-O文件的类型，如下图： 一般我们通过真机生成的可执行文件，其架构是arm64，是一个单一架构 iOS 9.0 以上的系统否支持 64位架构 123% cd /Users/zhangjian/Library/Developer/Xcode/DerivedData/SRSF-bzdqlauzaknekvclilbreawtebqi/Build/Products/Debug-iphoneos/中图云书房.app% file 中图云书房 中图云书房: Mach-O 64-bit executable arm64 同时也可以在 Build Setting -&gt; Architectures 中设值编译的 架构 环境变量 $(ARCHS_STANDRAD) ：包含 arm64、armv7 还有一种架构：armv7s，iPhone5、iPhone5c可用的架构，可在工程中添加，此时查看 Release + 真机环境 可执行文件，支持3个架构 1234567% cd /Users/zhangjian/Library/Developer/Xcode/DerivedData/Demo-edwjvapoqaffzeeiyzyhfryhfrsr/Build/Products/Release-iphoneos/Demo.app % file DemoDemo: Mach-O universal binary with 3 architectures: [arm_v7:Mach-O executable arm_v7] [arm_v7s:Mach-O executable arm_v7s] [arm64:Mach-O 64-bit executable arm64]Demo (for architecture armv7): Mach-O executable arm_v7Demo (for architecture armv7s): Mach-O executable arm_v7sDemo (for architecture arm64): Mach-O 64-bit executable arm64 ARM架构ARM架构过去称作 进阶精简指令集机器（Advanced RISC Machine，更早称作：Acorn RISC Machine），是一个 32位精简指令集（RISC）处理器架构，ARM处理器非常适用于通讯领域，符合其主要设计目标为低耗电的特性 ARM和Intel处理器的第一个区别是，前者使用 精简指令集（RISC）,而后者使用 复杂指令集（CISC） ARM处理器指令集：是指计算机ARM操作系统指令系统 armv6、armv7、armv7s、arm64、arm64e 都是arm处理器的指令集，所有指令集原则上都是 向下兼容 的 苹果A7处理器支持两个不同的指令集： 32位 ARM指令集（armv6 | armv7 | armv7s）64位 ARM指令集（arm64） i386 | x86_64 是 Mac 处理器的指令集 iOS 设备支持的指令集 通用二进制源码 通过 CMD + shift + O 搜索 fat.h 找到其中通用二进制文件的头部结构 fat_header 如下所示 1234struct fat_header &#123; uint32_t magic; /* magic字段被定义为常量FAT_MAGIC，表示这是一个胖二进制 */ uint32_t nfat_arch; /* 表示有多少个Mach-O文件 */&#125;; 每个胖二进制都用 fat_arch 结构表示，在 fat_header 之后，紧接着一个活多个连续的fat_arch结构体 1234567struct fat_arch &#123; cpu_type_t cputype; /* cpu 类型 */ cpu_subtype_t cpusubtype; /* cpu的子类型 */ uint32_t offset; /* 制定了当前cpu架构数据相对于当前文件开头的偏移量 */ uint32_t size; /* 数据的大小 */ uint32_t align; /* 数据的内存对齐边界，取值必须是2的次方，它确保了当前cpu架构的目标文件在加载到内存中时，数据是经过内存优化对齐的 */&#125;; 终端指令 可以通过tool来查看fat_header信息：otool -f 可执行文件 12345678910111213141516171819202122232425262728% cd /Users/zhangjian/Library/Developer/Xcode/DerivedData/Demo-edwjvapoqaffzeeiyzyhfryhfrsr/Build/Products/Release-iphoneos/Demo.app % otool -f DemoFat headersfat_magic 0xcafebabenfat_arch 3architecture 0 cputype 12 cpusubtype 9 capabilities 0x0 offset 16384 size 79280 align 2^14 (16384)architecture 1 cputype 12 cpusubtype 11 capabilities 0x0 offset 98304 size 79280 align 2^14 (16384)architecture 2 cputype 16777228 cpusubtype 0 capabilities 0x0 offset 180224 size 80000 align 2^14 (16384)zhangjian@zhangjiandeMBP Demo.app % 可以通过lipo命令拆分、合并胖二进制文件，常用命令如下： $lipo -info MachO文件：使用lifo -info 可以查看MachO文件包含的架构 $lipo MachO文件 -thin 架构 -output 输出文件路径：使用lipo -thin 拆分某种架构 $lipo -create MachO1 MachO2 -output 输出文件路径：使用lipo -create 合并 多种架构 lipo演示 查看二进制文件中包含的架构：lipo -info Demo 1234% cd /Users/zhangjian/Library/Developer/Xcode/DerivedData/Demo-edwjvapoqaffzeeiyzyhfryhfrsr/Build/Products/Release-iphoneos/Demo.app % lipo -info Demo Architectures in the fat file: Demo are: armv7 armv7s arm64 拆分：lipo Demo -thin armv7 -output Demo_armv7，如果拆分没有的架构会报错 查看拆分后的可执行文件类型：file Demo_armv7 123% lipo Demo -thin armv7 -output Demo_armv7% file Demo_armv7Demo_armv7: Mach-O executable arm_v7 合并：lipo -create Demo_armv7 Demo_arm64 -output Demo_v7_64 总结 Mach-O 其实是 Mach Object文件格式的缩写，是mac以及iOS上可执行文件的格式，是一种 用于可执行文件、目标代码、动态库的文件格式，且 Mach-O提供了更强的扩展性 常见的Mach-O格式：.o、库文件（.a、.dylib、.framework）、可执行文件、dyld、.dsym .a + .h + sourceFile = .framwork 动态.framework：系统Framework库 静态.framwork：自定义的Framework库 查看文件类型命令：file 文件路径 查看Mach-O源文件的链接顺序：objdump --macho -d 可执行文件 dyld（the dynamic link editor）是苹果的动态链接器，mac中路径为&#x2F;usr&#x2F;lib dSYM 是保存 16 进制函数地址映射信息的中转文件，位于/Users/&lt;用户名&gt;/Library/Developer/Xcode/Archives目录。可以用于通过出错的函数地址去查询 dSYM 文件中程序对应的函数名和文件名 通用二进制文件（Universal Binary，也称为胖二进制（Fat Binary））。主要适用于解决多个平台的兼容性问题 通过otool来查看fat_header信息：otool -f 可执行文件 lipo命令拆分、合并胖二进制文件 $lipo -info MachO文件：使用lifo -info 可以查看MachO文件包含的架构 $lipo MachO文件 –thin 架构 –output 输出文件路径：使用lifo –thin 拆分某种架构 $lipo -create MachO1 MachO2 -output 输出文件路径： 使用lipo -create 合并多种架构","categories":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-逆向探索篇","slug":"OC-逆向探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%80%86%E5%90%91%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC高级强化04：静态库和动态库","slug":"OC进阶/OC高级强化04：ZJBlog","date":"2022-01-07T07:52:13.000Z","updated":"2022-01-10T08:45:36.000Z","comments":true,"path":"2022/01/07/OC进阶/OC高级强化04：ZJBlog/","link":"","permalink":"https://www.bboyzj.cn/2022/01/07/OC%E8%BF%9B%E9%98%B6/OC%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%9604%EF%BC%9AZJBlog/","excerpt":"","text":"常见的库文件格式 .a 静态库 .dylib 传统意义的动态库 .framework 可静态库也可动态库 .xcframework 2018年推出的针对不同架构的库 什么是库？库(Library)说白了就是一段编译好的而进行代码，加上头文件就可以供别人使用 什么时候会用到库? 某些代码需要给别人使用，但是我们不希望别人看到源码，就需要咦库的形式进行封装，只暴露出头文件 对于某些不会进行大的改动的代码，我们想减少编译的时间，就可以把它打包成库，因为库是已经编译好的二进制了，编译的时候只需要 Link 一下，不会浪费编译时间。 什么是链接？库在使用的时候需要链接（Link），链接的方式有两种： 静态 动态 .a静态库.o 文件的合集 .dylib动态库.a 静态库 链接 之后的产物，即最终链接产物 什么是tdb格式tdb全程是text-based stub libraries，本质上就是一个YAML描述的文本文件。 他的作用是用于记录动态库的一些信息，包括导出的符号、动态库的架构信息、动态库的依赖信息 用于避免在真机开发过程中直接使用传统的dylib。 对于真机来说，由于动态库都是在设备上，在xcode上使用基于tbd格式的伪framework可以打打减少xcode的大小 @rpath Runpath search Paths dylib 搜索路径 运行时 ‘@rpath’ 指示 ‘dylib’ 按顺序搜索路径列表，以找到动态库，‘@rpath’ 保存一个活多个路径变量 @rpath 谁链接我，谁给我提供rpath @executable_path：表示可执行程序所在你的目录，解析为可执行文件的绝对路径 @loader_path：表示被加载的Mach-O所在的目录，每次加载时，都可能被设置为不同的路径，由上层指定","categories":[{"name":"OC-高级强化探索篇","slug":"OC-高级强化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-高级强化探索篇","slug":"OC-高级强化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC高级强化03：符号与链接","slug":"OC进阶/OC高级强化03：符号与链接","date":"2022-01-07T06:38:12.000Z","updated":"2022-01-07T09:21:42.000Z","comments":true,"path":"2022/01/07/OC进阶/OC高级强化03：符号与链接/","link":"","permalink":"https://www.bboyzj.cn/2022/01/07/OC%E8%BF%9B%E9%98%B6/OC%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%9603%EF%BC%9A%E7%AC%A6%E5%8F%B7%E4%B8%8E%E9%93%BE%E6%8E%A5/","excerpt":"","text":"编译成目标文件.o的过程 对代码进行 汇编 把 符号 进行 归类 -&gt; 重定位符号表 重定位符号表 -&gt; .m&#x2F;.o 用到的 API .o -&gt; 链接 -&gt; 符号表和重定位符号表 合并到 一张表中 -&gt; 生成可执行文件 exec 链接 -&gt; 处理目标文件符号的过程 全局 和 本地 符号 全局符号：可见性 - 对整个项目可见 123456// 全局变量int global_uninit_value// 全局符号void global_object() &#123; NSLog(@&quot;global_object&quot;)&#125; 本地符号：可见性 - 只对当前文件可见 123456// 静态变量 -&gt; 本地变量static int static_init_value = 9;// 本地符号static void global_object() &#123; NSLog(@&quot;static_global_object&quot;)&#125; attribute(()) 12可以给编译器传递属性：__attribute__((deprecated)) ：告诉编译器已废弃 two_levelnamespace &amp; flat_namespace 二级命名空间 与 一级命名空间。连接器默认采用 二级命名空间，也就是除了会记录符号名称，还会记录属于哪个 Mach-O 的，比如会记录下来 _NSLog 来自Foundation。 终端查看符号表的方式 12% man nm 查看具体的文档% nm --help 符号表说明 下面我们来通过终端来查看一个可执行文件的符号表-pa ：不排序，显示所有符号 上面的 t、s等就是符号的种类 man nm 如何使用呢 终端输入 man nm 终端输入 &#x2F;-p 终端输入 &#x2F;-a","categories":[{"name":"OC-高级强化探索篇","slug":"OC-高级强化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-高级强化探索篇","slug":"OC-高级强化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC高级强化02：Mach-O与链接器","slug":"OC进阶/OC高级强化02：Mach-O与链接器","date":"2022-01-05T09:28:20.000Z","updated":"2022-01-07T06:54:51.000Z","comments":true,"path":"2022/01/05/OC进阶/OC高级强化02：Mach-O与链接器/","link":"","permalink":"https://www.bboyzj.cn/2022/01/05/OC%E8%BF%9B%E9%98%B6/OC%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%9602%EF%BC%9AMach-O%E4%B8%8E%E9%93%BE%E6%8E%A5%E5%99%A8/","excerpt":"","text":"Mach-O 是什么？Mach-O(Mach Object)是 macOS、iOS、iPadOS 用来 存储程序和库 的 文件格式。对应系统通过应用 二进制接口（application binary interface，缩写 ABI）来运行该格式的文件。 Mach-O格式用来替代BSD系统的a.out格式。Mach-O文件格式 保存 了在 编译过程 和 链接过程 中产生的 机器代码和数据，从而为 静态链接和动态链接 的代码提供了单一文件格式。 我习惯将 Mach-O = 配置文件 + 二进制代码 Mach-O文件格式如下： Mach-O 是可读可写的， Mach-O + 签名 苹果就认你这个Mach-O Mach-O __TEXT 代码段 只读 Mach-O __DATA 数据段 点击Xcode运行按钮的时候，系统做了哪些事情？首先，加载ipa包里可执行文件 Product -&gt; LoginApp -&gt; show in finder -&gt; 右键显示包内容，找到 LoginApp可执行文件 可执行文件的调用过程： 1）调用 fork 函数，创建一个 process 进程 2）调用 execve 或其衍生函数，在该进程上加载，执行我们的 Mach-O 文件，当我们调用 execve(应用程序加载器)，内核实际上在执行以下操作： 将文件加载到内存 开始分析 Mach-O 中的 mach_header，已确认它是有效的 Mach-O 文件 Mach-O 中是不是都是二进制？ 答：Mach-O 中就是二进制 Mach-O 是不是可读可写的？ 答：Mach-O 是 可读可写 的 二进制文件 程序的入口为什么一定是 main ？ 答：Mach-O 中默认指定了程序的入口必须是 main，我们写的代码最终会转成 二进制，最后落在 Mach-O 中，它的排列是按照一定规则的。 编译和链接 什么是 编译？ 答：实际上，编译 的过程就是去把写在文件(.h&#x2F;.m等)中的 代码 放到对应的 Mach-O的配置中。 什么是 链接？ 答：当我 编译 可执行文件的时候，中间要经过一个目标文件 .o 文件，链接的本质就是把多个目标文件组合成一个文件的过程 在代码 编译 中，我们会生成多个.o目标文件，最后要生成一个可执行文件，而链接就是把多个.o的目标文件符号表合 并成一起，最终生成一个可执行文件的过程。 符号表 Symbol TableSymbol Table：就是用来保存符号 String Table：就是用来保存符号的名称 Indirect Symbol Table：间接符号表，保存使用的外部符号，更准确一点就是使用的外部动态库的符号，是Symbol Table的子集。 如何让Xcode编译的命令显示到终端上 首先打开终端 command + t 新建一个窗口，输入 tty，会输出一个像链接一样的东西，这个链接的意思就是你可以把其他地方的输出定位到这个地方 123Last login: Thu Jan 6 10:21:55 on ttys001zhangjian@zhangjiandeMacBook-Pro ~ % tty/dev/ttys005 然后在XCode中，LoginApp -&gt; Build Phases -&gt; 点击+号 -&gt; 添加 Run Script 执行脚本，添加如下内容，让输出的内容 重定向 显示到终端上 1echo &quot;ZJ_Cat&quot; &gt; /dev/ttys005 点击运行按钮，你会在终端上打印 ZJ_Cat 内容 我们知道在 xxconfig 定义的变量可以在项目中获取， 同样的也可以被运行脚本的 Run Script 所获取 1echo &quot;$&#123;HOST_URL&#125;&quot; &gt; /dev/ttys005 由此可见，我们可以通过 脚本+xxconfig 来实现查看 可执行文件 的输出的 符号表 这里我先不做xxconfig+脚本记录，暂时列出几个知识点： 项目瘦身的顺序： -O1 -Oz 生成目标文件 （编译） dead code strip 使代码剥离 （链接） strip 剥离符号（mach-o） $SRCROOT 代码的路径 -p：不排序 -a：显示所有符号，包含调式符号 nm -pa 可执行文件路径 : 查看可执行文件的符号表","categories":[{"name":"OC-高级强化探索篇","slug":"OC-高级强化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-高级强化探索篇","slug":"OC-高级强化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC高级强化01：多环境配置","slug":"OC进阶/OC高级强化01：多环境配置","date":"2022-01-04T08:24:40.000Z","updated":"2022-07-11T03:44:52.000Z","comments":true,"path":"2022/01/04/OC进阶/OC高级强化01：多环境配置/","link":"","permalink":"https://www.bboyzj.cn/2022/01/04/OC%E8%BF%9B%E9%98%B6/OC%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%9601%EF%BC%9A%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"多环境配置 Project : 包含了项目所有的代码、资源文件和所有信息。 Target : 对指定代码和资源文件的具体构建方式。 Scheme : 对指定的Target的环境配置 在实际开发中，我们必须要进行网络请求（内网和外网），而网络请求则就要针对不同的环境（开发、测试、生产）有不同的的主机名称（URL_HOST），那么我们如何获取某个环境下的URL_HOST，那么在这个过程中，我们需要进行配置，而配置的方式有三种： Target 配置 Scheme 配置 xcconfig 配置 Target 配置1、新建Dev的Target 选中 Target 下 LoginApp -&gt; 右键选中 Duplicate 复制 -&gt; 生成新的 LoginApp copy -&gt; 将其改名为 LoginApp-Dev 修改 Bundle Identifier 名为 com.srsf.LoginApp-Dev 修改新生成的 LoginApp copy-info 名为 LoginApp-Dev-info，plist名称改变同时需要在 Build Settings -&gt; Packaging -&gt; info.list File 下 -&gt; 将 LoginApp copy-info 改成 LoginApp-Dev-info。 如下图： 注：到目前为止，你运行 LoginApp 和 LoginApp-Dev 会生成两个 App。 2、添加自定义宏 macros 选中 LoginApp-Dev -&gt; Builds Settings -&gt; all -&gt; 搜索 macros -&gt; Apple Clang - Preprocessing -&gt; 选中 Debug 右键空白双击 -&gt; 弹出添加 DEV&#x3D;1；同理，Release 设置 DEV&#x3D;0 此时，自定义的宏已经生效了，此时可以在任意地方调用下面的方式进行判断使用 12345#if DEV #define URL_HOST @&quot;http://192.168.0.1&quot;#else #define URL_HOST @&quot;http://192.168.0.2&quot;#endif 当你切换不同的Scheme时，打印不同的URL_HOST 3、总结 Target 配置这种方式，每创建一个 target 都会产生新的 info.plist，每一个都需要去配置 macros，配置比较乱，不推荐使用。 Scheme 配置1、首先我们要了解到 Scheme 默认是有两种环境变量 Debug 和 Release，可以在 Edit Scheme -&gt; Run -&gt; info -&gt; Build Configuration 下查看。 2、其次，与之对应的环境配置在 Project -&gt; LoginApp -&gt; Configurations 下也可以看到 3、在 Project -&gt; Configurations 下，我们可以创建一个自己的配置环境 Beta,现在我们有 了 三 种配置方式，对应的在 Edit Scheme -&gt; Run -&gt; info -&gt; Build Configuration 下也有三种，同时在 Target -&gt; Build Settings -&gt; Build Active Architecture Only 下也有对应的三种配置方式，说明这是一个 全局 的配置，如下图： 3、新建 Scheme 点击 LoginApp -&gt; manager Schemes -&gt; 点击 + 号 -&gt; 添加 Debug 和 Beta 两种，加上 LoginApp 本身Release就是三种，对应上面 三种 配置 ) 点击 Edit Scheme 切换 Scheme，并指定 Configurations，如下图 4、自定义主机名URL_HOST Target -&gt; Build Settings -&gt; 点击 + 号 -&gt; Add User-Defined Settings -&gt; URL_HOST，此时我们发现其对应的配置也是三个，分别设值如下： 5、将 URL_HOST 添加到 info.plist 文件中，Build Settings 中的 配置可以通过 info.plist 暴露出来，可以直接读出来 6、在项目中使用 123NSString * path = [NSBundle.mainBundle pathForResource:@&quot;Info&quot; ofType:@&quot;plist&quot;];NSDictionary * infoDic = [[NSDictionary alloc] initWithContentsOfFile:path];NSLog(@&quot;%@&quot;,infoDic[@&quot;HOST_URL&quot;]); 切换 Scheme ，打印如下 123Debug：http://137.0.0.2Beta：http://137.0.0.1LoginApp：http://www.zjboy.com 7、同理配置图标的也一样 xcconfig 配置1、在实际项目中，我们可能会有多个主机名称HOST_URL，因此，我们还是需要去配置多个Configurations，下面还是以三个为准 在 Project -&gt; LoginApp -&gt; Configurations 下，我们可以创建一个自己的配置环境 Beta,现在我们有 了 三 种配置方式，对应的在 Edit Scheme -&gt; Run -&gt; info -&gt; Build Configuration 下也有三种，同时在 Target -&gt; Build Settings -&gt; Build Active Architecture Only 下也有对应的三种配置方式，说明这是一个 全局 的配置，如下图： 2、在主项目下，创建 Congifg 文件，并在下面创建三个对应环境的 .xxconfig 文件 在Config文件夹下 -&gt; command + N -&gt; 搜索config 输入对应的名称 -&gt; 点击create 创建成功之后，如下图 2、选择对应Target的进行配置 3、在 xxconfig 文件中写入 HOST_URL Debug 下 12A = /HOST_URL = http:$&#123;A&#125;/127.0.0.1 Beta 12A = /HOST_URL = http:$&#123;A&#125;/127.0.0.2 Release ： 12A = /HOST_URL = http:$&#123;A&#125;/www.bboyzj.cn 4、同样，我们需要在 info.plist 文件中暴露，在项目中取出 5、项目中代码取出 123NSString * path = [NSBundle.mainBundle pathForResource:@&quot;Info&quot; ofType:@&quot;plist&quot;]; NSDictionary * infoDic = [[NSDictionary alloc] initWithContentsOfFile:path]; NSLog(@&quot;%@&quot;,infoDic[@&quot;HOST_URL&quot;]); 切换不同的 scheme 的打印结果 12345Debug：http://127.0.0.1Beta： http://127.0.0.2Release：https://www.bboyzj.cn 除了上面三种配置实现，其实还有一种实现，就是pch实现 到 Target -&gt; Build Settings -&gt; 设值不同的DEBUG值 具体是现代吗 12345678#if (DEBUG == 1) #define kBaseUrl @&quot;http://127.0.0.1&quot;#elif (DEBUG == 2) #define kBaseUrl @&quot;http://127.0.0.2&quot;#else #define kBaseUrl @&quot;https://www.bboyzj.cn&quot;#endif NSLog(@&quot;url:%@&quot;,kBaseUrl); xxconfig 其他功能 xxconfig 全名是 xcodeConfig，它不仅仅是一个文件，它的本质是控制 Build Settings 里面的选项(比如配置动态库、静态库等) 123// ld 配置到链接器上// OTHER_LDFLAGS 即 Other Linker Flags 的缩写OTHER_LDFLAGS = -framework &quot;AFNetworking&quot; 在Debug配置下运行，报错 ld: framework not found AFNetworking ，然后我们找到 Other Linker Flags，可以看到如下 他的原理与 cocoapods 的原理相同 想查找 Build Settings 中选项的缩写，这里有一个网站可以去查看 Build Settings 缩写网站 比如搜索一个 header search path，找到其缩写 HEADER_SEARCH_PATHS 1HEADER_SEARCH_PATHS = \\user\\zjbboy 你会在 build settings 找到","categories":[{"name":"OC-高级强化探索篇","slug":"OC-高级强化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-高级强化探索篇","slug":"OC-高级强化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理41：内存优化（一）野指针探测","slug":"OC进阶/OC底层原理41：内存优化（一）野指针探测","date":"2021-07-22T06:51:26.000Z","updated":"2023-03-03T07:53:22.000Z","comments":true,"path":"2021/07/22/OC进阶/OC底层原理41：内存优化（一）野指针探测/","link":"","permalink":"https://www.bboyzj.cn/2021/07/22/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8641%EF%BC%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E9%87%8E%E6%8C%87%E9%92%88%E6%8E%A2%E6%B5%8B/","excerpt":"","text":"前言本文主要讲解两种野指针检测的原理和实现 技术点：野指针探测本文的主要目的是理解野指针的形成过程以及如果去检测野指针 引子在介绍野指针之前，首先说下目前的异常处理类型，附 苹果官网链接 异常类型异常类型分为两类： 软件异常：主要来自 kill()、phread_kill()、iOS中的NSException未捕获、absort等 硬件异常：硬件的信号处理器trap，是和平台相关的，野指针崩溃大部分是硬件异常 而处理异常时，需要关注两个概念 Mach异常：Mach层异常 UNIX信号：BSD层获取 iOS中的POSIX API就是通过Mach之上的BSD层实现的，如下图所示： Mach 是一个受 Acccent 启发而高出的Unix系统 BSD 层是建立在Mach之上，是XNU中一个不可分割的一部分，BSD负责提供可靠的、现代的API POSIX 表示可移植操作系统接口（Portable Operation System Interface） 所以，综上所述，Mach异常和UNIX信号存在对应的关系 硬件异常流程：硬件异常 -&gt; Mach异常 -&gt; UNIX信号 软件异常流程：软件异常 -&gt; UNIX异常 Mach异常与UNIX信号的转换下面是 Mach异常 与 UNIX信号 的转换关系代码，来自 xnu 中的 bsd/uxkern/ux_exception.c 123456789101112131415161718192021222324252627282930313233343536373839404142switch(exception) &#123;case EXC_BAD_ACCESS: if (code == KERN_INVALID_ADDRESS) *ux_signal = SIGSEGV; else *ux_signal = SIGBUS; break;case EXC_BAD_INSTRUCTION: *ux_signal = SIGILL; break;case EXC_ARITHMETIC: *ux_signal = SIGFPE; break;case EXC_EMULATION: *ux_signal = SIGEMT; break;case EXC_SOFTWARE: switch (code) &#123; case EXC_UNIX_BAD_SYSCALL: *ux_signal = SIGSYS; break; case EXC_UNIX_BAD_PIPE: *ux_signal = SIGPIPE; break; case EXC_UNIX_ABORT: *ux_signal = SIGABRT; break; case EXC_SOFT_SIGNAL: *ux_signal = SIGKILL; break; &#125; break;case EXC_BREAKPOINT: *ux_signal = SIGTRAP; break;&#125; 将其对应关系汇总成一个表格，如下所示 其中 Mach异常有以下 UNIX信号有以下几种 野指针指向的 对象被释放或收回，但是该 指针没有做任何的修改，以至于 该指针仍指向已经回收的内存地址，这个指针就是 野指针 野指针分类这个参考腾讯Bugly团队的总结，大致分为两类 内存没被覆盖 内存被覆盖 如下图所示 为什么OC野指针的crash这么多？我们一般在APP发版前，都会经过多轮的 自测、内侧、灰度测试 等，按照常理来说，大部分的crash应该都被覆盖了，但是由于 野指针的随机性，使得经常在测试时不会出现crash，而是在 线上出现crash，这对App体验来说是非常致命的 而野指针的随机性问题大致可以分为两类： 跑不进出错的逻辑，执行不到出错的代码，这种可以通过 提高测试场景覆盖率 来解决 跑进有问题的逻辑，但是野指针指向的地址并不一定会导致crash，原因是因为：野指针 其本质是指向 已经删除的对象 或 受限内存区域 的指针，这里说的 OC野指针，是指 OC对象释放后指针未置空而导致的野指针。这里不必现的原因是因为 dealloc 执行后只是告诉系统，这片 内存我不用了，而系统并没有让这片内存不能访问。 野指针解决思路这里主要是借鉴Xcode中的两种处理方案： Malloc Scrrbble，其官方解释如下：申请内存 alloc 时在内存上填 0xAA，释放内存 dealloc 在内存上填 0x55。 Zombie Objects，其 官方解释 如下：一个对象已经解除了它的引用，已经释放掉，但是此时仍然是可以接收消息，这个对象就叫做 Zombie Objects（僵尸对象）。这种方案的重点就是 将释放的对象，全部转为僵尸对象 两种方案对比 僵尸对象 相比 Malloc Scribble，不需要考虑会不会崩溃的问题，只要野指针指向僵尸对象，那么再次访问野指针就一定会崩溃 僵尸对象这种方式，不如 Malloc Scribble覆盖面广，可以通过 hook free 方法将c函数也包含在其中 Malloc Scribble思路：当访问到对象内存中填写的是 0xAA、0x55 时，程序就会出现异常 申请内存 alloc 时在内存上填 0xAA 释放内存 dealloc 使在内存上填 0x55 以上的申请和释放的填充分别对应以下两种情况 申请：没有错初始化就直接被访问 释放：释放后访问 所以综上所述，针对野指针，我们的解决办法是：在对象释放时做数据填充 0x55 即可，关于对象的释放流程可以参考这篇文章 OC底层原理35：内存管理（一）TaggedPointer&#x2F;retain&#x2F;release&#x2F;dealloc&#x2F; 野指针探测实现1这个实现主要依据 腾讯Bugly工程师：陈其锋 的分享，在其代码的主要思路是： 通过 fishhook 替换 c函数 的 free 方法为自定义的 safe_free，类似于 Method Swizzling 在 safe_free 方法中对 已经释放变量的内存，填充 0x55 ，使已经释放变量 不能访问，从而使某些野指针的crash从不必现变成 必现 为了 防止填充0x55的内存内新的数据内容填充，使野指针crash变成不必现，在这里采用的策略是，safe_free不释放这片内存，而是自己保留着，即safe_free方法中不会真的调用free。 同时为了 防止系统内存过快消耗（因为要保留内存），需要在 保留内存大于一定值时释放一部分，防止被系统杀死，同时，在收到 系统内存警告 时，也需要 释放一部分内存 发生crash时，得到的崩溃信息有限，不利于排查问题，所以这里采用代理类（即集成自 NSProxy的子类），重写消息转发的三个方法（参考这篇文章 OC底层原理14-3：消息流程分析之动态方法决议 &amp; 消息转发），以及NSObject的实例方法，来获取异常信息。但是这样的话，还有一个问题，就是NSProxy只能做OC对象的代理，所以需要在safe_free中增加对象类型的判断 以下是完整的野指针探测实现代码 引入fishhook 实现NSProxy的代理子类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!--1、MIZombieProxy.h--&gt;@interface MIZombieProxy : NSProxy@property (nonatomic, assign) Class originClass;@end&lt;!--2、MIZombieProxy.m--&gt;#import &quot;MIZombieProxy.h&quot;@implementation MIZombieProxy- (BOOL)respondsToSelector:(SEL)aSelector&#123; return [self.originClass instancesRespondToSelector:aSelector];&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel&#123; return [self.originClass instanceMethodSignatureForSelector:sel];&#125;- (void)forwardInvocation: (NSInvocation *)invocation&#123; [self _throwMessageSentExceptionWithSelector: invocation.selector];&#125;#define MIZombieThrowMesssageSentException() [self _throwMessageSentExceptionWithSelector: _cmd]- (Class)class&#123; MIZombieThrowMesssageSentException(); return nil;&#125;- (BOOL)isEqual:(id)object&#123; MIZombieThrowMesssageSentException(); return NO;&#125;- (NSUInteger)hash&#123; MIZombieThrowMesssageSentException(); return 0;&#125;- (id)self&#123; MIZombieThrowMesssageSentException(); return nil;&#125;- (BOOL)isKindOfClass:(Class)aClass&#123; MIZombieThrowMesssageSentException(); return NO;&#125;- (BOOL)isMemberOfClass:(Class)aClass&#123; MIZombieThrowMesssageSentException(); return NO;&#125;- (BOOL)conformsToProtocol:(Protocol *)aProtocol&#123; MIZombieThrowMesssageSentException(); return NO;&#125;- (BOOL)isProxy&#123; MIZombieThrowMesssageSentException(); return NO;&#125;- (NSString *)description&#123; MIZombieThrowMesssageSentException(); return nil;&#125;#pragma mark - MRC- (instancetype)retain&#123; MIZombieThrowMesssageSentException(); return nil;&#125;- (oneway void)release&#123; MIZombieThrowMesssageSentException();&#125;- (void)dealloc&#123; MIZombieThrowMesssageSentException(); [super dealloc];&#125;- (NSUInteger)retainCount&#123; MIZombieThrowMesssageSentException(); return 0;&#125;- (struct _NSZone *)zone&#123; MIZombieThrowMesssageSentException(); return nil;&#125;#pragma mark - private- (void)_throwMessageSentExceptionWithSelector:(SEL)selector&#123; @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;(-[%@ %@]) was sent to a zombie object at address: %p&quot;, NSStringFromClass(self.originClass),NSStringFromSelector(selector), self] userInfo:nil];&#125;@end hook free 方法的具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165&lt;!--1、MISafeFree.h--&gt;@interface MISafeFree : NSObject//系统警告时，用函数释放一些内存void free_safe_mem(size_t freeNum);@end&lt;!--2、MISafeFree.m--&gt;#import &quot;MISafeFree.h&quot;#import &quot;queue.h&quot;#import &quot;fishhook.h&quot;#import &quot;MIZombieProxy.h&quot;#import &lt;dlfcn.h&gt;#import &lt;objc/runtime.h&gt;#import &lt;malloc/malloc.h&gt;//用于保存zombie类static Class kMIZombieIsa;//用于保存zombie类的实例变量大小static size_t kMIZombieSize;//用于表示调用free函数static void(* orig_free)(void *p);//用于保存已注册的类的集合static CFMutableSetRef registeredClasses = nil;/* 用来保存自己保留的内存 - 1、队列要线程安全或者自己加锁 - 2、这个队列内部应该尽量少申请和释放堆内存 */struct DSQueue *_unfreeQueue = NULL;//用来记录自己保存的内存的大小int unfreeSize = 0;//最多存储的内存，大于这个值就释放一部分#define MAX_STEAL_MEM_SIZE 1024*1024*100//最多保留的指针个数，超过就释放一部分#define MAX_STEAL_MEM_NUM 1024*1024*10//每次释放时释放的指针数量#define BATCH_FREE_NUM 100@implementation MISafeFree#pragma mark - Public Method//系统警告时，用函数释放一些内存void free_safe_mem(size_t freeNum)&#123;#ifdef DEBUG //获取队列的长度 size_t count = ds_queue_length(_unfreeQueue); //需要释放的内存大小 freeNum = freeNum &gt; count ? count : freeNum; //遍历并释放 for (int i = 0; i &lt; freeNum; i++) &#123; //获取未释放的内存块 void *unfreePoint = ds_queue_get(_unfreeQueue); //创建内存块申请的大小 size_t memSize = malloc_size(unfreePoint); //原子减操作，多线程对全局变量进行自减 __sync_fetch_and_sub(&amp;unfreeSize, (int)memSize); //释放 orig_free(unfreePoint); &#125;#endif&#125;#pragma mark - Life Circle+ (void)load&#123;#ifdef DEBUG loadZombieProxyClass(); init_safe_free();#endif&#125;#pragma mark - Private Methodvoid safe_free(void* p)&#123; //获取自己保留的内存的大小 int unFreeCount = ds_queue_length(_unfreeQueue); //保留的内存大于一定值时就释放一部分 if (unFreeCount &gt; MAX_STEAL_MEM_NUM*0.9 || unfreeSize&gt;MAX_STEAL_MEM_SIZE) &#123; free_safe_mem(BATCH_FREE_NUM); &#125;else&#123; //创建p申请的内存大小 size_t memSize = malloc_size(p); //有足够的空间才覆盖 if (memSize &gt; kMIZombieSize) &#123; //指针强转为id对象 id obj = (id)p; //获取指针原本的类 Class origClass = object_getClass(obj); //判断是不是objc对象 char *type = @encode(typeof(obj)); /* - strcmp 字符串比较 - CFSetContainsValue 查看已注册类中是否有origClass这个类 如果都满足，则将这块内存填充0x55 */ if (strcmp(&quot;@&quot;, type) == 0 &amp;&amp; CFSetContainsValue(registeredClasses, origClass)) &#123; //内存上填充0x55 memset(obj, 0x55, memSize); //将自己类的isa复制过去 memcpy(obj, &amp;kMIZombieIsa, sizeof(void*)); //为obj设置指定的类 object_setClass(obj, [MIZombieProxy class]); //保留obj原本的类 ((MIZombieProxy*)obj).originClass = origClass; //多线程下int的原子加操作，多线程对全局变量进行自加，不用理会线程锁了 __sync_fetch_and_add(&amp;unfreeSize, (int)memSize); //入队 ds_queue_put(_unfreeQueue, p); &#125;else&#123; orig_free(p); &#125; &#125;else&#123; orig_free(p); &#125; &#125;&#125;//加载野指针自定义类void loadZombieProxyClass()&#123; registeredClasses = CFSetCreateMutable(NULL, 0, NULL); //用于保存已注册类的个数 unsigned int count = 0; //获取所有已注册的类 Class *classes = objc_copyClassList(&amp;count); //遍历，并保存到registeredClasses中 for (int i = 0; i &lt; count; i++) &#123; CFSetAddValue(registeredClasses, (__bridge const void *)(classes[i])); &#125; //释放临时变量内存 free(classes); classes = NULL; kMIZombieIsa = objc_getClass(&quot;MIZombieProxy&quot;); kMIZombieSize = class_getInstanceSize(kMIZombieIsa);&#125;//初始化以及free符号重绑定bool init_safe_free()&#123; //初始化用于保存内存的队列 _unfreeQueue = ds_queue_create(MAX_STEAL_MEM_NUM); //dlsym 在打开的库中查找符号的值，即动态调用free函数 orig_free = (void(*)(void*))dlsym(RTLD_DEFAULT, &quot;free&quot;); /* rebind_symbols:符号重绑定 - 参数1：rebindings 是一个rebinding数组，其定义如下 struct rebinding &#123; const char *name; // 目标符号名 void *replacement; // 要替换的符号值（地址值） void **replaced; // 用来存放原来的符号值（地址值） &#125;; - 参数2：rebindings_nel 描述数组的长度 */ //重绑定free符号，让它指向自定义的safe_free函数 rebind_symbols((struct rebinding[])&#123;&#123;&quot;free&quot;, (void*)safe_free&#125;&#125;, 1); return true;&#125;@end 测试 12345678910111213141516171819- (void)viewDidLoad &#123; [super viewDidLoad]; id obj = [[NSObject alloc] init]; self.assignObj = obj; // [MIZombieSniffer installSniffer];&#125;- (IBAction)mallocScribbleAction:(id)sender &#123; UIView* testObj = [[UIView alloc] init]; [testObj release]; for (int i = 0; i &lt; 10; i++) &#123; UIView* testView = [[UIView alloc] initWithFrame:CGRectMake(0,200,CGRectGetWidth(self.view.bounds), 60)]; [self.view addSubview:testView]; &#125; [testObj setNeedsLayout]; &#125; 打印结果如下 Zombie Objects僵尸对象 可以用来检测内存错误（EXC_BAD_ACCESS）,它可以捕获任何阐释访问坏内存的调用 给僵尸对象发送消息的话，它仍然是可以响应的，然后会发生崩溃，并输出错误日志来显示野指针对象调用的类名和方法 苹果的僵尸对象检测原理 首先我们来看下Xcode中僵尸对象是如何实现的，具体操作步骤可以参考这篇文章 iOS Zombie Objects(僵尸对象)原理探索 从 dealloc 的源码中，我们可以看到 Replaced by NSZombie，即 对象释放 时，NSZombie 将 dealloc 里做替换，如下所示 所以僵尸对象的生成过程伪代码如下 1234567891011121314151617181920212223//1、获取到即将deallocted对象所属类（Class）Class cls = object_getClass(self);//2、获取类名const char *clsName = class_getName(cls)//3、生成僵尸对象类名const char *zombieClsName = &quot;_NSZombie_&quot; + clsName;//4、查看是否存在相同的僵尸对象类名，不存在则创建Class zombieCls = objc_lookUpClass(zombieClsName);if (!zombieCls) &#123; //5、获取僵尸对象类 _NSZombie_ Class baseZombieCls = objc_lookUpClass(“_NSZombie_&quot;); //6、创建 zombieClsName 类 zombieCls = objc_duplicateClass(baseZombieCls, zombieClsName, 0);&#125;//7、在对象内存未被释放的情况下销毁对象的成员变量及关联引用。 objc_destructInstance(self);//8、修改对象的 isa 指针，令其指向特殊的僵尸类objc_setClass(self, zombieCls); 当僵尸对象再次被访问时，将进入消息转发流程，开始处理僵尸对象访问，输出日志并发生crash 所以僵尸对象触发流程伪代码如下 12345678910111213141516171819//1、获取对象classClass cls = object_getClass(self);//2、获取对象类名const char *clsName = class_getName(cls);//3、检测是否带有前缀_NSZombie_if (string_has_prefix(clsName, &quot;_NSZombie_&quot;)) &#123;//4、获取被野指针对象类名 const char *originalClsName = substring_from(clsName, 10); //5、获取当前调用方法名 const char *selectorName = sel_getName(_cmd); //6、输出日志 Log(&#x27;&#x27;*** - [%s %s]: message sent to deallocated instance %p&quot;, originalClsName, selectorName, self); //7、结束进程 abort(); 所以综上所述，这野指针探测方式的思路是：dealloc 方法的替换，其关键是调用 objc_destructInstance 来解除对象的关联引用 野指针探测实现2这种思路主要来源 sindrilin 的源码，其主要思路是： 野指针检测流程 开启野指针检测 设值监控到野指针的回调block，在block中打印信息，或者存储堆栈 检测到野指针是否crash 最大内存占用空间 是否记录dealloc调用栈 监控策略 只监控自定义对象 白名单策略 黑名单策略 监控所有对象 交换NSObject的dealloc方法 触发野指针 开始处理对象 是否达到替换条件 根据监控策略，是否属于要检测的类 空间是否足够 如果符合条件，则获取对象，并解除引用，如果不符合则正常释放，即调用原来的dealloc方法 向对象内填充数据 赋值僵尸对象的类指针替换isa 对象+dealloc调用栈，保存在僵尸对象中 根据情况是否清理内存和对象 通过僵尸对象检测的实现思路 通过OC中 Method Swizzling，交换 根类NSObject和NSProxy 的 dealloc 方法为 自定义的dealloc 方法 为了 避免内存空间释放后被重写造成野指针 的问题，通过 字典存储被释放的对象，同时设置在 30s后调用dealloc方法将字典中存储的对象释放，避免内存增大 为了获取更多的崩溃信息，这里同样需要创建NSProxy的子类 具体实现 创建NSProxy的子类，其实现与上面的 MIZombieProxy 是一模一样的 hook dealloc 函数的具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200&lt;!--1、MIZombieSniffer.h--&gt;@interface MIZombieSniffer : NSObject/*! * @method installSniffer * 启动zombie检测 */+ (void)installSniffer;/*! * @method uninstallSnifier * 停止zombie检测 */+ (void)uninstallSnifier;/*! * @method appendIgnoreClass * 添加白名单类 */+ (void)appendIgnoreClass: (Class)cls;@end&lt;!--2、MIZombieSniffer.m--&gt;#import &quot;MIZombieSniffer.h&quot;#import &quot;MIZombieProxy.h&quot;#import &lt;objc/runtime.h&gt;//typedef void (*MIDeallocPointer) (id objc);//野指针探测器是否开启static BOOL _enabled = NO;//根类static NSArray *_rootClasses = nil;//用于存储被释放的对象static NSDictionary&lt;id, NSValue*&gt; *_rootClassDeallocImps = nil;//白名单static inline NSMutableSet *__mi_sniffer_white_lists()&#123; //创建白名单集合 static NSMutableSet *mi_sniffer_white_lists; //单例初始化白名单集合 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; mi_sniffer_white_lists = [[NSMutableSet alloc] init]; &#125;); return mi_sniffer_white_lists;&#125;static inline void __mi_dealloc(__unsafe_unretained id obj)&#123; //获取对象的类 Class currentCls = [obj class]; Class rootCls = currentCls; //获取非NSObject和NSProxy的类 while (rootCls != [NSObject class] &amp;&amp; rootCls != [NSProxy class]) &#123; //获取rootCls的父类，并赋值 rootCls = class_getSuperclass(rootCls); &#125; //获取类名 NSString *clsName = NSStringFromClass(rootCls); //根据类名获取dealloc的imp指针 MIDeallocPointer deallocImp = NULL; [[_rootClassDeallocImps objectForKey:clsName] getValue:&amp;deallocImp]; if (deallocImp != NULL) &#123; deallocImp(obj); &#125;&#125;//hook交换deallocstatic inline IMP __mi_swizzleMethodWithBlock(Method method, void *block)&#123; /* imp_implementationWithBlock ：接收一个block参数，将其拷贝到堆中，返回一个trampoline 可以让block当做任何一个类的方法的实现，即当做类的方法的IMP来使用 */ IMP blockImp = imp_implementationWithBlock((__bridge id _Nonnull)(block)); //method_setImplementation 替换掉method的IMP return method_setImplementation(method, blockImp);&#125;@implementation MIZombieSniffer//初始化根类+ (void)initialize&#123; _rootClasses = [@[[NSObject class], [NSProxy class]] retain];&#125;#pragma mark - public+ (void)installSniffer&#123; @synchronized (self) &#123; if (!_enabled) &#123; //hook根类的dealloc方法 [self _swizzleDealloc]; _enabled = YES; &#125; &#125;&#125;+ (void)uninstallSnifier&#123; @synchronized (self) &#123; if (_enabled) &#123; //还原dealloc方法 [self _unswizzleDealloc]; _enabled = NO; &#125; &#125;&#125;//添加百名单+ (void)appendIgnoreClass:(Class)cls&#123; @synchronized (self) &#123; NSMutableSet *whiteList = __mi_sniffer_white_lists(); NSString *clsName = NSStringFromClass(cls); [clsName retain]; [whiteList addObject:clsName]; &#125;&#125;#pragma mark - private+ (void)_swizzleDealloc&#123; static void *swizzledDeallocBlock = NULL; //定义block，作为方法的IMP static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; swizzledDeallocBlock = (__bridge void *)[^void(id obj) &#123; //获取对象的类 Class currentClass = [obj class]; //获取类名 NSString *clsName = NSStringFromClass(currentClass); //判断该类是否在白名单类 if ([__mi_sniffer_white_lists() containsObject: clsName]) &#123; //如果在白名单内，则直接释放对象 __mi_dealloc(obj); &#125; else &#123; //修改对象的isa指针，指向MIZombieProxy /* valueWithBytes:objCType 创建并返回一个包含给定值的NSValue对象，该值会被解释为一个给定的NSObject类型 - 参数1：NSValue对象的值 - 参数2：给定值的对应的OC类型，需要使用编译器指令@encode来创建 */ NSValue *objVal = [NSValue valueWithBytes: &amp;obj objCType: @encode(typeof(obj))]; //为obj设置指定的类 object_setClass(obj, [MIZombieProxy class]); //保留对象原本的类 ((MIZombieProxy *)obj).originClass = currentClass; //设置在30s后调用dealloc将存储的对象释放，避免内存空间的增大 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(30 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; __unsafe_unretained id deallocObj = nil; //获取需要dealloc的对象 [objVal getValue: &amp;deallocObj]; //设置对象的类为原本的类 object_setClass(deallocObj, currentClass); //释放 __mi_dealloc(deallocObj); &#125;); &#125; &#125; copy]; &#125;); //交换了根类NSObject和NSProxy的dealloc方法为originalDeallocImp NSMutableDictionary *deallocImps = [NSMutableDictionary dictionary]; //遍历根类 for (Class rootClass in _rootClasses) &#123; //获取指定类中dealloc方法 Method oriMethod = class_getInstanceMethod([rootClass class], NSSelectorFromString(@&quot;dealloc&quot;)); //hook - 交换dealloc方法的IMP实现 IMP originalDeallocImp = __mi_swizzleMethodWithBlock(oriMethod, swizzledDeallocBlock); //设置IMP的具体实现 [deallocImps setObject: [NSValue valueWithBytes: &amp;originalDeallocImp objCType: @encode(typeof(IMP))] forKey: NSStringFromClass(rootClass)]; &#125; //_rootClassDeallocImps字典存储交换后的IMP实现 _rootClassDeallocImps = [deallocImps copy];&#125;+ (void)_unswizzleDealloc&#123; //还原dealloc交换的IMP [_rootClasses enumerateObjectsUsingBlock:^(Class rootClass, NSUInteger idx, BOOL * _Nonnull stop) &#123; IMP originDeallocImp = NULL; //获取根类类名 NSString *clsName = NSStringFromClass(rootClass); //获取hook后的dealloc实现 [[_rootClassDeallocImps objectForKey:clsName] getValue:&amp;originDeallocImp]; NSParameterAssert(originDeallocImp); //获取原本的dealloc实现 Method oriMethod = class_getInstanceMethod([rootClass class], NSSelectorFromString(@&quot;dealloc&quot;)); //还原dealloc的实现 method_setImplementation(oriMethod, originDeallocImp); &#125;]; //释放 [_rootClassDeallocImps release]; _rootClassDeallocImps = nil;&#125;@end 测试 123456789101112131415161718192021@interface ViewController ()@property (nonatomic, assign) id assignObj;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; id obj = [[NSObject alloc] init]; self.assignObj = obj; [MIZombieSniffer installSniffer];&#125;- (IBAction)zombieObjectAction:(id)sender &#123; NSLog(@&quot;%@&quot;, self.assignObj); &#125; 打印崩溃信息如下","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC学习15：SDWebImage探索","slug":"OC学习/OC学习15：SDWebImage探索","date":"2021-07-13T02:11:45.000Z","updated":"2023-03-08T23:03:34.456Z","comments":true,"path":"2021/07/13/OC学习/OC学习15：SDWebImage探索/","link":"","permalink":"https://www.bboyzj.cn/2021/07/13/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A015%EF%BC%9ASDWebImage%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"简介SDWebImage 是一个 异步加载图片的库，提供了一个UIImageView+WebCache类支持来自互联网的远程图片，具有缓存管理、异步下载、同一个URL次数控制和优化等特征。 SDWebImage 加载图片的流程 通过 UIImageView+WebCache 类调用 sd_setImageWithURL:placeholderImage调用 UIView+WebCache类中的方法sd_internalSetImageWithURL:placeholderImage:options:context:setImageBlock:progress:completed:，如果有占位图片，先显示占位图片，然后根据 url 处理图片。 如果内存缓存中没有图片，则从磁盘中查找，根据对URL的MD5处理查找图片，如果找到图片，将图片添加到内存缓存，同时将找到的图片返回并显示。 如果磁盘和内存都找不到图片，则需要下载图片，通过共享或重新生成一个下载器SDWebImageDownloader下载图片。 图片下载由NSURLSession来完成，下载完成后对图片进行内存和磁盘缓存，并返回显示。 12// 下载图片 operation.loaderOperation = [imageLoader requestImageWithURL:url options:options context:context progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123; SDWebImageView 缓存机制 首先，SDWebImage的图片缓存采用的是 memory（内存） 和 disk（磁盘） 双重机制，SDImageCache 中有 memoryCache 和 diskCache 两个属性；memoryCache 是将图片存储在内存中 ； diskCache 是将图片放到 NSCacheDiretory 目录中，具体如下： Memory内存中查找：SDImageCache中查找图片缓存，如果找到直接返回，反之进入硬盘查找 Disk硬盘中查找：如果硬盘中找到，还需要将图片存储到 memory 中 ，如果找不到，则下载 下载：使用 downloader下载，失败加入failedURLS集合，下载拒绝再次加载，下载成功则写入 memory 和 disk，并返回显示 Disk缓存策略-APP在结束时执行清理任务： 1）清除过期的缓存文件 2）如果清除过期的缓存文件未满足条件，则先清除最早的文件，并且是折半清除。","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC底层原理40：组件化（二）组件间通讯方式","slug":"OC进阶/OC底层原理40：组件化（二）组件间通讯方式","date":"2021-07-05T06:50:58.000Z","updated":"2023-02-24T10:10:09.000Z","comments":true,"path":"2021/07/05/OC进阶/OC底层原理40：组件化（二）组件间通讯方式/","link":"","permalink":"https://www.bboyzj.cn/2021/07/05/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8640%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/","excerpt":"","text":"前言本文主要讲组件化之间是如何 通讯 的 组件化通讯方案目前的主流方式有三种： URL 路由 target-action protocol 匹配 URL路由目前iOS上大部分路由工具都是基于URL匹配的，或者根据命名约定，用runtime方法进行动态调用 这些动态化的方案的有点是实现简单，缺点是需要维护 字符串表，或者依赖于命名约定，无法在编译时暴露出所有问题，需要在运行时才能发现错误 URL路由方式主要是以蘑菇街为代表的 MGJRouter 其实现思路是： App启动时实例化各组件模块，然后这些组件向 ModuleManager 注册 Url，有些时候不需要实例化，使用class注册 当组件A需要调用组件B时，向 ModuleManager 传递URL，参数跟随URL以GET方式传递，类似openURL。然后由 ModuleManager 负责调度组件B，最后完成任务 1234567// 1.注册某个URLMGJRouter.registerURLPattern(&quot;app://home&quot;) &#123; (info) in print(&quot;info:\\(info)&quot;)&#125;// 2.调用路由MGJRouter.openURL(&quot;app://home&quot;) URL路由的优点 极高的动态性，适合经常开展运营活动的App，例如电商 方便地统一管理多平台的路由规则 易于适配URL Scheme URL路由的缺点 传参方式有限，并且无法利用编译器进行参数类型检查，因此所有的参数都是通过字符串转换而来 只适用于界面模块，不适用于通用模块 参数的格式不明确，是个灵活的 dictionary，也需要有个地方可以查参数格式 不支持storyboard 依赖于字符串硬编码，难以管理，蘑菇街做了个后台专门管理 无法保证所使用的模块一定存在 解耦能力有限，url的注册、实现、使用必须用相同的字符规则，一旦任何一方作出修改都会导致其他方的代码失效，并且重构难度大 除了 MGJRouter，还有以下这些三方框架 routable-ios JLRoutes HHRouter target-action这个方案是基于OC的 runtime、category 特性动态获取模块，例如通过 NSClassFromString 获取类并创建实例，通过 performSelector + NSInvocation 动态调用方法 其主要的代表框架是 casatwy的CTMediator 其实现思路是： 利用 分类 为路由添加新接口，在接口中 通过字符串获取对应的类 通过 runtime 创建实例，动态调用实例的方法 1234567891011121314151617181920212223242526272829//******* 1、分类定义新接口extension CTMediator&#123; @objc func A_showHome()-&gt;UIViewController?&#123; let params = [ kCTMediatorParamsKeySwiftTargetModuleName: &quot;ZJBase_Example&quot; ] if let vc = self.performTarget(&quot;A&quot;, action: &quot;Extension_HomeViewController&quot;, params: params, shouldCacheTarget: false) as? UIViewController&#123; return vc &#125; return nil &#125;&#125;//******* 2、模块提供者提供target-action的调用方式（对外需要加上public关键字）class Target_A: NSObject &#123; @objc func Action_Extension_HomeViewController(_ params: [String: Any])-&gt;UIViewController&#123; let home = HomeViewController() return home &#125;&#125;//******* 3、使用if let vc = CTMediator.sharedInstance().A_showHome() &#123; self.navigationController?.pushViewController(vc, animated: true) &#125; 其模块间的引用关系如下图所示： 缺点 需要在 mediator 和 target 中重新添加每一个接口，模块化时代码较为繁琐 在 category 中仍然引入了 字符串编码，内部使用字典传参，一定程度上也存在和URL路由相同的问题 无法保证使用的模块一定存在，target在修改后，使用者只能在运行时才能发现错误 可能会创建过多的 target 类 CTMediator源码分析 通过分类中调用的 performTarget 来到 CTMediator 中的具体实现，即 performTarget:action:params:shouldCacheTarget:，主要是通过传入的name，找到对应的 target和action 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget&#123; if (targetName == nil || actionName == nil) &#123; return nil; &#125; //在swift中使用时，需要传入对应项目的target名称，否则会找不到视图控制器 NSString *swiftModuleName = params[kCTMediatorParamsKeySwiftTargetModuleName]; // generate target 生成target NSString *targetClassString = nil; if (swiftModuleName.length &gt; 0) &#123; //swift中target文件名拼接 targetClassString = [NSString stringWithFormat:@&quot;%@.Target_%@&quot;, swiftModuleName, targetName]; &#125; else &#123; //OC中target文件名拼接 targetClassString = [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName]; &#125; //缓存中查找target NSObject *target = [self safeFetchCachedTarget:targetClassString]; //缓存中没有target if (target == nil) &#123; //通过字符串获取对应的类 Class targetClass = NSClassFromString(targetClassString); //创建实例 target = [[targetClass alloc] init]; &#125; // generate action 生成action方法名称 NSString *actionString = [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName]; //通过方法名字符串获取对应的sel SEL action = NSSelectorFromString(actionString); if (target == nil) &#123; // 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的 [self NoTargetActionResponseWithTargetString:targetClassString selectorString:actionString originParams:params]; return nil; &#125; //是否需要缓存 if (shouldCacheTarget) &#123; [self safeSetCachedTarget:target key:targetClassString]; &#125; //是否响应sel if ([target respondsToSelector:action]) &#123; //动态调用方法 return [self safePerformAction:action target:target params:params]; &#125; else &#123; // 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理 SEL action = NSSelectorFromString(@&quot;notFound:&quot;); if ([target respondsToSelector:action]) &#123; return [self safePerformAction:action target:target params:params]; &#125; else &#123; // 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。 [self NoTargetActionResponseWithTargetString:targetClassString selectorString:actionString originParams:params]; @synchronized (self) &#123; [self.cachedTarget removeObjectForKey:targetClassString]; &#125; return nil; &#125; &#125;&#125; 进入 safePerformAction: target: params: 实现，主要是通过 invocation 进行 参数传递+消息转发 123456789101112131415- (id)safePerformAction:(SEL)action target:(NSObject *)target params:(NSDictionary *)params&#123; //获取方法签名 NSMethodSignature* methodSig = [target methodSignatureForSelector:action]; if(methodSig == nil) &#123; return nil; &#125; //获取方法签名中的返回类型，然后根据返回值完成参数传递 const char* retType = [methodSig methodReturnType]; //void类型 if (strcmp(retType, @encode(void)) == 0) &#123; ... &#125; //...省略其他类型的判断&#125; protocol classprotocol匹配的 实现思路 是： 将 protocol 和对应的 类 进行 字典匹配 通过用 protocol 获取 class，在 动态创建实例 protocol比较典型的三方矿建就是 阿里的BeeHive，BeeHive 借鉴了Spring Service、Apache DSO的架构理念，采用AOP+扩展App声明周期API 形式，将 业务功能、基础功能 模块以模块方式以解决大型应用中的复杂问题，并让 模块之间以Service形式调用，将复杂问题切分，以AOP方式模块化服务 BeeHive核心思想 各个模块间调用从直接调用对应模块，变成调用 Service 的形式，避免了直接依赖 App声明周期的分发，将耦合在AppDelegate中逻辑拆分，买个模块以微应用的形式独立存在 示例如下 1234567// 1、注册[[BeeHive shareInstance] registerService:@protocol(HomeServiceProtocol) service:[BHViewController class]];// 2、使用#import &quot;BHService.h&quot;id&lt; HomeServiceProtocol &gt; homeVc = [[BeeHive shareInstance] createService:@protocol(HomeServiceProtocol)]; 优点 利用接口调用，实现了参数传递时的类型安全 直接使用模块的protocol接口，无序再重复封装 缺点 用框架来创建所有对象，创建方式不同，即不支持外部传入参数 用 OC runtime 创建对象，不支持swift 只做了 protocol 和 class 的匹配，不支持更复杂的创建方式和依赖注入 无法保证所使用的protocol一定存在对应的模块，也无法直接判断某个protocol是否能用于获取模块 除了 BeeHive，还有 Swinject BeeHive模块注册在 BeeHive 主要是通过 BHModuleManager 来管理各个模块的。BHModuleManager 中只会管理已经被注册过的模块。 BeeHive提供了三种不同的调用形式，静态plist，动态注册，annotation。Module、Service之间没有关联，每个业务模块可以单独实现Module或者Service的功能。 Annotation方式注册这种方式主要是通过 BeeHiveMod 宏进行 Annotation 标记 123456789101112//***** 使用BeeHiveMod(ShopModule)//***** BeeHiveMod的宏定义#define BeeHiveMod(name) \\class BeeHive; char * k##name##_mod BeeHiveDATA(BeehiveMods) = &quot;&quot;#name&quot;&quot;;//***** BeeHiveDATA的宏定义 #define BeeHiveDATA(sectname) __attribute((used, section(&quot;__DATA,&quot;#sectname&quot; &quot;)))//***** 全部转换出来后为下面的格式char * kShopModule_mod __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveMods&quot;&quot; &quot;))) = &quot;&quot;&quot;ShopModule&quot;&quot;&quot;; 这里针对 __attribute 需要说明以下几点 第一个参数 used：用来修饰函数，被used修饰以后，意味着即使函数没有被引用，在Release下也不会被优化。如果不加这个修饰，那么Release环境链接器下会去掉没有被引用的段。 通过使用 __attribute__((section(&quot;name&quot;))) 来指明哪个段。数据则用__attribute__((used)) 来标记，防止链接器会优化删除未被使用的段，然后将模块注入到 __DATA 中 进入 BHReadConfiguration 方法，主要是通过 Mach-O 找到存储的数据段，取出放入数组中 1234567891011121314151617181920212223242526NSArray&lt;NSString *&gt;* BHReadConfiguration(char *sectionName,const struct mach_header *mhp)&#123; NSMutableArray *configs = [NSMutableArray array]; unsigned long size = 0;#ifndef __LP64__ // 找到之前存储的数据段(Module找BeehiveMods段 和 Service找BeehiveServices段)的一片内存 uintptr_t *memory = (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);#else const struct mach_header_64 *mhp64 = (const struct mach_header_64 *)mhp; uintptr_t *memory = (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);#endif unsigned long counter = size/sizeof(void*); // 把特殊段里面的数据都转换成字符串存入数组中 for(int idx = 0; idx &lt; counter; ++idx)&#123; char *string = (char*)memory[idx]; NSString *str = [NSString stringWithUTF8String:string]; if(!str)continue; BHLog(@&quot;config = %@&quot;, str); if(str) [configs addObject:str]; &#125; return configs; &#125; 读取本地Plist文件 首先，需要设置好路径 1[BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/BeeHive&quot;; // 可选，默认为BeeHive.bundle/BeeHive.plist 创建plist文件，Plist文件的格式也是数组中包含多个字典。字典里面有两个Key，一个是@&quot;moduleLevel&quot;，另一个是 @&quot;moduleClass&quot; 。注意根的数组的名字叫@“moduleClasses”。 进入 loadLocalModules 方法，主要是从 Plist 里面取出数组，然后把数组加入到BHModuleInfos 数组里面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//初始化context时，加载Modules和Services-(void)setContext:(BHContext *)context&#123; _context = context; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [self loadStaticServices]; [self loadStaticModules]; &#125;);&#125;👇//加载modules- (void)loadStaticModules&#123; // 读取本地plist文件里面的Module，并注册到BHModuleManager的BHModuleInfos数组中 [[BHModuleManager sharedManager] loadLocalModules]; //注册所有modules，在内部根据优先级进行排序 [[BHModuleManager sharedManager] registedAllModules]; &#125;👇- (void)loadLocalModules&#123; //plist文件路径 NSString *plistPath = [[NSBundle mainBundle] pathForResource:[BHContext shareInstance].moduleConfigName ofType:@&quot;plist&quot;]; //判断文件是否存在 if (![[NSFileManager defaultManager] fileExistsAtPath:plistPath]) &#123; return; &#125; //读取整个文件[@&quot;moduleClasses&quot; : 数组] NSDictionary *moduleList = [[NSDictionary alloc] initWithContentsOfFile:plistPath]; //通过moduleClasses key读取 数组 [[@&quot;moduleClass&quot;:&quot;aaa&quot;, @&quot;moduleLevel&quot;: @&quot;bbb&quot;], [...]] NSArray&lt;NSDictionary *&gt; *modulesArray = [moduleList objectForKey:kModuleArrayKey]; NSMutableDictionary&lt;NSString *, NSNumber *&gt; *moduleInfoByClass = @&#123;&#125;.mutableCopy; //遍历数组 [self.BHModuleInfos enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; [moduleInfoByClass setObject:@1 forKey:[obj objectForKey:kModuleInfoNameKey]]; &#125;]; [modulesArray enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if (!moduleInfoByClass[[obj objectForKey:kModuleInfoNameKey]]) &#123; //存储到 BHModuleInfos 中 [self.BHModuleInfos addObject:obj]; &#125; &#125;];&#125; load方法注册 该方法 注册Module 就是在 Load 方法里面注册Module的类 1234+ (void)load&#123; [BeeHive registerDynamicModule:[self class]];&#125; 进入 registerDynamicModule 实现 123456789101112131415+ (void)registerDynamicModule:(Class)moduleClass&#123; [[BHModuleManager sharedManager] registerDynamicModule:moduleClass];&#125;👇- (void)registerDynamicModule:(Class)moduleClass&#123; [self registerDynamicModule:moduleClass shouldTriggerInitEvent:NO];&#125;👇- (void)registerDynamicModule:(Class)moduleClass shouldTriggerInitEvent:(BOOL)shouldTriggerInitEvent&#123; [self addModuleFromObject:moduleClass shouldTriggerInitEvent:shouldTriggerInitEvent];&#125; 其底层还是同第一种方式一样，最终会走到addModuleFromObject:shouldTriggerInitEvent:方法中 load方法，还可以使用 BH_EXPORT_MODULE 宏代替 123#define BH_EXPORT_MODULE(isAsync) \\+ (void)load &#123; [BeeHive registerDynamicModule:[self class]]; &#125; \\-(BOOL)async &#123; return [[NSString stringWithUTF8String:#isAsync] boolValue];&#125; BH_EXPORT_MODULE 宏里面可以传入一个参数，代表 是否异步加载Module模块，如果是YES就是 异步加载，如果是 NO 就是 同步加载。 BeeHive 模块事件 BeeHive会给每个模块提供生命周期事件，用于与BeeHive宿主环境进行必要信息交互，感知模块生命周期的变化。 BeeHive各个模块会收到一些事件。在 BHModuleManager 中，所有的事件被定义成了BHModuleEventType 枚举。如下所示，其中有2个事件很特殊，一个是 BHMInitEvent，一个是 BHMTearDownEvent 1234567891011121314151617181920212223242526272829303132typedef NS_ENUM(NSInteger, BHModuleEventType)&#123; //设置Module模块 BHMSetupEvent = 0, //用于初始化Module模块，例如环境判断，根据不同环境进行不同初始化 BHMInitEvent, //用于拆除Module模块 BHMTearDownEvent, BHMSplashEvent, BHMQuickActionEvent, BHMWillResignActiveEvent, BHMDidEnterBackgroundEvent, BHMWillEnterForegroundEvent, BHMDidBecomeActiveEvent, BHMWillTerminateEvent, BHMUnmountEvent, BHMOpenURLEvent, BHMDidReceiveMemoryWarningEvent, BHMDidFailToRegisterForRemoteNotificationsEvent, BHMDidRegisterForRemoteNotificationsEvent, BHMDidReceiveRemoteNotificationEvent, BHMDidReceiveLocalNotificationEvent, BHMWillPresentNotificationEvent, BHMDidReceiveNotificationResponseEvent, BHMWillContinueUserActivityEvent, BHMContinueUserActivityEvent, BHMDidFailToContinueUserActivityEvent, BHMDidUpdateUserActivityEvent, BHMHandleWatchKitExtensionRequestEvent, BHMDidCustomEvent = 1000 &#125;; 主要分为三种 系统事件：主要是指 Application生命周期事件! 一般的做法是AppDelegate改为 继承自BHAppDelegate 1@interface TestAppDelegate : BHAppDelegate &lt;UIApplicationDelegate&gt; 应用事件：官方给出的流程图，其中 modSetup、modInit 等，可以用于编码实现各插件模块的设置与初始化。 自定义事件 以上所有的事件都可以通过调用 BHModuleManager 的 triggerEvent: 来处理。 123456789101112131415161718192021222324252627282930313233343536- (void)triggerEvent:(NSInteger)eventType&#123; [self triggerEvent:eventType withCustomParam:nil]; &#125;👇- (void)triggerEvent:(NSInteger)eventType withCustomParam:(NSDictionary *)customParam &#123; [self handleModuleEvent:eventType forTarget:nil withCustomParam:customParam];&#125;👇#pragma mark - module protocol- (void)handleModuleEvent:(NSInteger)eventType forTarget:(id&lt;BHModuleProtocol&gt;)target withCustomParam:(NSDictionary *)customParam&#123; switch (eventType) &#123; //初始化事件 case BHMInitEvent: //special [self handleModulesInitEventForTarget:nil withCustomParam :customParam]; break; //析构事件 case BHMTearDownEvent: //special [self handleModulesTearDownEventForTarget:nil withCustomParam:customParam]; break; //其他3类事件 default: &#123; NSString *selectorStr = [self.BHSelectorByEvent objectForKey:@(eventType)]; [self handleModuleEvent:eventType forTarget:nil withSeletorStr:selectorStr andCustomParam:customParam]; &#125; break; &#125; &#125; 从上面的代码中可以发现，除去 BHMInitEvent 初始化事件和 BHMTearDownEvent 拆除Module事件这两个特殊事件以外，所有的事件都是调用的handleModuleEvent:forTarget:withSeletorStr:andCustomParam:方法，其内部实现主要是遍历 moduleInstances 实例数组，调用 performSelector:withObject: 方法实现对应方法调用 123456789101112131415161718192021222324252627282930313233343536- (void)handleModuleEvent:(NSInteger)eventType forTarget:(id&lt;BHModuleProtocol&gt;)target withSeletorStr:(NSString *)selectorStr andCustomParam:(NSDictionary *)customParam&#123; BHContext *context = [BHContext shareInstance].copy; context.customParam = customParam; context.customEvent = eventType; if (!selectorStr.length) &#123; selectorStr = [self.BHSelectorByEvent objectForKey:@(eventType)]; &#125; SEL seletor = NSSelectorFromString(selectorStr); if (!seletor) &#123; selectorStr = [self.BHSelectorByEvent objectForKey:@(eventType)]; seletor = NSSelectorFromString(selectorStr); &#125; NSArray&lt;id&lt;BHModuleProtocol&gt;&gt; *moduleInstances; if (target) &#123; moduleInstances = @[target]; &#125; else &#123; moduleInstances = [self.BHModulesByEvent objectForKey:@(eventType)]; &#125; //遍历 moduleInstances 实例数组，调用performSelector:withObject:方法实现对应方法调用 [moduleInstances enumerateObjectsUsingBlock:^(id&lt;BHModuleProtocol&gt; moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) &#123; if ([moduleInstance respondsToSelector:seletor]) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; //进行方法调用 [moduleInstance performSelector:seletor withObject:context];#pragma clang diagnostic pop [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@&quot;%@ --- %@&quot;, [moduleInstance class], NSStringFromSelector(seletor)]]; &#125; &#125;];&#125; 注意:这里所有的 Module 必须是遵循 BHModuleProtocol 的，否则无法接收到这些事件的消息。 BeeHive模块调用 在BeeHive中是通过 BHServiceManager 来管理各个 Protocol 的。BHServiceManager 中只会管理已经被注册过的 Protocol。 注册 Protocol 的方式总共有三种，和注册 Module 是一样一一对应的 Annotation方式注册 123456789//****** 1、通过BeeHiveService宏进行Annotation标记BeeHiveService(HomeServiceProtocol,BHViewController)//****** 2、宏定义#define BeeHiveService(servicename,impl) \\class BeeHive; char * k##servicename##_service BeeHiveDATA(BeehiveServices) = &quot;&#123; \\&quot;&quot;#servicename&quot;\\&quot; : \\&quot;&quot;#impl&quot;\\&quot;&#125;&quot;;//****** 3、转换后的格式，也是将其存储到特殊的段char * kHomeServiceProtocol_service __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveServices&quot;&quot; &quot;))) = &quot;&#123; \\&quot;&quot;&quot;HomeServiceProtocol&quot;&quot;\\&quot; : \\&quot;&quot;&quot;BHViewController&quot;&quot;\\&quot;&#125;&quot;; 读取本地plist文件 首先同Module一样，需要先设置好路径 1[BHContext shareInstance].serviceConfigName = @&quot;BeeHive.bundle/BHService&quot;; 设置plist文件 同样也是在 setContext 时注册 services 12345678910111213141516171819202122232425262728293031//加载services-(void)loadStaticServices&#123; [BHServiceManager sharedManager].enableException = self.enableException; [[BHServiceManager sharedManager] registerLocalServices]; &#125;👇- (void)registerLocalServices&#123; NSString *serviceConfigName = [BHContext shareInstance].serviceConfigName; //获取plist文件路径 NSString *plistPath = [[NSBundle mainBundle] pathForResource:serviceConfigName ofType:@&quot;plist&quot;]; if (!plistPath) &#123; return; &#125; NSArray *serviceList = [[NSArray alloc] initWithContentsOfFile:plistPath]; [self.lock lock]; //遍历并存储到allServicesDict中 for (NSDictionary *dict in serviceList) &#123; NSString *protocolKey = [dict objectForKey:@&quot;service&quot;]; NSString *protocolImplClass = [dict objectForKey:@&quot;impl&quot;]; if (protocolKey.length &gt; 0 &amp;&amp; protocolImplClass.length &gt; 0) &#123; [self.allServicesDict addEntriesFromDictionary:@&#123;protocolKey:protocolImplClass&#125;]; &#125; &#125; [self.lock unlock];&#125; load方法注册 在 Load 方法里面注册 Protocol 协议，主要是调用 BeeHive 里面的registerService:service: 完成 protocol 的注册 123456789+ (void)load&#123; [[BeeHive shareInstance] registerService:@protocol(UserTrackServiceProtocol) service:[BHUserTrackViewController class]];&#125;👇- (void)registerService:(Protocol *)proto service:(Class) serviceClass&#123; [[BHServiceManager sharedManager] registerService:proto implClass:serviceClass];&#125; 到此，三种方式就创建完成了 Protocol的获取 Protocol 与 Module 的区别在于，Protocol 比 Module 多了一个方法，可以返回 Protocol实例对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- (id)createService:(Protocol *)proto;&#123; return [[BHServiceManager sharedManager] createService:proto];&#125;👇- (id)createService:(Protocol *)service&#123; return [self createService:service withServiceName:nil];&#125;👇- (id)createService:(Protocol *)service withServiceName:(NSString *)serviceName &#123; return [self createService:service withServiceName:serviceName shouldCache:YES];&#125;👇- (id)createService:(Protocol *)service withServiceName:(NSString *)serviceName shouldCache:(BOOL)shouldCache &#123; if (!serviceName.length) &#123; serviceName = NSStringFromProtocol(service); &#125; id implInstance = nil; //判断protocol是否已经注册过 if (![self checkValidService:service]) &#123; if (self.enableException) &#123; @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ protocol does not been registed&quot;, NSStringFromProtocol(service)] userInfo:nil]; &#125; &#125; NSString *serviceStr = serviceName; //如果有缓存，则直接从缓存中获取 if (shouldCache) &#123; id protocolImpl = [[BHContext shareInstance] getServiceInstanceFromServiceName:serviceStr]; if (protocolImpl) &#123; return protocolImpl; &#125; &#125; //获取类后，然后响应下层的方法 Class implClass = [self serviceImplClass:service]; if ([[implClass class] respondsToSelector:@selector(singleton)]) &#123; if ([[implClass class] singleton]) &#123; if ([[implClass class] respondsToSelector:@selector(shareInstance)]) //创建单例对象 implInstance = [[implClass class] shareInstance]; else //创建实例对象 implInstance = [[implClass alloc] init]; if (shouldCache) &#123; //缓存 [[BHContext shareInstance] addServiceWithImplInstance:implInstance serviceName:serviceStr]; return implInstance; &#125; else &#123; return implInstance; &#125; &#125; &#125; return [[implClass alloc] init];&#125; createService 会先检查Protocol协议是否是注册过的。然后接着取出字典里面对应的Class，如果实现了 shareInstance 方法，那么就创建一个 单例对象，如果没有，那么就创建一个 实例对象。如果还实现了singleton，就能进一步的把 implInstance 和serviceStr 对应的加到 BHContext 的 servicesByName 字典里面 缓存 起来。这样就可以随着上下文传递了 进入 serviceImplClass 实现，从这里可以看出 protocol 和 类 是通过 字典 绑定的，protocol作为key，serviceImp（类的名字）作为value 123456789- (Class)serviceImplClass:(Protocol *)service&#123; //通过字典将 协议 和 类 绑定，其中协议作为key，serviceImp（类的名字）作为value NSString *serviceImpl = [[self servicesDict] objectForKey:NSStringFromProtocol(service)]; if (serviceImpl.length &gt; 0) &#123; return NSClassFromString(serviceImpl); &#125; return nil;&#125; Module &amp; Protocol这里简单总结下： 对于 Module：数组存储 对于 Protocol：通过字典将 protocol 与 类 进行 绑定，key 为 protocol， value 为 serviceImp 即类名 辅助类 BHConfig 类：是一个单例，其内部有一个 NSMutableDictionary 类型的 config 属性，该属性维护了一些动态的环境变量，作为 BHContext 的补充存在 BHContext 类：是一个单例，其内部有两个 NSMutableDictionary 的属性，分别是 modulesByName 和 servicesByName。这个类主要用来保存上下文信息的。例如在 application:didFinishLaunchingWithOptions: 的时候，就可以初始化大量的上下文信息 12345//保存信息[BHContext shareInstance].application = application;[BHContext shareInstance].launchOptions = launchOptions;[BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/BeeHive&quot;;//可选，默认为BeeHive.bundle/BeeHive.plist[BHContext shareInstance].serviceConfigName = @&quot;BeeHive.bundle/BHService&quot;; BHTimeProfiler 类：用来进行计算时间性能方面的Profiler BHWatchDog 类：用来开一个线程，监听主线程是否堵塞","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理39：组件化（一）方案","slug":"OC进阶/OC底层原理39：组件化（一）方案","date":"2021-06-22T06:50:12.000Z","updated":"2023-03-04T15:21:45.000Z","comments":true,"path":"2021/06/22/OC进阶/OC底层原理39：组件化（一）方案/","link":"","permalink":"https://www.bboyzj.cn/2021/06/22/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8639%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%B9%E6%A1%88/","excerpt":"","text":"组件化方案 常用的组件化方案主要有两种： 本地组件化：主要是通过在 工程中创建library，利用 cocoapods 的 workspec 进行本地管理，不需要将项目上传git，而是直接在本项目中以 framework 的方法进行调用 cocoapods组件化：主要是利用 cocoapods 来进行管理模块的 远程管理，需要将项目上传git（需要注意：这里的组件化模块分为 公有库 和 私有库，对公司而言，一般是 私有库） 本地组件化创建主工程 首先创建一个名为 Modularization 的工程 集成 cocoapods，进行本地管理 1234zhangjian@zhangjiandeMBP ~ % cd /Users/zhangjian/Desktop/Modularization zhangjian@zhangjiandeMBP Modularization % pod initIgnoring ffi-1.13.1 because its extensions are not built. Try: gem pristine ffi --version 1.13.1zhangjian@zhangjiandeMBP Modularization % pod install 创建组件假设有以下几个模块 主工程：承载主要的表层业务代码 Core：独立存在，应用加密、接口请求等敏感代码 Base：基类封装，拓展，基本的数据处理 Service：服务层，封装业务工具类，例如网络层服务、持久化服务等 Pods：三方依赖 其中，各个模块间的关系如下图 下面，我们来进行模块的创建，以 Core 模块为例： 选择 File -&gt; new -&gt; project -&gt; iOS -&gt; Framework，新建一个 ZJCore 模块 选择正确的 Group 和 WorkSpace（这里注意：创建的 library 最好放在 主工程根目录下，否则后续的 podfile 执行 pod install 会报错） 创建成功后，看到的结果如下： 将创建的 library 的 Build Settings -&gt; Mach-O Type 修改为静态库 Static Library 主工程调用Library 在 ZJCore 中新建一个文件，并添加如下代码 1234567@interface ZJCoreSetting : NSObject// 声明属性@property (nonatomic,copy)NSString * name;@end@implementation ZJCoreSetting@end 在 Build Phases -&gt; Headers -&gt; Public 中将新建的文件拖拽到 Puclic 中，这样主工程才能访问该文件 在ZJCore文件中添加引用 在主工程中，选择 target -&gt; Frameworks,Libraries,and Embedded Content -&gt; + 号 -&gt; 添加 ZJCore，只需要build主工程，library能够自动联编 使用首先 #import &lt;ZJCore/ZJCoreSetting.h&gt;，然后使用 这里需要注意的是，子library之间的互相调用，与主工程调用library类似，主需要添加依赖、暴露header即可 使用cocoapods管理三方依赖假设我们需要在 ZJCore 中封装网络层代码，需要用到三方库 AFNetworking，在podfile中有如下配置： 12345678910111213141516171819202122232425262728# Uncomment the next line to define a global platform for your projectplatform :ios, &#x27;9.0&#x27;################# 三方依赖# 网络def network_layer_pods pod &#x27;AFNetworking&#x27;end################# 模块target &#x27;ZJCore&#x27; do # 配置libray路径 project &#x27;ZJCore/ZJCore.xcodeproj&#x27; network_layer_podsend################# 主工程target &#x27;Modularization&#x27; do # Comment the next line if you don&#x27;t want to use dynamic frameworks use_frameworks! network_layer_pods # Pods for Modularizationend 终端 pod install ，然后等待成功，成功后你可以在 ZJCore 模块中引用头文件 #import &lt;AFNetworking.h&gt; 并使用三方库如下： 到此，一个本地组件化的模块就配置完成了 cocoapods组件化除了本地组件化，还可以使用 cocoapods，其原理如下图所示 这里还是以本地组件化中的结构为例 创建私有仓库 在 github 上创建一个 MySpecs 仓库 具体步骤：登录github -&gt; 点击右上角+号 -&gt; new reponsitory -&gt; 输入 repository name 为 MySpecs，选择仓库类型为 private，点击 Create reponsitory 将私有仓库添加至本地 ~/.cocoapods/repos 目录 1pod repo add MySpecs git@github.com:13718004742/MySpecs.git 查看添加结果 创建pods工程，即组件化工程 使用终端创建 ZJServices 模块 12% cd Desktop % pod lib create ZJServices 根据提示一次输入：iOS、Objc、Yes、None、No、ZJ 进入模块的目录，将文件拷贝至 ZJServices -&gt; Classes 中，删掉 ReplaceMe.m -&gt; 替换成你封装好的文件 执行 pod install，会将 Classes更新至pods中 12% cd /Users/zhangjian/Desktop/ZJServices/Example% pod install 成功后，查看工程结构如下： 配置pods工程修改模块的配置文件，即 ZJServices.podspec 如果需要依赖三方库，需要配置 s.dependecy 1s.dependency &#x27;AFNetworking&#x27;, &#x27;~&gt; 4.0.1&#x27; 如果模块间需要相互引用，同样需要配置 s.dependency，以 ZJCore 为例，需要引用 ZJService，在桌面以同样的方式再次创建一个 ZJCore，然后修改如下： 12// 1.修改 podspec 文件s.dependency &#x27;ZJServices&#x27; 12// 2. 修改podfile 文件pod &#x27;ZJServices&#x27;, :path =&gt; &#x27;../../ZJServices&#x27; 如果需要加载资源，如 图片/json/bundle 文件等 在模块的 Assets 文件夹中添加资源文件 在 specs 里配置资源路径（必须配置！！否则无法读取资源） 访问时需要指定资源文件路径 1234// 1. 修改 podspec 文件，自动创建ZJCore.bundles.resource_bundles = &#123; &#x27;ZJCore&#x27; =&gt; [&#x27;ZJCore/Assets/*.png&#x27;] &#125; ZJCore 为显示的图片资源的 bundle 名字，在本地会显示 ZJCore.bundle，这个 可以自定义，ZJCore/Assets 为图片文件目录，回到 ZJCore 的 Example 模块，安装 pod install 12345678910111213141516171819// 2. 使用UIImageView *imgView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];imgView.backgroundColor = [UIColor yellowColor];[self.view addSubview:imgView]; //到指定目录NSURL * bundleURL = [[NSBundle mainBundle] URLForResource:@&quot;Frameworks&quot; withExtension:nil];bundleURL = [bundleURL URLByAppendingPathComponent:@&quot;ZJCore&quot;];bundleURL = [bundleURL URLByAppendingPathExtension:@&quot;framework&quot;];if (bundleURL) &#123; NSBundle *imgBundle = [NSBundle bundleWithURL:bundleURL]; bundleURL = [imgBundle URLForResource:@&quot;ZJCore&quot; withExtension:@&quot;bundle&quot;]; if (bundleURL) &#123; NSBundle *bundle = [NSBundle bundleWithURL:bundleURL]; NSInteger scale = [[UIScreen mainScreen] scale]; NSString *imgName = [NSString stringWithFormat:@&quot;%@@%zdx.png&quot;, @&quot;zj&quot;,scale]; imgView.image = [UIImage imageWithContentsOfFile:[bundle pathForResource:imgName ofType:nil]]; &#125;&#125; 默认情况下，图片资源在 Frameworks 下的 ZJCore.framework 下的 ZJCore.bundle 包中，右键打开包内容，即可看到 zj@2x.png 图片，如下图： 同理，模块中的json文件的获取方式也是一样的 提交至git这里提交至git的模块是pods工程才可以，以 ZJCore 为例 需要在github上创建一个私有repository，命名为 ZJCore 执行以下终端命令 123456789101112$ git init$ git add .$ git commit -m &quot;第一次提交&quot; // 即第一个步骤中创建的仓库地址$ git remote add origin git@github.com:13718004742/ZJCore.git// 查看当前主分支名$ git branch$ git push -u -f origin master // 一定要有标签，不然会有下面的警告// podspec文件中获取Git版本控制的项目需要tag号， % git tag -d rm 表示删除$ git tag &quot;0.1.0&quot; $ git push --tags 验证podspec文件执行终端命令 pod spec lint，注意：pod spec 相对于 pod lib 会更为精确 * pod lib 相当于只验证一个本地仓库 * pod spec 会同时验证本地仓库和远程仓库 1% pod spec lint --allow-warnings 如果出现如下错误 解决办法将 podspec 文件下的所有 https://... 均改为 git@github... 提交到私有仓库执行 pod repo 查看本地 MySpecs Repo 执行以下命令 123// pod repo push [本地Spec Repo名称][podspec文件路径]// 举例$ pod repo push MySpecs ZJCore.podspec --verbose --allow-warnings 提交成功后，可在本地仓库中看到提交路径 MySpecs -&gt; ZJCore 模块化 在 Classes -&gt; 创建模块 UIView、UILabel等，并在各模块内存放你想拷贝的代码文件，如下图 上传改动到远程仓库 1234567$ git add .$ git commit -m &quot;xxx&quot;$ git push origin master// tag 值增加$ git tag 0.x.x//推送tag到服务器上$ git push --tags 修改.podspec 使用 新建一个 ZJDemo 工程，在项目的 podfile 里面添加 12345678910111213141516# Uncomment the next line to define a global platform for your projectplatform :ios, &#x27;9.0&#x27;# 私有库ZJCoresource &#x27;git@github.com:13718004742/MySpecs.git&#x27;target &#x27;ZJDemo&#x27; do # Comment the next line if you don&#x27;t want to use dynamic frameworks use_frameworks! # 私有库ZJCore pod &#x27;ZJCore&#x27; # Pods for ZJDemoend 执行 pod install 即可","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理38：界面优化方案","slug":"OC进阶/OC底层原理38：界面优化方案","date":"2021-06-09T06:49:41.000Z","updated":"2023-02-25T05:56:27.107Z","comments":true,"path":"2021/06/09/OC进阶/OC底层原理38：界面优化方案/","link":"","permalink":"https://www.bboyzj.cn/2021/06/09/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8638%EF%BC%9A%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/","excerpt":"","text":"前言本文主要讲： 卡顿原理：卡顿的原因 - 掉帧 卡顿检测工具 实战项目优化 界面卡顿通常来说，计算机中的显示过程是下面这样的，通过 CPU、GPU、显示器 协同工作来将图片显示到屏幕上的 CPU 计算好显示的 内容，提交到 GPU GPU 经过 渲染 完成后，将渲染的结果放入 FrameBuffer(帧缓存区) 随后 视频控制器 会按照 VSync(垂直同步) 信号逐行读取 FrameBuffer 的数据 经过可能的 数模转换 传递给 显示器 进行显示 最开始时，FrameBuffer只有一个，这种情况下 FrameBuffer 的读取和刷新有很大的 效率 问题，为了解决这个问题，引入了 双缓存区，即 双缓冲机制，即 前FrameBuffer 和 后FrameBuffer，GPU渲染结果来回切换放入 前、后FrameBuffer 中。视频控制器来回切换读取 前后FrameBuffer，交给 显示器显示 双缓存机制 虽然解决了 效率问题，但是随之而言的是新的问题，当视频控制器还未 读取的频率 和 渲染的频率 不一致时，就会产生 掉帧，例如屏幕内容显示一半，GPU将新的一帧内容提交到 FrameBuffer，并将两个FrameBuffer而进行交换后，视频控制器就将新的一帧数据的下半段显示到屏幕上，造成 屏幕撕裂 现象 为了解决这个问题，采用了 垂直同步信号机制，即固定屏幕刷新率 每秒刷新60次，当开启垂直同步后，GPU会等待显示器的VSync信号发出后，才进行新的一帧渲染和FrameBuffer更新，而目前iOS设备中采用的正是 双缓存区+VSync 屏幕卡顿原因 下面我们来说说，屏幕卡顿的原因 在 VSync 信号到来后，系统图形服务 会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，随后CPU会将计算好的内容提交到GPU去。由GPU进行变换、合成、渲染。随后 GPU 会把渲染结果提交到 帧缓冲区 去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步信号的机制，如果在一个VSync时间内，CPU后者GPU没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不改变。所以可以简单理解 掉帧 为 过时不候 如下图所示，是一个显示过程，第1个在VSync到来期间，GPU渲染提前完成，正常显示；第2个在VSync期间，仍在处理中，此时屏幕不刷新，依旧显示第1帧；第3个VSync期间，切换到另一个FrameBuffer，让CPU渲染；此时就出现了 掉帧2 情况，渲染时就会出现明显的 卡顿现象 从图中可以看出，CPU和GPU不论是哪个阻碍了显示流程，都会造成 掉帧 现象，所以为了给用户提供更好的体验，在开发中，我们需要进行 卡顿检测 以及相应的 优化 卡顿监控卡顿监控的方案一般有三种： YYFPSLabel：通过 CADisplayLink + YYWeakProxy FPS监控：为了保持流程的UI交互，App的刷新频率应该保持在 60fps 左右，其原因是因为 iOS 设备默认的刷新频率是 60次/秒，而1次刷新（即VSync信号发出）的间隔是 1000ms/60次= 16.67ms/1次 ，所以如果在 16.67ms 内没有准备好下一帧数据，就会产生卡顿 主线程卡顿监控：通过 子线程监测主线程Runloop，判断两个状态（kCFRunLoopBeforeSource 和 kCFRunLoopAfrerWaiting）之间的耗时是否达到一定阀值 FPS监控FPS的监控，主要是通过 CADislayLink 实现，借助 link 的时间差，来计算一次刷新所需要的时间，然后通过 刷新次数/时间差 得到刷新频次，并判断是否在其范围，通过显示不同的文字颜色来表示卡顿严重成都。 创建一个 SPSDisplay 工具类，实现如下代码 12345#import &lt;UIKit/UIKit.h&gt;@interface FPSDisplay: NSObject+ (instancetype)shareFPSDisplay;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#import &quot;FPSDisplay.h&quot;#define SCREEN_HEIGHT [UIScreen mainScreen].bounds.size.height#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width@interface FPSDisplay ()@property (strong, nonatomic) UILabel *displayLabel;@property (strong, nonatomic) CADisplayLink *link;@property (assign, nonatomic) NSInteger count;@property (assign, nonatomic) NSTimeInterval lastTime;@property (strong, nonatomic) UIFont *font;@property (strong, nonatomic) UIFont *subFont;@end@implementation FPSDisplay+ (instancetype)shareFPSDisplay &#123; static FPSDisplay *shareDisplay; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; shareDisplay = [[FPSDisplay alloc] init]; &#125;); return shareDisplay;&#125;- (instancetype)init &#123; self = [super init]; if (self) &#123; [self initDisplayLabel]; &#125; return self;&#125;- (void)initDisplayLabel &#123; CGRect frame = CGRectMake(SCREEN_WIDTH - 100, 44, 80, 30); self.displayLabel = [[UILabel alloc] initWithFrame: frame]; self.displayLabel.layer.cornerRadius = 5; self.displayLabel.clipsToBounds = YES; self.displayLabel.textAlignment = NSTextAlignmentCenter; self.displayLabel.userInteractionEnabled = NO; self.displayLabel.backgroundColor = [UIColor colorWithWhite:0.000 alpha:0.700]; _font = [UIFont fontWithName:@&quot;Menlo&quot; size:14]; if (_font) &#123; _subFont = [UIFont fontWithName:@&quot;Menlo&quot; size:4]; &#125; else &#123; _font = [UIFont fontWithName:@&quot;Courier&quot; size:14]; _subFont = [UIFont fontWithName:@&quot;Courier&quot; size:4]; &#125; [self initCADisplayLink]; [[self keyWindow] addSubview:self.displayLabel];&#125;-(UIWindow*)keyWindow&#123; UIWindow *foundWindow = nil; NSArray *windows = [[UIApplication sharedApplication]windows]; for (UIWindow *window in windows) &#123; if (window.isKeyWindow) &#123; foundWindow = window; break; &#125; &#125; return foundWindow;&#125;- (void)initCADisplayLink &#123; self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)]; [self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];&#125;- (void)tick:(CADisplayLink *)link &#123; if (self.lastTime == 0) &#123; //对LastTime进行初始化 self.lastTime = link.timestamp; return; &#125; self.count += 1; //记录tick在1秒内执行的次数 NSTimeInterval delta = link.timestamp - self.lastTime; //计算本次刷新和上次更新FPS的时间间隔 //大于等于1秒时，来计算FPS if (delta &gt;= 1) &#123; self.lastTime = link.timestamp; float fps = self.count / delta; // 次数 除以 时间 = FPS （次/秒） self.count = 0; [self updateDisplayLabelText: fps]; &#125;&#125;- (void)updateDisplayLabelText: (float) fps &#123; CGFloat progress = fps / 60.0; UIColor *color = [UIColor colorWithHue:0.27 * (progress - 0.2) saturation:1 brightness:0.9 alpha:1]; self.displayLabel.text = [NSString stringWithFormat:@&quot;%d FPS&quot;,(int)round(fps)]; self.displayLabel.textColor = color;&#125;- (void)dealloc &#123; [_link invalidate];&#125;@end 使用 1[FPSDisplay shareFPSDisplay]; 主线程卡顿监控除了FPS，还可以通过 RunLoop 来监控，因为卡顿的是事务，而事务是交由 主线程 的 RunLoop 处理的。 也可以直接使用三方库 OC 可以使用 微信matrix、滴滴DoramonKit Swift 的卡顿检测第三方 ANREye，其主要思路是：创建子线程进行循环监测，每次检测时设置标记置为true，然后派发任务到主线程，标记置为false，接着子线程睡眠超过阀值时，判断标记是否为false，如果没有，说明主线程发生了卡顿 界面优化CPU层面的优化 尽量 用轻量级的对象 代替重量级的对象，可以对性能有所优化，例如: 不需要相应 触摸 时间的控件，用 CALayer 代替 UIView 尽量减少 对 UIView 和 CALayer 的属性修改 CALayer内部并没有属性，当调用属性方法时，其内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并将对应属性值保存在内部的一个 Dictionary中，同时还会通知delegate、创建动画等，非常haoshi UIView 相关的显示属性，例如frame、bounds、transform等，实际上都是从CALayer映射来的，对齐进行调整时，消耗的资源比一般属性要大 当有大量对象释放时，也是非常耗时的，尽量挪到后台线程去释放 尽量 提前计算视图布局，即 预排版，例如cell的行高 Autolayout 在简单页面情况下我们可以很好的提升开发效率，但是对于复杂视图而言，会产生严重的性能问题，随着视图数量的增长，Autolayout 带来的CPU消耗是程指数上升的，所以尽量使用 代码布局，如果不想手动调整frame等，也可以借助三方库，例如Masonry（OC）、SnapKit(swift)等等 文本处理的优化：当一个界面有大量文本时，其行高的计算、绘制也是非常耗时的 如果对文本没有特殊要求，可以使用UILabel内部的实现方式，且需要放到子线程中进行，避免则塞主线程 计算文本宽高：[NSAttributedString boundingRectWithSize:options:context:] 文本绘制： [NSAttributedString drawWithRect:options:context:] 自定义文本控件，利用 TextKit 或最底层的 CoreText 对文本 异步绘制。并且 CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整和绘制都需要计算一次），CoreText直接使用了 CoreGraphics 占用内存小，效率高 图片处理（解码+绘制） 当使用 UIImage 或 CGImageSource 的方法创建图片时，图片的数据不会立即解码，而是在设置时解码（即图片设置到 UIImageView/CALayer.contents 中，然后在 CALayer 提交至GPU渲染前，CGImage 中的数据才进行解码）。这一步是 无可避免 的，且是发生在 主线程 中的。想要绕开这个机制，常见的做法是在子线程中优先将图片绘制到 CGBitmapContext，然后从 Bitmap 直接创建图片，例如 SDWebImage 三方框架对图片的编解码处理，这就是 Image 的 预解码 当使用 CG 开头的方法 绘制图像 到画布中，然后从画布中创建图片时，可以将图像的 绘制 在 子线程 中进行 图片优化 尽量使用 PNG 格式图片，不适用 JPEG 图片 通过 子线程预解码，主线程渲染，即通过 Bitmap 创建图片，在子线程赋值 image 优化图片大小，尽量避免动态缩放 尽量将多张图合并为一张进行显示 尽量 避免使用透明的view，因为使用透明的view，会导致在GPU中计算像素时，会将透明view下层图层的像素也计算进来，即 颜色混合 处理 按需加载 ，例如在TableView中滑动时不加载图片，使用默认占位图，而是在滑动停止时加载 少使用 addView 给 cell 动态添加 view GPU层面的优化相对于CPU而言，GPU主要是接收CPU提交的 纹理+顶点，经过一系列 transform，最终 混合并渲染，输出到 屏幕上 尽量 减少在短时间内大量图片的显示，尽可能将 多张图片合为一张显示，主要是因为当有大量图片进行显示时，无论是CPU计算还是GPU的渲染，都是非常耗时的，很可能出现掉帧的情况 尽量 避免图片的尺寸超过4096x4096，因为当图片超过这个尺寸时，会先由CPU进行预处理，然后再提交给GPU处理，导致额外CPU资源消耗 尽量 减少视图数量和层次，主要是因为视图过多且重叠时，GPU会将其混合，混合的过程也是非常耗时的 尽量避免离屏渲染 异步渲染，例如可以将cell中的所有控件、视图合并成一张图片进行显示。可以参考 Graver 三方框架 注：上述这些优化方式的落地实现，需要根据自身项目进行评估，合理的使用进行优化","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理37：内存管理（三）AutoReleasePool & NSRunLoop 底层分析","slug":"OC进阶/OC底层原理37：内存管理（三）AutoReleasePool-NSRunLoop-底层分析","date":"2021-06-02T06:48:31.000Z","updated":"2022-04-21T05:20:23.000Z","comments":true,"path":"2021/06/02/OC进阶/OC底层原理37：内存管理（三）AutoReleasePool-NSRunLoop-底层分析/","link":"","permalink":"https://www.bboyzj.cn/2021/06/02/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8637%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89AutoReleasePool-NSRunLoop-%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/","excerpt":"","text":"前言本文主要分析 AutoReleasePool 以及 NSRunLoop 的底层实现 AutoReleasePool 自动释放池自动释放池 是OC中的一种 内存自动回收机制，它可以将加入 AutoReleasePool 中的 变量release的时机延迟，简单来说，就是当创建一个 对象，在正常情况下，变量会在超出其作用域的时，立即release。如果对象加入到了自动释放池中，这个对象并 不会立即释放，会 等到runloop休眠/超出autoreleasepool&#123;&#125;作用域 之后才能 被释放。其机制如下图所示 从程序启动到加载完成，主线程对应的 runloop 会处于 休眠 状态，等待用户交互来唤醒runloop 用户的每一次 交互 都会启动一次 runloop，用于处理用户的 所有点击、触摸事件等 runloop 在 监听到交互事件 后，就会 创建 自动释放池，并将所有 延迟释放 的对象添加到自动释放池 在一次完整的runloop结束之前，会向自动释放池中所有对象 发送release消息，然后 销毁 自动释放池 clang分析根据之前源码分析经验，我们先通过 clang 来分析 定义如下代码 1234int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; &#125;&#125; 通过clang编译成底层实现，命令为：xcrun -sdk iphonesimulator clang -arch x86_64 - rewrite-objc main.m 123456789101112131415161718192021//*********__AtAutoreleasePool**********struct __AtAutoreleasePool &#123; //构造函数 __AtAutoreleasePool() &#123; atautoreleasepoolobj = objc_autoreleasePoolPush(); &#125; //析构函数 ~__AtAutoreleasePool() &#123; objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; void * atautoreleasepoolobj;&#125;;//*********main*********int main(int argc, const char * argv[]) &#123; &#123; // 是一个结构体 __AtAutoreleasePool __autoreleasepool; &#125; return 0;&#125; 简单来说，自动释放池其本质也是一个 对象 123@autoreleasepool &#123;&#125;//等价于&#123;__AtAutoreleasePool __autoreleasepool; &#125; __AtAutoreleasePool 是一个 结构体，由 构造函数 + 析构函数，结构体定义的对象在作用域结束后，会自动调用析构函数 其中 &#123;&#125; 是作用域，优点是 结构清晰，可读性强，可以 及时创建销毁 关于涉及的构造和析构函数的调用时机，可以通过下面一个案例来验证 12345678910111213141516171819struct ZJTest&#123; ZJTest()&#123; printf(&quot;123 - %s\\n&quot;, __func__); &#125; ~ZJTest()&#123; printf(&quot;456 - %s\\n&quot;, __func__); &#125;&#125;;int main(int argc, const char * argv[]) &#123; &#123; ZJTest test; &#125;&#125;//**********运行结果**********123 - ZJTest456 - ~ZJTest 从而可以得出，在 ZJTest 创建对象时，会自动调用 构造函数，在出了{}作用域后，会自动调用析构函数 汇编分析 在main代码部分加断点，运行程序，并开启汇编调试 通过调试结果发现，证明了我们clang分析的结果 总结 autoreleasepool 其本质是一个 结构体对象，一个自动释放池对象就是页，是 栈结构存储，符合 先进后出 的原则 页的栈底是一个 56 字节大小的 空占位符，一页总大小为 4096 字节 只有 第一页 有 哨兵 对象，最多存储 504 个对象，从第二页开始最多存储 505 个对象 autoreleasepool 在加入要释放的对象时，底层调用的是 objc_autoreleasePoolPush 方法 autoreleasepool 在调用析构函数释放时，内部的实现时调用 objc_autoreleasePoolPop 方法 底层分析在 objc 源码中，对 AutoreleasePool 的解释如下： 12345678910111213141516Autorelease pool implementation- A thread&#x27;s autorelease pool is a stack of pointers. 线程的自动释放池是指针的堆栈- Each pointer is either an object to release, or POOL_BOUNDARY which is an autorelease pool boundary.每个指针都是要释放的对象，或者是POOL_BOUNDARY，它是自动释放池的边界。- A pool token is a pointer to the POOL_BOUNDARY for that pool. When the pool is popped, every object hotter than the sentinel is released.池令牌是指向该池的POOL_BOUNDARY的指针。弹出池后，将释放比哨点更热的每个对象。- The stack is divided into a doubly-linked list of pages. Pages are added and deleted as necessary. 堆栈分为两个双向链接的页面列表。根据需要添加和删除页面。- Thread-local storage points to the hot page, where newly autoreleased objects are stored. 线程本地存储指向热页面，该页面存储新自动释放的对象。 通过描述。有以下几点说明： 自动释放池 是一个关于 指针 的 堆栈 其中的指针是指要 释放的对象 或者 pool_boundary 哨兵（现在经常被称为 边界） 自动释放池是一个 页 的结构（细腻内存中提及），而且这个 页 是一个 双向链接（表示父节点和子节点，在类中提及过，即类的继承链） 自动释放池 和 线程 有关系 对于 自动释放池，我们主要关心的点有以下三点： 自动释放池是什么时候 创建？ 对象时 如何加入到自动释放池 的？ 哪些对象才会加入 自动释放池？ 下面带着这些问题，我们来进一步探索自动释放池的底层原理 AutoreleasePoolPage 从最初的 clang 或者 汇编 分析我们了解了自动释放池其底层是调用的 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop 两个方法，其源码实现如下： 12345678910111213//***********push方法***********void *objc_autoreleasePoolPush(void)&#123; return AutoreleasePoolPage::push();&#125;//***********pop方法***********voidobjc_autoreleasePoolPop(void *ctxt)&#123; AutoreleasePoolPage::pop(ctxt);&#125; 从源码中我们发现，都是调用的 AutoreleasePoolPage 的 push 和 pop，以下是其定义，从定义中可以看出，自动释放池是一个 页，同时也是一个 对象，这个 页 的大小是 4096字节 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//************宏定义************#define PAGE_MIN_SIZE PAGE_SIZE#define PAGE_SIZE I386_PGBYTES#define I386_PGBYTES 4096 /* bytes per 80386 page *///************类定义************class AutoreleasePoolPage : private AutoreleasePoolPageData&#123; friend struct thread_data_t;public: //页的大小 static size_t const SIZE =#if PROTECT_AUTORELEASEPOOL PAGE_MAX_SIZE; // must be multiple of vm page size#else PAGE_MIN_SIZE; // size and alignment, power of 2#endifprivate: ... //构造函数 AutoreleasePoolPage(AutoreleasePoolPage *newParent) : AutoreleasePoolPageData(begin(),//开始存储的位置 objc_thread_self(),//传的是当前线程，当前线程时通过tls获取的 newParent, newParent ? 1+newParent-&gt;depth : 0,//如果是第一页深度为0，往后是前一个的深度+1 newParent ? newParent-&gt;hiwat : 0) &#123;...&#125; //析构函数 ~AutoreleasePoolPage() &#123;...&#125; ... //页的开始位置 id * begin() &#123;...&#125; //页的结束位置 id * end() &#123;...&#125; //页是否为空 bool empty() &#123;...&#125; //页是否满了 bool full() &#123;...&#125; //页的存储是否少于一半 bool lessThanHalfFull() &#123;...&#125; //添加释放对象 id *add(id obj)&#123;...&#125; //释放所有对象 void releaseAll() &#123;...&#125; //释放到stop位置之前的所有对象 void releaseUntil(id *stop) &#123;...&#125; //杀掉 void kill() &#123;...&#125; //释放本地线程存储空间 static void tls_dealloc(void *p) &#123;...&#125; //获取AutoreleasePoolPage static AutoreleasePoolPage *pageForPointer(const void *p) &#123;...&#125; static AutoreleasePoolPage *pageForPointer(uintptr_t p) &#123;...&#125; //是否有空池占位符 static inline bool haveEmptyPoolPlaceholder() &#123;...&#125; //设置空池占位符 static inline id* setEmptyPoolPlaceholder()&#123;...&#125; //获取当前操作页 static inline AutoreleasePoolPage *hotPage()&#123;...&#125; //设置当前操作页 static inline void setHotPage(AutoreleasePoolPage *page) &#123;...&#125; //获取coldPage static inline AutoreleasePoolPage *coldPage() &#123;...&#125; //快速释放 static inline id *autoreleaseFast(id obj)&#123;...&#125; //添加自动释放对象，当页满的时候调用这个方法 static __attribute__((noinline)) id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123;...&#125; //添加自动释放对象，当没页的时候使用这个方法 static __attribute__((noinline)) id *autoreleaseNoPage(id obj)&#123;...&#125; //创建新页 static __attribute__((noinline)) id *autoreleaseNewPage(id obj) &#123;...&#125; public: //自动释放 static inline id autorelease(id obj)&#123;...&#125; //入栈 static inline void *push() &#123;...&#125; //兼容老的 SDK 出栈方法 __attribute__((noinline, cold)) static void badPop(void *token)&#123;...&#125; //出栈页面 template&lt;bool allowDebug&gt; static void popPage(void *token, AutoreleasePoolPage *page, id *stop)&#123;...&#125; __attribute__((noinline, cold)) static void popPageDebug(void *token, AutoreleasePoolPage *page, id *stop)&#123;...&#125; //出栈 static inline void pop(void *token)&#123;...&#125; static void init()&#123;...&#125; //打印 __attribute__((noinline, cold)) void print()&#123;...&#125; //打印所有 __attribute__((noinline, cold)) static void printAll()&#123;...&#125; //打印Hiwat __attribute__((noinline, cold)) static void printHiwat()&#123;...&#125; 从其定义中发现，AutoreleasePoolPage 是集成自 AutoreleasePoolPageData，且该类的属性也是来自父类，以下是 AutoreleasePoolPage 的定义： 发现其中有 AutoreleasePoolPage 对象，所以有以下关系链 AutoreleasePoolPage -&gt; AutoreleasePoolPageData -&gt; AutoreleasePoolPage，从这里可以说明自动释放池除了是一个 页 ，还是一个 双向链表 结构 1234567891011121314151617181920212223242526class AutoreleasePoolPage;struct AutoreleasePoolPageData&#123; // 用来校验AutoreleasePoolPage的结构是否完整 magic_t const magic;//16个字节 // 指向最新添加的autoreleased对象的下一个位置，初始化时指向begin() __unsafe_unretained id *next;//8字节 // 指向当前线程 pthread_t const thread;//8字节 // 指向父节点，第一个结点的parent值为nil AutoreleasePoolPage * const parent;//8字节 // 指向子节点，最后一个结点的child值为nil AutoreleasePoolPage *child;//8字节 // 表示深度，从0开始，往后递增1 uint32_t const depth;//4字节 // 表示high water mark 最大入栈数量标记 uint32_t hiwat;//4字节 // 初始化 AutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat) : magic(), next(_next), thread(_thread), parent(_parent), child(nil), depth(_depth), hiwat(_hiwat) &#123; &#125;&#125;; 其中 AutoreleasePoolPageData 结构体的内存大小为 56 字节： 属性 magic 的类型是 magic_t 结构体，所占内存大小为 m[4]，所占内存（即4*4=16字节） 属性 next（指针）、thread（对象）、parent（对象）、child（对象）均占 8 字节（即4*8=32字节） 属性 depth、hiwat 类型为 unit32_t，实际类型是 unsigned int 类型，均占 4 字节（即2*4=8字节） objc_autoreleasePoolPush 源码分析进入 push 源码实现，有以下逻辑 判断是否为有 pool 如果没有，则通过 autoreleaseNewPage 方法创建 如果有，则通过 autoreleaseFast 压栈 哨兵对象 12345678910111213141516// 入栈static inline void *push() &#123; id *dest; // 判断是否有pool if (slowpath(DebugPoolAllocation)) &#123; // Each autorelease pool starts on a new pool page.自动释放池从新池页面开始 // 如果没有，则创建 dest = autoreleaseNewPage(POOL_BOUNDARY); &#125; else &#123; // 压栈一个POOL_BOUNDARY，即压栈哨兵 dest = autoreleaseFast(POOL_BOUNDARY); &#125; ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY); return dest;&#125; 创建页 autoreleaseNewPage 进入 objc_autoreleasePoolPush -&gt; push -&gt; autoreleaseNewPage 源码实现，主要是通过 hotPage 获取当前页，判断当前页是否存在 如果存在，则通过 autoreleaseFullPage 方法 压栈对象 如果不存在，则通过 autoreleaseNoPage 方法 创建页 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//创建新页static __attribute__((noinline))id *autoreleaseNewPage(id obj)&#123; //获取当前操作页 AutoreleasePoolPage *page = hotPage(); //如果存在，则压栈对象 if (page) return autoreleaseFullPage(obj, page); //如果不存在，则创建页 else return autoreleaseNoPage(obj);&#125;//******** hotPage方法 ********//获取当前操作页static inline AutoreleasePoolPage *hotPage() &#123; //获取当前页 AutoreleasePoolPage *result = (AutoreleasePoolPage *) tls_get_direct(key); //如果是一个空池，则返回nil，否则，返回当前线程的自动释放池 if ((id *)result == EMPTY_POOL_PLACEHOLDER) return nil; if (result) result-&gt;fastcheck(); return result;&#125;//******** autoreleaseNoPage方法 ********static __attribute__((noinline))id *autoreleaseNoPage(id obj)&#123; // &quot;No page&quot; could mean no pool has been pushed // or an empty placeholder pool has been pushed and has no contents yet ASSERT(!hotPage()); bool pushExtraBoundary = false; //判断是否是空占位符，如果是，则压栈哨兵标识符置为YES if (haveEmptyPoolPlaceholder()) &#123; // We are pushing a second pool over the empty placeholder pool // or pushing the first object into the empty placeholder pool. // Before doing that, push a pool boundary on behalf of the pool // that is currently represented by the empty placeholder. pushExtraBoundary = true; &#125; //如果对象不是哨兵对象，且没有Pool，则报错 else if (obj != POOL_BOUNDARY &amp;&amp; DebugMissingPools) &#123; // We are pushing an object with no pool in place, // and no-pool debugging was requested by environment. _objc_inform(&quot;MISSING POOLS: (%p) Object %p of class %s &quot; &quot;autoreleased with no pool in place - &quot; &quot;just leaking - break on &quot; &quot;objc_autoreleaseNoPool() to debug&quot;, objc_thread_self(), (void*)obj, object_getClassName(obj)); objc_autoreleaseNoPool(obj); return nil; &#125; //如果对象是哨兵对象，且没有申请自动释放池内存，则设置一个空占位符存储在tls中，其目的是为了节省内存 else if (obj == POOL_BOUNDARY &amp;&amp; !DebugPoolAllocation) &#123;//如果传入参数为哨兵 // We are pushing a pool with no pool in place, // and alloc-per-pool debugging was not requested. // Install and return the empty pool placeholder. return setEmptyPoolPlaceholder();//设置空的占位符 &#125; // We are pushing an object or a non-placeholder&#x27;d pool. // Install the first page. //初始化第一页 AutoreleasePoolPage *page = new AutoreleasePoolPage(nil); //设置page为当前聚焦页 setHotPage(page); // Push a boundary on behalf of the previously-placeholder&#x27;d pool. //压栈哨兵的标识符为YES，则压栈哨兵对象 if (pushExtraBoundary) &#123; //压栈哨兵 page-&gt;add(POOL_BOUNDARY); &#125; // Push the requested object or pool. //压栈对象 return page-&gt;add(obj);&#125; 其中 autoreleaseNoPage 方法中发现 当前线程的自动释放池 是通过 AutoreleasePoolPage 创建的，其定义中有 构造方法，而构造方法的实现是通过父类 AutoreleasePoolPageData 的初始化方法（从上面的定义中可以得知） 1234567891011121314151617181920212223242526//**********AutoreleasePoolPage构造方法********** AutoreleasePoolPage(AutoreleasePoolPage *newParent) : AutoreleasePoolPageData(begin(),//开始存储的位置 objc_thread_self(),//传的是当前线程，当前线程时通过tls获取的 newParent, newParent ? 1+newParent-&gt;depth : 0,//如果是第一页深度为0，往后是前一个的深度+1 newParent ? newParent-&gt;hiwat : 0)&#123; if (parent) &#123; parent-&gt;check(); ASSERT(!parent-&gt;child); parent-&gt;unprotect(); //this 表示 新建页面，将当前页面的子节点 赋值为新建页面 parent-&gt;child = this; parent-&gt;protect(); &#125; protect();&#125;//**********AutoreleasePoolPageData初始化方法**********AutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat) : magic(), next(_next), thread(_thread), parent(_parent), child(nil), depth(_depth), hiwat(_hiwat) &#123; &#125; 其中 AutoreleasePoolPageData 方法传入的参数含义为： begin() 表示 压栈 的位置（即下一个要释放对象的压栈地址）。可以通过源码调式 begin，发现其具体实现等于 页首地址+56，其中的 56 就是结构体 AutoreleasePoolPageData 的内存大小 123456//********begin()********//页的开始位置id * begin() &#123; //等于 首地址+56（AutoreleasePoolPage类所占内存大小） return (id *) ((uint8_t *)this+sizeof(*this));&#125; objc_thread_self() 表示的是 当前线程，而当前线程时通过tls获取的 123456__attribute__((const))static inline pthread_t objc_thread_self()&#123; //通过tls获取当前线程 return (pthread_t)tls_get_direct(_PTHREAD_TSD_SLOT_PTHREAD_SELF);&#125; newParent 表示 父节点 后续两个参数是 通过父节点的深度、最大入栈个数 计算 depth 以及 hiwat 查看自动释放池内存结构由于在ARC模式下，是无法手动调用 autorelease，所以将Demo切换至MRC模式（Build Settings -&gt; Object-C Automatic Refrence Counting 设置为 NO） 定义如下代码 1234567891011121314//************打印自动释放池结构************extern void _objc_autoreleasePoolPrint(void);//************运行代码************int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; //循环创建对象，并加入自动释放池 for (int i = 0; i &lt; 5; i++) &#123; NSObject *objc = [[NSObject alloc] sutorelease]; &#125; //调用 _objc_autoreleasePoolPrint(); &#125;&#125; 运行结果如下，发现是6个，但是我们压栈的对象其实只有5个，其中的 POOL 表示 哨兵，即 边界，其目的是 为了防止越界 查看自动释放池的内存结构，发现，页的首地址与 哨兵对象 相差 0x38，转换成十进制刚好是 56，也就是 AutoreleasePoolPage 自己本身的内存大小 将上述的测试代码的数据改为 505，其内存结构如下，发现第一页满了，存储了 504 个要释放的对象，第二页只存储了一个 在将数据改为 505+506，来验证第二页是否也是存储了 504 个对象 通过运行发现，第一页存储 504，第二页存储 505，第三页存储 2个 结论 所以通过上述测试，可以得出以下结论： 第一页可以存放 504 个对象，且 只有第一页有哨兵，当第一页压栈满了，就会开辟新的一页 第二页开始，最多可以存放 505 个对象 一页的大小等于 505 * 8 = 4040 这个结论同样可以通过 AutoreleasePoolPage 中的 SIZE 来得到印证，从其定义中我们可以得出，一页的大小是 4096 字节，而在其构造函数中 对象的压栈位置，是从 首地址+56 开始的，所以可以一页中实际可以存储 4096 - 56= 4040字节，转换成对象时 4040/8 = 505 个，即一页最多可以 存储505个对象，其中 第一页有哨兵对象，只能存储 504 个对象，其结构图示如下： 面试题：哨兵在一个自动释放池有几个 只有一个哨兵对象，且哨兵在第一页 第一页最多可存 504 个对象，第二页开始最多存 505 个 压栈对象 autoreleaseFast 进入 autoreleaseFast 源码，主要有以下几步： 获取当前操作页，并判断页是否存在以及是否满了 如果 页存在，且未满，则通过 add 方法压栈对象 如果 页存在，且满了，则通过 autoreleaseFullPage 方法安排新的页 如果 页不存在，则通过 autoreleaseNoPage 方法创建新页 12345678910111213141516 static inline id *autoreleaseFast(id obj)&#123; //获取当前操作页 AutoreleasePoolPage *page = hotPage(); //判断页是否满了 if (page &amp;&amp; !page-&gt;full()) &#123; //如果未满，则压栈 return page-&gt;add(obj); &#125; else if (page) &#123; //如果满了，则安排新的页面 return autoreleaseFullPage(obj, page); &#125; else &#123; //页不存在，则新建页 return autoreleaseNoPage(obj); &#125;&#125; autoreleaseFullPage 方法这个方法主要是用于判断当前页是否已经存储满了，如果当前页已经满了，通过 do-while循环 查找 子节点对应的页，如果不存在，则 新建页，并 压栈对象 1234567891011121314151617181920212223//添加自动释放对象，当页满的时候调用这个方法static __attribute__((noinline))id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)&#123; // The hot page is full. // Step to the next non-full page, adding a new page if necessary. // Then add the object to that page. ASSERT(page == hotPage()); ASSERT(page-&gt;full() || DebugPoolAllocation); //do-while遍历循环查找界面是否满了 do &#123; //如果子页面存在，则将页面替换为子页面 if (page-&gt;child) page = page-&gt;child; //如果子页面不存在，则新建页面 else page = new AutoreleasePoolPage(page); &#125; while (page-&gt;full()); //设置为当前操作页面 setHotPage(page); //对象压栈 return page-&gt;add(obj);&#125; 从 autoreleasePoolPage 初始化方法中可以看出，主要是通过操作 child 对象，将 当前页的child指向新建页面，由此可以得出 页是通过双向链表链接 add方法这个方法主要是 添加释放对象，其底层的实现时通过 next 指针存储释放对象，并将 next指针递增，表示下一个释放对象存储的位置，从这里可以看出 页 是通过 栈结构存储 123456789101112//添加释放对象id *add(id obj)&#123; ASSERT(!full()); unprotect(); //传入对象存储的位置 id *ret = next; // faster than `return next-1` because of aliasing //将obj压栈到next指针位置，然后next进行++，即下一个对象存储的位置 *next++ = obj; protect(); return ret;&#125; autorelease底层分析在demo中，我们通过 autorelease 方法，在MRC模式下，将对象压栈到自动释放池，下面分析其底层实现 查看 autorelease 方法源码 如果不是对象 或者 是小对象，则直接返回 如果是对象，则调用对象的 autorelease 进行释放 12345678910__attribute__((aligned(16), flatten, noinline))idobjc_autorelease(id obj)&#123; //如果不是对象，则直接返回 if (!obj) return obj; //如果是小对象，也直接返回 if (obj-&gt;isTaggedPointer()) return obj; return obj-&gt;autorelease();&#125; 进入对象的 autorelease 实现 12345678910111213141516171819202122232425262728293031323334353637383940👇inline id objc_object::autorelease()&#123; ASSERT(!isTaggedPointer()); //判断是否是自定义类 if (fastpath(!ISA()-&gt;hasCustomRR())) &#123; return rootAutorelease(); &#125; return ((id(*)(objc_object *, SEL))objc_msgSend)(this, @selector(autorelease));&#125;👇inline id objc_object::rootAutorelease()&#123; //如果是小对象，直接返回 if (isTaggedPointer()) return (id)this; if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this; return rootAutorelease2();&#125;👇__attribute__((noinline,used))id objc_object::rootAutorelease2()&#123; ASSERT(!isTaggedPointer()); return AutoreleasePoolPage::autorelease((id)this);&#125;👇static inline id autorelease(id obj)&#123; ASSERT(obj); ASSERT(!obj-&gt;isTaggedPointer()); //autoreleaseFast 压栈操作 id *dest __unused = autoreleaseFast(obj); ASSERT(!dest || dest == EMPTY_POOL_PLACEHOLDER || *dest == obj); return obj;&#125; 从这里看出，无论是 压栈哨兵对象，还是普通对象，都会来到 autorelease 方法，只是 区别标识不同 而已 objc_autoreleasePoolPop 源码分析在 objc_autoreleasePoolPop 方法中有个参数，在clang分析时，发现传入的参数是 push 压栈后返回的哨兵对象，即 ctxt，其目的是 避免出栈混乱，防止将别的对象出栈 进入 pop 源码实现，主要有以下几步 空页面的处理，并 根据token获取page 容错处理 通过 popPage 出栈页 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//出栈static inline voidpop(void *token)&#123; AutoreleasePoolPage *page; id *stop; //判断对象是否是空占位符 if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123; //如果当是空占位符 // Popping the top-level placeholder pool. //获取当前页 page = hotPage(); if (!page) &#123; // Pool was never used. Clear the placeholder. //如果当前页不存在，则清除空占位符 return setHotPage(nil); &#125; // Pool was used. Pop its contents normally. // Pool pages remain allocated for re-use as usual. //如果当前页存在，则将当前页设置为coldPage,token设置为coldPage的开始位置 page = coldPage(); token = page-&gt;begin(); &#125; else &#123; //获取token所在的页 page = pageForPointer(token); &#125; stop = (id *)token; //判断最后一个位置，是否是哨兵 if (*stop != POOL_BOUNDARY) &#123; //最后一个位置不是哨兵，即最后一个位置是一个对象 if (stop == page-&gt;begin() &amp;&amp; !page-&gt;parent) &#123; //如果是第一个位置，且没有父节点，什么也不做 // Start of coldest page may correctly not be POOL_BOUNDARY: // 1. top-level pool is popped, leaving the cold page in place // 2. an object is autoreleased with no pool &#125; else &#123; //如果是第一个位置，且有父节点，则出现了混乱 // Error. For bincompat purposes this is not // fatal in executables built with old SDKs. return badPop(token); &#125; &#125; if (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) &#123; return popPageDebug(token, page, stop); &#125; //出栈页 return popPage&lt;false&gt;(token, page, stop);&#125; 进入 popPage 源码，其中传入的 allowDebug 为false，则通过 releaseUntil 出栈当前页 stop 位置之前的所有对象，即出栈中的对象 发送release消息，直到遇到传入的 哨兵对象 12345678910111213141516171819202122232425262728293031323334353637//出栈页面template&lt;bool allowDebug&gt; static void popPage(void *token, AutoreleasePoolPage *page, id *stop)&#123; if (allowDebug &amp;&amp; PrintPoolHiwat) printHiwat(); //出栈当前操作页面对象 page-&gt;releaseUntil(stop); // memory: delete empty children 删除空子项 if (allowDebug &amp;&amp; DebugPoolAllocation &amp;&amp; page-&gt;empty()) &#123; // special case: delete everything during page-per-pool debugging //调试期间删除每个特殊情况下的所有池 //获取当前页面的父节点 AutoreleasePoolPage *parent = page-&gt;parent; //将当前页面杀掉 page-&gt;kill(); //设置操作页面为父节点页面 setHotPage(parent); &#125; else if (allowDebug &amp;&amp; DebugMissingPools &amp;&amp; page-&gt;empty() &amp;&amp; !page-&gt;parent) &#123; // special case: delete everything for pop(top) // when debugging missing autorelease pools //特殊情况：调试丢失的自动释放池时删除pop（top）的所有内容 page-&gt;kill(); setHotPage(nil); &#125; else if (page-&gt;child) &#123; // hysteresis: keep one empty child if page is more than half full 如果页面已满一半以上，则保留一个空子级 if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125; &#125;&#125; 进入 releaseUntil 实现，主要是通过 循环遍历，判断对象是否等于stop，其目的是 释放stop之前的所有的对象 首先通过 获取page的next释放对象（即page的最后一个对象），并对 next 进行 递减，获取 上一个对象 判断 是否哨兵对象，如果不是则自动调用 objc_release 释放 12345678910111213141516171819202122232425262728293031323334353637383940414243//释放到stop位置之前的所有对象void releaseUntil(id *stop) &#123; // Not recursive: we don&#x27;t want to blow out the stack 不是递归的：我们不想破坏堆栈 // if a thread accumulates a stupendous amount of garbage //判断下一个对象是否等于stop，如果不等于，则进入while循环 while (this-&gt;next != stop) &#123; // Restart from hotPage() every time, in case -release // autoreleased more objects 每次从hotPage（）重新启动，以防-release自动释放更多对象 //获取当前操作页面，即hot页面 AutoreleasePoolPage *page = hotPage(); // fixme I think this `while` can be `if`, but I can&#x27;t prove it //如果当前页是空的 while (page-&gt;empty()) &#123; //将page赋值为父节点页 page = page-&gt;parent; //并设置当前页为父节点页 setHotPage(page); &#125; page-&gt;unprotect(); //next进行--操作，即出栈 id obj = *--page-&gt;next; //将页索引位置置为SCRIBBLE，表示已经被释放 memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next)); page-&gt;protect(); if (obj != POOL_BOUNDARY) &#123; //释放 objc_release(obj); &#125; &#125; //设置当前页 setHotPage(this);#if DEBUG // we expect any children to be completely empty for (AutoreleasePoolPage *page = child; page; page = page-&gt;child) &#123; ASSERT(page-&gt;empty()); &#125;#endif&#125; 进入 kill 实现，主要是销毁当前页，将 当前页赋值为父节点页，并将 父节点页的child对象指针置为nil 1234567891011121314151617181920212223//销毁void kill() &#123; // Not recursive: we don&#x27;t want to blow out the stack // if a thread accumulates a stupendous amount of garbage AutoreleasePoolPage *page = this; //获取最后一个页 while (page-&gt;child) page = page-&gt;child; AutoreleasePoolPage *deathptr; do &#123; deathptr = page; //子节点 变成 父节点 page = page-&gt;parent; if (page) &#123; page-&gt;unprotect(); //子节点为nil page-&gt;child = nil; page-&gt;protect(); &#125; delete deathptr; &#125; while (deathptr != this);&#125; 总结通过上面的分析，针对自动释放池的push和pop，总结如下： 在自动释放池的 压栈（即push）操作中 当没有pool，即只有空占位符（存储在tls中）时，则创建页，压栈哨兵对象 在页中 压栈普通对象 主要是通过 next 指针 递增 进行的 当 页满 了时，需要设置页的 child 对象为 新建页 所以，综上所述，autorelease 和 objc_autoreleasePush 的整体底层的流程如下图所示 在自动释放池的 出栈（即 pop）操作中 在页中 出栈普通对象 主要是通过 next 指针 递减 进行的 当 页空 了时，需要赋值页的 parent 对象为 当前页 综上所述，objc_autoreleasePoolPop 出栈的流程如下所示 Runloop对于Runloop，主要关心的点有以下几个 runoop是什么？ runloop和线程是什么关系？ runloop是什么时候创建的？ Runloop介绍Runloop 是时间接收和分发机制的一个实现，是线程相关的基础框架的一部分，一个Runloop就是一个时间处理的循环，用来不停的调度工作以及处理输入事件。 Runloop 本质是一个 do-while循环，没事做就休息，来活了就干活。与普通的 while 循环时有区别的，普通的 while循环 会导致CPU进入 忙等待状态，即一直消耗cpu，而Runloop则不会，Runloop是一种 闲等待，即Runloop具备 休眠功能。 Runloop的作用 保持程序的持续运行 处理APP中的各种事件（触摸、定时器、performSelector（一种方法的调用方式）） 节省CPU资源，提高程序的性能，该做事就做事，该休息就休息 Runloop源码分析Runloop源码的下载地址，在其中找到最新版本下载即可 Runloop和线程的关系一般在日常开发中，对于 Runloop的获取 主要有以下两种方式 1234// 主运行循环CFRunLoopRef mainRunloop = CFRunLoopGetMain();// 当前运行循环CFRunLoopRef currentRunloop = CFRunLoopGetCurrent(); 进入 CFRunLoopGetMain 源码 1234567CFRunLoopRef CFRunLoopGetMain(void) &#123; CHECK_FOR_FORK(); static CFRunLoopRef __main = NULL; // no retain needed // pthread_main_thread_np 主线程 if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed return __main;&#125; 进入 _CFRunLoopGet0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// should only be called by Foundation// t==0 is a synonym for &quot;main thread&quot; that always worksCF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123; //如果t不存在，则标记为主线程（即默认情况，默认是主线程） if (pthread_equal(t, kNilPthreadT)) &#123; t = pthread_main_thread_np(); &#125; __CFSpinLock(&amp;loopsLock); if (!__CFRunLoops) &#123; __CFSpinUnlock(&amp;loopsLock); //创建全局字典，标记为kCFAllocatorSystemDefault CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks); //通过主线程 创建主运行循环 CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); //利用dict，进行key-value绑定操作，即可以说明，线程和runloop是一一对应的 // dict : key value CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123; CFRelease(dict); &#125; CFRelease(mainLoop); __CFSpinLock(&amp;loopsLock); &#125; //通过其他线程获取runloop CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); __CFSpinUnlock(&amp;loopsLock); if (!loop) &#123; //如果没有获取到，则新建一个运行循环 CFRunLoopRef newLoop = __CFRunLoopCreate(t); __CFSpinLock(&amp;loopsLock); loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); if (!loop) &#123; //将新建的runloop 与 线程进行key-value绑定 CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); loop = newLoop; &#125; // don&#x27;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it __CFSpinUnlock(&amp;loopsLock); CFRelease(newLoop); &#125; if (pthread_equal(t, pthread_self())) &#123; _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL); if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123; _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop); &#125; &#125; return loop;&#125; 从这里可以说明，Runloop 只有 两种，一种是 主线程的，一种是 其他线程的。即Runloop和线程是一一对应的 Runloop的创建 进入 __CFRunLoopCreate 源码，其中主要是对runloop属性的赋值操作 123456789101112131415161718192021222324252627282930313233static CFRunLoopRef __CFRunLoopCreate(pthread_t t) &#123; CFRunLoopRef loop = NULL; CFRunLoopModeRef rlm; uint32_t size = sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase); loop = (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopTypeID, size, NULL); //如果loop为空，则直接返回NULL if (NULL == loop) &#123; return NULL; &#125; //runloop属性配置 (void)__CFRunLoopPushPerRunData(loop); __CFRunLoopLockInit(&amp;loop-&gt;_lock); loop-&gt;_wakeUpPort = __CFPortAllocate(); if (CFPORT_NULL == loop-&gt;_wakeUpPort) HALT; __CFRunLoopSetIgnoreWakeUps(loop); loop-&gt;_commonModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks); CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode); loop-&gt;_commonModeItems = NULL; loop-&gt;_currentMode = NULL; loop-&gt;_modes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks); loop-&gt;_blocks_head = NULL; loop-&gt;_blocks_tail = NULL; loop-&gt;_counterpart = NULL; loop-&gt;_pthread = t;#if DEPLOYMENT_TARGET_WINDOWS loop-&gt;_winthread = GetCurrentThreadId();#else loop-&gt;_winthread = 0;#endif rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true); if (NULL != rlm) __CFRunLoopModeUnlock(rlm); return loop;&#125; 进入 CFRunLoopRef 的定义，根据定义得知，其实 RunLoop也是一个对象。是 __CFRunLoop 结构体的 指针类型 123456789101112131415161718typedef struct __CFRunLoop * CFRunLoopRef;👇struct __CFRunLoop &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* locked for accessing mode list */ __CFPort _wakeUpPort; // used for CFRunLoopWakeUp Boolean _unused; volatile _per_run_data *_perRunData; // reset for runs of the run loop pthread_t _pthread; uint32_t _winthread; CFMutableSetRef _commonModes; CFMutableSetRef _commonModeItems; CFRunLoopModeRef _currentMode; CFMutableSetRef _modes; struct _block_item *_blocks_head; struct _block_item *_blocks_tail; CFTypeRef _counterpart;&#125;; 从定义中可以得出，一个RunLoop依赖于多个Mode，意味着一个RunLoop需要处理多个事务，即 一个Mode对应多个item，而一个item包含了 timer、source、observer，如下图所示： Mode类型其中 mode 在苹果文档中提及的有五个，而在iOS中公开暴露出来的只有 NSDefaultRunLoopMode 和 NSRunLoopCommonModes。NSRunLoopCommonModes 实际上是一个 Mode 的集合，默认包括 NSDefaultRunLoopMode 和 NSEventTrackingRunLoopMode NSDefaultRunLoopMode：默认的 mode，正常情况下都是在这个mode NSConnectionReplyMode NSModalPanelRunLoopMode NSEventTrackingRunLoopMode：使用这个mode去跟踪来自用户交互的事件（比如UITableView上下滑动） NSRunLoopCommonModes：伪模式，灵活性更好 Source &amp; Timer &amp; Observer source： 表示可以 唤醒runloop的一些事件，例如用户点击了屏幕，就会创建一个runloop，主要分为 source0 和 source1 source0 表示 非系统事件，即用户自定义的事件 source1 表示 系统事件，主要负责底层的通讯，具备唤醒能力 timer： 就是常用的 NSTimer 定时器一类 observer：主要用于监听runloop的状态变化，并作出一定响应，主要有以下一些状态 123456789101112131415typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; //进入RunLoop kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将处理Timers kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理Source kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将进入休眠 kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //被唤醒 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //退出RunLoop kCFRunLoopExit = (1UL &lt;&lt; 7), kCFRunLoopAllActivities = 0x0FFFFFFFU&#125;; 验证：runloop和mode是一对多下面，通过上面的代码调式来验证我们上面提及的关系 通过lldb命令获取 mainRunLoop、currentRunLoop 的 currentMode po CFRunLoopCopyCurrentMode(mainRunloop) po CFRunLoopCopyCurrentMode(currentRunloop) 从这里，可以说明，runloop在运行时的mode只有一个 获取 mainRunloop 的所有模型，即 po CFRunLoopCopyAllModes(mainRunloop) 从结果可以验证 runloop 和 CFRunloopMode 具有 一对多 的关系 验证：mode和item也是一对多 在上述代码中，加断点，通过bt查看堆栈信息，从这里看出timer的item类型如下所示： 在 runloop 源码中查看 item 类型，有以下几种 block应用：CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK 调用timer：CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION 响应source0：CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION 响应source1：CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION GCD主队列：CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE observer：CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION 在这里以 timer 为例，一般初始化timer时，都会将timer通过 addTimer:forMode: 方法添加到runloop中，于是在源码中查找 addTimer 的相关方法，即 CFRunLoopAddTimer 方法，其源码实现如下，其实现主要判断是否是 kCFRunLoopCommonModes ，然后查找runloop的mode进行匹配处理 其中 kCFRunLoopCommonModes 不是一种模式，是一种抽象的 伪模式 ，比 defaultMode 更加灵活 通过 CFSetAddValue(rl-&gt;_commonModeItems, rlt); 可以得知，runloop 与 mode 是 一对多 的，同时可以得出 mode 与 item 也是 一对多 的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) &#123; CHECK_FOR_FORK(); if (__CFRunLoopIsDeallocating(rl)) return; if (!__CFIsValid(rlt) || (NULL != rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop != rl)) return; __CFRunLoopLock(rl); // 重点 : kCFRunLoopCommonModes if (modeName == kCFRunLoopCommonModes) &#123; //如果是kCFRunLoopCommonModes 类型 CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL; if (NULL == rl-&gt;_commonModeItems) &#123; rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks); &#125; //runloop与mode 是一对多的， mode与item也是一对多的 CFSetAddValue(rl-&gt;_commonModeItems, rlt); if (NULL != set) &#123; CFTypeRef context[2] = &#123;rl, rlt&#125;; /* add new item to all common-modes */ //执行 CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context); CFRelease(set); &#125; &#125; else &#123; //如果是非commonMode类型 //查找runloop的模型 CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true); if (NULL != rlm) &#123; if (NULL == rlm-&gt;_timers) &#123; CFArrayCallBacks cb = kCFTypeArrayCallBacks; cb.equal = NULL; rlm-&gt;_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;cb); &#125; &#125; //判断mode是否匹配 if (NULL != rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) &#123; __CFRunLoopTimerLock(rlt); if (NULL == rlt-&gt;_runLoop) &#123; rlt-&gt;_runLoop = rl; &#125; else if (rl != rlt-&gt;_runLoop) &#123; __CFRunLoopTimerUnlock(rlt); __CFRunLoopModeUnlock(rlm); __CFRunLoopUnlock(rl); return; &#125; // 如果匹配，则将runloop加进去，而runloop的执行依赖于 [runloop run] CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name); __CFRunLoopTimerUnlock(rlt); __CFRunLoopTimerFireTSRLock(); __CFRepositionTimerInMode(rlm, rlt, false); __CFRunLoopTimerFireTSRUnlock(); if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) &#123; // Normally we don&#x27;t do this on behalf of clients, but for // backwards compatibility due to the change in timer handling... if (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl); &#125; &#125; if (NULL != rlm) &#123; __CFRunLoopModeUnlock(rlm); &#125; &#125; __CFRunLoopUnlock(rl);&#125; RunLoop执行众所周知，runloop的执行依赖于 run 方法，从下面的堆栈信息中可以看出，其底层执行的是 __CFRunLoopRun 方法 进入 __CFRunLoopRun 源码，针对不同的对象，有不同的处理 如果有 observer，则调用 __CFRunLoopDoOnservers 如果有 block，则调用 __CFRunLoopDoBlocks 如果有 timer，则调用 __CFRunLoopDoTimers 如果是 source0，则调用 __CFRunLoopDoSources0 如果是 source1，则调用 __CFRunLoopDoSources1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* rl, rlm are locked on entrance and exit */static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123; ... do&#123; ... //通知 Observers: 即将处理timer事件 if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); //通知 Observers: 即将处理Source事件 if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources); //处理Blocks __CFRunLoopDoBlocks(rl, rlm); //处理sources0 Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle); //处理sources0返回为YES if (sourceHandledThisLoop) &#123; // 处理Blocks __CFRunLoopDoBlocks(rl, rlm); &#125; ... //如果是timer else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123; CFRUNLOOP_WAKEUP_FOR_TIMER(); if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123; // Re-arm the next timer, because we apparently fired early __CFArmNextTimerInMode(rlm, rl); &#125; &#125; ... //如果是source1 CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort); if (rls) &#123;#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI mach_msg_header_t *reply = NULL; sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop; if (NULL != reply) &#123; (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL); CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply); &#125;#elif DEPLOYMENT_TARGET_WINDOWS sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;#endif &#125; ... &#125;while (0 == retVal); ...&#125; 进入 __CFRunLoopDoTimers 源码，主要是通过for循环，对单个timer进行处理 12345678910static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) &#123; /* DOES CALLOUT */ ... //循环遍历，做下层单个timer的执行 for (CFIndex idx = 0, cnt = timers ? CFArrayGetCount(timers) : 0; idx &lt; cnt; idx++) &#123; CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx); Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt); timerHandled = timerHandled || did; &#125; ...&#125; 进入 __CFRunLoopDoTimer 源码，主要逻辑是 timer 执行完毕后，会主动调用 __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ 函数，正好与timer堆栈调用的一致 123456// mode and rl are locked on entry and exitstatic Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt) &#123; ... __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-&gt;_callout, rlt, context_info); ...&#125; timer执行总结 为自定义的timer，设置mode，并将其加入 runloop 中 在runloop的 run 方法执行时，会调用 __CFRunLoopDoTimers 执行所有的timer 在 __CFRunLoopDoTimers 方法中，会通过for循环执行单个timer的操作 在 __CFRunLoopDoTimer 方法中，timer执行完毕后，会执行对应的timer回调函数 以上，是针对 timer 的执行分析，对于 observer、block、source0、source1，其执行原理与timer是类似的，这里就不再重复说明，一下是 苹果官方文档 针对runloop处理不同源的图示： RunLoop底层管理从上述的堆栈信息中可以看出，run在底层的实现路径为 CFRunLoopRun -&gt; CFRunLoopRun -&gt; __CFRunLoopRun 12345678void CFRunLoopRun(void) &#123; /* DOES CALLOUT */ int32_t result; do &#123; // 1.0e10 : 科学技术 1*10^10 result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); CHECK_FOR_FORK(); &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);&#125; 进入 CFRunLoopRunSpecific 源码，，首先根据modeName找到对应的mode，然后主要分为三种情况： 如果是 entry，则通知observer，即将 进入runloop 如果是 exit，则通过observer，即将 退出runloop 如果是其他中间状态，主要是通过runloop处理各种源 其伪代码表示如下： 1234567891011121314151617181920SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123; /* DOES CALLOUT */ CHECK_FOR_FORK(); if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished; __CFRunLoopLock(rl); //首先根据modeName找到对应mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false); // 通知 Observers: RunLoop 即将进入 loop。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); // 内部函数，进入loop result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); // 通知 Observers: RunLoop 即将退出。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit); return result; &#125; 进入 __CFRunLoopRun 源码，由于这部分代码较多，于是这里用伪代码代替。其主要逻辑是 根据不同的事件源进行不同的处理，当RunLoop休眠时，可以通过相应的事件唤醒RunLoop 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//核心函数/* rl, rlm are locked on entrance and exit */static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode)&#123; //通过GCD开启一个定时器，然后开始跑圈 dispatch_source_t timeout_timer = NULL; ... dispatch_resume(timeout_timer); int32_t retVal = 0; //处理事务,即处理items do &#123; // 通知 Observers: 即将处理timer事件 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); // 通知 Observers: 即将处理Source事件 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources) // 处理Blocks __CFRunLoopDoBlocks(rl, rlm); // 处理sources0 Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle); // 处理sources0返回为YES if (sourceHandledThisLoop) &#123; // 处理Blocks __CFRunLoopDoBlocks(rl, rlm); &#125; // 判断有无端口消息(Source1) if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) &#123; // 处理消息 goto handle_msg; &#125; // 通知 Observers: 即将进入休眠 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting); __CFRunLoopSetSleeping(rl); // 等待被唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY); // user callouts now OK again __CFRunLoopUnsetSleeping(rl); // 通知 Observers: 被唤醒，结束休眠 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting); handle_msg: if (被timer唤醒) &#123; // 处理Timers __CFRunLoopDoTimers(rl, rlm, mach_absolute_time())； &#125;else if (被GCD唤醒)&#123; // 处理gcd __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125;else if (被source1唤醒)&#123; // 被Source1唤醒，处理Source1 __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) &#125; // 处理block __CFRunLoopDoBlocks(rl, rlm); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; retVal = kCFRunLoopRunHandledSource;//处理源 &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123; retVal = kCFRunLoopRunTimedOut;//超时 &#125; else if (__CFRunLoopIsStopped(rl)) &#123; __CFRunLoopUnsetStopped(rl); retVal = kCFRunLoopRunStopped;//停止 &#125; else if (rlm-&gt;_stopped) &#123; rlm-&gt;_stopped = false; retVal = kCFRunLoopRunStopped;//停止 &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123; retVal = kCFRunLoopRunFinished;//结束 &#125; &#125;while (0 == retVal); return retVal;&#125; 所以，综上所述，RunLoop的执行流程，如下所示： 相关面试题AutoreleasePool相关面试题1：临时变量什么时候释放 如果在 正常情况下，一般是 超出作用域就会立即释放 如果将临时变量加入了 自动释放池，会延迟释放，即在 runloop休眠/超出autoreleasePool作用域之后会释放 面试题2：AutoreleasePool原理 自动释放池的本质是一个 autoreleasePoolPage结构体对象，是一个 栈结构存储的页，每一个 autoreleasePoolPage 都是以 双向链表 的形式链接 自动释放池的 压栈 和 出栈 主要是通过结构体的 构造函数 和 析构函数 调用底层的 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop，实际上调用的是 autoreleasePoolPage 的 push 和 pop 两个方法 每次调用 push 操作其实就是创建一个新的 autoreleasePoolPage，而 autoreleasePoolPage 的具体操作就是插入一个 POOL_BOUNDARY,并返回插入 POOL_BOUNDARY 的内存地址。而 push 内部调用 autoreleaseFast 方法处理，主要有以下三种情况 当 page存在且不满 时，调用add方法将对象添加至page的next指针处，并next递增 当 page存在且已满 时，调用 autoreleaseFullPage 初始化一个新的page，然后调用add方法将对象添加至page栈中 当 page不存在 时，调用 autoreleaseNoPage 创建一个hotPage，然后调用add方法将对象添加至page栈中 当执行 pop 时，会传入一个值，这个值就是push操作的返回值，即 POOL_BOUNDARY 的内存地址 token，所以pop内部的实现就是根据token找到哨兵对象所处的page中，然后使用 objc_release 释放token之前的对象，并把next指针指到正确的位置 面试题3：autoreleasePool能否嵌套使用？ 可以嵌套使用，其目的是可以 控制应用程序的内存峰值，使其不要太高 可以嵌套的原因是因为自动释放池是以栈为节点，通过双向链表的形式链接的，且是和线程一一对应的 自动释放池的 多层嵌套 其实就是不停的 push哨兵对象，在pop时，会先释放里面的，在释放外面的 面试题4：哪些对象可以加入autoreleasePool？alloc创建可以吗？ 使用 alloc、new、copy 关键字生成的对象和 retain 了的对象 需要手动释放，不会被添加到自动释放池 设置为 autorelease 的对象 不需要手动释放，会直接进入自动释放池 所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中 面试题5：autoreleasePool的释放实际是什么时候？ APP启动后，苹果主线程 runloop 里面注册了两个 observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 observer 监视的事件是 Entry（即将键入loop），其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池，其 order 是 -2147483647，优先级最高，保证创建释放池发生在其他所有回调之前 第二个 observer 监视了两个事件：BeforeWaiting(准备进入休眠)时 调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池创建新的池子。 Exit（即退出loop）时调用 _objc_autoreleasePoolPop()来释放自动释放池。这个observer的order是214748647，优先级最低，保证其释放池子发生在其他所有回调之后。 面试题6：thread和autoreleasePool的关系？在 官方文档 中，找到如下说明： 1Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects (see Threads). As new pools are created, they get added to the top of the stack. When pools are deallocated, they are removed from the stack. Autoreleased objects are placed into the top autorelease pool for the current thread. When a thread terminates, it automatically drains all of the autorelease pools associated with itself. 大致意思是： 每个线程，包括 主线程 在内都维护了 自己的自动释放池堆栈结构 新的 自动释放池在被创建时，会被添加到 栈顶，当自动释放池 销毁时，会 从栈中移除 对于 当前线程 来说，会 将自动释放池的对象 放入自动释放池的 栈顶，在线程停止时，会 自动释放掉与该线程相关联的所有自动释放池 总结： 每个线程都有与之关联的自动释放池堆栈结构，新的pool在创建时会被压栈到栈顶，pool销毁时，会被出栈，对于当前线程来说，释放对象会被压栈到栈顶，线程停止时，会自动释放与之相关联的自动释放池 面试题7：runloop和autorelease的关系在 官方文档 中，找到如下说明 1The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event. 大致意思如下： 主线程的 runloop 在每次事件循环之前，会自动创建一个 autoreleasePool 并且会在 事件循环 结束时，执行 drain 操作，释放其中的对象 RunLoop相关面试题1：当前有个子线程，子线程中有个timer，timer是否能够执行，并进行持续大打印？1234567891011121314151617ZJThread *thread = [[ZJThread alloc] initWithBlock:^&#123; // thread.name = nil 因为这个变量只是捕捉 // ZJThread *thread = nil // thread = 初始化 捕捉一个nil进来 NSLog(@&quot;%@---%@&quot;,[NSThread currentThread],[[NSThread currentThread] name]); [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123; NSLog(@&quot;hello word&quot;); // 退出线程--结果runloop也停止了 if (self.isStopping) &#123; [NSThread exit]; &#125; &#125;]; &#125;]; thread.name = @&quot;lgcode.com&quot;; [thread start]; 不可以，因为 子线程的runloop默认是不启动的，需要 runloop run 启动，需要将上述代码改成下面： 123456789101112131415161718ZJThread *thread = [[ZJThread alloc] initWithBlock:^&#123; // thread.name = nil 因为这个变量只是捕捉 // ZJThread *thread = nil // thread = 初始化 捕捉一个nil进来 NSLog(@&quot;%@---%@&quot;,[NSThread currentThread],[[NSThread currentThread] name]); [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123; NSLog(@&quot;hello word&quot;); // 退出线程--结果runloop也停止了 if (self.isStopping) &#123; [NSThread exit]; &#125; &#125;]; [[NSRunLoop currentRunLoop] run]; &#125;]; thread.name = @&quot;lgcode.com&quot;; [thread start]; 面试题2：runloop和线程的关系 每个线程都有一个与之对应的runloop，所以 runloop与线程是一一对应的，其绑定关系通过一个 全局的Dictionary存储，线程为 key，runloop为 value 线程中的runloop主要用来里线程的，当线程runloop开启后，会在执行完任务后进行休眠状态，当有事件触发唤醒时，又开始工作，即 有活时干活，没活就休息。 主线程 的 runloop 是 默认开启的，在程序启动之后，会一直运行，不会退出 其他线程的 runloop默认是不开启的，如果需要，则手动开启 面试题3：NSRunLoop 和 CFRunLoopRef区别 NSRunLoop 是 基于CFRunLoopRef 面向对象的 API，是 不安全 的。 CFRunLoopRef 是 基于C 语言的，是 线程安全 的 面试题4：RunLoop的mode作用是什么？mode 主要是用于指定runloop中事件优先级的 面试题5：以 +scheduledTimerWithTimeInterval: 的方式触发的timer，在滑动页面上的利润表时，timer会暂停回调，为什么？如何解决？ timer停止的原因是因为滑动 scrollView 时，主线程的runloop会从 NSDefaultRunLoopMode 切换到 NSTrackingRunLoopMode ，而 timer 是添加在 NSDefaultRunLoopMode 上的，所以timer不会执行 将 timer 放入 NSRunLoopCommonModes 中执行","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理36：内存管理（二）強引用分析","slug":"OC进阶/OC底层原理36：内存管理（二）強引用分析","date":"2021-05-29T06:48:15.000Z","updated":"2022-04-13T06:42:35.000Z","comments":true,"path":"2021/05/29/OC进阶/OC底层原理36：内存管理（二）強引用分析/","link":"","permalink":"https://www.bboyzj.cn/2021/05/29/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8636%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BC%B7%E5%BC%95%E7%94%A8%E5%88%86%E6%9E%90/","excerpt":"","text":"前言本文主要是通过 定时器 来梳理 强引用 的几种解决方案 強应用（強持有）假设有 A和B 两个页面，从A push 到B页面，在B页面中有如下定时器代码，当从B pop 回到A界面时，发现定时器没有停止，其方法仍然在执行，为什么？ 12self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(fireHome) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes]; 其主要原因是 B页面没有释放，即 没有执行dealloc方法，导致timer也无法停止和释放 解决方式一 重写 didMoveParentViewController 方法 123456789- (void)didMoveToParentViewController:(UIViewController *)parent&#123; // 无论push 进来 还是 pop 出去 正常跑 // 就算继续push 到下一层 pop 回去还是继续 if (parent == nil) &#123; [self.timer invalidate]; self.timer = nil; NSLog(@&quot;timer 走了&quot;); &#125;&#125; 解决方式二 定义timer时，采用 闭包 的形式，因此不需要指定target 12345- (void)blockTimer&#123; self.timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123; NSLog(@&quot;timer fire - %@&quot;,timer); &#125;];&#125; 现在，我们从底层来深入研究，为什么 B 页面有了 timer 之后，导致 B 页面释放不掉，即不会走到 dealloc 方法，我们可以通过官方文档查看 timerWithTimeInterval:target:selector:userInfo:repeats: 方法中对target的描述 从文档中可以看出，timer对传入的target具有強持有，即 timer 持有 self。由于timer是定义在B页面中，所以 self也持有timer，因此 self- &gt; timer -&gt; self 构成了 循环引用 在 OC底层原理30：Block底层原理 文章中，针对循环引用提供了几种解决方式，我们可以尝试通过 __weak 即 弱引用 来解决，代码修改如下： 123__weak typeof(self) weakSelf = self;self.timer = [NSTimer timerWithTimeInterval:1 target:weakSelf selector:@selector(fireHome) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes]; 我们再次运行程序，运行 push-pop 跳转，发现 问题还是存在，即定时器方法仍然在执行，并 没有执行B的dealloc方法，为什么呢? 我们使用 __weak 虽然打破了 self -&gt; timer -&gt; self 之前的循环引用，即引用链变成了 self -&gt; timer -&gt; weakSelf -&gt; self。但是在这里我们分析的并不全面，此时还有一个 Runloop对timer的強持有，因为 Runloop 的 生命周期 比 B 页面 更长，所以导致了 timer无法释放，同时也导致了 B 页面的 self也无法释放。所以，最初引用链 应该是这样的： 加上 weakSelf 之后，变成了这样 weakSelf 与 self 对于 weakSelf 和 self ，主要有以下两个疑问？ weakSelf 会对引用计数进行 +1 操作么？ weakSelf 和 self 的指针地址相同么？是指向同一片内存么？ 带着疑问，我们在 weakSelf 前后打印 self 的引用计数 因此可以得出一个结论：weakSelf没有对内存进行+1操作 继续打印 weakSelf 和 self 对象，以及指针地址 12345po weakSelfpo selfp &amp;weakSelfp &amp;self 打印结果如下 从打印结果可以看出，当前 self 取地址和 weakSelf 取地址的值是不一样的。意味着 两个指针地址，指向的是同一片内存空间，即 weakSelf和self的内存地址是不一样的，都指向同一片内存空间 的 从上面打印可以看出，此时 timer 捕获的是 &lt;LGTimerViewController: 0x102c04dd0&gt; ，是一个 对象，所以 无法通过weakSelf来解决強持有。即引用链关系为 ：NSRunloop -&gt; timer -&gt; weakSelf(&lt;LGTimerViewController: 0x102c04dd0&gt;) 。所以 RunLoop对整个对象的空间有強持有，runloop没停，timer 和 weakSelf 是无法释放的 而我们在 block 原理中提及的 block循环引用，与 timer 是 有区别 的。通过block底层原理的方法 __Block_object_assign 可知，block捕获的是 对象的指针地址，即 weakSelf是临时变量的指针地址，跟 self 没有关系，因为 weakSelf是新的地址空间。所以此时的weakSelf相当于中间值。其引用关系链为 self -&gt; block -&gt; weakSelf(临时变量的指针地址)，可以通过 地址 拿到 指针 所以在这里，我们需要区别下 block 和 timer 循环引用的模型 timer模型：self -&gt; timer -&gt; weakSelf -&gt; self，当前的 timer 捕获的是 B页面的内存，即vc对象的内存，即 weakSelf表示的是vc对象 block模型：self -&gt; block -&gt; weakSelf -&gt; self，当前的block捕获的是 指针地址，即 weakSelf 表示的是 指向self的临时变量的指针地址 解决 強引用（強持有）有以下几种解决思路：依赖 中介者模式、打破強持有，其中 推荐思路四 思路一：pop时在其他方法中销毁timer根据前面的解释，我们知道由于 Runloop对timer的強持有，导致了 Runloop间接的強持有了self（因为timer中捕获的是 vc对象）。所以导致 dealloc 方法无法执行。需要查看在pop时，是否还有其他方法可以销毁 timer。这个方法就是 didMoveToParentViewController didMoveToParentViewController 方法，是用于当一个视图控制器中添加或者移除 viewController后，必须调用的方法。目的是为了告诉iOS，已经完成添加&#x2F;删除子控制器的操作。 在B界面中重写 didMoveToParentViewController 方法 123456789- (void)didMoveToParentViewController:(UIViewController *)parent&#123; // 无论push 进来 还是 pop 出去 正常跑 // 就算继续push 到下一层 pop 回去还是继续 if (parent == nil) &#123; [self.timer invalidate]; self.timer = nil; NSLog(@&quot;timer 走了&quot;); &#125;&#125; 思路二：中介者模式，即不使用self，依赖于其他对象在timer模式中，我们重点关注的是 fireHome 能执行，并 不关心timer捕获target 是谁，由于这里 不方便使用self（因为会有强持有问题），所以 可以将target换成其他对象，例如将target换成 NSObject对象，将 fireHome 交给 target 执行 将timer的target由self改成objc 123456789101112131415161718192021// 1.定义成其他对象@property (nonatomic, strong)id target;// 2.修改targetself.target = [[NSObject alloc] init];class_addMethod([NSObject class],@selector(fireHome),(IMP)fireHomeObjc,&quot;v@:&quot;);self.timer = [];// 3.imp- (void)fireHome&#123; num++; NSLog(@&quot;hello word - %d&quot;,num);&#125;void fireHomeObjc(id obj)&#123; NSLog(@&quot;%s -- %@&quot;,__func__,obj);&#125;// 4.dealloc- (void)dealloc&#123; NSLog(@&quot;%s&quot;,__func__);&#125; 查看运行结果如下 运行发现执行 dealloc 之后，timer还是会继续执行。原因是 解决了中介者的释放，但是 没有解决中介者的回收，即 self.target的回收。所以这种方式 有缺陷 可以通过在 dealloc 方法中，取消定时器来解决，代码如下： 12345- (void)dealloc&#123; [self.timer invalidate]; self.timer = nil; NSLog(@&quot;%s&quot;,__func__);&#125; 运行代码查看结果如下，发现 pop 之后，timer释放，从而中介者也会进行回收释放 思路三：自定义封装timer这种方式是根据思路二的原理，自定义封装timer，其步骤如下： 自定义timerWapper 在初始化方法中，定义一个timer，其target是自己。即 timerWapper 中的 timer，一直监听自己，判断 selector，此时的selector已交给了传入的target（即vc对象），此时有一个方法 fireHomeWapper，在方法中，判断target是否存在 如果 target存在，则需要让vc知道，即向传入的target发送selector消息，并将此时的timer作为参数也一并传入，所以vc就可以得知 fireHome 方法，这种方式是定时器方法能够执行的原因 如果 target不存在，已经释放了，则释放当前的 timerWapper ，即打破了Runloop对timerWapper的強持有（timerWapper &lt;- x - RunLoop） 自定义 zj_invalidate 方法中释放timer。这个方法在vc的dealloc方法中调用，即 vc释放，从而导致timerWapper释放，打破了 vc 对 timerWapper 的強持有（vc -&gt; x -&gt; timerWapper） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//********** .h文件 *********@interface ZJTimerWapper : NSObject- (instancetype)zj_initWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;- (void)zj_invalidate;@end//********** .m文件 ********@implementation ZJTimerWapper- (instancetype)zj_initWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo&#123; if (self == [super init]) &#123; // 传入vc self.target = aTarget; // 传入定时器方法 self.aSelector = aSelector; if ([self.target respondsToSelector:self.aSelector]) &#123; Method method = class_getInstanceMethod([self.target class], aSelector); const char *type = method_getTypeEncoding(method); // 给timerWapper添加方法 class_addMethod([self class], aSelector, (IMP)fireHomeWapper, type); // 启动一个timer，target是self，即监听自己 self.timer = [NSTimer scheduledTimerWithTimeInterval:ti target:self selector:aSelector userInfo:userInfo repeats:yesOrNo]; &#125; &#125; return self;&#125;// 一直跑 runloopvoid fireHomeWapper(ZJTimerWapper *warpper)&#123; // 判断target是否存在 if (warpper.target) &#123; // 如果存在则需要vc知道，即向传入的target发送selector消息，并将此时的timer参数一并传入，所以vc就可以得知 fireHome 方法，这种方式就是定时器方法能够执行的原因 void (*zj_msgSend)(void *,SEL, id) = (void *)objc_msgSend; zj_msgSend((__bridge void *)(warpper.target), warpper.aSelector,warpper.timer); &#125;else&#123; // 如果target不存在，已经释放，则释放当前的timerWrapper [warpper.timer invalidate]; warpper.timer = nil; &#125;&#125;// 在vc的dealloc方法中调用，通过vc释放，从而让timer释放- (void)zj_invalidate&#123; [self.timer invalidate]; self.timer = nil;&#125;- (void)dealloc&#123; NSLog(@&quot;%s&quot;,__func__);&#125;@end timerWapper的使用 12345678// 定义self.timerWapper = [[ZJTimerWapper alloc] zj_initWithTimeInterval:1 target:self selector:@selector(fireHome) userInfo:nil repeats:YES];// 释放- (void)dealloc&#123; [self.timerWapper zj_invalidate]; NSLog(@&quot;%s&quot;,__func__);&#125; 运行结果如下 这种方式看起来比较繁琐，步骤很多，而且针对 timerWapper，需要不断的添加method，需要进行一系列的处理 思路四：利用NSProxy虚基类的子类下面来介绍一种 timer 強引用 最常用 的处理方式：NSProxy子类 可以通过 NSProxy 虚基类，可以交给其子类实现，NSproxy的介绍在前面的文章已经介绍过了，这里不再重复 首先定义一个集成自 NSProxy 的子类 1234567891011121314151617//**********NSProxy子类**********@interface ZJProxy : NSProxy+ (instancetype)proxyWithTransformObject:(id)object;@end@interface ZJProxy()@property (nonatomic, weak) id object;@implementation ZJProxy+ (instancetype)proxyWithTransformObject:(id)object&#123; ZJProxy *proxy = [ZJProxy alloc]; proxy.object = object; return proxy;&#125;-(id)forwardingTargetForSelector:(SEL)aSelector &#123; return self.object;&#125; 将timer中的target传入NSProxy子类对象，即timer持有NSProxy子类对象 12345678910//**********解决timer強持有的问题*********self.proxy = [ZJProxy proxyWithTransformObject:self];self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self.proxy selector:@selector(fireHome) userInfo:nil repeats:YES];//在dealloc中将timer正常释放- (void)dealloc&#123; [self.timer invalidate]; self.timer = nil; NSLog(@&quot;%s&quot;,__func__);&#125; 这样做的目的是将 強引用的注意力转移成了消息转发。虚基类只负责消息转发，即使用 NSProxy 作为 中间代理、中间者 这里有个疑问，定义 proxy 对象，在dealloc释放时，还存在么？ proxy对象会正常释放，因为 vc 正常释放了，所以可以释放其持有者，即 timer和proxy，timer的释放也打破了 runloop对proxy的强持有。完美的达到了 两层释放，即 vc -&gt; proxy &lt;- runloop，解释如下： vc释放，导致了 proxy 的释放 dealloc方法中，timer进行了释放，所以runloop强引用也释放了","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理35：内存管理（一）TaggedPointer/retain/release/dealloc/retainCount 底层分析","slug":"OC进阶/OC底层原理35：内存管理（一）TaggedPointer-retain-release-dealloc-retainCount-底层分析","date":"2021-05-22T06:47:27.000Z","updated":"2022-04-12T06:31:59.000Z","comments":true,"path":"2021/05/22/OC进阶/OC底层原理35：内存管理（一）TaggedPointer-retain-release-dealloc-retainCount-底层分析/","link":"","permalink":"https://www.bboyzj.cn/2021/05/22/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8635%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89TaggedPointer-retain-release-dealloc-retainCount-%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/","excerpt":"","text":"前言本文主要是分析内存管理中的内存管理方案，以及 retain、retainCount、release、dealloc 的底层源码分析 ARC &amp; MRCiOS中的内存管理方案，大致可以分为两类：MRC(手动内存管理) 和 ARC(自动内存管理) MRC 在 MRC 时代，系统是通过对象的引用计数来判断一个是否销毁，有以下规则 对象被 创建时 引用计数都为 1 当对象 被其他指针引用 时，需要手动调用 [objc retain]，使对象的 引用计数+1 当指针变量不再使用对象时，需要手动调用 [objc release] 来 释放 对象，使对象的 引用计数-1 当一个对象的 引用计数为0 时，系统就会 销毁 这个对象 所以，在MRC模式下，必须遵守：谁创建，谁释放，谁引用，谁管理 ARC ARC 模式是在WWDC2011和iOS5引入的自动管理机制，即 自动引用计数，是编译器的一种特性。其规则与MRC一致，区别在于，ARC模式下不需要手动retain、release、autorelease，编译器会在适当位置插入release和autorelease 内存布局我们在前面介绍了 内存五大区，其实除了 内存区，还有 内核区 和 保留区，以 4GB 手机为例，如下所示，系统将其中的 3GB 给了 五大区 + 保留区，剩余的 1GB 给内核区使用 内核区：系统用来进行内核处理操作的区域 五大区：这里不再作说明，具体请参考上面的链接 保留区：预留给系统处理nil等 这里有个疑问，为什么五大区的最后内存地址是从 0x00400000 开始的。其主要原因是 0x00000000 表示 nil，不能直接用nil表示一个段，所以单独给了一段内存用于 处理nil 等情况 内存布局相关面试题面试题1：全局变量和局部变量在内存中是否有区别？如果有，是什么区别？ 有区别 全局变量 保存在内存的 全局存储区（即bss+data段），占用静态的存储单元 局部变量 保存在 栈 中，只有在所在 函数被调用时才动态的为变量分配存储单元 面试题2：Block中可以修改全局变量，全局静态变量，局部静态变量，局部变量吗？ 可以修改 全局变量，全局静态变量，因为 全局变量 和 静态全局变量 是 全局 的，作用域广 可以修改局部静态变量，不可以修改局部变量 局部静态变量（static修饰的）和 局部变量，被block从外面捕获的，成为 __main_block_imp_0 这个结构体的成员变量 局部变量 是以 指针形式，被block捕获的，由于捕获的是指针，所以 可以修改 局部静态变量的值 ARC环境下，一旦使用 __block 修饰并在block中修改，就会 触发copy，block就会从 栈区copy到堆区，此时的 block是堆区block ARC模式下，block中引用 id类型 的数据，无论有没有__block修饰，都会retain，对于 基础数据类型，没有__block就无法修改变量值，如果有 __block修饰，也是在底层修改 __block_byref_a_0 结构体，将其内部的 forwarding 指针指向 copy后的地址，来达到值的修改 内存管理方案内存管理方案除了前文提及的 MRC 和 ARC，还有以下三种： Tagged Pointer：专门用来处理小对象，例如NSNumber、NSDate、小NSString等 Nonpointer_isa：非指针类型的isa，主要是用来优化64位地址，这个在 OC底层原理08：isa和类关联探索 一文中，已经介绍了 SideTables：散列表，在散列表中主要有两个表，分别是 引用计数表、弱引用表 这里主要着重借号 Tagged Pointer 和 SideTables，我们通过一个面试题来引入 Tagged Pointer 面试题 以下代码会有什么问题？ 123456789101112131415161718192021222324252627@interface ViewController ()@property (nonatomic,strong)dispatch_queue_t queue;@property (nonatomic,copy)NSString * nameStr;@end@implementation ViewController- (void)taggedPointerDemo&#123; self.queue = dispatch_queue_create(&quot;com.zj.cn&quot;, DISPATCH_QUEUE_CONCURRENT); for (int i = 0; i &lt; 10000; i ++) &#123; dispatch_async(self.queue, ^&#123; // alloc 堆 iOS优化 - taggedpointer self.nameStr = [NSString stringWithFormat:@&quot;zj&quot;]; NSLog(@&quot;%@&quot;,self.nameStr); &#125;); &#125;&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;来了&quot;); for (int i = 0; i &lt; 10000; i ++) &#123; dispatch_async(self.queue, ^&#123; self.nameStr = [NSString stringWithFormat:@&quot;zj_越努力，越幸运&quot;]; NSLog(@&quot;%@&quot;,self.nameStr); &#125;); &#125;&#125;@end 运行以上代码，发现 taggedPointerDemo 单独运行没有问题，当触发 touchBegan 方法后。程序会崩溃，崩溃的原因是 多条线程同时对一个对象进行解释，导致了 过渡释放 所以崩溃。其根本原因是因为 nameStr 在底层的类型不一致导致的，我们可以通过调试看出 taggedPointerDemo 方法中的 nameStr 类型是 NSTaggedPointerString，存储在 常量区。因为 nameStr 在 alloc 分配时在 堆区，由于较小，所以经过xcode在iOS中的优化，成了 NSTaggedPointerString 类型，存储在 常量区 touchesBegan 方法中的 nameStr 类型是 NSCFString 类型，存储在 堆上 NSString的内存管理 我们可以通过NSString初始化的两种方式，来测试NSString的内存管理 通过 WithString + @&quot;&quot; 方式初始化 通过 WithFormat 方式初始化 1234567891011121314151617181920212223242526#define ZJLog(_c) NSLog(@&quot;%@ -- %p -- %@&quot;,_c,_c,[_c class]);- (void)testNSString&#123; // 初始化方式一：通过 WithString + @&quot;&quot; 方式 NSString * s1 = @&quot;1&quot;; NSString * s2 = [[NSString alloc] initWithString:@&quot;2&quot;]; NSString * s3 = [NSString stringWithString:@&quot;3&quot;]; ZJLog(s1); ZJLog(s2); ZJLog(s3); // 初始化方式二：通过 WithFormat // 字符串长度在9以内 NSString * s4 = [NSString stringWithFormat:@&quot;123456789&quot;]; NSString * s5 = [[NSString alloc] initWithFormat:@&quot;123456789&quot;]; // 字符串长度大于9 NSString * s6 = [NSString stringWithFormat:@&quot;1234567890&quot;]; NSString * s7 = [[NSString alloc] initWithFormat:@&quot;1234567890&quot;]; ZJLog(s4); ZJLog(s5); ZJLog(s6); ZJLog(s7);&#125; 以下是运行的结果 所以，从上面可以总结出，NSString的 内存管理 主要分为3中 __NSCFConstantString：字符串常量区，是一种 编译时常量，retainCount值很大，对其操作，不会引起引用计数变化，存储在字符串常量区 __NSCFString：是在 运行时 创建的 NSString子类，创建后 引用计数会加1，存储在堆上 NSTaggedPointerString：标签指针，是苹果在64位环境下对 NSString、NSNumber 等对象做的优化，对于NSString对象来说 当 字符串是由数字、英文字母组合且长度小于等于9 时，会自动成为 NSTaggedPointerString 类型，存储在 常量区 当有 中文或其他特殊符号 时，会直接成为 __NSCFString 类型，存储在 堆区 Tagged Pointer 小对象由一个NSString的面试题，引出了 Tagged Pointer ，为了探索小对象的引用计数器，处理我们需要进入 objc 源码中查看 retain、release 源码中对 Tagged Pointer 小对象的处理 小对象的引用计数处理分析 查看 setProperty -&gt; reallySetProperty 源码，其中是对 新值retain，旧值release 进入 objc_retain、objc_release 源码，在这里都判断是否是小对象，如果是小对象，则不会进行retain和release，会直接返回，因此可以得出一个结论：如果是小对象，不会进行retain和release 1234567891011121314151617181920212223//****************objc_retain****************__attribute__((aligned(16), flatten, noinline))id objc_retain(id obj)&#123; if (!obj) return obj; //判断是否是小对象，如果是，则直接返回对象 if (obj-&gt;isTaggedPointer()) return obj; //如果不是小对象，则retain return obj-&gt;retain();&#125;//****************objc_release****************__attribute__((aligned(16), flatten, noinline))void objc_release(id obj)&#123; if (!obj) return; //如果是小对象，则直接返回 if (obj-&gt;isTaggedPointer()) return; //如果不是小对象，则release return obj-&gt;release();&#125; 小对象地址分析 一般的 NSString 对象指针，都是 string值 + 指针地址，两者是 分开 的 对于 Tagged Pointer 指针，其 指针+值，都能在小对象中体现，所以 Tagged Pointer即包含指针，也包含值 在之前的文章讲类加载时，其中的 _read_image 源码中有一个方法对小对象进行了处理，即 initializeTaggedPointerObfuscator 方法 进入 _read_image -&gt; initializeTaggedPointerObfuscator 源码实现 123456789101112131415161718static voidinitializeTaggedPointerObfuscator(void)&#123; if (sdkIsOlderThan(10_14, 12_0, 12_0, 5_0, 3_0) || // Set the obfuscator to zero for apps linked against older SDKs, // in case they&#x27;re relying on the tagged pointer representation. DisableTaggedPointerObfuscation) &#123; objc_debug_taggedpointer_obfuscator = 0; &#125; //在iOS14之后，对小对象进行了混淆，通过与操作+_OBJC_TAG_MASK混淆 else &#123; // Pull random data into the variable, then shift away all non-payload bits. arc4random_buf(&amp;objc_debug_taggedpointer_obfuscator, sizeof(objc_debug_taggedpointer_obfuscator)); objc_debug_taggedpointer_obfuscator &amp;= ~_OBJC_TAG_MASK; &#125;&#125; 在实现中，我们可以看出，在iOS14之后，Tagged Pointer 采用了混淆处理，如下所示 我们可以在源码中通过 objc_debug_taggedpointer_obfuscator 查找 taggedPointer 的 编码 和 解码 ，来查看底层是如何混淆处理的 1234567891011//编码static inline void * _Nonnull_objc_encodeTaggedPointer(uintptr_t ptr)&#123; return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);&#125;//解码static inline uintptr_t_objc_decodeTaggedPointer(const void * _Nullable ptr)&#123; return (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator; 通过实现，我们可以得知，在编码和解码部分，经过了 两层异或，其目的是 得到小对象自己，例如以 1010 0001 为例，假设 mask 为 1010 1000 12345 1010 0001 ^0101 1000 mask（编码） 1111 1001^0101 1000 mask（解码） 1010 0001 所以在外界，为了 获取小对象的真是地址，我们可以将解码的源码拷贝到外面，将NSString混淆部分进行 解码，如下所示 12345678910111213141516extern uintptr_t objc_debug_taggedpointer_obfuscator;- (void)test&#123; NSString * s1 = [NSString stringWithFormat:@&quot;a&quot;]; NSString * s2 = [NSString stringWithFormat:@&quot;b&quot;]; NSLog(@&quot;%p - %@&quot;,s1,s1); NSLog(@&quot;%p - %@&quot;,s2,s2); NSLog(@&quot;0x%lx&quot;,_objc_decodeTaggedPointer_(s2)); &#125;uintptr_t_objc_decodeTaggedPointer_(id ptr)&#123; return (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator;&#125; 打印结果如下 观察解码后的 小对象地址，其中的 10 表示 b 的 ASCII 码，再以 NSNumber 为例，同样可以看出，8 就是我们实际的值 123NSNumber * n1 = @1; NSLog(@&quot;%@ - %p - 0x%lx&quot;,n1,n1,_objc_decodeTaggedPointer_(n1)); 打印结果如下 到这里，我们验证了 小对象指针地址中确实存储了值。 TaggedPointer 总结 Tagged Pointer 小对象类型（用于存储 NSNumber、NSDate、小NSString），小对象指针不再是简单的地址，而是 地址+值，即 真正的值，所以，实际上 它不再是一个对象了，它只是一个披着对象皮的普通变量 而已。所以可以直接进行读取。优点是 占用空间小、节省内存 Tagged Pointer 小对象 不会进入retain和release，而是 直接返回了，意味着 不需要ARC进行管理，所以 可以直接被系统自主的释放和回收 Tagged Pointer 的 内存并不存储在堆 中，而是在 常量区 中，也 不需要malloc和free，所以可以直接读取，相比存储在堆区的数据 读取，效率上快乐3倍左右，创建 的效率相比堆区 快了近100倍左右 所以，综合来说，Tagged Pointer 的内存管理方案，比常规的内存管理，要快的多 Tagged Pointer 的64位地址中，前4 位代表类型，后4 位主要适用于系统做一些处理，中间56位用于存储值 优化内存建议：对于 NSString 来说，当字符串 较小 时，建议直接通过 @&quot;&quot; 初始化，因为存储在 常量区，可以直接进行读取，会比 WithFormat初始化方式 更加快速 SideTable 散列表当 引用计数 存储到一定值时，并不会在存储到 Nonpointer_isa 的位域的 extra_rc 中，而是会存储到 SideTable散列表中 下面我们就来继续探索引用计数retain的底层实现 retain源码分析 进入 objc_retain -&gt; retain -&gt; rootRetain 源码实现，主要有以下几部分逻辑 【第一步】判断是否为 Nonapointer_isa 【第二步】操作引用计数 如果不是 Nonapointer_isa，则直接操作 SideTable 散列表，此时的散列表并不只有一张，而是有很多张（后续会分析，为什么需要多张？） 判断 是否正在释放，如果正在释放，则执行dealloc流程 执行 extra_rc + 1，即引用计数+1操作，并给一个引用计数的 状态标识carry， 用于表示 extra_rc 是否满了 如果 carry 的状态表示 extac_rc的引用计数满了 ，此时需要操作 散列表，即满状态拿出来存到 extra_rc，另一半存在散列表的 extrc_half。这么做的原因是因为如果都存储在 散列表，每次对散列表操作都需要开解锁，操作耗时，消耗性能大，这么 对半分 操作的目的在于 提高性能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465ALWAYS_INLINE id objc_object::rootRetain(bool tryRetain, bool handleOverflow)&#123; if (isTaggedPointer()) return (id)this; bool sideTableLocked = false; bool transcribeToSideTable = false; //为什么有isa？因为需要对引用计数+1，即retain+1，而引用计数存储在isa的bits中，需要进行新旧isa的替换 isa_t oldisa; isa_t newisa; //重点 do &#123; transcribeToSideTable = false; oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; //判断是否为nonpointer isa if (slowpath(!newisa.nonpointer)) &#123; //如果不是 nonpointer isa，直接操作散列表sidetable ClearExclusive(&amp;isa.bits); if (rawISA()-&gt;isMetaClass()) return (id)this; if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock(); if (tryRetain) return sidetable_tryRetain() ? (id)this : nil; else return sidetable_retain(); &#125; // don&#x27;t check newisa.fast_rr; we already called any RR overrides //dealloc源码 if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123; ClearExclusive(&amp;isa.bits); if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock(); return nil; &#125; uintptr_t carry; //执行引用计数+1操作，即对bits中的 1ULL&lt;&lt;45（arm64） 即extra_rc，用于该对象存储引用计数值 newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry); // extra_rc++ //判断extra_rc是否满了，carry是标识符 if (slowpath(carry)) &#123; // newisa.extra_rc++ overflowed if (!handleOverflow) &#123; ClearExclusive(&amp;isa.bits); return rootRetain_overflow(tryRetain); &#125; // Leave half of the retain counts inline and // prepare to copy the other half to the side table. if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock(); sideTableLocked = true; transcribeToSideTable = true; //如果extra_rc满了，则直接将满状态的一半拿出来存到extra_rc newisa.extra_rc = RC_HALF; //给一个标识符为YES，表示需要存储到散列表 newisa.has_sidetable_rc = true; &#125; &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits))); if (slowpath(transcribeToSideTable)) &#123; // Copy the other half of the retain counts to the side table. //将另一半存在散列表的rc_half中，即满状态下是8位，一半就是1左移7位，即除以2 //这么操作的目的在于提高性能，因为如果都存在散列表中，当需要release-1时，需要去访问散列表，每次都需要开解锁，比较消耗性能。extra_rc存储一半的话，可以直接操作extra_rc即可，不需要操作散列表。性能会提高很多 sidetable_addExtraRC_nolock(RC_HALF); &#125; if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock(); return (id)this;&#125; 问题1：散列表为什么在内存有多张？最多能够多少张？ 如果散列表只有一张表，意味着全局所有的对象都会存储在一张表中，都会进行开锁解锁（锁是锁整个表的读写）。当开锁时，由于所有数据都在一张表，则意味着 数据不安全 如果 每个对象都开一个表，会 耗费性能，所以也不能有无数个表 散列表的类型是 SideTable，有如下定义 1234567struct SideTable &#123; spinlock_t slock;//开/解锁 RefcountMap refcnts;//引用计数表 weak_table_t weak_table;//弱引用表 ....&#125; 通过查看 sidetable_unlock 方法定位 SideTables，其内部是通过 SideTablesMap 的get方法获取。而 SideTablesMap 是通过 StripedMap&lt;SideTable&gt; 定义的 12345678910111213void objc_object::sidetable_unlock()&#123; //SideTables散列表并不只是一张，而是很多张，与关联对象表类似 SideTable&amp; table = SideTables()[this]; table.unlock();&#125;👇static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123; return SideTablesMap.get();&#125;👇static objc::ExplicitInit&lt;StripedMap&lt;SideTable&gt;&gt; SideTablesMap; 从而进入 StripedMap 的定义，从这里可以看出，同一时间，真机中散列表最多只能有8张 问题2：为什么在用散列表，而不用数组、链表？ 数组：特点在于 查询方便（即通过下标访问），增删比较麻烦（类似于之前讲过的 methodList，通过 memcopy、memove 增删，非常麻烦），所以数据的特性是 读取快、存储不方便 链表：特点在于 增删方便、查询慢（需要从头头节点开始遍历查询），所以链表的特性是 存储快、读取慢 散列表 ： 本质 就是一张 哈希表，哈希表 集合了数组和链表的长处，增删改查都比较方便，例如 拉链哈希表（在之前锁的文章中，讲过 tls 的存储结构就是 拉链形式的），是最常用的，如下所示 可以从 SideTables -&gt; StripedMap -&gt; indexForPointer 中验证是 通过嘻哈函数计算哈希下标 以及 sideTables 为什么可以 使用[] 的原因 所以，综上所述，retain 的底层流程如下所示 总结：retain完成回答 retain 在底层首先会 判断是否是 Nonpointer isa，如果 不是，则直接操作散列表，进行+1操作 如果 是Nonpointer isa，还需要 判断是否正在释放，如果正在 释放，则执行dealloc流程，释放弱引用表和引用技术表，最后free释放对象内存 如果 不是正在释放，则对Nonpointer isa进行常规引用计数+1，这里需要注意一点的是，extra_rc 在真机上只有 8位用于存储引用计数的值，当存储 满了 时，需要 借助散列表 用于存储。需要将满了 extra_rc 对半分，一半（即2^7）存储在 散列表 中，另一半还是存储在 extra_rc 中，用于常规的引用计数的+1或者-1操作，然后再返回 release 源码分析分析了 retain 的底层实现，下面来分析 release 的底层实现 通过 setProperty -&gt; reallySetProperty -&gt; objc_release -&gt; release -&gt; rootRelease -&gt; rootRelease 顺序，进入 rootRelease 源码，其操作与retain相反 判断是否是 Nonpointer isa ，如果不是，则 直接对散列表进行-1操作 如果是 Nonpointer isa ，则对extra_rc 中的引用计数值进行 -1 操作，并存储此时的 extra_rc 状态到 carry 中 如果此时的状态 carry 为 0，则走到 underflow 流程 underflow 流程有以下几步 判断 散列表 中 是否存储了一半的引用计数 如果是，则从 散列表 中取出 存储的一半引用计数，进行 -1操作，然后存储到 extra_rc 中 如果此时 extra_rc 没有值，散列表中也是空的，则直接进行析构，即 dealloc 操作，属于自动触发 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132ALWAYS_INLINE bool objc_object::rootRelease(bool performDealloc, bool handleUnderflow)&#123; if (isTaggedPointer()) return false; bool sideTableLocked = false; isa_t oldisa; isa_t newisa; retry: do &#123; oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; //判断是否是Nonpointer isa if (slowpath(!newisa.nonpointer)) &#123; //如果不是，则直接操作散列表-1 ClearExclusive(&amp;isa.bits); if (rawISA()-&gt;isMetaClass()) return false; if (sideTableLocked) sidetable_unlock(); return sidetable_release(performDealloc); &#125; // don&#x27;t check newisa.fast_rr; we already called any RR overrides uintptr_t carry; //进行引用计数-1操作，即extra_rc-1 newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry); // extra_rc-- //如果此时extra_rc的值为0了，则走到underflow if (slowpath(carry)) &#123; // don&#x27;t ClearExclusive() goto underflow; &#125; &#125; while (slowpath(!StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, newisa.bits))); if (slowpath(sideTableLocked)) sidetable_unlock(); return false; underflow: // newisa.extra_rc-- underflowed: borrow from side table or deallocate // abandon newisa to undo the decrement newisa = oldisa; //判断散列表中是否存储了一半的引用计数 if (slowpath(newisa.has_sidetable_rc)) &#123; if (!handleUnderflow) &#123; ClearExclusive(&amp;isa.bits); return rootRelease_underflow(performDealloc); &#125; // Transfer retain count from side table to inline storage. if (!sideTableLocked) &#123; ClearExclusive(&amp;isa.bits); sidetable_lock(); sideTableLocked = true; // Need to start over to avoid a race against // the nonpointer -&gt; raw pointer transition. goto retry; &#125; // Try to remove some retain counts from the side table. //从散列表中取出存储的一半引用计数 size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF); // To avoid races, has_sidetable_rc must remain set // even if the side table count is now zero. if (borrowed &gt; 0) &#123; // Side table retain count decreased. // Try to add them to the inline count. //进行-1操作，然后存储到extra_rc中 newisa.extra_rc = borrowed - 1; // redo the original decrement too bool stored = StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, newisa.bits); if (!stored) &#123; // Inline update failed. // Try it again right now. This prevents livelock on LL/SC // architectures where the side table access itself may have // dropped the reservation. isa_t oldisa2 = LoadExclusive(&amp;isa.bits); isa_t newisa2 = oldisa2; if (newisa2.nonpointer) &#123; uintptr_t overflow; newisa2.bits = addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &amp;overflow); if (!overflow) &#123; stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, newisa2.bits); &#125; &#125; &#125; if (!stored) &#123; // Inline update failed. // Put the retains back in the side table. sidetable_addExtraRC_nolock(borrowed); goto retry; &#125; // Decrement successful after borrowing from side table. // This decrement cannot be the deallocating decrement - the side // table lock and has_sidetable_rc bit ensure that if everyone // else tried to -release while we worked, the last one would block. sidetable_unlock(); return false; &#125; else &#123; // Side table is empty after all. Fall-through to the dealloc path. &#125; &#125; //此时extra_rc中值为0，散列表中也是空的，则直接进行析构，即自动触发dealloc流程 // Really deallocate. //触发dealloc的时机 if (slowpath(newisa.deallocating)) &#123; ClearExclusive(&amp;isa.bits); if (sideTableLocked) sidetable_unlock(); return overrelease_error(); // does not actually return &#125; newisa.deallocating = true; if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry; if (slowpath(sideTableLocked)) sidetable_unlock(); __c11_atomic_thread_fence(__ATOMIC_ACQUIRE); if (performDealloc) &#123; //发送一个dealloc消息 ((void(*)(objc_object *, SEL))objc_msgSend)(this, @selector(dealloc)); &#125; return true;&#125; 所以，综上所述，release 的底层流程如下图所示 dealloc 源码分析在 retain 和 release 的底层实现中，都提及了 dealloc 析构函数，下面来分析 dealloc 的底层实现 进入 dealloc -&gt; _objc_rootDealloc -&gt; rootDealloc 源码实现，主要有两件事： 根据条件 判断是否有isa、cxx、关联对象、若引用表、引用计数表，如果没有，则 直接free释放内存 如果有，则进入 object_diapose 方法 1234567891011121314151617181920212223inline voidobjc_object::rootDealloc()&#123; //对象要释放，需要做哪些事情？ //1、isa - cxx - 关联对象 - 弱引用表 - 引用计数表 //2、free if (isTaggedPointer()) return; // fixme necessary? //如果没有这些，则直接free if (fastpath(isa.nonpointer &amp;&amp; !isa.weakly_referenced &amp;&amp; !isa.has_assoc &amp;&amp; !isa.has_cxx_dtor &amp;&amp; !isa.has_sidetable_rc)) &#123; assert(!sidetable_present()); free(this); &#125; else &#123; //如果有 object_dispose((id)this); &#125;&#125; 进入 object_dispose 源码，其目的有以下几个 销毁实例，主要有以下操作 调用c++析构函数 删除关联引用 释放散列表 清空弱引用表 free释放内存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566id object_dispose(id obj)&#123; if (!obj) return nil; //销毁实例而不会释放内存 objc_destructInstance(obj); //释放内存 free(obj); return nil;&#125;👇void *objc_destructInstance(id obj) &#123; if (obj) &#123; // Read all of the flags at once for performance. bool cxx = obj-&gt;hasCxxDtor(); bool assoc = obj-&gt;hasAssociatedObjects(); // This order is important. //调用C ++析构函数 if (cxx) object_cxxDestruct(obj); //删除关联引用 if (assoc) _object_remove_assocations(obj); //释放 obj-&gt;clearDeallocating(); &#125; return obj;&#125;👇inline void objc_object::clearDeallocating()&#123; //判断是否为nonpointer isa if (slowpath(!isa.nonpointer)) &#123; // Slow path for raw pointer isa. //如果不是，则直接释放散列表 sidetable_clearDeallocating(); &#125; //如果是，清空弱引用表 + 散列表 else if (slowpath(isa.weakly_referenced || isa.has_sidetable_rc)) &#123; // Slow path for non-pointer isa with weak refs and/or side table data. clearDeallocating_slow(); &#125; assert(!sidetable_present());&#125;👇NEVER_INLINE voidobjc_object::clearDeallocating_slow()&#123; ASSERT(isa.nonpointer &amp;&amp; (isa.weakly_referenced || isa.has_sidetable_rc)); SideTable&amp; table = SideTables()[this]; table.lock(); if (isa.weakly_referenced) &#123; //清空弱引用表 weak_clear_no_lock(&amp;table.weak_table, (id)this); &#125; if (isa.has_sidetable_rc) &#123; //清空引用计数 table.refcnts.erase(this); &#125; table.unlock();&#125; 所以，综上所述，dealloc 底层的流程图如图所示 所以，到目前为止，从最开始的 alloc底层分析 -&gt; retain -&gt; release -&gt; dealloc 就全部串联起来了 retainCount 源码分析引用计数的分析通过一个面试题来说明 面试题：alloc创建的对象的引用计数为多少？ 定义如下代码，打印其引用计数 12NSObject *objc = [NSObject alloc];NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)objc)); 其打印结果如下 进入 retainCount -&gt; _objc_rootRetainCount -&gt; rootRetainCount 源码，其实现如下： 12345678910111213141516171819202122232425262728293031323334- (NSUInteger)retainCount &#123; return _objc_rootRetainCount(self);&#125;👇uintptr_t_objc_rootRetainCount(id obj)&#123; ASSERT(obj); return obj-&gt;rootRetainCount();&#125;👇inline uintptr_t objc_object::rootRetainCount()&#123; if (isTaggedPointer()) return (uintptr_t)this; sidetable_lock(); isa_t bits = LoadExclusive(&amp;isa.bits); ClearExclusive(&amp;isa.bits); //如果是nonpointer isa，才有引用计数的下层处理 if (bits.nonpointer) &#123; //alloc创建的对象引用计数为0，包括sideTable,所以对于alloc来说，是 0+1=1，这也是为什么通过retaincount获取的引用计数为1的原因 uintptr_t rc = 1 + bits.extra_rc; if (bits.has_sidetable_rc) &#123; rc += sidetable_getExtraRC_nolock(); &#125; sidetable_unlock(); return rc; &#125; //如果不是，则正常返回 sidetable_unlock(); return sidetable_retainCount();&#125; 在这里我们可以通过源码断点调试，来查看此时的 extra_rc 的值，结果如下 答案： 综上所述，alloc 创建的对象 实际的引用计数为0，其引用计数打印结果为1，是因为在底层 rootRetainCount 方法中，引用计数默认+1 了，但是这里 只有 对引用计数的 读取 操作，是没有写入操作的，简单来说就是：为了防止alloc创建的对象被释放（引用计数为0会被释放），所以在编译阶段，程序底层默认进行了+1操作。实际上在extra_rc中的引用计数仍然诶0 总结 alloc 创建的对象 没有retain 和 release alloc 创建对象的 引用计数为0，会在 编译时期，程序 默认加1，所以读取引用计数时为1","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理34：启动优化（三）二进制重排","slug":"OC进阶/OC底层原理34：启动优化（三）二进制重排","date":"2021-05-17T06:44:54.000Z","updated":"2023-02-28T02:40:18.130Z","comments":true,"path":"2021/05/17/OC进阶/OC底层原理34：启动优化（三）二进制重排/","link":"","permalink":"https://www.bboyzj.cn/2021/05/17/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8634%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%87%8D%E6%8E%92/","excerpt":"","text":"前言在之前的两篇文章中，大致介绍了一些基本概念以及启动优化的思路，下面来着重介绍一个 pre-main阶段 的优化方案，即 二进制重排，这个方案最开始是由抖音的这篇文章抖音研发实践：基于二进制文件重排的解决方案 APP启动速度提升超15%提出来的。 二进制重排实现在虚拟内存部分，我们知道，当进程访问一个虚拟内存page，而对应的物理内存不存在时，会触发 缺页中断（Page Fault），因此阻塞进程，此时就需要先加载数据到物理内存，然后继续访问，这个对性能有一定影响的。如果存在大量的 缺页中断，会非常的耗时。 基于 Page fault，我们思考，APP在冷却启动过程中，会有大量的类、分类、三方等需要加载和执行，此时产生的 Page Fault 所带来的的耗时是很大的，以 实际项目 为例，我们来看下，在启动阶段的 Page Fault 的次数 CMD + i 快捷键，选择 System Trace 点击启动（启动前需要重启手机，清除缓存数据），第一个界面出来后，停掉，按照下图中操作 从图中可以看出 实际项目 发生的 Page Fault 有 1101 次，可想而知，这个是非常影响性能的。 下面，我们通过Demo查看方法在编译时期的排列顺序，在ViewController中按下列顺序定义以下几个方法 123456789101112131415161718void test1()&#123; printf(&quot;1&quot;);&#125;void test2()&#123; printf(&quot;2&quot;);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; test1();&#125;+ (void)load&#123; printf(&quot;3&quot;); test2();&#125; 在 Build Setting -&gt; write Link Map File 设置为 YES CMD + B 编译 Demo，查看 执行顺序 打印结果为 3 2 1，那么代码的 加载顺序 是什么？show in finder 在对应路径下查找 link map 文件，如下图所示： 打开.txt文件，可以发现类中 函数的加载顺序是从上到下 的，而 文件 的顺序是根据 Buid Phases -&gt; Compile Source 中的顺序加载的 从上面的 Page fault 的次数以及加载顺序，可以发现其实 导致 Page Fault 次数过多的根本原因是启动时刻需要调用的方法，处于不同的 Page Fault 导致的，因此我们的优化思路就是：将所有启动时刻需要调用的方法，排列在一起，即放在一个页中，这样就从多个 Page Fault变成了一个Page Fault，这就是 二进制重排 的核心原理，如下所示： 注意：在iOS生成环境中的APP，在发生Page Fault进行重新加载时，iOS系统还会对其做一次 签名验证，因此 iOS 生产环境的 Page Fault 比 Debug环境下所产生的耗时更多 二进制重排实践下面，我们来进行具体的实践，首先先理解几个名词 Link Map linkmap 是iOS编译过程的中间产物，记录了二进制文件的布局，需要在Xcode的 Build Settings 里面开启 Write Link Map File，Link Map 主要包含三个部分： Object Files ：生成二进制用到的link单元的路径和文件编号 Sections ：记录Mach-O每个Segment/Section的地址范围 Symbols ：按照顺序记录每个符号的地址范围 ld ld 是Xcode使用的链接器，有一个参数 order_file，我们可以通过在 Build Settings -&gt; Order Files 配置一个后缀为 order 的文件路径，在这个 order 文件中，将所需要的符号按照顺序写在里面，在项目编译时，会找找这个文件的顺序进行加载，以此来达到我们的优化 所以说，二进制重排的本质就是对启动加载的符号进行重新排列 到目前为止，原理我们基本弄清楚了，如果项目比较小，完全可以自定义一个 order 文件，将方法的顺序手动添加，但是如果项目比较大，设计到的方法特别多，此时我们如何获取启动运行的函数呢？有以下几种思路： hook objc_msgsSend：我们知道，函数的本质就是发送消息，在底层都会来到 objc_msgSend，但是由于objc_msgSend的参数是可变的，需要通过 汇编 获取，对开发人员要求较高，而且也只能拿到 oc 和 swift 中 @objc 后的方法 静态扫描：扫描 mach-o 特定段和节里面所存储的符号一级函数数据 Clang插桩：即 批量hook，可以实现 100%符号覆盖，即完全获取 swift、oc、block函数 自定义 order 文件，改变执行顺序 cd 到 Demo 根目录，新建 order文件 12zhangjian@zhangjiandeMBP ~ % cd /Users/zhangjian/Desktop/Demo zhangjian@zhangjiandeMBP Demo % touch zj.order order 文件中书写如下内容 在 build setting 搜索 order file 将根目录下的order文件路径填入：./zj.order cmd + b 重新编译，没有报错，说明有一个符号没有找不到会自动或略掉，继续查看 link map 文件 由上图可知，main变成第一位、viewDidLoad变成第二位、test1变成第三位，这就是二进制重排 Clang 插桩 llvm 内置了一个简单的代码覆盖率检测（SanitizerCoverage），它在函数级、基本块级和边缘级插入对用户定义函数的调用，我们这里的批量hook，就需要借助于 SanitizerCoverage 关于clang的插桩覆盖的官方文档如下：clang自带代码覆盖工具 文档中有详细概述，以及简短Demo演示 【第一步：配置】开启 SanitizerCoverage OC项目，需要在：Build Settings 里面的 Other C Flags 中添加 -fsanitize-coverage=trace-pc-guard 此时 CMD + B 编译，会报两个符号错误，说明添加了上面就会调用下面的两个符号： __sanitizer_cov_trace_pc_guard_init 和 __sanitizer_cov_trace_pc_guard 【第二步：重写方法】 将官方文档中的两个方法拷贝到 TraceDemo 项目中，如下图所示并运行，会报错找不 到 __sanitizer_symbolize_pc，我们将其注释，再次运行，成功 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#import &quot;ViewController.h&quot;// trace-pc-guard-cb.cc#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;sanitizer/coverage_interface.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view.&#125;void test1()&#123; &#125;void (^block1)(void) = ^&#123; &#125;;void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) &#123; static uint64_t N; // Counter for the guards. if (start == stop || *start) return; // Initialize only once. printf(&quot;INIT: %p %p\\n&quot;, start, stop); for (uint32_t *x = start; x &lt; stop; x++) *x = ++N; // Guards should start from 1.&#125;void __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123; // 将load方法过滤掉了，所以需要注释掉 if (!*guard) return; // 获取PC /* - PC 当前函数返回上一个调用的地址 - 0 当前这个函数地址，即当前函数的返回地址 - 1 当前函数调用者的地址，即上一个函数的返回地址 */ void *PC = __builtin_return_address(0); char PcDescr[1024]; // 再次运行这个符号找不到，找不到我就不调用了吗，删掉 // __sanitizer_symbolize_pc(PC, &quot;%p %F %L&quot;, PcDescr, sizeof(PcDescr)); printf(&quot;guard: %p %x PC %s\\n&quot;, guard, *guard, PcDescr);&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; test1(); block1();&#125; __sanitizer_cov_trace_pc_guard_init 方法 由上面运行结果可知，start &#x3D; 0x10204d3a0，stop &#x3D; 0x10204d3d8,那么这个是什么意思呢？ 参数1 start 是一个指针，指向无符号intl类型，4个字节，相当于一个数组的 起始位置，即符号的起始位置（是从高位往低位读） 参数2 stop ，由于数据的地址是往下读的（即 从高往低读，所以此时获取的地址并不是stop真正的地址，而是标记的最后的地址，读取stop时，由于stop占了4个字节，stop 真实地址 &#x3D; stop打印的地址-0x4） stop 内存地址中存储的值表示什么？在增加一个 方法/block/属性 后，发现其值也会增加对应的数，例如增加一个 touchesBegan方法，运行并打印得到 INIT: 0x104f0d3a8 0x104f0d3e4，重新查看 start 和 stop 的值： 由此可见 增加一个方法 对应 stop值就增加一个 【第三步：通过返回地址拿到符号】 __sanitizer_cov_trace_pc_guard 方法，主要是捕获所有的启动时刻的符号，将所有符号入队 参数 guard 是一个 哨兵，告诉我们是 第几个被调用的 引入库 #import &lt;dlfcn.h&gt; ，并点击屏幕可以通过返回地址拿到符号 123456789101112131415void __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123; if (!*guard) return; // 当前返回上一个调用的地址 void *PC = __builtin_return_address(0); // 通过返回地址PC，获取符号 Dl_info info; dladdr(PC, &amp;info); printf(&quot;frame:%s \\nfbase:%p \\nsname:%s \\nsaddr:%p\\n\\n&quot;,info.dli_fname,info.dli_fbase,info.dli_sname,info.dli_saddr); char PcDescr[1024]; // 再次运行这个符号找不到，找不到我就不调用了吗，删掉 // y__sanitizer_symbolize_pc(PC, &quot;%p %F %L&quot;, PcDescr, sizeof(PcDescr)); // printf(&quot;guard: %p %x PC %s\\n&quot;, guard, *guard, PcDescr);&#125; 查看打印结果 123456789101112131415161718// 文件的内存地址frame:/private/var/containers/Bundle/Application/A9B590E7-FC2A-4C54-85C1-FFFE55ACE448/TraceDemo.app/TraceDemo // 文件内存地址fbase:0x10251c000 // 符号名称sname:-[ViewController touchesBegan:withEvent:] // 起始位置地址saddr:0x102521b78frame:/private/var/containers/Bundle/Application/A9B590E7-FC2A-4C54-85C1-FFFE55ACE448/TraceDemo.app/TraceDemo fbase:0x10251c000 sname:test1 saddr:0x1025219e0frame:/private/var/containers/Bundle/Application/A9B590E7-FC2A-4C54-85C1-FFFE55ACE448/TraceDemo.app/TraceDemo fbase:0x10251c000 sname:block1_block_invoke saddr:0x1025219fc 【第四步：创建队列保存符号】 引入头文件 #import &lt;OSAtomic.h&gt;，符号的存储需要借助于链表，所以需要定义链表节点 ZJNode 通过 OSQueueHead 创建原子队列，其目的是保证线程安全 通过 OSAtomicEnqueue 方法将 node 入队，通过链表 next 指针可以访问下一个符号 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 原子队列-线程安全static OSQueueHead symbolList = OS_ATOMIC_QUEUE_INIT;// 定义符号结构体，以链表的形式typedef struct&#123; // 指针8个字节 void *pc; void *next;&#125;ZJNode;void __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123; // 将load方法过滤掉了，所以需要注释掉 if (!*guard) return; // 当前返回上一个调用的地址 void *PC = __builtin_return_address(0); // 创建结构体 ZJNode * node = malloc(sizeof(ZJNode)); *node = (ZJNode)&#123;PC,NULL&#125;; // 加入结构体 // 符号的访问不是通过下标访问，是通过链表的next指针，所以需要借用offsetof（结构体类型，下一个的地址即next） OSAtomicEnqueue(&amp;symbolList, node, offsetof(ZJNode, next)); // 通过返回地址PC，获取符号 Dl_info info; dladdr(PC, &amp;info); // printf(&quot;frame:%s \\nfbase:%p \\nsname:%s \\nsaddr:%p\\n\\n&quot;,info.dli_fname,info.dli_fbase,info.dli_sname,info.dli_saddr); char PcDescr[1024]; // 再次运行这个符号找不到，找不到我就不调用了吗，删掉 // y__sanitizer_symbolize_pc(PC, &quot;%p %F %L&quot;, PcDescr, sizeof(PcDescr)); // printf(&quot;guard: %p %x PC %s\\n&quot;, guard, *guard, PcDescr);&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; while (YES) &#123; // 一次循环！也会被HOOK一次 ZJNode * node = OSAtomicDequeue(&amp;symbolList, offsetof(ZJNode, next)); if (node == NULL) &#123; break; &#125; Dl_info info = &#123;0&#125;; dladdr(node-&gt;pc, &amp;info); printf(&quot;%s \\n&quot;,info.dli_sname); &#125;&#125; 【第五步：解决死循环问题】 当我们重新运行，点击屏幕，会发现一直重新打印，出现死循环 touchesBegan 我们打开汇编调式，发现有 3 个 __sanitizer_cov_trace_pc_guard 调用 第一次 bl 是 touchBegin；第二次是因为 while 循环，即只要是 跳转，就会被 hook，即有 bl&#x2F;b 的指令，就会被 hook；第三次就 printf 解决方式：将 Build Setting 中的 Other C Flags 的 -fsanitize-coverage=trace-pc-guard 改成 -fsanitize-coverage=func,trace-pc-guard，再次运行，看下面的结果显示已经没有死循环了 由上面的结果可知，还有几个问题需要解决：重复、顺序是反的，并且没有load 【第六步：生成数组去重、取反】 添加 + load 方法（需要注释掉if (!*guard) return;这句代码）、调用test、block方法，重新点击屏幕并查看结果 1234567891011121314151617+ (void)load&#123; &#125;- (void)viewDidLoad &#123; [super viewDidLoad]; test();&#125;void test()&#123; block();&#125;void (^block)(void) = ^&#123; &#125;; 查看打印结果 取反、去重 1234567891011121314151617181920212223242526272829303132333435363738- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // 定义数组 NSMutableArray&lt;NSString *&gt; * symbolNames = [NSMutableArray array]; while (YES) &#123; ZJNode * node = OSAtomicDequeue(&amp;symbolList, offsetof(ZJNode, next)); if (node == NULL) &#123; break; &#125; Dl_info info = &#123;0&#125;; dladdr(node-&gt;pc, &amp;info);// printf(&quot;%s \\n&quot;,info.dli_sname); // 转成字符串 NSString * name = @(info.dli_sname); if ([name hasPrefix:@&quot;+[&quot;] || [name hasPrefix:@&quot;-[&quot;]) &#123; // 如果是oc方法名称直接存 [symbolNames addObject:name]; continue; &#125; // 如果不是oc直接加个_存 [symbolNames addObject:[@&quot;_&quot; stringByAppendingString:name]]; &#125; // 反向遍历数组 symbolNames = (NSMutableArray&lt;NSString *&gt; *)[[symbolNames reverseObjectEnumerator] allObjects]; // 去重 NSEnumerator * enumerator = [symbolNames reverseObjectEnumerator]; NSMutableArray * funcs = [NSMutableArray arrayWithCapacity:symbolNames.count]; NSString * name; while (name = [enumerator nextObject])&#123; // 数组中不包含name if (![funcs containsObject:name]) &#123; [funcs addObject:name]; &#125; &#125; NSLog(@&quot;%@&quot;,funcs);&#125; 重新运行，查看打印结果 【第七步：生成order文件】 数组转成字符串 12// 数组转成字符串 NSString * funcStr = [symbolNames componentsJoinedByString:@&quot;\\n&quot;]; 字符串写入文件 123456// 字符串写入文件 // 文件路径 NSString * filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;zj.order&quot;]; // 文件内容 NSData * fileContents = [funcStr dataUsingEncoding:NSUTF8StringEncoding]; [[NSFileManager defaultManager] createFileAtPath:filePath contents:fileContents attributes:nil]; 【第八步：找到order文件，并配置order文件】 CMD + shift + 2 -&gt; Devices -&gt; TraceDemo -&gt; Download Container 将文件下载到桌面 -&gt; 显示包内容 -&gt; tmp -&gt; 找到 zj.order 配置 zj.order 到项目中，首先 link map 设值为 YES，配置前： 将 zj.order放在根目录，配置 order file 为 ./zj.order ，配置后： 此时发现配置后的执行顺序和配置前的执行顺序有明显的区别，此时此时 二进制重排成功。 补充 如果是Swift项目，还需要额外在 Other Swift Flags 中加入 -sanitize-coverage=func 和 -sanitize=undefined OC 和 swift 混编 OC 中引入头文件 按照上面的进行配置并查看 zj.order","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理33：启动优化（二）优化建议","slug":"OC进阶/OC底层原理33：启动优化（二）优化建议","date":"2021-05-11T07:19:40.000Z","updated":"2023-02-28T02:20:54.178Z","comments":true,"path":"2021/05/11/OC进阶/OC底层原理33：启动优化（二）优化建议/","link":"","permalink":"https://www.bboyzj.cn/2021/05/11/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8633%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/","excerpt":"","text":"冷启动和热启动启动的过程一般是指 从用户点击APP图标 到 进入到APP页面 的过程，一般在iOS开发中分为 冷启动 和 热启动 冷启动：用户将 设备重启 或者是 手动kill掉APP进程，又或者是 APP长时间未打开过，当用户点击启动APP图标的过程，这时需要创建一个新的 进程 分配给APP，并且内存中 不包含任何数据，必须从磁盘中载入数据到内存中的过程。 热启动：用户在使用APP过程中，按下 Home键，APP不会立即被kill掉，而是存活一段时间，这段时间里用户再打开APP，此时APP还在退到后台前的状态，APP进程还在系统中，无需开启新的进程，APP也不会重新加载数据到内存中的过程。 启动优化概念WWDC 2016 中首次出现了APP启动优化的话题，其中提到： App启动最佳速度是400ms以内 ，因为从点击App图标启动，然后 Launch Screen 出现再消失的时间就是400ms。 App启动最慢不得大于20s ，否则进程会被系统杀死 我们这里所说的启动优化，一般是指 冷启动 情况下的启动优化，是指用户唤起App开始到AppDelegate 中的 didFinishLaunchingWithOptions 方法执行完毕为止，并以 main() 函数为分界点，分为 pre-main 和 main() 两个阶段： pre-main 阶段：是指从用户唤起App到 main() 函数执行之前的过程 main() 阶段：是指 main() 函数开始执行到 didFinishLaunchingWithOptions 方法执行结束的过程 所以， pre-main() + main() 的过程就是从用户点击App图标到用户能看到主界面的过程，即需要优化的部分。 pre-main()启动优化我们在前面 OC底层原理15：dyld源码分析 中，已经了解了dyld的加载流程，pre-main() 阶段的 启动时间 就是 dyld加载过程的时间 针对 pre-main() 阶段的启动时间，苹果提供了APP启动时间检测方法，在 Product -&gt; Scheme -&gt; Edit Scheme -&gt; Environment Variables 点击 + 号添加环境变量 DYLD_PRINT_STATISTICS 设为 1，如下图： 然后运行，以下是 手机型号iPhone11 14.4.2 启动的我目前正在开发的电商项目的pre-main()时间： 如果想要更加详细的信息，就设置 DYLD_PRINT_STATISTICS_DETAILS 为 1，得到以下信息： 说明pre-main 阶段总共用时 1.3s dylib loading time (动态库耗时)：主要是加载动态库，用时 336.24ms rebase/binding time (偏移修正&#x2F;符号绑定耗时)，耗时 61.26ms rebase（偏移修正）：任何一个App生成的二进制文件，在二进制文件内部所有的方法、函数调用，都有一个地址，这个地址是在 当前二进制文件中的偏移地址。一旦在运行时刻（即运行到内存中），每次系统都会 随机分配一个ASLR(Address Space Layout Randomization，赋值空间布局随机化)地址值（是一个安全机制，会分配一个随机的数值，插入在二进制文件的开头），例如，二进制文件中有一个test方法，偏移值是 0x001，而随机分配的 ASLR 是 0x1000，如果想访问test方法，其内存地址（即真是地址）变为 ASLR+偏移值 = 运行时确定的内存地址（即0x1000 + 0x0001 = 0x1001） binding（绑定）：例如 NSLog方法，在编译时期 生成的 mach-o文件中，会创建一个符号 !NSLog（目前指向一个随机的地址），然后在运行时（从磁盘加载到内存中，是一个镜像文件），会将真正的地址给符号（即在内存中将地址与符号进行绑定，是 dyld 做的，也称为 动态库符号绑定），一句话概括：绑定就是给符号赋值的过程 Objc setup time（OC类注册的耗时）：OC 类越多，越耗时 initializer time ：（执行load和构造函数的耗时） 针对这几部，有以下几点优化建议： 尽量 少用外部动态库，苹果官方建议自定义的动态库最好 不要超过6个，如果超过6个，需要 合并 动态库 减少 OC 类，因为类越多，越耗时 将不必须在 +load 方法中做的事情延迟到 +initialize 中，尽量不要用 C++ 虚函数 如果是Swift，尽量使用 struct main 函数阶段的优化在 main 函数之后的 didFinishLaunching 方法中，主要是执行了各种业务，有很多并不是必须在这里执行的，这种业务我们可以采取 延迟加载，防止影响启动时间 在 didFinishLaunching 中的业务主要分为三个阶段 【第一类】初始化第三方sdk 【第二类】App运行环境配置 【第三类】自己工具类的初始化等 main函数阶段的优化建议主要有以下几点： 减少启动初始化的流程，能懒加载的懒加载，能延迟的延迟，能放后台初始化的放后台，尽量少占用主线程的启动时间 优化代码逻辑，去除非必须的代码逻辑，减少每个流程的消耗时间 启动阶段能 使用多线程 来初始化的，就使用多线程 尽量 使用纯代码 来进行UI框架的搭建，尤其是主UI框架，例如 UITabBarController，尽量避免使用Xib或者SB，相比纯代码而言，这种更耗时 删除废弃类、方法","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理32：启动优化（一）基本概念","slug":"OC进阶/OC底层原理32：启动优化（一）基本概念","date":"2021-05-04T06:44:11.000Z","updated":"2022-04-11T06:09:39.000Z","comments":true,"path":"2021/05/04/OC进阶/OC底层原理32：启动优化（一）基本概念/","link":"","permalink":"https://www.bboyzj.cn/2021/05/04/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8632%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"前言早期的 数据访问 是直接通过 物理地址 访问 物理内存，而物理内存是有 固定大小的，这种方式有以下两个问题： 1.内存不够用 2.内存数据的安全问题 内存不够用的解决方案：虚拟内存针对问题1，我们在 进程和物理内存 之间增加一个 中间层，这个中间层就是所谓的 虚拟内存，主要用于解决当多个进程同时存在时，对物理内存的管理，提高了CPU的利用率，使多个进程可以同时、按需加载，所以虚拟内存其本质就是 一张虚拟地址和物理地址对应关系的映射表 每个进程都有一个独立的 虚拟内存，其地址都是 从0开始，到最后结束，大小是 4G固定的，每个虚拟内存又划分为一个一个的 页，所有页放在一起组成 页表，统称 虚拟内存分页管理，页的大小在 iOS中是16K，Linux、MacOS等是4K，每次加载都是以页为单位加载的，进程间是无法互相访问的，保证了进程间数据的安全性。 一个进程中，只有部分功能是活跃的，所以只需要 将进程中活跃的部分放入物理内存，避免物理内存的浪费 当 CPU 需要 访问数据 时，首先是访问虚拟内存，然后通过虚拟内存地址寻址，这个虚拟地址在被送到内存条之前先转换为物理地址，这个转换的过程叫 地址翻译（需要CPU的硬件MMU和操作系统配合），即可以理解为在 虚拟地址和物理地址对应表 中找到对应的 物理地址，然后对相应的物理地址进行访问 如果在访问时，虚拟地址的内容未加载到物理内存，会发生缺页异常（pagefault），将当前进程阻塞掉，此时操作系统需要先将数据载入到物理内存中，这个过程很快用户感知不到（每页16K），然后再寻址，进行读取。这样就避免了内存浪费。 如果在访问时，物理内存满了，操作系统会将 新数据将旧数据覆盖 如下图所示，虚拟内存与物理内存间的关系： 内存数据安全问题的解决方案：ASLR技术在上面解释的虚拟内存中，我们提到了虚拟内存的起始地址与大小都是固定的，这意味着，当我们访问时，其数据的地址也是固定的，这会导致我们的数据非常容易被破解，为了解决这个问题，所以苹果为了解决这个问题，在iOS4.3开始引入了 ASLR技术。 ASLR 的概念：（Address Space Layout Randomization）地址空间配置随机加载，是一种 针对缓冲区溢出 的 安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。 其目的通过 利用随机方式配置数据地址空间，使某些敏感数据（例如App登录注册、支付相关代码）配置到一个恶意程序无法事先获知的地址，令攻击者难以进行攻击 由于ASLR的存在，导致可执行文件和动态链接库在虚拟内存中的 记载地址每次启动都不固定 ，所以需要在编译时来修复镜像中的资源指针，来指向正确的地址，即 正确的内存地址 = ASLR地址 + 偏移值 可执行文件不同的操作系统，其可执行文件的格式也不同，系统内核 将 可执行文件 读取到 内存，然后根据可执行文件的 头签名（magic魔数）判断二进制文件的格式。 可执行文件 魔数 用途 PE32&#x2F;PE32+ MZ Windows的可执行文件 ELF \\x7FFLF Linux和大部分UNIX的可执行文件和库文件 脚本 #! 主要用于shell脚本，也有一些解释器脚本使用这个格式，这是一种特殊的二进制文件格式，#!后面指向真正的可执行文件（比如python），而脚本其他内容，都被当做输入传递给这个命令 通用二进制格式（胖二进制格式） Oxcafebabe(小端) 包含多种架构支持的Mach-O格式，iOS和OS X支持的格式 Mach-O 0xfeedface(32位) 0xfeedfacf(64位) iOS和OS X支持的格式 其中 PE、ELF、Mach-O 这三种可执行文件格式都是 COFF(Command file format)格式的变种，COFF的主要贡献是目标文件里面 引入了 段 的机制，不同的目标文件可以拥有不同数量和不同类型的 段、 通用二进制文件因为不同的CPU平台支持的指令不同，比如 arm64 和 x86，苹果中的通用二进制格式就是 将多种架构的Mach-O文件打包在一起，然后系统根据自己的CPU平台，选择合适的 Mach-O，所以 通用二进制格式又被称为 胖二进制格式，如下图所示： 通用二进制格式的定义在 &lt;Mach-O/fat.h&gt;中，可以下载xnu，然后根据 xnu -&gt;EXTERNAL_HEADERS -&gt;mach-o中找到该文件，通用二进制文件开始的 Fat Header 是 fat_header 结构体，而 Fat Archs 是表示通用二进制文件中有多少个 Mach-O，单个 Mach-O 的描述是通过 fat_arch 结构体。两个结构体的定义如下： 123456789101112131415161718192021/* - magic：可以让系统内核读取该文件时知道是通用二进制文件 - nfat_arch：表明下面有多个fat_arch结构体，即通用二进制文件包含多少个Mach-O */struct fat_header &#123; uint32_t magic; /* FAT_MAGIC */ uint32_t nfat_arch; /* number of structs that follow */&#125;;/* fat_arch是描述Mach-O - cputype 和 cpusubtype：说明Mach-O适用的平台 - offset（偏移）、size（大小）、align（页对齐）描述了Mach-O二进制位于通用二进制文件的位置 */struct fat_arch &#123; cpu_type_t cputype; /* cpu specifier (int) */ cpu_subtype_t cpusubtype; /* machine specifier (int) */ uint32_t offset; /* file offset to this object file */ uint32_t size; /* size of this object file */ uint32_t align; /* alignment as a power of 2 */&#125;; 所以，综上所述 通用二进制文件是苹果公司提出的一种新的二进制文件的存储结构，可以 同时存储多种架构的二进制指令，使CPU在读取该二进制文件时可以自动检测并选用合适的架构，以最理想的方式进行读取。 由于通用二进制文件会同时存储多种架构，所以比单一架构的二进制文件大很多，会占用大量的磁盘空间，但由于系统会自动选择最合适的，不相关的架构代码不会占用内存空间，且执行效率高了 还可以通过指令来进行Mach-O的合并与拆分 查看当前Mach-O的架构：lipo -info MachO文件 合并：lipo -create MachO1 MachO2 -output 输出文件路径 拆分：lipo MachO文件 –thin 架构 –output 输出文件路径 Mach-O文件Mach-O文件是Mach Object文件格式的缩写，它是用于可执行文件、动态库、目标代码的文件格式。作为a.out格式的替代，Mach-O格式提供了更强的扩展性，以及更快的符号表信息访问速度 熟悉Mach-O文件格式，有助于更好的理解苹果底层的运行机制，更好的掌握dyld加载Mach-O的步骤。 查看Mach-O文件 如果想要查看具体的 Mach-O 文件信息，可以通过以下 两种 方式，推荐 使用 第二种 方式，更直观： 【方式一】otool终端命令：otool -l Mach-O文件名 【方式二】MachOView 工具（推荐）：将Mach-O可执行文件拖动到MachOView工具打开： Mach-O文件格式对于OS X 和 iOS来说，Mach-O是其可执行文件的格式，主要包括以下几种文件类型 Excutable：可执行文件 Dylib：动态链接库 Bundle：无法被链接的动态库，只能在运行时使用dlopen加载 Image：指的是Excutable、Dylib和Bundle的一种 Framework：包含Dylib、资源文件和头文件的集合 下面图示是Mach-O镜像文件格式： 以上是Mach-O文件的格式，一个完成的Mach-O文件主要分为三大部分： Header Mach-O头部：主要是Mach-O的cpu架构，文件类型以及加载命令等信息 Load Commands 加载命令：描述了文件中数据的具体组织结构，不同的数据类型使用不同的加载命令表示 Data 数据：数据中的每个段（segment）的数据都保存在这里，段的概念与ELF文件中段的概念类似。每个段都有一个或多个部分，它们放置了具体的数据与代码，主要包含代码，数据，例如符号表，动态符号表等等 HeaderMach-O的Header包含了整个Mach-O文件的关键信息，使得CPU能快速知道Mac-O的基本信息，其在Mach.h（路径同前文的fat.h一致）针对32位和64位架构的cpu，分别使用了mach_header和mach_header_64结构体来描述Mach-O头部。mach_header是连接器加载时最先读取的内容，决定了一些基础架构、系统类型、指令条数等信息，这里查看64位架构的mach_header_64结构体定义，相比于32位架构的mach_header，只是多了一个reserved保留字段 123456789101112131415161718192021/* - magic：0xfeedface(32位) 0xfeedfacf(64位)，系统内核用来判断是否是mach-o格式 - cputype：CPU类型，比如ARM - cpusubtype：CPU的具体类型，例如arm64、armv7 - filetype：由于可执行文件、目标文件、静态库和动态库等都是mach-o格式，所以需要filetype来说明mach-o文件是属于哪种文件 - ncmds：sizeofcmds：LoadCommands加载命令的条数（加载命令紧跟header之后） - sizeofcmds：LoadCommands加载命令的大小 - flags：标志位标识二进制文件支持的功能，主要是和系统加载、链接有关 - reserved：保留字段 */struct mach_header_64 &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */&#125;; 其中filetype主要记录Mach-O的文件类型，常用的有以下几种: 12345#define MH_OBJECT 0x1 /* 目标文件*/#define MH_EXECUTE 0x2 /* 可执行文件*/#define MH_DYLIB 0x6 /* 动态库*/#define MH_DYLINKER 0x7 /* 动态链接器*/#define MH_DSYM 0xa /* 存储二进制文件符号信息，用于debug分析*/ 相对应的，Header在MachOView中的展示如下: Load Commands在Mach-O文件中，Load Commands主要是用于 加载指令，其大小和数目在Header中已经被提供，其在Mach.h中的定义如下: 123456789/* load_command用于加载指令 - cmd 加载命令的类型 - cmdsize 加载命令的大小 */struct load_command &#123; uint32_t cmd; /* type of load command */ uint32_t cmdsize; /* total size of command in bytes */&#125;; 我们在MachOView中查看Load Commands，其中记录了很多信息，例如动态链接器的位置、程序的入口、依赖库的信息、代码的位置、符号表的位置等等，如下所示: 其中LC_SEGMENT_64的类型segment_command_64定义如下： 12345678910111213141516171819202122232425262728293031/* segment_command 段加载命令 - cmd：表示加载命令类型， - cmdsize：表示加载命令大小（还包括了紧跟其后的nsects个section的大小） - segname：16个字节的段名字 - vmaddr：段的虚拟内存起始地址 - vmsize：段的虚拟内存大小 - fileoff：段在文件中的偏移量 - filesize：段在文件中的大小 - maxprot：段页面所需要的最高内存保护（4 = r，2 = w，1 = x） - initprot：段页面初始的内存保护 - nsects：段中section数量 - flags：其他杂项标志位 - 从fileoff（偏移）处，取filesize字节的二进制数据，放到内存的vmaddr处的vmsize字节。（fileoff处到filesize字节的二进制数据，就是“段”） - 每一个段的权限相同（或者说，编译时候，编译器把相同权限的数据放在一起，成为段），其权限根据initprot初始化。initprot指定了如何通过读/写/执行位初始化页面的保护级别 - 段的保护设置可以动态改变，但是不能超过maxprot中指定的值（在iOS中，+x和+w是互斥的） */struct segment_command_64 &#123; /* for 64-bit architectures */ uint32_t cmd; /* LC_SEGMENT_64 */ uint32_t cmdsize; /* includes sizeof section_64 structs */ char segname[16]; /* segment name */ uint64_t vmaddr; /* memory address of this segment */ uint64_t vmsize; /* memory size of this segment */ uint64_t fileoff; /* file offset of this segment */ uint64_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */&#125;; DataLoad Commands 后就是Data区域，这个区域存储了具体的只读、可读写代码，例如方法、符号表、字符表、代码数据、连接器所需的数据（重定向、符号绑定等）。主要是存储具体的数据。其中大多数的Mach-O文件均包含以下三个段： __TEXT 代码段：只读，包括函数，和只读的字符串 __DATA 数据段：读写，包括可读写的全局变量等 __LINKEDIT： __LINKEDIT包含了方法和变量的元数据（位置，偏移量），以及代码签名等信息。 在Data区中，Section占了很大的比例，Section在Mach.h中是以结构体section_64（在arm64架构下）表示，其定义如下： 123456789101112131415161718192021222324252627282930/* Section节在MachO中集中体现在TEXT和DATA两段里. - sectname：当前section的名称 - segname：section所在的segment名称 - addr：内存中起始位置 - size：section大小 - offset：section的文件偏移 - align：字节大小对齐 - reloff：重定位入口的文件偏移 - nreloc：重定位入口数量 - flags：标志，section的类型和属性 - reserved1：保留（用于偏移量或索引） - reserved2：保留（用于count或sizeof） - reserved3：保留 */struct section_64 &#123; /* for 64-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint64_t addr; /* memory address of this section */ uint64_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */ uint32_t reserved3; /* reserved */&#125;; Section在MachOView中可以看出，主要集中体现在TEXT和DATA两段里，如下所示： 其中常见的section，主要有以下一些： 所以，综上所述，Mach-O的格式如下：","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理31：LLVM编译流程&Cland插件开发","slug":"OC进阶/OC底层原理31：LLVM编译流程-Cland插件开发","date":"2021-04-29T06:43:46.000Z","updated":"2022-03-08T03:56:25.000Z","comments":true,"path":"2021/04/29/OC进阶/OC底层原理31：LLVM编译流程-Cland插件开发/","link":"","permalink":"https://www.bboyzj.cn/2021/04/29/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8631%EF%BC%9ALLVM%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B-Cland%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/","excerpt":"","text":"","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理30：Block底层原理","slug":"OC进阶/OC底层原理30：Block底层原理","date":"2021-04-22T06:46:32.000Z","updated":"2022-11-07T01:13:07.000Z","comments":true,"path":"2021/04/22/OC进阶/OC底层原理30：Block底层原理/","link":"","permalink":"https://www.bboyzj.cn/2021/04/22/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8630%EF%BC%9ABlock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","excerpt":"","text":"Block类型block 主要有三种类型： 全局区、堆区、栈区 __NSGlobalBlock__ ：全局block，存储在 全局区 123void(^block)(void) = ^&#123; NSLog(@&quot;ZJ&quot;);&#125;; 此时的block无参数，也无返回值，属于全局block，如下图所示： __NSMallocBlock__ ：堆区block，因为block即是 函数 ，也是 对象 1234567- (void)mallocBlock&#123; int a = 10; void(^ block)(void) = ^&#123; NSLog(@&quot;ZJ - %d&quot;,a); &#125;; NSLog(@&quot;%@&quot;,block);&#125; 此时的block会访问外部变量，即 底层拷贝a ，所以是 堆区block 12021-08-02 11:11:56.986272+0800 001---Block深入浅出[1126:696422] &lt;__NSMallocBlock__: 0x2800e3c00&gt; __NSStackBlock__ ：block本身默认是 栈block 123456789101112// 栈block- (void)stackBlock&#123; __block int a = 10; void(^block)(void) = ^&#123; a = 20; NSLog(@&quot;ZJ - %d&quot;,a); &#125;; NSLog(@&quot;%@&quot;,^&#123; a = 20; NSLog(@&quot;ZJ - %d&quot;,a); &#125;);&#125; 【小知识点】：当block内部需要修改或访问外部变量a时，外部变量需要额外用 __block 修饰，否则修改不了 我们来看一下结果: 12021-08-02 11:15:47.243001+0800 001---Block深入浅出[1131:698266] &lt;__NSMallocBlock__: 0x28037a700&gt; 为什么？居然还是 __NSMallocBlock__ ，堆区？答：因为在 ARC 环境下，编译器自动帮我们加了 copy 操作。在 局部变量a 在没有处理（即没有 拷贝 之前）是 栈区block，处理之后（即 拷贝 之后）是 堆区block，目前的栈区block越来越少了。 当我们关掉ARC如下： 再来打印一下结果： 【总结】 block直接存储在 全局区 如果 block访问外界变量 ，并进行block相应拷贝，即 copy 在 ARC 环境下，存储在堆区 在 非ARC 环境下，存储在栈区 Block变量捕获为了保证Block内部能够正常访问外部变量，block有个自动捕获外部变量的机制 1、auto 类型局部变量：局部变量截获 是值截获。 例子： 1234567NSInteger num = 3;NSInteger(^block)(NSInteger) = ^NSInteger(NSInteger n)&#123; // num = 4; // 编译器报错 return n*num;&#125;;num = 1;NSLog(@&quot;%zd&quot;,block(2)); 查看打印结果： 12这里的输出是6而不是2，原因就是对局部变量num的截获是值截获。同样，在block里如果修改变量num，也是无效的，甚至编译器会报错。 2、 static 类型局部变量：局部静态变量截获是 指针截获 例子： 1234567// 静态变量-指针捕获static int a = 10;NSInteger(^Sblock)(NSInteger) = ^NSInteger(NSInteger n)&#123; return n*a;&#125;;a = 1;NSLog(@&quot;%zd&quot;,Sblock(2)); 打印结果： 12020-08-02 00:49:30.467652+0800 OC-Block初探[15224:868821] 2 结论: 1静态局部变量截获的是指针，在外部修改为1，对block有影响 3、__block修饰的变量: __block 变量截获是 指针截获,并且生成了一个新的结构体对象 例子： 1234567// __block修饰变量-指针捕获__block NSInteger n = 3;void(^Bblock)(void) = ^&#123; NSLog(@&quot;%zd&quot;,n); // __block修饰变量&#125;;n = 4;Bblock(); 打印结果: 12020-08-02 01:01:44.760288+0800 OC-Block初探[15345:878899] 4 结论： 1__block修饰的变量也是以指针形式截获的 解释：__block 是将外部变量包装成了一个对象并将 n 存在这个对象中，实际上block外面的 n 的地址也是指向这个对象中存储的 n 的，而block底层是有一个指针指向这个对象的，所以当外部更改n时，block里面通过指针找到这个对象进而找到n，然后获取到n的值，所以n发生了变化。 4、全局变量、静态全局变量：不截获,直接取值 例子: 123456789101112NSInteger num1 = 3; // 全局变量static NSInteger num2 = 30; // 静态全局变量- (void)blockTest&#123; void(^block)(void) = ^&#123; NSLog(@&quot;%zd&quot;,num1); // 全局变量 NSLog(@&quot;%zd&quot;,num2); // 全局静态变量 &#125;; num1 = 4; num2 = 40; block();&#125; 打印结果： 122020-08-02 01:01:44.760418+0800 OC-Block初探[15345:878899] 42020-08-02 01:01:44.760514+0800 OC-Block初探[15345:878899] 40 结论： 1全局变量、静态全局变量是不截获,直接取值 5、对象：对象类型的也是一样的，值截取 例子： 12345678910111213- (void)blockTest1&#123; // 局部对象 NSMutableArray * arr = [NSMutableArray arrayWithObjects:@1,@2, nil]; void(^block)(void) = ^&#123; NSLog(@&quot;%@&quot;,arr); [arr addObject:@(4)]; NSLog(@&quot;%@&quot;,arr); &#125;; [arr addObject:@3]; arr = nil; block();&#125; 查看打印结果: 12345678910112020-08-11 10:41:59.416461+0800 OC-Block变量截获的原理[31602:1829372] ( 1, 2, 3)2020-08-11 10:41:59.416882+0800 OC-Block变量截获的原理[31602:1829372] ( 1, 2, 3, 4) 结论: 1局部对象变量也是一样，截获的是值，而不是指针，在外部将其置为nil，对block没有影响，而该对象调用方法会影响 Block循环引用 正常释放：是指A持有B的引用，当A调用dealloc方法，给B发送release信号，B收到release信号，如果此时B的retainCount（即引用计数）为0时，则调用B的dealloc方法 循坏引用：A、B互相持有，所有导致A无法调用dealloc方法给B发送release信号，而B也无法接收到release信号，所以A、B此时都无法释放 关系图如下： Block循环引用解决请问下面两段代码是否有循环引用？12345678910// 代码一self.name = @&quot;ZJ&quot;;self.block = ^&#123; NSLog(@&quot;%@&quot;,self.name);&#125;; // 代码二[UIView animateWithDuration:1 animations:^&#123; NSLog(@&quot;%@&quot;,self.name);&#125;]; 【代码一】：发生了 循环引用，因为在 block 内部使用了 外部变量name，导致 block持有了self，而 self 原本是持有 block 的，所以导致 self和block的相互持有，即 self -&gt; name -&gt; block -&gt; self。 【代码二】：没发生 循环引用 ，虽然使用了 外部变量name，但是 self并没有持有animation 的 block,仅仅只有 block 持有 self ，不构成互相持有，即 block -&gt; self -&gt; name。 解决循环引用常见的几种方式 【方式一】： weak-strong-dance 强弱共舞 【方式二】： __block 修饰对象（需要注意的是在block内部需要 置空 对象，而且 block必须调用） 【方式三】： 传递 对象self 作为block的参数，提供给block内部使用 【方式四】： 使用 NSProxy 1、【方式一】：weak-strong-dance 如果block内部并未嵌套block，直接使用 __weak 修饰 self 即可： 12345678typedef void(^ZJBlock)(void);...@property (nonatomic, copy) ZJBlock block;... __weak typeof(self) weakSelf = self;self.block = ^&#123; NSLog(@&quot;%@&quot;,weakSelf.name);&#125;; 此时的 weakSelf 和 self 指向同一片 内存空间，且使用 __weak不会导致self的引用计数发生变化，可以通过打印 weakSelf 和 self 的指针地址和引用计数来验证，如下所示： 运行下面的代码： 12345678910// blockNSLog(@&quot;%ld&quot;,(long)CFGetRetainCount((__bridge CFTypeRef)(self)));__weak typeof(self) weakSelf = self;NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)(self)));self.block = ^&#123; NSLog(@&quot;%@&quot;,weakSelf.name);&#125;;NSLog(@&quot;%p - %p&quot;,weakSelf,self);NSLog(@&quot;%ld&quot;,(long)CFGetRetainCount((__bridge CFTypeRef)(self.block)));NSLog(@&quot;%ld&quot;,(long)CFGetRetainCount((__bridge CFTypeRef)(self))); 得到的结果如下： 如果 block 内部嵌套 block，需要同时使用 __weak 和 __strong 12345678__weak typeof(self) weakSelf = self;self.block = ^&#123; __strong typeof(weakSelf) strongSelf = weakSelf; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;%@&quot;,strongSelf.name); &#125;);&#125;;self.block(); 其中 strongSelf 是一个 临时变量 ，在block的作用域内，即内部 block执行完 就释放 strongSelf 这种方式属于 打破self对block的强引用，依赖于 中介者模式，属于自动置为 nil，即 自动释放 2、【方式二】：__block修饰变量 这种方式同样依赖于 中介者模式，属于 手动释放，是通过 __block 修饰对象，主要是因为 __block 修饰的对象时可以改变的 12345678__block ViewController * vc = self;self.block = ^&#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;%@&quot;,vc.name); vc = nil; &#125;);&#125;;self.block(); 需要注意的是这里的 block必须调用，如果不调用block，vc就不会被置空，那么依旧是循环引用，self 和 block 都不会被释放 3、【方式三】：对象self作为参数 主要是将 对象self作为参数 ，提供给block内部使用，不会有引用计数问题： 123456self.block = ^(BlockViewController * vc) &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;%@&quot;,vc.name); &#125;);&#125;;self.block(self); 4、【方式四】：NSProxy虚拟类 oc 是只能 单继承 的语言，但是它是 基于运行时的机制，所以通过 NSProxy 来实现 伪多继承 ，填补了多继承的空白 NSProxy 和 NSObject 是同级的一个类，也可以说是一个虚拟类，只是实现了NSObject 的协议 NSProxy 其实是一个 消息重定向封装的一个抽象类，类似于一个 代理人，中间件，可以通过继承它，并重写两个方法来实现消息转发到另一个实例 12- (void)forwardInvocation:(NSInvocation *)invocation;- (nullable NSMethodSignature *)methodSignatureForSelector:(SEL)sel NS_SWIFT_UNAVAILABLE(&quot;NSInvocation and related APIs not available&quot;); 使用场景 NSProxy 的使用场景主要有两种： 实现 多继承 功能 解决了 NSTimer &amp; CADisplayLink 创建时 对self强引用 的问题，参考 YYKit 的 YYWeakProxy。 循环引用解决原来 主要是通过自定义 NSProxy 类的对象来代替 self，并使用方法实现消息转发 下面是 NSProxy 子类的实现以及使用的场景： 【场景一】：多继承 自定义一个 NSProxy 的子类 ZJProxy 1234567891011121314151617181920212223242526272829303132333435363738@interface ZJProxy : NSProxy- (id)transformObjc:(NSObject *)objc;+ (instancetype)proxyWithObjc:(id)objc;@end@interface ZJProxy ()@property(nonatomic, weak, readonly) NSObject *objc;@end@implementation ZJProxy- (id)transformObjc:(NSObject *)objc&#123; _objc = objc; return self;&#125;+ (instancetype)proxyWithObjc:(id)objc&#123; return [[self alloc] transformObjc:objc];&#125;// 1.获取target类中的sel方法的方法签名- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123; return [self.objc methodSignatureForSelector:sel];&#125;// 2. 类似于方法重定向- (void)forwardInvocation:(NSInvocation *)invocation &#123; // 判断objc是否实现了该方法 if ([self.objc respondsToSelector:invocation.selector]) &#123; // 让objc调用该方法 [invocation invokeWithTarget:self.objc]; &#125;else &#123; // 找不到该方法 [invocation doesNotRecognizeSelector:invocation.selector]; &#125;&#125;- (BOOL)respondsToSelector:(SEL)aSelector&#123; return [self.objc respondsToSelector:aSelector];&#125;@end 自定义 Cat 和 Dog 类 12345678910111213141516171819//********Cat类********@interface Cat : NSObject@end@implementation Cat- (void)eat&#123; NSLog(@&quot;猫吃鱼&quot;);&#125;@end//********Dog类********@interface Dog : NSObject@end@implementation Dog- (void)shut&#123; NSLog(@&quot;狗叫&quot;);&#125;@end 通过 ZJProxy 实现 多继承 123456789Dog * dog = [[Dog alloc] init];Cat * cat = [[Cat alloc] init];ZJProxy *proxy = [ZJProxy alloc]; [proxy transformObjc:cat];[proxy performSelector:@selector(eat)]; [proxy transformObjc:dog];[proxy performSelector:@selector(shut)]; 【场景二】：通过 ZJProxy 解决 NSTimer计时器中self强引用 问题 12self.timer = [NSTimer timerWithTimeInterval:1 target:[ZJProxy proxyWithObjc:self] selector:@selector(print) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes]; 别忘了在 dealloc 中调用 [self.timer invalidate] 【场景三】：通过 ZJProxy 解决 CADisplayLink计时器中self强引用 问题 12self.link = [CADisplayLink displayLinkWithTarget:[ZJProxy proxyWithObjc:self] selector:@selector(linkMethod:)];[self.link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes]; 同样，别忘了在 dealloc 中调用 [self.link invalidate] 总结循环引用的解决方式，从根本上来说就两种，以 self -&gt; block -&gt; self 为例： 打破 self 对 block 的强引用，可以block属性修饰符使用 weak，但是这样会导致blcok还没有创建完就释放了，所以从这里打破强引用行不通。 打破 block 对 self 的强引用，主要就是self的作用域和block的作用域的 通讯，通讯有 代理、传值、通知、传参 等几种方式，用于解决循环引用。 weak-strong-dance __block（block内对象置空，且调用block） 将对象 self 作为block的参数 通过 NSProxy 子类代替 self Block 底层本质主要是通过 clang、断点调试 等方式分析Block底层 本质 定义 block.c 文件 12345678#include &quot;stdio.h&quot;int main()&#123; void(^block)(void) = ^&#123; printf(&quot;ZJ&quot;); &#125;; return 0;&#125; 到 block.c 文件目录，通过 xcrun -sdk iphonesimulator clang -arch x86_64 -rewrite-objc block.c，将 block.c 编译成 block.app，其中block在底层被编译成了一下的形式： 1234int main()&#123; void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); return 0;&#125; 简化后： 12345// 构造函数void(*block)(void) = __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));// block调用执行block-&gt;FuncPtr(block); 相当于 block 等于 __main_block_impl_0，是一个 函数 查看__main_block_impl_0，是一个 结构体，同时可以说明 block 是一个__main_block_impl_0 类型的 对象，这也是为什么 block 能够 %@ 打印的原因 123456789101112131415161718// block代码块的结构体类型struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;// block_impl的结构体类型struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;; 【总结】：block 的 本质 是 对象、函数、结构体，由于block函数没有名称，也被称为 匿名函数 block 通过 clang 编译后的源码间的关系如下图所示：以 block 修饰的变量为例： 1、block为什么需要调用？ 在底层block的类型 __main_block_imp_0 结构体，通过其同名构造函数创建，第一个传入的block内部实现代码块，即 __main_block_func_0，用 fp 表示，然后赋值给 impl 属性，然后在 main 中进行了调用，这也是block为什么需要调用的原因。如果不调用，block内部实现的代码块将无法执行，可以总结以下两点： 函数声明：即block内部实现声明了一个函数 __main_block_func_0 执行具体的函数实现：通过调用block的FuncPstr指针，调用block 2、block是如何获取外界变量的 定义一个变量，并在block中调用 1234567int main()&#123; int a = 10; void(^block)(void) = ^&#123; printf(&quot;ZJ - %ld&quot;,a); &#125;; return 0;&#125; 底层编译后 123456789101112131415161718192021222324252627struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int a; // 编译时就自动生成了相应的变量 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; // block的isa默认是stackBlock impl.Flags = flags; impl.FuncPtr = fp; // 函数指针赋值 Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int a = __cself-&gt;a; // bound by copy 值拷贝，即 a = 10，此时的a于传入的__cself的a并不是同一个 printf(&quot;ZJ - %ld&quot;,a); &#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main()&#123; int a = 10; void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a)); return 0;&#125; __main_block_func_0 中的 a 是 值拷贝，如果此时在block内部实现中做 a++ 操作，是有问题的，会造成编译器的代码歧义，即此时的 a 是只读的 总结： block捕获外界变量时，在 内部会自动生成同一个属性来保存 __block的原理 对 a 加一个 __block，然后在block中对 a 进行 ++ 操作 12345678int main()&#123; __block int a = 10; void(^block)(void) = ^&#123; a ++; printf(&quot;ZJ - %ld&quot;,a); &#125;; return 0;&#125; 底层编译如下： main中的 a 是通过外界变量封装的 对象 __main_block_impl_0 中，将 对象a 的地址 &amp;a 给构造函数 在 __main_block_func_0 内部对a的处理是 指针拷贝，此时创建的对象a与传入对象的a 指向同一片内存空间 1234567891011121314151617181920212223242526272829303132333435363738// __block修饰的外界变量结构体struct __Block_byref_a_0 &#123; void *__isa;__Block_byref_a_0 *__forwarding; int __flags; int __size; int a;&#125;;// __block的结构体类型struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_a_0 *a; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;// block内部实现static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref 指针拷贝，此时对象a 与 __cself对象的a指向同一片地址空间 // 等同于 外界的a++ (a-&gt;__forwarding-&gt;a) ++; printf(&quot;ZJ - %ld&quot;,(a-&gt;__forwarding-&gt;a)); &#125;int main()&#123; // __Block_byref_a_0 是结构体，a 等于 结构体的赋值，即外界变量a 封装成对象 // &amp;a 是外界变量a的地址 __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 10&#125;; // _main_block_img_0中的第三个参数&amp;a，是封装对象a的地址 void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344)); return 0;&#125; 总结： 外界变量 会生成 __block_byref_a_0 结构体 结构体用来 保存原始变量的指针和值 将变量生成的 结构体对象的指针地址，传递给block，然后在block内部就可以对外界变量进行操作了 两种拷贝对比： 值拷贝：-深拷贝，只是拷贝值，且拷贝的值不可以更改，指向不同的内存空间，案列中普通变量a就是值拷贝 指针拷贝：-浅拷贝，生成的对象指向同一片内存空间，案列中经过__block修饰的变量a就是 指针拷贝 block底层的真正类型分析block源码所在位置 运行下面的代码，并开启 Always Show Disassembly反汇编 12345int a = 10;void(^block)(void) = ^&#123; NSLog(@&quot;ZJ = %d&quot;,a);&#125;;block(); 通过在block处打断点，分析运行时的block 加 objc_retainBlock 符号断点，发现会走到 _Block_copy 加 _Block_copy 符号断点，运行时在 libsystem_blocks.dylib 源码中 可以到苹果开源网站下载最新的 libcloseure-074 源码，通过查看 _Block_copy 的源码实现，发现block底层的真正类型是_Block_layout Block的真正类型查看 Block_layout 类型的定义，是一个结构体： 1234567891011121314// Block 结构体struct Block_layout &#123; // 指向表明block类型的类 void *isa; // 8字节 // 用来作标识符的，类似于isa中的位域,按bit位表示一些block的附加信息 volatile int32_t flags; // contains ref count 4字节 // 保留信息，可以理解预留位置，用于存储block内部变量信息 int32_t reserved; // 4字节 // 函数指针，指向具体的block实现的调用地址 BlockInvokeFunction invoke; // block的附加信息 struct Block_descriptor_1 *descriptor; // imported variables&#125;; isa：指向表明block类型的类 flags：标识符，按bit位表示一些block的附加信息，类似于isa中的位域，其中flags 的种类有以下几种，主要重点关注 BLOCK_HAS_COPY_DISPOSE 和 BLOCK_HAS_SIGNATURE。BLOCK_HAS_COPY_DISPOSE 决定是否有Block_descriptor_2。BLOCK_HAS_SIGNATURE 决定是否有Block_descriptor_3： 第1 位 - BLOCK_DEALLOCATING，释放标记，-般常用 BLOCK_NEEDS_FREE 做 位与 操作，一同传入 Flags ， 告知该 block 可释放。 低16位 - BLOCK_REFCOUNT_MASK，存储引用计数的值;是一个可选用参数 第24位 - BLOCK_NEEDS_FREE，低16是否有效的标志，程序根据它来决定是否增加或是减少引用计数位的 值; 第25位 - BLOCK_HAS_COPY_DISPOSE，是否拥有拷贝辅助函数(a copy helper function); 第26位 - BLOCK_IS_GC，是否拥有 block 析构函数; 第27位，标志是否有垃圾回收; 第28位 - BLOCK_IS_GLOBAL，标志是否是全局block; 第30位 - BLOCK_HAS_SIGNATURE，与 BLOCK_USE_STRET 相对，判断当前 block 是否拥有一个签名。用于 runtime 时动态调用。 123456789101112131415161718192021222324// 注释: flags 标识// Values for Block_layout-&gt;flags to describe block objectsenum &#123; // 释放标记，一般常用于BLOCK_BYREF_NEEDS_FREE做位与运算，一同传入flags，告知该block可释放 BLOCK_DEALLOCATING = (0x0001), // runtime // 存储引用引用计数的 值，是一个可选用参数 BLOCK_REFCOUNT_MASK = (0xfffe), // runtime // 低16位是否有效的标志，程序根据它来决定是否增加或者减少引用计数位的值 BLOCK_NEEDS_FREE = (1 &lt;&lt; 24), // runtime // 是否拥有拷贝辅助函数，（a copy helper function）决定block_description_2 BLOCK_HAS_COPY_DISPOSE = (1 &lt;&lt; 25), // compiler // 是否拥有block C++析构函数 BLOCK_HAS_CTOR = (1 &lt;&lt; 26), // compiler: helpers have C++ code // 标志是否有垃圾回收，OSX BLOCK_IS_GC = (1 &lt;&lt; 27), // runtime // 标志是否是全局block BLOCK_IS_GLOBAL = (1 &lt;&lt; 28), // compiler // 与BLOCK_HAS_SIGNATURE相对，判断是否当前block拥有一个签名，用于runtime时动态调用 BLOCK_USE_STRET = (1 &lt;&lt; 29), // compiler: undefined if !BLOCK_HAS_SIGNATURE // 是否有签名 BLOCK_HAS_SIGNATURE = (1 &lt;&lt; 30), // compiler // 使用有拓展，决定block_description_3 BLOCK_HAS_EXTENDED_LAYOUT=(1 &lt;&lt; 31) // compiler&#125;; reserved：保留信息，可以理解预留位置，猜测是用于存储block内部变量信息 invoke：是一个函数指针，指向block的执行代码 descriptor： block的附加信息，比如保留变量数、block的大小、进行copy或dispose的辅助函数指针。有三类： Block_descriptor_1 是必选的 Block_descriptor_2 和 Block_descriptor_3 都是可选的 12345678910111213141516171819#define BLOCK_DESCRIPTOR_1 1struct Block_descriptor_1 &#123; uintptr_t reserved;//保留信息 uintptr_t size;//block大小&#125;;#define BLOCK_DESCRIPTOR_2 1struct Block_descriptor_2 &#123; // requires BLOCK_HAS_COPY_DISPOSE BlockCopyFunction copy;//拷贝函数指针 BlockDisposeFunction dispose;&#125;;#define BLOCK_DESCRIPTOR_3 1struct Block_descriptor_3 &#123; // requires BLOCK_HAS_SIGNATURE const char *signature;//签名 const char *layout; // contents depend on BLOCK_HAS_EXTENDED_LAYOUT 布局&#125;; 以上关于 descriptor 的可以从其构造函数中体现，其中 Block_descriptor_2 和Block_descriptor_3 都是通过 Block_descriptor_1 的地址，经过内存平移得到的 1234567891011121314151617181920212223242526static struct Block_descriptor_1 * _Block_descriptor_1(struct Block_layout *aBlock)&#123; return aBlock-&gt;descriptor;//默认打印&#125;#endif// 注释:Block 的描述 : copy 和 dispose 函数static struct Block_descriptor_2 * _Block_descriptor_2(struct Block_layout *aBlock)&#123; if (! (aBlock-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE)) return NULL; uint8_t *desc = (uint8_t *)aBlock-&gt;descriptor;//descriptor_1的地址 desc += sizeof(struct Block_descriptor_1);//通过内存平移获取 return (struct Block_descriptor_2 *)desc;&#125;// 注释: Block 的描述 : 签名相关static struct Block_descriptor_3 * _Block_descriptor_3(struct Block_layout *aBlock)&#123; if (! (aBlock-&gt;flags &amp; BLOCK_HAS_SIGNATURE)) return NULL; uint8_t *desc = (uint8_t *)aBlock-&gt;descriptor; desc += sizeof(struct Block_descriptor_1); if (aBlock-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123; desc += sizeof(struct Block_descriptor_2); &#125; return (struct Block_descriptor_3 *)desc;&#125; block内存变化1、没有外部变量的 block: 打断点运行，走到 objc_retainBlock，block断点处读取寄存器 x0，此时 block 是 全局block，即 __NSGlobalBlock__： 2、增加外部变量a的block： 同上，执行到符号断点 objc_retainBlock，得到的 block 是 栈block，即__NSStackBlock： 增加 _Block_copy 符号断点并断住，直接在最后的 ret 加断点，读取 x0，发现经过 _Block_copy 之后，变成了 堆block，即 __NSMallocBlock__，主要是因为block地址发生了改变，为堆 block: 调用情况 同样也可以通过断点来验证 register read x0 读取x0，为堆block register read x9 读取x9 register read x11 ，此时是指向一片内存空间，用于存储 _block_invoke 按住 control + step into，进入 _block_invoke，可以得出是通过内存平移得到的block内部实现 前面提到的 Block_layout 的结构体源码,从源码中可以看出，有个属性 invoke，即block的执行者，是从 isa 的首地址平移 16 字节取到 invoke，然后进行调用执行的 签名 继续操作，读取 x0 寄存器,看内存布局,通过 内存平移 3*8 就可获得 Block_layout 的属性 descriptor,主要是为了查看是否有 Block_descriptor_2 和 Block_descriptor_3，其中3中有block的签名 register read x0，读取寄存器x0 po 0x00000002828a2160 ， 打印block x/8gx 0x00000002828a2160 ，即打印block内存情况 x/8gx 0x00000001008a0010 ， 查看descriptor的内存情况，其中第三个0x000000010089f395 表示签名 判断是否有 Block_descriptor_2，即flags的 BLOCK_HAS_COPY_DISPOSE（拷贝辅助函数）是否有值 p/x 1&lt;&lt;25 ，即1左移25位，其十六进制为 0x2000000 p 0x02000000 &amp; 0x00000000c1000002 ，即 BLOCK_HAS_COPY_DISPOSE &amp; flags ，等于0，表示没有 Block_descriptor_2 判断是否有 Block_descriptor_3 p/x 1&lt;&lt;30，即1左移30位 p 0x40000000 &amp; 0x00000000c1000002 ，即 BLOCK_HAS_SIGNATURE &amp; flags ，有值，说明有 Block_descriptor_3 p (char *)0x000000010089f395 – 获取 Block_descriptor_3 中的属性 signature 签名 po [NSMethodSignature signatureWithObjCTypes:&quot;v8@?0&quot;] ，即打印签名 其中签名的部分说明如下: 12345678910111213141516//无返回值return value: -------- -------- -------- -------- type encoding (v) &#x27;v&#x27; flags &#123;&#125; modifiers &#123;&#125; frame &#123;offset = 0, offset adjust = 0, size = 0, size adjust = 0&#125; memory &#123;offset = 0, size = 0&#125;argument 0: -------- -------- -------- -------- //encoding = (@),类型是 @? type encoding (@) &#x27;@?&#x27; //@是isObject ，？是isBlock，代表 isBlockObject flags &#123;isObject, isBlock&#125; modifiers &#123;&#125; frame &#123;offset = 0, offset adjust = 0, size = 8, size adjust = 0&#125; //所在偏移位置是8字节 memory &#123;offset = 0, size = 8&#125; block的签名信息类似于方法的签名信息，主要是体现block的返回值，参数以及类型等信息 block三次copy分析_Block_copy源码分析 进入 _Block_copy 源码，将 block 从栈区拷贝至堆区 如果需要释放，则直接释放 如果是 globalBlock – 不需要copy，直接返回 反之，只有两种情况：栈区block or 堆区block，由于堆区block需要申请空间，前面并没有申请空间的相关代码，所以只能是 栈区block: 通过 malloc 申请内存空间用于接收block 通过 memmove 将block拷贝至新申请的内存中 设置block对象的类型为堆区block，即 result-&gt;isa = _NSConcreteMallocBlock 12345678910111213141516171819202122232425262728293031323334353637// Copy, or bump refcount, of a block. If really copying, call the copy helper if present.// 重点提示: 这里是核心重点 block的拷贝操作: 栈Block -&gt; 堆Blockvoid *_Block_copy(const void *arg) &#123; struct Block_layout *aBlock; if (!arg) return NULL; // The following would be better done as a switch statement aBlock = (struct Block_layout *)arg;//强转为Block_layout类型对象，防止对外界造成影响 if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;//是否需要释放 // latches on high latching_incr_int(&amp;aBlock-&gt;flags); return aBlock; &#125; else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;//如果是全局block，直接返回 return aBlock; &#125; else &#123;//为栈block 或者 堆block，由于堆区需要申请内存，所以只可能是栈区 // Its a stack block. Make a copy. 它是一个堆栈块block，拷贝。 struct Block_layout *result = (struct Block_layout *)malloc(aBlock-&gt;descriptor-&gt;size);//申请空间并接收 if (!result) return NULL; //通过memmove内存拷贝，将 aBlock 拷贝至result memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first#if __has_feature(ptrauth_calls) // Resign the invoke pointer as it uses address authentication. result-&gt;invoke = aBlock-&gt;invoke;//可以直接调起invoke#endif // reset refcount result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING); // XXX not needed 告知可释放 result-&gt;flags |= BLOCK_NEEDS_FREE | 2; // logical refcount 1 _Block_call_copy_helper(result, aBlock); // Set isa last so memory analysis tools see a fully-initialized object. result-&gt;isa = _NSConcreteMallocBlock;//设置block对象类型为堆区block return result; &#125;&#125; _Block_ovject_assign分析 想要分析block的三层copy，首先需要知道外部变量的种类有哪些，其中用的最多的是 BLOCK_FIELD_IS_OBJECT 和 BLOCK_FIELD_IS_BYREF 1234567891011121314151617// 注释: Block 捕获的外界变量的种类// Runtime support functions used by compiler when generating copy/dispose helpers// Values for _Block_object_assign() and _Block_object_dispose() parametersenum &#123; // see function implementation for a more complete description of these fields and combinations //普通对象，即没有其他的引用类型 BLOCK_FIELD_IS_OBJECT = 3, // id, NSObject, __attribute__((NSObject)), block, ... //block类型作为变量 BLOCK_FIELD_IS_BLOCK = 7, // a block variable //经过__block修饰的变量 BLOCK_FIELD_IS_BYREF = 8, // the on stack structure holding the __block variable //weak 弱引用变量 BLOCK_FIELD_IS_WEAK = 16, // declared __weak, only used in byref copy helpers //返回的调用对象 - 处理block_byref内部对象内存会加的一个额外标记，配合flags一起使用 BLOCK_BYREF_CALLER = 128, // called from __block (byref) copy/dispose support routines.&#125;; 而 _Block_object_assign 是在底层编译代码中，外部变量拷贝时调用的方法就是它 进入 _Block_object_assign 源码 如果是普通对象，则交给 系统arc处理，并拷贝 对象指针，即 引用计数+1，所以外界变量不能释放 如果是 block类型 的变量，则通过 _Block_copy 操作，将block从栈区拷贝到堆区 如果是 __block修饰 的变量，调用 _Block_byref_copy 函数 进行内存拷贝以及常规处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static struct Block_byref *_Block_byref_copy(const void *arg) &#123; //强转为Block_byref结构体类型，保存一份 struct Block_byref *src = (struct Block_byref *)arg; if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == 0) &#123; // src points to stack 申请内存 struct Block_byref *copy = (struct Block_byref *)malloc(src-&gt;size); copy-&gt;isa = NULL; // byref value 4 is logical refcount of 2: one for caller, one for stack copy-&gt;flags = src-&gt;flags | BLOCK_BYREF_NEEDS_FREE | 4; // block内部持有的Block_byref 和 外界的Block_byref 所持有的对象是同一个，这也是为什么__block修饰的变量具有修改能力 // copy 和 scr 的地址指针达到了完美的同一份拷贝，目前只有持有能力 copy-&gt;forwarding = copy; // patch heap copy to point to itself src-&gt;forwarding = copy; // patch stack to point to heap copy copy-&gt;size = src-&gt;size; // 如果有copy能力 if (src-&gt;flags &amp; BLOCK_BYREF_HAS_COPY_DISPOSE) &#123; // Trust copy helper to copy everything of interest // If more than one field shows up in a byref block this is wrong XXX //Block_byref_2是结构体，__block修饰的可能是对象，对象通过byref_keep保存，在合适的时机进行调用 struct Block_byref_2 *src2 = (struct Block_byref_2 *)(src+1); struct Block_byref_2 *copy2 = (struct Block_byref_2 *)(copy+1); copy2-&gt;byref_keep = src2-&gt;byref_keep; copy2-&gt;byref_destroy = src2-&gt;byref_destroy; if (src-&gt;flags &amp; BLOCK_BYREF_LAYOUT_EXTENDED) &#123; struct Block_byref_3 *src3 = (struct Block_byref_3 *)(src2+1); struct Block_byref_3 *copy3 = (struct Block_byref_3*)(copy2+1); copy3-&gt;layout = src3-&gt;layout; &#125; // 等价于 __Block_byref_id_object_copy (*src2-&gt;byref_keep)(copy, src); &#125; else &#123; // Bitwise copy. // This copy includes Block_byref_3, if any. memmove(copy+1, src+1, src-&gt;size - sizeof(*src)); &#125; &#125; // already copied to heap else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_BYREF_NEEDS_FREE) == BLOCK_BYREF_NEEDS_FREE) &#123; latching_incr_int(&amp;src-&gt;forwarding-&gt;flags); &#125; return src-&gt;forwarding;&#125; 进入 _Block_byref_copy 源码 将传入的对象，强转为 Block_byref 结构体类型对象，保存一份 没有将外界变量拷贝到堆，需要申请内存，其进行拷贝 如果已经拷贝过了，则进行处理并返回 其中 copy 和src的 forwarding 指针都指向同一片内存，这也是为什么__block修饰的对象具有修改能力的原因 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static struct Block_byref *_Block_byref_copy(const void *arg) &#123; //强转为Block_byref结构体类型，保存一份 struct Block_byref *src = (struct Block_byref *)arg; if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == 0) &#123; // src points to stack 申请内存 struct Block_byref *copy = (struct Block_byref *)malloc(src-&gt;size); copy-&gt;isa = NULL; // byref value 4 is logical refcount of 2: one for caller, one for stack copy-&gt;flags = src-&gt;flags | BLOCK_BYREF_NEEDS_FREE | 4; //block内部持有的Block_byref 和 外界的Block_byref 所持有的对象是同一个，这也是为什么__block修饰的变量具有修改能力 //copy 和 scr 的地址指针达到了完美的同一份拷贝，目前只有持有能力 copy-&gt;forwarding = copy; // patch heap copy to point to itself src-&gt;forwarding = copy; // patch stack to point to heap copy copy-&gt;size = src-&gt;size; //如果有copy能力 if (src-&gt;flags &amp; BLOCK_BYREF_HAS_COPY_DISPOSE) &#123; // Trust copy helper to copy everything of interest // If more than one field shows up in a byref block this is wrong XXX //Block_byref_2是结构体，__block修饰的可能是对象，对象通过byref_keep保存，在合适的时机进行调用 struct Block_byref_2 *src2 = (struct Block_byref_2 *)(src+1); struct Block_byref_2 *copy2 = (struct Block_byref_2 *)(copy+1); copy2-&gt;byref_keep = src2-&gt;byref_keep; copy2-&gt;byref_destroy = src2-&gt;byref_destroy; if (src-&gt;flags &amp; BLOCK_BYREF_LAYOUT_EXTENDED) &#123; struct Block_byref_3 *src3 = (struct Block_byref_3 *)(src2+1); struct Block_byref_3 *copy3 = (struct Block_byref_3*)(copy2+1); copy3-&gt;layout = src3-&gt;layout; &#125; //等价于 __Block_byref_id_object_copy (*src2-&gt;byref_keep)(copy, src); &#125; else &#123; // Bitwise copy. // This copy includes Block_byref_3, if any. memmove(copy+1, src+1, src-&gt;size - sizeof(*src)); &#125; &#125; // already copied to heap else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_BYREF_NEEDS_FREE) == BLOCK_BYREF_NEEDS_FREE) &#123; latching_incr_int(&amp;src-&gt;forwarding-&gt;flags); &#125; return src-&gt;forwarding;&#125; 代码调试 定义一个 __block 修饰的 NSString对象： 12345678 __block NSString * zj_name = [NSString stringWithFormat:@&quot;ZJ&quot;];void (^block1)(void) = ^&#123; // block_copy zj_name = @&quot;ZJ&quot;; NSLog(@&quot;ZJ - %@&quot;,zj_name); // block 内存&#125;;block1(); xcrun编译结果如下： 编译后的 zj_name 比普通变量多了 __Block_byref_id_object_copy_131 和 __Block_byref_id_object_dispose_131 __Block_byref_zj_name_0 结构体中多了 __Block_byref_id_object_copy 和 __Block_byref_id_object_dispose 1234567891011121314151617181920212223242526272829303132//********编译后的zj_name******** __Block_byref_zj_name_0 zj_name = &#123;(void*)0, (__Block_byref_zj_name_0 *)&amp;zj_name, 33554432, sizeof(__Block_byref_zj_name_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSString * _Nonnull (*)(id, SEL, NSString * _Nonnull, ...))(void *)objc_msgSend)((id)objc_getClass(&quot;NSString&quot;), sel_registerName(&quot;stringWithFormat:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_hr_l_56yp8j4y11491njzqx6f880000gn_T_main_9f330d_mi_0)&#125;; //********__Block_byref_zj_name_0结构体********struct __Block_byref_zj_name_0 &#123; void *__isa;__Block_byref_zj_name_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); // 5*8 = 40 NSString *zj_name;&#125;; //********__Block_byref_id_object_copy_131******** //block自身拷贝（_Block_copy） -- __block bref结构体拷贝(_Block_object_assign) -- _Block_object_assign中对外部变量（存储在bref）拷贝一份到内存static void __Block_byref_id_object_copy_131(void *dst, void *src) &#123; // dst 外部捕获的变量，即结构体 - 5*8 = 40，然后就找到了zj_name(zj_name在bref初始化时就赋值了) _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);&#125; //********__Block_byref_id_object_dispose_131********static void __Block_byref_id_object_dispose_131(void *src) &#123; _Block_object_dispose(*(void * *) ((char*)src + 40), 131);&#125; 通过 libclosure-74 可编译源码断点调试，关键方法的执行顺序为：_Block_copy -&gt; _Block_byref_copy -&gt; _Block_object_assign,正好对应上述的三层copy 综上所述，block是如何取到 zj_name 的？ 通过 _Block_copy 方法，将block拷贝一份至堆区 通过 _Block_object_assign 方法正常拷贝，因为__block修饰的外界变量在底层是 Block_byref 结构体 发现外部变量还存有一个对象，从bref中取出相应对象zj_name，拷贝至block空间，才能使用（相同空间才能使用，不同则不能使用）。最后通过 内存平移 就得到了 zj_name，此时的zj_name 和 外界的zj_name是同一片内存空间（从_Block_object_assign 方法中的 *dest = object 看出） 三层copy总结 总上所述，block三层拷贝是指以下三层： 【第一层】通过 _Block_copy 实现对象的 自身拷贝，从 栈区 拷贝到 堆区 【第二层】通过 _Block_byref_copy 方法，将对象拷贝为 Block_byref 结构体类型 【第三层】通过 _Block_object_assign 方法，对 __block 修饰的 当前变量的拷贝 注：只有 __block修饰 的对象，block即copy才有三层 _Block_object_dispose分析 同一般的 retain 和 release 一样，_Block_object_dispose 其本质主要是 retain，所以对应的还有一个 release，即 _Block_object_dispose 方法，其源码实现如下，也是通过区分block种类，进行不同释放操作 123456789101112131415161718192021222324// When Blocks or Block_byrefs hold objects their destroy helper routines call this entry point// to help dispose of the contents 当Blocks或Block_byrefs持有对象时，其销毁助手例程将调用此入口点以帮助处置内容void _Block_object_dispose(const void *object, const int flags) &#123; switch (os_assumes(flags &amp; BLOCK_ALL_COPY_DISPOSE_FLAGS)) &#123; case BLOCK_FIELD_IS_BYREF | BLOCK_FIELD_IS_WEAK: case BLOCK_FIELD_IS_BYREF://__block修饰的变量，即bref类型的 // get rid of the __block data structure held in a Block _Block_byref_release(object); break; case BLOCK_FIELD_IS_BLOCK://block类型的变量 _Block_release(object) ; break; case BLOCK_FIELD_IS_OBJECT://普通对象 _Block_release_object(object); break; case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT: case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK: case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT | BLOCK_FIELD_IS_WEAK: case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK | BLOCK_FIELD_IS_WEAK: break; default: break; &#125;&#125; 进入 _Block_byref_release 源码，主要就是对象、变量的释放销毁 12345678910111213141516171819static void _Block_byref_release(const void *arg) &#123; //对象强转为Block_byref类型结构体 struct Block_byref *byref = (struct Block_byref *)arg; // dereference the forwarding pointer since the compiler isn&#x27;t doing this anymore (ever?) byref = byref-&gt;forwarding;//取消指针引用 if (byref-&gt;flags &amp; BLOCK_BYREF_NEEDS_FREE) &#123; int32_t refcount = byref-&gt;flags &amp; BLOCK_REFCOUNT_MASK; os_assert(refcount); if (latching_decr_int_should_deallocate(&amp;byref-&gt;flags)) &#123; if (byref-&gt;flags &amp; BLOCK_BYREF_HAS_COPY_DISPOSE) &#123;//是否有拷贝辅助函数 struct Block_byref_2 *byref2 = (struct Block_byref_2 *)(byref+1); (*byref2-&gt;byref_destroy)(byref);//销毁拷贝对象 &#125; free(byref);//释放 &#125; &#125;&#125; 所以，综上所述，Block的 三层copy 的流程如下图所示：","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理29：锁的原理","slug":"OC进阶/OC底层原理29：锁的原理","date":"2021-04-10T06:46:18.000Z","updated":"2022-04-08T07:28:09.000Z","comments":true,"path":"2021/04/10/OC进阶/OC底层原理29：锁的原理/","link":"","permalink":"https://www.bboyzj.cn/2021/04/10/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8629%EF%BC%9A%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"","text":"前言本文主要介绍常见的锁，以及 synchronized、NSLock、递归锁、条件锁 的底层分析 锁借鉴一张锁的性能数据对比图，如下所示 可以看出，图中锁的性能从高到底依次是：OSSPinLock(自旋锁) -&gt; dispatch_semaphone(信号量) -&gt; ptread_mutex(互斥锁) -&gt; OSSPinLock(自旋锁) -&gt; NSCondition(条件锁) -&gt; pthread_mutex(recusive 互斥锁) -&gt; NSRecursiveLock(递归锁) -&gt; NSConditionLock(条件锁) -&gt; synchronized(互斥锁) 图中大致分为以下几类： 【自旋锁】：在自旋锁中，线程会反复检查变量是否可用。由于线程这个过程中一致保持执行，所以是一种忙等待。一旦获取了自旋锁，线程 就会一直保持该锁，直到显示释放自旋锁。自旋锁避免了进程上下文的调度开销，因此对于 线程只会阻塞很短时间的场合 是 有效 的。对于iOS属性的修饰符 atomic，自带一把自旋锁 OSSpinLock atomic 【互斥锁】：互斥锁 是一种用于 多线程编程 中，防止两条线程同时对同一公共资源（例如全局变量）进行读写的机制，该目的是通过 将代码切成一个个临界区 而达成 @synchroized NSLock pthread_mutex 【条件锁】：条件锁 就是 条件变量，当进程的某些 资源要求不满足 时就 进入休眠，即锁住了，当 资源被分配到了，条件锁打开了，进程继续进行 NSCondition NSConditionLock 【递归锁】：递归锁就是 同一个线程可以加锁N次而不会引发死锁。递归锁是 特殊的互斥锁，即是 带有递归性质的互斥锁 pthread_mutex(recursive) NSRecursiveLock 【信号量】：信号量 是一种 更高级的同步机制，互斥锁 可以说是 semaphore在取值0/1时的特例，信号量可以有更多的取值空间，用来 实现更加复杂的同步，而不是单单的线程间互斥 dispatch_semaphore 【读写锁】：读写锁实际是一种 特殊的自旋锁。将对共享资源的访问分成 读者 和 写者，读者 只对共享资源 进行读访问，写者 则需要对共享资源 进行写操作，这种锁相对于自旋锁而言，能 提高并发性 一个读写锁同时只能有一个写者或者多个读者，但不能即有读者又有写者，在读写锁保持期间也是抢占失效的 如果 读写锁当前没有读者，也没有写者，那么写者 可以立刻获取 读写锁，否则它必须自旋 在那里，直到没有任何写者或读者，如果读写锁没有写者，那么读者可以 立即获取读写锁 其实 基本的锁 就包括三类：自旋锁、互斥锁、读写锁，其他的比如 条件锁、递归锁、信号量 都是 上层的封装和实现 OSSpinLock（自旋锁）自从 OSSpinLock 出现安全问题，在iOS10之后就被废弃了，自旋锁之所有不安全，是因为 获取锁后，线程会一直处于忙等待，造成了 任务的优先级反转。 其中的忙等待机制可能会造成 高优先级任务一直runing等待，占用时间片，而 低优先级的任务无法抢占时间片，会造成一直不能完成，锁未释放的情况 在 OSSpinLock 被废弃后，其替代方案是内部封装了 os_unfair_lock，而 os_unfair_lock 在加锁时会处于 休眠状态，而不是自旋锁的忙等待状态 atomic（原子锁）atomic 适用于OC中属性的修饰符，其 自带一把自旋锁，但是这个一般基本不使用，都是使用的 nonatomic 在前面的文章中，我们提及 setter 方法会根据修饰符调用不同的方法，其中最后会统一调用 reallySetProperty 方法，其中就有 atomic 和 非atomic 的操作 123456789101112131415161718static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)&#123; ... id *slot = (id*) ((char*)self + offset); ... if (!atomic) &#123; // 未加锁 oldValue = *slot; *slot = newValue; &#125; else &#123; // 加锁 spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); &#125; ...&#125; 从源码中可以看出，对于 atomic 修饰的属性，进行了 spinlock_t 加锁处理，但是在前文中提到 OSSpinLock 已经废弃了，这里的 spinlock_t 在底层是通过 os_unfair_lock 替代了 OSSpinLock 实现的加锁。同时为了 防止哈希冲突，还是用了 加盐 操作 123456using spinlock_t = mutex_tt&lt;LOCKDEBUG&gt;;class mutex_tt : nocopy_t &#123; os_unfair_lock mLock; ...&#125; getter 方法中对 atomic 的处理，同 setter 是大致相同的 123456789101112131415161718id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) &#123; if (offset == 0) &#123; return object_getClass(self); &#125; // Retain release world id *slot = (id*) ((char*)self + offset); if (!atomic) return *slot; // Atomic retain release world spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); // 加锁 id value = objc_retain(*slot); slotlock.unlock(); // 解锁 // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock. return objc_autoreleaseReturnValue(value);&#125; synchronized(互斥递归锁) 开启汇编模式，发现 @synchronized 在执行过程中，会走底层的 objc_sync_enter 和 objc_sync_exit 方法 也可以通过 clang，查看底层编译代码 通过对 objc_sync_enter 方法符号断点，查看底层所在的源码库，通过断点发现在objc源码中，即 libpbjc.A.dylib objc_sync_enter &amp; objc_sync_exit 分析 进入 objc_sync_enter 源码实现 如果obj存在，则通过 id2data 方法获取响应的 SyncData，对 threadCount、lockCount 进行 递增 操作 如果obj不存在，则调用 objc_sync_nil，通过符号断点得知，这个方法里面什么都没做，直接return了 123456789101112131415161718int objc_sync_enter(id obj)&#123; int result = OBJC_SYNC_SUCCESS; if (obj) &#123; // 传入不为nil SyncData* data = id2data(obj, ACQUIRE); // 重点 ASSERT(data); data-&gt;mutex.lock(); // 加锁 &#125; else &#123; // 传入nil // @synchronized(nil) does nothing if (DebugNilSync) &#123; _objc_inform(&quot;NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug&quot;); &#125; objc_sync_nil(); &#125; return result;&#125; 进入 objc_sync_exit 源码实现 如果obj存在，则调用 id2data 方法获取对应的SyncData，对 threadCount、lockCount 进行 递减 操作 如果obj不存在，什么也不做 123456789101112131415161718192021// End synchronizing on &#x27;obj&#x27;. 结束对“ obj”的同步// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERRORint objc_sync_exit(id obj)&#123; int result = OBJC_SYNC_SUCCESS; if (obj) &#123;//obj不为nil SyncData* data = id2data(obj, RELEASE); if (!data) &#123; result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR; &#125; else &#123; bool okay = data-&gt;mutex.tryUnlock();//解锁 if (!okay) &#123; result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR; &#125; &#125; &#125; else &#123;//obj为nil时，什么也不做 // @synchronized(nil) does nothing &#125; return result;&#125; 通过上面两个实现逻辑的对比，发现它们有一个共同点，在obj存在时，都会通过 id2data 方法，获取 SyncData 进入 SyncData 的定义，是一个结构体，主要用来表示一个 线程data，类似于 链表结构，有next指向，且封装了 recursive_mutex_t 属性，可以确认 @synchronized 确实是一个 递归互斥锁 123456typedef struct alignas(CacheLineSize) SyncData &#123; struct SyncData* nextData; DisguisedPtr&lt;objc_object&gt; object; // 类似链表结构 int32_t threadCount; // number of THREADS using this block recursive_mutex_t mutex; // 递归锁&#125; SyncData; 进入 SyncCache 的定义，也是一个结构体，用于存储线程，其中 list[0] 表示 当前线程的链表data，主要用于存储 SyncData 和 lockCount 12345678910typedef struct &#123; SyncData *data; unsigned int lockCount; // number of times THIS THREAD locked this block&#125; SyncCacheItem;typedef struct SyncCache &#123; unsigned int allocated; unsigned int used; SyncCacheItem list[0];&#125; SyncCache; id2data 分析 进入 id2data 源码，从上面的分析，可以看出，这个方法是 加锁和解锁 都复用的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170static SyncData* id2data(id object, enum usage why)&#123; spinlock_t *lockp = &amp;LOCK_FOR_OBJ(object); SyncData **listp = &amp;LIST_FOR_OBJ(object); SyncData* result = NULL;#if SUPPORT_DIRECT_THREAD_KEYS //tls（Thread Local Storage，本地局部的线程缓存） // Check per-thread single-entry fast cache for matching object bool fastCacheOccupied = NO; //通过KVC方式对线程进行获取 线程绑定的data SyncData *data = (SyncData *)tls_get_direct(SYNC_DATA_DIRECT_KEY); //如果线程缓存中有data，执行if流程 if (data) &#123; fastCacheOccupied = YES; //如果在线程空间找到了data if (data-&gt;object == object) &#123; // Found a match in fast cache. uintptr_t lockCount; result = data; //通过KVC获取lockCount，lockCount用来记录 被锁了几次，即 该锁可嵌套 lockCount = (uintptr_t)tls_get_direct(SYNC_COUNT_DIRECT_KEY); if (result-&gt;threadCount &lt;= 0 || lockCount &lt;= 0) &#123; _objc_fatal(&quot;id2data fastcache is buggy&quot;); &#125; switch(why) &#123; case ACQUIRE: &#123; //objc_sync_enter走这里，传入的是ACQUIRE -- 获取 lockCount++;//通过lockCount判断被锁了几次，即表示 可重入（递归锁如果可重入，会死锁） tls_set_direct(SYNC_COUNT_DIRECT_KEY, (void*)lockCount);//设置 break; &#125; case RELEASE: //objc_sync_exit走这里，传入的why是RELEASE -- 释放 lockCount--; tls_set_direct(SYNC_COUNT_DIRECT_KEY, (void*)lockCount); if (lockCount == 0) &#123; // remove from fast cache tls_set_direct(SYNC_DATA_DIRECT_KEY, NULL); // atomic because may collide with concurrent ACQUIRE OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount); &#125; break; case CHECK: // do nothing break; &#125; return result; &#125; &#125;#endif // Check per-thread cache of already-owned locks for matching object SyncCache *cache = fetch_cache(NO);//判断缓存中是否有该线程 //如果cache中有，方式与线程缓存一致 if (cache) &#123; unsigned int i; for (i = 0; i &lt; cache-&gt;used; i++) &#123;//遍历总表 SyncCacheItem *item = &amp;cache-&gt;list[i]; if (item-&gt;data-&gt;object != object) continue; // Found a match. result = item-&gt;data; if (result-&gt;threadCount &lt;= 0 || item-&gt;lockCount &lt;= 0) &#123; _objc_fatal(&quot;id2data cache is buggy&quot;); &#125; switch(why) &#123; case ACQUIRE://加锁 item-&gt;lockCount++; break; case RELEASE://解锁 item-&gt;lockCount--; if (item-&gt;lockCount == 0) &#123; // remove from per-thread cache 从cache中清除使用标记 cache-&gt;list[i] = cache-&gt;list[--cache-&gt;used]; // atomic because may collide with concurrent ACQUIRE OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount); &#125; break; case CHECK: // do nothing break; &#125; return result; &#125; &#125; // Thread cache didn&#x27;t find anything. // Walk in-use list looking for matching object // Spinlock prevents multiple threads from creating multiple // locks for the same new object. // We could keep the nodes in some hash table if we find that there are // more than 20 or so distinct locks active, but we don&#x27;t do that now. //第一次进来，所有缓存都找不到 lockp-&gt;lock(); &#123; SyncData* p; SyncData* firstUnused = NULL; for (p = *listp; p != NULL; p = p-&gt;nextData) &#123;//cache中已经找到 if ( p-&gt;object == object ) &#123;//如果不等于空，且与object相似 result = p;//赋值 // atomic because may collide with concurrent RELEASE OSAtomicIncrement32Barrier(&amp;result-&gt;threadCount);//对threadCount进行++ goto done; &#125; if ( (firstUnused == NULL) &amp;&amp; (p-&gt;threadCount == 0) ) firstUnused = p; &#125; // no SyncData currently associated with object 没有与当前对象关联的SyncData if ( (why == RELEASE) || (why == CHECK) ) goto done; // an unused one was found, use it 第一次进来，没有找到 if ( firstUnused != NULL ) &#123; result = firstUnused; result-&gt;object = (objc_object *)object; result-&gt;threadCount = 1; goto done; &#125; &#125; // Allocate a new SyncData and add to list. // XXX allocating memory with a global lock held is bad practice, // might be worth releasing the lock, allocating, and searching again. // But since we never free these guys we won&#x27;t be stuck in allocation very often. posix_memalign((void **)&amp;result, alignof(SyncData), sizeof(SyncData));//创建赋值 result-&gt;object = (objc_object *)object; result-&gt;threadCount = 1; new (&amp;result-&gt;mutex) recursive_mutex_t(fork_unsafe_lock); result-&gt;nextData = *listp; *listp = result; done: lockp-&gt;unlock(); if (result) &#123; // Only new ACQUIRE should get here. // All RELEASE and CHECK and recursive ACQUIRE are // handled by the per-thread caches above. if (why == RELEASE) &#123; // Probably some thread is incorrectly exiting // while the object is held by another thread. return nil; &#125; if (why != ACQUIRE) _objc_fatal(&quot;id2data is buggy&quot;); if (result-&gt;object != object) _objc_fatal(&quot;id2data is buggy&quot;);#if SUPPORT_DIRECT_THREAD_KEYS if (!fastCacheOccupied) &#123; //判断是否支持栈存缓存，支持则通过KVC形式赋值 存入tls // Save in fast thread cache tls_set_direct(SYNC_DATA_DIRECT_KEY, result); tls_set_direct(SYNC_COUNT_DIRECT_KEY, (void*)1);//lockCount = 1 &#125; else #endif &#123; // Save in thread cache 缓存中存一份 if (!cache) cache = fetch_cache(YES);//第一次存储时，对线程进行了绑定 cache-&gt;list[cache-&gt;used].data = result; cache-&gt;list[cache-&gt;used].lockCount = 1; cache-&gt;used++; &#125; &#125; return result;&#125; 【第一步】首页在 tls 即 线程缓存 中查找 在 tls_get_direct 方法中以 线程为key，通过 KVC 的方式获取与之绑定的 SyncData，即线程 data，其中的 tls()，表示 本地局部的线程缓存 判断获取的data是否存在，以及判断data中是否能找到对应的objct 如果都找到了，在 tls_get_direct 方法中以KVC的方式获取 lockcount，用来记录 对象被锁了几次（即锁的嵌套次数） 如果data中的 threadCount 小于等于0，或者 lockCount 小于等于0时，则直接崩溃 通过传入的 why，判断操作类型 如果是 ACQUIRE，表示加锁，则进行lockCount++，并保存到tls缓存 如果是 RELEASE，表示释放，则进行lockCount++，并保存到tls缓存，如果 lockCount 等于 0，从tls中 移除 线程data 如果是 CHECK，则什么也不做 【第二步】如果 tls 中没有，则在 cache缓存 中查找 通过 fetch_cache 方法查找cache缓存中是否有线程 如果有，则遍历cache总表，读取出线程对应的 SyncCacheItem 从 SyncCacheItem 中取出 data，然后后续步骤与tls的匹配是一致的 【第三步】如果cache中也没有，即 第一次进来，则创建 SyncData，并存储到相应缓存中 如果在cache中找到线程，且与object相等，则进行 赋值、以及 threadCount++ 如果在cache中没有找到，则 threadCount 等于 1. 所以在 id2data 方法中，主要分为三种情况 【第一次进来，没有锁】 threadCount &#x3D; 1 lockCount &#x3D; 1 存储到 tls 【不是第一次进来，且是同一个线程】 tls中有数据，则 lockCount++ 存储到 tls 【不是第一次进来，且是不同线程】 全局线程空间 进行查找线程 threadCount++ lockCount++ 存储到 cache tls和cache表结构 针对tls和cache缓存，底层的表结构如下所示 哈希表 结构中通过 SyncList 结构来组装 多线程 的情况 SyncData 通过 链表 的形式组装 当前可重入 的情况 下层通过 tls线程缓存、cache缓存 来进行 处理 底层主要有两个东西：lockCount、threadCount，解决了递归互斥锁，解决了嵌套可重入 @synchronized 坑点下面代码这样写，会有什么问题？ 12345678910 - (void)zj_testSync&#123; _testArray = [NSMutableArray array]; for (int i = 0; i &lt; 200000; i++) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; @synchronized (self.testArray) &#123; self.testArray = [NSMutableArray array]; &#125; &#125;); &#125;&#125; 运行结果发现，运行就崩溃 崩溃的主要原因是 testArray 在某一瞬间变成了nil，从@synchronized底层流程可知，如果 加锁的对象成了nil，是锁不住的，相当于下面这种情况，block内部不停的retain、release，会在某一瞬间 上一个未release，下一个已经准备release，这样会导致 野指针 的产生 12345678- (void)zj_crash&#123; _testArray = [NSMutableArray array]; for (int i = 0; i &lt; 200000; i++) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; _testArray = [NSMutableArray array]; &#125;); &#125;&#125; 可以根据上面的代码，打开 edit scheme -&gt; run -&gt; Diagnostics 中勾选 Zombie Objects，来查看是否存在僵尸对象，结果如下所示 我们一般使用 @synchronized(self)，主要是因为 _testArray 的持有者是 self 注意：野指针 vs 过度释放 野指针：是指由于过度释放产生的指针还在进行操作 过度释放：每次都会 retain 和 release 总结 @synchronized 在底层封装的是一把 递归锁，所以这个锁是 递归互斥锁 @synchronized 的可重入，即可 嵌套，主要是由于 lockCount 和 threadCount 的搭配 @synchronized 使用 链表 的原因是 链表方便下一个data的插入 但是由于底层中 链表查询、缓存的查找以及递归，是非常 耗内存 以及 性能 的，导致 性能低，所以在前文中，该锁的排名在最后 不能使用 非OC对象 作为加锁对象，因为其 object 的参数为 id @synchronized(self) 这种适用于 嵌套次数较少 的场景。这里锁住的对象也 并不永远是self，这里需要读者注意 如果锁嵌套次数较多，即 锁self过多，会导致底层的查找非常麻烦，因为其底层是链表进行查找，所以会相对比较麻烦，所以此时可以使用 NSLock、信号量 等 NSLockNSLock 是对 下层phread_mutex 的封装，使用如下： 123NSLock *lock = [[NSLock alloc] init];[lock lock];[lock unlock]; 直接进入 NSLock 定义查看，其遵循了 NSLocking 协议，下面来探索 NSLock 的底层实现 NSLock底层分析 通过加符号断点 lock 分析，发现其源码在 Foundation 框架中 由于OC的 Foundation 框架不开源，所以这里借助 Swift 的开源框架 Foundation 来分析 NSLock 的底层实现，其原理与OC是大致相同的 通过源码实现可以看出，底层是通过 pthread_mutex 互斥锁实现的，并且在init方法中，还做了一些其他操作，所以在使用NSLock时需要使用init初始化 回到前文的性能图中，可以看出 NSLock 的性能仅次于 pthread_mutex（互斥锁），非常接近 使用弊端请问下面block嵌套block的代码中，会有什么问题？ 123456789101112for (int i= 0; i&lt;100; i++) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; static void (^testMethod)(int); testMethod = ^(int value)&#123; if (value &gt; 0) &#123; NSLog(@&quot;current value = %d&quot;,value); testMethod(value - 1); &#125; &#125;; testMethod(10); &#125;);&#125; 在未加锁之前，其中current打印的结果数据混乱，主要原因是多线程导致的 如果像下面这样加锁，会有什么问题？ 123456789101112131415NSLock * lock = [[NSLock alloc] init];for (int i= 0; i&lt;100; i++) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; static void (^testMethod)(int); testMethod = ^(int value)&#123; [lock lock]; if (value &gt; 0) &#123; NSLog(@&quot;current value = %d&quot;,value); testMethod(value - 1); &#125; &#125;; testMethod(10); [lock unlock]; &#125;);&#125; 会出现一直等待的情况，主要是因为 嵌套使用的递归，使用 NSLock（简单的互斥锁，如果没有回来，会一直睡觉等待），即会存在一直加lock，等不到unlock的堵塞情况 所以，针对这种情况，可以使用以下方式解决 使用 NSLock 12345678910111213141516NSLock * lock = [[NSLock alloc] init];for (int i= 0; i&lt;100; i++) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; static void (^testMethod)(int); [lock lock]; testMethod = ^(int value)&#123; if (value &gt; 0) &#123; NSLog(@&quot;current value = %d&quot;,value); testMethod(value - 1); &#125;else &#123; [lock unlock]; &#125; &#125;; testMethod(10); &#125;);&#125; 使用 @synchronized 1234567891011121314for (int i= 0; i&lt;100; i++) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; static void (^testMethod)(int); testMethod = ^(int value)&#123; @synchronized (self) &#123; if (value &gt; 0) &#123; NSLog(@&quot;current value = %d&quot;,value); testMethod(value - 1); &#125; &#125; &#125;; testMethod(10); &#125;);&#125; 使用递归锁 NSRecursiveLock 123456789101112131415NSRecursiveLock * lock = [[NSRecursiveLock alloc] init];for (int i= 0; i&lt;100; i++) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; static void (^testMethod)(int); [lock lock]; // 加锁 testMethod = ^(int value)&#123; if (value &gt; 0) &#123; NSLog(@&quot;current value = %d&quot;,value); testMethod(value - 1); &#125; [lock unlock]; &#125;; testMethod(10); &#125;);&#125; pthread_mutexpthread_mutex 就是 互斥锁本身，当锁被占用，其他线程申请锁时，不会一直忙等待，而是 阻塞线程并睡眠 使用 123456789101112131415161718# 导入头文件#import &lt;tphread.j&gt;// 全局声明互斥锁phread_mutex_t _lock;// 初始化互斥锁pthread_mutex_init(&amp;_lock, NULL);// 加锁pthread_mutex_lock(&amp;_lock);// 这里需要线程安全操作// 解锁pthread_mutex_unlock(&amp;_lock);// 释放锁pthread_mutex_destroy(&amp;_lock); NSRecursiveLockNSRecursiveLock 在底层也是对 pthread_mutex 的封装，可以通过 swift 的 Foundation 源码查看 对比 NSLock 和 NSRecursiveLock，其底层实现几乎一模一样，区别在于init时，NSRecursiveLock 有一个标识 PTHREAD_MUTEX_RECURSIVE ，而 NSLock 是默认的 递归锁 主要是用于 解决一些嵌套形式，其中循环嵌套居多 NSConditionNSCondition 是一个 条件锁，在日常开发中使用较少，与信号量有点相似：线程1 需要满足条件才会往下走，否则会堵塞等待，直到条件满足，经典模型是 生产消费者模型 NSCondition的对象 实际上作为一个 锁 和一个 线程检查器 锁 主要为了 当检测条件时保护数据源，执行条件引发的任务 线程检查器 主要是 根据条件决定是否继续运行线程，即线程是否被 阻塞 使用 1234567891011121314// 初始化NSCondition *condition = [[NSCondition alloc] init]// 一般用于多线程同时访问、修改同一个数据源，保证在同一 时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到 unlock ，才可访问[condition lock];// 与lock 同时使用[condition unlock];// 让当前线程处于等待状态[condition wait];// CPU发信号告诉线程不用在等待，可以继续执行[condition signal]; 底层分析通过swift的Foundation源码查看 NSCondition 的底层实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748open class NSCondition: NSObject, NSLocking &#123; internal var mutex = _MutexPointer.allocate(capacity: 1) internal var cond = _ConditionVariablePointer.allocate(capacity: 1) //初始化 public override init() &#123; pthread_mutex_init(mutex, nil) pthread_cond_init(cond, nil) &#125; //析构 deinit &#123; pthread_mutex_destroy(mutex) pthread_cond_destroy(cond) mutex.deinitialize(count: 1) cond.deinitialize(count: 1) mutex.deallocate() cond.deallocate() &#125; //加锁 open func lock() &#123; pthread_mutex_lock(mutex) &#125; //解锁 open func unlock() &#123; pthread_mutex_unlock(mutex) &#125; //等待 open func wait() &#123; pthread_cond_wait(cond, mutex) &#125; //等待 open func wait(until limit: Date) -&gt; Bool &#123; guard var timeout = timeSpecFrom(date: limit) else &#123; return false &#125; return pthread_cond_timedwait(cond, mutex, &amp;timeout) == 0 &#125; //信号，表示等待的可以执行了 open func signal() &#123; pthread_cond_signal(cond) &#125; //广播 open func broadcast() &#123; // 汇编分析 - 猜 (多看多玩) pthread_cond_broadcast(cond) // wait signal &#125; open var name: String?&#125; 其底层也是对下层 pthread_mutex 的封装 NSCondition 是对 mutex 和 cond 的一种封装（cond就是用于访问和操作特定类型数据的指针） wait 操作会 阻塞线程，使其进入 休眠状态，直至超时 signal 操作是 唤醒 一个正在休眠等待的线程 broadcast 会唤醒所有在等待的线程 NSConditionLockNSConditionLock 是条件锁，一旦一个线程获取锁，其他线程一定等待 相比 NSConditionLock 而言，NSCondition 使用比较麻烦，所以推荐使用 NSConditionLock ,其使用如下 12345678910111213141516// 初始化NSConditionLock * conditionLock = [[NSConditionLock alloc] initWithCondition:2];// 表示 conditionLock 期待获得锁，如果没有其他线程获得锁(不需要判断内部的 condition) 那它能执行此行以下代码，如果已经有其他线程获得锁(可能是条件锁，或者无条件 锁)，则等待，直至其他线程解锁[conditionLock lock]; // 表示如果没有其他线程获得该锁，但是该锁内部的 condition不等于A条件，它依然不能获得锁，仍然等待。如果内部的condition等于A条件，并且 没有其他线程获得该锁，则进入代码区，同时设置它获得该锁，其他任何线程都将等待它代码的 完成，直至它解锁。[conditionLock lockWhenCondition:A条件]; // 表示释放锁，同时把内部的condition设置为A条件[conditionLock unlockWithCondition:A条件]; // 表示如果被锁定(没获得 锁)，并超过该时间则不再阻塞线程。但是注意:返回的值是NO,它没有改变锁的状态，这个函 数的目的在于可以实现两种状态下的处理return = [conditionLock lockWhenCondition:A条件 beforeDate:A时间];// 其中所谓的condition就是整数，内部通过整数比较条件 NSConditionLock ，其本质就是 NSCondition + Lock，以下是其swift的底层实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576open class NSConditionLock : NSObject, NSLocking &#123; internal var _cond = NSCondition() internal var _value: Int internal var _thread: _swift_CFThreadRef? public convenience override init() &#123; self.init(condition: 0) &#125; public init(condition: Int) &#123; _value = condition &#125; open func lock() &#123; let _ = lock(before: Date.distantFuture) &#125; open func unlock() &#123; _cond.lock() _thread = nil _cond.broadcast() _cond.unlock() &#125; open var condition: Int &#123; return _value &#125; open func lock(whenCondition condition: Int) &#123; let _ = lock(whenCondition: condition, before: Date.distantFuture) &#125; open func `try`() -&gt; Bool &#123; return lock(before: Date.distantPast) &#125; open func tryLock(whenCondition condition: Int) -&gt; Bool &#123; return lock(whenCondition: condition, before: Date.distantPast) &#125; open func unlock(withCondition condition: Int) &#123; _cond.lock() _thread = nil _value = condition _cond.broadcast() _cond.unlock() &#125; open func lock(before limit: Date) -&gt; Bool &#123; _cond.lock() while _thread != nil &#123; if !_cond.wait(until: limit) &#123; _cond.unlock() return false &#125; &#125; _thread = pthread_self() _cond.unlock() return true &#125; open func lock(whenCondition condition: Int, before limit: Date) -&gt; Bool &#123; _cond.lock() while _thread != nil || _value != condition &#123; if !_cond.wait(until: limit) &#123; _cond.unlock() return false &#125; &#125; _thread = pthread_self() _cond.unlock() return true &#125; open var name: String?&#125; 通过源码可以看出 NSConditionLock 是 NSCondition 的封装 NSConditionLock 可以 设值锁条件，即 NSCondition值，而 NSCondition只是信号的通知 调试验证以下面的代码为例，调试 NSConditionLock 底层流程 12345678910111213141516171819202122- (void)zj_testConditonLock&#123; // 信号量 NSConditionLock * conditionLock = [[NSConditionLock alloc] initWithCondition:2]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; [conditionLock lockWhenCondition:1]; // conditoion = 1 内部 Condition 匹配 NSLog(@&quot;线程 1&quot;); [conditionLock unlockWithCondition:0]; &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123; [conditionLock lockWhenCondition:2]; sleep(0.1); NSLog(@&quot;线程 2&quot;); [conditionLock unlockWithCondition:1]; // _value = 2 -&gt; 1 &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [conditionLock lock]; NSLog(@&quot;线程 3&quot;); [conditionLock unlock]; &#125;);&#125; 查看打印结果 打印结果分析 线程1 调用 [conditionLock lockWhenCondition:1]，此时因为不满足条件，所以会 进入waiting状态，当进入到waiting时，会释放当前的互斥锁 此时当前的 线程3 调用 [conditionLock lock]，本质上是调用 [NSConditionLock lockBeforeDate:]，这里 不需要对比条件值，所以 线程3先打印 接下来 线程2 执行 [conditionLock lockWhenCondition:2]，因为 满足条件值，所以 线程2会打印，打印完成后调用 [conditionLock unlockWithCondition:1]，这个时候将value设置为 1，并发送boradcast，此时 线程1 接收到当前的信号，唤醒执行并打印 自此当前打因为：线程3-&gt;线程2-&gt;线程1 [conditionLock lockWhenCondition:] 这里会根据传入的 condition值 和 Value值进行对比，如果 不相等，这里 就会阻塞，进入线程池，否则的话就继续代码执行 [conditionLock unlockWithCondition:1] ，这里会 先更改当前的value值，然后进行上市。然后 进行广播，唤醒当前的线程 性能总结 OSSpinLock自旋锁 由于安全性问题，在iOS10之后已经被废弃，其底层的实现用 os_unfair_lock 替代 使用 OSSpinLock 及所示，会处于 忙等待状态 而 os_unfair_lock 是处于 休眠状态 atomic原子锁 自带一把自旋锁，只能保证 setter、getter 时的线程安全，在日常开发中使用更多的还是 nonatomic 修饰属性 atomic：当属性在调用 setter、getter 方法时，会加上 自旋锁OSSpinLock，用于保证同一时刻只能有一个线程调用属性的读或写，避免了属性读写不同步的问题，由于是底层编译器自动生成的互斥锁代码，会导致效率相对较低 nonatomic：当属性在调用 setter、getter 方法时，不会加上自旋锁，即 线程不安全，由于编译器不会自动生成互斥锁代码，可以 提高效率 @synchronized 在底层维护了一个 哈希表 进行线程data的存储，通过 链表 表示 可重入（即嵌套）的特性，虽然性能较低，但由于简单好用，使用频率高 NSLock、NSRecursiveLock 底层是对 pthread_mutex 的封装 NSCondition 和 NSConditionLock 是条件锁，底层都是对 pthread_mutex 的封装，当满足某一条件时才能进行操作，和信号量 dispatch_semphore 类似 锁的使用场景 如果只是 简单 的使用，例如涉及线程安全，使用 NSLock 即可。 如果是 循环嵌套，推荐使用 @synchronized ，主要是因为使用 递归锁 的性能不能使用 @synchronized 的性能（因为在 @synchronized 中无论怎么重入，都没有关系，而 NSRecursiveLock可能会出现崩溃现象） 在 循环嵌套 中，如果递归锁掌握的很好，则建议使用 递归锁，因为性能好 如果是 循环嵌套，并且还有 多线程影响，例如有等待、死锁现象时，建议 使用 @synchronized","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理28：GCD之底层原理分析","slug":"OC进阶/OC底层原理28：GCD之底层原理分析","date":"2021-04-05T06:46:07.000Z","updated":"2022-04-02T00:42:48.000Z","comments":true,"path":"2021/04/05/OC进阶/OC底层原理28：GCD之底层原理分析/","link":"","permalink":"https://www.bboyzj.cn/2021/04/05/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8628%EF%BC%9AGCD%E4%B9%8B%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理27：GCD之 NSThread & GCD & NSOperation","slug":"OC进阶/OC底层原理27：GCD之 NSThread & GCD & NSOperation","date":"2021-03-23T06:59:47.000Z","updated":"2023-02-24T16:13:35.534Z","comments":true,"path":"2021/03/23/OC进阶/OC底层原理27：GCD之 NSThread & GCD & NSOperation/","link":"","permalink":"https://www.bboyzj.cn/2021/03/23/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8627%EF%BC%9AGCD%E4%B9%8B%20NSThread%20&%20GCD%20&%20NSOperation/","excerpt":"","text":"前言本文主要目的是介绍 NSThread、GCD、NSOperation 常见的使用方式 NSThreadNSThread 是苹果官方提供 面向对象 的线程操作技术，是对 thread 的上层封装，比较偏向于底层，简单方便，可以直接操作线程对象，使用频率较少 创建线程 线程的创建方式主要有以下三种方式 通过 init 初始化方式创建，需要手动启动 通过 detachNewThreadSelector 构造器方式创建 通过 performSelector... 方式创建，主要是用于获取 主线程，以及 后台线程 12345678910111213141516171819202122- (void)createNSThread&#123; // 方式一：初始化方式，需要手动启动 NSString * threadName1 = @&quot;NSThread1&quot;; NSThread * thread1 = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:threadName1]; [thread1 start]; // 方式二：构造器方式，自动启动 NSString * threadName2 = @&quot;NSThread2&quot;; [NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:threadName2]; // 方式三：performSelector...方法创建 NSString * threadName3 = @&quot;NSThread3&quot;; [self performSelectorInBackground:@selector(doSomething:) withObject:threadName3]; // 方式四：在主线程执行 NSString * threadName4 = @&quot;NSThread4&quot;; [self performSelectorOnMainThread:@selector(doSomething:) withObject:threadName4 waitUntilDone:YES];&#125;- (void)doSomething:(NSObject *)objc&#123; NSLog(@&quot;%@ - %@&quot;, objc, [NSThread currentThread]);&#125; 属性 12345- thread.executing // 线程是否在执行- thread.isCancelled // 线程是否取消- thread.isFinished // 线程是否完成- thread.isMainThread // 是否是主线程- thread.threadPriority // 线程的优先级，取值返回0.0~1.0默认优先级是0.5，1.0便是最高优先级，优先级越高，CPU调度的评率高 类方法 常用的类方法有以下几个： currentThread：获取当前线程 sleep…：阻塞线程 exit：退出线程 mainThread：获取主线程 1234567891011121314151617- (void)threadClassMethod&#123; // 当前线程 [NSThread currentThread]; // 如果number = 1，则表示在主线程，否则在子线程 NSLog(@&quot;%@&quot;,[NSThread currentThread]); // 阻塞休眠 [NSThread sleepForTimeInterval:2]; // 休眠2s [NSThread sleepUntilDate:[NSDate date]]; // 休眠到指定时间 // 其他 [NSThread exit]; // 退出线程 [NSThread isMainThread]; // 判断当前线程是否为主线程 [NSThread isMultiThreaded]; // 判断当前线程是否为多线程 NSThread * mainThread = [NSThread mainThread]; // 主线程对象 NSLog(@&quot;%@&quot;,mainThread);&#125; 实际使用 根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？ dispatch_group_t + dispatch_group_enter + dispatch_group_leave + dispatch_group_notify 123456789101112131415161718192021222324-(void)Btn&#123; NSString *str = @&quot;http://www.jianshu.com/p/6930f335adba&quot;; NSURL *url = [NSURL URLWithString:str]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; NSURLSession *session = [NSURLSession sharedSession]; // 创建线程组 dispatch_group_t downloadGroup = dispatch_group_create(); for (int i=0; i&lt;10; i++) &#123; // enter dispatch_group_enter(downloadGroup); // 下载图片 NSURLSessionDataTask * task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSLog(@&quot;%d---%d&quot;,i,i); // 离开 dispatch_group_leave(downloadGroup); &#125;]; [task resume]; &#125; dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;end&quot;); &#125;);&#125; dispatch_group_enter：通知group，下面的任务马上要放到group中执行了。dispatch_group_leave：通知group，任务完成了，该任务要从group中移除了。dispatch_group_notify：通知线程组中的任务都完成了 10个网络请求顺序回调? dispatch_semaphore_t：信号量 123456789101112131415161718192021222324-(void)Btn&#123; NSString *str = @&quot;http://www.jianshu.com/p/6930f335adba&quot;; NSURL *url = [NSURL URLWithString:str]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; NSURLSession *session = [NSURLSession sharedSession]; dispatch_semaphore_t sem = dispatch_semaphore_create(0); for (int i=0; i&lt;10; i++) &#123; NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSLog(@&quot;%d---%d&quot;,i,i); dispatch_semaphore_signal(sem); &#125;]; [task resume]; // 让循环等待 dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;end&quot;); &#125;);&#125; GCDdispatch_after 123456789- (void)testAfter&#123; /* dispatch_after表示在某队列中的blcok延迟执行 应用场景：在主队列上延迟执行一向任务，如viewDidload之后延迟1s，提示一个alertview（是延迟加入到队列，而不是延迟执行） */ dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;1s后输出&quot;); &#125;);&#125; dispath_once 1234567891011- (void)testOnce&#123; /* dispatch_once保证APP在运行期间，block中的代码只执行有一次 应用场景：单例、method_swizzling */ static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 创建单例、method swizzled或其他服务 NSLog(@&quot;创建单例&quot;); &#125;);&#125; dispach_apply 12345678910111213141516171819202122- (void)testApply&#123; /* dispatch_apply将指定的block追加到指定的队列中重复执行，并等到全部的处理执行结束 - 相当于线程安全的for循环 应用场景：用来拉取网络数据后提前算出各个控件的大小，防止绘制时计算，提高表单滑动流畅性 - 添加到串行队列中 —— 按序执行 - 添加到主队列中 —— 死锁 - 添加到并发队列中 —— 乱序执行 - 添加都全局队列中 —— 乱序执行 */ dispatch_queue_t queue = dispatch_queue_create(&quot;ZJ&quot;, DISPATCH_QUEUE_SERIAL); NSLog(@&quot;dispatch_apply前&quot;); /* param1：重复的次数 param2：追加的队列 param3：执行任务 */ dispatch_apply(10, queue, ^(size_t index) &#123; NSLog(@&quot;dispatch_apply 的线程 %zu - %@&quot;, index, [NSThread currentThread]); &#125;); NSLog(@&quot;dispatch_apply后&quot;);&#125; dispatch_group_t 有以下两种使用方式 方式一：使用 dispatch_group_t + dispatch_group_notify 12345678910111213141516171819202122232425- (void)testGroup1&#123; /* dispatch_group_t：调度组将任务分组执行，能监听任务组完成，并设置等待时间 应用场景：多个接口请求之后刷新页面 */ dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_queue_create(0, 0); dispatch_group_async(group, queue, ^&#123; NSLog(@&quot;请求一完成&quot;); &#125;); dispatch_group_async(group, queue, ^&#123; NSLog(@&quot;请求二完成&quot;); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;刷新页面&quot;); &#125;);&#125;// ****打印结果****2022-02-22 14:54:43.783327+0800 NSThread_Demo[4902:3701318] 请求一完成2022-02-22 14:54:43.783404+0800 NSThread_Demo[4902:3701318] 请求二完成2022-02-22 14:54:43.783432+0800 NSThread_Demo[4902:3701318] 刷新页面 【方式二】使用 dispatch_group_enter + dispatch_group_leave + dispatch_group_notify 12345678910111213141516171819202122232425262728- (void)testGroup2&#123; /* dispatch_group_enter 和 dispatch_group_leave 成对出现，使进出组的逻辑更加清晰 */ dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_queue_create(0, 0); dispatch_group_enter(group); dispatch_async(queue, ^&#123; NSLog(@&quot;请求一完成&quot;); dispatch_group_leave(group); &#125;); dispatch_group_enter(group); dispatch_async(queue, ^&#123; NSLog(@&quot;请求二完成&quot;); dispatch_group_leave(group); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;刷新页面&quot;); &#125;);&#125;// ****打印结果****2022-02-22 15:13:39.981715+0800 NSThread_Demo[4906:3707145] 请求一完成2022-02-22 15:13:39.981788+0800 NSThread_Demo[4906:3707145] 请求二完成2022-02-22 15:13:39.987105+0800 NSThread_Demo[4906:3707122] 刷新页面 在方式二的基础上增加超时 dispatch_group_wait 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950- (void)testGroup3&#123; /* long dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout) group：需要等待的调度组 timeout：等待的超时时间（即等多久） - 设置为 DISPATCH_TIME_NOW意味着不等待直接判定调度组是否执行完毕 - 设置为 DISPATCH_TIME_FOREVER则会阻塞当前调度组，直到调度组执行完毕 返回值：为long 类型 - 返回值为0 —— 在指定时间内调度组完成了任务 - 返回值不为0 —— 在指定时间内调度组没有按时完成任务 */ dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_group_enter(group); dispatch_async(queue, ^&#123; NSLog(@&quot;请求一完成&quot;); dispatch_group_leave(group); &#125;); dispatch_group_enter(group); dispatch_async(queue, ^&#123; NSLog(@&quot;请求二完成&quot;); dispatch_group_leave(group); &#125;); // long timeout = dispatch_group_wait(group, DISPATCH_TIME_NOW); // 立即// long timeout = dispatch_group_wait(group, DISPATCH_TIME_FOREVER); // 没限制 long timeout = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, 1 *NSEC_PER_SEC)); // 1s后 NSLog(@&quot;timeout = %ld&quot;,timeout); if (timeout == 0) &#123; NSLog(@&quot;按时完成任务&quot;); &#125;else &#123; NSLog(@&quot;超时&quot;); &#125; dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;刷新页面&quot;); &#125;);&#125;// ****打印结果****2022-02-22 15:25:03.528855+0800 NSThread_Demo[4915:3711930] 请求一完成2022-02-22 15:25:03.528859+0800 NSThread_Demo[4915:3711929] 请求二完成2022-02-22 15:25:03.528923+0800 NSThread_Demo[4915:3711910] timeout = 02022-02-22 15:25:03.528946+0800 NSThread_Demo[4915:3711910] 按时完成任务2022-02-22 15:25:03.534554+0800 NSThread_Demo[4915:3711910] 刷新页面 dispatch_barrier_sync &amp; dispatch_barrier_async 栅栏函数，主要有两种使用场景：串行队列、并发队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384- (void)testBarrier&#123; /* dispatch_barrier_sync &amp; dispatch_barrier_async 应用场景：同步锁 等栅栏前追加到队列中的任务执行完毕后，再讲栅栏后的任务追加到队列中 简而言之，就是先执行栅栏前任务，在执行栅栏任务，最后执行栅栏后任务 - dispatch_barrier_async：前面的任务执行完毕才会来到这里 - dispatch_barrier_sync：作用相同，但是这个会堵塞线程，影响后面的任务执行 - dispatch_barrier_async：可以控制队列中任务的执行顺序 - dispatch_barrier_sync：不仅阻塞了队列的执行，也阻塞了线程的执行（尽量少用） */// [self testBarrier1]; [self testBarrier2];&#125;- (void)testBarrier1&#123; // 串行队列使用栅栏函数 dispatch_queue_t queue = dispatch_queue_create(&quot;ZJ&quot;, DISPATCH_QUEUE_SERIAL); NSLog(@&quot;开始 - %@&quot;,[NSThread currentThread]); dispatch_async(queue, ^&#123; sleep(2); NSLog(@&quot;延迟2s的任务1 - %@&quot;, [NSThread currentThread]); &#125;); NSLog(@&quot;第一次结束 - %@&quot;,[NSThread currentThread]); // 栅栏函数的作用是讲队列中的任务进行分组，所以我们只要关注任务1、任务2 dispatch_barrier_async(queue, ^&#123; NSLog(@&quot;----------栅栏任务----------%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;栅栏结束 - %@&quot;,[NSThread currentThread]); dispatch_async(queue, ^&#123; sleep(2); NSLog(@&quot;延迟2s的任务2 - %@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;第二次结束 - %@&quot;,[NSThread currentThread]);&#125;// ****打印结果****2022-02-22 16:27:58.036179+0800 NSThread_Demo[4930:3731173] 开始 - &lt;_NSMainThread: 0x282bfc800&gt;&#123;number = 1, name = main&#125;2022-02-22 16:27:58.036253+0800 NSThread_Demo[4930:3731173] 第一次结束 - &lt;_NSMainThread: 0x282bfc800&gt;&#123;number = 1, name = main&#125;2022-02-22 16:27:58.036278+0800 NSThread_Demo[4930:3731173] 栅栏结束 - &lt;_NSMainThread: 0x282bfc800&gt;&#123;number = 1, name = main&#125;2022-02-22 16:27:58.036303+0800 NSThread_Demo[4930:3731173] 第二次结束 - &lt;_NSMainThread: 0x282bfc800&gt;&#123;number = 1, name = main&#125;2022-02-22 16:28:00.041655+0800 NSThread_Demo[4930:3731195] 延迟2s的任务1 - &lt;NSThread: 0x282bfaa80&gt;&#123;number = 4, name = (null)&#125;2022-02-22 16:28:00.042098+0800 NSThread_Demo[4930:3731195] ----------栅栏任务----------&lt;NSThread: 0x282bfaa80&gt;&#123;number = 4, name = (null)&#125;2022-02-22 16:28:02.047479+0800 NSThread_Demo[4930:3731195] 延迟2s的任务2 - &lt;NSThread: 0x282bfaa80&gt;&#123;number = 4, name = (null)&#125;// testBarrier2- (void)testBarrier2&#123; // 并发队列使用栅栏函数 dispatch_queue_t queue = dispatch_queue_create(&quot;ZJ&quot;, DISPATCH_QUEUE_CONCURRENT); NSLog(@&quot;开始 - %@&quot;,[NSThread currentThread]); dispatch_async(queue, ^&#123; sleep(2); NSLog(@&quot;延迟2s的任务1 - %@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;第一次结束 - %@&quot;,[NSThread currentThread]); // 由于并发队列异步任务时乱序执行完毕的，所以使用栅栏函数可以很好的控制队列内任务执行的顺序 dispatch_barrier_async(queue, ^&#123; NSLog(@&quot;----------栅栏任务----------%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;栅栏结束 - %@&quot;,[NSThread currentThread]); dispatch_async(queue, ^&#123; sleep(2); NSLog(@&quot;延迟2s的任务2 - %@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;第二次结束 - %@&quot;,[NSThread currentThread]);&#125;// ****打印结果****2022-02-22 16:24:07.750567+0800 NSThread_Demo[4927:3729822] 开始 - &lt;_NSMainThread: 0x2809c8800&gt;&#123;number = 1, name = main&#125;2022-02-22 16:24:07.750635+0800 NSThread_Demo[4927:3729822] 第一次结束 - &lt;_NSMainThread: 0x2809c8800&gt;&#123;number = 1, name = main&#125;2022-02-22 16:24:07.750665+0800 NSThread_Demo[4927:3729822] 栅栏结束 - &lt;_NSMainThread: 0x2809c8800&gt;&#123;number = 1, name = main&#125;2022-02-22 16:24:07.750685+0800 NSThread_Demo[4927:3729822] 第二次结束 - &lt;_NSMainThread: 0x2809c8800&gt;&#123;number = 1, name = main&#125;2022-02-22 16:24:09.756044+0800 NSThread_Demo[4927:3729837] 延迟2s的任务1 - &lt;NSThread: 0x2809840c0&gt;&#123;number = 5, name = (null)&#125;2022-02-22 16:24:09.756553+0800 NSThread_Demo[4927:3729837] ----------栅栏任务----------&lt;NSThread: 0x2809840c0&gt;&#123;number = 5, name = (null)&#125;2022-02-22 16:24:11.761825+0800 NSThread_Demo[4927:3729837] 延迟2s的任务2 - &lt;NSThread: 0x2809840c0&gt;&#123;number = 5, name = (null)&#125; dispatch_semaphore_t 信号量主要作用于同步锁，用于控制 GCD 最大并发数 12345678910111213141516171819202122232425262728- (void)testSemaphore&#123; /* 应用场景：同步锁，控制GCD最大并发数 - dispatch_semphore_create()：创建信号量 - dispatch_semphore_wait()：等待信号量，信号量减1，当信号量 &lt; 0 时会阻塞当前线程，根据传入的等待时间决定接下来的操作，如果永久等待将等到信号(signal)才能执行下去 - dispatch_semphore_signal()：释放信号量，信号量加1，当信号量 &gt;= 0 会执行wait之后的代码 */ dispatch_queue_t queue = dispatch_queue_create(&quot;ZJ&quot;, DISPATCH_QUEUE_CONCURRENT); for (int i = 0; i &lt; 10; i ++) &#123; dispatch_async(queue, ^&#123; NSLog(@&quot;当前 - %d，线程 - %@&quot;,i,[NSThread currentThread]); &#125;); &#125; // 利用信号量来改写 dispatch_semaphore_t sem = dispatch_semaphore_create(0); for (int i = 0; i &lt; 10; i ++) &#123; dispatch_async(queue, ^&#123; NSLog(@&quot;当前 - %d 线程 - %@&quot;,i,[NSThread currentThread]); dispatch_semaphore_signal(sem); &#125;); dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); &#125; &#125; 由上面的代码可知，在使用信号量之前的打印结果是无序的： 123456789102022-02-23 08:59:56.276005+0800 NSThread_Demo[5019:3790181] 当前 - 1，线程 - &lt;NSThread: 0x2825f0c00&gt;&#123;number = 4, name = (null)&#125;2022-02-23 08:59:56.276005+0800 NSThread_Demo[5019:3790180] 当前 - 0，线程 - &lt;NSThread: 0x2825f0080&gt;&#123;number = 3, name = (null)&#125;2022-02-23 08:59:56.276048+0800 NSThread_Demo[5019:3790182] 当前 - 3，线程 - &lt;NSThread: 0x2825e5180&gt;&#123;number = 7, name = (null)&#125;2022-02-23 08:59:56.276079+0800 NSThread_Demo[5019:3790181] 当前 - 4，线程 - &lt;NSThread: 0x2825f0c00&gt;&#123;number = 4, name = (null)&#125;2022-02-23 08:59:56.276081+0800 NSThread_Demo[5019:3790184] 当前 - 2，线程 - &lt;NSThread: 0x2825eca40&gt;&#123;number = 6, name = (null)&#125;2022-02-23 08:59:56.276110+0800 NSThread_Demo[5019:3790181] 当前 - 7，线程 - &lt;NSThread: 0x2825f0c00&gt;&#123;number = 4, name = (null)&#125;2022-02-23 08:59:56.276093+0800 NSThread_Demo[5019:3790182] 当前 - 6，线程 - &lt;NSThread: 0x2825e5180&gt;&#123;number = 7, name = (null)&#125;2022-02-23 08:59:56.276157+0800 NSThread_Demo[5019:3790182] 当前 - 9，线程 - &lt;NSThread: 0x2825e5180&gt;&#123;number = 7, name = (null)&#125;2022-02-23 08:59:56.276172+0800 NSThread_Demo[5019:3790185] 当前 - 5，线程 - &lt;NSThread: 0x2825f0440&gt;&#123;number = 5, name = (null)&#125;2022-02-23 08:59:56.276185+0800 NSThread_Demo[5019:3790181] 当前 - 8，线程 - &lt;NSThread: 0x2825f0c00&gt;&#123;number = 4, name = (null)&#125; 由上面的代码可知，在使用信号量之后，打印的结果是有序的，如下： 123456789102022-02-23 08:59:56.276197+0800 NSThread_Demo[5019:3790186] 当前 - 0 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;2022-02-23 08:59:56.276416+0800 NSThread_Demo[5019:3790186] 当前 - 1 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;2022-02-23 08:59:56.276572+0800 NSThread_Demo[5019:3790186] 当前 - 2 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;2022-02-23 08:59:56.276706+0800 NSThread_Demo[5019:3790186] 当前 - 3 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;2022-02-23 08:59:56.276828+0800 NSThread_Demo[5019:3790186] 当前 - 4 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;2022-02-23 08:59:56.276934+0800 NSThread_Demo[5019:3790186] 当前 - 5 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;2022-02-23 08:59:56.276997+0800 NSThread_Demo[5019:3790186] 当前 - 6 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;2022-02-23 08:59:56.277125+0800 NSThread_Demo[5019:3790186] 当前 - 7 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;2022-02-23 08:59:56.277179+0800 NSThread_Demo[5019:3790186] 当前 - 8 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;2022-02-23 08:59:56.277298+0800 NSThread_Demo[5019:3790186] 当前 - 9 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125; dispatch_source_t dispatch_source_t 主要用于计时操作，其原因是因为它创建的timer不依赖于Runloop，且计时精准度比 NSTimer 高，dispatch_source_t 有一点必须要设值为属性，否则会被立即释放 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657- (void)testSource&#123; /* dispatch_source 应用场景：GCDTimer 在iOS开发中一般使用NSTimer来处理定时逻辑，但NSTimer是依赖Runloop的，而Runloop可以运行在不同的模式下 如果NSTimer添加在一种模式下，当Runloop运行在其他模式下的时候，定时器就挂机了 dispatch_source是一种基本的数据类型，可以用来监听一些底层的系统事件 - Timer Dispatch Source：定时器事件源，用来生成周期性的通知或回调 - Signal Dispatch Source：监听信号事件源，当有UNIX信号发生时会通知 - Descriptor Dispatch Source：监听文件或socket事件源，当文件或socket数据发生变化时会通知 - Process Dispatch Source：监听进程事件源，与进程相关的事件通知 - Mach port Dispatch Source：监听Mach端口事件源 - Custom Dispatch Source：监听自定义事件源 主要使用的API: - dispatch_source_create：创建时间源 - dispatch_source_set_event_handler：设值数据源回调 - dispatch_source_merge_data：设值事件源数据 - dispatch_source_get_data：获取事件源数据 - dispatch_resume：继续 - dispatch_suspend：挂起 - dispatch_cancle：取消 */ // 创建队列 dispatch_queue_t queue = dispatch_queue_create(&quot;ZJ&quot;, DISPATCH_QUEUE_SERIAL); // 创建timer self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); // 设置timer首次执行事件，间隔，精确度 dispatch_source_set_timer(self.timer, dispatch_time(DISPATCH_TIME_NOW, 2.0 * NSEC_PER_SEC), 1.0 * NSEC_PER_SEC, 0); // 设置timer回调事件 dispatch_source_set_event_handler(self.timer, ^&#123; NSLog(@&quot;GCDTimer&quot;); &#125;); // 默认是挂起状态，需要手动激活 dispatch_resume(self.timer);&#125;// 打印结果2022-02-23 10:01:59.795986+0800 NSThread_Demo[5145:3819354] GCDTimer2022-02-23 10:02:00.795906+0800 NSThread_Demo[5145:3819354] GCDTimer2022-02-23 10:02:01.795952+0800 NSThread_Demo[5145:3819354] GCDTimer2022-02-23 10:02:02.795970+0800 NSThread_Demo[5145:3819354] GCDTimer2022-02-23 10:02:03.796053+0800 NSThread_Demo[5145:3819354] GCDTimer2022-02-23 10:02:04.796022+0800 NSThread_Demo[5145:3819354] GCDTimer2022-02-23 10:02:05.796038+0800 NSThread_Demo[5145:3819354] GCDTimer2022-02-23 10:02:06.796074+0800 NSThread_Demo[5145:3819354] GCDTimer2022-02-23 10:02:07.796115+0800 NSThread_Demo[5145:3819354] GCDTimer2022-02-23 10:02:08.796159+0800 NSThread_Demo[5145:3819355] GCDTimer2022-02-23 10:02:09.796130+0800 NSThread_Demo[5145:3819355] GCDTimer2022-02-23 10:02:10.796167+0800 NSThread_Demo[5145:3819355] GCDTimer2022-02-23 10:02:11.796161+0800 NSThread_Demo[5145:3819355] GCDTimer2022-02-23 10:02:12.796162+0800 NSThread_Demo[5145:3819355] GCDTimer2022-02-23 10:02:13.796169+0800 NSThread_Demo[5145:3819355] GCDTimer... NSOperationNSOperation 是基于 GCD 之上的更高一层的封装， NSOpetation 需要配合 NSOpetationQueue 来实现多线程 NSOpetation 实现多线程的步骤如下： 创建任务：先将需要执行的操作封装到 NSOperation 对象中。 创建队列：创建 NSOperationQueue。 将任务加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 中。 1234567891011- (void)testBaseNSOperation&#123; // 处理事务 NSInvocationOperation * op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(handleInvocation:) object:@&quot;ZJ&quot;]; // 创建队列 NSOperationQueue * queue = [[NSOperationQueue alloc] init]; // 操作加入队列 [queue addOperation:op];&#125;- (void)handleInvocation:(id)operation&#123; NSLog(@&quot;%@ - %@&quot;,operation,[NSThread currentThread]);&#125; 需要注意的是，NSOperation 是个抽象类，实际运用时中需要使用它的子类，有三种方式： 使用子类 NSInvocationOperation 12345- (void)createNSOperation&#123; // 创建 NSInvocationOperation 对象并关联方法，之后start NSInvocationOperation * invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(doSomething:) object:@&quot;ZJ&quot;]; [invocationOperation start];&#125; 使用子类 NSBlockOperation 123456789101112131415161718192021222324252627- (void)testBlockOperationExecution&#123; // 通过 addExecutionBlock 这个方法可以让 NSBlockOperation 实现多线程 // NSBlockOperation 创建时 block 中的任务是主线程执行，而运用 addExecutionBlock 加入的任务是在子线程执行的 NSBlockOperation * blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;main task = &gt;currentThread: %@&quot;,[NSThread currentThread]); &#125;]; [blockOperation addExecutionBlock:^&#123; NSLog(@&quot;task1 = &gt;currentThread: %@&quot;,[NSThread currentThread]); &#125;]; [blockOperation addExecutionBlock:^&#123; NSLog(@&quot;task2 = &gt;currentThread: %@&quot;,[NSThread currentThread]); &#125;]; [blockOperation addExecutionBlock:^&#123; NSLog(@&quot;task3 = &gt;currentThread: %@&quot;,[NSThread currentThread]); &#125;]; [blockOperation start];&#125;// 打印结果2022-02-23 13:48:54.022671+0800 NSThread_Demo[5246:3887949] main task = &gt;currentThread: &lt;_NSMainThread: 0x281598800&gt;&#123;number = 1, name = main&#125;2022-02-23 13:48:54.022688+0800 NSThread_Demo[5246:3887974] task1 = &gt;currentThread: &lt;NSThread: 0x2815c8180&gt;&#123;number = 4, name = (null)&#125;2022-02-23 13:48:54.022786+0800 NSThread_Demo[5246:3887971] task2 = &gt;currentThread: &lt;NSThread: 0x2815da480&gt;&#123;number = 5, name = (null)&#125;2022-02-23 13:48:54.022786+0800 NSThread_Demo[5246:3887976] task3 = &gt;currentThread: &lt;NSThread: 0x2815dc0c0&gt;&#123;number = 6, name = (null)&#125; 定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装任务 1234567891011121314151617181920212223// 自定义继承自NSOperation的子类@interface ZJOperation : NSOperation@end@implementation ZJOperation- (void)main&#123; for (int i = 0; i &lt; 3; i ++) &#123; NSLog(@&quot;NSOperation的子类：%@&quot;,[NSThread currentThread]); &#125;&#125;@end// 使用- (void)testZJOperation&#123; // 运用集成自NSOperation的子类，首先我们定义一个集成自NSOperation的类，然后重写它的main方法 ZJOperation * operation = [[ZJOperation alloc] init]; [operation start];&#125;// 打印结果2022-02-25 15:16:22.694568+0800 NSThread_Demo[5696:4241286] NSOperation的子类：&lt;_NSMainThread: 0x282180800&gt;&#123;number = 1, name = main&#125;2022-02-25 15:16:22.694645+0800 NSThread_Demo[5696:4241286] NSOperation的子类：&lt;_NSMainThread: 0x282180800&gt;&#123;number = 1, name = main&#125;2022-02-25 15:16:22.694670+0800 NSThread_Demo[5696:4241286] NSOperation的子类：&lt;_NSMainThread: 0x282180800&gt;&#123;number = 1, name = main&#125; NSOperationQueueNSOperationQueue添加事务 NSOperationQueue 有两种队列：主队列、其他队列。其他队列包含了 串行和并发。 主队列：主队列 上的任务时在 主线程 执行的 其他队列（非主队列）：加入到 非队列 中的任务 默认就是并发，开启多线程 12345678910111213141516171819202122232425262728293031- (void)testNSOperationQueue&#123; /* NSInvocationOperation 和 NSBlockOperation 两者之间的区别在于： - 前者类似target形式 - 后者类似block形式——函数式编程，业务逻辑代码可读性更高 NSOperationQueue 是异步执行的，所以 任务一、任务二的完成顺序不确定 */ // 初始化事务 NSBlockOperation * bo = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;任务1——%@&quot;,[NSThread currentThread]); &#125;]; // 添加事务 [bo addExecutionBlock:^&#123; NSLog(@&quot;任务2——%@&quot;,[NSThread currentThread]); &#125;]; // 回调监听 bo.completionBlock = ^&#123; NSLog(@&quot;完成了!!!&quot;); &#125;; NSOperationQueue * queue = [[NSOperationQueue alloc] init]; [queue addOperation:bo]; NSLog(@&quot;事务添加加进了NSOperationQueue&quot;);&#125;// 打印结果2022-02-25 15:28:17.704473+0800 NSThread_Demo[5720:4246238] 事务添加加进了NSOperationQueue2022-02-25 15:28:17.704513+0800 NSThread_Demo[5720:4246260] 任务1——&lt;NSThread: 0x282f6c340&gt;&#123;number = 5, name = (null)&#125;2022-02-25 15:28:17.704552+0800 NSThread_Demo[5720:4246260] 任务2——&lt;NSThread: 0x282f6c340&gt;&#123;number = 5, name = (null)&#125;2022-02-25 15:28:17.704602+0800 NSThread_Demo[5720:4246260] 完成了!!! 设值执行顺序 123456789101112131415- (void)testQueueSequence&#123; NSOperationQueue * queue = [[NSOperationQueue alloc] init]; for (int i = 0; i &lt; 5; i ++) &#123; [queue addOperationWithBlock:^&#123; NSLog(@&quot;%@ --- %d&quot;,[NSThread currentThread],i); &#125;]; &#125;&#125;// 打印结果2022-03-08 09:11:03.759862+0800 NSThread_Demo[4217:3030339] &lt;NSThread: 0x281b90240&gt;&#123;number = 3, name = (null)&#125; --- 12022-03-08 09:11:03.760398+0800 NSThread_Demo[4217:3030384] &lt;NSThread: 0x281be7a80&gt;&#123;number = 7, name = (null)&#125; --- 32022-03-08 09:11:03.760526+0800 NSThread_Demo[4217:3030340] &lt;NSThread: 0x281b830c0&gt;&#123;number = 6, name = (null)&#125; --- 22022-03-08 09:11:03.760655+0800 NSThread_Demo[4217:3030339] &lt;NSThread: 0x281b90240&gt;&#123;number = 3, name = (null)&#125; --- 42022-03-08 09:11:03.760697+0800 NSThread_Demo[4217:3030343] &lt;NSThread: 0x281b84280&gt;&#123;number = 5, name = (null)&#125; --- 0 设置优先级123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051- (void)testOperationQuality&#123; /* NSOperation设值优先级只会让CPU有更高的几率调用，不是说设值高就一定全部先完成 - 不适用sleep —— 高优先级的任务先于低优先级的任务 - 使用sleep进行延时 —— 高优先级的任务慢于低优先级的任务 */ NSBlockOperation * bo1 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 5; i ++) &#123; // sleep(1); NSLog(@&quot;第一个操作 %d --- %@&quot;,i,[NSThread currentThread]); &#125; &#125;]; // 设置最高优先级 bo1.qualityOfService = NSQualityOfServiceUserInteractive; NSBlockOperation * bo2 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 5; i ++) &#123; NSLog(@&quot;第二个操作 %d --- %@&quot;,i,[NSThread currentThread]); &#125; &#125;]; // 设置最低优先级 bo2.qualityOfService = NSQualityOfServiceBackground; NSOperationQueue * queue = [[NSOperationQueue alloc] init]; [queue addOperation:bo1]; [queue addOperation:bo2];&#125;// 不使用sleep的打印结果2022-03-08 09:23:44.072325+0800 NSThread_Demo[4220:3035578] 第一个操作 0 --- &lt;NSThread: 0x2826ac100&gt;&#123;number = 4, name = (null)&#125;2022-03-08 09:23:44.072420+0800 NSThread_Demo[4220:3035578] 第一个操作 1 --- &lt;NSThread: 0x2826ac100&gt;&#123;number = 4, name = (null)&#125;2022-03-08 09:23:44.072448+0800 NSThread_Demo[4220:3035578] 第一个操作 2 --- &lt;NSThread: 0x2826ac100&gt;&#123;number = 4, name = (null)&#125;2022-03-08 09:23:44.072516+0800 NSThread_Demo[4220:3035578] 第一个操作 3 --- &lt;NSThread: 0x2826ac100&gt;&#123;number = 4, name = (null)&#125;2022-03-08 09:23:44.072447+0800 NSThread_Demo[4220:3035582] 第二个操作 0 --- &lt;NSThread: 0x2826a8300&gt;&#123;number = 5, name = (null)&#125;2022-03-08 09:23:44.072555+0800 NSThread_Demo[4220:3035578] 第一个操作 4 --- &lt;NSThread: 0x2826ac100&gt;&#123;number = 4, name = (null)&#125;2022-03-08 09:23:44.073242+0800 NSThread_Demo[4220:3035582] 第二个操作 1 --- &lt;NSThread: 0x2826a8300&gt;&#123;number = 5, name = (null)&#125;2022-03-08 09:23:44.073345+0800 NSThread_Demo[4220:3035582] 第二个操作 2 --- &lt;NSThread: 0x2826a8300&gt;&#123;number = 5, name = (null)&#125;2022-03-08 09:23:44.073484+0800 NSThread_Demo[4220:3035582] 第二个操作 3 --- &lt;NSThread: 0x2826a8300&gt;&#123;number = 5, name = (null)&#125;2022-03-08 09:23:44.073546+0800 NSThread_Demo[4220:3035582] 第二个操作 4 --- &lt;NSThread: 0x2826a8300&gt;&#123;number = 5, name = (null)&#125;// 使用sleep的打印结果2022-03-08 09:25:01.471850+0800 NSThread_Demo[4223:3036749] 第二个操作 0 --- &lt;NSThread: 0x282c1de40&gt;&#123;number = 4, name = (null)&#125;2022-03-08 09:25:01.472242+0800 NSThread_Demo[4223:3036749] 第二个操作 1 --- &lt;NSThread: 0x282c1de40&gt;&#123;number = 4, name = (null)&#125;2022-03-08 09:25:01.472334+0800 NSThread_Demo[4223:3036749] 第二个操作 2 --- &lt;NSThread: 0x282c1de40&gt;&#123;number = 4, name = (null)&#125;2022-03-08 09:25:01.472867+0800 NSThread_Demo[4223:3036749] 第二个操作 3 --- &lt;NSThread: 0x282c1de40&gt;&#123;number = 4, name = (null)&#125;2022-03-08 09:25:01.473057+0800 NSThread_Demo[4223:3036749] 第二个操作 4 --- &lt;NSThread: 0x282c1de40&gt;&#123;number = 4, name = (null)&#125;2022-03-08 09:25:02.472831+0800 NSThread_Demo[4223:3036750] 第一个操作 0 --- &lt;NSThread: 0x282c4c080&gt;&#123;number = 5, name = (null)&#125;2022-03-08 09:25:03.474228+0800 NSThread_Demo[4223:3036750] 第一个操作 1 --- &lt;NSThread: 0x282c4c080&gt;&#123;number = 5, name = (null)&#125;2022-03-08 09:25:04.475736+0800 NSThread_Demo[4223:3036750] 第一个操作 2 --- &lt;NSThread: 0x282c4c080&gt;&#123;number = 5, name = (null)&#125;2022-03-08 09:25:05.477191+0800 NSThread_Demo[4223:3036750] 第一个操作 3 --- &lt;NSThread: 0x282c4c080&gt;&#123;number = 5, name = (null)&#125;2022-03-08 09:25:06.478576+0800 NSThread_Demo[4223:3036750] 第一个操作 4 --- &lt;NSThread: 0x282c4c080&gt;&#123;number = 5, name = (null)&#125; 设置并发数123456789101112131415161718192021222324- (void)testOperationMaxCount&#123; /* 在GCD中只能使用信号量来设置并发数 而NSOperation轻易就能设置并发数 通过设置maxConcurrentOperationCount来控制单次队列去执行的任务数 */ NSOperationQueue * queue = [[NSOperationQueue alloc] init]; queue.name = @&quot;Felix&quot;; queue.maxConcurrentOperationCount = 2; for (int i = 0; i &lt; 5; i ++) &#123; [queue addOperationWithBlock:^&#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;%d -- %@&quot;,i,[NSThread currentThread]); &#125;]; &#125;&#125;// 查看打印结果2022-03-08 11:12:55.459322+0800 NSThread_Demo[4293:3074227] 0 -- &lt;NSThread: 0x283260080&gt;&#123;number = 4, name = (null)&#125;2022-03-08 11:12:55.459326+0800 NSThread_Demo[4293:3074223] 1 -- &lt;NSThread: 0x283264140&gt;&#123;number = 3, name = (null)&#125;2022-03-08 11:12:57.463085+0800 NSThread_Demo[4293:3074223] 3 -- &lt;NSThread: 0x283264140&gt;&#123;number = 3, name = (null)&#125;2022-03-08 11:12:57.464903+0800 NSThread_Demo[4293:3074227] 2 -- &lt;NSThread: 0x283260080&gt;&#123;number = 4, name = (null)&#125;2022-03-08 11:12:59.468845+0800 NSThread_Demo[4293:3074225] 4 -- &lt;NSThread: 0x2832724c0&gt;&#123;number = 6, name = (null)&#125; 添加依赖123456789101112131415161718192021222324252627282930- (void)testOperationDependency&#123; NSOperationQueue * queue = [[NSOperationQueue alloc] init]; NSBlockOperation * bo1 = [NSBlockOperation blockOperationWithBlock:^&#123; [NSThread sleepForTimeInterval:0.5]; NSLog(@&quot;请求token&quot;); &#125;]; NSBlockOperation * bo2 = [NSBlockOperation blockOperationWithBlock:^&#123; [NSThread sleepForTimeInterval:0.5]; NSLog(@&quot;拿着token，请求数据1&quot;); &#125;]; NSBlockOperation * bo3 = [NSBlockOperation blockOperationWithBlock:^&#123; [NSThread sleepForTimeInterval:0.5]; NSLog(@&quot;拿着数据1，请求数据2&quot;); &#125;]; [bo2 addDependency:bo1]; [bo3 addDependency:bo2]; [queue addOperations:@[bo1,bo2,bo3] waitUntilFinished:YES]; NSLog(@&quot;执行完成了？我要干其他事情了&quot;);&#125;// 查看打印结果2022-03-08 11:17:14.425701+0800 NSThread_Demo[4295:3076256] 请求token2022-03-08 11:17:14.931254+0800 NSThread_Demo[4295:3076255] 拿着token，请求数据12022-03-08 11:17:15.436695+0800 NSThread_Demo[4295:3076258] 拿着数据1，请求数据22022-03-08 11:17:15.437079+0800 NSThread_Demo[4295:3076238] 执行完成了？我要干其他事情了 线程间通讯123456789101112131415- (void)testOperationNoti&#123; NSOperationQueue * queue = [[NSOperationQueue alloc] init]; queue.name = @&quot;Felix&quot;; [queue addOperationWithBlock:^&#123; NSLog(@&quot;请求网络%@ -- %@&quot;,[NSOperationQueue currentQueue],[NSThread currentThread]); [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; NSLog(@&quot;刷新UI%@ -- %@&quot;,[NSOperationQueue currentQueue],[NSThread currentThread]); &#125;]; &#125;];&#125;// 查看打印结果2022-03-08 11:20:27.970126+0800 NSThread_Demo[4297:3077823] 请求网络&lt;NSOperationQueue: 0x10bd087d0&gt;&#123;name = &#x27;Felix&#x27;&#125; -- &lt;NSThread: 0x28206b140&gt;&#123;number = 4, name = (null)&#125;2022-03-08 11:20:27.976293+0800 NSThread_Demo[4297:3077803] 刷新UI&lt;NSOperationQueue: 0x10d005570&gt;&#123;name = &#x27;NSOperationQueue Main Queue&#x27;&#125; -- &lt;_NSMainThread: 0x28206c880&gt;&#123;number = 1, name = main&#125;","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理26：GCD之函数与队列","slug":"OC进阶/OC底层原理26：GCD之函数与队列","date":"2021-03-10T06:45:48.000Z","updated":"2022-03-08T03:55:35.000Z","comments":true,"path":"2021/03/10/OC进阶/OC底层原理26：GCD之函数与队列/","link":"","permalink":"https://www.bboyzj.cn/2021/03/10/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8626%EF%BC%9AGCD%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%8E%E9%98%9F%E5%88%97/","excerpt":"","text":"GCD简介1、什么是GCD？ 全称是 Grand Central Dispatch，纯 C 语言，提供了非常强大的函数 2、GCD 的优势 GCD 是苹果公司为多核的并行运算提出的解决方案 GCD 会自动利用更多的 CPU 内核（比如双核、四核） GCD 会自动管理线程的声明周期（创建线程、调度任务、销毁线程） 程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码 【重点】用一句话总结 GCD ： 将任务添加到队列，并且指定执行任务的函数。 GCD 核心在日常开发中，GCD一般写成下面的形式 123diaptch_async(dispatch_queue_create(&quot;com.zj.Queue&quot;,NULL)), ^&#123; NSLog(@&quot;GCD基本使用&quot;)&#125;); 将上述代码拆分，方便我们来理解 GCD 的 核心，主要是由 任务 + 队列 + 函数 构成 123456789//*****GCD基础写法*****// 创建任务dispatch_block_t block= ^&#123; NSLog(@&quot;hello GCD&quot;);&#125;// 创建队列dispatch_queue_t queue = dispatch_queue_create(&quot;com.zj.Queue&quot;,NULL);// 将任务添加到队列，并指定函数执行dispatch_async(queue,block); dispatch_block_t：创建任务 dispatch_queue_t：创建队列 dispatch_async：函数 函数和队列1、在GCD中函数按照执行方式分为 同步函数 和 异步函数 同步函数：dispatch_sync 必须等待当前语句执行完毕，才会执行下一条语句 不会开启线程，即不具备开启新线程的能力 在当前执行 block 任务 异步函数：dispatch_async 会开启新的线程执行 block 任务 异步是多线程的代名词 综上所述，两种执行方式的 主要区别 有两点： 是否等待 队列的任务执行完毕 是否具备开启新线程 的能力 2、队列 在GCD中队列是用来 存放任务，是一种特殊的 线性表，遵循 FIFO（先进先出） 原则，新任务总是被 插入到队尾，而任务的读取是从 队首开始读取，每读一个任务，则队列中释放一个任务，如下图所示： 队列主要分为 串行队列（Serial Dispatch Queue） 和 并发队列(Concurrent Dispatch Queue) 两种，如下图所示 串行队列：每次 只有一个任务被执行，等待上一个任务执行完毕再执行下一个，即只开启一个线程（通俗理解：同一时刻只调度一个任务执行） 使用 dispatch_queue_create(&quot;xxx&quot;,DISPATCH_QUEUE_SERIAL) 创建串行队列 其中 DISPATCH_QUEUE_SERIAL 也可以用 NULL 表示，这两种均表示 默认的串行队列 1234// 串行队列的获取方法dispatch_queue_t serialQueue1 = dispatch_queue_create(&quot;com.ZJ.Queue&quot;,DISPATCH_QUQUQ_SERIAL);dispatch_quque_t serialQuquq2 = dispatch_ququq_create(&quot;com.ZJ.Queue&quot;,Null); 并发队列：一次可以 并发执行多个任务，即 开启多个线程，并同时执行任务（通俗理解：同意时刻可以调度多个任务执行） 使用 dispach_queue_create(&quot;xxx&quot;,DISPATCH_QUQUQ_CONCURRENT) 创建并发队列 注意：并发队列 的并发功能 只有在异步函数下才有效 12// 并发队列的获取方法dispatch_quque_t concurrentQueue = dispatch_quque_create(&quot;com.ZJ.Queue&quot;,DISPATCH_QUQUE_CONCURRENT); 主队列 和 全局并发队列在GCD中，针对这两种队列，分别提供了 主队列（Main Dispatch Queue） 和 全局并发队列（Global Dispatch Queue） 主队列（Main Dispatch Queue）：GCD 中提供的 特殊的串行队列 专门用来 在主线程上调度任务的串行队列，依赖于主线程、主Runloop，在main函数调用之前 自动创建 不会开启线程 如果当前主线程正在有任务执行，那么无论主队列中当前被添加了什么任务，都不会被调用 使用 dispatch_get_main_queue() 获得 主队列 通常在返回 主线程 更新UI 时使用 12// 主队列的获取方法dispatch_queue_t mainQueue = dispatch_get_main_queue(); 全局并发队列（Global Dispatch Queue）：GCD 提供的默认的 并发队列 为了方便程序员使用，苹果提供了全局队列 在使用多线程开发时，如果对队列没有特殊要求，在执行异步任务时，可以直接使用全局队列 使用 dispatch_get_global_queue 获取全局并发队列，最简单的是 dispatch_get_global_queue(0,0) 第一个参数表示 队列优先级，默认优先级未 DISPATCH_QUEUE_PRIORITY_DEFAULT=0，在iOS9之后，已经被 服务质量（quality-of-service） 取代 第二个参数使用 0 12345678// 全集并发队列的获取方法dispatch_queue_t globalQueue = dispatch_get_global_queue(0,0);// 优先级从高到底（对应的服务质量）依次为- DISPATCH_QUEUE_PRIORITY_HIGH: QOS_CLASS_USER_INITIATED- DISPATCH_QUEUE_PRIORITY_DEFAULT: QOS_CLASS_DEFAULT- DISPATCH_QUEUE_PRIORITY_LOW: QOS_CLASS_UTILITY- DISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_BACKGROUND 全局并发队列 + 主队列 配合使用在日常开发中， 全局队列 + 并发队列 一般是这样配合使用的 1234567// 主队列 + 全局并发队列 的日常使用dispatch_async(dispatch_get_global_queue(0,0), ^&#123; // 执行耗时操作 dispatch_async(dispatch_get_main_queue(),^&#123; // 回到主线程进行UI操作 &#125;);&#125;); 函数与队列的不同组合 串行队列 + 同步函数 【任务 按顺序执行】：任务一个接一个的在当前线程执行，不会开辟新线程 12345678910// 串行队列 + 同步函数- (void)test1&#123; NSLog(@&quot;串行 + 同步：%@&quot;,[NSThread currentThread]); dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, DISPATCH_QUEUE_SERIAL); for (int i = 0; i &lt; 5; i ++) &#123; dispatch_sync(serialQueue, ^&#123; NSLog(@&quot;串行 + 同步：%d - %@&quot;,i,[NSThread currentThread]); &#125;); &#125;&#125; 运行代码，查看打印结果如下 1234562022-01-12 15:13:39.595134+0800 GCD之函数和队列[4500:155055] 串行 + 同步：&lt;_NSMainThread: 0x6000025d00c0&gt;&#123;number = 1, name = main&#125;2022-01-12 15:13:39.595275+0800 GCD之函数和队列[4500:155055] 串行 + 同步：0 - &lt;_NSMainThread: 0x6000025d00c0&gt;&#123;number = 1, name = main&#125;2022-01-12 15:13:39.595388+0800 GCD之函数和队列[4500:155055] 串行 + 同步：1 - &lt;_NSMainThread: 0x6000025d00c0&gt;&#123;number = 1, name = main&#125;2022-01-12 15:13:39.595512+0800 GCD之函数和队列[4500:155055] 串行 + 同步：2 - &lt;_NSMainThread: 0x6000025d00c0&gt;&#123;number = 1, name = main&#125;2022-01-12 15:13:39.595639+0800 GCD之函数和队列[4500:155055] 串行 + 同步：3 - &lt;_NSMainThread: 0x6000025d00c0&gt;&#123;number = 1, name = main&#125;2022-01-12 15:13:39.595759+0800 GCD之函数和队列[4500:155055] 串行 + 同步：4 - &lt;_NSMainThread: 0x6000025d00c0&gt;&#123;number = 1, name = main&#125; 串行队列 + 异步函数 【任务 按顺序执行】：任务一个接一个的执行，会 开辟新线程 12345678910// 串行队列 + 异步函数- (void)test2&#123; NSLog(@&quot;串行 + 异步：%@&quot;,[NSThread currentThread]); dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, NULL); for (int i = 0; i &lt; 5; i ++) &#123; dispatch_async(serialQueue, ^&#123; NSLog(@&quot;串行 + 异步：%d - %@&quot;,i,[NSThread currentThread]); &#125;); &#125;&#125; 运行代码，查看打印结果如下 1234562022-01-12 15:20:12.884840+0800 GCD之函数和队列[4590:160591] 串行 + 异步：&lt;_NSMainThread: 0x600000ee4140&gt;&#123;number = 1, name = main&#125;2022-01-12 15:20:12.885010+0800 GCD之函数和队列[4590:160734] 串行 + 异步：0 - &lt;NSThread: 0x600000eb01c0&gt;&#123;number = 3, name = (null)&#125;2022-01-12 15:20:12.885136+0800 GCD之函数和队列[4590:160734] 串行 + 异步：1 - &lt;NSThread: 0x600000eb01c0&gt;&#123;number = 3, name = (null)&#125;2022-01-12 15:20:12.885262+0800 GCD之函数和队列[4590:160734] 串行 + 异步：2 - &lt;NSThread: 0x600000eb01c0&gt;&#123;number = 3, name = (null)&#125;2022-01-12 15:20:12.885392+0800 GCD之函数和队列[4590:160734] 串行 + 异步：3 - &lt;NSThread: 0x600000eb01c0&gt;&#123;number = 3, name = (null)&#125;2022-01-12 15:20:12.885538+0800 GCD之函数和队列[4590:160734] 串行 + 异步：4 - &lt;NSThread: 0x600000eb01c0&gt;&#123;number = 3, name = (null)&#125; 并发队列 + 同步函数 【任务 按顺序执行】：任务一个接一个的执行，不开辟新线程 12345678910// 并发队列 + 同步函数- (void)test3&#123; NSLog(@&quot;并发 + 同步：%@&quot;,[NSThread currentThread]); dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, DISPATCH_QUEUE_CONCURRENT); for (int i = 0; i &lt; 5; i ++) &#123; dispatch_sync(serialQueue, ^&#123; NSLog(@&quot;并发 + 同步：%d - %@&quot;,i,[NSThread currentThread]); &#125;); &#125;&#125; 运行代码，查看打印结果如下 12345622-01-12 15:23:15.939687+0800 GCD之函数和队列[4630:163688] 并发 + 同步：&lt;_NSMainThread: 0x600000de8000&gt;&#123;number = 1, name = main&#125;2022-01-12 15:23:15.939830+0800 GCD之函数和队列[4630:163688] 并发 + 同步：0 - &lt;_NSMainThread: 0x600000de8000&gt;&#123;number = 1, name = main&#125;2022-01-12 15:23:15.939922+0800 GCD之函数和队列[4630:163688] 并发 + 同步：1 - &lt;_NSMainThread: 0x600000de8000&gt;&#123;number = 1, name = main&#125;2022-01-12 15:23:15.940014+0800 GCD之函数和队列[4630:163688] 并发 + 同步：2 - &lt;_NSMainThread: 0x600000de8000&gt;&#123;number = 1, name = main&#125;2022-01-12 15:23:15.940102+0800 GCD之函数和队列[4630:163688] 并发 + 同步：3 - &lt;_NSMainThread: 0x600000de8000&gt;&#123;number = 1, name = main&#125;2022-01-12 15:23:15.940217+0800 GCD之函数和队列[4630:163688] 并发 + 同步：4 - &lt;_NSMainThread: 0x600000de8000&gt;&#123;number = 1, name = main&#125; 并发队列 + 异步函数 【任务 乱序执行】：任务执行无顺序，会 开辟新线程 12345678910// 并发队列 + 异步函数- (void)test4&#123; NSLog(@&quot;并发 + 异步：%@&quot;,[NSThread currentThread]); dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, DISPATCH_QUEUE_CONCURRENT); for (int i = 0; i &lt; 5; i ++) &#123; dispatch_async(serialQueue, ^&#123; NSLog(@&quot;并发 + 异步：%d - %@&quot;,i,[NSThread currentThread]); &#125;); &#125;&#125; 运行代码，查看打印结果如下 1234562022-01-12 15:26:35.249949+0800 GCD之函数和队列[4716:166604] 并发 + 异步：&lt;_NSMainThread: 0x600003344740&gt;&#123;number = 1, name = main&#125;2022-01-12 15:26:35.250144+0800 GCD之函数和队列[4716:166729] 并发 + 异步：0 - &lt;NSThread: 0x60000332c100&gt;&#123;number = 7, name = (null)&#125;2022-01-12 15:26:35.250153+0800 GCD之函数和队列[4716:166735] 并发 + 异步：1 - &lt;NSThread: 0x600003300d40&gt;&#123;number = 6, name = (null)&#125;2022-01-12 15:26:35.250174+0800 GCD之函数和队列[4716:166734] 并发 + 异步：3 - &lt;NSThread: 0x60000330f0c0&gt;&#123;number = 4, name = (null)&#125;2022-01-12 15:26:35.250238+0800 GCD之函数和队列[4716:166731] 并发 + 异步：4 - &lt;NSThread: 0x600003328040&gt;&#123;number = 8, name = (null)&#125;2022-01-12 15:26:35.250277+0800 GCD之函数和队列[4716:166733] 并发 + 异步：2 - &lt;NSThread: 0x600003305c40&gt;&#123;number = 3, name = (null)&#125; 主队列 + 同步函数 【造成 死锁】：任务 相互等待，造成 死锁 造成死锁的原因分析如下： 主队列有两个任务，顺序为： NSLog任务 - 同步block 执行NSLog任务后，执行同步的block，会将 任务1（即 i=1） 加入到主队列，主队列顺序为 ：NSLog任务 - 同步block - 任务1 任务1 的执行需要 等待同步block执行完毕 才会执行，而 同步block 的执行需要 等待任务1执行完毕，所以就造成了 互相等待 的情况，即造成 死锁崩溃。 【死锁现象】 主线程 因为你 同步函数 的原因 等着先执行任务 主队列等着主线程的任务 执行完毕再执行自己的任务 主队列和主线程相互等待 会造成死锁 主队列 + 异步函数 【任务 按顺序执行】：任务一个接一个的执行，不开辟线程 12345678910// 主队列 + 异步函数- (void)test6&#123; NSLog(@&quot;主队列 + 异步：%@&quot;,[NSThread currentThread]); dispatch_queue_t mainQueue = dispatch_get_main_queue(); for (int i = 0; i &lt; 5; i ++) &#123; dispatch_async(mainQueue, ^&#123; NSLog(@&quot;主队列 + 异步：%d - %@&quot;,i,[NSThread currentThread]); &#125;); &#125;&#125; 运行代码，查看打印结果如下 1234562022-01-12 16:27:53.197940+0800 GCD之函数和队列[5926:204672] 主队列 + 异步：&lt;_NSMainThread: 0x600001880000&gt;&#123;number = 1, name = main&#125;2022-01-12 16:27:53.213528+0800 GCD之函数和队列[5926:204672] 主队列 + 异步：0 - &lt;_NSMainThread: 0x600001880000&gt;&#123;number = 1, name = main&#125;2022-01-12 16:27:53.213718+0800 GCD之函数和队列[5926:204672] 主队列 + 异步：1 - &lt;_NSMainThread: 0x600001880000&gt;&#123;number = 1, name = main&#125;2022-01-12 16:27:53.213879+0800 GCD之函数和队列[5926:204672] 主队列 + 异步：2 - &lt;_NSMainThread: 0x600001880000&gt;&#123;number = 1, name = main&#125;2022-01-12 16:27:53.214016+0800 GCD之函数和队列[5926:204672] 主队列 + 异步：3 - &lt;_NSMainThread: 0x600001880000&gt;&#123;number = 1, name = main&#125;2022-01-12 16:27:53.214196+0800 GCD之函数和队列[5926:204672] 主队列 + 异步：4 - &lt;_NSMainThread: 0x600001880000&gt;&#123;number = 1, name = main&#125; 全局并发队列 + 同步函数 【任务 按顺序执行】：任务一个接一个的执行，不开辟新线程 12345678910// 全局并发队列 + 同步函数- (void)test7&#123; NSLog(@&quot;全局并发 + 同步：%@&quot;,[NSThread currentThread]); dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0); for (int i = 0; i &lt; 5; i ++) &#123; dispatch_sync(globalQueue, ^&#123; NSLog(@&quot;全局并发 + 同步：%d - %@&quot;,i,[NSThread currentThread]); &#125;); &#125;&#125; 运行代码，查看打印结果如下 1234562022-01-12 16:32:08.207844+0800 GCD之函数和队列[6000:209221] 全局并发 + 同步：&lt;_NSMainThread: 0x60000031c140&gt;&#123;number = 1, name = main&#125;2022-01-12 16:32:08.207992+0800 GCD之函数和队列[6000:209221] 全局并发 + 同步：0 - &lt;_NSMainThread: 0x60000031c140&gt;&#123;number = 1, name = main&#125;2022-01-12 16:32:08.208098+0800 GCD之函数和队列[6000:209221] 全局并发 + 同步：1 - &lt;_NSMainThread: 0x60000031c140&gt;&#123;number = 1, name = main&#125;2022-01-12 16:32:08.208280+0800 GCD之函数和队列[6000:209221] 全局并发 + 同步：2 - &lt;_NSMainThread: 0x60000031c140&gt;&#123;number = 1, name = main&#125;2022-01-12 16:32:08.208400+0800 GCD之函数和队列[6000:209221] 全局并发 + 同步：3 - &lt;_NSMainThread: 0x60000031c140&gt;&#123;number = 1, name = main&#125;2022-01-12 16:32:08.208504+0800 GCD之函数和队列[6000:209221] 全局并发 + 同步：4 - &lt;_NSMainThread: 0x60000031c140&gt;&#123;number = 1, name = main&#125; 全局并发队列 + 异步函数 【任务 乱序执行】：任务乱序执行，会开辟新线程 12345678910// 全局并发队列 + 异步函数- (void)test8&#123; NSLog(@&quot;全局并发 + 异步：%@&quot;,[NSThread currentThread]); dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0); for (int i = 0; i &lt; 5; i ++) &#123; dispatch_async(globalQueue, ^&#123; NSLog(@&quot;全局并发 + 异步：%d - %@&quot;,i,[NSThread currentThread]); &#125;); &#125;&#125; 运行代码，查看打印结果如下 1234562022-01-12 16:34:18.147614+0800 GCD之函数和队列[6082:211916] 全局并发 + 异步：&lt;_NSMainThread: 0x600002cd8340&gt;&#123;number = 1, name = main&#125;2022-01-12 16:34:18.147839+0800 GCD之函数和队列[6082:212058] 全局并发 + 异步：1 - &lt;NSThread: 0x600002cdcdc0&gt;&#123;number = 4, name = (null)&#125;2022-01-12 16:34:18.147859+0800 GCD之函数和队列[6082:212057] 全局并发 + 异步：0 - &lt;NSThread: 0x600002c97640&gt;&#123;number = 3, name = (null)&#125;2022-01-12 16:34:18.147880+0800 GCD之函数和队列[6082:212052] 全局并发 + 异步：2 - &lt;NSThread: 0x600002cb9140&gt;&#123;number = 7, name = (null)&#125;2022-01-12 16:34:18.147880+0800 GCD之函数和队列[6082:212053] 全局并发 + 异步：3 - &lt;NSThread: 0x600002c972c0&gt;&#123;number = 5, name = (null)&#125;2022-01-12 16:34:18.147892+0800 GCD之函数和队列[6082:212055] 全局并发 + 异步：4 - &lt;NSThread: 0x600002c80000&gt;&#123;number = 8, name = (null)&#125; 总结 函数\\队列 串行队列 并发队列 主队列 全局并发队列 同步函数 顺序执行，不开辟新线程 顺序执行，不开辟新线程 死锁 顺序执行，不开辟新线程 异步函数 顺序执行，开辟新线程 乱序执行，开辟新线程 顺序执行，不开破新线程 乱序执行，开辟先线程 相关面试题解析 【面试题-1】：并行队列 + 异步函数 下面代码的输出顺序是什么？ 123456789101112131415- (void)interview01&#123; // 并发队列 dispatch_queue_t queue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, DISPATCH_QUEUE_CONCURRENT); NSLog(@&quot;1 %@&quot;,[NSThread currentThread]); // 耗时 dispatch_async(queue, ^&#123; NSLog(@&quot;2 %@&quot;,[NSThread currentThread]); // 耗时 dispatch_async(queue, ^&#123; NSLog(@&quot;3 %@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;4 %@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;5 %@&quot;,[NSThread currentThread]);&#125; 运行代码，查看打印结果如下 123452022-01-12 16:50:01.867461+0800 GCD之函数和队列[6319:225209] 1 &lt;_NSMainThread: 0x6000023f4840&gt;&#123;number = 1, name = main&#125;2022-01-12 16:50:01.867626+0800 GCD之函数和队列[6319:225209] 5 &lt;_NSMainThread: 0x6000023f4840&gt;&#123;number = 1, name = main&#125;2022-01-12 16:50:01.867695+0800 GCD之函数和队列[6319:225342] 2 &lt;NSThread: 0x600002399ec0&gt;&#123;number = 6, name = (null)&#125;2022-01-12 16:50:01.867840+0800 GCD之函数和队列[6319:225342] 4 &lt;NSThread: 0x600002399ec0&gt;&#123;number = 6, name = (null)&#125;2022-01-12 16:50:01.867852+0800 GCD之函数和队列[6319:225345] 3 &lt;NSThread: 0x6000023a8b00&gt;&#123;number = 4, name = (null)&#125; 异步函数 并 不会阻塞 主队列，会开辟新线程 执行异步任务 代码分析：如下图所示，红线表示任务的执行顺序 主线程 的任务队列为：任务1、异步block1、任务5，其中 异步block1 会比较耗费性能，任务1 和 任务5 的任务复杂度是相同的，所以 任务1 和 任务5 优先于 异步block1 执行 在 异步block1 中，任务队列为：任务2、异步block2、任务4，其中 block2 相对比较耗费性能，任务2 和 任务4 复杂度一样，所以 任务2 和 任务4 优先于 block2 执行 最后执行 block2 中的 任务3 在极端情况下，可能会出现 任务2 优先 任务1 和 任务5 执行，原因是出现了当前主线程卡顿或者延迟 的情况 代码修改 【修改1】：将 并行队列 改成 串行队列，对结果没有任何影响，顺序仍然是 15243 【修改2】：在 任务5 之前，休眠2s，即 sleep(2)，执行的顺序为：12435，原因是因为 I&#x2F;O 的打印，相比于休眠 2s，复杂度更简单，所以 异步block1 会优先于任务5执行。当然如果主队列阻塞，会出现其他的执行顺序。 【面试题-2】：并发队列 + 异步函数嵌套同步函数 下面代码的输出顺序是什么？ 123456789101112131415- (void)interview2&#123; // 并发队列 dispatch_queue_t queue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, DISPATCH_QUEUE_CONCURRENT); NSLog(@&quot;1 %@&quot;,[NSThread currentThread]); //异步函数 dispatch_async(queue, ^&#123; NSLog(@&quot;2 %@&quot;,[NSThread currentThread]); // 同步函数 dispatch_sync(queue, ^&#123; NSLog(@&quot;3 %@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;4 %@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;5 %@&quot;,[NSThread currentThread]);&#125; 运行代码，查看打印结果如下 123452022-01-12 17:37:11.034204+0800 GCD之函数和队列[7126:263322] 1 &lt;_NSMainThread: 0x600000074300&gt;&#123;number = 1, name = main&#125;2022-01-12 17:37:11.034340+0800 GCD之函数和队列[7126:263322] 5 &lt;_NSMainThread: 0x600000074300&gt;&#123;number = 1, name = main&#125;2022-01-12 17:37:11.034378+0800 GCD之函数和队列[7126:263438] 2 &lt;NSThread: 0x600000039c40&gt;&#123;number = 3, name = (null)&#125;2022-01-12 17:37:11.034494+0800 GCD之函数和队列[7126:263438] 3 &lt;NSThread: 0x600000039c40&gt;&#123;number = 3, name = (null)&#125;2022-01-12 17:37:11.034625+0800 GCD之函数和队列[7126:263438] 4 &lt;NSThread: 0x600000039c40&gt;&#123;number = 3, name = (null)&#125; 代码分析： 任务1、block1、任务5 的分析和前面一致，执行顺序为：任务1 任务5 block1 在 异步block1 中，任务2、block2、任务4 的执行顺序，由于 block2 是同步函数会阻塞当前线程，所以 任务4 需要等待 block2 中的 任务3 执行完成后，才能执行，所以异步block中的执行顺序是：任务2、任务3、任务4 【面试题-3】：串行队列 + 异步函数嵌套同步函数 下面代码的输出顺序是什么？会出现什么情况？为什么？ 123456789101112131415- (void)interview3&#123; // 串行队列 dispatch_queue_t queue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, DISPATCH_QUEUE_SERIAL); NSLog(@&quot;1 %@&quot;,[NSThread currentThread]); //异步函数 dispatch_async(queue, ^&#123; NSLog(@&quot;2 %@&quot;,[NSThread currentThread]); // 同步函数 dispatch_sync(queue, ^&#123; NSLog(@&quot;3 %@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;4 %@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;5 %@&quot;,[NSThread currentThread]);&#125; 运行代码，查看打印结果如下 分析： 如下图所示，红色代表任务执行顺序，黄色线表示等待 首先，在主线程上有 任务1、异步block、任务5，首先执行 任务1，由于 异步block 复杂度高于 任务5，因此，执行顺序是 任务1 -&gt; 任务5 -&gt; 异步block 在异步block中，开启了新的线程，执行顺序首先是 任务2，然后是 同步block，同步函数会阻塞当前线程，所以执行 任务4 需要 等待任务3完成，由于 任务3的执行，需要 等待异步block完成，异步block完成需要 等待任务4完成， 因此就会造成 任务4等待任务3，任务3等待任务4，即 互相等待 的局面，就会造成 死锁，这里有个重点是 关键的堆栈slow 修改 去掉任务4，执行顺序是什么？ 还是会死锁，因为 任务3等待的是异步block执行完毕，而异步block等待任务3完成 4、【面试题4-新浪】：异步函数 + 同步函数 + 并发队列 下面代码执行的顺序是什么？（答案是AC）A：1230789B：1237890C：3120798D：2137890 12345678910111213141516171819202122232425262728- (void)interview04&#123; // 并发队列 dispatch_queue_t queue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; // 耗时 NSLog(@&quot;1 %@&quot;,[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@&quot;2 %@&quot;,[NSThread currentThread]); &#125;); // 同步 dispatch_sync(queue, ^&#123; NSLog(@&quot;3 %@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;0 %@&quot;,[NSThread currentThread]); dispatch_async(queue, ^&#123; NSLog(@&quot;7 %@&quot;,[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@&quot;8 %@&quot;,[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@&quot;9 %@&quot;,[NSThread currentThread]); &#125;);&#125; 打印结果是： （1、2、3无序） 0 （7、8、9无序），可以确定的 0 一定在 3 之后， 在789之前 分析： 任务1 和 任务2 是由于 异步函数 + 并发队列，会开启线程，所以没有固定顺序 任务7、任务8、任务9同理，会开启线程，所以没有固定顺序 任务3 是 同步函数 + 并发队列，同步函数会 阻塞主线程，但是也只会阻塞0，所以，可以确定的是 0一定在3之后，在789之前 以下是不同的打印结果： 12345672022-01-14 14:45:42.843292+0800 GCD之函数和队列[18838:775240] 3 &lt;_NSMainThread: 0x600001198a00&gt;&#123;number = 1, name = main&#125;2022-01-14 14:45:42.843329+0800 GCD之函数和队列[18838:775341] 1 &lt;NSThread: 0x600001189cc0&gt;&#123;number = 5, name = (null)&#125;2022-01-14 14:45:42.843361+0800 GCD之函数和队列[18838:775340] 2 &lt;NSThread: 0x600001195a40&gt;&#123;number = 7, name = (null)&#125;2022-01-14 14:45:42.843415+0800 GCD之函数和队列[18838:775240] 0 &lt;_NSMainThread: 0x600001198a00&gt;&#123;number = 1, name = main&#125;2022-01-14 14:45:42.843546+0800 GCD之函数和队列[18838:775340] 7 &lt;NSThread: 0x600001195a40&gt;&#123;number = 7, name = (null)&#125;2022-01-14 14:45:42.843628+0800 GCD之函数和队列[18838:775341] 8 &lt;NSThread: 0x600001189cc0&gt;&#123;number = 5, name = (null)&#125;2022-01-14 14:45:42.843653+0800 GCD之函数和队列[18838:775343] 9 &lt;NSThread: 0x60000119ce80&gt;&#123;number = 6, name = (null)&#125; 123456782022-01-14 14:50:18.831754+0800 GCD之函数和队列[18899:780910] 3 &lt;_NSMainThread: 0x600000054a00&gt;&#123;number = 1, name = main&#125;2022-01-14 14:50:18.831835+0800 GCD之函数和队列[18899:781015] 2 &lt;NSThread: 0x600000010e00&gt;&#123;number = 6, name = (null)&#125;2022-01-14 14:50:18.831801+0800 GCD之函数和队列[18899:781016] 1 &lt;NSThread: 0x600000052340&gt;&#123;number = 5, name = (null)&#125;2022-01-14 14:50:18.831887+0800 GCD之函数和队列[18899:780910] 0 &lt;_NSMainThread: 0x600000054a00&gt;&#123;number = 1, name = main&#125;2022-01-14 14:50:18.832053+0800 GCD之函数和队列[18899:781016] 7 &lt;NSThread: 0x600000052340&gt;&#123;number = 5, name = (null)&#125;2022-01-14 14:50:18.832058+0800 GCD之函数和队列[18899:781015] 8 &lt;NSThread: 0x600000010e00&gt;&#123;number = 6, name = (null)&#125;2022-01-14 14:50:18.832082+0800 GCD之函数和队列[18899:781019] 9 &lt;NSThread: 0x600000011b80&gt;&#123;number = 3, name = (null)&#125; 12345672022-01-14 14:51:47.433576+0800 GCD之函数和队列[18934:784384] 3 &lt;_NSMainThread: 0x6000030280c0&gt;&#123;number = 1, name = main&#125;2022-01-14 14:51:47.433577+0800 GCD之函数和队列[18934:784516] 2 &lt;NSThread: 0x6000030741c0&gt;&#123;number = 4, name = (null)&#125;2022-01-14 14:51:47.433578+0800 GCD之函数和队列[18934:784518] 1 &lt;NSThread: 0x60000304d540&gt;&#123;number = 6, name = (null)&#125;2022-01-14 14:51:47.433718+0800 GCD之函数和队列[18934:784384] 0 &lt;_NSMainThread: 0x6000030280c0&gt;&#123;number = 1, name = main&#125;2022-01-14 14:51:47.433880+0800 GCD之函数和队列[18934:784518] 7 &lt;NSThread: 0x60000304d540&gt;&#123;number = 6, name = (null)&#125;2022-01-14 14:51:47.433890+0800 GCD之函数和队列[18934:784513] 9 &lt;NSThread: 0x600003040000&gt;&#123;number = 5, name = (null)&#125;2022-01-14 14:51:47.433891+0800 GCD之函数和队列[18934:784516] 8 &lt;NSThread: 0x6000030741c0&gt;&#123;number = 4, name = (null)&#125; 5、【面试题-5-美团】：下面代码中，队列的类型有几种？ 1234567891011// 串行队列 - Serial Dispatch Queuedispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, NULL); // 并发队列 - Concurrent Dispatch Queuedispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, DISPATCH_QUEUE_CONCURRENT); // 主队列 - Main Dispatch Queuedispatch_queue_t mainQueue = dispatch_get_main_queue(); // 全局并发队列 - Global Dispatch Queuedispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0); 队列总共有两种：串行队列 和 并发队列 串行队列：serialQueue、mainQueue 并发队列：concurrentQueue、globalQueue","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理25：多线程原理探索","slug":"OC进阶/OC底层原理25：多线程原理探索","date":"2021-02-21T01:35:17.000Z","updated":"2023-02-24T15:37:23.453Z","comments":true,"path":"2021/02/21/OC进阶/OC底层原理25：多线程原理探索/","link":"","permalink":"https://www.bboyzj.cn/2021/02/21/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8625%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"前言本文的目的在于了解进程、线程、多线程、线程池 等的基本概念及原理 线程和进程的定义线程 线程是进程的基本执行单元，一个进程的所有任务都在线程中执行 进程要想执行任务，必须得有线程，一个进程至少要有一条线程 程序启动会默认开启一条线程，这条线程被称为主线程 或者 UI线程 进程 进程 是指在 系统中正在运行的一个应用程序 每个进程之间是独立的，每个进程均运行在其专用的且受保护的内存空间内 通过活动监视器可以查看Mac系统中所开启的线程 所以，可以简单的理解为：进程是线程的容器，而线程是用来执行任务的。在iOS中是单进程开发，一个进程就是一个APP，进程之间是相互独立的，如：微信、支付宝、qq等，这些都属于不同的进程。 进程和线程的关系进程和线程之间的关系主要涉及两个方面： 地址空间 同一个进程的线程共享本进程的地址空间 而进程之间则是独立的地址空间 资源拥有 同一个进程内线程共享进程的资源，如内存、I&#x2F;O、cpu等 但是进程之间资源是独立的 进程和线程的关系就相当于工厂和流水线的关系，工厂和工厂之间是相互独立的，而工厂中的流水线是共享工厂的资源的，即进程相当于一个工厂，线程相当于工厂中的一条流水线 针对进程和线程，还有以下几点说明： 1、多进程要比多线程健壮 一个进程崩溃后，在保护模式下不会对其他进程产生影响 而一个线程崩溃后整个进程都死掉 2、使用场景：频繁切换、并发操作 进程切换时，小号的资源大、效率高，所以设计到频繁切换时，使用线程要好与进程 同样，如果要求同时进行并又要共享某些变量的并发操作，只能用线程，不能用进程 3、执行过程 每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口 但是线程不能独立执行，必须依赖存在应用程序中，由应用程序提供多个线程来执行控制 4、线程是处理器调度的基本单元，但进程不是 5、线程没有地址空间，线程包含在进程的地址空间中 线程 和 Runloop 的关系 runloop与线程是一一对应的，一个runloop对应一个核心的线程，为什么说核心的，是因为runloop是可以嵌套的，但是核心的只能有一个，他们的关系保存在一个全局的字典里 runloop是用来管理线程的，当线程的runloop被开启后，线程会在执行完任务后进入休眠状态，有了任务就会被唤醒去执行任务。 runloop在第一次获取时被创建，在线程结束时被销毁 对于主线程来说，runloop在程序已启动就默认创建好了 对于子线程来说，runloop是来加载的，只有当我们使用的时候才会创建，所以在子线程使用定时器要注意，确保子线程的runloop被创建，不然定时器不会回调 多线程多线程原理 对于 单核CPU，同一时间，CPU只能处理一条线程，即只有一条线程在工作 iOS中的多线程同时执行，其本质是CPU在多个任务间直接进行快速切换，由于CPU调度线程的时间足够快，就造成了多线程同时执行的效果，其中奇幻的时间间隔就是时间片 多线程意义 优点 能适当提高程序的执行效率 能适当提高资源的利用率，如CPU、内存 线程上的任务执行完成后，线程会自动销毁 缺点 开启线程需要占用一定的内存空间，默认情况下，每一个线程占用512KB 如果开启大量线程，会占用大量的内存空间，降低程序的性能 线程越多，CPU在调用线程上的开销越大 程序设计更加复杂，比如线程间的通信，多线程的数据共享 多线程生命周期多线程的声明周期主要分为五个部分：新建-就绪-运行-阻塞-死亡，如下图所示： 新建：主要是实例化线程对象 就绪：线程对象 调用start方法，将线程对象 加入可调度线程池，等待CPU的调用，即 调用start方法，并不会立即执行，进入 就绪状态，需要等待一段时间，经CPU调度后才执行，也就是从就绪状态进入 运行状态 运行：CPU负责调度可调度线程的执行，在线程执行完成之前，其状态可能会在就绪和运行之间来回切换，这个变化是由CPU负责，开发人员不能干预 阻塞：当满足某个预定条件时，可以 使用休眠、即sleep、或者同步锁，阻塞线程执行，当进入sleep时，会重新将 线程加入就绪 中，下面关于休眠的时间设置，都是 NSThread 的 sleepUnilDate ：阻塞当前线程，直到指定的时间为止，即 &#96;休眠到指定时间 sleepForTimeInerval：在给定的时间间隔内休眠线程，即 指定休眠时长 同步锁：@synchronized(self) 死亡：分为两种情况 正常死亡，即线程执行完毕 非正常死亡，即当满足某个条件后，在线程内部（或主线程中）终止执行（调用exit方法等退出） 简要说明：就是处于 运行中的线程 拥有一段可以执行的事件（成为 时间片） 如果 时间片用尽，线程就会进入 就绪状态队列 如果 时间片没有用尽，且需要开始 等待某事件，就会进入 阻塞状态队列 等待事件发生后，线程又重新进入 就绪状态队列 每当一个 线程离开运行，即执行完毕或者强制退出后，会重新 从就绪状态队列中选择一个线程继续执行 线程的 exit 和 cancel 说明： exit：一旦强行终止线程，后续的所有代码都不会执行 1- cancel：取消当前线程，但是不能取消正在执行的线程 【面试题】线程的优先级越高，是不是意味着任务的执行越快？ 答：并不是，线程执行的快慢，除了要看优先级，还需要查看 资源的大小（即任务的复杂度）、以及 CPU调度 情况，在NSThread中，线程优先级 threadPriority 已经被服务质量 qualityOfService 取代，一下是相关的枚举值： 线程池的原理 【第一步】判断核心线程是否都正在执行任务 返回NO，创建新的工作线程去执行 返回YES，进入【第二步】 【第二步】判断线程池工作队列是否已经饱满 返回NO，将任务存储到工作队列，等待CPU调度 返回YES，进入【第三步】 【第三步】判断线程池中的线程是否都出于执行状态 返回NO，安排可调度线程池中空闲的线程去执行任务 返回YES，进入【第四步】 【第四步】交给饱和策略去执行，主要有以下四种（在iOS中并没有找到以下4中策略） AbortPolicy：直接抛出RejectedExecutionExeception异常来阻止系统正常运行 CallerRunsPolicy ：将任务回退到调用者 DisOldestPolicy：丢掉等待最久的任务 DisCardPolicy：直接丢弃任务 iOS中多线程的实现方案iOS中的多线程实现方式，主要有四种：pthread、NSThread、GCD、NSOperation，汇总如图所示： 方案 简介 语言 线程的声明周期 使用频率 Pthread 1、一套通用的多线程API 2、使用与Unix&#x2F;Linus&#x2F;windows等系统 3、跨平台、可移植 4、使用难度大 C 程序员管理 几乎不用 NSThread 1、使用更加面向对象 2、使用简单，可直接操作线程对象 OC 程序员管理 偶尔使用 GCD 1、旨在替代GCD等线程技术 2、充分利用设备的多核 C 自动管理 经常使用 NSOperation 1、基于GCD（底层是GCD） 2、比GCD多了一些更简单实用的功能 3、使用更加面向对象 OC 自动管理 经常使用 下面是四种方案的简单示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// *********1: pthread*********pthread_t threadId = NULL;//c字符串char *cString = &quot;HelloCode&quot;;/** pthread_create 创建线程 参数： 1. pthread_t：要创建线程的结构体指针，通常开发的时候，如果遇到 C 语言的结构体，类型后缀 `_t / Ref` 结尾 同时不需要 `*` 2. 线程的属性，nil(空对象 - OC 使用的) / NULL(空地址，C 使用的) 3. 线程要执行的`函数地址` void *: 返回类型，表示指向任意对象的指针，和 OC 中的 id 类似 (*): 函数名 (void *): 参数类型，void * 4. 传递给第三个参数(函数)的`参数` */int result = pthread_create(&amp;threadId, NULL, pthreadTest, cString);if (result == 0) &#123; NSLog(@&quot;成功&quot;);&#125; else &#123; NSLog(@&quot;失败&quot;);&#125; //*********2、NSThread*********[NSThread detachNewThreadSelector:@selector(threadTest) toTarget:self withObject:nil]; //*********3、GCD*********dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self threadTest];&#125;); //*********4、NSOperation*********[[[NSOperationQueue alloc] init] addOperationWithBlock:^&#123; [self threadTest];&#125;];// 函数方法- (void)threadTest&#123; NSLog(@&quot;begin&quot;); NSInteger count = 1000 * 100; for (NSInteger i = 0; i &lt; count; i++) &#123; // 栈区 NSInteger num = i; // 常量区 NSString *name = @&quot;zhang&quot;; // 堆区 NSString *myName = [NSString stringWithFormat:@&quot;%@ - %zd&quot;, name, num]; NSLog(@&quot;%@&quot;, myName); &#125; NSLog(@&quot;over&quot;);&#125;void *pthreadTest(void *para)&#123; // 接 C 语言的字符串 // NSLog(@&quot;===&gt; %@ %s&quot;, [NSThread currentThread], para); // __bridge 将 C 语言的类型桥接到 OC 的类型 NSString *name = (__bridge NSString *)(para); NSLog(@&quot;===&gt;%@ %@&quot;, [NSThread currentThread], name); return NULL;&#125; C 和 OC 的桥接其中涉及C与OC的桥接，有以下几点说明 __bridge只做类型转换，但是不修改对象（内存）管理权 __bridge_retained(也可以使用CFBridgingRetain)将Object-C的对象转换为Core Foundation的对象，同时将对象（内存）的管理权交给我们，后续需要使用 CFRelease或相关方法来释放对象 __bridge_transfer(也可以使用 CFBridgingRelease)将 Core Foundation 的对象 转换为 Object-C的对象，同时将 对象（内存）的管理权交给ARC 线程安全问题当多个线程同时访问一块内存资源时，容易引发数据错乱 和 数据安全问题，有以下两种解决方案： 互斥锁（即同步锁）：@synchronized 自旋锁 互斥锁 用于保护临界区，确保 同一时间，只有一条线程能够执行 如果代码中 只有一个地方需要加锁，大多数都使用 self，这样可以避免单独再创建一个锁对象 加入互斥锁的代码，当新线程访问时，如果发现其他线程正在执行锁定的代码，新线程就会进入 休眠 针对互斥锁，还需要注意以下几点： 互斥锁的 锁定范围，应该尽量小，锁定范围越大，效率越差 能够 加锁的任意 NSObject 对象 锁对象一定要保证所有的线程都能够访问 自旋锁 自旋锁 与 互斥锁 类似，但它不是通过休眠使线程阻塞，而是 在获取锁之前一直处于忙等（即原地打转，成为自旋）阻塞状态 使用场景：锁持有的时间短，切线程不希望在重新调度上花太多成本时，就需要使用自旋锁，属性修饰符 atomic，本身就有一把 自旋锁 加入了自旋锁，当新线程访问代码时，如果发现有其他线程正在锁定代码，新线程会用 死循环 的方法，一直等待锁定的代码执行完成，即 不停的尝试执行代码，比较消耗性能 【面试题】：自旋锁 vs 互斥锁 同：在同一时间，保证了只有一条线程执行任务，即保证了相应 同步 的功能 不同： 互斥锁：发现其他线程执行，当前线程休眠（即就绪状态） ，进入等待执行，即挂起，一直等其他线程打开后，然后唤醒执行 自旋锁：发现其他线程执行，当前线程 一直询问（即一直访问），处于忙等状态，耗费的性能比较高 场景：根据任务复杂度区分，使用不同的锁，但判断补全时，更多的是使用互斥锁去处理 当前的任务状态比较 短小精悍时，用自旋锁 反之的，用互斥锁 atomic 原子锁 &amp; nonatomic 非原子锁atomic 和 nonatomic 主要用于属性的修饰，以下是相关的一些说明： atomic 是 原子属性，是为 多线程开发准备的，是默认属性 仅仅在属性的 setter 方法中，增加了 锁（自旋锁），能够 保证同一时间，只有一条线程 对属性进行 写 操作 同一时间单（线程）写多（线程）读 的 线程处理技术 Mac开发中常用 nonatomic 是 非原子属性 没有锁 ， 性能高 移动端开发常用 【面试题】 atomic 和 nonatmic区别 nonatomic 非原子属性 非线程安全，适合内存小的移动设备 atomic 原子属性，线程安全 ，针对多线程设计的，默认值 保证同一时间只有一个线程能够写入，但是同一个时间多个线程都可以取值 atomic本身就有一把锁（自旋锁），单写多读：单个线程写入，多个线程读取 线程安全，需要消耗大量的资源 iOS开发建议 所有属性都声明为nonatomic 尽量避免多线程抢夺同一块资源，尽量将加锁、资源抢夺的业务逻辑交给服务器处理，减小移动端客户端的压力你 线程间的通讯在Threading Programming Guide文档中，提及，线程间的通讯有以下几种方式 直接消息传递：通过performSelector的一系列方法，可以实现由某一线程指定在另外的线程上执行任务，因为任务的执行上下文是目标线程，这种方式发送的消息将会自动的被序列化 全局变量、共享内存块和对象：在两个线程之间传递信息的另一种简单的方法是使用全局变量，共享对象或共享内存块，尽管共享变量即快速又简单，但是它们比直接消息传递更脆弱，必须使用锁或其他同步机制仔细保护共享变量，以确保代码的正确性，否则可能会导致竞争状况，数据损坏或崩溃。 条件执行: 条件是一种同步工具，可用于控制线程何时执行代码的特定部分。您可以将条件视为关守，让线程仅在满足指定条件时运行。 Runloop sources: 一个自定义的 Runloop source 配置可以让一个线程上收到特定的应用程序消息。由于 Runloop source 是事件驱动的，因此在无事可做时，线程会自动进入睡眠状态，从而提高了线程的效率 Ports and sockets：基于 端口的通信 是在两个线程之间进行通信的一种更为复杂的方法，但它也是一种 非常可靠的技术。更重要的是，端口和套接字可用于与外部实体（例如其他进程和服务）进行通信。为了提高效率，使用 Runloop source 来实现端口，因此当端口上没有数据等待时，线程将进入睡眠状态。需要注意的是，端口通讯需要将端口加入到 主线程的Runloop中，否则不会走到端口回调方法 消息队列: 传统的多处理服务定义了先进先出（FIFO）队列抽象，用于管理传入和传出数据。尽管消息队列既简单又方便，但是它们不如其他一些通信技术高效 Cocoa 分布式对象: 分布式对象是一种 Cocoa 技术，可提供基于端口的通信的高级实现。尽管可以将这种技术用于线程间通信，但是强烈建议不要这样做，因为它会产生大量开销。分布式对象更适合与其他进程进行通信，尽管在这些进程之间进行事务的开销也很高","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理24：内存五大区","slug":"OC进阶/OC底层原理24：内存五大区","date":"2021-02-14T08:38:08.000Z","updated":"2023-03-02T11:13:00.448Z","comments":true,"path":"2021/02/14/OC进阶/OC底层原理24：内存五大区/","link":"","permalink":"https://www.bboyzj.cn/2021/02/14/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8624%EF%BC%9A%E5%86%85%E5%AD%98%E4%BA%94%E5%A4%A7%E5%8C%BA/","excerpt":"","text":"前言在iOS中，内存主要分为 栈区、堆区、全局区、常量区、代码区 五个区域，如下图所示： 栈区义 栈是 系统数据结构，其对应的 进程或者线程是唯一的 栈是 向低地址扩展 的数据结构 栈是一块 连续的内存区域，遵循 先进后出（FILO） 原则 栈区一般在 运行时 分配 存储 栈区是由 编译器自动分配并释放的，主要来存储 局部变量 函数的参数，例如函数的隐藏参数（id self, SEL _cmd） 优缺点 优点：因为栈是由编译器自动分配并释放的，不会产生内存碎片，所以快速高效 确定：栈的&#96;内存大小有限制，数据不灵活 iOS主线程大小是1MB 其他线程是512KB MAC只有8MB 以上内存大小的说明，在Threading Programming Guide中有相关说明，如下图： 堆区*定义 堆是向高地址扩展的数据结构 堆是不连续的内存区域，类似于链表结构（便于增删，不便于查询），遵循先进先出（FIFO）原则 堆的地址空间在iOS中是是动态的 堆区的分配一般是以在运行时分配 *存储 堆区是由程序员动态分配和释放的，如果程序员不释放，程序结束后，可能由操作系统回收，主要用于存放： OC中使用alloc或者new开辟空间创建对象 C语言中使用malloc、calloc、realloc分配的空间，需要free释放 优缺点 优点：灵活方便，数据适应面广泛 缺点：需手动管理、速度慢，容易产生内存碎片 当需要访问堆中数据时，一般需要先通过对象读取到栈区的指针地址，然后通过指针地址访问堆区 全局区（静态区，即.bss &amp; .data）全局区是编译时分配的内存空间，在程序运行过程中，此内存中的数据一直存在，程序结束后由系统释放，主要存： 未初始化的全局变量和静态变量，即BSS区（.bss） 已初始化的全局变量和静态变量，即DATA区（.data） 其中，全局变量是指变量值可以在运行时被动态修改，而静态变量是static修饰的变量，包含静态局部变量和静态全局变量 常量区（即.rodata）常量区是编译时分配的内存空间，在程序结束后由系统释放，主要存放： 已经使用了的，且没有指向的字符串常量 字符串常量因为可能在程序中被多次使用，所以在程序运行之前就会提前分配内存 代码区（即.text）代码区是由编译时分配，主要用于存放程序运行时的代码，代码会被编译成二进制存进内存的 内存五大区验证运行下面的一段代码，看看变量在内存中是如何分配的： 1234567891011121314int a = 10; // 全局区（已初始化的全局变量）char * b; // 全局区(未初始化的全局变量)- (void)test&#123; NSInteger i = 123; // 栈区（局部变量） NSLog(@&quot;i的内存地址：%p&quot;, &amp;i); NSString *string = @&quot;ZJ&quot;; // 常量区（字符串常量） NSLog(@&quot;string的内存地址：%p&quot;, string); NSLog(@&quot;&amp;string的内存地址：%p&quot;, &amp;string); NSObject *obj = [[NSObject alloc] init]; // 堆区（alloc对象） NSLog(@&quot;obj的内存地址：%p&quot;, obj); NSLog(@&quot;&amp;obj的内存地址：%p&quot;, &amp;obj); &#125; 运行结果如下： 123452022-03-11 14:34:25.438913+0800 内存五大区[70321:4340509] i的内存地址：0x16f6f5a182022-03-11 14:34:25.438976+0800 内存五大区[70321:4340509] string的内存地址：0x1007100982022-03-11 14:34:25.438997+0800 内存五大区[70321:4340509] &amp;string的内存地址：0x16f6f5a102022-03-11 14:34:25.439014+0800 内存五大区[70321:4340509] obj的内存地址：0x280fa0bc02022-03-11 14:34:25.439031+0800 内存五大区[70321:4340509] &amp;obj的内存地址：0x16f6f5a08 对于局部变量i， 存放在栈区 对于字符串对象string，分别打印了string得对象地址和string对象的指针地址 string的对象地址是是存放在常量区 string对象的指针地址，是存放在栈区 对于alloc创建的对象obj，分别打印了obj得对象地址和obj对象的指针地址 obj的对象地址是存放在堆区 obj对象的指针地址是存放在栈区 函数栈 函数栈 又称为 栈区，在内存中从高地址往低地址分配，与堆区相对，具体图示请看上面 栈帧 是指 函数（运行中且未完成）占用的一块独立的连续内存区域 应用中新创建的 每个线程都有专用的栈空间，栈可以在线程期间自由使用，而线程中有千千万万的函数调用，这些函数 共享 进程的这个 栈空间。每个函数所使用的栈空间是一个栈帧，所有栈帧就组成了这个线程完成的栈 函数调用是发生在栈上 的，每个 函数的相关信息（例如局部变量、调用记录等）都 存储在一个栈帧 中，每执行一次 函数调用，就会生成一个与其相关的栈帧，然后将其 栈帧压入函数栈，而当函数 执行结束，则将此函数对应的 栈帧出栈并释放掉 如下图所示，是经典图- ARM的栈帧布局方式 其中 main stack frame 为调用函数的栈帧 func1 stack frame 为当前 当前函数（被调用者）的栈帧 栈底 在 高 地址，栈向下增长 FP 就是 栈基址，它指向函数的 栈帧起始地址 SP 则是函数的 栈指针，它指向 栈顶 的位置 ARM压栈 的 顺序 很是规则（也比较容易被黑客攻破），依次为 当前函数指针PC、返回指针LR、栈指针SP、栈基址FP、传入参数个数及指针、本地变量 和 临时变量。如果函数准备调用另一个函数，跳转之前临时变量区先要保存另一个函数的参数 ARM 也可以 用栈基址和栈指针明确标示栈帧的位置，栈指针SP一直移动，ARM的特点是，两个栈空间内的地址（SP+FP）前面，必然有两个代码地址（PC+LP）明确标示着调用函数位置内的某个地址 堆栈溢出一般情况下应用程序是不需要考虑堆和栈的大小的，但是事实上堆和栈不是无上限的，过多的递归会导致栈溢出，过多的alloc变量会导致堆溢出 所以 预防堆栈溢出 的方法： 避免层次过深 的 递归 调用 不要使用过多的局部变量，控制局部变量的大小 避免分配 占用空间 太大的对象，并 及时释放 实在不行，适当的情景下 调用系统API修改线程的堆栈大小 栈帧示例描述下面代码的栈帧变化 栈帧程序示例 1234567891011int Add(int x,int y) &#123; int z = 0; z = x + y; return z;&#125;int main() &#123; int a = 10; int b = 20; int ret = Add(a, b);&#125; 程序执行时，栈区中栈帧的变化如下图所示：","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理23：KVO底层原理分析","slug":"OC进阶/OC底层原理23：KVO底层原理分析","date":"2021-01-25T08:34:11.000Z","updated":"2022-04-25T03:21:28.000Z","comments":true,"path":"2021/01/25/OC进阶/OC底层原理23：KVO底层原理分析/","link":"","permalink":"https://www.bboyzj.cn/2021/01/25/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8623%EF%BC%9AKVO%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"前言KVO 全称 Key Value Observing，中文名为 键值观察，KVO是一种机制，它 允许将其他对象的指定属性的更改通知给对象 在 key Value Observing Programming Guide 官方文档中，有这么一句话：理解KVO之前，必须先理解 KVC（即KVO是基于KVC基础之上） 123In order to understand key-value observing, you must first understand key-value coding.KVC是键值编码，在对象创建完成后，可以动态的给对象属性赋值，而KVO是键值观察，提供了一种监听机制，当指定的对象的属性被修改后，则对象会收到通知，所以可以看出KVO是基于KVC的基础上对属性动态变化的监听 在iOS日常开发中，经常 使用KVO来监听对象属性的变化，并及时作出响应，即当指定的被观察对象属性被修改后，KVO 会自动通知响应的管擦着，那么 KVO 与 NSNotificationCenter 有什么区别呢？ 相同点 两者的实现原理 都是观察者模式，都是用于 监听 都能 实现一对多 的操作 不同点 KVO只能用于监听对象属性的变化，并且属性名都是通过 NSString 来查找，编译器不会帮你检测对错和补全，纯手敲会比较容易出错 NSNotification 的 发送监听（post） 的操作 我们可以控制，KVO由系统控制 KVO 可以 记录新旧值变化 KVO 使用基本使用KVO的基本使用主要分为三步： 注册观察者 addObserver:forKeyPath:option:context 1[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:NULL]; 实现KVO回调 observerValueForKeyPath:ofObject:change:context 12345- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; if ([keyPath isEqualToString:@&quot;name&quot;]) &#123; NSLog(@&quot;%@&quot;,change); &#125;&#125; 移除观察者 removeObserver:forKeyPath:context 1[self.person removeObserver:self forKeyPath:@&quot;name&quot; context:NULL]; context 使用在官方文档中，针对 参数context 有如下说明： 大致含义就是：addObserver:forKeyPath:option:context: 方法中的 上下文context 指针包含任意数据，这些数据将在响应的更改通知中传递回观察者。可以通过 指定context为NULL，从而 依靠keyPath 即 键路径字符串 传来的确定更改通知的来源，但是这种方法可能导致对象的父类由于不同的原因也观察到相同的键路径而导致问题。所以可以为每个观察到的 keyPath 创建一个不同的 context，从而 完全不需要进行字符串比较，从而可以更有效地进行通知解析 通俗的讲，context上下文 主要是用于 区分不同对象的同名属性，从而在KVO回调方法中可以 直接使用context进行区分，可以大大提高性能，以及代码的可读性，并且更加安全 context使用总结 不使用 context，使用 keyPath 区分通知来源 12// context的类型是 nullable void *，应该是NULL，而不是nil[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:NULL]; 使用 context 区分通知来源 Person类中增加两个属性 12@property (nonatomic,copy)NSString * name;@property (nonatomic,copy)NSString * nick; DetailViewController类中代码实现 1234567891011121314151617181920// 定义contextstatic void * PersonNickContext = &amp;PersonNickContext;static void * PersonNameContext = &amp;PersonNameContext;// 注册观察者[self.person addObserver:self forKeyPath:@&quot;nick&quot; options:NSKeyValueObservingOptionNew context:PersonNickContext];[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:PersonNameContext]; // KVO回调- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; if (context == PersonNickContext) &#123; NSLog(@&quot;%@&quot;,change); &#125;else if (context == PersonNameContext)&#123; NSLog(@&quot;%@&quot;,change); &#125;&#125;// KVO移除[self.person removeObserver:self forKeyPath:@&quot;name&quot;];[self.person removeObserver:self forKeyPath:@&quot;nick&quot;]; 移除KVO通知的必要性在官方文档中，针对 KVO移除 有以下几点说明： 删除观察者时，请记住以下几点： 要求被移除为观察者（如果尚未注册为观察者）会导致 NSRangeException，您可以对 removeObserver:forKeyPath:context: 进行一次调用，以对应对 addObserver:forKeyPath:option:context: 的调用，或者如果在您的应用中不可行，则将 removeObserver:forKeyPath:context: 调用在 try/catch块 内处理潜在的异常 释放后，观察者不会自动将其自身移除。被观察对象继续发送通知，而或略了观察者的状态。但是，与发送到已释放对象的任何其他消息一样，更改通知会触发内存访问异常。因此，您 可以确保观察者在从内存中消失之前将自己移除 该协议无法询问对象是观察者还是被观察者。构造代码以避免发布相关的错误。一种典型的模式是在观察者初始化期间（例如，在init或viewDidLoad中注册为观察者），并在释放过程中（通常 在dealloc中注销），以确保成对和有序添加和删除观察者，并确保观察者在注册之前被取消注册，从内存中释放出来 所以，总的来说，KVO注册观察者和移除观察者时需要成对出现的，如果 只注册不移除，会出现类似野指针的崩溃（EXC_BAD_ACCESS），如下图所示： 崩溃的原因是，由于 第一次注册KVO观察者没有移除，再次进入页面，会 第二次注册KVO观察者，导致 KVO观察者的重复注册，而且第一次的通知对象还在内存中，没有进行释放，此时接收到属性值变化的通知，会出现 找不到原有的通知对象，只能找到现有的通知对象，即第二次KVO注册的观察者，所以 导致了类似野指针的崩溃，即一直保持着一个 野通知，且一直在监听 注：这里的崩溃案例是通过 单例对象 实现（崩溃有很大的几率，不是每次必现），因为单例对象在内存是常驻的，针对一般的类对象，貌似不移除也是可以的，但是为了防止线上意外，建议还是移除比较好 KVO的自动触发与手动触发KVO观察者的 开启和关闭 有两种方式：自动和手动 自动开关，返回 NO 就是监听不到，返回 YES 表示监听 1234// 自动开关+ (BOOL) automaticallyNotifiesObserversForKey:(NSString *)key&#123; return YES;&#125; 自动开关关闭的时候，可以通过 手动开关监听 12345678910111213// 自动关闭时，手动开启- (void)setName:(NSString *)name&#123; // 手动开关 [self willChangeValueForKey:@&quot;name&quot;]; _name = name; // 父类的setter方法 [self didChangeValueForKey:@&quot;name&quot;];&#125;// 查看打印结果2022-03-09 10:27:56.006156+0800 KVO_Demo[4580:3263311] &#123; kind = 1; new = &quot;hello world&quot;;&#125; 使用手动开关的好处就是你想监听就监听，不想监听关闭即可，比自动触发更方便灵活 KVO观察：一对多KVO观察中的 一对多，意思是通过 注册一个KVO观察者，可以 监听多个属性的变化 以下载进度为例，比如目前有一个需求，需要根据 总的下载量totalData 和 当前下载量currentData 来计算 当前的下载进度downloadProcess，实现如下： 【合二为一观察法】： 分别观察 总的下载量totalData 和 当前下载量currentData 两个属性，当其中一个发生变化 计算当前下载量进度downloadProcess，实现 keyPathsForValueAffectingValueForKey 方法，将两个观察合为一个观察，即 观察当前下载进度currentProcess 12345678910111213141516171819202122232425262728293031@interface Person : NSObject@property (nonatomic,copy)NSString * name;@property (nonatomic,copy)NSString * nick;@property (nonatomic,assign)double totalData;@property (nonatomic,assign)double currentData;@property (nonatomic,copy)NSString * downloadProcess; // 下载进度@property (nonatomic,strong)NSMutableArray * mArr; // 可变数组+ (instancetype)shareInstance;@end@implementation Person+ (instancetype)shareInstance&#123; static Person * person = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; person = [[Person alloc] init]; &#125;); return person;&#125;#pragma mark -2.合二为一的观察法+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key&#123; NSSet * keyPaths = [super keyPathsForValuesAffectingValueForKey:key]; if ([key isEqualToString:@&quot;downloadProcess&quot;]) &#123; NSArray * affectingKeys = @[@&quot;totalData&quot;,@&quot;currentData&quot;]; keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys]; &#125; return keyPaths;&#125;@end 注册KVO观察者，当 currentData改变 时，计算 当前下载进度downloadProcess 123456789101112131415161718192021// 2.合二为一的观察法[self.person addObserver:self forKeyPath:@&quot;downloadProcess&quot; options:NSKeyValueObservingOptionNew context:NULL]; - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // 2.合二为一的观察法 self.person.currentData += 1; self.person.totalData = 100;&#125;#pragma mark -KVO回调- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; // 2.合二为一的观察法 Person * person = (Person *)object; NSLog(@&quot;%f&quot;,person.currentData/person.totalData);&#125;#pragma mark -delloc-(void)dealloc&#123; // 2.合二为一的观察法 [self.person removeObserver:self forKeyPath:@&quot;downloadProcess&quot;];&#125; KVO观察可变数组KVO 是 基于KVC 基础 之上 的，所以 可变数组 如果 直接添加数据，是 不会调用setter方法 的，所有 对可变数组的KVO观察 下面这种方式 是不生效 的，即直接通过 [self.person.mArr addObject:@&quot;1&quot;]; 像数组添加元素，是 不会触发KVO 通知回调的，如下代码是不会通知回调的： Person.h 中 123@interface Person : NSObject@property (nonatomic,strong)NSMutableArray * mArr; // 可变数组@end DetailViewController.m 中 12345678910111213141516171819// 可变数组self.person.mArr = [NSMutableArray arrayWithCapacity:1];[self.person addObserver:self forKeyPath:@&quot;mArr&quot; options:NSKeyValueObservingOptionNew context:NULL];- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // 可变数组 [self.person.mArr addObject:@&quot;1&quot;];&#125;#pragma mark -KVO回调- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; // 可变数组 NSLog(@&quot;%@&quot;,change);&#125;-(void)dealloc&#123; // 可变数组 [self.person removeObserver:self forKeyPath:@&quot;mArr&quot;];&#125; 在 KVC官方文档中，针对 可变数组的集合 类型，有如下说明，即访问集合对象需要通过 mutableArrayValueForKey 方法，这样才能 将元素添加到可变数组中 因此，需要将上面 可变数组 添加元素的方法，改为如下： 1234- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // 可变数组 [[self.person mutableArrayValueForKey:@&quot;mArr&quot;] addObject:@&quot;1&quot;];&#125; 运行结果如下，可以看到，元素被添加到可变数组了： 12345672022-03-09 10:11:24.697680+0800 KVO_Demo[4557:3255716] &#123; indexes = &quot;&lt;_NSCachedIndexSet: 0x2826d91c0&gt;[number of indexes: 1 (in 1 ranges), indexes: (0)]&quot;; kind = 2; // 插入 new = ( 1 );&#125; 其中的 kind 表示 键值变化的类型，是一个枚举，主要有以下 4 种： 123456typedef NS_ENUM(NSUInteger, NSKeyValueChange) &#123; NSKeyValueChangeSetting = 1, // 设值 NSKeyValueChangeInsertion = 2, // 插入 NSKeyValueChangeRemoval = 3, // 移除 NSKeyValueChangeReplacement = 4, // 替换&#125;; 一般的 属性 与 集合 的KVO观察是由区别的，其 kind不同，以 属性name 和 可变数组 为例 属性 的 kind 一般是 设值 可变数组 的 kind 一般是 插入 KVO的底层原理探索官方文档说明 在KVO的官方文档使用指南中，有如下说明 KVO 是使用 isa-swizzling 的技术实现的 顾名思义，isa指针指向维护分配表的对象的类。该分配表实质上包含指向该类实现的方法的指针以及其他数据 当为对象的属性 注册观察者时，将 修改 观察者对象的 isa指针，指向中间类 而不是真实类。结果，isa 指针的值不一定反映实例的实际类 你不应该依靠isa指针来确定类的成员变量，相反，你应该 使用class方法来确定对象实例的类 代码调式探索KVO只对属性观察在 ZJPerson 中有一个 成员变量name 和 属性nick，分别注册KVO观察者，触发属性变化时，会有什么现象？ 创建 ZJPerson 类，声明 成员变量name 和 属性nick 1234567@interface ZJPerson : NSObject&#123; @public NSString * name;&#125;@property (nonatomic,copy)NSString * nick;@end 分别为 成员变量name 和 属性nick 注册观察者 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor orangeColor]; self.person = [[ZJPerson alloc] init]; [self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:NULL]; [self.person addObserver:self forKeyPath:@&quot;nick&quot; options:NSKeyValueObservingOptionNew context:NULL]; &#125; KVO触发通知操作 1234- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; self.person-&gt;name = @&quot;ZJ&quot;; self.person.nick = @&quot;XJ&quot;;&#125; KVO接收通知操作 1234- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; NSLog(@&quot;%@&quot;,change);&#125; 运行结果如下 12342022-03-09 14:33:59.443356+0800 002--KVO原理探讨[4675:3328750] &#123; kind = 1; new = XJ;&#125; 结论：KVO对 成员变量name不观察，只对 属性name观察，属性和成员变量的区别在于 属性多了一个setter方法，而 KVO恰好观察的是setter方法 中间类根据官方文档所述，在 注册KVO观察者后，观察者对象的isa指针指向会发生改变 注册观察者之前： 实例对象person 的 isa 指针指向 ZJPerson 注册观察者之后：实例对象person 的 isa 指针指向 NSKVONotifing_ZJPerson 综上所述，在注册观察者后，实例对象 的 isa 指针 指向 由 ZJPerson类 变为了 NSKVONotifying_ZJPerson中间类，即实例对象的 isa 指针指向发生了变化 判断中间类是否是 派生类 即 子类？那么这个动态生成的中间类 NSKVONotifying_ZJPerson 和 ZJPerson 有什么关系？下面通过代码来验证 可以通过下面封装的方法，获取ZJPerson的相关类 123456789101112131415161718192021222324252627// 添加KVO之前[self printClasses:[ZJPerson class]]; // 添加观察者[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:NULL];[self.person addObserver:self forKeyPath:@&quot;nick&quot; options:NSKeyValueObservingOptionNew context:NULL]; // 添加KVO之后[self printClasses:[ZJPerson class]];#pragma mark -遍历类以及子类- (void)printClasses:(Class)cls&#123; // 注册类的总数 int count = objc_getClassList(NULL, 0); // 创建一个数组， 其中包含给定对象 NSMutableArray * mArr = [NSMutableArray arrayWithObject:cls]; // 获取所有已注册的类 Class * classes = (Class*)malloc(sizeof(Class)*count); objc_getClassList(classes, count); for (int i = 0; i &lt; count; i ++) &#123; if (cls == class_getSuperclass(classes[i])) &#123; [mArr addObject:classes[i]]; &#125; &#125; free(classes); NSLog(@&quot;classes = %@&quot;, mArr);&#125; 打印结果如下： 从打印结果可以得出，NSKVONotifying_ZJPerson 是 ZJPerson 的子类 中间类中有什么？可以通过下面的方法获取 NSKVONotifying_ZJPerson 类中的所有方法 12345678910111213141516171819// 遍历方法[self printClassAllMethod:objc_getClass(&quot;NSKVONotifying_ZJPerson&quot;)]; #pragma mark -遍历方法- (void)printClassAllMethod:(Class)cls&#123; unsigned int count = 0; // 获取一个类中的所有实例方法 Method * methodList = class_copyMethodList(cls, &amp;count); for (int i = 0; i &lt; count; i ++) &#123; // 获取单个方法 Method method = methodList[i]; // 方法编号 SEL sel = method_getName(method); // 方法实现 IMP imp = class_getMethodImplementation(cls, sel); NSLog(@&quot;%@ - %p&quot;,NSStringFromSelector(sel),imp); &#125; free(methodList);&#125; 查看打印结果 从结果中可以看出有四个方法，分别是 setNick、class、dealloc、_isKVOA，这些方法是 继承 还是 重写？ 在 ZJStudent(继承自ZJPerson) 中重写 setNick 方法，获取 ZJStudent 类的所有方法 由打印结果可知，如果是继承那么 NSKVONotifying_ZJPerson 打印的方法应该与 ZJPerson 打印的结果一致 获取 ZJPerson 和 NSKVONotifying_ZJPerson 的方法列表进行对比 【结论】 综上所述，有如下结论： NSKVONotifying_ZJPerson 中间类 重写 了 父类ZJPerson 的 setNick 方法 NSKVONotifying_ZJPerson 中间类 重写 了 基类NSObject 的 class、dealloc、_isKVOA 方法 其中 dealloc 是释放方法 _isKVOA 判断当前是否是 KVO类 dealloc中移除观察者后，isa指向谁，以及中间类是否会销毁？ 移除观察者前：实例对象的isa 指向仍是 NSKVONotifying_ZJPerson中间类 移除观察者之后：实例对象的isa指针指向更改为 ZJPerson类 所以，在 移除KVO观察者后，isa 的指向由 KSKVONotifying_ZJPerson 变成了 ZJPerson 那么中间类从创建后，到dealloc方法中移除观察者之后，KSKVONotifying_ZJPerson 是否还存在？ 在上一个界面打印 ZJPerson 的子类情况，用于判断中间类是否销毁 通过子类的打印结果可以看出，中间类一旦生成，没有移除，没有销毁，还在内存中，主要是考虑 重用 的想法，即 中间类注册到内存中，为了考虑后续的重用问题，所以中间类一直存在 总结综上所述，关于 中间类，有如下说明： 实例对象isa 的指向 在注册KVO观察者之后，由 原有类 更改为 中间类 中间类 重写了观察 属性setter方法、class、dealloc、_isKVOA 方法 dealloc 方法中，移除KVO观察者之后，实例对象isa 指向由 中间类 更改为 原有类 中间类 从创建后，就一直 存在内存中，不会被销毁 自定义KVO自定义KVO的流程，只是在系统的基础上针对其部分做了一些优化处理。 模拟系统 实现 KVO自动销毁机制 将 响应式和函数式 整合 在系统中，注册观察者和KVO响应属于 响应式编程，是分开写的，在自定义为了代码更好的协调，使用 block 的形式，将注册和回调的逻辑组合在一起，即采用 函数式变成 方式 那么如何实现自定义KVO呢？分为以下几个步骤： 注册观察者 12345678// 定义blcocktypedef void(^ZJKVOBlock)(id observer,NSString * keyPath,id oldValue,id newValue);// 创建一个 NSObject+ZJKVO的分类，注册观察者@interface NSObject (ZJKVO)- (void)zj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath block:(ZJKVOBlock)block;- (void)zj_removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;@end KVO监听 这部分主要是通过 重写setter方法，在中间类的setter方法中，通过 block 方式传递给外部进行响应 移除观察者 1- (void)zj_removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; 注册观察者在注册观察者步骤中，主要有以下几步操作： 1、验证是否存在 setter 方法，目的是 不让实例进来 2、动态生成子类，将需要重写的 class 方法添加到中间类中 3、 isa 指向原有类，改为 指向中间类 4、 保存信息：这里用的是数组，也可以使用map，需要创建信息的 model模型类 【注意】： 关于 objc_msgSend 的检查关闭：target -&gt; Build Setting -&gt; Enable Strict Checking of objc_msgsend Calls 设置为 NO KVO响应 主要是给 子类 动态添加 setter 方法，其目的是为了在 setter方法 中向父类发送消息，告知其属性值的变化 通过系统的 objc_msgSendSuper 强制类型转换自定义的消息发送 zj_msgSendSuper 告知vc去响应：获取信息，通过block传递 移除观察者为了避免在外界不断的调用 removeObserver 方法，在自定义 KVO 中实现 自动移除观察者 1、实现 zj_removeObserver:forKeyPath: 方法，主要是清空数组，以及 isa 指向更改 2、在子类中重写 dealloc 方法，当子类销毁时，会自动调用dealloc方法（在动态生成子类的方法中添加） 其主要原理是：ZJPerson 发送消息释放即 dealloc 了，就会自动走到重写的 zj_dealloc 方法中（原因是person对象的 isa 指向变了），指向中间类，但是实例对象的地址是不变的，所以子类的释放，相当于释放了外界的person，而重写的 zj_dealloc 相当于是 重写了ZJPerson 的 dealloc 方法，所以会走到 zj_dealloc 方法中，达到自动移除观察者的目的。 完整的代码 【NSObject+ZJKVO.h】 1234567typedef void(^ZJKVOBlock)(id observer,NSString *keyPath,id oldValue,id newValue);@interface NSObject (LGKVO)- (void)zj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath block:(LGKVOBlock)block;- (void)zj_removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;@end 【NSObject+ZJKVO.m】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#import &quot;NSObject+ZJKVO.h&quot;#import &lt;objc/message.h&gt;static NSString *const kZJKVOPrefix = @&quot;ZJKVONotifying_&quot;;static NSString *const kZJKVOAssiociateKey = @&quot;kZJKVO_AssiociateKey&quot;;#*****信息model*****@interface ZJInfo : NSObject@property (nonatomic,weak)NSObject * observer;@property (nonatomic,copy)NSString * keyPath;@property (nonatomic,copy)ZJKVOBlock handleBlock;@end@implementation ZJInfo- (instancetype)initWitObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath handleBlock:(ZJKVOBlock)block&#123; if (self=[super init]) &#123; _observer = observer; _keyPath = keyPath; _handleBlock = block; &#125; return self;&#125;@end@implementation NSObject (ZJKVO)- (void)zj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath block:(ZJKVOBlock)block&#123; // 1.验证是否存在setter方法：不让实例进来 [self judgeSetterMethodFromKeyPath:keyPath]; // 2.动态生成子类 Class newClass = [self createChildClassWithKeyPath:keyPath]; // 3.isa的指向 : ZJKVONotifying_ZJPerson object_setClass(self, newClass); // 4.保存信息 ZJInfo * info = [[ZJInfo alloc] initWitObserver:observer forKeyPath:keyPath handleBlock:block]; NSMutableArray * mArray = objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kZJKVOAssiociateKey)); if (!mArray) &#123; mArray = [NSMutableArray arrayWithCapacity:1]; objc_setAssociatedObject(self, (__bridge const void * _Nonnull)(kZJKVOAssiociateKey), mArray, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; [mArray addObject:info];&#125;#pragma mark -移除观察者- (void)zj_removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath&#123; NSMutableArray *observerArr = objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kZJKVOAssiociateKey)); if (observerArr.count&lt;=0) &#123; return; &#125; for (ZJInfo *info in observerArr) &#123; if ([info.keyPath isEqualToString:keyPath]) &#123; [observerArr removeObject:info]; objc_setAssociatedObject(self, (__bridge const void * _Nonnull)(kZJKVOAssiociateKey), observerArr, OBJC_ASSOCIATION_RETAIN_NONATOMIC); break; &#125; &#125; if (observerArr.count&lt;=0) &#123; // 指回给父类 Class superClass = [self class]; object_setClass(self, superClass); &#125;&#125;#pragma mark - 验证是否存在setter方法- (void)judgeSetterMethodFromKeyPath:(NSString *)keyPath&#123; Class superClass = object_getClass(self); // 获取类Person SEL setterSeletor = NSSelectorFromString(setterForGetter(keyPath)); Method setterMethod = class_getInstanceMethod(superClass, setterSeletor); if (!setterMethod) &#123; @throw [NSException exceptionWithName:NSInvalidArgumentException reason:[NSString stringWithFormat:@&quot;老铁没有当前%@的setter&quot;,keyPath] userInfo:nil]; &#125;&#125;#pragma mark -动态生成子类- (Class)createChildClassWithKeyPath:(NSString *)keyPath&#123; // 获取原本的类名（Person） NSString * oldClassName = NSStringFromClass([self class]); // 拼接子类类名（ZJKVONotifying_Person） NSString * newClassName = [NSString stringWithFormat:@&quot;%@%@&quot;,kZJKVOPrefix,oldClassName]; // 获取子类 Class newClass = NSClassFromString(newClassName); // 防止重复创建生成新类 if (newClass) return newClass; /** * 如果内存不存在,创建生成 * 参数一: 父类 * 参数二: 新类的名字 * 参数三: 新类的开辟的额外空间 */ // 2.1 : 申请类（ZJKVONotifying_Person） newClass = objc_allocateClassPair([self class], newClassName.UTF8String, 0); // 2.2 : 注册类 objc_registerClassPair(newClass); // 2.3.1 : 添加class : class的指向是ZJPerson SEL classSEL = NSSelectorFromString(@&quot;class&quot;); Method classMethod = class_getInstanceMethod([self class], classSEL); const char *classTypes = method_getTypeEncoding(classMethod); class_addMethod(newClass, classSEL, (IMP)zj_class, classTypes); // 2.3.2 : 添加setter SEL setterSEL = NSSelectorFromString(setterForGetter(keyPath)); // 获取sel Method setterMethod = class_getInstanceMethod([self class], setterSEL); // 获取setter实例方法 const char *setterTypes = method_getTypeEncoding(setterMethod); // 方法签名 class_addMethod(newClass, setterSEL, (IMP)zj_setter, setterTypes); // 添加一个setter方法 // 2.3.3 : 添加dealloc SEL deallocSEL = NSSelectorFromString(@&quot;dealloc&quot;); Method deallocMethod = class_getInstanceMethod([self class], deallocSEL); const char *deallocTypes = method_getTypeEncoding(deallocMethod); class_addMethod(newClass, deallocSEL, (IMP)zj_dealloc, deallocTypes); return newClass;&#125;#pragma mark -重写class方法，为了与系统类对外保持一致Class zj_class(id self,SEL _cmd)&#123; return class_getSuperclass(object_getClass(self));&#125;#pragma mark -添加setter方法static void zj_setter(id self,SEL _cmd,id newValue)&#123; NSString *keyPath = getterForSetter(NSStringFromSelector(_cmd)); id oldValue = [self valueForKey:keyPath]; // 4: 消息转发 : 转发给父类 // 通过系统强制类型转换自定义objc_msgSendSuper void (*zj_msgSendSuper)(void *,SEL , id) = (void *)objc_msgSendSuper; // 定义一个结构体 struct objc_super superStruct = &#123; .receiver = self, // 消息接收者为当前的self .super_class = class_getSuperclass(object_getClass(self)), // 当第一次快捷查找的类为父类 &#125;; // 调用自定义的放消息函数 zj_msgSendSuper(&amp;superStruct,_cmd,newValue); // 5: 信息数据回调 NSMutableArray *mArray = objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kZJKVOAssiociateKey)); for (ZJInfo *info in mArray) &#123; if ([info.keyPath isEqualToString:keyPath] &amp;&amp; info.handleBlock) &#123; info.handleBlock(info.observer, keyPath, oldValue, newValue); &#125; &#125;&#125;#pragma mark - 从get方法获取set方法的名称 key -&gt; setKey:static NSString *setterForGetter(NSString *getter)&#123; if (getter.length &lt;= 0) &#123; return nil;&#125; NSString *firstString = [[getter substringToIndex:1] uppercaseString]; NSString *leaveString = [getter substringFromIndex:1]; return [NSString stringWithFormat:@&quot;set%@%@:&quot;,firstString,leaveString];&#125;#pragma mark - 从set方法获取getter方法的名称 set&lt;Key&gt;:===&gt; keystatic NSString *getterForSetter(NSString *setter)&#123; if (setter.length &lt;= 0 || ![setter hasPrefix:@&quot;set&quot;] || ![setter hasSuffix:@&quot;:&quot;]) &#123; return nil;&#125; NSRange range = NSMakeRange(3, setter.length-4); NSString *getter = [setter substringWithRange:range]; NSString *firstString = [[getter substringToIndex:1] lowercaseString]; return [getter stringByReplacingCharactersInRange:NSMakeRange(0, 1) withString:firstString];&#125;#pragma mark -重写deallocstatic void zj_dealloc(id self,SEL _cmd)&#123; NSLog(@&quot;[%@ dealloc]&quot;,self); Class superClass = [self class]; object_setClass(self, superClass);&#125;@end 总结综上所述，自定义KVO大致分为一下几步： 注册观察者 &amp; 响应 验证是否存在 setter 方法 动态生成子类，需要重写 class、setter 方法 在子类的setter方法中向父类发消息，即 自定义消息发送 isa原有类指向中间类 保存信息 让观察者 响应 移除观察者 更改 isa指向 为原有类 重写子类的 dealloc 方法","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理22：KVC底层原理分析","slug":"OC进阶/OC底层原理22：KVC底层原理分析","date":"2021-01-17T08:33:44.000Z","updated":"2022-04-24T08:39:28.000Z","comments":true,"path":"2021/01/17/OC进阶/OC底层原理22：KVC底层原理分析/","link":"","permalink":"https://www.bboyzj.cn/2021/01/17/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8622%EF%BC%9AKVC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"前言KVC 的全称是 Key-Value-Coding ，翻译成中文是 键值编码 ，键值编码是由NSKeyValueCoding 非正式协议启动的一种机制，对象采用该协议来间接访问其属性。既可以通过一个 字符串Key来访问某个属性。这种间接访问机制补充了实例变量及其相关的访问器方法所提供的直接访问。 KVC相关API常用方法 主要有以下四种常用的方法： 通过 key 设值&#x2F;取值 12345// 通过key来取值- (nullable id)valueForKey:(NSString *)key;// 通过key来设值- (void)setValue:(nullable id)value forKey:(NSString *)key; 通过 keyPath（即路由）设值&#x2F;取值 12345// 通过keyPath来取值-(nullable id)valueForKeyPath:(NSString *)keyPath;// 通过keyPath来设值-(void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; 其他方法 123默认返回YES，表示如果没有找到Set&lt;Key&gt;方法的话，会按照_key，_iskey，key，iskey的顺序搜索成员，设置成NO就不这样搜索是否可以直接访问实例变量+(BOOL)accessInstanceVariablesDirectly; 12KVC提供属性值正确性验证的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError; 12这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回。- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key; 12如果Key不存在，且KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常。- (nullable id)valueForUndefinedKey:(NSString *)key; 12和上一个方法一样，但这个方法是设值。- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key; 12如果你在SetValue方法时面给Value传nil，则会调用这个方法- (void)setNilValueForKey:(NSString *)key; 12输入一组key,返回该组key对应的Value，再转成字典返回，用于将Model转到字典。- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys; KVC设值底层原理在日常开发中，针对对象属性的赋值，一般有以下两种方式 直接通过 setter 方法赋值 通过 KVC键值编码 的相关API赋值 12345ZJPerson * person = [[ZJPerson alloc] init];// 1.一般setter方法person.name = @&quot;ZJ_哈哈&quot;;// 2.KVC方法[person setValue:@&quot;ZJ_嘻嘻&quot; forKey:@&quot;name&quot;]; 下面针对使用最多的KVC设值方法：seValue:forKey，来进行底层原理的探索 首先进入 seValue:forKey 的声明，发现是在 Foundation 框架中，而Foundation 框架是不开源的，有以下几种方式可以去探索底层： 通过 Hopper 反汇编，查看伪代码 通过苹果 官方文档 Github 搜索是否有相关的demo 在这里，我们通过 Key-Value Coding Programming Guide 苹果官方文档来研究，针对设值流程，有如下说明 当调用 seValue:forKey 设值属性 value 时，其底层的执行流程为： 【第一步】 首先查找是否有这三种 setter 方法，按照查找顺序为 set&lt;Key&gt; 、_set&lt;Key&gt;、setIs&lt;Key&gt; 如果 有其中任意一个 setter方法，则 直接设值属性的value（注意：key是指成功变量名，首字母的大小写需要符合KVC的命名规范） 如果都 没有 ，则进入 【第二步】 【第二步】 如果没有第一步的三个简单的setter方法，则查找accessInstanceVariablesDirectly 是否返回 YES 如果返回 YES，则查找间接访问的实例变量进行赋值，查找顺序为：_&lt;key&gt;、_is&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt; 如果找到其中任意一个实例变量，则赋值 如果都没有，则进入 【第三步】 如果返回NO，则进入 【第三步】 【第三步】 如果 setter方法 或者 实例变量 都没有找到，系统会执行该对象的seValue:forUnderfinedKey:方法，默认抛出NSUnderfinedKeyException类型的异常 综上所述，KVC通过 seValue:forKey 方法设值的流程，以ZJPerson的对象person的属性name为例，如下图所示： KVC取值底层原理同样的，我们可以通过官方文档分析KVC取值的底层原理 当调用 valueForKey 时，其底层的执行流程如下： 【第一步】 首先查找 getter 方法，按照：get&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt;、_&lt;key&gt; 的方法顺序查找 如果 找到 ，则进入 【第五步】 如果 没有找到 ，则进入 【第二步】 【第二步】 如果第一步中的 getter 方法没有找到，KVC会查找：countOf&lt;Key&gt;、objectIn&lt;Key&gt; AtIndex:、&lt;key&gt;AtIndex: 如果找到 countOf&lt;Key&gt; 和其他两个中的一个，则会创建一个响应所有 NSArray 方法的 集合代理对象，并返回该对象，即 NSKeyValueArray，是NSArray 的子类。代理对象随后将接收到的所有 NSArray 消息转换为countOf&lt;Key&gt;、objectIn&lt;Key&gt; AtIndex:、&lt;key&gt;AtIndex: 消息的某种组合，用来创建键值编码对象。如果原始对象还实现了一个名为 get&lt;Key&gt;：range：之类的可选方法，则代理对象也将在适当时使用该方法（注意：方法名的命名规则要符合KVC的标准命名方法，包括方法签名。） 如果没有找到这三个访问数组，则继续进入 【第三步】 【第三步】 如果没有找到上面的几种方法，则会同时查找 countOf &lt;Key&gt;，enumeratorOf&lt;Key&gt;和memberOf&lt;Key&gt; 这三个方法 如果这三个方法都找到，则会创建一个响应 所有NSSet方法的集合代理对象 ，并返回该对象，此代理对象随后将其收到的所有 NSSet 消息转换为 countOf&lt;Key&gt;，enumeratorOf&lt;Key&gt;和memberOf&lt;Key&gt;： 消息的某种组合，用于创建它的对象 如果还是没有找到，则进入 【第四步】 【第四步】 如果还没有找到，检查类方法 InstanceVariablesDirectly 是否 YES，依次搜索 _&lt;key&gt;，_is&lt;Key&gt;，&lt;key&gt; 或 is&lt;Key&gt; 的实例变量 如果搜到，直接获取实例变量的值，进入 【第五步】 【第五步】 根据搜索到的属性值的类型，返回不同的结果 如果是对象指针，则直接返回结果 如果是 NSNumber支持 的标量类型，则将其 存储在NSNumber实例 中并返回它 如果是是 NSNumber不支持 的标量类型，请 转换为NSValue对象 并返回该对象 【第六步】 如果上面5步的方法 均失败，系统会执行该对象的valueForUndefinedKey: 方法，默认抛出 NSUndefinedKeyException 类型的异常 综上所述，KVC通过 valueForKey: 方法取值的流程以设值 ZJPerson 的对象person的属性 name 为例，如下图所示： 自定义KVC原理：通过给 NSObject 添加 分类ZJKVC，实现自定义的 zj_setValue：forKey： 和 zj_valueForKey： 方法，根据苹果官方文档提供的查找规则进行实现： 123456@interface NSObject (ZJKVC)// 设值- (void)zj_setValue:(nullable id)value forKey:(NSString *)key;// 取值- (nullable id)zj_valueForKey:(NSString *)key;@end 自定义KVC设值自定义KVC设值 1、判断 key非空 2、查找 setter 方法，顺序是：setXXX、_setXXX、setIsXXX 3、判断是否响应 accessInstanceVariablesDirectly 方法，即间接访问实例变量 返回 YES，继续下一步设值 返回 NO，则崩溃 4、间接访问变量赋值（只会走一次），顺序是：_key、_isKey、key、isKey 定义一个手机实例变量的可变数组 通过class_getInstanceVariable 方法，获取响应的ivar 通过object_setIvar方法，对响应的ivar设值值 5、如果找不到相关实例变量，则抛出异常 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@implementation NSObject (ZJKVC)// 设值- (void)zj_setValue:(nullable id)value forKey:(NSString *)key&#123; // 1.判断key是否存在 if (key == nil || key.length == 0) &#123; return; &#125; // 2.找setter方法，顺序是：setXXX、_setXXX、setIsXXX NSString * Key = key.capitalizedString; // key 要大写 NSString * setKey = [NSString stringWithFormat:@&quot;set%@:&quot;, Key]; NSString * _setKey = [NSString stringWithFormat:@&quot;_set%@:&quot;, Key]; NSString * setIsKey = [NSString stringWithFormat:@&quot;setIs%@:&quot;, Key]; // 判断是否有方法 if ([self zj_performSelectorWithMethodName:setKey value:value]) &#123; NSLog(@&quot;*************%@*************&quot;, setKey); return; &#125;else if ([self zj_performSelectorWithMethodName:_setKey value:value]) &#123; NSLog(@&quot;*************%@*************&quot;, _setKey); return; &#125;if([self zj_performSelectorWithMethodName:setIsKey value:value])&#123; NSLog(@&quot;*************%@*************&quot;, setIsKey); return; &#125; // 3、判断是否响应accessInstanceVariablesDirectly方法，即间接访问实例变量，返回YES，继续下一步设值，如果是NO，则崩溃 if (![self.class accessInstanceVariablesDirectly]) &#123; @throw [NSException exceptionWithName:@&quot;ZJUnKnownKeyException&quot; reason:[NSString stringWithFormat:@&quot;***[%@ valueForUnderfinedKey:] this class is not key value coding-compliant for the key name.***&quot;] userInfo:nil]; &#125; // 4.间接访问变量赋值，顺序为：_key、_isKey、key、isKey // 4.1 定义一个手机实例变量的可变数组 NSMutableArray * mArray = [self getIvarListName]; // _key、_isKey、key、isKey NSString * _key = [NSString stringWithFormat:@&quot;_%@:&quot;, Key]; NSString * _isKey = [NSString stringWithFormat:@&quot;_is%@:&quot;, Key]; NSString * isKey = [NSString stringWithFormat:@&quot;is%@:&quot;, Key]; if ([mArray containsObject:_key]) &#123; // 4.2 获取响应的 ivar Ivar ivar = class_getInstanceVariable([self class], _key.UTF8String); // 4.3 对相应的 ivar 设值值 object_setIvar(self, ivar, value); return; &#125;else if ([mArray containsObject:_isKey]) &#123; Ivar ivar = class_getInstanceVariable([self class], _isKey.UTF8String); object_setIvar(self, ivar, value); return; &#125;else if ([mArray containsObject:key]) &#123; Ivar ivar = class_getInstanceVariable([self class], key.UTF8String); object_setIvar(self, ivar, value); return; &#125;else if ([mArray containsObject:isKey]) &#123; Ivar ivar = class_getInstanceVariable([self class], isKey.UTF8String); object_setIvar(self, ivar, value); return; &#125; // 5.如果找不到则抛出异常 @throw [NSException exceptionWithName:@&quot;ZJUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ %@]: this class is not key value coding-compliant for the key name.****&quot;,self,NSStringFromSelector(_cmd)] userInfo:nil];&#125; 相关方法 123456789101112131415161718192021222324#pragma mark - 相关方法- (BOOL)zj_performSelectorWithMethodName:(NSString *)methodName value:(id)value&#123; if ([self respondsToSelector:NSSelectorFromString(methodName)]) &#123;#pragma clang diagnostic push // 如果你确定不会发生内存泄漏的情况下，可以使用如下的语句来忽略掉这条警告#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; [self performSelector:NSSelectorFromString(methodName) withObject:value];#pragma clang diagnostic pop return YES; &#125; return NO;&#125;- (id)performSelectorWithMethodName:(NSString *)methodName&#123; if ([self respondsToSelector:NSSelectorFromString(methodName)]) &#123;#pragma clang diagnostic push // 如果你确定不会发生内存泄漏的情况下，可以使用如下的语句来忽略掉这条警告#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; return [self performSelector:NSSelectorFromString(methodName) ];#pragma clang diagnostic pop &#125; return nil;&#125; 获取成员变量 123456789101112131415161718192021222324#pragma mark -获取成员变量名- (NSMutableArray *)getIvarListName&#123; // 创建可变数组，用于存储ivar成员变量 NSMutableArray * mArray = [NSMutableArray arrayWithCapacity:1]; unsigned int count = 0; // 获取类的成员变量列表 Ivar * ivars = class_copyIvarList([self class], &amp;count); // 遍历成员变量列表 for (int i = 0; i&lt;count; i++) &#123; Ivar ivar = ivars[i]; // 获取成员变量名字字符 const char * ivarNameChar = ivar_getName(ivar); // 将字符转换成字符串 NSString * ivarName = [NSString stringWithUTF8String:ivarNameChar]; NSLog(@&quot;ivarName == %@&quot;, ivarName); // 存入可变数组 [mArray addObject:ivarName]; &#125; //释放成员变量列表 free(ivars); return mArray;&#125;@end 自定义KVC取值 1、判断 key非空 2、查找相应方法，顺序是 get&lt;Key&gt;、&lt;key&gt;、countOf&lt;Key&gt;、objectIn&lt;Key&gt;AtIndex 3、判断是否能够直接赋值实例变量，即判断是否响应 accessInstanceVariablesDirectly 方法，间接访问实例变量 返回 YES，继续下一步取值 返回 NO，则崩溃 4、间接访问实例变量，顺序是 _&lt;key&gt;、_is&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt; 定义一个手机实例变量的可变数组 通过class_getInstanceVariable方法，获取相应的ivar 通过object_getIvar方法，返回相应的ivar的值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#pragma mark -取值- (nullable id)zj_valueForKey:(NSString *)key&#123; // 1、判断非空 if (key == nil || key.length == 0) &#123; return nil; &#125; // 2、找到相关方法：get&lt;Key&gt;、&lt;key&gt;、countOf&lt;Key&gt; 、objectIn&lt;Key&gt;AtIndex // key 要大写 NSString * Key = key.capitalizedString; // 拼接方法 NSString * getKey = [NSString stringWithFormat:@&quot;get%@&quot;,Key]; NSString * countOfKey = [NSString stringWithFormat:@&quot;countOf%@&quot;,Key]; NSString * objectInKeyAtIndex = [NSString stringWithFormat:@&quot;objectIn%@AtIndex:&quot;,Key];#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; if ([self respondsToSelector:NSSelectorFromString(getKey)]) &#123; return [self performSelector:NSSelectorFromString(getKey)]; &#125;else if ([self respondsToSelector:NSSelectorFromString(key)])&#123; return [self performSelector:NSSelectorFromString(key)]; &#125; // 集合类型 else if ([self respondsToSelector:NSSelectorFromString(countOfKey)])&#123; if ([self respondsToSelector:NSSelectorFromString(objectInKeyAtIndex)]) &#123; int num = (int)[self performSelector:NSSelectorFromString(countOfKey)]; NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:1]; for (int i = 0; i&lt;num-1; i++) &#123; num = (int)[self performSelector:NSSelectorFromString(countOfKey)]; &#125; for (int j = 0; j&lt;num; j++) &#123; id objc = [self performSelector:NSSelectorFromString(objectInKeyAtIndex) withObject:@(num)]; [mArray addObject:objc]; &#125; return mArray; &#125; &#125;#pragma clang diagnostic pop // 3、判断是否响应`accessInstanceVariablesDirectly`方法，即间接访问实例变量，返回YES，继续下一步设值，如果是NO，则崩溃 if (![self.class accessInstanceVariablesDirectly]) &#123; @throw [NSException exceptionWithName:@&quot;ZJLUnKnownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ valueForUndefinedKey:]: this class is not key value coding-compliant for the key name.****&quot;,self] userInfo:nil]; &#125; // 4.找相关实例变量进行赋值，顺序为：_&lt;key&gt;、 _is&lt;Key&gt;、 &lt;key&gt;、 is&lt;Key&gt; // 4.1 定义一个收集实例变量的可变数组 NSMutableArray *mArray = [self getIvarListName]; // 例如：_name -&gt; _isName -&gt; name -&gt; isName NSString * _key = [NSString stringWithFormat:@&quot;_%@&quot;,key]; NSString * _isKey = [NSString stringWithFormat:@&quot;_is%@&quot;,Key]; NSString * isKey = [NSString stringWithFormat:@&quot;is%@&quot;,Key]; if ([mArray containsObject:_key]) &#123; Ivar ivar = class_getInstanceVariable([self class], _key.UTF8String); return object_getIvar(self, ivar);; &#125;else if ([mArray containsObject:_isKey]) &#123; Ivar ivar = class_getInstanceVariable([self class], _isKey.UTF8String); return object_getIvar(self, ivar);; &#125;else if ([mArray containsObject:key]) &#123; Ivar ivar = class_getInstanceVariable([self class], key.UTF8String); return object_getIvar(self, ivar);; &#125;else if ([mArray containsObject:isKey]) &#123; Ivar ivar = class_getInstanceVariable([self class], isKey.UTF8String); return object_getIvar(self, ivar);; &#125; return @&quot;&quot;;&#125; 使用路由访问，即keyPath在日常开发中，一个类的成员变量有可能是自定义类或者其他的复杂数据类型，一般的操作是，我们可以先通过KVC获取该属性，然后再通过KVC获取自定义类的属性，就是比较麻烦，还有另一种比较简单的方法，就是使用 KeyPath 即路由，涉及一下两个方法： setValue:forKeyPath: 和 valueForKeyPath: 1234// 通过KeyPath来设值- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;// 通过KeyPath来取值- (nullable id)valueForKeyPath:(NSString *)kePath; 参考如下的案例 123456789101112131415161718192021222324252627// ZJPerson类@interface ZJPerson : NSObject@property (nonatomic, copy) NSString *age;@property (nonatomic, strong) ZJStudent *student;@end// ZJStudent类@interface ZJStudent : NSObject@property (nonatomic, copy) NSString *name;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; ZJPerson *person = [[ZJPerson alloc] init]; ZJStudent *student = [ZJStudent alloc]; student.name = @&quot;ZJ&quot;; person.student = student; //根据kvc - keyPath路由修改student的subject属性的值 [person setValue:@&quot;嘻嘻&quot; forKeyPath:@&quot;student.name&quot;]; NSLog(@&quot;%@&quot;,[person valueForKeyPath:@&quot;student.name&quot;]); &#125; return 0;&#125;//*************打印结果*************2021-5-27 09:55:08.512833+0800 001-KVC简介[58089:6301894] 改变前：ZJ2021-5-27 09:55:08.512929+0800 001-KVC简介[58089:6301894] 改变后：嘻嘻 KVC的使用场景 1、动态设值和取值 常用的可以通过 setValue:forKey: 和 valueForKey: 也可以通过路由的方式 setValue:forKeyPath: 和 valueForKeyPath: 2、通过KVC访问和修改私有变量 在日常开发中，对于类的私有属性，在外部定义的对象，是 无法直接访问私有属性的，但是对于KVC而言，一个对象没有自己的隐私，所以可以 通过KVC修改和访问任何私有属性 3、多值操作（model和字典互转） model和字典的转换可以通过下面两个KVC的API实现 123456// 字典转模型- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *, id&gt; *)keyedValues;// 模型转字典- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys; 4、修改一些系统空间的内部属性 在日常开发中，我们知道，很多UI控件都是在其内部由多个UI空间组合而成，这些内部控件苹果并没有提供访问的API，但是使用KVC可以解决这个问题，常用的就是 自定义tabbar、个性化UITextField中的placeHolderText 5、用KVC实现高阶消息传递 在对容器类使用KVC时，valueForKey: 将会被传递给容器中的每一个对象，而不是对容器本身进行操作，结果会被添加到返回的容器中，这样，可以很方便的操作集合 来返回 另一个集合 如下所示： 12345678910111213141516171819202122// KVC实现高阶消息传递- (void)transmitMsg&#123; NSArray *arrStr = @[@&quot;english&quot;, @&quot;franch&quot;, @&quot;chinese&quot;]; NSArray *arrCapStr = [arrStr valueForKey:@&quot;capitalizedString&quot;]; for (NSString *str in arrCapStr) &#123; NSLog(@&quot;%@&quot;, str); &#125; NSArray *arrCapStrLength = [arrCapStr valueForKeyPath:@&quot;capitalizedString.length&quot;]; for (NSNumber *length in arrCapStrLength) &#123; NSLog(@&quot;%ld&quot;, (long)length.integerValue); &#125;&#125;//********打印结果********2021-5-27 11:33:43.377672+0800 CJLCustom[60035:6380757] English2021-5-27 11:33:43.377773+0800 CJLCustom[60035:6380757] Franch2021-5-27 11:33:43.377860+0800 CJLCustom[60035:6380757] Chinese2021-5-27 11:33:43.378233+0800 CJLCustom[60035:6380757] 72021-5-27 11:33:43.378327+0800 CJLCustom[60035:6380757] 62021-5-27 11:33:43.378417+0800 CJLCustom[60035:6380757] 7","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理21：Method-Swizzling方法交换","slug":"OC进阶/OC底层原理21：Method-Swizzling方法交换","date":"2021-01-10T07:22:47.000Z","updated":"2022-03-15T02:55:37.000Z","comments":true,"path":"2021/01/10/OC进阶/OC底层原理21：Method-Swizzling方法交换/","link":"","permalink":"https://www.bboyzj.cn/2021/01/10/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8621%EF%BC%9AMethod-Swizzling%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2/","excerpt":"","text":"method-swizzling 是什么？ method-swizzling 的含义是 方法交换，其主要作用是 在运行时将一个方法的实现替换成另一个方法的实现，这就是我们常说的 iOS黑魔法 在OC中就是 利用method-swizzling实现AOP，其中 AOP(Aspect Oriented Programing，面向切面编程），区别于 OOP（面向对象编程） OOP和AOP都是一种编程的思想 OOP编程思想更加倾向于对业务模块的封装，划分出更加清晰的逻辑单元 而AOP是面向切面进行提取封装，提取各个模块中的公共部分，提高模块的复用率，降低业务之间的耦合性 每个类 都维护者一个 方法列表，即 method_list,method_list 中有不同的 方法 即 Method，每个方法中包含了方法的 sel 和 IMP，方法交换就是 将sel和IMP原本的对应断开，并将sel和新的IMP生成对应关系 如下图所示，交换前后的 sel 和 IMP 的对应关系： method-swizzling 涉及的相关API 通过 sel 获取方法 Method class_getInstanceMethod：获取实例方法 class_getClassMethod：获取类方法 method_getImplementation：获取一个方法的实现 method_setImplementation：设置一个方法的实现 method_getTypeEncoding：获取方法实现的编码类型 class_addMethod：添加方法实现 class_replaceMethod：用一个方法的实现，替换另一个方法的实现，即 aIMP 指向 bIMP，但是 bIMP 不一定指向 aIMP method_exchangeImplementations：交换两个方法的实现，即 aIMP -&gt; bIMP，bIMP -&gt; aIMP 坑点1：method-swizzling 使用过程中一次性的问题所谓的一次性就是：method-swizzling 写在 load 方法中，而 load 方法会主动调用多次，这样会 导致方法的重复交换，使方法 sel 的指向又恢复成原来的 imp 的问题 【解决方案】 可以通过 单例设计 原则，使方法交换 只执行一次，在 OC 中可以通过 dispatch_once 实现单例 123456+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [ZJRuntimeTool zj_methodSwizzlingWithClass:self oriSEL:@selector(helloworld) swizzledSEL:@selector(sayHello)]; &#125;);&#125; 坑点2：子类没有实现，父类实现了在下面的这段代码中，ZJPerson 中实现了 personInstanceMethod，而 ZJStudent 继承自 ZJPerson，没有实现 personInstanceMethod，运行下面的这段代码会出现什么问题？ 12345678910111213141516171819202122232425262728293031323334353637// ***ZJPerson类****@interface ZJPerson : NSObject- (void)personInstanceMethod;@end@implementation ZJPerson- (void)personInstanceMethod&#123; NSLog(@&quot;person对象方法:%s&quot;,__func__);&#125;@end// ******ZJStudent类******@interface ZJStudent : ZJPerson- (void)helloword;+ (void)sayHello;@end@implementation ZJStudent- (void)helloword&#123; NSLog(@&quot;student对象方法:%s&quot;,__func__);&#125;+ (void)sayHello&#123; NSLog(@&quot;student类方法:%s&quot;,__func__);&#125;@end//*****VC****@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // 黑魔法坑点二：子类没有实现 - 父类实现 ZJStudent * student = [[ZJStudent alloc] init]; [student personInstanceMethod]; ZJPerson * person = [[ZJPerson alloc] init]; [person personInstanceMethod];&#125;@end 其中，方法交换代码如下，是通过 ZJStudent 的分类 ZJ 实现 1234567891011121314151617181920// ****ZJStudent+ZJ分类*****@interface ZJStudent (ZJ)@end@implementation ZJStudent (ZJ)+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [ZJRuntimeTool zj_methodSwizzlingWithClass:self oriSEL:@selector(personInstanceMethod) swizzledSEL:@selector(zj_studentInstanceMethod)]; &#125;);&#125;// personInstanceMethod 我需要父类的这个方法的一些东西// 给你加一个personInstanceMethod 方法// imp- (void)zj_studentInstanceMethod&#123; // 是否会产生递归？ 不会产生递归，原因是zj_studentInstanceMethod 会走 oriIMP,即personInstanceMethod的实现中去 [self zj_studentInstanceMethod]; NSLog(@&quot;ZJStudent分类添加的zj对象方法：%s&quot;,__func__);&#125;@end 下面是封装好的 method-swizzling 方法 12345678910111213@interface ZJRuntimeTool : NSObject+ (void)zj_methodSwizzlingWithClass:(Class)cls oriSEL:(SEL)oriSEL swizzledSEL:(SEL)swizzledSEL;@end@implementation ZJRuntimeTool+ (void)zj_methodSwizzlingWithClass:(Class)cls oriSEL:(SEL)oriSEL swizzledSEL:(SEL)swizzledSEL&#123; if (!cls) &#123; NSLog(@&quot;传入的交换类不能为空&quot;); &#125; Method oriMethod = class_getInstanceMethod(cls, oriSEL); Method swiMethod = class_getInstanceMethod(cls, swizzledSEL); method_exchangeImplementations(oriMethod, swiMethod);&#125;@end 通过实际代码的调试，发现会在p调用 personInstanceMethod 方法时崩溃，下面来进行详细说明 [student personInstanceMethod]; 中不报错是因为 student 中的 imp 交换成了 zj_studentInstanceMethod，而 ZJStudent 中有这个方法（在ZJ分类中），所以不会报错 崩溃的点在于 [person personInstanceMethod];，其本质原因：ZJStudent 的分类ZJ 中进行了方法交换，将 person 中的 IMP 交换成了 ZJStudent 中的 zj_studentInstanceMethod，但是 ZJPerson 中没有 zj_studentInstanceMethod方法，即 相关的IMP找不到，所以就崩溃了 【优化：避免imp找不到】 通过 class_addMethod 尝试添加你要交换的方法 如果 添加成功，即类中没有这个方法，则通过 class_replaceMethod 进行 替换，其内部会调用 class_addMethod 进行添加 如果添加不成功，即类中有这个方法，则通过 method_exchangeImplementations 进行 交换 12345678910111213141516171819+ (void)zj_methodSwizzlingWithClass:(Class)cls oriSEL:(SEL)oriSEL swizzledSEL:(SEL)swizzledSEL&#123; if (!cls) &#123; NSLog(@&quot;传入的交换类不能为空&quot;); &#125; Method oriMethod = class_getInstanceMethod(cls, oriSEL); Method swiMethod = class_getInstanceMethod(cls, swizzledSEL); // 一般交换方法：交换自己有的方法 // 交换自己没有实现的方法： // 首先：会先尝试给自己添加要交换的方法 - personInstanceMethod(SEL) -&gt; swiMethod(IMP) // 然后再将父类的IMP给swizzle personInstanceMethod(IMP) -&gt; swizzledSEL BOOL success = class_addMethod(cls, oriSEL, method_getImplementation(swiMethod), method_getTypeEncoding(oriMethod)); if (success) &#123; // 自己没有 - 交换 - 没有父类进行处理（重写一个） class_replaceMethod(cls, swizzledSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod)); &#125;else &#123; // 自己有 method_exchangeImplementations(oriMethod, swiMethod); &#125;&#125; 下面是 class_replaceMethod、class_addMethod、method_exchangeImplementations 的源码实现 其中 class_replaceMethod 和 class_addMethod 中都调用了 addMethod 方法，区别在于 bool 值的判断，下面是 addMethod 的源码实现。 坑点3：子类没有实现，父类也没有实现，下面的调用有什么问题？在调用 personInstanceMethod 方法时，父类 ZJPerson 中只有声明，没有实现，子类 ZJStudent 中即没有声明，也没有实现 123456// 将父类 ZJPerson 实现注释@implementation ZJPerson//- (void)personInstanceMethod&#123;// NSLog(@&quot;person对象方法:%s&quot;,__func__);//&#125;@end 经过调试，发现运行代码会崩溃，报错结果如下所示： 原因是：栈溢出，递归死循环，那么为什么会发生递归呢？ 主要是因为 personInstanceMethod 没有实现，然后在方法交换后，始终找不到 oriMethod，然后交换了个寂寞，即交换失败，当我们调用 personInstanceMethod(oriMethod)时，也就是 oriMethod 会进入 ZJ 中 zj_studentInstanceMethod 方法，然后这个方法中又调用了 zj_studentInstanceMethod，此时的 zj_studentInstanceMethod 并没有指向 oriMethod，然后导致了 自己调自己，即递归死循环 【优化：避免递归死循环】 如果 oriMethod 为空，为了避免方法交换没有意义，而被废弃，需要做一些事情 通过 class_addMethod 给 oriSEL 添加 swiMethod 方法 通过 method_setImplementation 将 swiMethod 的 IMP 指向 不做任何事的空实现 1234567891011121314151617181920212223242526+ (void)zj_methodSwizzlingWithClass:(Class)cls oriSEL:(SEL)oriSEL swizzledSEL:(SEL)swizzledSEL&#123; if (!cls) &#123; NSLog(@&quot;传入的交换类不能为空&quot;); &#125; Method oriMethod = class_getInstanceMethod(cls, oriSEL); Method swiMethod = class_getInstanceMethod(cls, swizzledSEL); // 如果没有 oriMethod if (!oriMethod) &#123; // 在oriMethod为nil时，替换后将swizzledSEL复制一个不做任何事的空实现 class_addMethod(cls, oriSEL, method_getImplementation(swiMethod), method_getTypeEncoding(swiMethod)); method_setImplementation(swiMethod, imp_implementationWithBlock(^(id self,SEL _cmd)&#123;&#125;)); &#125; // 一般交换方法：交换自己有的方法 // 交换自己没有实现的方法： // 首先：会先尝试给自己添加要交换的方法 - personInstanceMethod(SEL) -&gt; swiMethod(IMP) // 然后再将父类的IMP给swizzle personInstanceMethod(IMP) -&gt; swizzledSEL BOOL success = class_addMethod(cls, oriSEL, method_getImplementation(swiMethod), method_getTypeEncoding(swiMethod)); if (success) &#123; // 自己没有 - 交换 - 没有父类进行处理（重写一个） class_replaceMethod(cls, swizzledSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod)); &#125;else &#123; // 自己有 method_exchangeImplementations(oriMethod, swiMethod); &#125;&#125; method-swizzling 类方法类方法和实例方法的method-swizzling的原理是类似的，唯一的区别就是类方法存在 元类 中，所以可以做如下操作 ZJStudent 中只有类方法 sayHello 的声明，没有实现 12345@interface ZJStudent : ZJPerson+ (void)sayHello;@end@implementation ZJStudent@end 在ZJStudent的分类的load方法中实现类方法的交换方法 1234567891011//*****ZJStudent(ZJ)+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [ZJRuntimeTool zj_bestClassMethodSwizzlingWithClass:self oriSEL:@selector(sayHello) swizzledSEL:@selector(zj_studentClassMethod)]; &#125;);&#125;+ (void)zj_studentClassMethod&#123; NSLog(@&quot;ZJStudent分类添加的lg类方法:%s&quot;,__func__); [[self class] zj_studentClassMethod];&#125; 封装的 方法交换 如下： 需要通过 class_getClassMethod 方法 获取类方法 在调用 class_addMethod 和 class_replaceMethod 方法添加和替换时，需要传入的类是 元类，元类可以通过 object_getClass 方法获取类的元类 12345678910111213141516171819202122232425262728+ (void)zj_bestClassMethodSwizzlingWithClass:(Class)cls oriSEL:(SEL)oriSEL swizzledSEL:(SEL)swizzledSEL&#123; if (!cls) NSLog(@&quot;传入的交换类不能为空&quot;); Method oriMethod = class_getClassMethod([cls class], oriSEL); Method swiMethod = class_getClassMethod([cls class], swizzledSEL); if (!oriMethod) &#123; // 避免动作没有意义 // 在oriMethod为nil时，替换后将swizzledSEL复制一个不做任何事的空实现,代码如下: class_addMethod(object_getClass(cls), oriSEL, method_getImplementation(swiMethod), method_getTypeEncoding(swiMethod)); method_setImplementation(swiMethod, imp_implementationWithBlock(^(id self, SEL _cmd)&#123; NSLog(@&quot;来了一个空的 imp&quot;); &#125;)); &#125; // 一般交换方法: 交换自己有的方法 -- 走下面 因为自己有意味添加方法失败 // 交换自己没有实现的方法: // 首先第一步:会先尝试给自己添加要交换的方法 :personInstanceMethod (SEL) -&gt; swiMethod(IMP) // 然后再将父类的IMP给swizzle personInstanceMethod(imp) -&gt; swizzledSEL //oriSEL:personInstanceMethod BOOL didAddMethod = class_addMethod(object_getClass(cls), oriSEL, method_getImplementation(swiMethod), method_getTypeEncoding(swiMethod)); if (didAddMethod) &#123; class_replaceMethod(object_getClass(cls), swizzledSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod)); &#125;else&#123; method_exchangeImplementations(oriMethod, swiMethod); &#125;&#125; 调用如下 12345- (void)viewDidLoad &#123; [super viewDidLoad]; [ZJStudent sayHello];&#125; 运行结果如下，由于符合 方法没有实现，所以或走到 空的imp 中 122022-03-14 15:48:59.225558+0800 Method-Swizzling[5512:3942308] ZJStudent分类添加的lg类方法:+[ZJStudent(ZJ) zj_studentClassMethod]2022-03-14 15:48:59.225602+0800 Method-Swizzling[5512:3942308] 来了一个空的 imp method-swizzling 应用method-swizzling 最常用到的是 防止崩溃、字典、数组等越界。 在iOS中，NSNumber、NSArray、NSDictionary 等这些都是类族，一个 NSArray 的实现可能由 多个类组成，所以如果想对 NSArray进行swizzling，必须获取到其“真身”进行swizzling，直接对NSArray进行操作是无效的 下面列举了 NSArray 和 NSDictionary 本类的类名，可以通过 Runtime 函数来取出本类 NSArray: __NSArrayI NSMutableArray: __NSArrayM NSDictionary: __NSDictionaryI NSMutableDicionary: __NSDictionaryM 【以NSArray为例】 创建一个NSArray分类 NSArray+ZJ 12345678910111213141516171819202122232425262728@implementation NSArray (ZJ)// Swizzling核心代码// 须要注意的是，好多同窗反馈下面代码不起做用，形成这个问题的缘由大多都是其调用了super load方法。在下面的load方法中，不该该调用父类的load方法。+ (void)load &#123; Method fromMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayI&quot;), @selector(objectAtIndex:)); Method toMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayI&quot;), @selector(cm_objectAtIndex:)); method_exchangeImplementations(fromMethod, toMethod);&#125;// 为了不和系统的方法冲突，我通常都会在swizzling方法前面加前缀- (id)cm_objectAtIndex:(NSUInteger)index &#123; // 判断下标是否越界，若是越界就进入异常拦截 if (self.count-1 &lt; index) &#123; @try &#123; return [self cm_objectAtIndex:index]; &#125; @catch (NSException *exception) &#123; // 在崩溃后会打印崩溃信息。若是是线上，能够在这里将崩溃信息发送到服务器 NSLog(@&quot;---------- %s Crash Because Method %s ----------\\n&quot;, class_getName(self.class), __func__); NSLog(@&quot;%@&quot;, [exception callStackSymbols]); return nil; &#125; @finally &#123;&#125; &#125; // 若是没有问题，则正常进行方法调用 else &#123; return [self cm_objectAtIndex:index]; &#125;&#125; 打印结果如下，会输出崩溃日志，但是实际不会崩溃","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理20：OC底层面试题解析","slug":"OC进阶/OC底层原理20：OC底层面试题解析","date":"2020-12-15T07:22:19.000Z","updated":"2022-04-08T07:10:46.000Z","comments":true,"path":"2020/12/15/OC进阶/OC底层原理20：OC底层面试题解析/","link":"","permalink":"https://www.bboyzj.cn/2020/12/15/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8620%EF%BC%9AOC%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/","excerpt":"","text":"【面试题1】Runtime Associate 方法关系的对象，需要在dealloc中释放？当我们对象释放时，会调用 dealloc C++函数释放：objc_cxxDestruce 移除关联属性：_object_remove_associations 将弱引用自动设值nil：weak_clear_no_lock(&amp;table_weak_table。(id)this); 引用计数处理：table_refcnts_erase(this) 销毁对象：free(obj) 所以，关联对象 不需要我们手动移除，会在对象析构即 dealloc 时释放 dealloc源码 dealloc的源码查找路径：dealloc -&gt; _objc_rootDealloc -&gt; rootDealloc -&gt; object_dispose（释放对象） -&gt; objc_destructInstance -&gt; _object_remove_assocations 在objc源码中搜索 dealloc 的源码实现 进入 _objc_rootDealloc 源码实现，主要是对 对象进行析构 进入 rootDealloc 源码实现，发现其中有 关联属性时设置bool值，当有这些条件时，需要进入else流程 进入 object_dispose 源码实现，主要是 销毁实例对象 进入 objc_destructInstance 源码实现，在这里有一处关联属性的方法 进入 _object_remove_assocations 源码，关联属性的移除，主要是 从全局哈希map中招待相关对象的迭代器，然后将迭代器中关联属性，从头到尾的移除 【面试2】方法的调用顺序类的方法 和 分类方法 重名，如果调用，是什么情况？ 如果同名方法是 普通方法，包括 initialize – 先调用分类方法 因为 分类的方法是在类realize之后attach进去的，插在类的方法的前面，所以 优先调用分类的方法（注意：不是分类覆盖主类！！），所以你看到的只有 类的initialize * `initialize` 方法什么时候调用？`initialize` 方法也是 `主动调用`，即 `第一次消息时` 调用，为了不影响整个load，可以将需要 `提前加载的数据` 写到 `initialize` 中 如果同名方法是 load 方法 – 先 主类load，后 分类load（分类之间，看编译的顺序） 原因：参考 iOS-底层原理18：类的加载（下） 文章中的 load_images 原理分析 【面试3】Runtime是什么？ runtime 是由 C和C++ 汇编实现的一套 API，为 OC 语言加入了 面向对象、以及运行时的功能 运行时是指将 数据类型的确定由编译时推到了运行时 举例：extension 和 category 的区别 平时编写的 OC 代码，在程序运行过程中，其实最终会转变成 runtime 的 C语言代码，runtime是OC的幕后工作者 1. category类别、分类 专门用来给类添加新的方法 不能给类添加成员变量，添加了成员属性，也无法取到 注意：其实 可以通过runtime给分类添加属性，即属性关联，重写setter、getter方法 分类中用 @property 定义变量，只会生成 变量的 setter、getter 方法的 声明，不能生成方法实现和带下划线的成员变量 2. extension 类扩展 可以说成是 特殊的类，也可以称作 匿名的类 可以 给类添加成员属性，但是 是私有变量 可以 给类添加方法，也是 私有方法 【面试4】方法的本质，sel是什么？IMP是什么？两者之间的关系又是什么？ 方法的本质：发送消息，消息会有以下几个流程 快速查找（objc_msgSend）-&gt; cache_t 缓存消息中查找 慢速查找 - 递归自己|父类 -&gt; lookUpImpOrForward 查找不到消息 -&gt; 动态方法解析 - resolveInstanceMethod 消息快速转发 - forwardingTargetForSelector 消息慢速转发 - methodSignatureForSelector &amp; forwardInvocation sel 是 方法编号 - 在 read_images 期间就编译进了内存，相当于一本书的 目录title imp 是 函数实现指针，找imp就是找函数的过程，相当于 书本的页码 查找具体的函数就是想看这本书具体篇章的内容 首先知道想看什么，即目录 title-sel 根据目录查找到对应的页码 - imp 通过页码去翻到具体的内容 【面试5】能否像编译后得到的类中增加实例变量？能否像运行时创建的类中添加实例变量？ 不能 像编译后得到的类中增加实例变量 只要类没有注册到内存还是可以添加的 可以 添加属性+方法 【原因】 ：编译好的实例变量存储的位置是ro，一旦编译完成，内存结构就完全确定了 【面试6】[self class] 和 [super class]的区别以及原理分析 [self class] 就是发送消息 objc_msgSend，消息接收者是 self，方法编号是 class [super class] 本质就是 objc_msgSendSuper，消息的接收者还是 self，方法编号 class，在运行时，底层调用的是 _objc_msgSendSuper2【重点!!!】 只是 objc_msgSendSuper2 会更快，直接跳过 self 的查找 【代码调试】 ZJPerson 中的 init 方法中打印这两种 class 调用 进入 [self class] 中的 class 源码 其底层是 获取对象的isa，当前的 对象是ZJPerson，其isa是其同名的 ZJPerson，所以 [self class] 打印的是 ZJPerson [super class]中，其中 super 是语法的 关键字，可以通过 clang 看 super 的本质，这是 编译时 的底层源码，其中第一个参数是消息接收者，是一个 __rw_objc_super 结构 底层源码中搜索 __rw_objc_super，是一个中间结构体 objc中搜索 objc_msgSendSuper，查看其隐藏参数 搜索 struct objc_super 通过 clang 的底层编译代码可知，当前 消息的接收者 是 self，而 self 等于 ZJPerson，所以 [super class] 进入 class 方法来源后，其中的 self是init后的实例对象，实例对象的 isa 指向的是本类，即消息接收者是 ZJPerson本类 我们再来看 [super class] 在运行时是否如上一步的底层编码所示，是 objc_msgSendSuper，打开汇编调试，调试结果如下 搜索 objc_msgSendSuper2，从注释得知，是 从类开始查找的，而不是父类 查看 objc_msgSendSuper2 的汇编源码，是从 superclass 中的 cache 中查找方法 12345678ENTRY _objc_msgSendSuper2UNWIND _objc_msgSendSuper2, NoFrameldp p0, p16, [x0] // p0 = real receiver, p16 = class 取出receiver 和 classldr p16, [x16, #SUPERCLASS] // p16 = class-&gt;superclassCacheLookup NORMAL, _objc_msgSendSuper2//cache中查找--快速查找END_ENTRY _objc_msgSendSuper2 【完成回答】 [self class] 方法调用的本质是 发送消息，调用class的消息流程，拿到 元类的类型，在这里是因为类已经加载到内存，所以在读取时是一个字符串类型，这个字符串类型是在 map_images 的 readClass 时已经加入表中，所以打印为 ZJPerson [super class] 打印的是 ZJPerson，原因是当前的 super 是一个 关键字，在这里只是调用 objc_msgSendSuper2，其实他的消息接收者和[self class]是一模一样的，所以返回的是 ZJPerson 【面试7】内存平移问题ZJPerson中有一个 属性zj_name 和 实例方法saySomething，通过下面代码这种方式能否调用实例方法？为什么？ 1234567891011121314@interface ZJPerson : NSObject@property (nonatomic,copy)NSString * zj_name;- (void)saySomething;@end@implementation ZJPerson- (void)saySomething&#123; NSLog(@&quot;%s&quot;,__func__);&#125;@end// 不一般的调用实例的方法Class cls = [ZJPerson class];void *zj = &amp;cls;[(__bridge id)zj saySomething]; 【代码调试】 我们在日常开发中的调用方式是下面这种 123// 常见的调用实例方法ZJPerson * person = [[ZJPerson alloc] init];[person saySomething]; 通过运行发现，是可以执行的，打印结果如下： 122022-03-16 10:30:27.686250+0800 load+initialize-demo[6296:4626148] -[ZJPerson saySomething]2022-03-16 10:30:27.686295+0800 load+initialize-demo[6296:4626148] -[ZJPerson saySomething] [person saySomething] 的本质是 对象发送消息，那么当前的 person 是什么？ person 的 isa 指向类 ZJPerson， 即 person 的首地址 指向 ZJPerson 的首地址，我们可以通过 ZJPerson 的内存平移找到 cache，在 cache 中查找方法 [(__bridge id)zj saySomething] 中的 zj 是来自于 ZJPerson 这个类，然后有一个指针 zj，将其 指向ZJPerson的首地址 所以，person 是指向 ZJPeron 类的结构，zj 也是指向 ZJPerson 类的结构，然后都是在 ZJPerson 中的 methodList 中查找方法 修改：saySomething里面有属性 self.zj_name 的打印12345678910111213- (void)saySomething&#123; NSLog(@&quot;%s - %@&quot;,__func__,self.zj_name);&#125;// 下面这两种方式调用// 方式一Class cls = [ZJPerson class];void *zj = &amp;cls;[(__bridge id)zj saySomething]; // 方式二ZJPerson * person = [[ZJPerson alloc] init];[person saySomething]; 查看这两种调用方式的打印结果，如下所示 zj 方式的调用打印的 zj_name 是 &lt;ViewController: 0x100e06eb0&gt; person 方式调用打印的 zj_name 是 (null) 为什么会出现打印不一致的情况？ 其中 person 方式的 zj_name 是由于 self指向person的内部结构，然后通过 内存平移8字节，取出去zj_name，即 self指针首地址平移8字节获取 【方式一】其中 zj 指针中没有任何，所以 zj表示8字节指针，self.zj_name 的获取，相当于 zj首地址的指针也需要平移8字节找zj_name，那么此时的zj的指针地址是多少？平移8字节获取的是什么？ zj 是一个指针，是存在 栈 中的，栈是一个 先进后出 的结构，参数传入就是一个不断压栈的过程 其中 隐藏参数会压入栈，且每个函数都会有两个隐藏参数 (id self,sel _cmd)，可以通过 clang 查看底层编译 隐藏参数压栈 的过程，其地址是 递减 的，而 栈是从高地址 -&gt; 低地址分配 的，即 在栈中，参数会从前往后一直压 super通过clang查看底层的编译，是 objc_msgSendSuper，其第一个参数是一个结构体 __rw_objc_super（self,class_getSuperclass），那么结构体中的属性时如何压栈的？可以通过自定义一个结构体，判断结构体内部成员的压栈情况 p &amp;person3 p *(NSNumber **)0x000000016d2f59f0 p *(NSNumber **)0x000000016d2f59f8 1234struct zj_struct&#123; NSNumber *num1; NSNumber *num2;&#125;zj_struct; 所以图中可以得到 20先加入，再加入10，因此 结构体内部 的压栈情况是 低地址 -&gt; 高 地址，递增 的，栈中 结构体内部 的成员是 反向 压入栈，即 低地址 -&gt; 高地址，是递增的 所以到目前为止，栈中 从高地址到低地址 的顺序的：self -&gt; _cmd -&gt; (id)class_getSuperclass(objc_getClass(&quot;ViewController&quot;)) -&gt; self -&gt; cls -&gt; zj -&gt; person self 和 _cmd 是 viewDidLoad 方法的两个隐藏的参数，是高地址 -&gt; 低地址 正向压栈 的 class_getSuperClass 和 self 为 objc_msgSendSuper2 中的结构体成员，是从最后一个成员变量，即低地址 -&gt; 高地址 反向压栈 的 可以通过下面这段代码打印下栈的存储是否如上面所说 其中为什么 class_getSuperclass 是 viewController，因为 objc_msgSendSuper2 返回的是 当前类，两个self，并不是同一个self，而是栈的指针不同，但是指向同一片内存空间 [(__bridge id)zj saySomething] 调用时，此时的 zj 是 ZJPerson：0x16bbc1a08 ，所以 saySomething 方法中传入的 self 还是 ZJPerson ，但并不是我们通常认为的 ZJPerson，使我们当前 传入的消息接收者，即 ZJPerson：0x16bbc1a08，是ZJPerson的实例对象，此时操作与普通的ZJPerson是一致的，即 ZJPerson的地址内存平移8字节 普通person流程：person -&gt; zj_name -&gt; 内存平移8字节 zj流程：0x16bbc1a08 + 0x8 - &gt; 0x16bbc1a10，即为 self，指向 &lt;ViewController: 0x10470a370&gt;，如下图所示 其中 person 与 ZJPerson 的关系是 person是以ZJPerson为模板实例化对象，即alloc有一个指针地址，指向isa，isa指向ZJPerson，它们之间关联是由一个isa指向 而zj也是指向ZJPerson的关系，编译器会人为 zj也是ZJPerson的一个实例化对象，即 zj相当于isa，即首地址，指向ZJPerson，具有和person一样的效果，简单来说，我们已经完全将编译器骗过了，即zj也有zj_name，由于 person查找zj_name是通过内存地址平移8字节，所以zj也是通过内存地址平移8字节去查找zj_name。 哪些东西在栈里？哪些在堆里？ alloc 的对象都在 堆 中 指针、对象 在 栈 中，例如 person指向的空间 在 堆 中，person所在的空间在 栈 中 临时变量 在 栈 中 属性值 在 堆，属性随对象是在 栈 中 【注意】 堆 是从小到大，即低地址 -&gt; 高地址 栈 是从大到小，即从高地址 -&gt; 低地址分配 函数隐藏参数会 从前往后 一直压，即 从高地址 -&gt; 低地址 开始入栈。 结构体内部成员是 从低地址 -&gt; 高地址 一般情况下，内存地址有如下规则 0x60 开头表示在 堆 中 0x70 开头的地址表示在 栈 中 0x10 开头的地址表示在 全局区域 中 【面试8】runtime是如何实现weak的，为什么可以自动置为nil？ 通过 sideTable 找到我们的 weak_table weak_table 根据 referent 找到或创建 weak_entry_t 然后 append_referrer（entry,referrer） 将我的新弱引用的对象加进去entry 最后 weak_entry_insert，把 entry 加入到我们的 weak_table 底层源码调用流程如下图所示","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理19：类扩展与关联对象","slug":"OC进阶/OC底层原理19：类扩展与关联对象","date":"2020-11-29T07:22:06.000Z","updated":"2022-03-10T01:09:42.000Z","comments":true,"path":"2020/11/29/OC进阶/OC底层原理19：类扩展与关联对象/","link":"","permalink":"https://www.bboyzj.cn/2020/11/29/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8619%EF%BC%9A%E7%B1%BB%E6%89%A9%E5%B1%95%E4%B8%8E%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理18：类的加载（下）","slug":"OC进阶/OC底层原理18：类的加载（下）","date":"2020-11-19T07:21:46.000Z","updated":"2022-03-10T01:09:48.000Z","comments":true,"path":"2020/11/19/OC进阶/OC底层原理18：类的加载（下）/","link":"","permalink":"https://www.bboyzj.cn/2020/11/19/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8618%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理17：类的加载（上）","slug":"OC进阶/OC底层原理17：类的加载（上）","date":"2020-11-03T07:21:34.000Z","updated":"2022-03-10T01:09:54.000Z","comments":true,"path":"2020/11/03/OC进阶/OC底层原理17：类的加载（上）/","link":"","permalink":"https://www.bboyzj.cn/2020/11/03/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8617%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理16：dyld与objc的关联","slug":"OC进阶/OC底层原理16：dyld与objc的关联","date":"2020-10-20T07:21:21.000Z","updated":"2023-02-25T20:57:46.222Z","comments":true,"path":"2020/10/20/OC进阶/OC底层原理16：dyld与objc的关联/","link":"","permalink":"https://www.bboyzj.cn/2020/10/20/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8616%EF%BC%9Adyld%E4%B8%8Eobjc%E7%9A%84%E5%85%B3%E8%81%94/","excerpt":"","text":"前言本文的主要目的是理解 dyld 与 objc 是如何关联的？ 在上两篇文章中，我们梳理了 dyld 的加载流程，下面来详细介绍下 dyld 和 objc 的关联 _objc_init 源码解析首先，来看下libObjc中的_objc_init方法源码 12345678910111213141516171819202122232425262728293031323334353637void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? //读取影响运行时的环境变量，如果需要，还可以打开环境变量帮助 export OBJC_HELP = 1 environ_init(); //关于线程key的绑定，例如线程数据的析构函数 tls_init(); //运行C++静态构造函数，在dyld调用我们的静态析构函数之前，libc会调用_objc_init(),因此我们必须自己做 static_init(); //runtime运行时环境初始化，里面主要是unattachedCategories、allocatedClasses -- 分类初始化 runtime_init(); //初始化libobjc的异常处理系统 exception_init(); //缓存条件初始化 cache_init(); //启动回调机制，通常这不会做什么，因为所有的初始化都是惰性的，但是对于某些进程，我们会迫不及待地加载trampolines dylib _imp_implementationWithBlock_init(); /* _dyld_objc_notify_register -- dyld 注册的地方 - 仅供objc运行时使用 - 注册处理程序，以便在映射、取消映射 和初始化objc镜像文件时使用，dyld将使用包含objc_image_info的镜像文件数组，回调 mapped 函数 map_images:dyld将image镜像文件加载进内存时，会触发该函数 load_images：dyld初始化image会触发该函数 unmap_image：dyld将image移除时会触发该函数 */ _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);#if __OBJC2__ didCallDyldNotifyRegister = true;#endif&#125; 根据源码所知，主要分为以下几部分： environ_init：初始化一系列环境变量，并读取影响运行时的环境变量 tls_init：关于线程key的绑定 static_init：运行C++静态构造函数（只会运行系统级别的构造函数），在dyld调用静态析构函数之前，libc会调用_objc_init runtime_init：runtime运行时环境初始化，里面操作是unattachedCategories、allocatedClasses（表的初始化） exception_init：初始化libObjc的异常处理系统 cache_init： cache缓存初始化 _imp_implementationWithBlock_init ：启动回调机制，通常这不会做什么，因为所有的初始化都是惰性的，但是对于某些进程，我们会迫不及待地加载trampolines dylib _dyld_objc_notify_register： dyld的注册 下面主要针对以上几部分配合源码进行说明 environ_init方法：环境变量初始化environ_init方法的源码如下，其中的关键代码是 for 循环 123456789101112void environ_init(void) &#123; //...省略部分逻辑if (PrintHelp || PrintOptions) &#123; //...省略部分逻辑 for (size_t i = 0; i &lt; sizeof(Settings)/sizeof(Settings[0]); i++) &#123; const option_t *opt = &amp;Settings[i]; if (PrintHelp) _objc_inform(&quot;%s: %s&quot;, opt-&gt;env, opt-&gt;help); if (PrintOptions &amp;&amp; *opt-&gt;var) _objc_inform(&quot;%s is set&quot;, opt-&gt;env); &#125; &#125;&#125; 有以下两种方式可以打印所有的环境变量 将for循环单独拿出来，去除所有条件，打印环境变量 通过终端命令export OBJC_hrlp &#x3D; 1,打印环境变量 这些环境变量，均可以通过target – Edit Scheme – Run –Arguments – Environment Variables配置，其中常用的环境变量主要有以下几个（环境变量汇总见文末！）： DYLD_PRINT_STATISTICS：设置 DYLD_PRINT_STATISTICS 为YES，控制台就会打印 App 的加载时长，包括整体加载时长和动态库加载时长，即main函数之前的启动时间（查看pre-main耗时），可以通过设置了解其耗时部分，并对其进行启动优化。 OBJC_DISABLE_NONPOINTER_ISA：杜绝生成相应的nonpointer isa（nonpointer isa指针地址 末尾为1 ），生成的都是普通的isa OBJC_PRINT_LOAD_METHODS：打印 Class 及 Category 的 + (void)load 方法的调用信息 NSDoubleLocalizedStrings：项目做国际化本地化(Localized)的时候是一个挺耗时的工作，想要检测国际化翻译好的语言文字UI会变成什么样子，可以指定这个启动项。可以设置 NSDoubleLocalizedStrings 为YES。 NSShowNonLocalizedStrings：在完成国际化的时候，偶尔会有一些字符串没有做本地化，这时就可以设置NSShowNonLocalizedStrings 为YES，所有没有被本地化的字符串全都会变成大写。 环境变量 - OBJC_DISABLE_NONPOINTER_ISA以OBJC_DISABLE_NONPOINTER_ISA为例，将其设置为YES，如下图所示 未设置 OBJC_DISABLE_NONPOINTER_ISA前， isa地址的二进制打印，末尾为1 设置OBJC_DISABLE_NONPOINTER_ISA环境变量后，末尾变成了0 所以OBJC_DISABLE_NONPOINTER_ISA可以控制isa优化开关，从而优化整个内存结构 环境变量 - OBJC_PRINT_LOAD_METHODS 配置打印load 方法的环境变量OBJC_PRINT_LOAD_METHODS，设置为YES 在LGPerson类中重写+load函数，运行程序，load函数的打印如下 所以，OBJC_PRINT_LOAD_METHODS可以监控所有的+load方法，从而处理启动优化（后续会总结下启动优化方法） tls_init：线程key的绑定主要是本地线程池的初始化以及析构，源码如下 12345678void tls_init(void)&#123;#if SUPPORT_DIRECT_THREAD_KEYS//本地线程池，用来进行处理 pthread_key_init_np(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);//初始init#else _objc_pthread_key = tls_create(&amp;_objc_pthread_destroyspecific);//析构#endif&#125; static_init：运行系统级别的C++静态构造函数主要是运行系统级别的C++静态构造函数，在dyld调用我们的静态构造函数之前，libc调用_objc_init方法，即系统级别的C++构造函数 先于 自定义的C++构造函数 运行 12345678static void static_init()&#123; size_t count; auto inits = getLibobjcInitializers(&amp;_mh_dylib_header, &amp;count); for (size_t i = 0; i &lt; count; i++) &#123; inits[i](); &#125;&#125; runtime_init：运行时环境初始化主要是运行时的初始化，主要分为两部分：分类初始化、类的表初始化（后续会详细讲解对应的函数） 12345void runtime_init(void)&#123; objc::unattachedCategories.init(32); objc::allocatedClasses.init(); //初始化 -- 开辟的类的表&#125; exception_init：初始化libobjc的异常处理系统主要是初始化libobjc的异常处理系统，注册异常处理的回调，从而监控异常的处理，源码如下 1234void exception_init(void)&#123; old_terminate = std::set_terminate(&amp;_objc_terminate);&#125; 当有crash（crash是指系统发生的不允许的一些指令，然后系统给的一些信号）发生时，会来到_objc_terminate方法，走到uncaught_handler扔出异常 1234567891011121314151617181920212223242526272829303132333435/************************************************************************ _objc_terminate* Custom std::terminate handler.** The uncaught exception callback is implemented as a std::terminate handler. * 1. Check if there&#x27;s an active exception* 2. If so, check if it&#x27;s an Objective-C exception* 3. If so, call our registered callback with the object.* 4. Finally, call the previous terminate handler.**********************************************************************/static void (*old_terminate)(void) = nil;static void _objc_terminate(void)&#123; if (PrintExceptions) &#123; _objc_inform(&quot;EXCEPTIONS: terminating&quot;); &#125; if (! __cxa_current_exception_type()) &#123; // No current exception. (*old_terminate)(); &#125; else &#123; // There is a current exception. Check if it&#x27;s an objc exception. @try &#123; __cxa_rethrow(); &#125; @catch (id e) &#123; // It&#x27;s an objc object. Call Foundation&#x27;s handler, if any. (*uncaught_handler)((id)e);//扔出异常 (*old_terminate)(); &#125; @catch (...) &#123; // It&#x27;s not an objc object. Continue to C++ terminate. (*old_terminate)(); &#125; &#125;&#125; 搜索uncaught_handler，在app层会传入一个函数用于处理异常，以便于调用函数，然后回到原有的app层中，如下所示，其中fn即为传入的函数，即 uncaught_handler 等于 fn 12345678objc_uncaught_exception_handler objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler fn)&#123;// fn为设置的异常句柄 传入的函数，为外界给的 objc_uncaught_exception_handler result = uncaught_handler; uncaught_handler = fn; //赋值 return result;&#125; crash分类crash的主要原因是收到了未处理的信号，主要来源于三个地方： kernel 内核 其他进行 App本身 所以相对应的，crash也分为了3种 Mach异常：是指最底层的内核级异常。用户态的开发者可以直接通过Mach API设置thread，task，host的异常端口，来捕获Mach异常。 Unix信号：又称BSD 信号，如果开发者没有捕获Mach异常，则会被host层的方法ux_exception()将异常转换为对应的UNIX信号，并通过方法threadsignal()将信号投递到出错线程。可以通过方法signal(x, SignalHandler)来捕获single。 NSException 应用级异常：它是未被捕获的Objective-C异常，导致程序向自身发送了SIGABRT信号而崩溃，对于未捕获的Objective-C异常，是可以通过try catch来捕获的，或者通过NSSetUncaughtExceptionHandler()机制来捕获。 针对应用级异常，可以通过注册异常捕获的函数，即NSSetUncaughtExceptionHandler机制,实现线程保活, 收集上传崩溃日志 应用级crash拦截所以在开发中，会针对crash进行拦截处理，即app代码中给一个异常句柄NSSetUncaughtExceptionHandler，传入一个函数给系统，当异常发生后，调用函数（函数中可以线程保活、收集并上传崩溃日志），然后回到原有的app层中，其本质就是一个回调函数，如下图所示 上述方式只适合收集应用级异常，我们要做的就是用自定义的函数替代该ExceptionHandler即可 cache_init：缓存初始化主要是缓存初始化，源码如下 1234567891011121314151617void cache_init()&#123;#if HAVE_TASK_RESTARTABLE_RANGES mach_msg_type_number_t count = 0; kern_return_t kr; while (objc_restartableRanges[count].location) &#123; count++; &#125; //为当前任务注册一组可重新启动的缓存 kr = task_restartable_ranges_register(mach_task_self(), objc_restartableRanges, count); if (kr == KERN_SUCCESS) return; _objc_fatal(&quot;task_restartable_ranges_register failed (result 0x%x: %s)&quot;, kr, mach_error_string(kr));#endif // HAVE_TASK_RESTARTABLE_RANGES&#125; _imp_implementationWithBlock_init：启动回调机制该方法主要是启动回调机制，通常这不会做什么，因为所有的初始化都是惰性的，但是对于某些进程，我们会迫不及待地加载libobjc-trampolines.dylib，其源码如下 123456789101112131415161718192021void_imp_implementationWithBlock_init(void)&#123;#if TARGET_OS_OSX // Eagerly load libobjc-trampolines.dylib in certain processes. Some // programs (most notably QtWebEngineProcess used by older versions of // embedded Chromium) enable a highly restrictive sandbox profile which // blocks access to that dylib. If anything calls // imp_implementationWithBlock (as AppKit has started doing) then we&#x27;ll // crash trying to load it. Loading it here sets it up before the sandbox // profile is enabled and blocks it. // 在某些进程中渴望加载libobjc-trampolines.dylib。一些程序（最著名的是嵌入式Chromium的较早版本使用的QtWebEngineProcess）启用了严格限制的沙箱配置文件，从而阻止了对该dylib的访问。如果有任何调用imp_implementationWithBlock的操作（如AppKit开始执行的操作），那么我们将在尝试加载它时崩溃。将其加载到此处可在启用沙箱配置文件之前对其进行设置并阻止它。 // This fixes EA Origin (rdar://problem/50813789) // and Steam (rdar://problem/55286131) if (__progname &amp;&amp; (strcmp(__progname, &quot;QtWebEngineProcess&quot;) == 0 || strcmp(__progname, &quot;Steam Helper&quot;) == 0)) &#123; Trampolines.Initialize(); &#125;#endif&#125; _dyld_objc_notify_register：dyld注册_dyld_objc_notify_register方法 这个方法的具体实现在 iOS-底层原理 15-1：dyld加载流程 已经有详细说明，其源码实现是在dyld源码中，以下是_dyld_objc_notify_register方法的声明 12345678910111213//// Note: only for use by objc runtime// Register handlers to be called when objc images are mapped, unmapped, and initialized.// Dyld will call back the &quot;mapped&quot; function with an array of images that contain an objc-image-info section.// Those images that are dylibs will have the ref-counts automatically bumped, so objc will no longer need to// call dlopen() on them to keep them from being unloaded. During the call to _dyld_objc_notify_register(),// dyld will call the &quot;mapped&quot; function with already loaded objc images. During any later dlopen() call,// dyld will also call the &quot;mapped&quot; function. Dyld will call the &quot;init&quot; function when dyld would be called// initializers in that image. This is when objc calls any +load methods in that image.//void _dyld_objc_notify_register(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped); 从注释中，可以得出： 仅供objc运行时使用 注册处理程序，以便在映射、取消映射和初始化objc图像时调用 dyld将会通过一个包含objc-image-info的镜像文件的数组回调mapped函数 方法中的三个参数分别表示的含义如下： map_images：dyld将image（镜像文件）加载进内存时，会触发该函数 load_image：dyld初始化image会触发该函数 unmap_image：dyld将image移除时，会触发该函数 dyld与Objc的关联其方法的源码实现与调用如下，即dyld与Objc的关联可以通过源码体现 1234567891011===&gt; dyld源码--具体实现void _dyld_objc_notify_register(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)&#123; dyld::registerObjCNotifiers(mapped, init, unmapped);&#125;🔽===&gt; libobjc源码中--调用_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image); 从上可以得出 mapped 等价于 map_images init 等价于 load_images unmapped 等价于 unmap_image 在iOS-底层原理 15-1：dyld加载流程 中，我们知道了load_images是在notifySingle方法中，通过sNotifyObjCInit调用的，如下所示 然后通过查找sNotifyObjCInit，最终找到了_dyld_objc_notify_register –&gt; registerObjCNotifiers,在该方法中将_dyld_objc_notify_register传入的参数赋值给了3个回调方法 所以 有以下等价关系 sNotifyObjCMapped &#x3D;&#x3D; mapped &#x3D;&#x3D; map_images sNotifyObjCInit &#x3D;&#x3D; init &#x3D;&#x3D; load_images sNotifyObjCUnmapped &#x3D;&#x3D; unmapped &#x3D;&#x3D; unmap_image map_images调用时机 关于load_images的调用时机已经在dyld加载流程中讲解过了，下面以map_images为例，看看其调用时机 dyld中全局搜索 sNotifyObjcMapped ：registerObjCNotifiers – notifyBatchPartial – sNotifyObjCMapped 全局搜索notifyBatchPartial，在registerObjCNotifiers方法中调用 所以有以下结论：map_images是先于load_images调用，即先map_images ，再load_images dyld与Objc关联结合dyld加载流程，dyld与Objc的关联如下图所示 在dyld中注册回调函数，可以理解为 添加观察者 在objc中dyld注册，可以理解为发送通知 触发回调，可以理解为执行通知selector 附录环境变量汇总","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理15：dyld源码分析","slug":"OC进阶/OC底层原理15-1：dyld加载流程","date":"2020-10-10T13:02:58.000Z","updated":"2023-02-25T20:29:31.347Z","comments":true,"path":"2020/10/10/OC进阶/OC底层原理15-1：dyld加载流程/","link":"","permalink":"https://www.bboyzj.cn/2020/10/10/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8615-1%EF%BC%9Adyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/","excerpt":"","text":"前言本文的目的主要是分析 dyld 的加载流程，了解在 main 函数之前，底层还做了什么 印子 创建一个project，在ViewController中重写了 load方法，在main中加了一个 C++方法，即 kcFUnc，请问它们的打印先后顺序是什么？ VC中代码： main.m 中实现： 运行程序，查看 load、kcFunc、main的打印顺序，下面是打印结果，通过结果可以看出其顺序是 load --&gt; C++方法 --&gt; main 那么问题来了？为什么是这么一个顺序？按照常规的思维理解，main不是入口函数吗？为什么不是main最先执行？ 下面根据这个问题，我们来探索在走到main之前，到底还做了什么。 编译过程及库在分析app启动之前，我们需要先了解iOSapp代码的 编译过程以及 动态库和静态库。 编译过程其中 编译过程 如下图所示，主要分为以下几步： 源文件：载入.h、.m、.cpp等文件 预处理：替换宏，删除注释，展开头文件，产生.i文件 编译：将.i文件转换为汇编语言，产生.s文件 汇编：将汇编文件转换为机器码文件，产生.o文件 链接：对.o文件中引用其他库的地方进行引用，生成最后的 可执行文件 MachO 静态库 和 动态库 静态库：在链接阶段，会将可汇编生成的目标程序与引用的库一起链接打包到可执行文件当中。此时的静态库就不会在改变了，因为它是 编译时被直接拷贝一份，复制到目标程序里的 好处：编译完成后，库文件实际上就没有作用了，目标程序没有外部依赖，直接就可以运行 缺点：由于静态库会有两份，所以会导致 目标程序的体积增大，对内存、性能、速度消耗很大 动态库：程序编译时并不会链接到目标程序中，目标程序只会存储指向动态库的引用，在 程序运行时才被载入 优势： 减少打包之后app的大小：因为不需要拷贝至目标程序中，所以不会影响目标程序的体积，与静态库相比，减少了app的体积大小 共享内存，节约资源：同一份库可以被多个程序使用 通过 更新动态库，达到更新程序 的目的：由于运行时才载入的特性，可以随时对库进行替换，而不需要重新编译代码 缺点：动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境，如果环境缺少了动态库，或者库的版本不正确，就会导致程序无法运行 静态库和动态库的图示如图所示: dyld加载流程分析根据 dyld 源码，以及 libobjc、libSystem、libdispatch 源码协同分析 什么是dyld？ dyld（the dynamic link editor）是苹果的 动态链接器，是苹果操作系统的重要组成部分，在app被编译打包成可执行文件格式的 Mach-O 文件后，交由 dyld负责连接，加载程序 所以 App 的启动流程图如下： app启动的起始点 在前文的demo中，在load方法处加一个断点，通过bt堆栈信息查看app启动是从哪里开始的 【app启动起点】：通过程序运行发现，是从 dyld 中的 _dyld_start 开始的，所以需要去 OpenSource 下载一份dyld的源码来进行分析 也可以通过xcode左侧的堆栈信息来找到入口 dyld::_main函数源码分析 在 dyld-750.6 源码中查找 _dyld_start,查找 arm64架构 发现，是由汇编实现，通过汇编注释发现会调用 dyldbootstrap::start(app_mh, argc, argv, dyld_mh, &amp;startGlue) 方法，是一个 C++ 方法（以arm64架构为例） 源码中搜索 dyldbootstrap 找到命名作用空间，再在这个文件中查找 start 方法，其核心是返回值的调用了 dyld的main 函数，其中 macho_header 是 Mach-O 的头部，而 dyld 加载的文件就是 Mach-O 类型的，即 Mach-O 类型是 可执行文件类型，由四部分组成：Mach-O头部、Load Command、section、Other Data，可以通过 MachOView 查看可执行文件信息 进入 dyld::_main 的源码实现，特别长，大约600多行，如果对dyld加载流程不太了解的童鞋，可以根据 _main 函数的返回值进行反推，这里就多作说明。在 _main 函数中主要做了一下几件事情： 【第一步：环境变量配置】：根据环境变量设置相应的值以及获取当前运行架构 【第二步：共享缓存】：检查是否开启了共享缓存，以及共享缓存是否映射到共享区域，例如 UIKit、CoreFoundation 等 【第三步：主程序的初始化】：调用 instantiateFromLoadedImage 函数实例化了一个ImageLoader 对象 【第四步：插入动态库】：遍历DYLD_INSERT_LIBRARIES环境变量，调用loadInsertedDylib加载 【第五步：link 主程序】 【第六步：link 动态库】 【第七步：弱符号绑定】 【第八步：执行初始化方法】 【第九步：寻找主程序入口即main函数】：从Load Command读取LC_MAIN入口，如果没有，就读取LC_UNIXTHREAD，这样就来到了日常开发中熟悉的main函数了 下面主要分析下【第三步】和【第八步】 sMainExecutable 表示主程序变量，查看其赋值，是通过 instantiateFromLoadedImage 方法初始化 进入 instantiateFromLoadedImage 源码，其中创建 一个ImageLoader 实例对象，通过instantiateMainExecutable 方法创建 进入 instantiateMainExecutable 源码，其作用是为主可执行文件创建映像，返回一个ImageLoader 类型的image对象，即主程序。其中 sniffLoadCommands 函数时获取 Mach-O 类型文件的 Load Command 的相关信息，并对其进行各种校验 【第八步：执行初始化方法】 进入 initializeMainExecutable 源码,主要是循环遍历，都会执行runInitializers方法 全局搜索 runInitializers (cons,找到如下源码，其核心代码是processInitializers函数的调用 进入 processInitializers 函数的源码实现，其中对镜像列表调用recursiveInitialization 函数进行递归实例化 全局搜索recursiveInitialization(cons函数,其源码实现如下 在这里，需要分成两部分探索，一部分是notifySingle函数，一部分是doInitialization函数，首先探索notifySingle函数 notifySingle 函数 全局搜索 notifySingle(函数,其重点是(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader());这句 全局搜索 sNotifyObjCInit，发现没有找到实现，有赋值操作 搜索 registerObjCNotifiers 在哪里调用了，发现在 _dyld_objc_notify_register 进行了调用 注意：_dyld_objc_notify_register 的函数需要在 libobjc 源码中搜索 在 objc4-781 源码中搜索 _dyld_objc_notify_register，发现在 _objc_init 源码中调用了该方法，并传入了参数，所以 sNotifyObjCInit 的赋值的就是 objc 中的load_images，而 load_images 会调用所有的 +load 方法。所以综上所述，notifySingle 是一个回调函数 load函数加载下面我们进入 load_images 的源码看看其实现，以此来证明 load_images 中调用了所有的load函数 通过objc源码中_objc_init源码实现，进入load_images的源码实现 进入 call_load_methods 源码实现，可以发现其核心是通过 do-while 循环调用 +load 方法 进入 call_class_loads 源码实现，了解到这里调用的 load 方法证实我们前文提及的类的load方法 所以，load_images 调用了所有的 load 函数，以上的源码分析过程正好对应堆栈的打印信息 【总结】load的源码链为：_dyld_start -&gt; dyldbootstrap::start -&gt; dyld::_main -&gt; dyld::initializeMainExecutable -&gt; ImageLoader::runInitializers -&gt; ImageLoader::processInitializers -&gt; ImageLoader::recursiveInitialization -&gt; dyld::notifySingle(是一个回调处理) -&gt; sNotifyObjCInit –&gt; load_images(libobjc.A.dylib) 那么问题又来了，_objc_init 是什么时候调用的呢？请接着往下看 doInitialization 函数 走到 objc 的 _objc_init 函数，发现走不通了，我们回退到 recursiveInitialization 递归函数的源码实现，发现我们忽略了一个函数 doInitialization 进入doInitialization函数的源码实现 这里也需要分成两部分，一部分是 doImageInit 函数，一部分是 doModInitFunctions 函数 进入 doImageInit 源码实现，其核心主要是for循环加载方法的调用，这里需要注意的一点是，libSystem的初始化必须先运行 进入 doModInitFunctions 源码实现，这个方法中加载了所有 Cxx 文件 走到这里，还是没有找到_objc_init的调用？怎么办呢？放弃吗？当然不行，我们还可以通过_objc_init加一个符号断点来查看调用_objc_init前的堆栈信息， _objc_init 加一个符号断点，运行程序，查看_objc_init断住后的堆栈信息 在libsystem中查找libSystem_initializer，查看其中的实现 根据前面的堆栈信息，我们发现走的是 libSystem_initializer 中会调用libdispatch_init 函数，而这个函数的源码是在 libdispatch 开源库中的，在libdispatch中搜索libdispatch_init 进入 _os_object_init 源码实现，其源码实现调用了 _objc_init 函数 结合上面的分析，从初始化_objc_init注册的_dyld_objc_notify_register的参数2，即load_images，到sNotifySingle –&gt; sNotifyObjCInie&#x3D;参数2 到sNotifyObjcInit()调用，形成了一个闭环 所以可以简单的理解为sNotifySingle这里是添加通知即addObserver，_objc_init中调用_dyld_objc_notify_register相当于发送通知，即push，而sNotifyObjcInit相当于通知的处理函数，即selector 【总结】：_objc_init的源码链：_dyld_start –&gt; dyldbootstrap::start –&gt; dyld::_main –&gt; dyld::initializeMainExecutable –&gt; ImageLoader::runInitializers –&gt; ImageLoader::processInitializers –&gt; ImageLoader::recursiveInitialization –&gt; doInitialization –&gt;libSystem_initializer（libSystem.B.dylib） –&gt; _os_object_init（libdispatch.dylib） –&gt; _objc_init(libobjc.A.dylib) 第九步：寻找主入口函数 汇编调试，可以看到显示来到 +[ViewController load] 方法 继续执行，来到 kcFunc 的 C++ 函数 点击stepover,继续往下，跑完了整个流程，会回到 _dyld_start,然后调用main()函数,通过汇编完成main的参数赋值等操作 dyld汇编源码实现 所以，综上所述，最终dyld加载流程，如下图所示，图中也诠释了前文中的问题：为什么是load–&gt;Cxx–&gt;main的调用顺序","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理14-3：objc_msgSend之动态方法决议 & 消息转发","slug":"OC进阶/OC底层原理14-3：objc_msgSend之动态方法决议&消息转发","date":"2020-10-06T02:13:46.000Z","updated":"2023-02-25T19:00:06.038Z","comments":true,"path":"2020/10/06/OC进阶/OC底层原理14-3：objc_msgSend之动态方法决议&消息转发/","link":"","permalink":"https://www.bboyzj.cn/2020/10/06/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8614-3%EF%BC%9Aobjc_msgSend%E4%B9%8B%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E5%86%B3%E8%AE%AE&%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/","excerpt":"","text":"前言 在前面两篇文章中，分别分析了 objc_msgSend 的 快速查找(缓存) 和 慢速查找(方法列表)，其整个流程： objc_msgSend -&gt; 慢速缓存查找(没有) -&gt; 慢速方法列表二分查找自己(有) -&gt; cache_fill -&gt; objc_msgSend 整个闭环 慢速方法列表二分查找没有找到 -&gt; 父类去查找（缓存 -&gt; 方法列表） -&gt; 根类（NSObject）也没找到 在这两种方法都没找到方法实现的情况下，苹果给了两条建议 动态方法决议：慢速查找流程未能找到，会执行一次动态方法决议 消息转发：如果动态方法决议仍然没有找到实现，则进行消息转发 如果这两个建议都没有作出任何操作，就会报我们日常开发中常见的 方法未实现 的 崩溃报错，其步骤如下 定义 ZJPerson 类，其中 say666 实例方法 和 sayNB 类方法均没有实现 调用类方法 sayNB 的报错结果 方法未实现报错源码根据 慢速查找 的源码，我们发现，其报错最后都是走到 __objc_msgForward_impcache 方法，本质是调用的 objc_defaultForwardHandler 方法 下面我们来讲讲如何在崩溃前，防止方法未实现的崩溃 三次方法查找的挽救机会根据苹果建议，我们一共有三次挽救的机会： 【第一次机会】：动态方法决议 消息转发流程： 【第二次机会】：快速转发 【第三次机会】：慢速转发 【第一次机会】动态方法决议在 慢速查找 流程 未找到 方法实现时，首先会 尝试一次动态方法决议，其源码实现如下： 123456789101112131415161718192021222324252627static NEVER_INLINE IMPresolveMethod_locked(id inst, SEL sel, Class cls, int behavior)&#123; runtimeLock.assertLocked(); ASSERT(cls-&gt;isRealized()); runtimeLock.unlock(); // 对象 -&gt; 类 if (! cls-&gt;isMetaClass()) &#123; // 类不是元类，调用对象的解析方法 // try [cls resolveInstanceMethod:sel] resolveInstanceMethod(inst, sel, cls); &#125; else &#123; // 如果是元类，调用类的解析方法，类 -&gt; 元类 // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] resolveClassMethod(inst, sel, cls); // 为什么要有这行代码？ -&gt; 类方法在元类中是对象方法，所以还是需要查询元类中对象方法的动态方法决议 if (!lookUpImpOrNil(inst, sel, cls)) &#123; // 如果没有找到或者为空，在元类的对象方法解析方法中查找 resolveInstanceMethod(inst, sel, cls); &#125; &#125; // chances are that calling the resolver have populated the cache // so attempt using it // 如果方法解析中奖其实现指向其他方法，则继续走方法查找流程 return lookUpImpOrForward(inst, sel, cls, behavior | LOOKUP_CACHE);&#125; 主要分为以下几个步骤 判断类是否是元类 如果是 类，执行 实例方法 的动态方法决议 resolveInstanceMethod 如果是 元类，执行 类方法 的动态方法决议 resolveClassMethod，如果在元类中 没有找到 或者为 空，则在 元类 的 实例方法 的动态方法决议 resolveInstanceMethod 中查找，主要是因为 类方法在元类中是实例方法，所以还需要查找元类中实例方法的动态方法决议 如果 动态方法决议 中，将其 实现指向了其他方法，则继续 查找指定的imp，即继续慢速查找 lookupImpOrForward 实例方法针对 实例方法 调用，在 快速、慢速查找 均没有找到 实例方法 的实现时，我们有一次挽救的机会，即尝试一次 动态方法决议，由于是 实例方法，所以会走到 resolveInstanceMethod 方法，其源码如下： 12345678910111213141516171819202122232425262728293031323334353637static void resolveInstanceMethod(id inst, SEL sel, Class cls)&#123; runtimeLock.assertUnlocked(); ASSERT(cls-&gt;isRealized()); SEL resolve_sel = @selector(resolveInstanceMethod:); // look的是 resolveInstanceMethod 相当于是发送消息前的容错处理 if (!lookUpImpOrNil(cls, resolve_sel, cls-&gt;ISA())) &#123; // Resolver not implemented. return; &#125; BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(cls, resolve_sel, sel); // 发送resolve_sel消息 // Cache the result (good or bad) so the resolver doesn&#x27;t fire next time. // +resolveInstanceMethod adds to self a.k.a. cls // 查找say666 IMP imp = lookUpImpOrNil(inst, sel, cls); if (resolved &amp;&amp; PrintResolving) &#123; if (imp) &#123; _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot; &quot;dynamically resolved to %p&quot;, cls-&gt;isMetaClass() ? &#x27;+&#x27; : &#x27;-&#x27;, cls-&gt;nameForLogging(), sel_getName(sel), imp); &#125; else &#123; // Method resolver didn&#x27;t add anything? _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot; &quot;, but no new implementation of %c[%s %s] was found&quot;, cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? &#x27;+&#x27; : &#x27;-&#x27;, cls-&gt;nameForLogging(), sel_getName(sel)); &#125; &#125;&#125; 主要分为以下几个步骤 在 发送resolveInstanceMethod消息 前，需要查找 cls类 中是否有该方法的 实现，即通过 lookupImpOrNil 方法又会进入 lookupImpOrForward 慢速查找流程查找 resolveInstanceMethod 方法 如果没有，则直接返回 如果有，则发送 resolveInstanceMethod 消息 再次慢速查找实例方法的实现，即通过 lookupImpOrNil 方法又会进入 lookupImpOrForward 慢速查找流程查找 实例方法 崩溃修改 所以，针对 实例方法sya666 未实现的报错崩溃，可以通过在 类 中 重写resolveInstanceMethod类方法，并将其指向其他方法的实现，即在 ZJPerson 中 重写resolveInstanceMethod类方法，将 实例方法sya666 的实现指向 sayMaster 方法实现，如下所示 1234567891011121314151617181920212223242526@interface ZJPerson : NSObject- (void)say666;- (void)sayMaster;@end@implementation ZJPerson- (void)sayMaster&#123; NSLog(@&quot;say666&quot;);&#125;// 重写resolveInstanceMethod+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if (sel == @selector(say666)) &#123; NSLog(@&quot;%@ 来了&quot;,NSStringFromSelector(sel)); // 获取sayMaster方法的imp IMP imp = class_getMethodImplementation(self, @selector(sayMaster)); // 获取sayMaster的实例方法 Method sayMethod = class_getInstanceMethod(self, @selector(sayMaster)); // 获取sayMaster的丰富签名 const char * type = method_getTypeEncoding(sayMethod); // 将sel的实现指向sayMaster return class_addMethod(self, sel, imp, type); &#125; return [super resolveInstanceMethod:sel];&#125;@end 重新运行，其打印结果如下： 类方法针对 类方法，与实例方法类似，同样可以通过重写 resolveClassMethod 类方法来解决前文的崩溃问题，即在 ZJPerson 类中重写该方法，并将 sayNB 类方法的实现 指向类方法zjClassMethod 123456789101112131415161718192021@interface ZJPerson : NSObject+ (void)sayNB;+ (void)zjClassMethod;@end@implementation ZJPerson+ (void)zjClassMethod&#123; NSLog(@&quot;sayNB&quot;);&#125;+ (BOOL)resolveClassMethod:(SEL)sel&#123; if (sel == @selector(sayNB)) &#123; NSLog(@&quot;%@ 来了&quot;,NSStringFromSelector(sel)); IMP imp = class_getMethodImplementation(objc_getMetaClass(&quot;ZJPerson&quot;), @selector(zjClassMethod)); Method zjClassMethod = class_getInstanceMethod(objc_getMetaClass(&quot;ZJPerson&quot;), @selector(zjClassMethod)); const char * type = method_getTypeEncoding(zjClassMethod); return class_addMethod(objc_getMetaClass(&quot;ZJPerson&quot;), sel, imp, type); &#125; return [super resolveClassMethod:sel];&#125;@end resolveClassMethod 类方法的重写需要注意一点，传入的 cls 不再是类，而是 元类，可以通过 objc_getMetaClass 方法 获取元类，原因是因为 类方法在元类中是实例方法 优化 上面的这种方式是单独再每个类中重写，有没有更好的，一劳永逸的方法呢？其实通过方法慢速查找流程可以发现其查找路径有两条 实例方法：类 -&gt; 父类 -&gt; 根类 -&gt; nil 类方法：元类 -&gt; 根元类 -&gt; 根类 -&gt; nil 它们的共同点是如果前面没找到，都会来到 根类即NSObject中查找，所以我们是否可以将上述的两个方法统一整合在一起呢？答案是 可以的，可以通过 NSObject添加分类 的方式来 实现同意处理，而且由于类方法的查找，在其集成链，查找的也是实例方法，所以将 实例方法 和 类方法 的统一处理放在 resolveInstanceMethod 方法中，如下所示： 1234567891011121314151617181920212223@interface NSObject (ZJ)@end@implementation NSObject (ZJ)+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if (sel == @selector(say666)) &#123; NSLog(@&quot;%@ 来了&quot;,NSStringFromSelector(sel)); IMP imp = class_getMethodImplementation(self, @selector(sayMaster)); Method sayMethod = class_getInstanceMethod(self, @selector(sayMaster)); const char *type = method_getTypeEncoding(sayMethod); return class_addMethod(self, sel, imp, type); &#125;else if (sel == @selector(sayNB))&#123; NSLog(@&quot;%@ 来了&quot;,NSStringFromSelector(sel)); IMP imp = class_getMethodImplementation(objc_getMetaClass(&quot;ZJPerson&quot;), @selector(zjClassMethod)); Method zjClassMethod = class_getInstanceMethod(objc_getMetaClass(&quot;ZJPerson&quot;), @selector(zjClassMethod)); const char * type = method_getTypeEncoding(zjClassMethod); return class_addMethod(objc_getMetaClass(&quot;ZJPerson&quot;), sel, imp, type); &#125; return NO;&#125;@end 这样方式的实现，正好与源码中针对类方法的处理逻辑是一致的，即完美阐述为什么调用了类方法动态方法决议，还要调用对象方法的动态方法决议，其根本原因还是 类方法在元类中的实例方法 当然，上面这种写法还是会有其他问题，比如 系统方法也会被更改，针对这一点，是可以优化的，即我们 可以针对自定义类中方法同意方法名的前缀，根据前缀来判断是否是自定义方法，然后 统一处理自定义方法，例如可以在崩溃前pop到首页，主要是用于 app线上防崩溃的处理，提升用户的体验 消息转发流程在慢速查找的流程中，我们了解到，如果快速+慢速没有找到方法实现，动态方法决议也不行，就使用 消息转发，但是，我们找遍了源码也没有发现消息转发的相关源码，可以通过以下方式来了解，方法调用崩溃前都走了哪些方法 通过 instrumentObjcMessageSends 方式打印发小消息的日志 通过 hopper/IDA反编译 通过 instrumentObjcMessageSends 通过 lookUpImpOrForward -&gt; log_and_fill_cache -&gt; logMessageSend，在logMessageSend源码下方找到 instrumentObjcMessageSends 的源码实现，在main中调用 instrumentObjcMessageSends 打印方法调用的日志信息，有以下两点准备工作 打开 objcMsgLogEnabled 开关，即调用 instrumentObjcMessageSends 方法时，传入 YES 在 main 中通过 extern 声明 instrumentObjcMessageSends 方法 123456789101112131415extern void instrumentObjcMessageSends(BOOL flag);int main(int argc, char * argv[]) &#123; NSString * appDelegateClassName; @autoreleasepool &#123; ZJPerson * person = [ZJPerson alloc]; instrumentObjcMessageSends(YES); [person sayHello]; instrumentObjcMessageSends(NO); appDelegateClassName = NSStringFromClass([AppDelegate class]); &#125; return UIApplicationMain(argc, argv, nil, appDelegateClassName);&#125; 通过 logMessageSend 源码，了解到消息发送打印信息存储在 /tmp/msgSends 目录，如下所示： 运行代码，并前往 /tmp/msgSends/ 目录，发现有 msgSends 开头的日志文件，打开发现崩溃前，执行了以下方法： 两次 动态方法决议：resolveInstanceMethod 方法 两次 消息快速转发：forwardingTargetForSelector 方法 两次 消息慢速转发：methodSignatureForSelector + resolveInvocation 通过hopper&#x2F;IDA反编译Hopper 和 IDA 是一个可以帮助我们静态分析可视性文件的工具，可以将执行文件反编译成伪代码、控制流程图等，下面以Hopper为例（注：hopper高级版本是一款收费软件，针对比较简单的反汇编需求来说，demo版本足够使用了） 运行程序崩溃，查看堆栈信息 发现 __forwarding__ 来自 CoreFoundation 通过 image list，读取整个镜像文件，然后搜索 CoreFoundation，查看其可执行文件的路径 通过文件路径，找到 CoreFoundation 的 可执行文件 打开hopper，选择Try the Demo，然后将上一步的可执行文件拖入hopper进行反汇编，选择x86(64 bits) 以下是反汇编后的界面，主要使用上面的三个功能，分别是 汇编、流程图、伪代码 通过左侧的搜索框搜索__forwarding_prep_0___，然后选择伪代码 以下是__forwarding_prep_0___的汇编伪代码，跳转至___forwarding___ 以下是___forwarding___的伪代码实现，首先是查看是否实现forwardingTargetForSelector方法，如果没有响应，跳转至loc_6459b即快速转发没有响应，进入慢速转发流程 跳转至loc_6459b，在其下方判断是否响应methodSignatureForSelector方法 如果没有响应，跳转至loc_6490b，则直接报错 如果获取methodSignatureForSelector的方法签名为nil，也是直接报错 如果methodSignatureForSelector返回值不为空，则在forwardInvocation方法中对invocation进行处理 所以，通过上面两种查找方式可以验证，消息转发 的方法有3个 【快速转发】forwardingTargetForSelector 【慢速转发】 methodSignatureForSelector forwardInvocation 所以，综上所述，消息转发整体的流程如下 消息转发 的处理主要分为两部分： 【快速转发】当慢速查找以及动态方法决议没有找到实现时，进行消息转发，首先是进行 快速消息转发，即走到 forwardingTargetForSelector 方法 如果返回 消息接收者，在消息接收者中还是没有找到，则进入另一个方法的查找流程 如果返回 nil，则进入 慢速消息转发 【慢速转发】执行到 methodSignalForSelector 方法 如果返回的 方法签名 为 nil，则直接 崩溃报错 如果返回的方法签名 不为nil，走到 forwardInvocation 方法中，对invocation事务进行处理，如果不处理也不会报错 【第二次机会】快速转发针对前文的崩溃问题，如果 动态方法决议 也没有找到方法实现，则需要在 ZJPerson 中重写 forwardingTargetForSelector 方法，将ZJPerson的实例方法的 接收者指定为ZJStudent 的对象（ZJStudent类中有say666的具体实现），如下所示 12345678910111213141516171819202122232425262728293031// ZJPerson类@interface ZJPerson : NSObject- (void)say666;@end@implementation ZJPerson- (id)forwardingTargetForSelector:(SEL)aSelector&#123; NSLog(@&quot;%s - %@&quot;,__func__,NSStringFromSelector(aSelector)); // 将消息接收者指定为ZJStudent，在ZJStudent中查找say666的实现 return [ZJStudent alloc];&#125;@end// ZJStudent类@interface ZJStudent : NSObject@end@implementation ZJStudent- (void)say666&#123; NSLog(@&quot;say666&quot;);&#125;@end// main中int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; ZJPerson * person = [ZJPerson new]; [person say666]; &#125; return 0;&#125; 执行结果如下 也可以直接不指定消息接收者，直接调用父类的该方法，如果还是没有找到，则 直接报错 【第三次机会】慢速转发针对 第二次机会即快速转发 中还是没有找到，则进入最后的一次挽救机会，即在 ZJPerson 中重写 methodSignalForSelector，如下所示 123456789// 慢速转发- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; NSLog(@&quot;%s - %@&quot;,__func__,NSStringFromSelector(aSelector)); return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; NSLog(@&quot;%s - %@&quot;,__func__,anInvocation);&#125; 打印结果如下，发现 forwardInvocation 方法中不对 invocation 进行处理，也不会崩溃 也可以 处理invocation 事务，如下所示，修改 invocation 的 target 为 [ZJStudent alloc]，调用 [anInvocation invoke] 触发 即ZJPerson 类的 say666 实例方法的调用会调用 ZJStudent 的 say666 方法 12345- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; NSLog(@&quot;%s - %@&quot;,__func__,anInvocation); anInvocation.target = [ZJStudent alloc]; [anInvocation invoke];&#125; 执行结果如下 https://user-images.githubusercontent.com/25925248/160738899-270d3fb2-e047-4f64-a962-23b5278f8ddd.jpg 所以，由上述可知，无论在 forwardInvocation 方法中 是否处理invocation 事务，程序都不会崩溃 总结到目前为止，objc_msgSend 发送消息的流程就分析完成了，在这里简单总结下 【快速查找流程】在类的 缓存cache 中查找指定方法的实现 【慢速查找流程】如果缓存中 没有找到，则在 类的方法列表 中查找，如果还是没有找到，则去 父类的缓存和方法列表中 查找 【动态方法决议】如果慢速查找 还是没有找到，第一次挽救的机会就是 尝试一次动态方法决议，即 重写resolveInstanceMethod/resolveClassMethod 方法 【消息转发】如果动态方法决议还是没有找到，则进行 消息转发，消息转发中有 两次挽救几会：快速转发+慢速转发 如果转发之后也没有，则程序直接报错崩溃 unrecognized selector sent to instance","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理14-2：objc_msgSend方法列表查找(快速查找)汇编分析","slug":"OC进阶/OC底层原理14-2：objc_msgSend方法列表查找(慢速查找)汇编分析","date":"2020-10-05T02:12:37.000Z","updated":"2023-02-25T18:21:38.843Z","comments":true,"path":"2020/10/05/OC进阶/OC底层原理14-2：objc_msgSend方法列表查找(慢速查找)汇编分析/","link":"","permalink":"https://www.bboyzj.cn/2020/10/05/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8614-2%EF%BC%9Aobjc_msgSend%E6%96%B9%E6%B3%95%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE(%E6%85%A2%E9%80%9F%E6%9F%A5%E6%89%BE)%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90/","excerpt":"","text":"前言上一章我们了解了 objc_msgSend消息发送慢速查找流程 即 缓存CacheLookup查找 这一章我们来学习 objc_msgSend消息发送慢速查找流程 即 MethodTableLookup(即查询方法列表) 方法列表查找汇编分析在 缓存CacheLookup查找 过程中，如果没有找到方法实现，无论是走到 CheckMiss 还是 JumpMiss，最终都会走到 __objc_msgSend_uncached 汇编函数 在 objc-msg-ram64.s 文件中查找 __objc_msgSend_uncached 的汇编实现，其中的核心是 MethodTableLookup(即查询方法列表) ，其源码如下： __objc_msgSend_uncached源码 1234567891011STATIC_ENTRY __objc_msgSend_uncachedUNWIND __objc_msgSend_uncached, FrameWithNoSaves// THIS IS NOT A CALLABLE C FUNCTION// Out-of-band p16 is the class to search// 开始查询方法列表MethodTableLookup TailCallFunctionPointer x17END_ENTRY __objc_msgSend_uncached 搜索 MethodTableLookup 的汇编实现，其中的核心是 _lookUpImpOrForward，汇编源码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344.macro MethodTableLookup // push frame SignLR stp fp, lr, [sp, #-16]! mov fp, sp // save parameter registers: x0..x8, q0..q7 sub sp, sp, #(10*8 + 8*16) stp q0, q1, [sp, #(0*16)] stp q2, q3, [sp, #(2*16)] stp q4, q5, [sp, #(4*16)] stp q6, q7, [sp, #(6*16)] stp x0, x1, [sp, #(8*16+0*8)] stp x2, x3, [sp, #(8*16+2*8)] stp x4, x5, [sp, #(8*16+4*8)] stp x6, x7, [sp, #(8*16+6*8)] str x8, [sp, #(8*16+8*8)] // lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER) // receiver and selector already in x0 and x1 mov x2, x16 mov x3, #3 bl _lookUpImpOrForward // 核心源码 // IMP in x0 mov x17, x0 // restore registers and return ldp q0, q1, [sp, #(0*16)] ldp q2, q3, [sp, #(2*16)] ldp q4, q5, [sp, #(4*16)] ldp q6, q7, [sp, #(6*16)] ldp x0, x1, [sp, #(8*16+0*8)] ldp x2, x3, [sp, #(8*16+2*8)] ldp x4, x5, [sp, #(8*16+4*8)] ldp x6, x7, [sp, #(8*16+6*8)] ldr x8, [sp, #(8*16+8*8)] mov sp, fp ldp fp, lr, [sp], #16 AuthenticateLR.endmacro 由汇编源码可知，最终跳转到 bl _lookUpImpOrForward 中 验证 上述汇编的过程，可以通过 汇编调式来验证 在 main 中，例如 [person sayNB] 对象方法调用处加一个断点，并且开启汇编调试 Debug -&gt; Debug workflow -&gt; 勾选 Always show Disassembly，运行程序 汇编中 objc_msgSend 加一个断点，执行断住，按住 control + stepinto，进入 objc_msgSend 的汇编 在 _objc_msgSend_uncached 加一个断点，执行断住，按住 control + stepinto，进入汇编 从上面可以看出最后走到的就是 lookUpImpOrForward ，此时并不是汇编实现 123注：1、C/C++中调用汇编，去查找汇编时，C/C++调用的方法需要 `多加一个下划线`2、汇编中调用C/C++方法时，去查找C/C++方法，需要将汇编调用的 `方法去掉一个下划线` MethodTableLookup(即查询方法列表)慢速查找 C&#x2F;C++ 部分 根据汇编部分的提示全局搜索 lookUpImpOrForward，最后在 objc-runtime-new.mm 文件中找到了源码实现，这是一个 c实现的函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)&#123; // 定义的消息转发 const IMP forward_imp = (IMP)_objc_msgForward_impcache; IMP imp = nil; Class curClass; runtimeLock.assertUnlocked(); /* 快速查找，如果找到则直接返回imp 目的：防止多线程操作时，刚好调用函数，此时缓存进来了 */ if (fastpath(behavior &amp; LOOKUP_CACHE)) &#123; imp = cache_getImp(cls, sel); if (imp) goto done_nolock; &#125; // 加锁，目的是保证读取的线程安全 runtimeLock.lock(); // 判断是否是一个已知的类：判断当前类是否已经被认可的类，即已经加载的类 checkIsKnownClass(cls); // 判断类是否实现，如果没有，需要先实现，此时的目的是为了确保父类链，方法后续的循环 if (slowpath(!cls-&gt;isRealized())) &#123; cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock); &#125; // 判断类是否初始化，如果没有，需要先初始化 if (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123; cls = initializeAndLeaveLocked(cls, inst, runtimeLock); &#125; runtimeLock.assertLocked(); curClass = cls; /* 查找类的缓存 unreasonableClassCount 表示类的迭代上限 猜测这里递归的原因是attempts在第一次循环时做了减一操作，然后再次循环时 仍在上限范围内，所以可以继续递归 */ for (unsigned attempts = unreasonableClassCount();;) &#123; // 当前类方法列表（采用二分查找算法），如果找到，则返回，将方法缓存到cache中 Method meth = getMethodNoSuper_nolock(curClass, sel); if (meth) &#123; imp = meth-&gt;imp; goto done; &#125; // 当前类 = 当前类的父类，并判断父类是否为nil if (slowpath((curClass = curClass-&gt;superclass) == nil)) &#123; // 未找到方法实现，方法解析器也不行，使用转发 imp = forward_imp; break; &#125; // 如果父类链中存在循环，则停止 if (slowpath(--attempts == 0)) &#123; _objc_fatal(&quot;Memory corruption in class list.&quot;); &#125; // 父类缓存 imp = cache_getImp(curClass, sel); if (slowpath(imp == forward_imp)) &#123; // 如果在父类中找到了forward，则停止查找，且不缓存，首先调用此类的方法解析器 break; &#125; if (fastpath(imp)) &#123; // 如果在父类中，找到了此方法，将其存储到cache中 goto done; &#125; &#125; // 如果没找到方法，尝试一次方法解析 if (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123; // 动态方法决议的控制条件，便是流程只走一次 behavior ^= LOOKUP_RESOLVER; return resolveMethod_locked(inst, sel, cls, behavior); &#125; done: // 存储到缓存 log_and_fill_cache(cls, imp, sel, inst, curClass); // 解锁 runtimeLock.unlock(); done_nolock: if (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123; return nil; &#125; return imp;&#125; 其整体的慢速查找流程如下图： 主要有以下几步： 【第一步】cache 缓存中进行查找，即 快速查找，找到则直接返回 imp，反之，则进入【第二步】 【第二步】判断 cls 是否是 已知类，如果不是，则 报错 类是否 实现，如果没有，则需要先实现，确定其父类链，此时实例化的目的是为了确定父类链、ro、以及rw等，方法后续数据的读取以及查找的循环 是否 初始化，如果没有，则初始化 【第三步】for 循环，按照 类继承链或者元类继承链 的顺序查找 当前的 cls 的方法列表中使用 二分查找算法 查找方法，如果找到，则 进入cache写入流程（在OC底层原理13：cache_t底层原理分析 文章中已经详述过），并 返回imp，如果 没有找到，则返回 nil 当前cls 被赋值为 父类，如果父类 等于nil，则 imp = 消息转发，并终止递归，进入【第四步】 如果 父类链 中存在循环，则报错，终止循环 父类缓存 中查找方法 如果 未找到，则直接返回 nil，继续 循环查找 如果 找到，则直接 返回imp，执行 cache写入流程 【第四步】判断 是否执行过 动态方法解析 如果 没有，执行 动态方法解析 如果 执行过 一次动态方法解析，则走到 消息转发流程 以上就是方法的 慢速查找流程，下面在分别详细解释 二分查找原理，以及 父类缓存查找 详细步骤 getMethodNoSuper_nolock 方法：二分查找方法流程查找方法列表流程： 其 二分查找 核心的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839ALWAYS_INLINE static method_t *findMethodInSortedMethodList(SEL key, const method_list_t *list)&#123; ASSERT(list); const method_t * const first = &amp;list-&gt;first; const method_t *base = first; const method_t *probe; uintptr_t keyValue = (uintptr_t)key; // key 等于 say666 uint32_t count; // base相当于low，count是max了，probe是middle，这就是二分 for (count = list-&gt;count; count != 0; count &gt;&gt;= 1) &#123; // 从首地址+下标 -&gt; 移动到中间位置（count &gt;&gt; 1 右移1位 count/2 = 4） probe = base + (count &gt;&gt; 1); uintptr_t probeValue = (uintptr_t)probe-&gt;name; // 如果查找的key是keyVal 等于中间位置（probe）的probeValue，则直接返回中间位置 if (keyValue == probeValue) &#123; // while 平移 排除分类重名方法 while (probe &gt; first &amp;&amp; keyValue == (uintptr_t)probe[-1].name) &#123; /* 排除分类重名方法（方法的存储是先存储方法，再存储分类，按照先进后出的原则，分类方法最先出， 而我们要取的类方法，所以需要先排除分类方法 如果是两个分类，就看谁先进行加载） */ probe--; &#125; return (method_t *)probe; &#125; // 如果keyValue 大于 probeValue，就往probe即中间位置的右边查找 if (keyValue &gt; probeValue) &#123; base = probe + 1; count--; &#125; &#125; return nil;&#125; 算法原理 简述：从第一次查找开始，每次都取 中间位置，与想查找的 key的value的值 作比较，如果 相等，则需要 排除分类方法，然后将查询到的位置的方法实现返回，如果 不相等，则需要 继续二分查找，如果循环至 count=0 还是 没有找到，则直接返回 nil，如下图所示： 以查找 ZJPerson 类的 sayNB实例方法 为例，其二分查找过程如下： cache_getImp方法：父类缓存查找cache_getImp 方法是通过 汇编_cache_getImp实现，传入 $0 是 GETIMP，如下所示： 如果 父类缓存 中找到了方法实现，则跳转至 CacheHit 即命中，则直接 返回imp 如果在 父类缓存 中，没有找到 方法实现，则跳转至 CheckMiss 或者 JumpMiss，通过判断 $0 跳转至 LGetImpMiss，直接返回 nil 总结 对于 对象方法（即实例方法），即在 类中查找，其慢速查找的 父类链 是：类 -&gt; 父类 -&gt; 根类 -&gt; nil 对于 类方法，即在 元类中查找，其慢速查找的 父类链 是：元类 -&gt; 根元类 -&gt; 根类 -&gt; nil 如果 快速查找、慢速查找 也 没有找到 方法实现，则尝试 动态方法决议 如果 动态方法决议 仍然没有找到，则进行 消息转发 常见方法未实现报错源码如果在 快速查找、慢速查找、方法解析流程中，均没有找到方法实现，则使用消息转发，其流程如下： 消息转发的实现 其中 _objc_msgForward_impcache 是汇编实现，会跳转至 __objc_msgForward，其核心是 __objc_forward_handler 123456789101112131415STATIC_ENTRY __objc_msgForward_impcache// No stret specialization.b __objc_msgForwardEND_ENTRY __objc_msgForward_impcache ENTRY __objc_msgForwardadrp x17, __objc_forward_handler@PAGEldr p17, [x17, __objc_forward_handler@PAGEOFF]TailCallFunctionPointer x17 END_ENTRY __objc_msgForward 汇编实现中查找 __objc_forward_handler ，并没有找到，在源码中去掉一个下划线进行全局搜索 _objc_forward_handler ,有如下实现，本质是调用的 objc_defaultForwardHandler 方法 12345678910// Default forward handler halts the process.__attribute__((noreturn, cold)) voidobjc_defaultForwardHandler(id self, SEL sel)&#123; _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot; &quot;(no message forward handler is installed)&quot;, class_isMetaClass(object_getClass(self)) ? &#x27;+&#x27; : &#x27;-&#x27;, object_getClassName(self), sel_getName(sel), self);&#125;void *_objc_forward_handler = (void*)objc_defaultForwardHandler; 看着 objc_defaultForwardHandler 有没有很眼熟，这就是我们日常开发中最常见的错误：没有实现函数，运行程序，崩溃时的报错提示","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理13：cache_t底层原理分析","slug":"OC进阶/OC底层原理13：cache-t底层原理分析","date":"2020-09-30T10:28:30.000Z","updated":"2022-04-22T09:23:19.000Z","comments":true,"path":"2020/09/30/OC进阶/OC底层原理13：cache-t底层原理分析/","link":"","permalink":"https://www.bboyzj.cn/2020/09/30/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8613%EF%BC%9Acache-t%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"前言我们在前面的 OC底层原理10：类 &amp; 类结构分析 中得知 类 都是以 objc_class 模板创建的，而 objc_class 中包含许多属性，如 Class ISA、Class superclass、cache_t cache、class_data_bits_t bits，并分析了 ISA、superclass、bits，本文主要分析 cache_t 中的 cache 属性。 cache_t 结构分析 通过 objc4-781源码 ，查看 cache_t 的源码结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940// cache 存的是什么？ 怎么存的？// cache 用来缓存struct cache_t &#123;#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED // MacOS 或 模拟器 -- 主要作为架构的区分 // explicit_atomic 显示原子性，目的是为了能够 增删改查时 保证线程的安全性 // 等价于 struct bucket_t * _buckets; // _buckets 中放的是 sel imp // _buckets的读取 有提供相应名称的方法 buckets() explicit_atomic&lt;struct bucket_t *&gt; _buckets; // _mask 掩码，即面具 -- 类似于isa的掩码，即位域 explicit_atomic&lt;mask_t&gt; _mask; #elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16 // 真机 &amp; 64位 // _maskAndBuckets 把原来的两个结构 _buckets 和 _mask 写成一个了，作用 为了优化 explicit_atomic&lt;uintptr_t&gt; _maskAndBuckets; // 苹果没有写完 mask_t _mask_unused; // 静态的省略... #elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4 // 真机 不是64位的 explicit_atomic&lt;uintptr_t&gt; _maskAndBuckets; mask_t _mask_unused; // 静态的省略... #else#error Unknown cache mask storage type.#endif #if __LP64__ // 位置标记 uint16_t _flags;#endif // 占位 uint16_t _occupied; //其他方法省略..... 分析 cache_t 的结构： 首先我们需要了解一下苹果设备的不同的 架构，如下： MacOS 架构：i386 真机 架构：arm64 模拟器 架构：x86 通过上面的 cache_t 源码可知，分为 3 个架构处理： CACHE_MASK_STORAGE_OUTLINED：表示运行的环境是 MacOS 或者 模拟器 CACHE_MASK_STORAGE_HIGH_16：表示运行的环境是 64位 的 真机 CACHE_MASK_STORAGE_LOW_4：表示运行的环境是 非64位 的 真机 我们可以点进 CACHE_MASK_STORAGE 中查看具体的定义： 123456789101112#define CACHE_MASK_STORAGE_OUTLINED 1 #define CACHE_MASK_STORAGE_HIGH_16 2#define CACHE_MASK_STORAGE_LOW_4 3#if defined(__arm64__) &amp;&amp; __LP64__ // 真机 &amp; 64位#define CACHE_MASK_STORAGE CACHE_MASK_STORAGE_HIGH_16#elif defined(__arm64__) &amp;&amp; !__LP64__ // 真机 &amp; 非64位#define CACHE_MASK_STORAGE CACHE_MASK_STORAGE_LOW_4#else // MacOS 或 模拟器#define CACHE_MASK_STORAGE CACHE_MASK_STORAGE_OUTLINED#endif explicit_atomic：表示 显示原子性，目的是为了能够保证 增删改查时 线程的安全性 _buckets：是一个 struct bucket_t 的结构体，其内部源码如下： 1234567891011struct bucket_t &#123;private: // IMP-first is better for arm64e ptrauth and no worse for arm64. // SEL-first is better for armv7* and i386 and x86_64.#if __arm64__ // 真机 64位 explicit_atomic&lt;uintptr_t&gt; _imp; explicit_atomic&lt;SEL&gt; _sel;#else // 非真机 explicit_atomic&lt;SEL&gt; _sel; explicit_atomic&lt;uintptr_t&gt; _imp;#endif 由 bucket_t 源码可知，其内部保存的是 SEL 和 IMP _mask：是 masK_t 结构，掩码，即面具，类似于 isa中的掩码即 位域 真机 环境： uint32_t 类型的 其他 环境：uint16_t 类型的 masK_t 的内部结构如下： 12345#if __LP64__typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits#elsetypedef uint16_t mask_t;#endif _maskAndBuckets： 真机 环境把原来的两个结构 _buckets 和 _mask 写成一个了，作用是 为了优化 【总结】 通过上面几个结构体分析，我们可以得出一个如下的结构图： 【补充知识】sel &amp; imp 的关系我们知道，每一个方法都有一个 sel 和 imp，sel 就是 方法编号，imp 就是 函数指针(方法实现)，我们在查找方法的时候是一个非常漫长的过程，oc 的 函数实现 是通过 下层c/c++ 来实现的，oc上层 的 sel 和 imp 起始是 对下层 的 封装 【方法的组成】: SEL：方法编号 IMP：函数指针地址 【用通俗易懂的方式解释】： SEL：相当于书本目录的名称IMP：相当于书本目录的页码 首先明白我们要找到书本的什么内容（sel目录里面的名称） 通过名称找到对应的书本页码（imp） 通过页码去定位具体的内容 下面用一张图表示： cache中查找sel-impcache_t 中查找存储的 sel-imp，有以下两种方式 通过源码查找 脱离源码在项目中查找 【准备工作】 自定义一个 ZJPerson 类，并定义 2个属性 和 5个实例方法 及其 实现 ZJPerson.h 中 123456789101112131415@interface ZJPerson : NSObject@property (nonatomic, copy) NSString *zjName;@property (nonatomic, strong) NSString *nickName;- (void)sayHello;- (void)sayCode;- (void)sayMaster;- (void)sayNB;+ (void)sayHappy;@end ZJPerson.m 中 123456789101112131415161718192021@implementation ZJPerson- (void)sayHello&#123; NSLog(@&quot;ZJPerson say : %s&quot;,__func__);&#125;- (void)sayCode&#123; NSLog(@&quot;ZJPerson say : %s&quot;,__func__);&#125;- (void)sayMaster&#123; NSLog(@&quot;ZJPerson say : %s&quot;,__func__);&#125;- (void)sayNB&#123; NSLog(@&quot;ZJPerson say : %s&quot;,__func__);&#125;+ (void)sayHappy&#123; NSLog(@&quot;ZJPerson say : %s&quot;,__func__);&#125;@end 在 main.m 中定义 ZJPerson 类的 对象p，并调用其中的 3个实例方法，在第一个方法处加两个 断点 【通过源码查找】 运行执行，断在 [p sayHello]; 部分，此时执行以下lldb调试流程： 由上面的调式流程可知： cache属性 的获取，需要通过 pClass 的 首地址平移16字节，即 首地址 + 0x10 获取 cache的地址 _buckets属性 的获取，在 cache_t 结构体中提供了获取 _buckets 属性的方法 buckets()，在 _buckets 属性中（目前处于macOS环境）缓存着 sel-imp sel 和 imp 的获取，在 _buckets 中提供了 sel() 和 imp(pClass) 方法获取 sel 和 imp 由上图可知，在没有执行方法调用之前，此时 cache 是没有缓存的，执行调用了一次之后，cache 中就 缓存 了 一次，即调用一次方法就会缓存一次。 我们在前面了解了如何获取 cache 中 sel-imp，那么如何验证打印的sel-imp 就是我们调用的呢？可以通过 machoView 打开 target 的可执行文件，在方法列表中查看其 imp 的值 是否是一致 的，如下所示，发现是一致的，所以打印的这个 sel-imp 就是 ZJPerson 的实例方法： 【machoView图】： 【imp截图：】 接着上面的 LLDB 调试步骤，我们再调一个方法，其 LLDB 调试如下图： 第一个调用方法的存储获取很简单，直接通过 _buckets 的 首地址 调用对应的方法即可，那么获取第二个呢？在之前的 OC底层原理10：类 &amp; 类结构分析 文章中，曾提及过一个概念 指针偏移，所以我们这里可以通过 _buckets 属性的 首地址偏移，即 p *($9+1) 即可获取第二个方法的 sel 和 imp 如果有多个方法需要获取，以此类推，例如 p *($9+i) 【脱离源码通过项目查找】 脱离源码环境，就是将所需的 源码 的部分 拷贝至项目 中，其完整代码如下： 【ZJPerson类】 1234567891011121314151617181920212223242526272829303132333435363738394041//*********.h********@interface ZJPerson : NSObject@property (nonatomic, copy) NSString *zjName;@property (nonatomic, strong) NSString *nickName;- (void)say1;- (void)say2;- (void)say3;- (void)say4;- (void)say5;- (void)say6;- (void)say7;+ (void)sayHappy;@end//*********.m********@implementation ZJPerson- (void)say1&#123; NSLog(@&quot;ZJPerson say : %s&quot;,__func__);&#125;- (void)say2&#123; NSLog(@&quot;ZJPerson say : %s&quot;,__func__);&#125;- (void)say3&#123; NSLog(@&quot;ZJPerson say : %s&quot;,__func__);&#125;- (void)say4&#123; NSLog(@&quot;ZJPerson say : %s&quot;,__func__);&#125;- (void)say5&#123; NSLog(@&quot;ZJPerson say : %s&quot;,__func__);&#125;- (void)say6&#123; NSLog(@&quot;ZJPerson say : %s&quot;,__func__);&#125;- (void)say7&#123; NSLog(@&quot;ZJPerson say : %s&quot;,__func__);&#125;+ (void)sayHappy&#123; NSLog(@&quot;ZJPerson say : %s&quot;,__func__);&#125;@end 【main中代码】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#import &lt;Foundation/Foundation.h&gt;#import &quot;ZJPerson.h&quot;#import &lt;objc/runtime.h&gt;typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bitsstruct zj_bucket_t &#123; SEL _sel; IMP _imp;&#125;;struct zj_cache_t &#123; struct zj_bucket_t * _buckets; mask_t _mask; uint16_t _flags; uint16_t _occupied;&#125;;struct zj_class_data_bits_t &#123; uintptr_t bits;&#125;;struct zj_objc_class &#123; Class ISA; Class superclass; struct zj_cache_t cache; // formerly cache pointer and vtable struct zj_class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags&#125;;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; ZJPerson *p = [ZJPerson alloc]; Class pClass = [ZJPerson class]; // objc_clas [p say1]; [p say2]; [p say3]; [p say4]; // _occupied _mask 是什么 cup - 1 // 会变化 2-3 -&gt; 2-7 // bucket 会有丢失 重新申请 // 顺序有点问题 哈希 // cache_t 底层原理 // 线索 : struct zj_objc_class *zj_pClass = (__bridge struct zj_objc_class *)(pClass); NSLog(@&quot;%hu - %u&quot;,zj_pClass-&gt;cache._occupied,zj_pClass-&gt;cache._mask); for (mask_t i = 0; i&lt;zj_pClass-&gt;cache._mask; i++) &#123; // 打印获取的 bucket struct zj_bucket_t bucket = zj_pClass-&gt;cache._buckets[i]; NSLog(@&quot;%@ - %p&quot;,NSStringFromSelector(bucket._sel),bucket._imp); &#125; NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125; 这里有个问题需要注意，在源码中，objc_class 的 ISA 属性时继承自 objc_object 的，但在我们将其拷贝过来时，去掉了 objc_class 的继承关系，需要将这个属性明确，否则打印的结果是有问题的，如下图所示： 加上 ISA 属性后，其正确的打印结果如下： 针对上面的打印结果，有以下几个疑问？ _mask 是什么？ _occupied 是什么？ 为什么随着方法调用的增多，其打印的 occupied 和 mask 会变化？ bucket 数据为什么会有 丢失的情况？例如 2-7中，只有say3、say4方法有函数指针？ 2-7中say3、say4的打印顺序为什么是say4先打印，say3后打印，且还不是挨着的，即 顺序有问题？ 打印的 cache_t 中的 _occupied 为什么是从 2 开始？ 带着上述的这些疑问，下面来进行 cache 底层原理的探索 cache_t 底层原理分析 首先，从 cache_t 中的 _mask 属性开始分析，找 cache_t 中引起变化的函数，发现了 incrementOccupied() 函数 该函数的具体实现为 1234567void incrementOccupied(); //Occupied自增//👇具体实现void cache_t::incrementOccupied() &#123; _occupied++;&#125; 源码中，全局搜索 incrementOccupied() 函数，发现只在 cache_t 的 insert 方法有调用 insert 方法，理解为 cache_t 的插入，而 cache 中存储的就是 sel-imp，所以 cache 的原理从 insert 方法开始分析，以下是 cache 原理分析的流程图 全局搜索 insert( 方法，发现只有 cache_fill 方法中的调用符合 全局搜索 cache_fill，发现在写入之前，还有一步操作，即 cache 读取，即查找 sel-imp，如下所示 但本文的重点还是分析 cache 存储的原理，接下来根据 cache_t 写入的流程图，着重分析 insert 方法 insert 方法分析在 insert 方法中，其源码实现如下 主要分为以下几部分： 【第一步】计算 出当前的 缓存占用量 【第二步】根基 缓存占用量判断 执行的 操作 【第三步】针对需要存储的 bucket 进行内部 imp和set赋值 1、【第一步】计算出当前的缓存占用量 根据 occupied 的值计算出当前的缓存占用量，当 属性未赋值及无法调用时，此时的 occupied()为0 ，而 newOccupied为1 ，如下所示 1mask_t newOccupied = occupied() + 1; 关于缓存占用量的计算，有以下几点说明： alloc 申请空间时，此时的 对象已经创建，如果再调用 init 方法，occupied也会+1 当 有属性赋值 时，会隐式调用 set 方法，occupied 也会增加，即 有几个属性赋值，occupied就会在原有的基础上加几个 当 有方法调用 时，occupied 也会增加，即 有几次调用，occupied就会在原有的基础上加几个 2、【第二步】根据缓存占用量判断执行的操作 如果是 第一次创建，则默认开辟4个 123456if (slowpath(isConstantEmptyCache())) &#123; //小概率发生的 即当 occupied() = 0时，即创建缓存，创建属于小概率事件 // Cache is read-only. Replace it. if (!capacity) capacity = INIT_CACHE_SIZE; //初始化时，capacity = 4（1&lt;&lt;2 -- 100） reallocate(oldCapacity, capacity, /* freeOld */false); //开辟空间 //到目前为止，if的流程的操作都是初始化创建&#125; 如果缓存占用量 小于等于3/4，则不作任何处理 123else if (fastpath(newOccupied + CACHE_END_MARKER &lt;= capacity / 4 * 3)) &#123; // Cache is less than 3/4 full. Use it as-is.&#125; 如果缓存占用量 超过3/4，则需要进行 两倍扩容 以及 重新开辟空间 12345678910else &#123; //如果超出了3/4，则需要扩容（两倍扩容） // 扩容算法： 有cap时，扩容两倍，没有cap就初始化为4 capacity = capacity ? capacity * 2 : INIT_CACHE_SIZE; // 扩容两倍 2*4 = 8 if (capacity &gt; MAX_CACHE_SIZE) &#123; capacity = MAX_CACHE_SIZE; &#125; // 走到这里表示 曾经有，但是已经满了，需要重新梳理 reallocate(oldCapacity, capacity, true); // 内存 扩容完毕&#125; 【realloc方法：开辟空间】 该方法，在 第一次创建 以及 两倍扩容 时，都会使用，其源码实现如图所示 主要有以下几步： allocateBuckets 方法：向系统 申请开辟内存，即开辟 bucket，此时的bucket只是一个临时变量 setBucketsAndMask 方法：将 临时 的 bucket 存入缓存中，此时的存储分为两种情况： 如果是 真机，根据 bucket和mask的位置存储，并将 occupied 占用设置为 0 如果 不是真机，正常存储bucket和mask，并将 occupied 占用设置为 0 如果有旧的buckets，需要清理之前的缓存，即调用 cache_collect_free 方法，其源码实现如下 该方法的实现主要有以下几步： _garbage_make_room 方法：创建垃圾回收空间 如果是 第一次，需要 分配回收空间 如果 不是第一次，则将内存段加大，即 原有内存*2 记录 存储 这次的 bucket cache_collect 方法：垃圾回收，清理旧的bucket 【第三步】针对需要存贮的bucket进行内部imp和sel赋值 这部分主要是根据 cache_hash 方法，即 哈希算法 ，计算 sel-imp 存储的 哈希下标，分为以下三种情况： 如果哈希下标的位置 未存储sel，即该下标位置 获取sel等于0，此时将 sel-imp存储 进去，并将 occupied 占用大小 加1 如果当前哈希下标存储的sel 等于 即将插入的sel，则直接返回 如果当前哈希下标存储的sel 不等于 即将插入的sel，则重新经过 cache_next方法 即哈希冲突算法，重新进行哈希计算，得到新的下标，再去对比进行存储 其中涉及的两种哈希算法，其源码如下： cache_hash：哈希算法 1234static inline mask_t cache_hash(SEL sel, mask_t mask) &#123; return (mask_t)(uintptr_t)sel &amp; mask; // 通过sel &amp; mask（mask = cap -1）&#125; cache_next：哈希冲突算法 123456789101112131415#if __arm__ || __x86_64__ || __i386__// objc_msgSend has few registers available.// Cache scan increments and wraps at special end-marking bucket.#define CACHE_END_MARKER 1static inline mask_t cache_next(mask_t i, mask_t mask) &#123; return (i+1) &amp; mask; //（将当前的哈希下标 +1） &amp; mask，重新进行哈希计算，得到一个新的下标&#125;#elif __arm64__// objc_msgSend has lots of registers available.// Cache scan decrements. No end marker needed.#define CACHE_END_MARKER 0static inline mask_t cache_next(mask_t i, mask_t mask) &#123; return i ? i-1 : mask; //如果i是空，则为mask，mask = cap -1，如果不为空，则 i-1，向前插入sel-imp&#125; 到此，cache_t的原理基本分析完成了，然后前文提及的几个问题，我们现在就有答案了 疑问解答1、_mask 是什么？ _mask 是指 掩码数据，用于在 哈希算法或者哈希冲突算法 中 计算哈希下标，其中mask 等于 capacity - 1 2、_occupied 是什么？ _occupied 表示哈希表中 sel-imp 的占用大小 (即可以理解为分配的内存中已经存储了sel-imp的的个数) init 会导致occupied变化 属性赋值，也会隐式调用，导致occupied变化 方法调用，导致occupied变化 3、为什么随着方法调用的增多，其打印的 occupied 和 mask 会变化？ 因为在 cache 初始化时，分配的空间是 4 个，随着方法调用的增多，当存储的 sel-imp个数，即 newOccupied + CACHE_END_MARKER（等于1）的和 超过 总容量的3/4,例如有 4 个时，当occupied等于2时，就需要对cache的内存进行两倍扩容 4、bucket 数据为什么会有 丢失的情况？例如 2-7中，只有say3、say4方法有函数指针？ 原因是在 扩容 时，是将 原有的内存全部清除 了，再 重新申请 了内存 导致 的 5、2-7中say3、say4的打印顺序为什么是say4先打印，say3后打印，且还不是挨着的，即 顺序有问题？ 因为sel-imp的存储是通过哈希算法计算下标的，其计算的下标有可能已经存储了sel，所以 又需要通过哈希冲突算法重新计算哈希下标，所以导致 下标是随机的，并不是固定的 6、打印的 cache_t 中的 _occupied 为什么是从 2 开始？ 这里是因为 ZJPerson 通过alloc创建的对象，并 对其两个属性赋值的原因，属性赋值，会隐式调用set方法，set方法 的调用也会导致 occupied变化","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理12：copy & strong & weak底层分析","slug":"OC进阶/OC底层原理12：copy-strong-weak底层分析","date":"2020-09-28T13:58:37.000Z","updated":"2022-04-22T07:34:45.000Z","comments":true,"path":"2020/09/28/OC进阶/OC底层原理12：copy-strong-weak底层分析/","link":"","permalink":"https://www.bboyzj.cn/2020/09/28/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8612%EF%BC%9Acopy-strong-weak%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/","excerpt":"","text":"前言属性 通过 clang 编译的 cpp 文件中可以发现 copy &amp; strong &amp; weak 修饰， 在编译的底层代码中是有区别的 【补充知识】：Type Encoding &amp; Property Type String【Type encoding】：编码类型 获取 Type encoding 有两种方式： 【方式一】：通过 代码 获取 在 main.m 中添加添加函数方法： ZJLog：打印结果描述 12345#ifdef DEBUG#define ZJLog(format, ...) printf(&quot;%s\\n&quot;, [[NSString stringWithFormat:format, ## __VA_ARGS__] UTF8String]);#else#define ZJLog(format, ...);#endif zjTypes 函数：打印各种类型编码函数 123456789101112131415161718192021222324252627282930313233343536#pragma mark - 各种类型编码void zjTypes()&#123; NSLog(@&quot;char --&gt; %s&quot;,@encode(char)); NSLog(@&quot;int --&gt; %s&quot;,@encode(int)); NSLog(@&quot;short --&gt; %s&quot;,@encode(short)); NSLog(@&quot;long --&gt; %s&quot;,@encode(long)); NSLog(@&quot;long long --&gt; %s&quot;,@encode(long long)); NSLog(@&quot;unsigned char --&gt; %s&quot;,@encode(unsigned char)); NSLog(@&quot;unsigned int --&gt; %s&quot;,@encode(unsigned int)); NSLog(@&quot;unsigned short --&gt; %s&quot;,@encode(unsigned short)); NSLog(@&quot;unsigned long --&gt; %s&quot;,@encode(unsigned long long)); NSLog(@&quot;float --&gt; %s&quot;,@encode(float)); NSLog(@&quot;bool --&gt; %s&quot;,@encode(bool)); NSLog(@&quot;void --&gt; %s&quot;,@encode(void)); NSLog(@&quot;char * --&gt; %s&quot;,@encode(char *)); NSLog(@&quot;id --&gt; %s&quot;,@encode(id)); NSLog(@&quot;Class --&gt; %s&quot;,@encode(Class)); NSLog(@&quot;SEL --&gt; %s&quot;,@encode(SEL)); int array[] = &#123;1,2,3&#125;; NSLog(@&quot;int[] --&gt; %s&quot;,@encode(typeof(array))); typedef struct person&#123; char *name; int age; &#125;Person; NSLog(@&quot;struct --&gt; %s&quot;,@encode(Person)); typedef union union_type&#123; char *name; int a; &#125;Union; NSLog(@&quot;union --&gt; %s&quot;,@encode(Union)); int a = 2; int *b = &#123;&amp;a&#125;; NSLog(@&quot;int[] --&gt; %s&quot;,@encode(typeof(b)));&#125; 我们在 main.m 函数中调用上面的函数 1234567int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; zjTypes(); NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125; 查看输出的打印结果： 12345678910111213141516171819202020-10-17 14:45:23.857263+0800 001-类的属性与变量[24305:733568] char --&gt; c2020-10-17 14:45:23.857725+0800 001-类的属性与变量[24305:733568] int --&gt; i2020-10-17 14:45:23.857763+0800 001-类的属性与变量[24305:733568] short --&gt; s2020-10-17 14:45:23.857818+0800 001-类的属性与变量[24305:733568] long --&gt; q2020-10-17 14:45:23.857887+0800 001-类的属性与变量[24305:733568] long long --&gt; q2020-10-17 14:45:23.857936+0800 001-类的属性与变量[24305:733568] unsigned char --&gt; C2020-10-17 14:45:23.857965+0800 001-类的属性与变量[24305:733568] unsigned int --&gt; I2020-10-17 14:45:23.857989+0800 001-类的属性与变量[24305:733568] unsigned short --&gt; S2020-10-17 14:45:23.858012+0800 001-类的属性与变量[24305:733568] unsigned long --&gt; Q2020-10-17 14:45:23.858065+0800 001-类的属性与变量[24305:733568] float --&gt; f2020-10-17 14:45:23.858105+0800 001-类的属性与变量[24305:733568] bool --&gt; B2020-10-17 14:45:23.858143+0800 001-类的属性与变量[24305:733568] void --&gt; v2020-10-17 14:45:23.858172+0800 001-类的属性与变量[24305:733568] char * --&gt; *2020-10-17 14:45:23.858196+0800 001-类的属性与变量[24305:733568] id --&gt; @2020-10-17 14:45:23.858222+0800 001-类的属性与变量[24305:733568] Class --&gt; #2020-10-17 14:45:23.862415+0800 001-类的属性与变量[24305:733568] SEL --&gt; :2020-10-17 14:45:23.862459+0800 001-类的属性与变量[24305:733568] int[] --&gt; [3i]2020-10-17 14:45:23.862516+0800 001-类的属性与变量[24305:733568] struct --&gt; &#123;person=*i&#125;2020-10-17 14:45:23.862591+0800 001-类的属性与变量[24305:733568] union --&gt; (union_type=*i)2020-10-17 14:45:23.862647+0800 001-类的属性与变量[24305:733568] int[] --&gt; ^i 【方式二】：查看官方文档 Type Encoding-官方文档 【结论】： 由上面的结果我们可知： 每一个 变量类型 都对应一个 编码类型，如 char -&gt; c 等等。 【Property Type String】：属性类型编码 属性类型编码可以通过下面的官方文档学习： Property Type String-官方文档 我们前面学习了，属性 通过 clang 编译 cpp 后，会生成对应的 成员变量、方法列表 、属性列表，如下: 【方法列表】： 【属性列表】： 【成员变量列表】： 方法列表中@16@0:8 到底是什么意思？ 以 @16@0:8 为例: 第一个参数@：返回值 第二个参数16：共用16字节 第三个参数@：第一个参数 第四个参数0：从0开始（0~8） 第五个参数 ：号：sel 从 8 号位置开始 第六个参数8：从8开始（8~16） 属性列表中 &quot;name&quot;,&quot;T@\\&quot;NSString\\&quot;,&amp;,N,V_name&quot; 是什么意思？ 以 &quot;name&quot;,&quot;T@\\&quot;NSString\\&quot;,&amp;,N,V_name&quot; 为例： T 表示 type @ 表示 变量类型 C 表示 copy N 表示 nonatomic V 表示 variable 变量，即下划线变量 _nickName copy &amp; strong &amp; weak 底层分析 在 ZJPerson 中声明两个属性 nickName 和 name ,分别用 copy 和 strong 修饰 1234@interface ZJPerson : NSObject@property (nonatomic, copy) NSString *nickName;@property (nonatomic, strong) NSString *name;@end 通过 clang 将 main.m 文件编译成 main.cpp,然后发现 copy 和 strong 修饰的属性的 set方法 是有区别的，如下图： 这里就有了疑问，为什么 copy 修饰的 nickName属性 使用了 objc_setProperty ，而 strong 的没有？ 想要分析 copy 和 strong 在底层是如何实现的，需要分析 LLVM源码 下载好 LLVM源码 后，在 LLVM 中搜索 objc_setProperty ，找到如下所示的 getOptimizedSetPropertyFn 方法中： 由上图可以看出: 如果是 atomic &amp; copy 修饰，name 为 objc_setProperty_atomic_copy 如果是 atomic &amp; !copy 修饰，name 为 objc_setProperty_atomic 如果是 nonatomic &amp; copy 修饰，name 为 objc_setProperty_nonatomic_copy 其他剩余的组合，即 nonatomic、nonatomic &amp; strong、nonatomic &amp; weak 等，name 为 objc_setProperty_nonatomic 我们可以通过 汇编调试 查看最终到底会执行哪个命令： 我们发现 不管是 copy修饰 还是 strong修饰 还是 weak修饰 的属性，最终都会执行 objc_storeStrong objc4源码 中搜索 objc_storeStrong，如下： 1234567891011voidobjc_storeStrong(id *location, id obj)&#123; id prev = *location; if (obj == prev) &#123; return; &#125; objc_retain(obj); // retain新值 *location = obj; objc_release(prev); // release旧值&#125; 主要也是 retain新值，release旧值 回到 LLVM 源码中搜索 objc_storeStrong，我们发现其底层调用的是 EmitARCStoreStrongCall ，如下图： LLVM 中搜索 EmitARCStoreStrongCall 方法，在GenerateCopyHelperFunction 方法有调用，然后在这里发现了 strong 和 weak 的不同处理","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC三方框架03：FDFullscreenPopGesture探索","slug":"OC三方框架/OC三方框架03：FDFullscreenPopGesture探索","date":"2020-09-28T06:18:18.000Z","updated":"2020-10-17T05:09:37.000Z","comments":true,"path":"2020/09/28/OC三方框架/OC三方框架03：FDFullscreenPopGesture探索/","link":"","permalink":"https://www.bboyzj.cn/2020/09/28/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B603%EF%BC%9AFDFullscreenPopGesture%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"前言1.什么是侧滑？侧滑本身是系统自带的，但是是左边缘触发的侧滑； 2.是什么导致了自带的实现不起作用的？原因有:（1）隐藏了系统右上角返回的按钮，系统会自动关掉左滑返回的功能；（2）禁用侧滑功能；（3）自定义返回键或者导航栏后，侧滑失灵； 3.怎么解决？ 使用 FDFullscreenPopGesture 可以解决一个支持全屏侧滑的 UINavigationController的类目。 FDFullscreenPopGesture的这个类目：UINavigation+FDFullscreenPopGesture，扩展了iOS7+的侧滑返回功能。取代从左边缘滑起的是，我们可以从屏幕的任意位置滑动，并且伴随着返回上个界面的过渡动画也可以正常流畅。 主要功能1.自动支持全屏侧滑2.禁用导航/控制器的侧滑功能 源码解读1.在 UINavigationController 的分类 UINavigationController + FDFullscreenPopGesture中，暴露给用户的属性有: 123456789@interface UINavigationController (FDFullscreenPopGesture)// 这个滑动手势，处理用户的侧滑弹出操作@property (nonatomic, strong, readonly) UIPanGestureRecognizer *fd_fullscreenPopGestureRecognizer;// 判断fd_viewControllerBasedNavigationBarAppearanceEnabled属性，视图控制器可以自己控制，而不是全局的方式控制，导航栏的外观。，默认是YES。@property (nonatomic, assign) BOOL fd_viewControllerBasedNavigationBarAppearanceEnabled;@end 2.在 UIViewController 的分类 UIViewController + FDFullscreenPopGesture中，允许视图控制器禁用用户弹出手势，比如某些情况下，视图控制器需要自己处理滑动手势。其中，暴露给用户的属性有 123456//当处于导航控制栈中时，是否禁用用户弹出手势；@property (nonatomic, assign) BOOL fd_interactivePopDisabled;//通过检查基于导航栏的视图控制器是否可用，来指明视图控制器的导航栏隐藏与否。默认是NO，一般导航栏是展示的。@property (nonatomic, assign) BOOL fd_prefersNavigationBarHidden; 基本使用具体集成过程就不再讲解，如果有不知道的，看我iOS-OC三方库01：SDCycleScrollView基本使用集成过程，下面来看看具体使用： 1.把这个框架的.h文件添加到全局的宏中，所有的导航控制器都将自动会支持全屏侧滑。 12// FDFullscreenPopGesture(全屏侧滑)#import &lt;UINavigationController+FDFullscreenPopGesture.h&gt; 2.禁用手势 禁用导航控制器的侧滑功能: 1self.navigationController.fd_fullscreenPopGestureRecognizer.enabled = NO; 禁用当前viewcontroller的侧滑功能： 1self = YES;","categories":[{"name":"OC-三方框架探索篇","slug":"OC-三方框架探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-三方框架探索篇","slug":"OC-三方框架探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理11：类 & isa 底层面试题分析","slug":"OC进阶/OC底层原理11：类 & isa 底层面试题分析","date":"2020-09-26T15:37:09.000Z","updated":"2022-04-22T07:02:37.000Z","comments":true,"path":"2020/09/26/OC进阶/OC底层原理11：类 & isa 底层面试题分析/","link":"","permalink":"https://www.bboyzj.cn/2020/09/26/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8611%EF%BC%9A%E7%B1%BB%20&%20isa%20%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/","excerpt":"","text":"前言本文的面试题主要涉及 isa走位 &amp; 继承关系 &amp; 类结构 相关的面试题以及针对面试题的分析 【面试题】类存在几份？由于 类的信息 在内存中永远 只存在一份，所以 类对象只有一份 【百度面试题】objc_object 与 对象 的关系？ 所有的 对象 都是以 objc_object 为模板 继承 过来的 所有的 对象 都是 来自NSObject(来自于OC端)，但是真正到 底层 是一个 objc_object（C/C++） 结构体 类型的 【总结】：objc_object 与 对象 的关系是 继承 关系 【面试题】什么是 属性 &amp; 成员变量 &amp; 实例变量 ？ 属性(property)：在 OC 中是通过 @property 开头 定义，且是 带下划线成员变量 + setter + getter方法 的变量 成员变量(ivar)：在 OC 类的 &#123;&#125; 中定义的，且 没有下划线的变量 实例变量：通过当前对象类型，具备实例化的变量，是一种 特殊的成员变量，例如 NSObject、UILabel、UIButton 等 【面试题】元类 中为什么会有 类对象 的 类方法？在上一章 OC底层原理10：类 &amp; 类结构分析 中，我们知道了 实例方法存储在类中，类方法存储在元类中 为了探索我们的面试题现象，定义了以下几个方法，来探索方法的归属问题 在ZJPerson中定义一个实例方法和一个类方法，并实现 1234567891011121314@interface ZJPerson : NSObject- (void)sayHello;+ (void)sayHappy;@end@implementation ZJPerson- (void)sayHello&#123; NSLog(@&quot;ZJPerson say : Hello!!!&quot;);&#125;+ (void)sayHappy&#123; NSLog(@&quot;ZJPerson say : Happy!!!&quot;);&#125;@end 在 main 主函数，调用自定义的方法 12345678910111213141516int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; ZJPerson * p = [ZJPerson alloc]; Class pClass = object_getClass(p); // 获取类的方法 zjObjc_copyMethodList(pClass); // 获取类和元类的实例方法 zjInstanceMethod_classToMetaclass(pClass); // 获取类和元类的类方法 zjClassMethod_classToMetaclass(pClass); // 获取类和元类的方法实现 zjIMP_classToMetaclass(pClass); NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125; zjObjc_copyMethodList ：用于获取 类的方法列表 12345678910111213// 获取类的方法列表void zjObjc_copyMethodList(Class pClass)&#123; unsigned int count = 0; Method *methods = class_copyMethodList(pClass, &amp;count); for (unsigned int i=0; i &lt; count; i++) &#123; Method const method = methods[i]; //获取方法名 NSString *key = NSStringFromSelector(method_getName(method)); ZJLog(@&quot;Method, name: %@&quot;, key); &#125; free(methods);&#125; 查看一下打印结果: 1Method, name: sayHello 下面我们来分析一下打印结果: 【zjObjc_copyMethodList函数】 这个函数的主要作用是打印 类 中存在的 方法，由前面所知，实例方法 存储在 类中，因此打印结果只有 Method, name: sayHello zjInstanceMethod_classToMetaclass ：用于获取 类和元类 的 实例方法 12345678910111213void zjInstanceMethod_classToMetaclass(Class pClass)&#123; const char *className = class_getName(pClass); Class metaClass = objc_getMetaClass(className); Method method1 = class_getInstanceMethod(pClass, @selector(sayHello)); Method method2 = class_getInstanceMethod(metaClass, @selector(sayHello)); Method method3 = class_getInstanceMethod(pClass, @selector(sayHappy)); Method method4 = class_getInstanceMethod(metaClass, @selector(sayHappy)); ZJLog(@&quot;%s - %p-%p-%p-%p&quot;,__func__,method1,method2,method3,method4);&#125; 查看一下打印结果: 1zjInstanceMethod_classToMetaclass - 0x100003100-0x0-0x0-0x100003098 下面我们来分析一下打印结果: 【zjInstanceMethod_classToMetaclass函数】:用于获取 类和元类 的 类方法 在分析前先了解一下函数 class_getInstanceMethod :作用是获取实例方法，根据官方文档的解释: 其大致含义就是：如果在传入的类或者类的父类中没有找到指定的实例方法，则返回NULL 从上面的代码可知传入的 pClass 是 ZJPerson 类，metaClass 是 ZJPerson元类,函数中4个打印结果分别是： method1的地址：0x100003100 传入的 pClass 是 ZJPerson，查找的方法是sayHello实例方法，由于ZJPerson中有该方法，所以返回的地址是 0x100003100 method2的地址：0x0 传入的 metaClass 是 ZJPerson元类，查找的方法是sayHello实例方法，由于ZJPerson中没有该方法，所以返回的地址是 0x0 method3的地址：0x0 传入的 pClass 是 ZJPerson，查找的方法是sayHappy实例方法，由于ZJPerson中没有该方法，所以返回的地址是 0x0 method4的地址：0x100003098 传入的 metaClass 是 ZJPerson元类，查找的方法是sayHappy实例方法，由于类ZJPerson中类方法sayHappys是以 实例方法 存储在 元类中的，因此元类ZJPerson 中有该方法，所以返回的地址是 0x100003098 zjClassMethod_classToMetaclass函数：获取类或类的父类中的类方法 12345678910111213141516// 类和元类-类方法void zjClassMethod_classToMetaclass(Class pClass)&#123; const char *className = class_getName(pClass); Class metaClass = objc_getMetaClass(className); Method method1 = class_getClassMethod(pClass, @selector(sayHello)); Method method2 = class_getClassMethod(metaClass, @selector(sayHello)); Method method3 = class_getClassMethod(pClass, @selector(sayHappy)); // 元类 为什么有 sayHappy 类方法 0 1 // Method method4 = class_getClassMethod(metaClass, @selector(sayHappy)); ZJLog(@&quot;%s-%p-%p-%p-%p&quot;,__func__,method1,method2,method3,method4);&#125; 查看一下打印结果: 1zjClassMethod_classToMetaclass-0x0-0x0-0x100003098-0x100003098 下面我们来分析一下打印结果: class_getClassMethod：用于获取 类或类的父类 的 类方法，根据官方文档的解释: 其大致含义就是：如果在传入的类或者类的父类中没有找到指定的类方法，则返回NULL 从上面的代码可知传入的 pClass 是 ZJPerson 类，metaClass 是 ZJPerson元类,函数中4个打印结果分别是： method1 的地址：0x0 传入的 pClass 是 ZJPerson，查找的方法是sayHello类方法，由于ZJPerson中没有该方法，所以返回的地址是 0x0 method2 的地址：0x0 传入的 metaClass 是 ZJPerson元类，查找的方法是sayHello类方法，由于 ZJPerson元类中没有该方法，所以返回的地址是 0x0 method3 的地址：0x100003098 传入的 pClass 是 ZJPerson，查找的方法是 sayHappy类方法，由于ZJPerson中有该方法，所以返回的地址是 0x100003098 method4的地址：0x100003098 传入的 metaClass 是 ZJPerson元类，查找的方法是 sayHappy类方法，由于类ZJPerson中 类方法sayHappys 是以 实例方法 存储在 元类中的，因此 元类ZJPerson 中有该 实例方法，那么为什么会返回 类方法sayHappy 的地址呢？ 【问题】：ZJPerson元类 为什么会有 类方法sayHappy？ 我们查看一下源码: 123456789101112131415//获取类方法Method class_getClassMethod(Class cls, SEL sel)&#123; if (!cls || !sel) return nil; return class_getInstanceMethod(cls-&gt;getMeta(), sel);&#125;⬇️//获取元类 // NOT identical to this-&gt;ISA when this is a metaclass 判断是否是元类，是元类就直接返回，反之，继续找isa指向Class getMeta() &#123; if (isMetaClass()) return (Class)this; else return this-&gt;ISA();&#125; 由源码可知：class_getClassMethod 的实现是获取类的类方法，其本质就是 获取元类的实例方法，最终还是会走到 class_getInstanceMethod，但是在这里需要注意的一点是，在 getMeta 源码中，如果判断出 cls 是 元类，那么就 不会 再继续往下 递归查找，会直接返回 this ，其目的是为了 防止元类的无限递归查找 【结论】由源码可知： 获取元类的类方法，本质是 获取元类的实例方法 方法method4：是会返回地址的 zjIMP_classToMetaclass 函数：用于获取 类和元类 中的方法实现 12345678910111213141516void zjIMP_classToMetaclass(Class pClass)&#123; const char *className = class_getName(pClass); Class metaClass = objc_getMetaClass(className); // - (void)sayHello; // + (void)sayHappy; IMP imp1 = class_getMethodImplementation(pClass, @selector(sayHello)); IMP imp2 = class_getMethodImplementation(metaClass, @selector(sayHello)); IMP imp3 = class_getMethodImplementation(pClass, @selector(sayHappy)); IMP imp4 = class_getMethodImplementation(metaClass, @selector(sayHappy)); NSLog(@&quot;%p-%p-%p-%p&quot;,imp1,imp2,imp3,imp4); NSLog(@&quot;%s&quot;,__func__);&#125; 查看一下打印结果: 10x1000017c0-0x7fff72080580-0x7fff72080580-0x1000017f0 下面我们来分析一下打印结果: class_getMethodImplementation ：用于获取 类或类的父类 的 方法实现，根据官方文档的解释: 其大致含义就是：该函数在向类实例发送消息时会被调用，并返回一个指向 方法实现函数的指针。这个函数会比 method_getImplementation(class_getInstanceMethod(cls, name)) 更快。返回的函数指针可能是一个指向 runtime内部的函数，而不一定是方法的实际实现。如果类实例无法响应 selector ，则返回的函数指针将是运行时 消息转发机制 的一部分 下面我们也可以通过这个方法的源码来印证上面的这个说法， 12345678910111213141516IMP class_getMethodImplementation(Class cls, SEL sel)&#123; IMP imp; if (!cls || !sel) return nil; //查找方法实现 imp = lookUpImpOrNil(nil, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER); //如果没有找到，则进行消息转发 if (!imp) &#123; return _objc_msgForward; &#125; return imp;&#125; 从上面的代码可知传入的 pClass 是 ZJPerson 类，metaClass 是 ZJPerson元类,函数中4个打印结果分别是： imp1的地址：0x1000017c0 传入的 pClass 是 ZJPerson，查找的是sayHello函数指针，由于ZJPerson中有该函数指针，所以返回的地址是 0x1000017c0 imp2的地址：0x7fff72080580 传入的 metaClass 是 ZJPerson元类，查找的方法是 sayHello类方法，根据 类方法存储在元类中 可知，sayHello是一个实例方法，并不存储在元类中，也没有其任何实现，所以进行了 消息转发 imp3的地址：0x7fff72080580 传入的 pClass 是 ZJPerson，查找的方法是 sayHappy类方法，sayHappy 是一个类方法，并不存储在类中，也没有其任何实现，所以进行了 消息转发 imp4的地址：0x1000017f0 传入的 metaClass 是 ZJPerson元类，查找的方法是 sayHappy类方法，根据 类方法存储在元类中，可以在元类中查找到sayHappy 的具体实现，所以返回一个 imp函数指针的地址 【总结】 class_getInstanceMethod：获取 实例方法，如果指定的 类或其父类 不包含带有指定选择器的实例方法，则为NULL class_getClassMethod：获取 类方法，如果指定的类或其父类不包含具有指定选择器的类方法，则为NULL。 class_getMethodImplementation：获取方法的具体实现，如果未查找到，则进行 消息转发 【面试题】iskindOfClass &amp; isMemberOfClass 的理解 iskindOfClass &amp; isMemberOfClass 类方法调用 12345BOOL re1 = [(id)[NSObject class] isKindOfClass:[NSObject class]]; BOOL re2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];BOOL re3 = [(id)[ZJPerson class] isKindOfClass:[ZJPerson class]];BOOL re4 = [(id)[ZJPerson class] isMemberOfClass:[ZJPerson class]];NSLog(@&quot; re1 :%hhd\\n re2 :%hhd\\n re3 :%hhd\\n re4 :%hhd\\n&quot;,re1,re2,re3,re4); 查看打印结果: 12342020-09-16 23:45:31.732090+0800 KCObjc[41895:1261834] re1 :1 re2 :0 re3 :0 re4 :0 iskindOfClass &amp; isMemberOfClass 实例方法调用 123456BOOL re5 = [(id)[NSObject alloc] isKindOfClass:[NSObject class]]; BOOL re6 = [(id)[NSObject alloc] isMemberOfClass:[NSObject class]]; BOOL re7 = [(id)[ZJPerson alloc] isKindOfClass:[ZJPerson class]]; BOOL re8 = [(id)[ZJPerson alloc] isMemberOfClass:[ZJPerson class]]; NSLog(@&quot; re5 :%hhd\\n re6 :%hhd\\n re7 :%hhd\\n re8 :%hhd\\n&quot;,re5,re6,re7,re8); 查看打印结果： 123452020-09-16 23:45:31.733480+0800 KCObjc[41895:1261834] re5 :1 re6 :1 re7 :1 re8 :1Program ended with exit code: 0 【问题】：那么是为什么呢？接下来我们通过 objc4 源码来分析一下： 要想分析源码，我们需要深入理解 isa 流程图，如下： 注：NSObject类 和 NSObject根元类 不相等 接下来我们查一下 isKindOfClass 调用的源码: 查看 类 调用的源码： 123456+ (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = self-&gt;ISA(); tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125; 查看 实例对象 调用的源码: 123456- (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125; 我们再查看一下 isMemberOfClass 调用的源码： 查看 类 调用的源码： 123+ (BOOL)isMemberOfClass:(Class)cls &#123; return self-&gt;ISA() == cls;&#125; 查看 实例对象 调用的源码: 1234- (BOOL)isMemberOfClass:(Class)cls &#123; return [self class] == cls;&#125; 【源码分析总结】 isKindOfClass 类方法：元类（isa） --&gt; 根元类（父类） --&gt; 根类（父类） --&gt; nil（父类） 与 传入类的对比 实例方法：对象的类 --&gt; 父类 --&gt; 根类 --&gt; nil 与 传入类的对比 isMemberOfClass 类方法： 类的元类 与 传入类 对比 实例方法：对象的父类 与 传入类 对比 由上面的源码我们知道了具体调用的源码，由此我们来具体分析为什么打印1000 1111这个结果: 【使用类方法结果分析】 re1：1，是 NSObject 和 NSObject 的对比，使用 +isKindOfClass NSObject（传入类，即 根类）vs NSObject的元类（即 根元类） 相比 – 不相等 NSObject（传入类，即 根类）vs 根元类的父类（即 根类）相比 – 相等 [NSObject class] isKindOfClass:[NSObject class]] 内部调用分析图： 由上面的分析图可知：打印结果为 1 re2：0，是 NSObject 和 NSObject 的对比，使用 +isMemberOfClass NSObject （传入类，即 根类） vs NSObject的元类（即 根元类）对比 – 不相等 [NSObject class] isMemberOfClass:[NSObject class] 内部调用分析图： re3：0，是 ZJPerson 与 ZJPerson 的对比，使用 +isKindOfClass ZJPerson（传入 类）vs ZJPerson的元类（即 元类ZJPerson） 对比 – 不相等 ZJPerson（传入 类）vs 元类ZJPerson的父类（即 根元类） 对比 – 不相等 ZJPerson（传入 类）vs 根元类的父类（即 根类） 对比 – 不相等 ZJPerson（传入 类）vs 根类的父类（即 nil） 对比 – 不相等 [ZJPerson class] isKindOfClass:[ZJPerson class] 内部调用分析图： re4：0，是 ZJPerson 与 ZJPerson 的对比，使用 +isMemberOfClass ZJPerson（传入 类）vs 元类 对比 – 不相等 [ZJPerson class] isMemberOfClass:[ZJPerson class] 内部调用分析图： 【使用实例方法结果分析】 re5：1，是 NSObject对象 和 NSObject 的对比，使用 -isKindOfClass NSObject（传入 根类）vs 对象的 isa（即 NSObject根类） 对比 – 相等 [NSObject alloc] isKindOfClass:[NSObject class] 内部调用分析图： re6：1，是 NSObject对象 和 NSObject 的对比，使用 -isMemberOfClass NSObject（传入 根类）vs 对象的类（即 NSObject根类） 对比 – 相等 [NSObject alloc] isMemberOfClass:[NSObject class]内部调用分析图： re7：1，是 ZJPerson对象 和 ZJPerson 的对比，使用 -isKindOfClass ZJPerson（传入 类）vs 对象的 isa （即 ZJPerson） 对比 – 相等 [ZJPerson alloc] isKindOfClass:[ZJPerson class]内部调用分析图： re8：1，是 ZJPerson对象 和 ZJPerson 的对比，使用 -isMemberOfClass ZJPerson（传入 类）vs 对象的类（即 ZJPerson） 对比 – 相等 [ZJPerson alloc] isMemberOfClass:[ZJPerson class]","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理10：类 & 类结构分析","slug":"OC进阶/OC底层原理10：类 & 类结构分析","date":"2020-09-24T13:58:37.000Z","updated":"2022-04-22T07:42:49.000Z","comments":true,"path":"2020/09/24/OC进阶/OC底层原理10：类 & 类结构分析/","link":"","permalink":"https://www.bboyzj.cn/2020/09/24/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8610%EF%BC%9A%E7%B1%BB%20&%20%E7%B1%BB%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/","excerpt":"","text":"前言本章主要的目的是分析 类 和 类结构 objc_class 和 objc_object为什么 对象 和 类 都有 isa指针？ 在 iOS-OC底层原理08：isa和类关联探索 中，使用 clang 编译过 main.m 文件，从编译后的 main.cpp 文件中,我们分析了 对象 的 本质 是 结构体，如下: NSObject 的底层编译是 struct objc_object 结构体 123456789typedef struct objc_object NSObject;struct NSObject_IMPL &#123; Class isa;&#125;;typedef struct objc_class *Class;struct objc_object &#123; Class _Nonnull isa __attribute__((deprecated));&#125;; 由编译后的 c++ 源码可知： NSObject 底层被编译成结构体 struct objc_object 类型，因此 对象 的本质是 结构体 isa指针 是 Class 类型的，是由 struct objc_calss 结构体定义的类型，所有的 Class 都是以 objc_class 为模板创建的 objc_object 结构体内部有 objc_class 这个结构体，那么问题来了 【问题】objec_class 和 objc_object 有什么关系呢？ 我们通过查看 objc4源码 找到 objc_class 和 objc_object 的定义，来分析一下两者之间的关系： 在objc4源码中搜索 objc_class，其源码定义如下: 一个位于 runtime.h 文件中，已经被废弃了 一个位于 objc-runtime-new.h 文件中，是可用的 在 objc4 源码中搜索 objc_object，其源码定义如下： 位于 objc.h 文件中 通过上述查找源码和其定义，可总结出以下几点内容： 结构体类型 objc_class 继承自 objc_object 类型，其中 objc_object 也是一个结构体，且有一个 isa 属性，所以 objc_class 也拥有了 isa 属性 mian.cpp 底层编译文件中，NSObject 中的 isa 在底层是由 Class 定义的，其中 class 的底层编码来自 objc_class 类型，所以 NSObject 也拥有了 isa属性 NSObject 是一个类，用它初始化一个实例对象 objc，objc 满足 objc_object 的特性（即有isa属性），主要是因为 isa 是由 NSObject 从objc_class 继承过来的，而 objc_class 继承自 objc_object，objc_object 有isa属性。所以 对象 都 有 一个 isa，isa表示指向，来自于当前的 objc_object objc_object（结构体） 是 当前的 根对象，所有的 对象 都有这样一个特性 objc_object，即拥有 isa属性 【百度面试题】objc_object 与 对象的关系? 所有的 对象 都是 来自NSObject(来自于OC端)，但是真正到底层是一个 objc_object（C/c++） 结构体 类型的 所有的 对象 都是 以objc_object 模板 继承过来的 【总结】： 所有的 对象 + 类 + 元类 都有 isa 所有的 对象 都是由 objc_object继承 来的 简单概括就是 万物皆对象，万物皆来源于 objc_object，有以下两点结论： 所有以 objc_object 为模板 创建的 对象，都有 isa属性 所有以 objc_class 为模板，创建的 类，都有 isa属性 在结构层面可以通俗的理解为 上层OC 与 底层 的对接： 底层是通过 结构体 定义的 模板，例如 objc_class、objc_object 上层 是通过底层的模板创建的 一些类型，例如ZJPerson 补充知识-内存偏移在分析 类信息 中存储哪些信息之前，需要先 了解内存偏移，因为分析 类信息 需要用到内存偏移 1、【普通指针】 定义一个方法 12345678910// 普通指针void testOffset1()&#123; // a/b : 变量 10 ： 值 int a = 10; int b = 10; // a/b : 打印得值 &amp;a/&amp;b : 取a的地址指针 NSLog(@&quot;%d---%p&quot;,a,&amp;a); NSLog(@&quot;%d---%p&quot;,b,&amp;b);&#125; 在mian.m调用，查看打印结果 122020-10-04 13:41:07.378260+0800 KCObjc[23781:838866] 10---0x7ffeefbff4a82020-10-04 13:41:07.378948+0800 KCObjc[23781:838866] 10---0x7ffeefbff4ac 由上述的打印结果可知： a、b 都是 常量型变量，a、b 的 地址指针不一样，分别指向 值10，在内存中 10 是通过 值拷贝，分别赋值给 a、b a 的地址是 0x7ffeefbff4a8，b 的地址是 0x7ffeefbff4ac，他们相差 4字节，这是由 a/b 本身类型(Int占4个字节) 决定的 其地址指针指向如图所示： 2、【对象指针】 定义一个方法 12345678// 对象指针void testOffset2()&#123; // p1：指针 ZJPerson * p1 = [ZJPerson alloc]; ZJPerson * p2 = [ZJPerson alloc]; NSLog(@&quot;%@---%p&quot;,p1,&amp;p1); NSLog(@&quot;%@---%p&quot;,p2,&amp;p2);&#125; 在mian.m调用，查看打印结果 122020-10-04 14:14:59.341733+0800 KCObjc[24079:859357] &lt;ZJPerson: 0x101035830&gt;---0x7ffeefbff4a02020-10-04 14:14:59.341901+0800 KCObjc[24079:859357] &lt;ZJPerson: 0x101035980&gt;---0x7ffeefbff4a8 由上述的打印结果可知： p1、p2 是 一级地址指针，p1、p2 是指向 [ZJPerson alloc] 申请内存空间 &amp;p1、&amp;p2 是 二级指针， &amp;p1、&amp;p2 指向 p1、p2 对象的 一级地址指针 其地址指针指向如图所示： 3、【数组指针】 定义一个方法 12345678// 数组指针void testOffset3()&#123; int c[4] = &#123;1,2,3,4&#125;; int *d = c; NSLog(@&quot;%p -- %p - %p&quot;, &amp;c, &amp;c[0], &amp;c[1]); NSLog(@&quot;%p -- %p - %p&quot;, d, d+1, d+2);&#125; 在mian.m调用，查看打印结果 122020-10-04 14:38:14.720430+0800 KCObjc[24171:872712] 0x7ffeefbff490 -- 0x7ffeefbff490 - 0x7ffeefbff4942020-10-04 14:38:14.720522+0800 KCObjc[24171:872712] 0x7ffeefbff490 -- 0x7ffeefbff494 - 0x7ffeefbff498 由上述的打印结果可知： &amp;c 和 &amp;c[0] 都是取 首地址，即数组名等于首地址 &amp;c 与 &amp;c[1] 相差 4个字节，地址之间相差的字节数，主要 取决于 存储的 数据类型 *d 代表取 c 的地址，可以通过 lldb 调试 p *(d+1)、*(d+2) 获取 地址 所对应的值 2、4 可以通过 首地址+偏移量 取出数组中的其他元素，其中偏移量 是 数组的 下标，内存中首地址实际移动的 字节数 等于 偏移量 * 数据类型字节数 其地址指针指向如图所示： 探索类信息中都有哪些内容由前文可知，所有的 类 都是以 objc_class 模板创建的，通过 objc4 源码可知，objc_class 中包含许多属性，如下： 12345678910111213struct objc_class : objc_object &#123; // Class ISA; // 继承自objc_object 的isa指针 Class superclass; // Class 类型的 superclass cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags // 获取data class_rw_t *data() const &#123; return bits.data(); &#125; //...此处省略许多方法&#125; 【这些属性的定义】： isa 属性：继承自 objc_object 的isa，占 8 字节 superclass 属性：Class 类型，Class是由 objc_object 定义的，是一个指针，占 8 字节 cache 属性：简单从类型 class_data_bits_t 目前无法得知，而class_data_bits_t 是一个结构体类型，结构体的 内存大小 需要根据 内部的属性 来确定，而 结构体指针才是8字节 bits属性：只有 首地址 经过上面 3个属性 的 内存大小总和 的 平移，才能获取到 bits 我们知道了 objc_class 中 存储 了 类 的 信息，那么如何去验证呢? 【验证方法】lldb 调试验证： 自定义一个ZJPerson类，继承自NSObject 1234@interface ZJPerson : NSObject@end@implementation ZJPerson@end 在 main.m 中初始化 ZJPerson 类和 NSObject 类 12345678910int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... NSObject * obj = [NSObject alloc]; ZJPerson * p = [ZJPerson alloc]; NSLog(@&quot;Hello, World! %@ - %@&quot;,obj,p); &#125; return 0;&#125; 下断点到 NSObject... 行，通过 lldb 调试，过程如下： 计算cache_t的内存大小由上面的分析，我们知道了 cache_t 内存大小 和 内部属性 有关，因此我们需要进入 objc4-781新版本 内部源码去分析 进入 cache 类 cache_t 的定义（只贴出了结构体中 非static 修饰的 属性，主要是因为 static类型 的属性 不存在结构体 的内存中），有如下几个属性： 1234567891011121314151617181920212223242526struct cache_t &#123;#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED // 是一个结构体指针类型，占8字节 explicit_atomic&lt;struct bucket_t *&gt; _buckets; // 是mask_t 类型，而 mask_t 是 unsigned int 的别名，占4字节 explicit_atomic&lt;mask_t&gt; _mask;#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16 ...此处省略 #elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4 ...此处省略 #else#error Unknown cache mask storage type.#endif #if __LP64__ // 内部是 unsigned short 类型的 2字节 uint16_t _flags; // 2#endif // 内部是 unsigned short 类型的 2字节 uint16_t _occupied; // 2 &#125; 计算 cache_t 内部属性的大小，最后的内存大小总和都是 16 字节 _buckets 类型是 struct bucket_t *，是结构体指针类型，占8字节 mask 是 mask_t 类型，而 mask_t 是 unsigned int 的类型，占4字节 _flags 是 uint16_t 类型，uint16_t是 unsigned short 的类型，占 2个字节 _occupied 是 uint16_t 类型，uint16_t是 unsigned short 的类型，占 2个字节 总结：所以最后计算出 cache_t 类的内存大小 = 8 + 4 + 2 + 2 = 16字节 获取bits由上述计算 Class类型 ISA 是 8字节、Class superclass 是 8 字节、cache_t cache 是 16字节; 可知，想要获取 bits 的中的内容，只需通过 类的 首地址平移 32字节（8 + 8 + 16） 即可 【验证】：通过lldb命令调试 自定义两个类 ZJPerson 和继承自ZJPerson的 ZJStudent 类： 1234567891011121314151617@interface ZJPerson : NSObject// 名字@property (nonatomic,copy)NSString * name;// 方法- (void)test;@end@implementation ZJPerson// 方法- (void)test&#123; NSLog(@&quot;来了!&quot;);&#125;@end@interface ZJStudent : ZJPerson@end@implementation ZJStudent@end main.m中定义两个类 1234ZJPerson * person = [ZJPerson alloc];ZJStudent * student = [ZJStudent alloc];// class_data_bits_tNSLog(@&quot;hello world :%@ %@&quot;,person,student); 下断点到 NSLog，lldb 命令调试 bits 流程如下: 由调试结果可知: 通过 p/x ZJPerson.class 获类的信息，即 首地址 信息 通过 x/4gx 0x0000000100002188 拿到 首地址 0x100002188，经过 32位平移 得到 bits 地址 0x1000021a8 通过 p (class_data_bits_t *)0x1000021a8 获取 bits 通过 p $1-&gt;data() 获取 class_rw_t 如果 class_data_bits_t * 是 * 号，说明是对象，访问对象用 -&gt; 如果 class_data_bits_t 是 结构体，用 . 号 通过 p *$2 打印 bits 中 class_rw_t 内部信息，firstSubclass = ZJStudent,表示第一个继承子类 ZJStudent class_rw_t通过查看 class_rw_t 定义的源码发现，结构体中有提供相应的方法去获取 属性列表、方法列表 等，如下所示： 属性列表（property_list）【准备工作】：在ZJPerson中增加一个 属性 和一个 成员变量 12345678@interface ZJPerson : NSObject&#123; NSString * sex; // 性别&#125;// 名字@property (nonatomic,copy)NSString * name;@end@implementation ZJPerson 【探索】 由上图可知 properties 是 property_array_t 类型的，其内部源码如下： 我们通过 lldb 调试属性列表，如下: 由lldb调试可知: p $3.properties() 命令中的 propertoes 方法是由 class_rw_t 提供的,方法中返回的实际类型为 property_array_t 由于 list 的类型是 property_list_t ，是一个指针，所以通过 p *$4 获取内存中的信息，同时也证明 bits 中存储了 property_list，即属性列表 p $6.get(0)，获取ZJPerson中的第一个属性 name p $6.get(1)，想要获取 ZJPerson 中的成员变量 sex， 发现会报错，提示数组越界了，说明 property_list 中只有 一个属性 name 【问题】探索成员变量的存储 由此可得出 property_list 中只有 属性，没有 成员变量 ，属性与成员变量的区别就是有没有set、get方法，如果有，则是属性，如果没有，则是成员变量。 那么问题来了，成员变量 存储在哪里？为什么会有这种情况？请移至文末的分析与探索 方法列表（methods_list）【准备工作】 在ZJPerson中增加两个方法，一个对象方法和一个类方法 123456789101112@interface ZJPerson : NSObject- (void)sayHello;+ (void)sayBye;@end@implementation ZJPerson- (void)sayHello&#123; NSLog(@&quot;hello&quot;);&#125;+ (void)sayBye&#123; NSLog(@&quot;bye&quot;);&#125;@end 【开始探索】通过 lldb 调试来获取方法列表，步骤如图所示： 由lldb调试可知: 系统在编译的时候自动帮你生成 通过 p $4.methods() 获得具体的方法列表的list结构，其中 methods 也是class_rw_t 提供的方法 通过 p *$6. 打印的 count = 4 可知，存储了 4 个方法，其中 syaHello 是 自己 声明的方法，cxx_destruct、name、setName: 是 系统 生成的方法 可以通过p $7.get(i)内存偏移 的方式获取单个方法,i 的范围是 0-3 如果在打印 p $7.get(4)，获取第五个方法，也会报错，提示 数组越界 补充知识-属性、成员变量、实例变量我们通常都知道 @property 是 属性 的意思，但是什么是 成员变量 和 实例变量 呢？我们探索一下： 1、首先我们自定义一个类 ZJPerson，放在 main.m 中： 1234567891011121314151617181920// 成员变量 vs 属性@interface ZJPerson : NSObject&#123; NSString *hobby; NSObject *objc;&#125;@property (nonatomic, copy) NSString *nickName;@property (nonatomic, strong) NSString *name;@end@implementation ZJPerson@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // 属性&amp;成员变量&amp;实例变量 ZJPerson * P = [ZJPerson alloc]; NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125; 2、我们通过 clang 编译一下这个 main.m 为 main.cpp ,来查看 C 的底层实现，步骤如下： 1）我们打开终端，cd到你要编译文件的文件夹下： 1mac@192 ~ % cd /Users/mac/Desktop/逻辑教育/LG-OC底层大师班上课资料/20200914-大师班第5天-类原理分析-资料/01--课堂代码/001-类的属性与变量/001-类的属性与变量 2）输入编译命令clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk xxxx.m编译你的目标文件： 1mac@192 001-类的属性与变量 % clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk main.m 3）然后你目录下就会重写一个 cpp 文件，内容比较多你可以搜索关键类 ZJPerson 对照查看： 3.我们打开 main.cpp 查找 ZJPerson 来查看一下： hobby 和 objc 没有下划线 _，是 成员变量 nickName 和 name 有下划线 _，是 属性 继续往下看： hobby 和 objc 没有没有生成 setter 和 getter 方法，是 成员变量 nickName 和 name 有生成 setter 和 getter 方法，是 属性 4、由上面我们知道了什么是成员变量和属性，那么实例变量呢？ hobby 不能进行实例化，是 成员变量 objc 能进行实例化，是 实例变量 ，也可以称特殊的成员变量,如: objc = [NSObject alloc] ; 5、我们用一下图表示 成员变量&amp;实例变量&amp;属性 的关系： 6、由上面的分析我们得知了，什么是 属性、成员变量和实例变量 由上面的探索我们了解了什么是 属性 和 成员变量，我们也可以通过下面的方法来验证一下属性列表和成员变量列表是不是正确的，如下： zjObjc_copyIvar_copyProperies 函数：打印 变量 和 属性 名 123456789101112131415161718192021222324void zjObjc_copyIvar_copyProperies(Class pClass)&#123; unsigned int count = 0; Ivar *ivars = class_copyIvarList(pClass, &amp;count); for (unsigned int i=0; i &lt; count; i++) &#123; Ivar const ivar = ivars[i]; // 获取实例变量名 const char*cName = ivar_getName(ivar); NSString *ivarName = [NSString stringWithUTF8String:cName]; ZJLog(@&quot;class_copyIvarList:%@&quot;,ivarName); &#125; free(ivars); unsigned int pCount = 0; objc_property_t *properties = class_copyPropertyList(pClass, &amp;pCount); for (unsigned int i=0; i &lt; pCount; i++) &#123; objc_property_t const property = properties[i]; // 获取属性名 NSString *propertyName = [NSString stringWithUTF8String:property_getName(property)]; // 获取属性值 ZJLog(@&quot;class_copyProperiesList:%@&quot;,propertyName); &#125; free(properties);&#125; 在main.m中调用 123456789101112int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; //属性&amp;成员变量&amp;实例变量 ZJPerson * P = [ZJPerson alloc]; // 打印 Class pClass = object_getClass(P); zjTypes(); zjObjc_copyIvar_copyProperies(pClass); NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125; 查看打印结果： 123456class_copyIvarList:hobbyclass_copyIvarList:objcclass_copyIvarList:_nickNameclass_copyIvarList:_nameclass_copyProperiesList:nickNameclass_copyProperiesList:name 由结果可知： 成员变量列表有4个：hobby、objc、_nickName、_name 。 属性列表有2个： nickName、name。 成员变量的存储（ivars）由上面的属性列表分析可得出 property_list 中只有 属性，没有 成员变量，那么问题来了，成员变量 存储在哪里 ？为什么会有这种情况？ 通过 objc4-781最新源码 查看 objc_class 中 bits属性 中存储数据的类 class_rw_t 的结构发现，除了 methods、properties、protocols 方法，还有一个 ro 方法，其返回类型是 class_ro_t ，如下图所示: 点击进去查看 class_ro_t 定义，如下图： 发现其中有一个 ivars属性 ，我们可以做如下猜测：是否成员变量就存储在这个 ivar_list_t 类型的 ivars 属性中呢？ 下面我们通过 lldb 的调试来验证一下： 由上图lld调试可知： 通过 p *$7 打印成员变量列表，count = 2，我们知道 class_ro_t 中包含两个 成员变量 sex 和 name 通过 bits --&gt; data() --&gt;ro() --&gt; ivars 获取 成员变量 列表，除了包括成员变量，还包括 属性 定义的 成员变量 通过 @property 定义的属性，也会存储在 bits 属性中，通过 bits --&gt; data() --&gt; properties() --&gt; list 获取属性列表，其中只存储 属性 类方法的存储我们由前文探索方法列表可知，在 method_list 中 没有类方法，只有实例方法，那么问题来了，类方法存储在哪里？为什么会有这种情况？下面我们来仔细分析下 我们在 OC底层原理09：isa走向&amp;继承分析 中，曾提及了 元类，类对象的 isa 指向就是 元类，元类是用来 存储类 的 相关信息 的，所以我们猜测：是否 类方法 是否存储在 源类bits方法 中呢？可以通过 lldb 命令来验证我们的猜测。下图是 lldb 命令的调试流程： 由上图lld调试可知： 类的 实例方法 存储在 类的bits属性 中，通过 bits --&gt; methods() --&gt; list 获取实例方法列表，例如 ZJPerson类 的 实例方法 sayHello 就存储在ZJPerson类 的 bits属性 中，类中的方法列表除了 包括实例方法，还包括系统自动生成的 属性 的 set方法 、 get方法 和 cxx_destruct方法， 类的 类方法 存储 在元类 的 bits属性 中，通过元类 bits --&gt; methods() --&gt; list 获取类方法列表，例如ZJPerson中的类方法 sayBye 就存储在ZJPerson类的 元类（名称也是ZJPerson）的 bits属性 中","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理09：isa走向&继承分析","slug":"OC进阶/OC底层原理09：isa走向&继承分析","date":"2020-09-22T13:57:52.000Z","updated":"2022-04-22T02:33:43.000Z","comments":true,"path":"2020/09/22/OC进阶/OC底层原理09：isa走向&继承分析/","link":"","permalink":"https://www.bboyzj.cn/2020/09/22/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8609%EF%BC%9Aisa%E8%B5%B0%E5%90%91&%E7%BB%A7%E6%89%BF%E5%88%86%E6%9E%90/","excerpt":"","text":"本文的主要目的是分析 isa走向 和 继承 的分析 准备工作定义两个类 : 继承自 NSObject 的 ZJPerson 类 1234@interface ZJPerson : NSObject@end@implementation ZJPerson@end 继承自 ZJPerson 的 ZJStudent 类 1234@interface ZJStudent : ZJPerson@end@implementation ZJStudent@end 在 main.m 中 分别创建两个对象：person &amp; student 123456789int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // ISA_MASK 0x00007ffffffffff8ULL ZJPerson * person = [ZJPerson alloc]; ZJStudent * student = [ZJStudent alloc]; NSLog(@&quot;Hello World:%@ - %@&quot;,person,student); &#125; return 0;&#125; 元类首先，我们先通过一个案例的 lldb 调试引入 元类 概念 在 main 中 NSLog(@&quot;Hello World:%@ - %@&quot;,person,student); 处下一个 断点，运行程序，开启 lldb 调试，调试的过程如下图所示： x/4gx person ：查看 person 的内存分布情况，拿到 isa 的指针地址 0x001d8001000021d1 p/x person ：拿到 0x0000000101159370 地址，这个地址首先代表 首地址，其次代表 当前对象，也代表 isa， 那么为什么即代表当前对象，又代表 isa 呢？ 任何自定义的类，如ZJPerson，均继承自NSObject，NSObject 默认第一个参数为 Class isa，所以首地址会指向 isa，isa 又代表当前的类 p/x 0x001d8001000021d1 &amp; 0x00007ffffffffff8ULL：获取 类ZJPerson 的指针地址 0x00000001000021d0 po 0x00000001000021d0：根据 类 的指针地址 0x00000001000021d0 打印 类信息，得到 类 ZJPerson 查看类的内存分布有三种方式： 通过 类 的 指针地址: x 0x00000001000021d0 通过 class 的 API: x ZJPerson.class 通过 runtime 的 API: x object_getClass(person) x/4gx 0x00000001000021d0：查看 类ZJPerson 的 内存分布 情况，拿到 isa 指针地址 0x00000001000021a8 po 0x00000001000021a8：打印ZJPerson类的isa指针指向的内容，即 元类，其元类也是ZJPerson p/x 0x00000001000021a8 &amp; 0x00007ffffffffff8ULL：通过 类isa &amp; mask 获取元类的isa指针地址0x00000001000021a8 po 0x00000001000021a8：打印 元类 的指针信息，拿到 ZJPerson 根据调试过程，我们产生了一个疑问：为什么图中的 p/x 0x001d8001000021d1 &amp; 0x00007ffffffffff8ULL 与 p/x 0x00000001000021a8 &amp; 0x00007ffffffffff8ULL 中的类信息打印出来都是 ZJPerson？ 0x001d8001000021d1 是 person对象的 isa指针地址，其 &amp; mask 后得到的结果是获取对象 person 的 类ZJPerson 0x00000001000021a8 是 元类的isa指针地址，即 ZJPerson类的类 的isa指针地址，在Apple中，我们简称 ZJPerson类的类 为 元类 所以，两个打印都是 ZJPerson 的根本原因就是因为 元类 导致的 元类的说明: 下面来解释什么是元类，主要有以下几点说明： 我们知道 对象的isa 是 指向类，类 其实 也是 一个 对象，可以称为 类对象，其 isa 的位域 指向 苹果定义的 元类 元类 是 系统生成 的，其定义和创建都是由编译器完成，在这个过程中，类 的归属 来自 于 元类 元类 是 类对象 的 类，每个类都有一个独一无二的元类用来存储 类方法的相关信息。 元类本身是没有名称的，由于与类相关联，所以使用了同类名一样的名称 isa走向下面通过 lldb 命令来探索isa指针的走向，如下图所示: 由上图 lldb 探索可以得出一个关系链：对象 --&gt; 类 --&gt; 元类 --&gt; NSobject --&gt; 指向自己 下面用一张图表示 isa走向 流程： 由上面的分析结果我们可知： 实例对象 的 isa 指针指向 类 类对象 的 isa 指针指向 元 类 元类 的 isa 指针指向 根元类 根元类 的 isa 指针指向 自己 NSObject到底有几个？由上图可知，最后的根元类是NSObject，这和我们日常开发中所知道的NSObject是同一个吗？ 有以下两种验证方式 【方法一】lldb命令验证 【方法二】代码验证 【方法一】lldb命令验证 从图中可以看出，由实例对象 person 最终 isa 找到的根源个 NSObject，与下面 开发中使用的 NSobject 相同，所以可以得出一个结论：内存中只存在一份根元类NSObject，根元类的元类是指向它自己 【方法二】代码验证 通过三种不同的方式获取类，看他们打印的地址是否相同 1234567// MARK: -分析类对象在内存中存在几份void testClassNum()&#123; Class class1 = [ZJPerson class]; Class class2 = [ZJPerson alloc].class; Class class3 = object_getClass([ZJPerson alloc]); NSLog(@&quot;\\n%p-\\n%p-\\n%p&quot;, class1, class2, class3);&#125; 以上代码的运行结果是 12342020-10-02 22:46:53.183944+0800 ZJObjc[21320:623345] 0x100002190-0x100002190-0x100002190 从打印结果中可以看出，打印的 地址 都是 同一个 ，所以 类对象 在内存中 只存在一份。 【面试题】 问：类对象在内存中存在几份？ 答：由于类信息在内存中只存在一份，所以 类对象只存在一份 继承下面我们通过两道面试题来了解一下继承关系 1、【面试题1】： 我们知道 类ZJTeacher 继承自 类ZJPerson ，那么 实例对象tearher 和 实例对象person 有关系么？ 答：没有关系 分析： 继承关系之来源与 类 实例对象没有关系 2、【面试题2】： ZJTearher 继承自 ZJPerson，ZJPerson 继承自 NSObject,那么 NSObject 继承自谁呢？ 答：NSObject 继承自 nil 用一张图来总结一下继承关系: ZJTeacher 和 NSObject isa 走位图由上面 继承 和 isa走位图 分析，我们可以得出 ZJTeacher 和 NSObject 的 isa走位 图： 继承 和 isa走位图根据上面的探索以及各种验证，我们可以得到著名的 继承 &amp; isa走位图： isa走位链三条： teacher（实例对象） -&gt; ZJTeacher（类） -&gt; ZJTeacher（元类）-&gt; NSObject（根元类）-&gt; NSObject（根根元类） person（实例对象） -&gt; ZJPerson（类） -&gt; ZJPerson（元类）-&gt; NSObject（根元类）-&gt; NSObject（根根元类） object（实例对象） -&gt; NSObject（类） -&gt; NSObject（元类）-&gt; NSObject（根元类）-&gt; NSObject（根根元类） 继承链两条： ZJTeacher（子类）-&gt; ZJPerson（父类）-&gt; NSObject(根类) -&gt; nil ZJTeacher（子元类）-&gt; ZJPerson（父元类）-&gt; NSObject(根元类) -&gt; NSObject（根类）-&gt; nil","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理08：isa和类关联探索","slug":"OC进阶/OC底层原理08：isa和类关联探索","date":"2020-09-18T07:04:23.000Z","updated":"2023-02-25T07:33:42.588Z","comments":true,"path":"2020/09/18/OC进阶/OC底层原理08：isa和类关联探索/","link":"","permalink":"https://www.bboyzj.cn/2020/09/18/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8608%EF%BC%9Aisa%E5%92%8C%E7%B1%BB%E5%85%B3%E8%81%94%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"前言本文的主要目的是理解 类与isa 是如何 关联 的 在介绍正文之前，首先需要理解一个概念：OC对象 的 本质 是什么？ 在探索oc对象本质前，先了解一个编译器：clang Clang1、介绍 Clang 是⼀个由 Apple 主导编写，基于 LLVM的C/C++/Objective-C 编译器 主要是用于 底层编译，将一些文件输出成 c++ 文件，例如 main.m 输出成 main.cpp，其目的是为了更好的观察 底层 的一些 结构 及 实现 的逻辑，方便理解底层原理。 2、 常用编译命令： 把⽬标⽂件编译成 c++ ⽂件，终端输入 clang -rewrite-objc main.m -o main.cpp 3、 xcode安装的时候顺带安装了 xcrun 命令，xcrun 命令在 clang 的基础上进⾏了⼀些封装，要更好⽤⼀些： xcrun -sdk iphonesimulator clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp (模拟器) xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main\u0002arm64.cpp (⼿机) 对象的本质**1、 第一步：自定义一个 ZJPerson 类，添加一个属性 name ** 2、 通过终端，利用 clang 将 main.m 编译成 main.cpp，有以下几种编译命令，这里使用的是第一种: 12345678910111213// 1、将 main.m 编译成 main.cppclang -rewrite-objc main.m -o main.cpp// 2、将 main.m 编译成 main.cppclang -rewrite-objc -fobjc-arc -fobjc-runtime=ios-13.0.0 -isysroot / /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator13.7.sdk main.m// 以下两种方式是通过指定架构模式的命令行，使用xcode工具 xcrun// 3、模拟器文件编译xcrun -sdk iphonesimulator clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp // 4、真机文件编译xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main\u0002arm64.cpp 3、打开编译好的 main.cpp，找到 ZJPerson 的定义，发现 ZJPerson 在底层会被编译成 struct 结构体: 123456789101112131415161718192021// 👇NSObject的定义@interface NSObject &lt;NSObject&gt; &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot; Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop&#125;// 👇NSObject的底层编译struct NSObject_IMPL &#123; Class isa;&#125;;// 👇ZJPerson的底层编译struct ZJPerson_IMPL &#123; // NSObject_IVARS是isa // 结构体在c/c++可以继承的，继承自NSObject_IMPL struct NSObject_IMPL NSObject_IVARS; NSString *_name;&#125;; 如下图： ZJPerson 继承自 NSObject，属于 伪继承 ，伪继承 的方式是直接将NSObject 结构体定义为 ZJPerson 中的第一个属性，意味着 ZJPerson 拥有 NSObject 中的所有 成员变量。 ZJPerson 中的第一个属性就是 Class isa。 4、 总结 OC对象 的 本质 其实就是 结构体 ZJPerson 中的 isa 是 继承 自 NSObject 中的 isa objc_setProperty由上面可知 ZJPerson 被编译成 结构体，属性 name 被编译成对应的 set 和 get 方法，其中 set 方法的实现是依赖 runtime API objc_setProperty 实现的。 1、我们可以通过查找 objc4 源码来查看 objc_setProperty 底层的进一步实现： 1）全局搜索 objc_setProperty，查找所在位置 2）点击进入 objc_setProperty 内部查看源码实现 3）点击 reallySetProperty 查看内部源码实现 2、总结 通过对 objc_setProperty 底层源码探索，我们可得出以下几个结论： 所有 的 set 方法最终都将会 找到objc_setProperty LLVM中间 隔离层 函数去 调用 objc_setProperty 用于 关联上层 的 set 方法 和 下层 的reallySetProperty 的一个 接口隔离层 函数 这么设计的原因是，如果上层有 很多set 方法，如果你直接调用 下层 的 LLVM 方法，会 产生很多中间层变量，非常恶心，很难 去处理（很难找） 那么如何区分呢，系统根据 cmd 去查找，就是说无论你 上层 怎么变化，我下层reallySetProperty 都 不用变化，你 下层 怎么 变化 ，上层 都 不会被影响 3、上层、隔离层、底层之间的关系图： 联合体和结构体在 iOS-OC底层原理03：alloc&amp;init&amp;new探索 和 iOS-OC底层原理07：malloc源码探索 中我们分别探索了alloc核心源码中的前两个，分别是 cls-&gt;instanceSize 和 calloc ，今天我们来探索最后一个 obj-&gt;initInstanceIsa 在此之前我们需要先了解什么是 联合体，它和 结构体 的区别？ 1、构造数据类型的方式有以下两种： 结构体（struct） 联合体（union，也称为共用体） 2、 结构体和联合体 写法： 1234567891011121314151617181920// 结构体:s表示结构体类型名struct s&#123; // a,b,c表示结构体成员名 char a; //占1个字节 （0） int b; //占4个字节 （4，5，6，7） short c; //占2个字节 （8，9）&#125;s1;// s1表示结构体变量名// 访问该结构体内部成员时可以采用s1.a=1;其中&quot;点&quot;表示结构体成员运算符// 联合体// u1表示联合体类型名union u1&#123; // a,b,c表示联合体成员名 char a; //占1个字节 int b; //占4个字节 short c;//占2个字节&#125;u1; 在main.m中打印一下 12345678910111213int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; printf(&quot;%lu\\n&quot;,sizeof(s1)); printf(&quot;%lu\\n&quot;,sizeof(u1)); NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125;******查看打印结果******124(lldb) 由结果可知： 结构体 的大小为 12 ，最大成员变量的倍数 4*3 = 12 联合体 的大小为 4 ，最大成员变量 4 3、结构体（struct） 结构体：各成员各自拥有 自己的内存，各自使用 互不干涉，同时存在的，遵循 内存对齐 原则。一个 struct 变量的 总长度 等于 所有成员 的 长度之和。 缺点：所有属性都分配内存，比较浪费内存，假设有 4个int 成员，一共分配了 4*4=16 字节的内存，但是在使用时，你只使用了4字节，剩余的12字节就是属于内存的浪费 优点：存储容量较大，包容性强，且成员之间不会相互影响 4、联合体（union） 联合体：各成员 共用 一块 内存空间，并且同时只有一个成员可以得到这块内存的 使用权(对该内存的读写)，各变量 共用一个内存 首地址。因而，联合体比结构体更 节约内存。一个 union 变量的总长度至少能容纳 最大 的成员变量，而且要满足是所有 成员变量 类型大小的 整数倍。 缺点：，包容性弱 优点：所有成员共用一段内存，使内存的使用更为精细灵活，同时也节约内存 5、两者的区别 1）内存占用情况 结构体 的各个成员会 占用不同 的 内存 ，互相之间没有影响 共用体 的所有成员 占用同一段 内存，修改一个成员会影响其余所有成员 2）内存分配大小 结构体 内存 &gt;&#x3D; 所有成员占用的内存总和（成员之间可能会有缝隙） 共用体占用的内存等于最大的成员占用的内存 isa的类型1、我们知道 isa 的类型是 isa_t 的 联合体 ，isa_t 类型使用 联合体 的原因 也是基于 内存优化 的考虑；这里的内存优化是指在 isa 指针中通过 char + 位域（即二进制中每一位均可表示不同的信息）的原理实现。通常来说，isa 指针占用的内存 大小是 8 字节(1字节&#x3D;8位)，即 8*8=64 位，已经足够存储很多的信息了，这样可以极大的 节省内存，以 提高性能。 isa_t源码： 1234567891011121314// 联合体union isa_t &#123; // isa的两种初始化方法 isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; // 提供了 cls 和 bits ，两者是互斥关系 Class cls; // 存储cls信息 uintptr_t bits; // 存储多位的信息#if defined(ISA_BITFIELD) struct &#123; ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125;; 2、从 isa_t 的定义中可以看出： 提供了两个成员，cls 和 bits，由联合体的定义所知，这两个成员是互斥的，也就意味着，当初始化isa指针时，有两种初始化方式： 如果不是 nonpointer，通过 isa_t(uintptr_t value) : bits(value) &#123; &#125;实现初始化 12345// 如果不是nonpointer,初始化isa，返回cls信息if (!nonpointer) &#123; // 初始化isa isa = isa_t((uintptr_t)cls);&#125; 如果是 nonpointer ,通过 isa_t() 初始化 12345678910111213141516171819202122232425262728293031323334// 如果是nonpointer的初始化方式else &#123; ASSERT(!DisableNonpointerIsa); ASSERT(!cls-&gt;instancesRequireRawIsa()); // 初始化isa isa_t newisa(0); // 返回0#if SUPPORT_INDEXED_ISA ASSERT(cls-&gt;classArrayIndex() &gt; 0); newisa.bits = ISA_INDEX_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex(); // 64位走这个地方#else // 赋值bits newisa.bits = ISA_MAGIC_VALUE; // 赋值cxx newisa.has_cxx_dtor = hasCxxDtor; // 赋值类信息 newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;#endif // 赋值isa isa = newisa; &#125; 3、SUPPORT_INDEXED_ISA ：表示 isa_t 中存放的 Class 信息是 Class 的地址，还是一个索引(根据该 索引 可在 类信息表 中查找该类结构地址)。目前接触到的iOS的设备上 SUPPORT_INDEXED_ISA 为 0 ，如下代码: 12345678// 如果不是64位#if __ARM_ARCH_7K__ &gt;= 2 || (__arm64__ &amp;&amp; !__LP64__)# define SUPPORT_INDEXED_ISA 1// 如果是64位#else# define SUPPORT_INDEXED_ISA 0#endif 4、isa_t 还提供了一个结构体定义的 位域 ，用于存储类信息及其他信息，结构体的成员 ISA_BITFIELD ，这是一个宏定义，有两个 架构__arm64__（真机） 和 __x86_64__（macOS/模拟器），以下是它们的一些宏定义，如下图所示： nonpointer：表示是否对 isa 指针 开启指针优化 0：如果没有 nonpointer 就是纯isa指针 1：如果有 nonpointer，不⽌有 类对象地址 ,isa 中包含了 类信息、对象的 引⽤计数 等 has_assoc：关联对象标志位 0没有 1存在 has_cxx_dtor：该对象是否有C++或者 Objc 的析构器,如果有析构函数,则需要做析构逻辑, 如果没有,则可以更快的释放对象 shiftcls: 存储类指针的值。开启指针优化的情况下： 在 __arm64__ 架构中有 33 位⽤来存储 类指针、dealloc 函数 在 __x86_64__ 架构中有 44 位用来存储类指针。 magic：⽤于调试器判断当前对象是 真的对象 还是 没有初始化 的 空间 weakly_referenced：指对象是否被 指向 或者 曾经指向 ⼀个 ARC 的弱变量 如果 有，则在调用 delloc 进行 释放 如果 没有，弱引⽤的对象可以 更快释放。 deallocating：标志对象是否 正在释放 内存 has_sidetable_rc：当对象 引⽤计数⼤于 10 时，则需要借⽤该变量 存储进位 extra_rc：当表示该对象的 引⽤计数值，实际上是引⽤计数值 减 1 如果对象的引⽤计数为 10，那么 extra_rc 为 9。 如果引⽤计数⼤于 10，则需要使⽤到 上⾯ 的 has_sidetable_rc。 针对两种不同平台，其isa的存储情况如图所示： 由上面的分析得出，大部分 自定义的类 都是属于 nonpointer_isa，不光存储了isa，还存储了其他一些 信息。 dealloc释放我们通过 dealloc释 查看 通过 中 dealloc 释放流程： 1、dealloc调用_objc_rootDealloc： 1234// Replaced by NSZombies- (void)dealloc &#123; _objc_rootDealloc(self);&#125; 2、_objc_rootDealloc调用rootDealloc: 12345678void_objc_rootDealloc(id obj)&#123; ASSERT(obj); obj-&gt;rootDealloc();&#125; 3、rootDealloc内部进行一些判断，释放 isa 相关信息： 1234567891011121314151617181920inline voidobjc_object::rootDealloc()&#123; if (isTaggedPointer()) return; // fixme necessary? // isa有nonpointer，更快释放 if (fastpath(isa.nonpointer &amp;&amp; !isa.weakly_referenced &amp;&amp; !isa.has_assoc &amp;&amp; !isa.has_cxx_dtor &amp;&amp; !isa.has_sidetable_rc)) &#123; assert(!sidetable_present()); free(this); &#125; // 没有nonpointer,调用object_dispose else &#123; object_dispose((id)this); &#125;&#125; 4、object_dispose内部调用objc_destructInstance 12345678910id object_dispose(id obj)&#123; if (!obj) return nil; objc_destructInstance(obj); free(obj); return nil;&#125; 5、objc_destructInstance 内部调用 clearDeallocating 清除 1234567891011121314151617181920void *objc_destructInstance(id obj) &#123; if (obj) &#123; // Read all of the flags at once for performance. // 是否有c++/oc析构函数 bool cxx = obj-&gt;hasCxxDtor(); // 是否有关联对象 bool assoc = obj-&gt;hasAssociatedObjects(); // This order is important. // 析构函数 if (cxx) object_cxxDestruct(obj); // 移除关联对象 if (assoc) _object_remove_assocations(obj); // 清除 obj-&gt;clearDeallocating(); &#125; return obj;&#125; 具体细节待完善… isa 和 类关联isa 与 cls 关联 原理 就是 isa 指针中的 shiftcls位域中存储了类信息 ，其中 initInstanceIsa 的过程是将 calloc 指针和当前的 类cls 关联起来，有以下几种验证方式： 【方式一】通过 initIsa 方法中的 newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3验证 【方式二】通过 isa指针 地址与 ISA_MSAK 的值 &amp; 来验证 【方式三】通过 runtime 的方法 object_getClass 验证 【方式四】通过 位运算 验证 【方法一】通过 initIsa 方法中的 newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3验证1、首先通过main中的ZJPerson 断点 –&gt; initInstanceIsa –&gt; initIsa –&gt; 走到else中的 newisa.bits = ISA_MAGIC_VALUE这一行: 2、 通过lldb调试打印 p newisa 初始化的信息: 这时 isa 通过 newisa 进行了初始化，但是还未被赋值 3、往下走一步，走到下一行newisa.has_cxx_dtor = hasCxxDtor ： 继续断点调试，在上一行 newisa.bits = ISA_MAGIC_VALUE 已经为 isa 的 bits 成员赋值，执行lldb命令 p newisa，得到的结果如下: 通过与前一个 newisa 对比我们发现，isa 指针中有一些变化，如下图所示： 赋值 bits 会对 cls 进行追加 0x001d800000000001 默认值 赋值 bits 里面的 ISA_BITFIELD 宏中所有的信息】 nonpointer = 1，代表是nonpointer magic = 59 ，为什么呢？往下看 4、打开 计算器 我们查看一下 16 进制 0x001d800000000001 转化为 二进制，和 10进制59 转化为二进制，进行对比一下： 由对比可知，0x001d800000000001转化为二进制 ，从 47（因为前面有4个位域，共占用46位） 位开始往后数6位是 110111； 和 10 进制 magic = 59 转换成二进制，从 0 开始 往后数 6 位的 值相等； 5、继续往下执行断点到newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3： shiftcls 存的是 类的信息 cls 是 ZJPerson 进行 编码 之后往 右移3位 1234(lldb) p (uintptr_t)cls(uintptr_t) $2 = 4294975720(lldb) p $2 &gt;&gt; 3(uintptr_t) $3 = 536871965 6、继续往下走一到 执行断点到isa = newisa： 我们通过 lldb 调试一下 newisa： 我们看到 cls = ZJPerson，而 shiftcls = 536871965 与 上面的 $3 = 536871965 刚好吻合 7、最后用一张图来表示一下具体流程: 8、为什么在shiftcls赋值时需要类型强转？ 因为内存的存储不能存储字符串，机器码 只能识别 0 、1 这两种数字，所以需要将其转换为 uintptr_t 数据类型，这样 shiftcls 中存储的类信息才能被 机器码理解， 其中 uintptr_t 是long 9、为什么需要右移3位？ 主要是由于 shiftcls 处于 isa 指针地址的 中间 部分，前面还有 3 个位域，为了不影响前面的3个位域的数据，需要 右移 将其 抹零。 【方法二】：通过 isa 指针地址与 ISA_MSAK 的值 &amp; 来验证1、在方法一执行完后，回到 _class_createInstanceFromZone中，此时 isa 与 cls 已经关联完成，我们走到下面这个方法，打上断点： 2、执行 po obj,输出对应的值，再执行 x/4gx 0x10181ba70 得到 isa 指针的地址 0x001d8001000020e9,将 isa 指针地址 &amp; ISA_MASK ，即 po 0x001d8001000020e9 &amp; 0x0000000ffffffff8ULL 或 po 0x001d8001000020e9 &amp; 0x00007ffffffffff8ULL ，得出 ZJPerson __arm64__中，ISA_MASK 宏定义的值为 0x0000000ffffffff8ULL __x86_64__中，ISA_MASK 宏定义的值为 0x00007ffffffffff8ULL 【方法三】：通过 object_getClass通过查看 object_getClass 的源码实现，同样可以验证 isa 与 类 关联的原理，有以下几步： 1、main中导入#import &lt;objc/runtime.h&gt; 2、通过 runtime 的 api，即 object_getClass 函数获取类信息 1object_getClass(&lt;#id _Nullable obj#&gt;) 3、查看object_getClass函数 源码的实现 4、点击进入object_getClass 底层实现 5、点击getIsa 进入查看底层实现: 6、点击 ISA 进入查看底层实现，可以看到如果是 SUPPORT_INDEXED_ISA 类型，执行 if 流程，反之 执行的是 else 流程，我们这里走的是 else: 在else流程中，拿到 isa 的 bits 这个位，再 &amp; ISA_MASK，这与方式二中的原理是一致的，获得当前的类信息 从这里也可以得出 isa 与 cls 已经完美关联 【方法四】：通过位运算1、回到 _class_createInstanceFromZone 方法。通过 x/4gx obj 得到 obj的 内存分布情况 ，当前类的信息存储在 isa 指针中，且 isa 中的 shiftcls 此时占 44 位（因为处于macOS环境） 2、想要读取中间的 44 位 类信息(shiftcls)，就需要经过 位运算 ，将 右边3位，和 左边17 位 除去，44位以外 的部分都 抹零，其 相对位置是不变的。其位运算过程如图所示，其中shiftcls即为需要读取的类信息： **3、将isa地址右移3位：p/x 0x001d8001000020e9 &gt;&gt; 3 ，得到0x0003b0002000041d ** 在将得到的 0x0003b0002000041d 左移20位：p/x 0x0003b0002000041d &lt;&lt; 20 ,得到 0x0002000041d00000 为什么是左移20位？因为先右移了3位，相当于向右偏移了3位，而左边需要抹零的位数有17位，所以一共需要移动20位 将得到的0x0002000041d00000 再右移17位：p/x 0x0002000041d00000 &gt;&gt; 17 得到新的0x00000001000020e8 获取cls的地址 与 上面的进行验证 ：p/x cls 也得出0x00000001000020e8，所以由此可以证明 isa 与 cls 是关联的 4、为什么右移3位，左移20位，再右移17位？ 因为 initIsa（初始化isa） 传入的是 cls（即ZJPerson），只有中间 shiftcls 才 存储着类的信息 ，在 __x86_64__ 架构是 44 位，在 __arm64__ 架构是 33 位，只有在 33位/44位 才存 储着类信息，当右移3位，左移20位，再右移17位，相当于复位，不足64位 系统 自动帮我们 用0补全。 isa返回Class类型的验证1、我们在前面探索了 对象 的 本质 是 结构体，它的第一个 属性 是 继承 自 NSObject 的 isa 是 Class 类型的，而后面我们通过【方法三】object_getClass 验证 isa 与 cls 关联流程得知， isa 是 isa_t 类型的: 2、那么为什么我们在 外层 得到的是 Class 的 isa 呢? 我们其实在上面的【方法三】，已经验证了其原因，看源码 return (Class)(isa.bits &amp; ISA_MASK); 这一句代码将其 强转 为 Class 类型提供给外层使用。","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理07：malloc源码探索","slug":"OC进阶/OC底层原理07：malloc源码探索","date":"2020-09-15T18:06:06.000Z","updated":"2022-04-21T09:34:17.000Z","comments":true,"path":"2020/09/16/OC进阶/OC底层原理07：malloc源码探索/","link":"","permalink":"https://www.bboyzj.cn/2020/09/16/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8607%EF%BC%9Amalloc%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"前言我们在 OC底层原理03：alloc&amp;init&amp;new探索 文章中，分别得知alloc最核心的三个操作： 第一个核心方法：cls-&gt;instanceSize,我们得知是申请内存大小，系统默认是 16 字节对齐。 第二个核心方法：calloc，即申请内存，即今天要 探索 的内容，其实探索的本质也是为了验证ios中对象中实际的对齐方式是 8 字节对齐 objc4中分析calloc 源码由 OC底层原理03：alloc&amp;init&amp;new探索 文章中可知，obj = (id)calloc(1, size)调用的源码不在objc4中，如下图： 实际上 calloc 的源码需要查看 libmalloc源码 中，可以在 这里 下载最新版，然后去探索 libmalloc中分析calloc源码1、第一步:在main中使用 calloc 创建一个指针 2、第二步：进入 calloc 的源码实现，其中的关键代码是 malloc_zone_calloc 其中 default_zone 是 malloc_zone_t 类型： 1static malloc_zone_t *default_zone = &amp;virtual_default_zone.malloc_zone; 3、第三步:进入 malloc_zone_calloc 的源码实现，其中关键代码是 zone-&gt;calloc 到这里，我们点击 calloc 发现，找不到下面要执行的源码了，我们通过终端 p zone-&gt;calloc 去查看一下底层调用： 由此可发现，内部起始调用的是 default_zone_calloc 4、第四步:断点调试查看 default_zone_calloc 内部源码 与上面一样，终端 p zone-&gt;calloc 去查看一下底层调用： 由此可发现，内部起始调用的是 nano_calloc 5、第五步:断点调试查看 nano_calloc 内部源码 如果要开辟的空间小于 NANO_MAX_SIZE 则进行，我们通过断点调试，发现执行的是这个流程 否则就进行 helper_zone 的流程 6、第六步:点进 _nano_malloc_check_clear 查看内部源码 7、第七步：点进关键代码 segregated_size_to_fit 查看源码 由上面的图，我们可以得知 size 为传入 24 ，但是最后返回的 slot_bytes 实际上是 32，说明是 16 位的倍数，计算方法图上已经说明 8、第八步：如果是第一次调用 segregated_next_block 函数，band 不存在，缓存也不会存在，所以会调用segregated_band_grow。来开辟新的 band","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理06：内存对齐探索","slug":"OC进阶/OC底层原理06：内存对齐探索","date":"2020-09-13T18:05:22.000Z","updated":"2022-04-21T09:18:18.000Z","comments":true,"path":"2020/09/14/OC进阶/OC底层原理06：内存对齐探索/","link":"","permalink":"https://www.bboyzj.cn/2020/09/14/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8606%EF%BC%9A%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"查看内存地址的方法1、【方法一】：Debug-&gt;Debug Workflow-&gt;Alway View Memory 2、【方法二】：x 地址&#x2F;x 对象 1）下面我们通过代码具体查看一下使用： 123456789101112@interface ZJPerson : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) int age;@end// 内存对齐ZJPerson * p = [ZJPerson alloc];p.name = @&quot;ZJ&quot;; // NSStringp.age = 30; // int NSLog(@&quot;%@&quot;,p); 2）通过LLDB编译命令查看内存情况： x 0x100867a60 ：以16进制打印当前地址的内存情况，查看不方便 x/4gx 0x100867a60：以16进制形式打印4个地址，查看方便 0x100867a60 ： 内存地址 0x001d80010000220d：isa 0x000000000000001e：30 0x0000000100001010：ZJ 3）那么 0x100867a60、0x102038770 和 0x001d80010000220d 0x000000000000001e 0x0000000100001010 0x0000000000000000有什么关系呢？我们用一张图来表示一下： 4）如果有一个 double/float 类型的 height 呢？ 我们来分析一下： 123@property (nonatomic, assign) double height;p.height = 170; // double 通过 x/4gx p 查看打印的结果: 12(lldb) po 0x40654000000000004640185359819341824 我们发现竟然没有打印170，这是为什么呢？ 原因：16进制和double/float类型的转换验证： 12(lldb) p/x (double)170(double) $7 = 0x4065400000000000 我们可以得到和上面的地址一抹抹一样样，还有谁? 5）从打印结果我们可以看出一个问题，两个属性占用内存不是按照定义属性的顺序，这是为什么呢？其实这就是 iOS中的内存字节对齐现象 内存对齐的原因对于大部分程序员来说，内存对齐 对他们来说都应该是 透明的。 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问 未对齐 的内存，处理器需要作 两次 内存访问；而 对齐 的内存 访问 仅需要 一次 访问。 内存对齐三大原则每个特定平台上的编译器都有自己的默认 “对齐系数”(也叫对齐模数)。程序员可以通过预编译命令#pragma pack(n)，n&#x3D;1,2,4,8,16来改变这一系数，其中的n就是你要指定的 “对齐系数”。在 ios 中，Xcode默认为 #pragma pack(8)，即 8字节对齐 数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset 为0的地方，以后每个数据成员存储的起始位置要从该成员的大小或子成员大小的整数倍开始存储（比如 int 为4字节，那么他的起始位置则为 4*n ） 结构体作为成员:如果⼀个结构⾥有某些结构体成员,则结构体成员要从其内部最⼤元素⼤⼩的整数倍地址开始存储.(struct a ⾥存有 struct b ,b ⾥有char,int ,double等元素,那 b 应该从 8 的整数倍开始存储.) 结构体总体大小，必须是其内部最大成员的整数倍，不足要补齐 数据类型所占字节 获取内存的三个方法 sizeof 是运算符，编译的时候就替换为常数，返回的是 一个类型所占内存的大小 class_getInstanceSize 传入一个类对象，返回 一个对象的实例至少需要多少内存,它等价于sizeof，需要导入#import &lt;objc/runtime.h&gt; malloc_size返回 系统实际分配的内存大小，需要导入#import &lt;malloc/malloc.h&gt; 对象属性内存对齐1、首先通过一个类的内存段来分析 2、然后我们下断点，分析一下对象的内存情况 po p：查看当前的对象信息&lt;ZJPerson: 0x60000072f870&gt; ZJPerson为当前的类，0x60000072f870 为当前对象的 首地址 iOS为 小端 模式,内存要 倒着读，即 0x0000 0001 0950 2730,不足16位要补0，而 0x0000 000109502730 是指针 isa ，指向内存的首地址 0x60000072f870 x p：意思是查看这个地址的内存情况，即内存段 由于小端模式不好读取，所以我们用一个命令自动帮我们整理好 x/6gx 等等 x/6xg p：意思就是按照16进制,以6整段打印当前p对象 我们发现OC为我们做了一些优化,我们发现0x0000001200006261这个内存段存储了age,char1,char2,三个属性 我们 po 0x00000012 打印 30,也就是我们的 age 属性值 po 0x61 0x62 打印的分别为 97 98 也就是我们 a和b对应的ASCII 码 3、为什么 age、c1、c2 三个属性放在一个 8字节 内存中呢? iOS系统不是对每一个属性都开辟8个字节内存空间，如果每一个属性都开辟8个字节，会造成内存浪费iOS系统通过内存对齐方式，对 属性重排，内存优化 ， 结构体内存对齐 结构体指针的内存大小8 结构体大小根据内部大小来计算 我们都知道 对象 的 本质 是 结构体 ，因此 对象 的 内存对齐 来自 结构体 ，因此接下来我们分析一下机构体是如何内存对齐的： 1、struct1 1234567891011// 普通结构体struct ZJStruct1 &#123; double a; // 占8个字节 起始位置(0-7) char b; // 占1个字节 8是1的整数倍[8 1] 起始位置(8) int c; // 占4个字节 9不是4的整数倍，往下找[9 4] 9 10 11 起始位置(12 13 14 15) short d; // 占2个字节 16是2的整数倍[16 2] 起始位置(16 17)&#125;struct1;// 内部需要的大小为: 17个字节// 最大属性 : 8个字节// 结构体整数倍: 最大成员的整数倍 8*3 = 24个字节 我们通过图来分析一下struct1的内存存储情况： 根据内存对齐规则，分析ZJStruct1的内存计算： 变量a：占8个字节，从0开始，此时 0 存储 a 变量b：占1个字节，从8开始，此时8可以整除8，即 8-15 存储 b 变量c：占4个字节，从9开始，此时9不可以整除8，往后移动到12，12可以整除4，即 12-15 存储 c 变量d：占2个字节，从16开始，此时16可以整除2，即 16-17 存储 d 因此ZJStruct1的需要的内存大小为 18 字节，而ZJStruct1中最大变量的字节数为 8，所以 ZJStruct1 实际的内存大小必须是 8 的整数倍，18 向上取整到 24，主要是因为 24 是 8 的整数倍，所以 sizeof(ZJStruct1) 的结果是 24 2、struct2 123456789101112// 普通结构体struct ZJStruct2 &#123; char a; //占1个字节 起始位置(0) int b; //占4个字节 1不是4的整数倍 起始位置(4~7) short c; //占2个字节 8是2的倍数，起始位置(8 9) double c; //占8个字节 10不是8的倍数 起始位置(16~23) &#125;struct2;// 内部需要的大小为：23个字节// 最大属性：8个字节// 结构体整数倍：8*3 = 24个字节 我们通过图来分析一下struct1的内存存储情况： 根据内存对齐规则，分析ZJStruct2的内存计算： 变量a：占1个字节，从0开始，此时 0 存储 a 变量b：占4个字节，从1开始，此时1不可以整除4，往后移动到4，此时4可以整除4，即 4-7 存储 b 变量c：占2个字节，从8开始，此时8可以整除2，即 8-9 存储 c 变量d：占8个字节，从10开始，此时10不可以整除2，往后移动到16，16可以整除8，即 16-23 存储 d 因此 ZJStruct2 的需要的内存大小为 24 字节，而ZJStruct1中最大变量的字节数为 8，所以 ZJStruct1 实际的内存大小必须是 8 的整数倍，24 向上取整到 24，主要是因为 24 是 8 的整数倍，所以 sizeof(ZJStruct2) 的结果是 24 3、struct3 12345678910111213141516// 嵌套结构体struct ZJStruct3 &#123; char a; //占1个字节 int b; //占4个字节 short c; //占2个字节&#125;struct3;struct ZJStruct4 &#123; double a; //占8个字节 起始位置(0~7) int b; //占4个字节 8是4的整数倍[8 4] 起始位置(8 9 10 11) struct ZJStruct3 s3; // char(12) int(16,17,18,19) short(20,21) 结构体内部要对齐（4*3=12）补22,23 short c; //占2个字节 24是2的整数倍 (24,25)&#125;struct4;// 内部需要的大小：25个字节// 最大属性：8个字节// 结构体整数倍：8*4 = 32个字节 我们通过图来分析一下struct3的内存存储情况： 根据内存对齐规则，分析ZJStruct3的内存计算： 变量a：占8个字节，从0开始，此时 0-7 存储 a 变量b：占4个字节，从8开始，此时8可以整除4，即 8-11 存储 b 结构体成员s1：s1是一个结构体，根据内存对齐原则二，结构体成员要从其内部最大成员大小的整数倍开始存储，而ZJStruct3中最大的成员大小为4，所以s3要从4的整数倍开始，当前是从12开始，所以符合要求，12是4的整数倍，符合内存对齐原则，所以 12开始 变量a：占1个字节，从12开始，此时12可以整除4，即 12 存储 a 变量b：占4个字节，从13开始，此时13不可以整除4，往后移动到16，此时16可以整除4，即 16-19 存储 b 变量c：占2个字节，从20开始，20可以整除2，即 20-21 存储 c 由于结构体内部的字节对齐原则4的整数倍，后面要补上22，23，此时12-23正好是4的整数倍，即4*3 变量c：占2个字节，从24开始，24可以整除2，即 24-25 存储 c 因此ZJStruct4的需要的内存大小为 26 字节，而ZJStruct4中最大变量的字节数为 8，所以 ZJStruct4 实际的内存大小必须是 8 的整数倍，26 向上取整到 32，主要是因为 32 是 8 的整数倍，所以 sizeof(ZJStruct4) 的结果是 32 4、我们通过上面的分析来实际验证一下结果： 12345// 打印结构体内存大小NSLog(@&quot;%lu-%lu-%lu-%lu&quot;,sizeof(struct1),sizeof(struct2),sizeof(struct4),sizeof(struct4.s3)); *******打印结果******2020-09-15 20:23:52.275929+0800 001-内存对齐原则[25197:515659] 24-16-32-12 结果显示我们分析的结果是正确的 内存优化（属性重排） 如果是结构体中数据成员是根据内存 从小到大的顺序定义 的，根据内存对齐规则来计算结构体内存大小，需要增加有较大的内存padding即内存占位符，才能满足内存对齐规则，比较 浪费内存 如果是结构体中数据成员是根据内存 从大到小的顺序定义 的，根据内存对齐规则来计算结构体内存大小，我们只需要补齐少量内存padding即可满足堆存对齐规则，这种方式就是苹果中采用的，利用 空间换时间 ，将类中的属性进行重排，来达到优化内存的目的 以下面这个例子来进行说明 苹果中属性重排，即内存优化： 1、我们通过自定义一个类ZJPerson，并定义几个属性，来分析一下 12345678@interface ZJPerson : NSObject@property (nonatomic, copy) NSString * name;@property (nonatomic, copy) NSString *nickName;@property (nonatomic, assign) int age;@property (nonatomic, assign) long height;@property (nonatomic) char c1;@property (nonatomic) char c2;@end 2、在main中创建ZJPerson的实例对象，并对其中的几个属性赋值 12345678910111213141516171819202122232425#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;#import &lt;malloc/malloc.h&gt;#import &quot;ZJPerson.h&quot;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... // 对象的内存对齐 - 对象的内存对齐来自结构体 ZJPerson * p = [ZJPerson alloc]; //占8字节 p.name = @&quot;ZJ&quot;; //占8个字节 p.nickName = @&quot;小J&quot;; //占8个字节 p.age = 30; //占4个字节 p.c1 = &#x27;a&#x27;; //占1个字节 p.c2 = &#x27;b&#x27;; //占1个字节 NSLog(@&quot;%@ - %lu - %lu - %lu&quot;,p,sizeof(p),class_getInstanceSize([p class]),malloc_size((__bridge const void *)(p))); &#125; return 0;&#125;********打印结果******2020-09-13 23:48:30.357717+0800 KCObjc[84742:2078708] &lt;ZJPerson: 0x100660120&gt; - 8 - 40 - 48 3、断点调试p，根据ZJPerson的对象地址，查找出属性的值： 当我们向通过 0x0000001e00006261 地址找出 age 等数据时，发现是 乱码，这里无法找出值的原因是苹果中针对 age、c1、c2 属性的内存进行了重排，因为 age 类型占 4 个字节，c1 和 c2 类型 char 分别占 1 个字节，通过 4+1+1 的方式，按照 8 字节对齐，不足补齐的方式存储在同一块内存中 我们通过po 0x000000010d671058找出name的值ZJ，通过po 0x000000010d671078找出nickName的值小J 4、所以，这里可以总结下苹果中的内存对齐思想： 大部分的内存都是通过固定的内存块进行读取，尽管我们在内存中采用了内存对齐的方式，但并不是所有的内存都可以进行浪费的，苹果会自动 对属性进行重排，以此来 优化内存 字节对齐到底采用多少字节对齐？到目前为止，我们在前文既提到了 8 字节对齐，也提及了 16 字节对齐，那我们到底采用哪种字节对齐呢？ 我们可以通过 objc4 中的源码来进行分析 1、实例对象开辟内存的流程如下： 1）class_getInstanceSize内部实现如下: 1234567891011/** * Returns the size of instances of a class. * * @param cls A class object. * * @return The size in bytes of instances of the class \\e cls, or \\c 0 if \\e cls is \\c Nil. */OBJC_EXPORT size_tclass_getInstanceSize(Class _Nullable cls) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); class_getInstanceSize内部调用alignedInstanceSize 1234// Class&#x27;s ivar size rounded up to a pointer-size boundary. uint32_t alignedInstanceSize() const &#123; return word_align(unalignedInstanceSize()); &#125; word_align内部调用如下： 12345678910111213#ifdef __LP64__# define WORD_SHIFT 3UL# define WORD_MASK 7UL# define WORD_BITS 64#else# define WORD_SHIFT 2UL# define WORD_MASK 3UL# define WORD_BITS 32#endifstatic inline uint32_t word_align(uint32_t x) &#123; return (x + WORD_MASK) &amp; ~WORD_MASK;&#125; 由源码可知：(x + WORD_MASK) &amp; ~WORD_MASK是一个运算，代表 8 字节对齐 2、为什么对象真正开辟内存是8字节对齐？系统为对象开辟的是16字节对齐? apple系统为了 防止一切的容错，采用的是 16 字节对齐的内存，主要是因为采用 8 字节对齐时，两个对象的内存会紧挨着，显得 比较紧凑，而 16 字节 比较宽松，利于苹果以后的扩展。 8字节内存计算由断点可知此时的x为40，WORD_MASK为7，我们来计算一下：(x + WORD_MASK) &amp; ~WORD_MASK 1234567891011121314152^5 = 32 2^4 = 16 2^3 = 8 2^2 = 4 2^1 = 2 2^0 = 140 + 7 = 47 = 32 + 8 + 4 + 2 + 1 16进制表示0000 0000 0010 1111 70000 0000 0000 01117取反~1111 1111 1111 1000 47 &amp; ~70000 0000 0010 11111111 1111 1111 1000-----------------------0000 0000 0010 1000 = 40 由结果40可知，与class_getInstanceSize获取实例对象的大小40如何吻合，还有谁？ 总结 class_getInstanceSize：是采用 8 字节对齐，参照的对象的属性内存大小 malloc_size：采用 16 字节对齐，参照的整个对象的内存大小，对象实际分配的内存大小必须是 16 的整数倍","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理05：objc_alloc探索","slug":"OC进阶/OC底层原理05：objc-alloc探索","date":"2020-09-11T18:04:27.000Z","updated":"2022-04-21T08:50:42.000Z","comments":true,"path":"2020/09/12/OC进阶/OC底层原理05：objc-alloc探索/","link":"","permalink":"https://www.bboyzj.cn/2020/09/12/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8605%EF%BC%9Aobjc-alloc%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"前言本章主要探索继承自 NSObject 的类 ZJPerson 和 NSObject 调用 alloc 的区别 准备工作1、下载objc4-781源码。 2、编译源码，可参考iOS-OC底层原理02：Objc4源码编译 NSObject调用alloc探索1、第一步：在main函数中实现下面的代码，并下断点： 2、第二步：到源码下断点到 + (id)alloc，先 取消断点，等程序运行到目标行在去跟踪断点，原因在前面查找源码已经讲过，在此不在说明： 我们发现并没有进来，我滴天呐，说明调用的不是 alloc 3、第三步：我们换一种方式去查看源码，打开Debug-&gt;Debug WorkFlow-&gt;Debug-&gt;Debug Workflow-&gt;Alway Show Disassembly查看汇编： 我们发现底层源码调用的是 objc_alloc ，到底是不是呢？接下来我们 二次验证 一下 **4、第四步:二次验证-&gt;先取消Debug查看方式，到源码中下断点到 objc_alloc ** 我们发现 Class cls 这个类确实是 NSObject ,验证了我们上面的调用过程 5、第五步：继续往下走，callAlloc 内部调用流程 我们发现 callAlloc 内部最终调用的是 _objc_rootAllocWithZone 最终和iOS-OC底层原理03：alloc&amp;init&amp;new探索alloc调用流程不谋而合 6、结论：我们用流程图去表达一下调用流程 继承类ZPerson调用alloc真实调用流程1、第一步：在 main 函数中实现 ZJPerson 类的 alloc 方法进入alloc方法，并下断点： 2、第二步：打开 Debug-&gt;Debug WorkFlow-&gt;Debug-&gt;Debug Workflow-&gt;Alway Show Disassembly 查看汇编： 3、第三步：通过在源码中下断点 objc_alloc 和 alloc 去跟踪具体先执行过程： 1234567跳转至objc_alloc的源码实现// Calls [cls alloc].idobjc_alloc(Class cls)&#123; return callAlloc(cls, true/*checkNil*/, false/*allocWithZone*/);&#125; 4、第四步：跳转至 callAlloc 的源码实现 12345678910111213141516171819202122// Call [cls alloc] or [cls allocWithZone:nil], with appropriate // shortcutting optimizations.static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false)&#123;#if __OBJC2__ // checkNil:true if (slowpath(checkNil &amp;&amp; !cls)) return nil; if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123; // cls NSObject return _objc_rootAllocWithZone(cls, nil); &#125;#endif // No shortcuts available. // allocWithZone : false if (allocWithZone) &#123; return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil); &#125; return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));&#125; 5、第五步：跳转至 return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc)); 的内部源码实现 12objc_msgSend(void /* id self, SEL op, ... */ ) OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 系统通过特殊消息发送：sel - imp 做了一层处理，最终执行到 alloc，根本就是系统通过LLVM特殊消息发送做的处理，有兴趣的小伙伴可以通过LLVM源码去探索一下 6、第六步：跳转至 alloc 源码实现 123+ (id)alloc &#123; return _objc_rootAlloc(self);&#125; 7、第七步：跳转至 _objc_rootAlloc 源码实现，我们可以验证 cls 是ZJPerson 8、第八步：跳转至 _objc_rootAllocWithZone 源码实现 123456789101112131415161718192021// Call [cls alloc] or [cls allocWithZone:nil], with appropriate // shortcutting optimizations.static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false)&#123;#if __OBJC2__ // checkNil:true if (slowpath(checkNil &amp;&amp; !cls)) return nil; if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123; // cls NSObject return _objc_rootAllocWithZone(cls, nil); &#125;#endif // No shortcuts available. // allocWithZone : false if (allocWithZone) &#123; return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil); &#125; return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));&#125; 9、第九步：跳转至 _class_createInstanceFromZone 源码实现 12345678NEVER_INLINEid_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)&#123; // allocWithZone under __OBJC2__ ignores the zone parameter return _class_createInstanceFromZone(cls, 0, nil, OBJECT_CONSTRUCT_CALL_BADALLOC);&#125; 10、第十步：内部调用 cls-&gt;instanceSize、calloc、obj-&gt;initInstanceIsa(cls, hasCxxDtor)、return obj 方法返回对象，具体流程不再赘述 11、总结:ZJPerson的alloc调用流程图: ZJPerson的alloc和NSObject的alloc区别 ZJPerson 会走两次 objc_alloc -&gt; alloc NSObject 只走一次 objc_alloc","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理04：Optimization-Level-优化等级","slug":"OC进阶/OC底层原理04：Optimization-Level-优化等级","date":"2020-09-08T17:30:34.000Z","updated":"2022-04-21T09:25:29.000Z","comments":true,"path":"2020/09/09/OC进阶/OC底层原理04：Optimization-Level-优化等级/","link":"","permalink":"https://www.bboyzj.cn/2020/09/09/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8604%EF%BC%9AOptimization-Level-%E4%BC%98%E5%8C%96%E7%AD%89%E7%BA%A7/","excerpt":"","text":"前言Optimization Level 是编译器的优化程度。比较早期的时候，硬件资源是比较缺乏的。为了 提高性能，开发编译器的大师们，都会对编译器(从c到汇编的编译过程)加上一定的优化策略。优化后的代码效率比较高，但是可读性比较差，且编译时间更长。 Optimization Level下面我用一张截图表示设置的位置 编译器优化设置在target-&gt;Build Settings-&gt;Optimization Level下,如图: 1）主要有两种模式Debug和Release Debug下默认是关闭 默认是 None[-O0] Release模式下，编译器也会自动优化一些代码,这样生成的程序性能是最优的。默认是 Fastest,Smallest[-Os] 2）Optimization Level可以设置代码的优化等级。 None：不优化。[-O0]与此设置,编译器的目标是降低成本的编译和调试产生预期的结果。语句是独立的:如果你停止程序语句之间有一个断点,然后您可以指定一个新值的任何变量或任何其他声明改变程序计数器的功能和得到你期望的结果从源代码。 Fast：优化编译需要更多的时间,和更多的内存大的功能。[-O,O1]与此设置,编译器试图减少代码大小和执行时间,没有执行任何优化,需要大量的编译时间。在苹果的编译器,严格的混叠,阻挡重新排序,并内嵌调度优化时默认是禁用的。 Faster：编译器执行几乎所有支持优化,不涉及space-speed权衡。[-O2]与此设置,编译器不执行循环展开或内联函数,或寄存器重命名。相比“快速”的设置,该设置增加编译时间和生成的代码的性能。 Fastest：打开 更快 指定的优化设置,也取决于函数内联和寄存器重命名选项。此设置可能会导致一个更大的二进制。 Fastest [-O3]：最小的优化尺寸。这个设置允许所有 更快 的优化通常不增加代码大小。它还旨在减少代码的大小进行进一步的优化。 通过下面的代码我们来探索一下 我们可以通过下图方式去切换Debug和Release模式运行在真机： 1、在真机Debug模式下运行，查看堆栈信息 注:x代表的是arm64操作系统，w代表的是arm32位操作系统，为了节省资源，所以在真机下用的是arm32为w来存储数据 我们通过LLDB调试具体打印： 12345678910111213warning: failed to set breakpoint site at 0x104336290 for breakpoint 3.1: error: 0 sending the breakpoint request(lldb) po 0xa10(lldb) po 0x1420(lldb) register read w8 w8 = 0x0000001e(lldb) po 0x0000001e30(lldb) po(print object): 常用于查看对象信息 register read：读取所有寄存器值 2、在真机Release模式下运行，查看堆栈信息 我们来读取一下寄存器中的数据： 123456(lldb) register read w8 w8 = 0x0000001e(lldb) po 0x0000001e30(lldb) 3、Debug和Release的区别： 行数上看，debug是28行，release是14行，差距很大,这当然是编译器优化的结果。 debug版在0x104a725b8在调用NSLog之前做了好多多余动作，往返访问xmm寄存器。而release版都是立即数，没有做多余的动作。 4、编译器优化作用 将变量存储到寄存器中，提高读取速度，进而提高性能。","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理03：alloc&init&new探索","slug":"OC进阶/OC底层原理03：alloc&init&new源码分析","date":"2020-09-06T17:05:36.000Z","updated":"2022-11-01T09:29:16.000Z","comments":true,"path":"2020/09/07/OC进阶/OC底层原理03：alloc&init&new源码分析/","link":"","permalink":"https://www.bboyzj.cn/2020/09/07/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8603%EF%BC%9Aalloc&init&new%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"前言 在分析alloc&amp;init&amp;new源码之前，我们先来看看下面的代码： 1234567891011121314- (void)viewDidLoad &#123; [super viewDidLoad]; // 熟悉的入手 - 对象 // alloc 做了什么？ // init 做了什么？ ZJPerson *p1 = [ZJPerson alloc]; ZJPerson *p2 = [p1 init]; ZJPerson *p3 = [p1 init]; ZJNSLog(@&quot;%@ - %p - %p&quot;,p1,p1,&amp;p1); ZJNSLog(@&quot;%@ - %p - %p&quot;,p2,p2,&amp;p2); ZJNSLog(@&quot;%@ - %p - %p&quot;,p3,p3,&amp;p3);&#125; 查看打印结果，分别输出3个对象的内容、内存地址、指针地址： 123&lt;ZJPerson: 0x600001316130&gt; - 0x600001316130 - 0x7ffee10e6188&lt;ZJPerson: 0x600001316130&gt; - 0x600001316130 - 0x7ffee10e6180&lt;ZJPerson: 0x600001316130&gt; - 0x600001316130 - 0x7ffee10e6178 由上述打印结果，我们可以知道： p1,p2,p3对象 的 内存地址 是相同的 返回的 指针变量p1,p2,p3 指向对象的 内存地址 也是相同的 而 指针p的地址&amp;p 是不同的 结论： 说明 alloc开辟了内存空间，而 init没有开辟内存空间 p1,p2,p3指针变量指向了同一个内存空间ZJPerson 下面用一张图说明一下: 这就是本文需要探索的内容，alloc做了什么？init做了什么？，alloc&amp;init&amp;new到底干了什么? 准备工作1、下载 objc4-781 源码 2、编译源码，可参考iOS-OC底层原理02：Objc4源码编译 alloc源码探索1、 创建一个ZJPerson自定义类，来分析一下底层调用流程 2、跟踪alloc调用流程 通过断点调试alloc调用_objc_rootAlloc 123+ (id)alloc &#123; return _objc_rootAlloc(self);&#125; 通过断点调试_objc_rootAlloc调用callAlloc 1234_objc_rootAlloc(Class cls)&#123; return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);&#125; 通过断点调试callAlloc调用_objc_rootAllocWithZone 1234567891011121314151617181920static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false)// alloc 源码 第三步&#123;#if __OBJC2__ //有可用的编译器优化 // checkNil 为false，!cls 也为false ，所以slowpath 为 false，假值判断不会走到if里面，即不会返回nil if (slowpath(checkNil &amp;&amp; !cls)) return nil; //hasCustomAWZ实际意义是hasCustomAllocWithZone——这里表示有没有alloc / allocWithZone的实现 if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123; //继承自NSObject/NSProxy的类才能走到这里，在oc中基本都继承自这两个类 return _objc_rootAllocWithZone(cls, nil); &#125;#endif // No shortcuts available. // 没有可用的编译器优化 if (allocWithZone) &#123; return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil); &#125; return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));&#125; 这里补充一下cls-&gt;ISA()-&gt;hasCustomAWZ()是什么意思呢？ 其中fastpath中的 cls-&gt;ISA()-&gt;hasCustomAWZ() 这里表示hasCustomAWZ实际意义是hasCustomAllocWithZone——这里表示有没有alloc &#x2F; allocWithZone的实现（只有不是继承NSObject&#x2F;NSProxy的类才为true），这里通过断点调试，是没有自定义的实现，所以会执行到 if 里面的代码，即走到 _objc_rootAllocWithZone 这里补充一下 slowpath &amp; fastpath 是什么？ 其中关于slowpath和fastpath这里需要简要说明下，这两个都是objc源码中定义的宏，其定义如下： 1234// x很可能为真， fastpath 可以简称为 真值判断#define fastpath(x) (__builtin_expect(bool(x), 1)) // x很可能为假，slowpath 可以简称为 假值判断#define slowpath(x) (__builtin_expect(bool(x), 0)) 其中的__builtin_expect指令是由gcc引入的， 1234567891011目的：编译器可以对代码进行优化，以减少指令跳转带来的性能下降。即性能优化作用：允许程序员将最有可能执行的分支告诉编译器。指令的写法为：`__builtin_expect(EXP, N)`。表示 EXP==N的概率很大。fastpath定义中__builtin_expect((x),1)表示 x 的值为真的可能性更大；即 执行if 里面语句的机会更大slowpath定义中的__builtin_expect((x),0)表示 x 的值为假的可能性更大。即执行 else 里面语句的机会更大在日常的开发中，也可以通过设置来优化编译器，达到性能优化的目的，设置的路径为：`Build Setting --&gt; Optimization Level --&gt; Debug --&gt;` 将None 改为 fastest 或者 smallest，即编译器优化 通过断点调试_objc_rootAllocWithZone调用_class_createInstanceFromZone 123456_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)&#123; // allocWithZone under __OBJC2__ ignores the zone parameter return _class_createInstanceFromZone(cls, 0, nil, OBJECT_CONSTRUCT_CALL_BADALLOC);&#125; 通过断点调试_class_createInstanceFromZone内部调用cls-&gt;instanceSize、calloc、obj-&gt;initInstanceIsa，最后返回对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, int construct_flags = OBJECT_CONSTRUCT_NONE, bool cxxConstruct = true, size_t *outAllocatedSize = nil)&#123; ASSERT(cls-&gt;isRealized()); // Read class&#x27;s info bits all at once for performance // hasCxxCtor()是判断当前class或者superclass是否有.cxx_construct 构造方法的实现 bool hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor(); // hasCxxDtor()是判断判断当前class或者superclass是否有.cxx_destruct 析构方法的实现 bool hasCxxDtor = cls-&gt;hasCxxDtor(); // canAllocNonpointer()是具体标记某个类是否支持优化的isa bool fast = cls-&gt;canAllocNonpointer(); size_t size; //1.返回开辟内存大小 size = cls-&gt;instanceSize(extraBytes); if (outAllocatedSize) *outAllocatedSize = size; id obj; if (zone) &#123; obj = (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size); &#125; else &#123; //2.开辟内存 obj = (id)calloc(1, size); &#125; if (slowpath(!obj)) &#123; if (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123; return _objc_callBadAllocHandler(cls); &#125; return nil; &#125; //3.初始化指针关联到相应的类 if (!zone &amp;&amp; fast) &#123; obj-&gt;initInstanceIsa(cls, hasCxxDtor); &#125; else &#123; // Use raw pointer isa on the assumption that they might be // doing something weird with the zone or RR. obj-&gt;initIsa(cls); &#125; //4.编译器优化返回对象 if (fastpath(!hasCxxCtor)) &#123; return obj; &#125; construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE; return object_cxxConstructFromClass(obj, cls, construct_flags);&#125; 调用的流程图 3、cls-&gt;instanceSize 实例对象返回开辟内存的大小？ 点击instanceSize跟踪断点去看源码来分析： 1）调用的是下面两个函数 1234size_t size = _flags &amp; FAST_CACHE_ALLOC_MASK;// remove the FAST_CACHE_ALLOC_DELTA16 that was added// by setFastInstanceSizereturn align16(size + extra - FAST_CACHE_ALLOC_DELTA16); 123#define FAST_CACHE_ALLOC_MASK 0x1ff8#define FAST_CACHE_ALLOC_MASK16 0x1ff0#define FAST_CACHE_ALLOC_DELTA16 0x0008 size得到的值是16 extra得到的值是0 FAST_CACHE_ALLOC_DELTA16得到的值为 = 16 - 0 - 8 = 8 123(lldb) po 0x00088 2）然后我们计算一下 16 字节对齐 align16 到底返回多少字节？ 计算一下(x + size_t(15))) &amp; ~size_t(15)的值 1234567891011121314158 + 15 = 230000 0000 0001 0111 150000 0000 0000 1111~1111 1111 1111 0000 23 &amp; ~150000 0000 0001 01111111 1111 1111 0000-----------------------0000 0000 0001 0000 最后的值为160000 0000 0001 0000 结论：留下了16的倍数，系统返回了16字节的内存 3）为什么是16字节的对齐？ 方便快捷 16字节更加安全 看起来不像 8字节 那么紧凑，并满足以后发展 4、calloc 1）调用下面的方法去开辟内存 12//开辟内存obj = (id)calloc(1, size); 2)下断点到obj &#x3D; (id)calloc(1, size);在这个地方打印po： 12(lldb) po obj0x000000010241e660 打印的是指针变量的地址，没有打印出对象，说明这个地方还没有返回对象 5、obj-&gt;initInstanceIsa 1）断点查看下面的源码 12345678// 3.初始化指针关联到相应的类if (!zone &amp;&amp; fast) &#123; obj-&gt;initInstanceIsa(cls, hasCxxDtor);&#125; else &#123; // Use raw pointer isa on the assumption that they might be // doing something weird with the zone or RR. obj-&gt;initIsa(cls);&#125; 2）下断点到 obj-&gt;initInstanceIsa(cls, hasCxxDtor); 到这行打印 po ： 1234(lldb) po obj&lt;ZJPerson: 0x10241e660&gt;(lldb) 说明在这个位置才是 将初始化的指针关联到对象 3）返回对象 1234// 4.编译器优化返回对象if (fastpath(!hasCxxCtor)) &#123; return obj;&#125; 对象开辟内存的影响因素1、给对象添加属性 ZJPerson.h文件 1234@interface ZJPerson : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) int age;@end main.h文件 123456789101112int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... ZJPerson * p = [ZJPerson alloc]; p.name = @&quot;zj&quot;; //8 p.age = 30; //4 NSLog(@&quot;申请内存大小为：%lu——-系统开辟内存大小为：%lu&quot;,class_getInstanceSize([p class]),malloc_size((__bridge const void *)(p))); &#125; return 0;&#125; 2、分析结果： 12345678910分析结果：1. 成员变量应该分配内存：8字节 + 4字节 = 12字节2. 再加上isa的8字节 = 20字节3. 根据对象8字节对齐原则最大8字节，所以20往大走补充到24字节4. 所以内存空间应该分配24字节5. 注意：对象开辟空间的时候成员变量就会编译进来，所以成员变量未赋值也会分配内存6. 系统由于是16字节对齐原则，所以系统开辟的内存大小为16的倍数 = 16 * 2 = 32,而24大于16小于32，所以为32字节实际打印结果 : 2020-09-06 15:28:31.072150+0800 ZJObjc[15774:988136] 申请内存大小为：24——-系统开辟内存大小为：32 3、分析内存情况 1）打断点在 ZJPerson * p = [ZJPerson alloc]; 行，终端输入: 1234(lldb) x p0x1006414b0: 35 22 00 00 01 80 1d 00 00 00 00 00 00 00 00 00 5&quot;..............0x1006414c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................(lldb) 0x1006414b0 为首地址，在iOS中内存是小端模式，由于没有赋值name和age所以 35 22 00 00 01 80 1d 00 后面的00 00 00 00 00 00 00 00是没值的 2）当我们打断点在NSLog(@”申请内存大小为…行时，终端输入: 1234(lldb) x/4gx p0x1006414b0: 0x001d800100002235 0x000000000000001e0x1006414c0: 0x0000000100001018 0x0000000000000000(lldb) 此时，我们看到0x000000000000001e和0x0000000100001018是有值的，分别代表age=30和name=zj 12345(lldb) po 0x000000000000001e30(lldb) po 0x0000000100001018zj init探索1、查看源码： 1234567891011- (id)init &#123; return _objc_rootInit(self);&#125;_objc_rootInit(id obj)&#123; // In practice, it will be hard to rely on this function. // Many classes do not properly chain -init calls. return obj;&#125; 由源码可知：init什么都没做，只是调用了 _objc_rootInit 重写 init，即构造方法，给用户提供入口去实现工厂设计。 new查看源码 123+ (id)new &#123; return [callAlloc(self, false/*checkNil*/) init];&#125; 发现 和 alloc 调用 callAlloc 是一个流程，即等同于 new = alloc + init，但是有一点区别没有自定义的构造方法，所以一般自定义的类会用alloc init，系统的类用new。 总结本人小白，很多细节问题待补充，希望多多指点。","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理02：Objc4源码编译","slug":"OC进阶/OC底层原理02：Objc4源码编译","date":"2020-09-05T14:45:38.000Z","updated":"2023-02-25T18:03:10.676Z","comments":true,"path":"2020/09/05/OC进阶/OC底层原理02：Objc4源码编译/","link":"","permalink":"https://www.bboyzj.cn/2020/09/05/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8602%EF%BC%9AObjc4%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/","excerpt":"","text":"简介OC的一个主要特性Runtime运行时特性，在日常开发中我们使用到的都是不可见的，还好官方提供了 Runtime（objc4） 源码供开发者研究，我是 ZJ，下面就开始迈出源码探索的第一步，源码编译。 下载objc4-781 进入源码区 打开源码链接 选择 macOS ，搜索 objc4- ，然后下载到桌面 首先编译 target objc unable to find sdk ‘macosx.internal’ 解决办法： PROJECTS –&gt; objc –&gt; Build Settings, 将 Base SDK 改成 macOS TARGETS –&gt; objc –&gt; Build Settings, 将 Base SDK 改成 macOS ‘sys&#x2F;reason.h’ file not found 解决办法： 还是在 macOS 目录下，下载 xnu-8020.101.41, 把 xnu-8020.101.41/bsd/sys/reason.h 文件复制到桌面创建的新文件夹 comm_ifl/sys 目录下 将文件 ZJCommon 放在工程根目录下，并在工程设置文件的索引路径 target -&gt; objc -&gt; Build Settings -&gt; Header Search Paths -&gt; 添加 $(SRCROOT)/ZJCommon 注释错误 可以最后再弄Unknown type name ‘uint32_t’ 添加 #include &lt;stdint.h&gt; ‘mach-o&#x2F;dyld_priv.h’ file not found 原理同上，下载 dyld-960 文件，将 dyld_priv.h 文件，拷贝到 comm_ifl/mach-o/dyld_priv.h 下 ‘os&#x2F;lock_private.h’ file not found 原理同上，下载 libplatform-273.100.5 文件，将 libplatform-273.100.5/private/os/lock_private.h 中 lock_private.h 文件，拷贝到 comm_ifl/os/lock_private.h 下 extern dyld_platform_t dyld_get_active_platform(void) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); —- 报错 Expected ‘,’ 由于调试主要基于 macos，删除 , bridgeos(3.0) 批量同上均删除 , bridgeos(3.0) bridgeos(4.0) 问题 去除 , bridgeos(4.0) ‘os&#x2F;base_private.h’ file not found 在 xnu-8020.101.41/libken/os/base_private.h 中， 把 base_private.h 文件， 拷贝到 comm_ifl/os/base_private.h ‘pthread&#x2F;tsd_private.h’ file not found 下载 libpthread-libpthread-486.100.11 文件，将 libpthread-libpthread-486.100.11/private/pthread/tsd_private.h 拷贝到 comm_ifl/pthread/tsd_private.h ‘os&#x2F;feature_private.h’ file not found 注释掉 ‘os&#x2F;variant_private.h’ file not found 拷贝 Libc-Libc-1507.100.9/os/variant_private.h 至 comm_ifl/os/variant_private.h ‘os&#x2F;tsd.h’ file not found 拷贝 xnu-xnu-8020.101.4/libsyscall/os/tsd.h 至 comm_ifl/os/tsd.h ‘pthread&#x2F;spinlock_private.h’ file not found 拷贝 libpthread-libpthread-486.100.11/private/pthread/spinlock_private.h 至 comm_ifl/pthread/spinlock_private.h Expected function body after function declarator ‘System&#x2F;pthread_machdep.h’ file not found‘System&#x2F;pthread_machdep.h’文件只有在Libc-825.40.1及以下版本才有 在 https://opensource.apple.com/source/Libc/Libc-583/pthreads/ 上下载 pthread_machdep.h，拷贝 pthread_machdep.h 至 comm_ifl/System/pthread_machdep.h ‘CrashReporterClient.h’ file not found 在 这里下载 拷贝 CrashReporterClient.h 至 comm_ifl/CrashReporterClient.h #include_next&lt;CrashReporterClient.h&gt; 改为#include &lt;CrashReporterClient.h&gt; 依然报错：在 Build Settings -&gt; Preprocessor Macros 中加入: LIBC_NO_LIBCRASHREPORTERCLIENT Typedef redefinition with different types (‘int’ vs ‘volatile OSSpinLock’ (aka ‘volatile int’)) 注释掉 Unexpected character &lt;U+1F92F&gt; 注释掉 Use of undeclared identifier ‘dyld_platform_version_macOS_10_13’ 注释掉 ‘os&#x2F;reason_private.h’ file not found 拷贝 xnu-xnu-8020.101.4/libkern/os/reason_private.h 至 comm_ifl/os/reason_private.h ‘os&#x2F;bsd.h’ file not found 直接注释 ‘objc-shared-cache.h’ file not found 拷贝 dyld-dyld-960/include/objc-shared-cache.h 至 comm_ifl/objc-shared-cache.h ‘os&#x2F;linker_set.h’ file not found 拷贝 Libc-Libc-1507.100.9/os/linker_set.h 至 comm_ifl/os/linker_set.h ‘_simple.h’ file not found 全局搜索 _simple.h 拷贝至 comm_ifl/_simple.h Use of undeclared identifier ‘dyld_fall_2020_os_versions’ 注释掉 Use of undeclared identifier ‘objc4’ 注释掉 Use of undeclared identifier ‘preoptimizedCaches’ 注释掉 Use of undeclared identifier ‘CRGetCrashLogMessage’ 注释掉 ‘Cambria&#x2F;Traps.h’ file not found 和 ‘Cambria&#x2F;Cambria.h’ file not found 注释掉 Use of undeclared identifier ‘objc_thread_get_rip’ ‘kern&#x2F;restartable.h’ file not found xnu-xnu-8020.101.4/osfmk/kern/restartable.h 拷贝到 comm_ifl/kern/restartable.h Use of undeclared identifier ‘oah_is_current_process_translated’ 注释掉 ‘Block_private.h’ file not found libclosure-libclosure-79.1/Block_private.h 拷贝到 comm_ifl/Block_private.h Use of undeclared identifier ‘os_parse_boot_arg_string’ 注释掉 Use of undeclared identifier ‘dyld_platform_version_macOS_10_11’ 注释掉 Use of undeclared identifier ‘dyld_fall_2018_os_versions’ Use of undeclared identifier ‘dyld_platform_version_macOS_10_12’ ‘_static_assert’ declared as an array with a negative size 注释掉 最后这几步很重要在 dyld_priv.h 文件顶部加入宏1234#define DYLD_MACOSX_VERSION_10_11 0x000A0B00#define DYLD_MACOSX_VERSION_10_12 0x000A0C00#define DYLD_MACOSX_VERSION_10_13 0x000A0D00#define DYLD_MACOSX_VERSION_10_14 0x000A0E00 CrashReporterClient异常 library not found for -loah ‘macosx.internal’ cannot be located. 接下来objc进行编译调试新建target ：ZJDemo 建立依赖 创建一个macOS类ZJPerson 绑定到ZJDemo的target上 注释文件执行顺序 编译调试target 下符号调试","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理01：查找源码有三种方式","slug":"OC进阶/OC底层原理01：查找源码有三种方式","date":"2020-09-02T17:35:35.000Z","updated":"2023-02-25T06:43:11.614Z","comments":true,"path":"2020/09/03/OC进阶/OC底层原理01：查找源码有三种方式/","link":"","permalink":"https://www.bboyzj.cn/2020/09/03/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8601%EF%BC%9A%E6%9F%A5%E6%89%BE%E6%BA%90%E7%A0%81%E6%9C%89%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"前言本文主要介绍下源码探索的三种方法： 1、符号断点直接跟流程 2、通过按住 control+step into 3、汇编跟流程 下符号断点的形式直接跟流程 切换到Show the breakpoing navigator栏，打击左下角“+”号create a breakpoint创建一个断点 添加要查看的符号alloc 设置地址断点，并取消之前设置的符号断点4，以便执行目标行，因为系统调用alloc的方法有很多，你不知道什么时候能执行到目标位置 command + R编译并运行工程，当代码执行到3时，将符号断点4选中，查看执行的底层源码 通过摁住control - step into command + R编译并运行工程，代码执行到目标行，按住control + step into单步运行箭头 按上面的方式，进入汇编可得下图： 注:jmpq是设么意思？jmpq 就是jmp 指令。q是gnu汇编的用法。q表示跳转到64位地址。l表示32位地址。 然后打一个objc_alloc的符号断点，跳转到汇编代码可得下图: 由上图可知objc_alloc是在libobjc.A.dylib这个动态链接库上注：.dylib是OSX上的动态库扩展 查看运行时的汇编代码 Xcode点击Debug-&gt;Debug Workflow-&gt;Alway Show Disassembly查看运行时的汇编代码 运行成功后的汇编代码如下 可知底层调用的方法是objc_alloc 注：callq：调用函数的意思，即调用函数时的压栈出栈 在下一个符号断点objc_alloc,继续执行和上面的就一样了 总结由上面的方法我们可知 alloc 底层调用的是 objc_alloc，所在的位置是libobjc.A.dylib 这个动态链接库，用一张流程图总结：","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理00：LLDB常用命令","slug":"OC进阶/OC底层原理00：LLDB常用命令","date":"2020-09-01T15:31:27.000Z","updated":"2022-04-21T06:04:50.000Z","comments":true,"path":"2020/09/01/OC进阶/OC底层原理00：LLDB常用命令/","link":"","permalink":"https://www.bboyzj.cn/2020/09/01/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8600%EF%BC%9ALLDB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"x 对象：以 16 进制，打印对象的内存分布，位数为 16123(lldb) x p0x100792110: 75 32 00 00 01 80 1d 00 00 00 00 00 00 00 00 00 u2..............0x100792120: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ memory read 对象：以 16 进制，打印对象的内存分布，和1一样，位数为 16123(lldb) memory read p0x100792110: 75 32 00 00 01 80 1d 00 00 00 00 00 00 00 00 00 u2..............0x100792120: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ x/4gx 对象：以16进制，打印4段对象的内存分布情况，位数为16123(lldb) x/4gx p0x100792110: 0x001d800100003275 0x00000000000000000x100792120: 0x0000000000000000 0x0000000000000000 x/4gw 对象：以16进制，打印4段对象的内存分布情况，位数为1612(lldb) x/4gw p0x100792110: 0x00003275 0x001d8001 0x00000000 0x00000000 po 对象：输出对应的值12(lldb) po p&lt;LGPerson: 0x100792110&gt; p 对象：返回值的类型以及命令结果的引用名，将地址0x0000000100792110放到寄存器$5中12(lldb) p p(LGPerson *) $5 = 0x0000000100792110 p/x：以16进制的形式，打印类信息12(lldb) p/x p(LGPerson *) $6 = 0x0000000100792110","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"iOS开发者账号03：苹果开发者证书创建","slug":"开发者账号申请流程/iOS开发者账号03：苹果开发者证书创建","date":"2020-08-29T08:03:09.000Z","updated":"2023-03-14T22:23:40.247Z","comments":true,"path":"2020/08/29/开发者账号申请流程/iOS开发者账号03：苹果开发者证书创建/","link":"","permalink":"https://www.bboyzj.cn/2020/08/29/%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B/iOS%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B703%EF%BC%9A%E8%8B%B9%E6%9E%9C%E5%BC%80%E5%8F%91%E8%80%85%E8%AF%81%E4%B9%A6%E5%88%9B%E5%BB%BA/","excerpt":"","text":"前言在 Certificates, Identifiers &amp; Profiles 中，有几个选项，而前面四个是苹果开发者账号证书配置分为四个部分： 申请 Identifiers：即 APP IDs ,设备唯一标识 创建证书 Certificates ：开发、发布证书(包括推送证书) Devices：测试设备注册 Profiles：应用描述配置 申请Identifiers 选择 APP IDs ，点击 Continue，进入下一个页面 来到 Select a type，默认选中 App ，点击 Continue 继续往下个页面走 来到设置 Budle ID 的页面，填写 描述信息和Budle id 填写： Description： 填写APP 描述 Bundle ID：公司网址颠倒 + APP名字，例如 epod.cn.xxxx。 Explocit：显示的，默认选中。 Wildcard：通配符样式 Capabilities : 在下面还有一些可选功能 根据APP需求，勾选需要的权限，一般推送，内购买。 点击Register 得到的 Idenifiers 如下： Mac生成CSR 打开钥匙串-&gt;证书助理-&gt;从证书颁发机构请求证书 注：不管是申请 开发(Development)证书 还是 发布(Distribution)证书 ，都需要使用 证书请求(.certSigningRequest)文件 打开Mac上的钥匙串，从证书助手那里请求证书。 填写证书信息 点击继续保存到你要保存的位置 证书配置 Software 下证书分类两种: iOS App Development： 为开发证书，用于真机测试。 iOS Distribution (App Store and Ad Hoc)：为 APP发布证书，用于上架APP到 APP Store 或者 Ad Hoc 上传包到蒲公英。 Services 下推送证书也分为两种： Apple Push Notification service SSL (Sandbox) ：开发环境下的推送证书 Apple Push Notification service SSL (Sandbox &amp; Production)：生产环境的推送证书 开发证书iOS App Development的创建流程: 选中 Software 下的 iOS App Development 和 Services 下的 Apple Push Notification service SSL (Sandbox)，然后点击 continue 来到 Creat New Certificate 页面，需要上传 CSR 文件 由上图可知，上传证书签名请求，您需要Mac上的证书签名请求（CSR）文件，要手动生成证书。 点击 Choose file 导入 CSR 文件 点击 download 并 双击 运行到项目中 接下来就是配置开发环境的 推送证书 按序号操作，进入 找到 Services 点击 Continue 按下面的序号依次操作 之后还是配置CSR文件 下载推送证书 生产环境证书 和 生产环境推送证书 类似于 开发环境，就不一一介绍了 最后生产四种类型的证书 项目中使用 项目中选择TARGET，添加一个账户 Add an Account: 输入你的 Apple ID 账号 发送给自己手机验证码 选中你添加的账号名 确保Bundle ID 和 你开发者账号上的一致","categories":[{"name":"iOS-开发者账号探索篇","slug":"iOS-开发者账号探索篇","permalink":"https://www.bboyzj.cn/categories/iOS-%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.bboyzj.cn/tags/iOS/"}],"keywords":[{"name":"iOS-开发者账号探索篇","slug":"iOS-开发者账号探索篇","permalink":"https://www.bboyzj.cn/categories/iOS-%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"iOS开发者账号02：开发者账号发票修改抬头流程","slug":"开发者账号申请流程/iOS开发者账号02：开发者账号发票修改抬头流程","date":"2020-08-29T03:25:08.000Z","updated":"2023-03-14T22:18:15.249Z","comments":true,"path":"2020/08/29/开发者账号申请流程/iOS开发者账号02：开发者账号发票修改抬头流程/","link":"","permalink":"https://www.bboyzj.cn/2020/08/29/%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B/iOS%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B702%EF%BC%9A%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E5%8F%91%E7%A5%A8%E4%BF%AE%E6%94%B9%E6%8A%AC%E5%A4%B4%E6%B5%81%E7%A8%8B/","excerpt":"","text":"背景由于公司之前有人注册过开发者账号，但是已经很久很久没有用了，所以免去了我从头注册的麻烦，我只要用 visa卡 去续费就可以了 发票填写错误处理流程 登录 开发者网站，点击 Account 登录账号，点击续费，具体流程很简单，按照提示走就行了，唯一需要注意的是，开发票，选择 企业发票，需要填写 公司抬头 和 纳税人识别号。我就是在这个地方把公司的抬头填写错的。 续费方法有两种： APP内购 续费：下载 Developer， 通过APP去付费 网页 续费：一般订单号以 W开头 后加 9位数字 如何解决 发票 问题： APP内购买 续费：通过 开发者网站 -&gt; 联系我们 -&gt; 会员资格和账户 -&gt; 计划购买和续订 -&gt; 电话 网页 续费：通过拨打 400-666-8800 按提示音 -&gt; 找到 账户购买技术支持，去解决，我是废了好长时间才弄明白，因为我的订单号是 W 开头的，不能走 内购买 流程。","categories":[{"name":"iOS-开发者账号","slug":"iOS-开发者账号","permalink":"https://www.bboyzj.cn/categories/iOS-%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.bboyzj.cn/tags/iOS/"}],"keywords":[{"name":"iOS-开发者账号","slug":"iOS-开发者账号","permalink":"https://www.bboyzj.cn/categories/iOS-%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7/"}]},{"title":"iOS开发者账号01：开发者账号介绍","slug":"开发者账号申请流程/iOS开发者账号01：开发者账号介绍","date":"2020-08-29T02:54:02.000Z","updated":"2023-03-08T21:48:14.902Z","comments":true,"path":"2020/08/29/开发者账号申请流程/iOS开发者账号01：开发者账号介绍/","link":"","permalink":"https://www.bboyzj.cn/2020/08/29/%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B/iOS%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B701%EF%BC%9A%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"开发者账号苹果开发者账号可分为三种类型：个人、公司、企业，且三者的费用以及权限等不尽相同。 个人账号 费用：99 美元&#x2F;年协作人数：仅限开发者自己不需要填写公司的邓百氏编码（ D-U-N-S Number）支持账号下的 app 上线 App Store需要创建 Apple ID 公司账号 费用：99 美元&#x2F;年允许多个开发者协作开发需要填写公司的邓百氏编码（ D-U-N-S Number）该账号下的 app 可上线至 App Store需要创建 Apple ID 苹果企业开发者账号 费用：299 美元&#x2F;年允许多个开发者协作开发需要填写公司的邓百氏编码（ D-U-N-S Number）该账号下的 app 不能发布到 App Store 中需要创建 Apple ID 开发者账号付款方式苹果公司只接受2种付款方式，一种就是 VISA 卡，另外一种是 万事达卡（MasterCard），都可以在国内银行办理 介于我本人去办理VISA卡的流成： 带着自己的身份证，知道公司地址、公司座机电话，这三个最主要，其他的根据银行办卡要求去填写。 办卡选择中美双汇币VISA卡，具体你去银行办理就知道了。 MasterCard 与 VISA 卡的区别有： 目前国际上有六大信用卡品牌，分别是 威士国际组织（VISA International） 及 万事达卡国际组织（MasterCard International） 两大组织及 美国运通国际股份有限公司（America Express）、中国银联股份有限公司（China UnionPay Co.,Ltd.）、大来信用卡有限公司（Diners Club）、JCB日本国际信用卡公司（JCB）四家专业信用卡公司。 VISA(威士卡）、Mastercard（万事达卡）、China UnionPay（银联卡）在全球范围构建了一个刷卡消费的联盟，国内银行与他们合作以后，国内银行发行的信用卡就能在他们联盟范围内刷卡消费，在部分国家地区甚至可以持银联卡直接消费。你可以在申请信用卡的时候选择申请VISA(威士）信用卡还是Mastercard（万事达）信用卡。 就目前来讲两家国际组织在国内区别不大，区别比较大的是银联卡，选择哪一个完全可以凭自己的喜好。如果你经常在 亚洲、澳大利亚旅游 或者 刷卡消费的话，那么建议你选择 VISA，因为VISA在亚洲和澳大利亚受理的商户数量比较多，使用起来更方便。 Mastercard的优势在于 欧洲 和 北美。经常去这欧洲和美洲的朋友可以选择 Mastercard（万事达）","categories":[{"name":"iOS-开发者账号","slug":"iOS-开发者账号","permalink":"https://www.bboyzj.cn/categories/iOS-%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.bboyzj.cn/tags/iOS/"}],"keywords":[{"name":"iOS-开发者账号","slug":"iOS-开发者账号","permalink":"https://www.bboyzj.cn/categories/iOS-%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7/"}]},{"title":"OC数据结构02：二叉树探索","slug":"OC数据结构和算法/OC数据结构02：二叉树探索","date":"2020-08-26T08:35:40.000Z","updated":"2023-03-06T10:16:16.075Z","comments":true,"path":"2020/08/26/OC数据结构和算法/OC数据结构02：二叉树探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/26/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"什么是二叉树树形结构，两个节点 以内均称为 二叉树，分为 左子树 和 右子树，有顺序，不能颠倒；比如把人看做树：头是树根，左右是坐子树，右手是右子树。 二叉树遍历类型 深度优先遍历：采用栈 先序遍历：对任一子树，先访问根，然后遍历左子树，最后遍历其右子树 中序遍历：对任一子树，先遍历左子树，然后访问根，最后遍历其右子树 后序遍历：对任一子树，先遍历其左子树，然后遍历其右子树，最后访问根 广度优先遍历：采用队列 层次遍历，从上往下 对每一层依次访问，每一层从 左往右（或从右往左）访问节点，访问完一层就进入下一层，直到没有节点可以访问为止。 区别： 深度优先算法：不全部保留节点，占用空间小，有回溯操作，运行速度慢，用时间换空间 广度优先算法：保留全部节点，占用空间大，无回溯操作，运行速度快，用空间换时间 二叉排序树的好处？二叉树是一种比较折中的方案；数组的搜索比较方便，可以直接用下标，但删除或插入比较耗时；链表与之相反，删除或插入很快，但查找很慢；二叉排序树既有链表的好处，也有数组的好处，在处理大批量的动态数据是比较有用的 二叉排序树节点定义采用单项链表的形式，只从根节点指向孩子节点，不保存父节点。 对于二叉搜索树这种数据类型，用简单的数组来表示是不适合的。所以要建立一个模型： 值：就用最简单的整数来表示，实际使用中，这个整型值也是必不可少的，可以当做key来用，这是二叉搜索树排序的凭证。 左子树：用一个同类型的指针表示 右子树：用一个同类型的指针表示 以上3个是二叉搜索树必不可少的属性 123456789// 二叉排序树节点@interface BinaryTreeNode : NSObject// 值@property (nonatomic, assign) NSInteger value;// 左节点@property (nonatomic, strong) BinaryTreeNode *leftNode;// 右节点@property (nonatomic, strong) BinaryTreeNode *rightNode;@end 如何验证两个二叉树是完全相等的？递归 去判断每个节点的 值 是否相等，如果均相等，则两个二叉树完全相等 123456789101112- (void)isSameTree:(TreeNode *)root1 tree:(TreeNode *)root2&#123; if (root1 == null &amp;&amp; root2 == null) &#123; return true; &#125; if ((root1 == null &amp;&amp; root2 != null) || (root1 != null &amp;&amp; root2 == null))&#123; return false; &#125; if (root1.val != root2.val) &#123; // 判断每个节点的值是否相等，如果去除此判断，则判断两个二叉树是否结构相等 return false; &#125; return [self isSameTree:root1.left tree:root2.left] &amp;&amp; [self isSameTree:root1.right tree:root2.right];&#125; 创建二叉排序树 二叉树中左右节点值本身没有大小之分，所以如果要创建二叉树，就需要考虑如何处理某个节点是左节点还是右节点，如何终止某个子树而切换到另一个子树。 因此我选择了 二叉排序树，二叉排序树中对于左右节点有明确的要求，程序可以自动根据键值大小自动选择是左节点还是右节点。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 创建二叉排序树 * 二叉排序树：左节点值全部小于根节点值，右节点值全部大于根节点值 * @param values 数组 * @return 二叉树根节点 */+ (BinaryTreeNode *)createTreeWithValues:(NSArray *)values &#123; BinaryTreeNode *root = nil; for (NSInteger i=0; i&lt;values.count; i++) &#123; NSInteger value = [(NSNumber *)[values objectAtIndex:i] integerValue]; root = [BinaryTree addTreeNode:root value:value]; &#125; return root;&#125;/** * 向二叉排序树节点添加一个节点 * * @param treeNode 根节点 * @param value 值 * * @return 根节点 */+ (BinaryTreeNode *)addTreeNode:(BinaryTreeNode *)treeNode value:(NSInteger)value &#123; //根节点不存在，创建节点 if (!treeNode) &#123; treeNode = [BinaryTreeNode new]; treeNode.value = value; NSLog(@&quot;node:%@&quot;, @(value)); &#125; else if (value &lt;= treeNode.value) &#123; NSLog(@&quot;to left&quot;); // 值小于根节点，则插入到左子树 treeNode.leftNode = [BinaryTree addTreeNode:treeNode.leftNode value:value]; &#125;else &#123; NSLog(@&quot;to right&quot;); // 值大于根节点，则插入到右子树 treeNode.rightNode = [BinaryTree addTreeNode:treeNode.rightNode value:value]; &#125; return treeNode;&#125; 实际使用 1）创建一个二叉树类BinaryTreeNode，在类中实现如下代码： 12345678910111213141516171819#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface BinaryTreeNode : NSObject// 值：当做key来用，是排序用的凭证@property (nonatomic,assign)NSInteger value;// 左子树@property (nonatomic,strong)BinaryTreeNode * leftChild;// 右子树@property (nonatomic,strong)BinaryTreeNode * rightChild;// 创建二叉排序树+ (BinaryTreeNode *)createBinaryTreeWithValues:(NSArray *)values;// 向二叉排序树中添加一个节点+ (BinaryTreeNode *)addNode:(BinaryTreeNode *)rootNode value:(NSInteger)value;@endNS_ASSUME_NONNULL_END 12345678910111213141516171819202122232425262728293031323334353637383940/* 创建二叉排序树 二叉排序树：左节点值全部小于根节点值，右节点值全部大于根节点值 @param values：数组 @return 二叉排序树根节点 */+ (BinaryTreeNode *)createBinaryTreeWithValues:(NSArray *)values&#123; BinaryTreeNode * rootNode = nil; for (NSNumber * number in values) &#123; NSInteger value = [number integerValue]; rootNode = [BinaryTreeNode addNode:rootNode value:value]; &#125; return rootNode;&#125;/* 向二叉排序树节点添加一个节点 @param rootNode 根节点 @param value 值 @return 根节点 */+ (BinaryTreeNode *)addNode:(BinaryTreeNode *)rootNode value:(NSInteger)value&#123; // 根节点不存在，创建节点 if (rootNode == nil) &#123; rootNode = [[BinaryTreeNode alloc] init]; rootNode.value = value; NSLog(@&quot;node:%@&quot;,@(value)); &#125;else if (value &lt;= rootNode.value) &#123; NSLog(@&quot;to left&quot;); // 值小于根节点，则插入到左子树；这是递归，左子树将做同样的事儿 rootNode.leftChild = [self addNode:rootNode.leftChild value:value]; &#125;else if (value &gt; rootNode.value) &#123; NSLog(@&quot;to right&quot;); // 值大于根节点，则插入到右子树；这是递归，右子树将做同样的事儿 rootNode.rightChild = [self addNode:rootNode.rightChild value:value]; &#125;else &#123; NSLog(@&quot;二叉排序树没有键值相等的节点，值%@已存在，不能插入&quot;,@(value)); &#125; return rootNode;&#125; 2）在controller中，用一个属性持有这个二叉搜索树。 12345678#import &quot;ViewController.h&quot;//二叉树#import &quot;BinaryTreeNode.h&quot;@interface ViewController ()// 二叉搜索树的根节点，代表一棵树@property (strong, nonatomic) BinaryTreeNode *rootNode;@end 输入用一串值，得到一颗二叉搜索树 1234567- (void)viewDidLoad &#123; [super viewDidLoad]; //创建一个二叉树 NSArray *values = @[@200, @23, @456, @89, @23, @670, @5674, @15]; self.rootNode = [BinaryTreeNode createBinaryTreeWithValues:values]; &#125; 3）用断点，查看“链式”结构，同时通过log可以看出创建过程。 4）生成的二叉树图 先序遍历 先访问根，再遍历左子树，再遍历右子树。典型的递归思想。 123456789101112131415161718/** * 先序遍历 * 先访问根，再遍历左子树，再遍历右子树 * * @param rootNode 根节点 * @param handler 访问节点处理函数 */+ (void)preOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123; if (rootNode) &#123; // 先根 if (handler) &#123; handler(rootNode); &#125; // 再左 [self preOrderTraverseTree:rootNode.leftNode handler:handler]; // 最后右 [self preOrderTraverseTree:rootNode.rightNode handler:handler]; &#125;&#125; 实际使用 12345678// 先序遍历- (void)preOrderTraverse&#123; NSMutableArray * preArr = [NSMutableArray array]; [BinaryTreeNode preOrderTraverseTree:self.rootNode handler:^(BinaryTreeNode * _Nonnull treeNode) &#123; [preArr addObject:[NSNumber numberWithInteger:treeNode.value]]; &#125;]; NSLog(@&quot;先序遍历：%@&quot;, preArr);&#125; 查看打印结果： 1234567892020-08-26 22:45:09.310234+0800 OC-二叉树[50561:2829401] 先序遍历：( 200, 23, 15, 89, 456, 670, 5674) 中序遍历 先遍历左子树，再访问根，再遍历右子树。对于二叉排序树来说，中序遍历得到的序列是一个从小到大排序好的序列。 12345678910111213141516/** * 中序遍历 * 先遍历左子树，再访问根，再遍历右子树 * * @param rootNode 根节点 * @param handler 访问节点处理函数 */+ (void)inOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123; if (rootNode) &#123; [self inOrderTraverseTree:rootNode.leftNode handler:handler]; if (handler) &#123; handler(rootNode); &#125; [self inOrderTraverseTree:rootNode.rightNode handler:handler]; &#125;&#125; 实际使用 12345678//中序遍历- (void)inOrderTraverse&#123; NSMutableArray * inArr = [NSMutableArray array]; [BinaryTreeNode inOrderTraverseTree:self.rootNode handler:^(BinaryTreeNode * _Nonnull treeNode) &#123; [inArr addObject:[NSNumber numberWithInteger:treeNode.value]]; &#125;]; NSLog(@&quot;中序遍历：%@&quot;, inArr);&#125; 查看打印结果 1234567892020-08-26 22:49:26.310344+0800 OC-二叉树[50591:2832806] 中序遍历：( 15, 23, 89, 200, 456, 670, 5674) 后续遍历 先遍历左子树，再遍历右子树，再访问根 12345678910111213141516/** * 后序遍历 * 先遍历左子树，再遍历右子树，再访问根 * * @param rootNode 根节点 * @param handler 访问节点处理函数 */+ (void)afterOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123; if (rootNode) &#123; [self afterOrderTraverseTree:rootNode.leftNode handler:handler]; [self afterOrderTraverseTree:rootNode.rightNode handler:handler]; if (handler) &#123; handler(rootNode); &#125; &#125;&#125; 实际使用 12345678//后序遍历- (void)afterOrderTraverse&#123; NSMutableArray * afterArr = [NSMutableArray array]; [BinaryTreeNode afterOrderTraverseTree:self.rootNode handler:^(BinaryTreeNode * _Nonnull treeNode) &#123; [afterArr addObject:[NSNumber numberWithInteger:treeNode.value]]; &#125;]; NSLog(@&quot;后序遍历：%@&quot;, afterArr);&#125; 查看打印结果 123456789102020-08-26 22:51:50.637367+0800 OC-二叉树[50628:2835309] 后序遍历：( 15, 89, 23, 5674, 670, 456, 200) 翻转二叉树 你会翻转二叉树吗？如果不会，那对不起，我们不会录用你！ 翻转二叉树，又叫求二叉树的镜像，就是把二叉树的左右子树对调（当然是递归的） 1234567891011121314151617181920212223242526272829/* 翻转二叉树（又叫：二叉树的镜像） @param rootNode 根节点 @return 翻转后的树根节点（其实就是原二叉树的根节点） */// 翻转二叉树+ (BinaryTreeNode *)flipBinaryTree:(BinaryTreeNode *)rootNode&#123; // 判空 if(!rootNode)&#123; return nil; &#125; // 没有子节点 if(!rootNode.leftNode &amp;&amp; !rootNode.rightNode)&#123; return rootNode; &#125; // 左右子树递归 [self flipBinaryTree:rootNode.leftNode]; [self flipBinaryTree:rootNode.rightNode]; // 左右节点交换 BinaryTreeNode * tempNode = rootNode.leftNode; rootNode.leftNode = rootNode.rightNode; rootNode.rightNode = tempNode.leftNode; return rootNode;&#125; 实际使用 1234// 翻转二叉树- (void)invertBinaryTree&#123; self.rootNode = [BinaryTreeNode invertBinaryTree:self.rootNode];&#125; 查看打印结果 生成二叉树的图 查找二叉树中某个位置的结点类似索引操作，按 层次 遍历，位置从0开始算。 12345678910111213141516171819202122232425262728293031323334353637/* 查找二叉树某个位置的结点 @param index 按层次便利树是的位置（从0开始） @param rootNode 树根结点 @return 结点 */// 指定位置查找节点+ (BinaryTreeNode *)findTreeNodeAtIndex:(int)index withRootTree:(BinaryTreeNode *)rootNode&#123; // 如果节点不存在，查找位置不符合规范 if (!rootNode || index &lt; 0)&#123; return nil; &#125; NSMutableArray * queueArr = [NSMutableArray arrayWithCapacity:0]; // 压入根节点 [queueArr addObject:rootNode]; while (queueArr.count &gt; 0) &#123; BinaryTreeNode * node = [queueArr firstObject]; // 如果是根节点，则直接返回 if(index == 0)&#123; return node; &#125; // 仿照队列先进先出FIFO，移除最前面的节点 [queueArr removeObjectAtIndex:0]; index --; // 按照从左往右依次压入节点 if(node.leftNode)&#123; [queueArr addObject:node.leftNode]; &#125; if(node.rightNode)&#123; [queueArr addObject:node.rightNode]; &#125; &#125; // 遍历完，还没有找到位置，返回nil return nil;&#125; 在controller中调用 12345678// 查找某个位置的节点- (void)searchNode&#123; BinaryTreeNode * node = [BinaryTreeNode findTreeNodeAtIndex:4 withTree:self.rootNode]; NSLog(@&quot;node-------%@&quot;,[NSNumber numberWithInteger:node.value]);&#125;********打印结果******2020-08-27 11:29:47.724120+0800 OC-二叉树[51450:2892148] node-------89 层次遍历 按照从上到下、从左到右的次序进行遍历。先遍历完一层，再遍历下一层，因此又叫广度优先遍历。需要用到队列，在OC里可以用可变数组来实现。 根改了：NSArray *values &#x3D; @[@100, @23, @45, @89, @23, @67, @54, @15]; 1234567891011121314151617181920212223242526272829303132333435/*层次遍历（广度优先）@param rootNode 树根节点@param handler 访问节点处理函数*/// 层次遍历+ (void)levelTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *))handler&#123; // 空节点 if(!rootNode)&#123; return; &#125; // 数组当成队列 NSMutableArray * queueArr = [NSMutableArray array]; // 压入根节点 [queueArr addObject:rootNode]; // 当队列有数据的时候去遍历 while (queueArr.count &gt; 0) &#123; BinaryTreeNode * node = [queueArr firstObject]; if (handler)&#123; handler(node); &#125; // 仿照队列先进先出FIFO，移除最前面的节点 [queueArr removeObjectAtIndex:0]; // 按照从左往右依次压入节点 if(node.leftNode)&#123; [queueArr addObject:node.leftNode]; &#125; if(node.rightNode)&#123; [queueArr addObject:node.rightNode]; &#125; &#125;&#125; 在controller中调用 12345678//层次遍历- (void)levelTraverse&#123; NSMutableArray * levelArr = [NSMutableArray array]; [BinaryTreeNode levelTraverseTree:self.rootNode handler:^(BinaryTreeNode * _Nonnull treeNode) &#123; NSLog(@&quot;value:%ld&quot;,treeNode.value); [levelArr addObject:treeNode]; &#125;];&#125; 次遍历：查看打印结果 12345672020-08-31 17:18:50.185983+0800 OC-二叉树[59736:4179500] value:1002020-08-31 17:18:50.186414+0800 OC-二叉树[59736:4179500] value:232020-08-31 17:18:50.186896+0800 OC-二叉树[59736:4179500] value:152020-08-31 17:18:50.187158+0800 OC-二叉树[59736:4179500] value:452020-08-31 17:18:50.187479+0800 OC-二叉树[59736:4179500] value:892020-08-31 17:18:50.187753+0800 OC-二叉树[59736:4179500] value:672020-08-31 17:18:50.188040+0800 OC-二叉树[59736:4179500] value:54 二叉树的深度 二叉树的深度定义为：从根节点到叶子结点依次经过的结点形成树的一条路径,最长路径的长度为树的深度。1）如果根节点为空，则深度为0；2）如果左右节点都是空，则深度为1；3）递归思想：二叉树的深度&#x3D;max（左子树的深度，右子树的深度）+ 1 12345678910111213141516171819202122/* 二叉树的深度 @param rootNode 二叉树根节点 @return 二叉树的深度 */// 二叉树的深度+ (NSInteger)depthOfTree:(BinaryTreeNode *)rootNode&#123; if (!rootNode)&#123; return 0; &#125; if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode)&#123; return 1; &#125; // 左子树深度 NSInteger leftDepth = [self depthOfTree:rootNode.leftNode]; // 右子树深度 NSInteger rightDepth = [self depthOfTree:rootNode.rightNode]; // 二叉树深度 NSInteger totalDepth = MAX(leftDepth, rightDepth) + 1; return totalDepth;&#125; 在controller中调用 12345//树的深度- (void)depthTree&#123; NSInteger depth = [BinaryTreeNode depthOfTree:self.rootNode]; NSLog(@&quot;depth:%ld&quot;,depth);&#125; 查看结果 12020-08-31 17:29:49.989752+0800 OC-二叉树[59816:4186549] depth:6 二叉树的宽度二叉树的 宽度 定义为各层节点数的最大值。 12345678910111213141516171819202122232425262728293031323334353637/** * 二叉树的宽度 * @param rootNode 二叉树根节点 * @return 二叉树宽度 */+ (NSInteger)widthOfTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return 0; &#125; NSMutableArray * queueArray = [NSMutableArray array]; [queueArray addObject:rootNode]; // 压入根节点 NSInteger maxWidth = 1; // 最大的宽度，初始化为1（因为已经有根节点） NSInteger curWidth = 0; // 当前层的宽度 while (queueArray.count &gt; 0) &#123; curWidth = queueArray.count; //依次弹出当前层的节点 for (NSInteger i=0; i&lt;curWidth; i++) &#123; BinaryTreeNode * node = [queueArray firstObject]; // 弹出最前面的节点，仿照队列先进先出原则 [queueArray removeObjectAtIndex:0]; // 压入左子数 if (node.leftNode) &#123; [queueArray addObject:node.leftNode]; &#125; // 压入右子树 if (node.rightNode) &#123; [queueArray addObject:node.rightNode]; &#125; &#125; // 宽度 = 当前层节点数 maxWidth = MAX(maxWidth, queueArray.count); &#125; return maxWidth;&#125; vc实现 123// 二叉树宽度NSInteger width = [BinaryTreeNode widthOfTree:self.rootNode];NSLog(@&quot;width-%ld&quot;,width); 打印结果 12022-11-26 16:21:36.767352+0800 二叉树[4523:170689] width-2 二叉树的所有节点数递归思想：二叉树所有节点数 &#x3D; 左子树节点数 + 右子树节点数 + 1 1234567891011121314151617/** * 二叉树的所有节点数 * * @param rootNode 根节点 * * @return 所有节点数 */// 二叉树所有节点数+ (NSInteger)numberOfNodesInTree:(BinaryTreeNode *)rootNode&#123; if (!rootNode)&#123; return 0; &#125; // 总节点数 = 左子树节点数 + 右子树节点数 + 1 NSInteger totalNode = [self numberOfNodesInTree:rootNode.leftNode] + [self numberOfNodesInTree:rootNode.rightNode] + 1; return totalNode;&#125; vc实现 123// 二叉树节点数NSInteger totalNode = [BinaryTreeNode numberOfNodesInTree:self.rootNode];NSLog(@&quot;totalNode-%ld&quot;,totalNode); 打印结果 12022-11-26 16:10:38.371816+0800 二叉树[4369:160462] totalNode-5 二叉树某层中的节点数1）根节点为空，则节点数为0； 2）层为1，则节点数为1（即根节点） 3）递归思想：二叉树第k层节点数 &#x3D; 左子树第k-1层节点数 + 右子树第k-1层节点数 12345678910111213141516171819202122/** * 二叉树某层中的节点数 * * @param level 层 * @param rootNode 根节点 * * @return 层中的节点数 */// 二叉树某层中的节点数+ (NSInteger)numberOfNodesOnLevel:(NSInteger)level inTree:(BinaryTreeNode *)rootNode&#123; // 根节点不存在 或 level &lt; 0 if (!rootNode || level &lt; 1) &#123; return 0; &#125; // level = 1，返回1（根节点） if (level == 1) &#123; return 1; &#125; // 递归：level层节点数 = 左子树level-1层节点数 + 右子树level-1层节点数 NSInteger levelNode = [self numberOfNodesOnLevel:level-1 inTree:rootNode.leftNode] + [self numberOfNodesOnLevel:level-1 inTree:rootNode.rightNode]; return levelNode;&#125; vc实现 123// 某层节点数NSInteger levelNode = [BinaryTreeNode numberOfNodesOnLevel:1 inTree:self.rootNode];NSLog(@&quot;levelNode-%ld&quot;,levelNode); 打印结果 12022-11-26 16:27:02.360866+0800 二叉树[4593:175705] levelNode-1 二叉树叶子节点数叶子节点，又叫终端节点，是左右子树都是空的节点。 123456789101112131415161718/** * 二叉树叶子节点数 * * @param rootNode 根节点 * * @return 叶子节点数 */+ (NSInteger)numberOfLeafsInTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return 0; &#125; // 左子树和右子树都是空，说明是叶子节点 if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123; return 1; &#125; // 递归：叶子数 = 左子树叶子数 + 右子树叶子数 return [self numberOfLeafsInTree:rootNode.leftNode] + [self numberOfLeafsInTree:rootNode.rightNode];&#125; 二叉树最大距离（二叉树的直径）二叉树中任意两个节点都有且仅有一条路径，这个路径的长度叫这两个节点的距离。二叉树中所有节点之间的距离的最大值就是二叉树的直径。 有一种解法，把这个最大距离划分了3种情况： 1）这2个节点分别在根节点的左子树和右子树上，他们之间的路径肯定经过根节点，而且他们肯定是根节点左右子树上最远的叶子节点（他们到根节点的距离&#x3D;左右子树的深度）。 2）这2个节点都在左子树上 3）这2个节点都在右子树上 综上，只要取这3种情况中的最大值，就是二叉树的直径。 12345678910111213141516171819202122/** * 二叉树最大距离（直径） * * @param rootNode 根节点 * * @return 最大距离 */+ (NSInteger)maxDistanceOfTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return 0; &#125;// 方案一：（递归次数较多，效率较低） //分3种情况： //1、最远距离经过根节点：距离 = 左子树深度 + 右子树深度 NSInteger distance = [self depthOfTree:rootNode.leftNode] + [self depthOfTree:rootNode.rightNode]; //2、最远距离在根节点左子树上，即计算左子树最远距离 NSInteger disLeft = [self maxDistanceOfTree:rootNode.leftNode]; //3、最远距离在根节点右子树上，即计算右子树最远距离 NSInteger disRight = [self maxDistanceOfTree:rootNode.rightNode]; return MAX(MAX(disLeft, disRight), distance);&#125; 这个方案效率较低，因为计算子树的深度和最远距离是分开递归的，存在重复递归遍历的情况。其实一次递归，就可以分别计算出深度和最远距离，于是有了第二种方案： 123456789101112131415161718192021222324252627282930313233343536373839/** * 二叉树最大距离（直径） * * @param rootNode 根节点 * * @return 最大距离 */+ (NSInteger)maxDistanceOfTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return 0; &#125;// 方案2：将计算节点深度和最大距离放到一次递归中计算，方案一是分别单独递归计算深度和最远距离 TreeNodeProperty *p = [self propertyOfTreeNode:rootNode]; return p.distance;&#125;/** * 计算树节点的最大深度和最大距离 * * @param rootNode 根节点 * * @return TreeNodeProperty */+ (TreeNodeProperty *)propertyOfTreeNode:(BinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return nil; &#125; TreeNodeProperty *left = [self propertyOfTreeNode:rootNode.leftNode]; TreeNodeProperty *right = [self propertyOfTreeNode:rootNode.rightNode]; TreeNodeProperty *p = [TreeNodeProperty new]; //节点的深度depth = 左子树深度、右子树深度中最大值+1（+1是因为根节点占了1个depth） p.depth = MAX(left.depth, right.depth) + 1; //最远距离 = 左子树最远距离、右子树最远距离和横跨左右子树最远距离中最大值 p.distance = MAX(MAX(left.distance, right.distance), left.depth+right.depth); return p;&#125; 二叉树中某个节点到根节点的路径既是寻路问题，又是查找节点问题。 定义一个存放路径的栈（不是队列了，但是还是用可变数组来实现的） 1）压入根节点，再从左子树中查找（递归进行的），如果未找到，再从右子树中查找，如果也未找到，则弹出根节点，再遍历栈中上一个节点。 2）如果找到，则栈中存放的节点就是路径所经过的节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 二叉树中某个节点到根节点的路径 * * @param treeNode 节点 * @param rootNode 根节点 * * @return 存放路径节点的数组 */+ (NSArray *)pathOfTreeNode:(BinaryTreeNode *)treeNode inTree:(BinaryTreeNode *)rootNode &#123; NSMutableArray *pathArray = [NSMutableArray array]; [self isFoundTreeNode:treeNode inTree:rootNode routePath:pathArray]; return pathArray;&#125;/** * 查找某个节点是否在树中 * * @param treeNode 待查找的节点 * @param rootNode 根节点 * @param path 根节点到待查找节点的路径 * * @return YES：找到，NO：未找到 */+ (BOOL)isFoundTreeNode:(BinaryTreeNode *)treeNode inTree:(BinaryTreeNode *)rootNode routePath:(NSMutableArray *)path &#123; if (!rootNode || !treeNode) &#123; return NO; &#125; //找到节点 if (rootNode == treeNode) &#123; [path addObject:rootNode]; return YES; &#125; //压入根节点，进行递归 [path addObject:rootNode]; //先从左子树中查找 BOOL find = [self isFoundTreeNode:treeNode inTree:rootNode.leftNode routePath:path]; //未找到，再从右子树查找 if (!find) &#123; find = [self isFoundTreeNode:treeNode inTree:rootNode.rightNode routePath:path]; &#125; //如果2边都没查找到，则弹出此根节点 if (!find) &#123; [path removeLastObject]; &#125; return find;&#125; 二叉树中两个节点最近的公共父节点首先需要明白，根节点肯定是二叉树中任意两个节点的公共父节点（不一定是最近的），因此二叉树中2个节点的最近公共父节点一定在从根节点到这个节点的路径上。因此我们可以先分别找到从根节点到这2个节点的路径，再从这两个路径中找到最近的公共父节点。 1234567891011121314151617181920212223242526272829303132333435/** * 二叉树中两个节点最近的公共父节点 * * @param nodeA 第一个节点 * @param nodeB 第二个节点 * @param rootNode 二叉树根节点 * * @return 最近的公共父节点 */+ (BinaryTreeNode *)parentOfNode:(BinaryTreeNode *)nodeA andNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode || !nodeA || !nodeB) &#123; return nil; &#125; if (nodeA == nodeB) &#123; return nodeA; &#125; //从根节点到节点A的路径 NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode]; //从根节点到节点B的路径 NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode]; //其中一个节点不在树中，则没有公共父节点 if (pathA.count == 0 || pathB == 0) &#123; return nil; &#125; //从后往前推，查找第一个出现的公共节点 for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123; for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123; if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123; //找到 return [pathA objectAtIndex:i]; &#125; &#125; &#125; return nil;&#125; 二叉树中两个节点之间的路径从查找最近公共父节点衍生出来的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 二叉树中两个节点之间的路径 * * @param nodeA 第一个节点 * @param nodeB 第二个节点 * @param rootNode 二叉树根节点 * * @return 两个节点间的路径 */+ (NSArray *)pathFromNode:(BinaryTreeNode *)nodeA toNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode || !nodeA || !nodeB) &#123; return nil; &#125; NSMutableArray *path = [NSMutableArray array]; if (nodeA == nodeB) &#123; [path addObject:nodeA]; [path addObject:nodeB]; return path; &#125; //从根节点到节点A的路径 NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode]; //从根节点到节点B的路径 NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode]; //其中一个节点不在树中，则没有路径 if (pathA.count == 0 || pathB == 0) &#123; return nil; &#125; //从后往前推，查找第一个出现的公共节点 for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123; [path addObject:[pathA objectAtIndex:i]]; for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123; //找到公共父节点，则将pathB中后面的节点压入path if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123; j++; //j++是为了避开公共父节点 while (j&lt;pathB.count) &#123; [path addObject:[pathB objectAtIndex:j]]; j++; &#125; return path; &#125; &#125; &#125; return nil;&#125; 二叉树两个节点之间的距离可以从两个节点之间的路径衍生出来。 123456789101112131415161718192021222324252627282930313233343536/** * 二叉树两个节点之间的距离 * * @param nodeA 第一个节点 * @param nodeB 第二个节点 * @param rootNode 二叉树根节点 * * @return 两个节点间的距离（-1：表示没有找到路径） */+ (NSInteger)distanceFromNode:(BinaryTreeNode *)nodeA toNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode || !nodeA || !nodeB) &#123; return -1; &#125; if (nodeA == nodeB) &#123; return 0; &#125; //从根节点到节点A的路径 NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode]; //从根节点到节点B的路径 NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode]; //其中一个节点不在树中，则没有路径 if (pathA.count == 0 || pathB == 0) &#123; return -1; &#125; //从后往前推，查找第一个出现的公共节点 for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123; for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123; //找到公共父节点 if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123; //距离=路径节点数-1 （这里要-2，因为公共父节点重复了一次） return (pathA.count - i) + (pathB.count - j) - 2; &#125; &#125; &#125; return -1;&#125; 判断二叉树是否完全二叉树完全二叉树定义为：若设二叉树的高度为h，除第h层外，其它各层的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布。 完全二叉树必须满足2个条件： 1）如果某个节点的右子树不为空，则它的左子树必须不为空 2）如果某个节点的右子树为空，则排在它后面的节点必须没有孩子节点 这里还需要理解“排在它后面的节点”，回头看看层次遍历算法，我们就能知道在层次遍历时，是从上到下从左到右遍历的，先将根节点弹出队列，再压入孩子节点，因此“排在它后面的节点”有2种情况： 1）同层次的后面的节点 2）同层次的前面的节点的孩子节点（因为遍历前面的节点时，会弹出节点，同时将孩子节点压入队列） 通过上面的分析，我们可以设置一个标志位flag，当子树满足完全二叉树时，设置flag&#x3D;YES。当flag&#x3D;YES而节点又破坏了完全二叉树的条件，那么它就不是完全二叉树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 是否完全二叉树 * 完全二叉树：若设二叉树的高度为h，除第h层外，其它各层的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布 * * @param rootNode 根节点 * * @return YES：是完全二叉树，NO：不是完全二叉树 */+ (BOOL)isCompleteBinaryTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return NO; &#125; //左子树和右子树都是空，则是完全二叉树 if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123; return YES; &#125; //左子树是空，右子树不是空，则不是完全二叉树 if (!rootNode.leftNode &amp;&amp; rootNode.rightNode) &#123; return NO; &#125; //按层次遍历节点，找到满足完全二叉树的条件： //条件1：如果某个节点的右子树不为空，则它的左子树必须不为空 //条件2：如果某个节点的右子树为空，则排在它后面的节点必须没有孩子节点 //排在该节点后面的节点有2种：1）同层次的后面的节点 2）同层次的前面的节点的孩子节点（因为遍历前面的节点的时候，会将节点从队列里pop，同时把它的孩子节点push到队列里） NSMutableArray *queue = [NSMutableArray array]; [queue addObject:rootNode]; BOOL isComplete = NO; //是否已经满足完全二叉树 while (queue.count &gt; 0) &#123; BinaryTreeNode *node = [queue firstObject]; [queue removeObjectAtIndex:0]; //左子树为空且右子树不为空，则不是完全二叉树 if (!node.leftNode &amp;&amp; node.rightNode) &#123; return NO; &#125; if (isComplete &amp;&amp; (node.leftNode || node.rightNode)) &#123; //前面的节点已满足完全二叉树,如果还有孩子节点，则不是完全二叉树 return NO; &#125; //右子树为空，则已经满足完全二叉树 if (!node.rightNode) &#123; isComplete = YES; &#125; //压入 if (node.leftNode) &#123; [queue addObject:node.leftNode]; &#125; if (node.rightNode) &#123; [queue addObject:node.rightNode]; &#125; &#125; return isComplete;&#125; 判断二叉树是否满二叉树 满二叉树定义为：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树 满二叉树的一个特性是：叶子数&#x3D;2^(深度-1)，因此我们可以根据这个特性来判断二叉树是否是满二叉树。 123456789101112131415161718192021222324/** * 是否满二叉树 * 满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树 * * @param rootNode 根节点 * * @return YES：满二叉树，NO：非满二叉树 */+ (BOOL)isFullBinaryTree:(BinaryTreeNode *)rootNode &#123; if (!rootNode) &#123; return NO; &#125; //二叉树深度 NSInteger depth = [self depthOfTree:rootNode]; //二叉树叶子节点数 NSInteger leafNum = [self numberOfLeafsInTree:rootNode]; //满二叉树特性：叶子数=2^(深度-1) if (leafNum == pow(2, (depth - 1))) &#123; return YES; &#125; return NO;&#125; 判断二叉树是否平衡二叉树平衡二叉树定义为：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树又叫AVL树。 12345678910111213141516171819202122232425262728293031/** * 是否平衡二叉树 * 平衡二叉树：即AVL树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树 * * @param rootNode 根节点 * * @return YES：平衡二叉树，NO：非平衡二叉树 */+ (BOOL)isAVLBinaryTree:(BinaryTreeNode *)rootNode &#123; static NSInteger height; if (!rootNode) &#123; height = 0; return YES; &#125; if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123; height = 1; return YES; &#125; BOOL isAVLLeft = [self isAVLBinaryTree:rootNode.leftNode]; NSInteger heightLeft = height; BOOL isAVLRight = [self isAVLBinaryTree:rootNode.rightNode]; NSInteger heightRight = height; height = MAX(heightLeft, heightRight)+1; if (isAVLLeft &amp;&amp; isAVLRight &amp;&amp; ABS(heightLeft-heightRight) &lt;= 1) &#123; return YES; &#125; return NO;&#125; 总结 以上就是我目前整理的一些二叉树相关的算法，算法资料和思想都来源于网络，如有错误，欢迎指正！后续如果有新的算法，我也会更新进去。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.bboyzj.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"OC-数据结构探索篇","slug":"OC-数据结构探索篇","permalink":"https://www.bboyzj.cn/tags/OC-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.bboyzj.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"OC算法04：二分查找探索","slug":"OC数据结构和算法/OC算法04：二分查找探索","date":"2020-08-26T08:34:46.000Z","updated":"2023-03-06T10:17:20.158Z","comments":true,"path":"2020/08/26/OC数据结构和算法/OC算法04：二分查找探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/26/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9504%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"二分查找 简介 二分查找(也称折半查找)是很常见的一种在数组中查找数据的算法,作为一名程序员是应该必须会的。 基本思想 获取数组的中间值，将数组分割成两份，利用查找的值跟中间值进行比较，如果查找的值大于中间值，就在数组的右边进行查找；如果查找的值小于中间值，就在数组的左边进行查找。如此循环的执行下去，最终找到符合的值。 优缺点 1）优点： 速度快 比较次数少 性能好 2）缺点： 必须是一个有序的数组（升序或者降序） 适用范围：适用不经常变动的数组 复杂度 时间复杂度就变成了O(logN) 具体代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748- (void)viewDidLoad &#123; [super viewDidLoad]; NSArray * arr = @[@1,@3,@5,@6,@8,@15,@20]; NSInteger result = [self binarySearchTarget:@1 inArray:arr]; NSLog(@&quot;%ld&quot;,(long)result);&#125;// 在某个数组中搜索目标- (NSInteger)binarySearchTarget:(NSNumber *)target inArray:(NSArray *)arr&#123; //如果数组无元素，则返回 if (arr.count &lt; 1) &#123; return -1; &#125; //如果数组有元素 //定义三个变量 第一个值下标、最后一个值下标、中间值下标 NSInteger start = 0; NSInteger end = arr.count - 1; NSInteger mid = 0; //如果开始和结束中间还有元素，则循环 while (start &lt; end - 1) &#123; //会有一些朋友看到有些人是( start + end ) / 2这样写的,但是这样写有一点不好,就是start+end会出现整数溢出的情况,如果存在溢出,你再除以2也是没有用的,所以不能这么写 mid = start + (end - start) / 2; //如果中间值大于目标值 if ([arr[mid] intValue] &gt; [target intValue]) &#123; //中间值做为最后一个值，在前半段再进行相同的搜索 end = mid; &#125; //如果中间值小于或等于目标值 else &#123; start = mid; &#125; &#125; //考虑到边界问题，所以下面这俩个必须写 //如果第一个值和目标值相等则获取第一个值的下标 if ([arr[start] intValue] == [target intValue]) &#123; return start; &#125; //如果最后一个值和目标值相等则获取最后一个值的下标 if ([arr[end] intValue] == [target intValue]) &#123; return end; &#125; return -1;&#125; 查看打印结果 122020-08-26 18:06:44.754180+0800 iOS-OC之二分查找[49535:2738585] 0","categories":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"OC-算法探索篇","slug":"OC-算法探索篇","permalink":"https://www.bboyzj.cn/tags/OC-%E7%AE%97%E6%B3%95%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"OC算法05：选择排序探索","slug":"OC数据结构和算法/OC算法05：选择排序探索","date":"2020-08-26T04:20:18.000Z","updated":"2023-03-06T10:17:23.942Z","comments":true,"path":"2020/08/26/OC数据结构和算法/OC算法05：选择排序探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/26/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9505%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"选择排序 基本思路：选择排序（Selection sort）是最基本的 O(n^2) 的排序算法，它的原理是每一次从待排序的数据元素中 选出最小或最大 的一个元素，存放在序列的起始位置，然后，再从 剩余未排序的元素当中继续寻找最小或大的元素， 然后放到未排序的末尾，以此类推，直到全部待排序的数据元素排完。 稳定性 选择排序是不稳定的排序方法。 主要流程：从小到大 第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换； 第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换； 以此类推，第i趟在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，使有序序列不断增长直到全部排序完毕。 具体代码 123456789101112131415161718192021222324252627- (void)viewDidLoad &#123; [super viewDidLoad]; [self selectionSortWithArr:[NSMutableArray arrayWithArray:@[@3,@1,@2,@5,@4]]];&#125;// 选择排序- (void)selectionSortWithArr:(NSMutableArray *)arr&#123; // 开始时间 double startTime = CFAbsoluteTimeGetCurrent(); // 外层遍历 for (int i = 0; i&lt; arr.count; i++) &#123; int minIndex = i; // 内层遍历 for (int j = i + 1; j &lt; arr.count; j++) &#123; // 获取最小下标 if ([arr[j] intValue]&lt; [arr[minIndex] intValue]) &#123; minIndex = j; &#125; &#125; //交换位置 [arr exchangeObjectAtIndex:i withObjectAtIndex:minIndex]; &#125; double endTime = CFAbsoluteTimeGetCurrent(); NSLog(@&quot;%@&quot;,arr); NSLog(@&quot;选择排序用时:%f s&quot;,endTime - startTime);&#125; 查看打印结果 1234567892020-08-26 17:11:21.653476+0800 OC-选择排序[48845:2694230] ( 1, 2, 3, 4, 5)2020-08-26 17:11:21.653672+0800 OC-选择排序[48845:2694230] 选择排序用时:0.000003 s","categories":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"OC-算法探索篇","slug":"OC-算法探索篇","permalink":"https://www.bboyzj.cn/tags/OC-%E7%AE%97%E6%B3%95%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"Swift学习：OC项目引入swift","slug":"Swift/Swift学习：OC项目引入swift","date":"2020-08-22T14:33:06.000Z","updated":"2023-03-08T22:16:57.810Z","comments":true,"path":"2020/08/22/Swift/Swift学习：OC项目引入swift/","link":"","permalink":"https://www.bboyzj.cn/2020/08/22/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9AOC%E9%A1%B9%E7%9B%AE%E5%BC%95%E5%85%A5swift/","excerpt":"","text":"在项目开发中，多人合作时，有可能遇到同事是主 swift 开发，而自己是主 OC 开发，这时如果是以 OC 语言为主，swift 语言为辅，那么就需要了解如何让 OC 引入 swift 创建桥接文件 注：在项目中我们第一次创建 swift 文件时，xcode 会提示我们创建，点击创建即可 此时，我们可以把 swift file 文件删掉，然后创建自己需要的文件， 此时我们看列表，发现桥接文件 项目名-Bridging-Header.h 配置 builder setting 除了上述桥接文件，还有一个隐藏文件 项目名-Swift，在 OC 调用 swift 的时候会用到，在列表中不显示 注：这个名字可以改写成自己想要的 Swift.h 创建swift文件，供OC调用 创建swift文件，Test继承NSObject 和 TestViewController继承UIViewController 分别添加一个方法，在swift文件中，方法前要加上 @objc，不然 OC 无法调用 调用在 OC 的 pch 文件下，导入隐藏生成的 swift.h，这样就可以全局使用，不需要每次都导入 在 ViewController 中使用","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习00：简介","slug":"Swift课程/Swift学习00：简介","date":"2020-08-22T13:17:43.000Z","updated":"2023-03-09T07:21:13.177Z","comments":true,"path":"2020/08/22/Swift课程/Swift学习00：简介/","link":"","permalink":"https://www.bboyzj.cn/2020/08/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A000%EF%BC%9A%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Swift介绍Swift是Apple在2014年6月WWDC发布的全新的编程语言。 Swift是一种高性能系统编程语言，提供了对现有C和OC代码框架的无缝访问，并且是内存安全的。 Swift语言更加简洁，是一门类型安全的语言。 Swift和OC的区别 编程范式 Swift可以 面试协议编程、函数式编程和面向对象编程 OC以 面向对象编程 为主，当然你可以引入 Reactive Cocoa 的类库来进行函数式编程 类型安全 Swift是一门 类型安全的语言。鼓励程序员在代码中清楚明确值的类型。如果代码中使用一个字符串String，那么你不能错误地传递一个整型Int给它。因为Swift是类型安全的，它会在代码编译的时候做类型检查，并且把所有不匹配的类型作为一个错误标记出来。这样使得程序员在开发中尽可能早地发现和修正错误。 而OC则 不是类型安全的语言，你声明一个NSString变量，仍然可以传递一个NSNumber给它，尽管编译器会抱怨，但是你仍然可以作为NSNumber来使用它。 值类型的增强 在Swift中，典型的有 struct、enum 以及 元祖tuple 都是值类型。而平时使用的Int、Double、Float 、String 、Array 、Dictionary、Set其实都是用结构体实现的，也是 值类型。 OC中，NSNumber、NSString以及集合类对象都是指针类型。 枚举增强 Swift的枚举可以使用 整型、浮点型、字符串等，还能拥有 属性和方法，甚至支持 泛型、协议、扩展等。 OC里面的枚举则鸡肋很多。 泛型 Swift中 支持泛型，也支持泛型的类型约束等特性 苹果推出了Swift2.0版本，为了让开发者从OC更好的国度到Swift上，苹果也为OC带来了Gennerics泛型支持，不过OC的泛型约束也仅停留在编译器警告阶段。 协议和扩展 Swift对协议的支持更加丰富，配合扩展（extension）、泛型、关联类型等可以实现面向协议编程，从而大大提高代码的灵活性。同时swift中的protocol还可以用于值类型，如结构体和枚举 OC的协议却反强约束，提供optional特性往往成为很多问题得来源，而如果放弃optional又会让实现代价过大。 函数和闭包 Swift函数是一等公民，可以直接定义函数类型变量，可以作为其他函数参数传递，可以作为函数的返回值类型。 OC里面函数仍然是次等公民，需要selector封装或者使用block才能模拟Swift中类似的效果。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-课程篇","slug":"Swift-课程篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"OCRuntime04：Runtime实际应用","slug":"OCRuntime&Runloop/OCRuntime04：Runtime实际应用","date":"2020-08-18T07:23:24.000Z","updated":"2023-02-15T16:48:28.816Z","comments":true,"path":"2020/08/18/OCRuntime&Runloop/OCRuntime04：Runtime实际应用/","link":"","permalink":"https://www.bboyzj.cn/2020/08/18/OCRuntime&Runloop/OCRuntime04%EF%BC%9ARuntime%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/","excerpt":"","text":"Runtime实际应用1.runtime交换方法场景：当第三方框架或者系统原生的方法不满足需求的时候，可以在不改动原有方法的基础上，添加额外的功能。 方式：利用 OC 的 runtime 机制 代码示例： 123456789101112131415161718192021222324252627#import &quot;UIImage+A.h&quot;#import &quot;objc/runtime.h&quot;@implementation UIImage (A)/* 作用：把类加载进内存的时候调用,只会调用一次 调用：方法应先交换，再去调用 */+ (void)load&#123; //1.获取image方法地址 Method originMethod = class_getClassMethod(self, @selector(imageNamed:)); //2.获取zl_imageNamed方法地址 Method newMethod = class_getClassMethod(self, @selector(zj_imageNamed:)); //3.交换方法地址 method_exchangeImplementations(originMethod, newMethod);&#125;// 加载图片 且 带判断是否加载成功+ (UIImage *)zj_imageNamed:(NSString *)name&#123; UIImage * img = [UIImage zj_imageNamed:name]; if (img) &#123; NSLog(@&quot;runtime交互方法 -&gt; 图片加载成功&quot;); &#125;else &#123; NSLog(@&quot;runtime交互方法 -&gt; 图片加载失败&quot;); &#125; return img;&#125;@end 2.Runtime给分类添加属性场景：给系统的类添加额外属性的时候 原理：利用 OC 的 runtime机制。 代码示例： 123456789101112131415161718192021222324252627282930@interface Person (A)@property (nonatomic,copy)NSString * name;@property (nonatomic,assign)int age;@end#import &quot;Person+A.h&quot;#import &quot;objc/runtime.h&quot;@implementation Person (A)// 1.String类型// 我们需要在.m里声明这个keystatic void * name_key = &amp;name_key;- (void)setName:(NSString *)name&#123; objc_setAssociatedObject(self, name_key, name, OBJC_ASSOCIATION_COPY);&#125;- (NSString *)name&#123; return objc_getAssociatedObject(self, name_key);&#125;// 2.Int型// 我们需要在.m里声明这个keystatic void * age_key = &amp;age_key;- (void)setAge:(int)age&#123; objc_setAssociatedObject(self, age_key, @(age), OBJC_ASSOCIATION_ASSIGN);&#125;- (int)age&#123; NSNumber * number = objc_getAssociatedObject(self, age_key); return [number intValue];&#125;@end 3.动态添加方法场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。 原理：利用 OC 的 runtime机制，使用 performSelector 添加方法，相当于懒加载机制 代码示例： 123456789101112131415161718192021222324252627282930313233#import &quot;ZJPerson.h&quot;#import &quot;objc/runtime.h&quot;@implementation ZJPerson// 当一个方法没有实现，但是又调用了，就会调用调用下面的方法+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if (sel == @selector(eat))&#123; /** class 给哪个类添加方法 SEL 方法编码 IMP 方法实现，就是一个函数指针 type 方法类型，苹果官方文档可以查看 */ class_addMethod([ZJPerson class], sel, (IMP)eat, &quot;v@:&quot;); &#125;else if (sel == @selector(play:))&#123; class_addMethod([ZJPerson class], sel, (IMP)play, &quot;v@:@&quot;); &#125; return [super resolveInstanceMethod:sel];&#125;// 定义函数/* 一个方法默认都有两个参数：self _cmd(隐士参数) self：方法调用者 _cmd：调用方法的编号 */void eat(id self, SEL _cmd) &#123; NSLog(@&quot;调用了%@的%@方法&quot;,self,NSStringFromSelector(_cmd));&#125;void play(id self, SEL _cmd, id objc) &#123; NSLog(@&quot;调用了%@的%@方法 Play%@&quot;,self,NSStringFromSelector(_cmd),objc);&#125;@end 4.Runtime字典转模型思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值（从提醒：字典中取值，不一定要全部取出来）；提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类实现字典转模型。 考虑情况：1.当字典的key和模型的属性匹配不上。2.模型中嵌套模型（模型属性是另外一个模型对象）。3.数组中装着模型（模型的属性是一个数组，数组中是一个个模型对象）。 5.实现NSCoding的归档接档原理描述：用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。核心方法：在Model的基类中重写方法： 123456789101112131415161718192021222324- (id)initWithCoder:(NSCoder *)aDecoder &#123; if (self = [super init]) &#123; unsigned int outCount; Ivar * ivars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar ivar = ivars[i]; NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)]; [self setValue:[aDecoder decodeObjectForKey:key] forKey:key]; &#125; free(ivars); &#125; return self;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder &#123; unsigned int outCount; Ivar * ivars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar ivar = ivars[i]; NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)]; [aCoder encodeObject:[self valueForKey:key] forKey:key]; &#125; free(ivars);&#125;","categories":[{"name":"OC-Runloop探索篇","slug":"OC-Runloop探索篇","permalink":"https://www.bboyzj.cn/categories/OC-Runloop%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-Runloop探索篇","slug":"OC-Runloop探索篇","permalink":"https://www.bboyzj.cn/categories/OC-Runloop%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"iOS-OC之性能检测工具Network探索","slug":"OC性能优化/OC性能优化04：Network探索","date":"2020-08-14T04:13:45.000Z","updated":"2023-02-14T07:53:01.165Z","comments":true,"path":"2020/08/14/OC性能优化/OC性能优化04：Network探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/14/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604%EF%BC%9ANetwork%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"弱网优化 所谓弱网络，指在网络不好的情况下使用APP，如 2G、3G网络，用户的网络速度基本在 10k/s~60k/s。 考虑海外应用的话，就必须考虑弱网优化的方案了。 苹果建议，使用苹果内置的 Network Link Conditioner 来模拟网络环境处理 APP 的体验问题，在Xcode 和 手机都可以开启 Xcode：系统偏好设置iPhone：开发者 -&gt; Network Link Conditioner","categories":[{"name":"OC-性能优化探索篇","slug":"OC-性能优化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-性能优化探索篇","slug":"OC-性能优化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"iOS-OC之Energy Log探索","slug":"OC性能优化/OC性能优化03：Energy-Log探索","date":"2020-08-14T04:13:29.000Z","updated":"2020-10-17T05:10:17.000Z","comments":true,"path":"2020/08/14/OC性能优化/OC性能优化03：Energy-Log探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/14/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603%EF%BC%9AEnergy-Log%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"概述所有应用程序在执行网络操作、更新用户界面或在CPU上运行代码时都会消耗能量。随着用户越来越多地依赖电池电量，以及应用程序的激增，能效已成为用户体验中不可或缺的一部分。 电池寿命随着能源效率的下降，电池的寿命也会下降。同时消耗过多的资源会导致界面滞后，对用户输入的响应会很慢。随着越来越多的应用程序使用越来越多的资源，系统工作起来越来越努力，速度也越来越快，设备的物理温度也在逐渐升高。当这种情况发生时，系统会采取措施将温度降低到更容易接受的水平。 能量消耗的因素1.CPU: CPU是能源的主要消耗者。高CPU使用周期会迅速耗尽用户的电池。 CPU使用率超过20%就会快速耗干电池电量——建议只在必要时通过批处理、调度和优先级排序来完成工作。 2.Network：大多数iOS应用程序执行网络操作。当联网发生时，蜂窝无线电和Wi-Fi等组件就会启动并消耗能量。通过批量处理和减少事务、压缩数据和适当处理错误，您的应用程序可以为节能做出重大贡献。 3.GPU: 图形处理器(显卡的处理器),乱使用GPU会导致交互差,并且降低电池寿命。 4.Location: 许多应用程序发出位置请求是为了记录用户的物理活动或提供基于环境的警报。能量消耗随着精确度的提高和位置请求的延长而增加。你的应用应该尽可能减少定位活动的准确性和持续时间。当不再需要时停止位置请求。 5.Background: 后台状态App仍会消耗电量,App要按需执行后台操作,并使用延迟APNS来保证系统运算高效执行.另外,在app进入后台状态是,立即减少动作,并且通知系统一次这些动作已经完成. 6.Bluetooth: 长时间的蓝牙活动会耗尽iOS设备和蓝牙设备的电池。只要可能，批处理和缓冲蓝牙活动，并减少对数据的轮询。 7.Device wakes：iOS设备依靠睡眠来延长电池寿命。无论设备何时唤醒，都会有很高的开销成本，因为必须为屏幕和其他资源提供电源。你的应用程序，尤其是在后台操作时，应该尽可能空闲，除非绝对必要，避免用推送通知或其他活动唤醒设备 分析工具1.Time Profile:时间分析器分析模板。使用此模板对正在运行的进程执行低开销的基于时间的采样。Time Profiler 监视应用程序中正在运行的线程，并定期采样。为每个样本收集完整的回溯，允许您深入查看样本，以准确找到代码中花费大量时间的位置。 2.Core Animation:核心动画分析模板。使用此模板可以测量图形性能和CPU使用率。启用模板 Core Animation 的Flash Updated Regions 设置，以查看应用中发生的每个屏幕更新，并观察不必要或意外的更新。 3.Activity Monitor: 活动监视器分析模板。使用此模板可以监视整体CPU，磁盘I&#x2F;O和网络使用情况。 Energy log调试和演示1.检查第一步，是通过xcode开发工具的energy impact来整体查看app的耗电情况。 Overhead：表示开销,包括CPU的唤起,无线电模组(蓝牙&amp;WiFi),和其他系统资源的调用等。 2.检查第二步：通过instrument工具的energy log来检测具体的耗电模块。 3.降低能量消耗举例1）CPU Timer的时间间隔不宜太短,满足需求即可 线程适量,不宜过多,不要阻塞主线程 优化算法,减少循环次数 适当使用多线程 避免庞大的xib,storyBoard,尽量使用纯代码开发 2）网络请求 识别：确保不重复做同一个操作； 优化：使用后台会话 合并：批处理事务 减少：最小化重试，缓存结构优化等等 3)GPU 减少视图刷新：确保必要的时候才刷新，能刷新1行cell最好只刷新一行； 审查模糊用法：避免将模糊放在更新元素上，尽量少使用圆角和透明度； 尽量减少使用离散GPU除非动画效果需要，或功能不能支持的情况下 4)Location, Bluetooth, Background 定位和蓝牙按需取用,定位之后要关闭或降低定位频率，进入后台关闭定位，停止定时器运行等","categories":[{"name":"OC-性能优化探索篇","slug":"OC-性能优化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-性能优化探索篇","slug":"OC-性能优化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"iOS-OC之性能检测工具Animation Hitches探索","slug":"OC性能优化/OC性能优化02：Animation Hitches探索","date":"2020-08-14T04:12:50.000Z","updated":"2023-02-11T03:08:08.772Z","comments":true,"path":"2020/08/14/OC性能优化/OC性能优化02：Animation Hitches探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/14/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602%EF%BC%9AAnimation%20Hitches%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"Animation Hitches 前言Instrument 新增 Animation Hieches 监测类型用于监测 卡顿，去掉了 Core Animation 检测方式。 Animation Hitches 简介卡顿时间比(Hitch Time Ratio) 的概念用于替代 FPS，iPhone13Pro之前屏幕刷最高刷新率仍为60HZ，iPhone13Pro及以上帧率调整到120HZ 调试页面渲染性能所以，现在可以不用打开Instruments也可以。 Color Blended Layer 图层混合 什么是图层混合：界面都是由多个UI控件 叠加 的，如果有 透明或半透明 的控件，GPU会计算显示颜色，损耗GPU资源。 解决办法：打开 color Blended Layer 选项，显示 红色则出现图层混合；我们调试的目的就是把红色区域消减的越少越好，只要 设置控件不透明 即可。 12label.background = [UIColor whiteColor];label.layer.masksToBounds = YES; Color Hits Green and Misses Red（光栅化） 检测是否正确的使用 layer 的 shouldRasterize 属性，shouldRasterize &#x3D; YES开启光栅化。 什么是光栅化？ 光栅化是将一个layer预先渲染成 位图(bitmap)，再加入到缓存中，成功被缓存的layer会标注为绿色,没有成功缓存的会标注为 红色，正确使用光栅化可以得到一定程度的性能提升。 适用情况：一般在图像内容不变的情况下才使用光栅化，例如设置阴影耗费资源比较多的 静态内容，如果 使用光栅化 对性能的提升有一定帮助。 非适用情况：如果 内容会经常变动,这个时候不要开启,否则会造成性能的浪费。 例如我们在使用tableViewCell中，一般 不要用光栅化，因为tableViewCell的绘制非常频繁，内容在不断的变化，如果使用了光栅化，会造成大量的离屏渲染降低性能。 Color Copied Images（图片颜色格式） 拷贝给CPU进行转化的图片显示为绿：GPU不支持当前图片的颜色格式，那么就会将图片交给CPU预先进行格式转化，并且这张图片标记为蓝色 Color Misaligned Images(图片大小) 图片大小 和 imageView size 不匹配，会出现 黄色，消耗资源压缩图片 Color Offscreen-Rendered Yellow（离屏渲染） 触发离屏渲染的操作： drawRect layer.shadow layer.shouldRasterize layer.mask layer.masksToBounds 和 layer.cornerRadius 同时使用等","categories":[{"name":"OC-性能优化探索篇","slug":"OC-性能优化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-性能优化探索篇","slug":"OC-性能优化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"iOS-OC之Time Profiler探索","slug":"OC性能优化/OC性能优化05：Time-Profiler探索","date":"2020-08-14T04:12:30.000Z","updated":"2023-02-08T09:39:54.838Z","comments":true,"path":"2020/08/14/OC性能优化/OC性能优化05：Time-Profiler探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/14/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605%EF%BC%9ATime-Profiler%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"Time Profiler简介Time Profiler见名知意：CPU分析工具-时间分析工具，它会按照设定的时间间隔（默认1毫秒）来跟踪每一线程的堆栈信息（stacktrace），并通过比较时间间隔之间的堆栈状态，来推算出某个方法执行了多久，给出一个近似值。 Time Profiler使用须知当点击Time Profiler应用程序开始运行后.就能获取到整个应用程序运行消耗时间分布和百分比.为了保证数据分析在统一使用场景真实行有如下点需要注意: 在开始进行应用程序性能分析的时候,一定要使用真机,模拟器运行在Mac上，然而Mac上的CPU往往比iOS设备要快。相反，Mac上的GPU和iOS设备的完全不一样，模拟器不得已要在软件层面（CPU）模拟设备的GPU，这意味着GPU相关的操作在模拟器上运行的更慢，尤其是使用CAEAGLLayer来写一些OpenGL的代码时候. 这就导致模拟器性能数据和用户真机使用性能数据相去甚运. 另外在开始性能分析前另外一件重要的事情是，应用程序运行一定要Release版本 而不是Debug版本. 在发布环境打包的时候，编译器会引入一系列提高性能的优化，例如去掉调试符号或者移除并重新组织代码.另iOS引入一种”Watch Dog”[看门狗]机制.不同的场景下，“看门狗”会监测应用的性能。如果超出了该场景所规定的运行时间，“看门狗”就会强制终结这个应用的进程.开发者可以crashlog看到对应的日志.但Xcode在调试配置下会禁用”Watch Dog”。 Time Profiler的使用 首先用Xcode打开你的项目。比如我的项目FJReading。 修改Edit Scheme为Release版本如下: 因为Release环境下的才是正确的配置： 打开Instrument -&gt; Time Profiler 界面的整体如下: weight: 整体运行时长和比例 self weight:自己代码的运行时长和比例 Symbol Name:被调用函数的符号信息,可以切换为实际调用的方法 选择真机和你要调试的App 点击Start按钮，Time Profiler就开始记录App的运行情况 可以看到在CPU使用过高的位置对应的具体调用栈 打开Time Profiler调试工具进入到调试界面,选择你的真机和项目，点击左上角红色原点（启动程序按钮）之后便可以看到如下图的时间消耗： CallTree选项介绍 但是我们发现这些信息只能显示到底层的线程Runloop耗时，并不能帮助我们定位到具体的代码中去，下面介绍CallTree选项的勾选操作以及含义。这些选项默认是不选的，但把它们勾选上可以帮你更快定位到关键的代码上，往往这也是问题的源头。 Separate by Thread（建议选择）：按线程分开做分析，这样更容易揪出那些吃资源的问题线程。特别是对于主线程，它要处理和渲染所有的接口数据，一旦受到阻塞，程序必然卡顿或停止响应。 Invert Call Tree（建议选择）：反向输出调用树。把调用层级最深的方法显示在最上面，更容易找到最耗时的操作。 Hide Missing Symbols（建议选择）：隐藏缺失符号。如果dSYM文件或其他系统架构缺失，列表中会出现很多奇怪的十六进制的数值，用此选项把这些干扰元素屏蔽掉，让列表回归清爽。 Hide System Libraries（建议选择）：隐藏系统库文件。过滤掉各种系统调用，只显示自己的代码调用。 Flattern Recursion（一般不选）：拼合递归。将同一递归函数产生的多条堆栈（因为递归函数会调用自己）合并为一条。 Top Functions（可选）：找到最耗时的函数或方法。 根据这些时间对应代码便可以做一些优化，减少重复的耗时逻辑优化CPU。我用上面的流程查看了我写的代码基本上是没有太耗时的操作，perfect。 写一个demo具体定位耗时 创建一个demo项目，写如下代码： 1234567891011121314- (void)viewDidLoad &#123; [super viewDidLoad]; //单元测试 NSDate * startDate = [NSDate date]; for (int i = 0; i &lt; 100000; i++) &#123; NSString *string = @&quot;123&quot;; string = [string stringByAppendingString:@&quot;abc&quot;]; NSLog(@&quot;%@&quot;, string); &#125; NSDate *endDate = [NSDate date]; NSTimeInterval interval = [endDate timeIntervalSinceDate:startDate]; NSLog(@&quot;time = %f&quot;,interval);&#125; 我们查看一下CPU耗时操作： 可以看到ViewController中占用大量的时间763ms，双击函数调用进入里面看看： 我们注释掉打印重新跑一遍代码看看效果 1234567for (int i = 0; i &lt; 100000; i++) &#123; @autoreleasepool &#123; NSString *string = @&quot;123&quot;; string = [string stringByAppendingString:@&quot;abc&quot;];// NSLog(@&quot;%@&quot;, string); &#125;&#125; 查看结果如下: 结论:由此可见，耗时操作明显下降了。","categories":[{"name":"OC-性能优化探索篇","slug":"OC-性能优化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-性能优化探索篇","slug":"OC-性能优化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"iOS-OC性能优化之Instruments工具初探","slug":"OC性能优化/OC性能优化01：Instruments工具初探","date":"2020-08-14T03:59:20.000Z","updated":"2020-10-17T05:10:08.000Z","comments":true,"path":"2020/08/14/OC性能优化/OC性能优化01：Instruments工具初探/","link":"","permalink":"https://www.bboyzj.cn/2020/08/14/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601%EF%BC%9AInstruments%E5%B7%A5%E5%85%B7%E5%88%9D%E6%8E%A2/","excerpt":"","text":"Xcode自带的检测调试工具InstrumentsInstruments提供了很多功能，我会重点介绍一下我最常用的几类： 1.Time Profiler：CPU分析工具分析代码的执行时间。 2.Core Animation：离屏渲染，图层混合等GPU耗时。 3.Leaks：内存检测，内存泄漏检测工具。但是不方便；使用MLeaksFinder三方库最好。 4.Energy Log：耗电检测工具。 5.Network：流量检测工具。 调试工具打开方式使用XCode自带的Instruments工具，可以通过如下的方式打开:方式一： 方式二： 最终看到如下的调试工具:","categories":[{"name":"OC-性能优化探索篇","slug":"OC-性能优化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-性能优化探索篇","slug":"OC-性能优化探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC：Charles探索","slug":"OC学习/OC学习18：Charles","date":"2020-08-13T12:33:43.000Z","updated":"2023-03-03T07:10:16.000Z","comments":true,"path":"2020/08/13/OC学习/OC学习18：Charles/","link":"","permalink":"https://www.bboyzj.cn/2020/08/13/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A018%EF%BC%9ACharles/","excerpt":"","text":"前言Charles是一款非常优秀的抓包工具，Charles不仅可以帮助我们抓取服务器返回的数据，还可以修改请求参数，修改响应体，还能模拟弱网络环境 应用一：Charles抓包iPhone上的HTTP1、Charles 上的设置点击Proxy -&gt; Proxy Setting -&gt; 端口Port填写 8888 -&gt; 勾选 Enable transparent HTTP proxying，如下图所示： 2、iPhone 上的设置1）首先，保证你的 iPhone 和 Mac上的 WiFi 要一致。2）其次，找到你链接的 WiFi，划到底部，配置HTTP代理，选择手动3）最后，填写 服务器IP(Mac面板-&gt;系统偏好设置-&gt;网络-&gt;状态下192.168.1.245) 和 端口号（上面配置的8888） 3、链接IP地址1）首先，打开Mac上的 Charles，iPhone 上打开任意联网的 APP2）其次，Charles就会弹出iPhone请求链接的确认弹窗，点击 Allow 即可完成设置,如下图： 4、查看Charles上你要截取的数据1）首先，打开Charles，找到Filter：输入过滤条件88882）其次，点击Contents，找到你要截取的数据，如下图： 应用二：Charles抓包HTTPS1、Charles上的设置抓取HTTPS需要电脑和手机安装证书（Help -&gt; SSL Proxying） 1）首先，打开Charles,找到Help -&gt; SSL Proxying，然后按照下图在 电脑 和 手机上 安装证书： 电脑上安装证书很简单，直接点击 Install Charles Root Certificate -&gt; 输入钥匙串密码 即可。 注：一般系统默认不信任Charles Proxy CA证书，打开 钥匙串-&gt; Charles Proxy CA -&gt; 始终信任，如下图： 手机上安装证书，点击上图的 Install Charles Root Certificate on a Mobile Device or Remote Browser，会给我们提示： 上面的提示框的意思是，在手机设置好代理（192.168.1.245）和 端口号（8888）后，在手机浏览器中访问 chls.pro/ssl 下载并安装证书，证书文件名是：charles-proxy-CA，证书下载完成后，在手机上安装该证书，打开phone手机：手机设置 -&gt; 通用 -&gt; 描述文件与设备管理 -&gt; Charles Proxy CA -&gt; 安装，并在 设置 -&gt; 关于手机 -&gt; 证书信任设值 -&gt; 开启完全信任 2）其次，电脑和手机上证书都安装完毕后，最后再设置一下 SSL Proxy -&gt; SSL Proxying Settings，就可以利用 Charles 抓包 https请求了 注： Host（主机地址）： * 代表全部的主机地址； Port（端口号）：默认403 应用三、Charles模拟慢网速1、首先，打开Charles -&gt; Proxy -&gt; Throttle Setting，进行设置，如下图： 2、其次，如果只想模拟指定网站的慢速网络，再勾选 only for selected hosts 项，然后在对话框的下部分设置中 add 指定的 hosts 项即可。","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.bboyzj.cn/tags/iOS/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OCRunloop02：runtime初探","slug":"OCRuntime&Runloop/OCRuntime01：runtime初探","date":"2020-08-11T15:25:14.000Z","updated":"2023-03-07T04:34:46.368Z","comments":true,"path":"2020/08/11/OCRuntime&Runloop/OCRuntime01：runtime初探/","link":"","permalink":"https://www.bboyzj.cn/2020/08/11/OCRuntime&Runloop/OCRuntime01%EF%BC%9Aruntime%E5%88%9D%E6%8E%A2/","excerpt":"","text":"Runtime简介Object_C 是一门动态语言，所以它总是想办法把一些决定工作 从编译器推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统 (runtime system) 来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个Objc运行框架的一块基石。 什么是Runtime？ 我们都知道，将源代码转换为可执行的程序，通常要经过四个步骤：预处理、编译、汇编、链接。不同的编译语言，在这四个步骤中所进行的操作又有些不同。 C/C++ 是 静态语言 的代表，它们在编译阶段就已经确定好了要调用的函数，以及函数的实现，如果函数未实现就会编译报错。 Runtime 又叫 运行时，是一套底层C语言的API，OC就是运行时机制，其中最主要的是 消息机制 。对于OC的函数，属于动态调用过程，在 编译 的时候并不能决定真正调用哪个函数，只有在真正 运行 的时候才会根据函数的名称找到对应的函数来调用。 运行时概念？运行时：把函数的调用从 编译阶段 推迟到 运行时阶段 的能力 多态概念?多态：不同对象以自己的方式响应相同的消息的能力叫做多态。 消息机制的基本原理OC的方法调用都是类似 [receiver selector] 的形式，其实每次都是一个运行时消息发送过程。 编译阶段：[receiver selector]方法被编译器转化： objc_msgSend(receiver，selector)（不带参数） objc_msgSend(recevier，selector，org1，org2，…)（带参数） 运行时阶段：消息接收者 recever 寻找对应的 selector： recever能找到对应的selector，直接执行接收receiver对象的selector方法。 recever找不到对应的selector，消息被转发或者临时向recever添加这个selector对应的实现内容，否则崩溃。 Runtime中的数据结构Runtime代码如何查看呢，我们可以通过下面的方式：我们也可以通过组合键 [Cmd + Shift + O ] ，搜索相关文件进入查看。 objc_msgSend Objective-C方法调用在编译时都会转化为对应C函数的调用：objc_msgSend(receiver，selector)。 Object（实例） objc.h中，我们来看一下Object（对象），是如何定义的： 1234567/// Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id; 我们知道 id 是一种通用的对象类型，它可以指向属于任何类的对象。在这里id被定义为一个指向 objc_object结构体的指针。 而 objc_object结构体 只包含一个 Class 类型的 isa指针，也就是说，一个Object（对象）唯一 保存 的就是它所属 Class（类） 的 地址。下面我们看一下Class是如何定义的。 Class（类） 在objc&#x2F;objc.h中，可以看到Class是一个指向objc_class结构体的指针： 12/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class; 在objc&#x2F;runtime.h中，是objc_object结构体的具体定义： 12345678910111213141516struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class _Nullable super_class // 指向父类的指针; const char * _Nonnull name // 类名; long version // 类的版本信息，默认为 0; long info // 类的信息，供运行期使用的一些位标识; long instance_size // 该类的实例变量大小; struct objc_ivar_list * _Nullable ivars // 该类的实例变量列表; struct objc_method_list * _Nullable * _Nullable methodLists // 方法定义列表 ; struct objc_cache * _Nonnull cache // 方法缓存; struct objc_protocol_list * _Nullable protocols // 遵守的协议列表; #endif &#125; OBJC2_UNAVAILABLE; 我们可以看到 objc_class结构体 中定义了很多的 成员变量：指向父类的指针、类的名字、版本、实例大小、实例变量列表、方法列表、缓存、遵守的协议列表等。这个结构体存放的数据称为元数据(metadata)。 我们还能注意到 objc_class 结构体中也有一个 isa指针。这就说明了Class本身其实也是一个对象，因此我们称之为 类对象，类对象在编译期产生，用于创建实例对象，是单例。 元类(Meta Class)： 我们可以发现 实例对象和类对象结构体中 都拥有一个 isa指针，实例对象的isa指针指向他所属的类（Class），那么类对象的isa指针指向哪儿里呢？ 类对象的isa指针指向了元类，元类(Meta Class)是一个类对象的类。在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。 为了调用类方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念，元类中保存了创建类对象以及类方法所需的所有信息。 实例对象、类、元类之间的关系 们已经了解了 实例对象（Object）、类（Class）、Meta Class（元类） 的基本概念。 下面，我们通过一张图，来清晰的了解下它们之间的继承关系，以及isa的指向关系： isa指针指向： 实例对象的isa指针指向了对应的类对象，而类对象的isa指针指向了对应的元类。 所有元类的isa指针最终指向了NSObject元类，因此NSObject元类也被称为根元类。根元类的isa指针又指向了自己。 super_class指针指向： 类对象的super_class指针指向了父类对象，父类对象又指向了根类对象，根类对象最终指向了nil。 元类的super_class指针指向了父元类。父元类又指向了根元类。而根元类的super_class指针指向了根类对象，最终指向了nil。 Method（方法） object_class 中 methodLists（方法列表）存放的元素就是Method（方法）。 在objc&#x2F;runtime.h中，看下定义： 12345678/// An opaque type that represents a method in a class definition.typedef struct objc_method *Method;struct objc_method &#123; SEL _Nonnull method_name // 方法名; char * _Nullable method_types // 方法类型; IMP _Nonnull method_imp // 方法实现;&#125; 1）SEL（方法名） SEL是一个指向objc_selector结构体的指针，然而我们并不能在Runtime中找到它的结构体的详细定义。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。 2）IMP（方法实现） 123456/// A pointer to the function of a method implementation. #if !OBJC_OLD_DISPATCH_PROTOTYPEStypedef void (*IMP)(void /* id, SEL, ... */ ); #elsetypedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); #endif IMP 的实质是一个 函数指针，它指向了方法实现的首地址。IMP用来找到函数地址，然后执行函数。 3）char * method_types （方法类型） 方法类型method_types是个字符串，用来 存储方法的参数类型和返回值类型。 总结： 到这里，Method的结构就已经很清楚了，Method将SEL（方法名） 和IMP（函数指针）关联起来，当对一个对象发送消息时，会通过给出的SEL（方法名）去找到IMP（函数指针），然后执行。 类缓存(objc_cache) 1234567typedef struct objc_cache *Cache OBJC2_UNAVAILABLE;struct objc_cache &#123; unsigned int mask /* total = mask + 1 */ OBJC2_UNAVAILABLE; unsigned int occupied OBJC2_UNAVAILABLE; Method _Nullable buckets[1] OBJC2_UNAVAILABLE;&#125;; objc_cache用于缓存最近使用的方法。一个类只有一部分方法是常用的，每次调用一个方法之后，这个方法就被缓存到objc_cache中，下次调用时runtime会先在objc_cache中查找，如果objc_cache中没有，才会去methodList中查找。相比直接在类的方法列表中遍历查找，效率更高。 深入理解Rutime消息发送 我们在分析了OC语言对应的底层C结构之后，现在可以进一步理解运行时的消息发送机制。先前讲到，OC调用方法被编译转化为如下的形式： 1id _Nullable objc_msgSend(id _Nullable self, SEL _Nonnull op, ...) 最后一步中我们提到：若找不到对应的selector，消息被转发或者临时向recevier添加这个selector应的实现方法，否则就会发生崩溃。 当一个方法找不到的时候，Runtime提供了 动态方法决议、消息快速转发、消息慢速转发 三种方法来处理，这三种方法的调用关系如下图： 动态方法决议 (Dynamic Method Resolution) 所谓动态方法决议，我们可以理解为通过 cache和方法列表没有找到方法 时，Runtime为我们提供一次 动态添加方法实现 的机会，主要用到的方法如下： 12345678910111213141516171819// OC方法：// 类方法未找到时调起，可于此添加类方法实现+ (BOOL)resolveClassMethod:(SEL)sel// 实例方法未找到时调起，可于此添加实例方法实现+ (BOOL)resolveInstanceMethod:(SEL)sel// Runtime方法：/** 运行时方法：向指定类中添加特定方法实现的操作 @param cls 被添加方法的类 @param name selector方法名 @param imp 指向实现方法的函数指针 @param types imp函数实现的返回值与参数类型 @return 添加方法是否成功 */BOOL class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) 下面使用一个示例来说明动态解析：ViewController类中声明方法却未添加实现，我们通过Runtime动态方法解析的操作为其添加方法实现，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#import &quot;ViewController.h&quot;#import &lt;objc/runtime.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //实例方法 [self performSelector:@selector(run)]; //类方法 [[self class] performSelector:@selector(walk)];&#125;//重写父类方法：处理实例方法+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if (sel == @selector(run)) &#123; class_addMethod([self class], sel, class_getMethodImplementation([self class], @selector(zj_run)), &quot;v@&quot;); //添加函数实现，返回YES return YES; &#125; return [super resolveInstanceMethod:sel];;&#125;//重写父类方法：处理类方法+ (BOOL)resolveClassMethod:(SEL)sel&#123; if (sel == @selector(walk)) &#123; class_addMethod(object_getClass(self), sel, class_getMethodImplementation(object_getClass(self), @selector(zj_walk)), &quot;v@&quot;); //添加函数实现，返回YES return YES; &#125; return [class_getSuperclass(self) resolveClassMethod:sel];&#125;- (void)zj_run&#123; NSLog(@&quot;%s&quot;,__FUNCTION__);&#125;+ (void)zj_walk&#123; NSLog(@&quot;%s&quot;,__FUNCTION__);&#125;@end 代码没有崩溃，并打印如下结果： 122020-08-18 14:32:15.894246+0800 iOS-OC之Runtime初探[7151:292311] -[ViewController zj_run]2020-08-18 14:32:15.894530+0800 iOS-OC之Runtime初探[7151:292311] +[ViewController zj_walk] class_addMethod 方法中的特殊参数“v@”，具体可参考官方文档中关于 Type Encodings 的说明：点击查看 这里+resolveInstanceMethod:或者 +resolveClassMethod:无论是返回YES，还是返回NO，只要其中没有添加其他函数实现，Runtime都会进行下一步：消息接受者重定向。 消息快速转发 这一步会调用下面两个方法： 12345// 重定向类方法的消息接收者，返回一个类+ (id)forwardingTargetForSelector:(SEL)aSelector//重定向实例方法的消息接受者，返回一个实例对象- (id)forwardingTargetForSelector:(SEL)aSelector 如果当前对象实现了这两个方法，Runtime就会调用这两个方法，允许我们将消息的接受者转发给其他对象。 下面使用一个示例来说明快速消息转发： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#import &quot;ViewController.h&quot;#import &lt;objc/runtime.h&gt;#import &quot;Person.h&quot;@interface ViewController ()@property (nonatomic, strong)Person * person;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //实例方法 [self performSelector:@selector(run)]; //类方法 [[self class] performSelector:@selector(walk)];&#125;#pragma mark -快速消息转发- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if (aSelector == @selector(run)) &#123; return self.person; &#125; return [super forwardingTargetForSelector:aSelector];&#125;//重定向类方法：返回一个类对象+ (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (aSelector == @selector(walk)) &#123; return [Person class]; &#125; return [super forwardingTargetForSelector:aSelector];&#125;- (Person *)person&#123; if (!_person) &#123; _person = [Person new]; &#125; return _person;&#125;@end 代码没有崩溃，并打印如下结果： 122020-08-18 14:51:50.445418+0800 iOS-OC之Runtime初探[7662:318157] -[Person run]2020-08-18 14:51:50.455564+0800 iOS-OC之Runtime初探[7662:318157] +[Person walk] 动态方法解析阶段无效时，我们可以通过forwardingTargetForSelector修改消息的接收者，该方法返回参数是一个对象，如果这个对象是非nil，非self，系统会将运行的消息转发给这个对象执行。否则，进行下一步：完成消息转发。 3）慢速消息转发机制1）这一步中首先会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil ，Runtime则会发出-doesNotRecognizeSelector: 消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送 -forwardInvocation:消息给目标对象。 2）作用： methodSignatureForSelector函数签名的作用：必须重新这个方法，消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象 forwardInvocation：除了发送消息给目标对象外，还可以防止崩溃 3）看下方法的定义： 1234567891011// 获取类方法函数的参数和返回值类型，返回签名+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;// 类方法消息重定向+ (void)forwardInvocation:(NSInvocation *)anInvocation；// 获取对象方法函数的参数和返回值类型，返回签名- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;// 对象方法消息重定向- (void)forwardInvocation:(NSInvocation *)anInvocation； 4)下面使用一个示例来说明慢速消息转发:person 1234567891011#import &quot;Person.h&quot;@implementation Person- (void)run&#123; NSLog(@&quot;%s&quot;,__FUNCTION__);&#125;+ (void)walk&#123; NSLog(@&quot;%s&quot;,__FUNCTION__);&#125;@end ViewController 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#import &quot;ViewController.h&quot;#import &lt;objc/runtime.h&gt;#import &quot;Person.h&quot;@interface ViewController ()@property (nonatomic, strong)Person * person;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //实例方法 [self performSelector:@selector(run)];&#125;//动态方法解析+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; return YES;// 返回YES，进入下一步转发&#125;//快速消息转发- (id)forwardingTargetForSelector:(SEL)aSelector &#123; return nil;// 返回nil，进入下一步转发&#125;// 获取函数的参数和返回值类型，返回签名- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;run&quot;]) &#123; return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];// 签名，进入forwardInvocation &#125; return [super methodSignatureForSelector:aSelector];&#125;// 消息重定向- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; SEL sel = anInvocation.selector;// 从anInvocation中获取消息 Person *p = [Person new]; if([p respondsToSelector:sel]) &#123; [anInvocation invokeWithTarget:p];// 将消息转发给其他对象处理 &#125; else &#123; [self doesNotRecognizeSelector:sel];// 报错，代码崩溃 &#125;&#125;- (Person *)person&#123; if (!_person) &#123; _person = [Person new]; &#125; return _person;&#125;@end 代码没有崩溃，并打印如下结果： 12020-08-18 15:01:42.400956+0800 iOS-OC之Runtime初探[7714:323673] -[Person run] 这一步中，通过签名，Runtime生成了一个对象anInvocation，发送给了forwardInvocation，我们在forwardInvocation方法里面让Person对象去执行了walk函数。 以上就是Runtime的三次转发流程。 消息发送流程总结调用[receiver selector]后，进行的流程： 1.编译阶段：[receiver selector]方法被编译器转化： objc_msgSend(receiver，selector)（不带参数）。 objc_msgSend(recevier，selector，org1，org2，…)（带参数）。 2.运行时阶段：recevier寻找对应的selector： 通过recevier的isa指针找到recevier的class（类）。 在Class（类）的cache（方法缓存）中寻找对应的selector。 如果在cache（方法缓存）中没有找到对应的 selector ，就继续在Class（类）的methodList（方法列表）中查找，如果找到，缓存到cache 中，并返回selector。 如果在class（类）中没有找到这个selector，就继续在它的superclass（父类）中寻找。 一旦找到selector，直接执行相关联的IMP（方法实现）。 若找不到对应的selector，Runtime系统进入消息转发阶段。 3.消息转发阶段： 动态解析：通过重写+resolveInstanceMethod: 或者+resolveClassMethod:方法，利用 class_addMethod方法添加其他函数实现。 快速转发阶段：如果上一步没有添加其他函数实现，可在当前对象中利用 forwardingTargetForSelector:方法将消息的接受者转发给其他对象。 慢速转发阶段：如果上一步返回值为nil，则利用 methodSignatureForSelector:方法获取函数的参数和返回值类型。 如果methodSignatureForSelector:返回nil。则 Runtime系统会发出doesNotRecognizeSelector:消息，程序也就崩溃了。 如果methodSignatureForSelector:返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送-forwardInvocation:消息给目标对象。","categories":[{"name":"OC-Runloop探索篇","slug":"OC-Runloop探索篇","permalink":"https://www.bboyzj.cn/categories/OC-Runloop%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-Runloop探索篇","slug":"OC-Runloop探索篇","permalink":"https://www.bboyzj.cn/categories/OC-Runloop%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC：多线程探索","slug":"OC学习/OC学习16：多线程","date":"2020-08-11T04:42:42.000Z","updated":"2023-03-09T21:12:56.405Z","comments":true,"path":"2020/08/11/OC学习/OC学习16：多线程/","link":"","permalink":"https://www.bboyzj.cn/2020/08/11/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A016%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"基本概念 进程 在系统中正在运行的一个应用程序 每个进程之间是独立的,它们均运行在其专用且受保护的内存空间内.若你此时打开了微信,又打开了QQ音乐,则系统会分别启动两个进程. iOS开发都是单进程,安卓可以支持多进程 进程可以控制很多条线程来执行相应的任务 进程至少要有一条线程,用来执行任务 线程 是进程的基本执行单元,1个进程若想执行任务,至少要有一个线程 系统会默认开启一条线程,称为主线程或UI线程 线程上的任务执行完毕后,线程会自动销毁 但是开辟线程要耗费一定的内存空间,会耗时,异步不会堵塞线程,会先执行下面的语句,就是因为辟线程耗时了 我们开辟线程时有时会给他们命名,这样是为了打断点调试时能看到调用的堆栈信息 主线程 处理UI，所有更新UI的操作都必须在主线程上执行。不要把耗时操作放在主线程，界面会卡。 多线程 在同一时刻，一个CPU只能处理1条线程，但CPU可以在多条线程之间快速的切换，只要切换的足够快，就造成了多线程一同执行的假象。 同步和异步 同步：在当前线程中执行任务，不具备开启新线程的能力； 异步：在新的线程中执行任务,具备开启新线程的能力； 同步函数(dispatch中的sync函数)： 在当前线程中执行队列里面的任务，不具备开启线程的能力； 立马在当前线程执行任务，执行完毕后才能继续往下执行 阻塞当前线程，即同步函数内的任务不执行完，该函数就会卡住，不会继续往下执行； 异步函数(dispatch中的async函数)： 在新的线程中执行队列里面的任务，具备开启线程的能力； 不阻塞当前线程，不用管当前的任务是否完成，都会往下执行； 会有一段时间去执行线程中的任务，因此后面的任务可能会在它之前执行； 串行和并发 串行队列(DISPATCH_QUEUE_SERIAL )：一个任务执行完成后,再执行下一个任务。 并发队列(DISPATCH_QUEUE_CONCURRENT)：多个任务并发(同时)执行； 进程和线程的区别 地址空间 进程之间是独立的地址空间,但同一进程的线程共享本进程的地址空间 资源拥有 进程之间的资源是独立的,但同一进程的线程共享本进程的资源(如内存,I&#x2F;O,cpu等) 线程是处理器调度的基本单位,但进程不是,意思是CPU调度是调度线程 执行过程进程可以独立执行,每个独立的进程都有一个程序运行的入口线程不能独立执行,必须存活在应用程序中 崩溃 进程崩溃时,对其他进程没有影响 线程崩溃时,整个进程就死掉了 多进程比多线程健壮 多线程 多线程的原理：CPU在单位时间片里快速的在各个线程之间切换 多线程的意义： 优点： 提高执行效率 提高资源(CPU,内存)利用率 线程执行完任务后,会自动销毁 缺点： 开启线程需要占用一定的内存空间,进行耗时 线程越多,耗时越多,会降低程序的性能,也会增大CPU在调用线程上的开销 程序设计会更加复杂,比如线程间的通信,多线程的数据共享 实现多线程的几种方式 NSThread GCD NSOperation NSThread优缺点 优点：NSThread比其他两个轻量级； 缺点：需要自己管理线程的生命周期，线程同步，线程同步时对数据的加锁会有一定的系统开销。 NSThread的使用优点：NSThread比其他两个轻量级；缺点：需要自己管理线程的生命周期，线程同步，线程同步时对数据的加锁会有一定的系统开销。 实例方法创建NSThread 实例方法创建的NSThread对象，我们需要手动调用方法[thread start]来启动线程，实际上都是开辟了一个子线程。 123456789101112131415161718- (void)demo&#123; //第一种方法：block方式 NSThread * thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [thread start]; //第二种方法：SEL方式 NSThread * thread1 = [[NSThread alloc] initWithBlock:^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]); &#125;]; [thread1 start];&#125;- (void)run&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]);&#125;*********打印结果********2020-08-13 15:19:24.874162+0800 OC-多线程之NSThread[43983:2668593] &lt;NSThread: 0x600002269a80&gt;&#123;number = 6, name = (null)&#125;2020-08-13 15:19:24.874219+0800 OC-多线程之NSThread[43983:2668594] &lt;NSThread: 0x600002269800&gt;&#123;number = 7, name = (null)&#125; 2.类方法创建NSThread 1234567891011121314//类方法创建- (void)demo1&#123; //block [NSThread detachNewThreadWithBlock:^&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]); &#125;]; //SEL [NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];&#125;*********打印结果********2020-08-13 15:24:21.931115+0800 OC-多线程之NSThread[44042:2672229] &lt;NSThread: 0x600001314480&gt;&#123;number = 7, name = (null)&#125;2020-08-13 15:24:21.931220+0800 OC-多线程之NSThread[44042:2672230] &lt;NSThread: 0x600001308a80&gt;&#123;number = 6, name = (null)&#125; 3.NSThread的其他方法 123456789101112131415161718//获取当前线程@property (class, readonly, strong) NSThread *currentThread;设置线程沉睡到指定日期+ (void)sleepUntilDate:(NSDate *)date; 线程沉睡时间间隔，这个方法在设置启动页间隔的时候比较常见+ (void)sleepForTimeInterval:(NSTimeInterval)ti; 线程退出，当执行到某一个特殊情况下的时候你可以退出当前的线程，注意不要在主线程随便调用+ (void)exit; 线程的优先级+ (double)threadPriority; 设置线程的优先级：取值范围0~1，值越大，执行越早+ (BOOL)setThreadPriority:(double)p; NSObject分类中创建线程的方法除了上面的两种方式创建线程外，@interface NSObject (NSThreadPerformAdditions)这个NSObject分类别中也有一些创建线程的方法：1）主线程执行任务 123456789/*在主线程执行任务aSelector：一个选择器, 指定要调用的方法arg：需要传递给调用方法的参数，如果没有需要的参数,传入nilwaitUntilDone：一个布尔值，指定是否阻塞当前线程直到指定选择器在主线程中执行完毕。选择YES会阻塞这个线程；选择NO，本方法会立刻返回。modes：RunLoop的运行的类型*/[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES modes:nil];[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO]; 2)实际使用例子1： 12345678910111213&#123; [self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO]; NSLog(@&quot;1&quot;);&#125; - (void)run&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]);&#125;*******打印结果******2020-08-13 23:11:39.640250+0800 OC-多线程之NSThread[45345:2800240] 12020-08-13 23:11:39.662218+0800 OC-多线程之NSThread[45345:2800240] &lt;NSThread: 0x600001114480&gt;&#123;number = 1, name = main&#125; 结论：waitUntilDone设置为NO，没有堵塞主线程，先打印1，后打印[NSThread currentThread]。 例子2： 1[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES]; 如果将waitUntilDone设置为YES，堵塞主线程，先打印[NSThread currentThread]后打印1 2.指定线程执行 12[self performSelector:@selector(run) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];[self performSelector:@selector(run) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO modes:nil]; 3.指定后台执行 12//后台执行[self performSelectorInBackground:@selector(run) withObject:nil]; 开启了一个新的线程去执行任务 GCD什么是GCD？Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。 GCD的优点? GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程） GCD更接近底层，性能较高 NSOperationNSOperation介绍 NSOperation是基于GCD开发的，是GCD更高一层的封装，比GCD拥有更强的可控性和代码可读性。 NSOperation是一个抽象基类，表示一个独立的计算单元，可以为子类提供有用且线程安全的建立状态，优先级，依赖和取消等操作。 我们使用比较多的就是它的子类NSInvocationOperation和NSBlockOperation。不过我们更多的使用是自己继承并定制自己的操作。 为什么要使用 NSOperation？ 可添加完成的代码块，在操作完成后执行。 添加操作之间的依赖关系，方便的控制执行顺序。 设定操作执行的优先级。 可以很方便的取消一个操作的执行。 使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。 NSOperation、NSOperationQueue 操作和操作队列既然是基于 GCD 的更高一层的封装。那么，GCD 中的一些概念同样适用于 NSOperation、NSOperationQueue。在 NSOperation、NSOperationQueue 中也有类似的任务（操作）和队列（操作队列）的概念。 1.操作（Operation） 执行操作的意思，换句话说就是你在线程中执行的那段代码。 在 GCD 中是放在 block 中的。在 NSOperation 中，我们使用 NSOperation 子类 NSInvocationOperation、NSBlockOperation，或者自定义子类来封装操作。 2.操作队列（Operation Queues）： 这里的队列指操作队列，即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。 操作队列通过设置最大并发操作数（maxConcurrentOperationCount）来控制并发、串行。 NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。 NSOperation、NSOperationQueue 使用介绍 NSOperation 需要配合 NSOperationQueue 来实现多线程。因为默认情况下，NSOperation 单独使用时系统同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行。 NSOperation 实现多线程的使用步骤分为三步： 创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。 创建队列：创建 NSOperationQueue 对象。 将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。 之后呢，系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。 NSOperation的基本使用1.使用子类 NSInvocationOperation 在主线程执行 1234567891011121314- (void)demo&#123; //1.创建NSInvocationOperation 对象 NSInvocationOperation * operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil]; //2.调用 start 方法开始执行操作 [operation start];&#125;- (void)run&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]);&#125;**********打印结果**********2020-08-16 11:59:20.701876+0800 OC-NSOperation[1670:53602] &lt;NSThread: 0x600003f28d40&gt;&#123;number = 1, name = main&#125; 可以看到：在没有使用 NSOperationQueue、在主线程中单独使用使用子类 NSInvocationOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。 在子线程执行 12345678910111213141516171819- (void)demo&#123; //3.在其他线程使用 [NSThread detachNewThreadWithBlock:^&#123; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); //1.创建NSInvocationOperation 对象 NSInvocationOperation * operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil]; //2.调用 start 方法开始执行操作 [operation start]; &#125;];&#125;- (void)run&#123; NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);&#125;**********打印结果**********2020-08-16 12:06:20.454733+0800 OC-NSOperation[1782:60475] 1---&lt;NSThread: 0x600000cfe200&gt;&#123;number = 6, name = (null)&#125;2020-08-16 12:06:20.455356+0800 OC-NSOperation[1782:60475] 2---&lt;NSThread: 0x600000cfe200&gt;&#123;number = 6, name = (null)&#125; 可以看到：在其他线程中单独使用子类 NSInvocationOperation，操作是在当前调用的其他线程执行的，并没有开启新线程。 2.使用子类 NSBlockOperation 在主线程使用 123456789101112- (void)demo1&#123; //1.创建 NSBlockOperation 对象 NSBlockOperation * operation = [NSBlockOperation blockOperationWithBlock:^&#123; //打印当前线程 NSLog(@&quot;%@&quot;, [NSThread currentThread]); &#125;]; //2.调用 start 方法开始执行操作 [operation start];&#125;*********打印结果**********2020-08-16 12:09:47.030187+0800 OC-NSOperation[1837:63421] &lt;NSThread: 0x6000034b0380&gt;&#123;number = 1, name = main&#125; 可以看到：在没有使用 NSOperationQueue、在主线程中单独使用 NSBlockOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。 注意：和上边 NSInvocationOperation 使用一样。因为代码是在主线程中调用的，所以打印结果为主线程。如果在其他线程中执行操作，则打印结果为其他线程。 但是，NSBlockOperation 还提供了一个方法 addExecutionBlock:，通过 addExecutionBlock: 就可以为 NSBlockOperation 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中同时（并发）执行。只有当所有相关的操作已经完成执行时，才视为完成。 如果添加的操作多的话，blockOperationWithBlock: 中的操作也可能会在其他线程（非当前线程）中执行，这是由系统决定的，并不是说添加到 blockOperationWithBlock: 中的操作一定会在当前线程中执行。（可以使用 addExecutionBlock: 多添加几个操作试试）。 12345678910111213141516171819202122232425262728293031323334353637- (void)demo1&#123; //1.创建 NSBlockOperation 对象 NSBlockOperation * operation = [NSBlockOperation blockOperationWithBlock:^&#123; //打印当前线程 NSLog(@&quot;%@&quot;, [NSThread currentThread]); &#125;]; //2.添加额外的操作 [operation addExecutionBlock:^&#123; //打印当前线程 NSLog(@&quot;1-%@&quot;, [NSThread currentThread]); &#125;]; [operation addExecutionBlock:^&#123; //打印当前线程 NSLog(@&quot;2-%@&quot;, [NSThread currentThread]); &#125;]; [operation addExecutionBlock:^&#123; //打印当前线程 NSLog(@&quot;3-%@&quot;, [NSThread currentThread]); &#125;]; [operation addExecutionBlock:^&#123; //打印当前线程 NSLog(@&quot;4-%@&quot;, [NSThread currentThread]); &#125;]; //调用 start 方法开始执行操作 [operation start];&#125;**********打印结果********2020-08-16 12:13:40.905153+0800 OC-NSOperation[1926:67565] 1-&lt;NSThread: 0x6000032c4f80&gt;&#123;number = 4, name = (null)&#125;2020-08-16 12:13:40.905162+0800 OC-NSOperation[1926:67564] 2-&lt;NSThread: 0x6000032be140&gt;&#123;number = 6, name = (null)&#125;2020-08-16 12:13:40.905168+0800 OC-NSOperation[1926:67563] 3-&lt;NSThread: 0x6000032cd180&gt;&#123;number = 7, name = (null)&#125;2020-08-16 12:13:40.905186+0800 OC-NSOperation[1926:67504] &lt;NSThread: 0x60000328c240&gt;&#123;number = 1, name = main&#125;2020-08-16 12:13:40.905385+0800 OC-NSOperation[1926:67565] 4-&lt;NSThread: 0x6000032c4f80&gt;&#123;number = 4, name = (null)&#125; 可以看出：使用子类 NSBlockOperation，并调用方法 AddExecutionBlock: 的情况下，blockOperationWithBlock:方法中的操作 和 addExecutionBlock: 中的操作是在不同的线程中并发执行的。而且，这次执行结果中 blockOperationWithBlock:方法中的操作也不是在当前线程（主线程）中执行的。从而印证了blockOperationWithBlock: 中的操作也可能会在其他线程（非当前线程）中执行。 一般情况下，如果一个 NSBlockOperation 对象封装了多个操作。NSBlockOperation 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。 3.使用自定义继承自 NSOperation 的子类如果使用子类 NSInvocationOperation、NSBlockOperation 不能满足日常需求，我们可以使用自定义继承自 NSOperation 的子类。可以通过重写 main 或者 start 方法 来定义自己的 NSOperation 对象。重写main方法比较简单，我们不需要管理操作的状态属性 isExecuting 和 isFinished。当 main 执行完返回的时候，这个操作就结束了。 在主线程中使用先定义一个继承自 NSOperation 的子类，重写main方法。.h文件中 12345678#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface ZJOperation : NSOperation@end .m文件中 123456789101112#import &quot;ZJOperation.h&quot;@implementation ZJOperation- (void)main&#123; if (!self.cancelled) &#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;ZJ---%@&quot;, [NSThread currentThread]); &#125; &#125;&#125;@end 在其他类中使用 12345678910- (void)demo2&#123; //1.创建ZJOperation对象 ZJOperation * operation = [[ZJOperation alloc] init]; //2.调用 start 方法开始执行操作 [operation start];&#125;*******打印结果******2020-08-16 12:24:16.940268+0800 OC-NSOperation[2093:75334] ZJ---&lt;NSThread: 0x600001994380&gt;&#123;number = 1, name = main&#125;2020-08-16 12:24:18.941867+0800 OC-NSOperation[2093:75334] ZJ---&lt;NSThread: 0x600001994380&gt;&#123;number = 1, name = main&#125; 可以看出：在没有使用 NSOperationQueue、在主线程单独使用自定义继承自 NSOperation 的子类的情况下，是在主线程执行操作，并没有开启新线程。 在子线程中使用 1234567891011121314151617- (void)demo2&#123; //1.在子线程中使用 [NSThread detachNewThreadWithBlock:^&#123; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); //1.创建ZJOperation对象 ZJOperation * operation = [[ZJOperation alloc] init]; //2.调用 start 方法开始执行操作 [operation start]; &#125;];&#125;*******打印结果******2020-08-16 12:26:04.684475+0800 OC-NSOperation[2117:76849] 1---&lt;NSThread: 0x600003fd6900&gt;&#123;number = 6, name = (null)&#125;2020-08-16 12:26:06.689546+0800 OC-NSOperation[2117:76849] ZJ---&lt;NSThread: 0x600003fd6900&gt;&#123;number = 6, name = (null)&#125;2020-08-16 12:26:08.694929+0800 OC-NSOperation[2117:76849] ZJ---&lt;NSThread: 0x600003fd6900&gt;&#123;number = 6, name = (null)&#125; 可以看出：在没有使用 NSOperationQueue、在子线程单独使用自定义继承自 NSOperation 的子类的情况下，是在子线程执行操作，没有开启新线程。 NSOperationQueue的基本使用NSOperationQueue 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。下边是主队列、自定义队列的基本创建方法和特点。 主队列：凡是添加到主队列中的操作，都会放到主线程中执行（注：不包括操作使用addExecutionBlock:添加的额外操作，额外操作可能在其他线程执行，感谢指正）。 12// 主队列获取方法NSOperationQueue *queue = [NSOperationQueue mainQueue]; 自定义队列（非主队列）：添加到这种队列中的操作，就会自动放到子线程中执行。同时包含了：串行、并发功能。 12// 自定义队列创建方法NSOperationQueue *queue = [[NSOperationQueue alloc] init]; 1.将操作加入到队列中上边我们说到 NSOperation 需要配合 NSOperationQueue 来实现多线程。 那么我们需要将创建好的操作加入到队列中去。总共有两种方法： 1)- (void)addOperation:(NSOperation *)op;需要先创建操作，再将创建好的操作加入到创建好的队列中去。 1234567891011121314151617181920212223242526272829303132- (void)demo3&#123; //1.创建队列 NSOperationQueue * queue = [[NSOperationQueue alloc] init]; // 2.创建操作 // 使用 NSInvocationOperation 创建操作1 NSInvocationOperation * op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil]; // 使用 NSBlockOperation 创建操作3 NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; // 打印当前线程 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); &#125;]; [op2 addExecutionBlock:^&#123; NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;]; // 3.使用 addOperation: 添加所有操作到队列中 [queue addOperation:op1]; // [op1 start] [queue addOperation:op2]; // [op2 start] &#125;- (void)run&#123; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);&#125;*********打印操作*******2020-08-16 12:37:09.954238+0800 OC-NSOperation[2180:82843] 2---&lt;NSThread: 0x600002018d40&gt;&#123;number = 5, name = (null)&#125;2020-08-16 12:37:09.954238+0800 OC-NSOperation[2180:82848] 3---&lt;NSThread: 0x60000201db40&gt;&#123;number = 3, name = (null)&#125;2020-08-16 12:37:09.954271+0800 OC-NSOperation[2180:82845] 1---&lt;NSThread: 0x600002062d40&gt;&#123;number = 4, name = (null)&#125; 可以看出：使用 NSOperation 子类创建操作，并使用 addOperation: 将操作加入到操作队列后能够开启新线程，进行并发执行。 2)- (void)addOperationWithBlock:(void (^)(void))block;无需先创建操作，在 block 中添加操作，直接将包含操作的 block 加入到队列中。 1234567891011121314151617181920- (void)demo4&#123; //1.创建队列 NSOperationQueue * queue = [[NSOperationQueue alloc] init]; //2.使用 addOperationWithBlock: 添加操作到队列中 [queue addOperationWithBlock:^&#123; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); &#125;]; [queue addOperationWithBlock:^&#123; NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); &#125;]; [queue addOperationWithBlock:^&#123; NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); &#125;];&#125;*********打印操作*******2020-08-16 12:40:45.166909+0800 OC-NSOperation[2238:85786] 2---&lt;NSThread: 0x60000291a680&gt;&#123;number = 5, name = (null)&#125;2020-08-16 12:40:45.166909+0800 OC-NSOperation[2238:85788] 1---&lt;NSThread: 0x600002965400&gt;&#123;number = 3, name = (null)&#125;2020-08-16 12:40:45.166921+0800 OC-NSOperation[2238:85784] 3---&lt;NSThread: 0x600002965540&gt;&#123;number = 6, name = (null)&#125; 可以看出：使用 addOperationWithBlock: 将操作加入到操作队列后能够开启新线程，进行并发执行。 2.NSOperationQueue 控制串行执行、并发执行 之前我们说过，NSOperationQueue 创建的自定义队列同时具有串行、并发功能，上边我们演示了并发功能，那么他的串行功能是如何实现的？ 这里有个关键属性 maxConcurrentOperationCount，叫做最大并发操作数。用来控制一个特定队列中可以有多少个操作同时参与并发执行。 注意：这里 maxConcurrentOperationCount 控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。 最大并发操作数：maxConcurrentOperationCountmaxConcurrentOperationCount 默认情况下为-1，表示不进行限制，可进行并发执行。 maxConcurrentOperationCount 为1时，队列为串行队列。只能串行执行。 maxConcurrentOperationCount 大于1时，队列为并发队列。操作并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为 min{自己设定的值，系统设定的默认最大值}。 12345678910111213141516171819202122232425262728- (void)demo5&#123; /* 设置 MaxConcurrentOperationCount（最大并发操作数） */ // 1.创建队列 NSOperationQueue * queue = [[NSOperationQueue alloc] init]; // 2.设置最大并发操作数// queue.maxConcurrentOperationCount = 1; // 串行队列// queue.maxConcurrentOperationCount = 2; // 并发队列 queue.maxConcurrentOperationCount = 8; // 并发队列 // 3.添加操作 [queue addOperationWithBlock:^&#123; NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;]; [queue addOperationWithBlock:^&#123; NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;]; [queue addOperationWithBlock:^&#123; NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;]; [queue addOperationWithBlock:^&#123; NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;]; &#125; 最大并发操作数为1 输出结果： 123452020-08-16 12:48:09.090860+0800 OC-NSOperation[2324:91784] 1---&lt;NSThread: 0x600002a2e780&gt;&#123;number = 4, name = (null)&#125;2020-08-16 12:48:09.091107+0800 OC-NSOperation[2324:91784] 2---&lt;NSThread: 0x600002a2e780&gt;&#123;number = 4, name = (null)&#125;2020-08-16 12:48:09.091296+0800 OC-NSOperation[2324:91784] 3---&lt;NSThread: 0x600002a2e780&gt;&#123;number = 4, name = (null)&#125;2020-08-16 12:48:09.091446+0800 OC-NSOperation[2324:91784] 4---&lt;NSThread: 0x600002a2e780&gt;&#123;number = 4, name = (null)&#125; 最大并发操作数为2 输出结果： 123452020-08-16 12:48:24.421434+0800 OC-NSOperation[2338:92272] 2---&lt;NSThread: 0x600001106780&gt;&#123;number = 6, name = (null)&#125;2020-08-16 12:48:24.421437+0800 OC-NSOperation[2338:92269] 1---&lt;NSThread: 0x6000011066c0&gt;&#123;number = 5, name = (null)&#125;2020-08-16 12:48:24.421724+0800 OC-NSOperation[2338:92269] 4---&lt;NSThread: 0x6000011066c0&gt;&#123;number = 5, name = (null)&#125;2020-08-16 12:48:24.421733+0800 OC-NSOperation[2338:92272] 3---&lt;NSThread: 0x600001106780&gt;&#123;number = 6, name = (null)&#125; 最大并发操作数为8 输出结果： 123456*******打印结果******82020-08-16 12:46:22.158690+0800 OC-NSOperation[2307:90480] 2---&lt;NSThread: 0x6000024003c0&gt;&#123;number = 4, name = (null)&#125;2020-08-16 12:46:22.158727+0800 OC-NSOperation[2307:90478] 4---&lt;NSThread: 0x60000240bb00&gt;&#123;number = 7, name = (null)&#125;2020-08-16 12:46:22.158737+0800 OC-NSOperation[2307:90482] 1---&lt;NSThread: 0x600002408ac0&gt;&#123;number = 5, name = (null)&#125;2020-08-16 12:46:22.158760+0800 OC-NSOperation[2307:90485] 3---&lt;NSThread: 0x600002418ac0&gt;&#123;number = 6, name = (null)&#125; 可以看出：当最大并发操作数为1时，操作是按顺序串行执行的，并且一个操作完成之后，下一个操作才开始执行。当最大操作并发数为2时，操作是并发执行的，可以同时执行两个操作。而开启线程数量是由系统决定的，不需要我们来管理。 3.NSOperationQueue 操作依赖NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。NSOperation 提供了3个接口供我们管理和查看依赖。 (void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。 (void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。当然，我们经常用到的还是添加依赖操作。现在考虑这样的需求，比如说有 A、B 两个操作，其中 A 执行完操作，B 才能执行操作。 如果使用依赖来处理的话，那么就需要让操作 B 依赖于操作 A。具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657- (void)demo5&#123; /* 设置 MaxConcurrentOperationCount（最大并发操作数） */ // 1.创建队列 NSOperationQueue * queue = [[NSOperationQueue alloc] init]; // 2.设置最大并发操作数// queue.maxConcurrentOperationCount = 1; // 串行队列 queue.maxConcurrentOperationCount = 2; // 并发队列// queue.maxConcurrentOperationCount = 8; // 并发队列 // 3.添加操作 [queue addOperationWithBlock:^&#123; NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;]; [queue addOperationWithBlock:^&#123; NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;]; [queue addOperationWithBlock:^&#123; NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;]; [queue addOperationWithBlock:^&#123; NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;]; &#125;- (void)demo6&#123; /* 操作依赖 使用方法：addDependency: */ // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.创建操作 NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;]; NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;]; // 3.添加依赖 [op2 addDependency:op1]; // 让op2 依赖于 op1，则先执行op1，在执行op2 // 4.添加操作到队列中 [queue addOperation:op1]; [queue addOperation:op2];&#125;******打印结果*****2020-08-16 12:52:02.556360+0800 OC-NSOperation[2376:94789] 1---&lt;NSThread: 0x6000017fe000&gt;&#123;number = 5, name = (null)&#125;2020-08-16 12:52:02.556627+0800 OC-NSOperation[2376:94792] 2---&lt;NSThread: 0x6000017f4ac0&gt;&#123;number = 6, name = (null)&#125; 可以看到：通过添加操作依赖，无论运行几次，其结果都是 op1 先执行，op2 后执行。 4.NSOperationQueue 优先级NSOperation 提供了queuePriority（优先级）属性，queuePriority属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是NSOperationQueuePriorityNormal。但是我们可以通过setQueuePriority:方法来改变当前操作在同一队列中的执行优先级。 12345678// 优先级的取值typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123; NSOperationQueuePriorityVeryLow = -8L, NSOperationQueuePriorityLow = -4L, NSOperationQueuePriorityNormal = 0, NSOperationQueuePriorityHigh = 4, NSOperationQueuePriorityVeryHigh = 8&#125;; 上边我们说过：对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。 那么，什么样的操作才是进入就绪状态的操作呢？ 当一个操作的所有依赖都已经完成时，操作对象通常会进入准备就绪状态，等待执行。举个例子，现在有4个优先级都是 NSOperationQueuePriorityNormal（默认级别）的操作：op1，op2，op3，op4。其中 op3 依赖于 op2，op2 依赖于 op1，即 op3 -&gt; op2 -&gt; op1。现在将这4个操作添加到队列中并发执行。 因为 op1 和 op4 都没有需要依赖的操作，所以在 op1，op4 执行之前，就是处于准备就绪状态的操作。而 op3 和 op2 都有依赖的操作（op3 依赖于 op2，op2 依赖于 op1），所以 op3 和 op2 都不是准备就绪状态下的操作。理解了进入就绪状态的操作，那么我们就理解了queuePriority 属性的作用对象。 queuePriority 属性决定了进入准备就绪状态下的操作之间的开始执行顺序。并且，优先级不能取代依赖关系。如果一个队列中既包含高优先级操作，又包含低优先级操作，并且两个操作都已经准备就绪，那么队列先执行高优先级操作。比如上例中，如果 op1 和 op4 是不同优先级的操作，那么就会先执行优先级高的操作。如果，一个队列中既包含了准备就绪状态的操作，又包含了未准备就绪的操作，未准备就绪的操作优先级比准备就绪的操作优先级高。那么，虽然准备就绪的操作优先级低，也会优先执行。优先级不能取代依赖关系。如果要控制操作间的启动顺序，则必须使用依赖关系。 123456789101112131415161718192021222324252627282930313233343536373839404142- (void)demo6&#123; /* 操作依赖 使用方法：addDependency: 优先级：setQueuePriority */ // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.创建操作 NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;]; [op1 setQueuePriority:NSOperationQueuePriorityLow]; NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;]; [op2 setQueuePriority:NSOperationQueuePriorityVeryHigh]; NSBlockOperation * op3 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;]; [op3 setQueuePriority:NSOperationQueuePriorityHigh]; // 3.添加依赖 [op2 addDependency:op1]; // 让op2 依赖于 op1，则先执行op1，在执行op2 // 4.添加操作到队列中 [queue addOperation:op1]; [queue addOperation:op2]; [queue addOperation:op3]; &#125;********打印结果*******2020-08-16 13:38:09.628886+0800 OC-NSOperation[2556:109314] 3---&lt;NSThread: 0x6000039d1880&gt;&#123;number = 5, name = (null)&#125;2020-08-16 13:38:09.628901+0800 OC-NSOperation[2556:109318] 1---&lt;NSThread: 0x6000039dcd80&gt;&#123;number = 3, name = (null)&#125;2020-08-16 13:38:09.629143+0800 OC-NSOperation[2556:109318] 2---&lt;NSThread: 0x6000039dcd80&gt;&#123;number = 3, name = (null)&#125; 由打印结果可知：优先级高的限制性，再执行优先级低的，再执行依赖关系的 NSOperation、NSOperationQueue 线程间的通信在 iOS 开发过程中，我们一般在主线程里边进行 UI 刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。 1234567891011121314151617181920212223242526/* 线程间通信 */- (void)demo7 &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc]init]; // 2.添加操作 [queue addOperationWithBlock:^&#123; // 异步进行耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程 // 回到主线程 [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; // 进行一些 UI 刷新等操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;]; &#125;];&#125; &#125;];&#125;***********打印结果********2020-08-16 13:43:39.078799+0800 OC-NSOperation[2631:113017] 1---&lt;NSThread: 0x60000328d940&gt;&#123;number = 3, name = (null)&#125;2020-08-16 13:43:39.097297+0800 OC-NSOperation[2631:112960] 2---&lt;NSThread: 0x6000032c8e80&gt;&#123;number = 1, name = main&#125; 可以看到：通过线程间的通信，先在其他线程中执行操作，等操作执行完了之后再回到主线程执行主线程的相应操作 NSOperation、NSOperationQueue 线程同步和线程安全 线程安全：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。 线程同步：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。 举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。 1.例子:下面，我们模拟火车票售卖的方式，实现 NSOperation 线程安全和解决线程同步问题。场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。 1）先来看看不考虑线程安全的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*** 非线程安全：不使用 NSLock* 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票*/- (void)demo8&#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 //总票数 self.ticketSurplusCount = 10; // 1.创建 queue1,queue1 代表北京火车票售卖窗口 NSOperationQueue * queue1 = [[NSOperationQueue alloc] init]; queue1.maxConcurrentOperationCount = 1; // 2.创建 queue2,queue2 代表上海火车票售卖窗口 NSOperationQueue *queue2 = [[NSOperationQueue alloc] init]; queue2.maxConcurrentOperationCount = 1; // 3.创建卖票操作 op1 NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; [self saleTicketNotSafe]; &#125;]; // 4.创建卖票操作 op2 NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; [self saleTicketNotSafe]; &#125;]; // 5.添加操作，开始卖票 [queue1 addOperation:op1]; [queue2 addOperation:op2];&#125;/** * 售卖火车票(非线程安全) */- (void)saleTicketNotSafe &#123; while (1) &#123; if (self.ticketSurplusCount &gt; 0) &#123; //如果还有票，继续售卖 self.ticketSurplusCount--; NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%ld 窗口:%@&quot;, (long)self.ticketSurplusCount, [NSThread currentThread]]); [NSThread sleepForTimeInterval:0.2]; &#125; else &#123; NSLog(@&quot;所有火车票均已售完&quot;); break; &#125; &#125;&#125; 打印结果： 1234567891011121314152020-08-16 13:51:15.967134+0800 OC-NSOperation[2709:117554] currentThread---&lt;NSThread: 0x600000170d40&gt;&#123;number = 1, name = main&#125;2020-08-16 13:51:15.970381+0800 OC-NSOperation[2709:117657] 剩余票数:9 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;2020-08-16 13:51:15.971286+0800 OC-NSOperation[2709:117652] 剩余票数:8 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;2020-08-16 13:51:16.171627+0800 OC-NSOperation[2709:117657] 剩余票数:7 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;2020-08-16 13:51:16.171722+0800 OC-NSOperation[2709:117652] 剩余票数:6 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;2020-08-16 13:51:16.374218+0800 OC-NSOperation[2709:117657] 剩余票数:5 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;2020-08-16 13:51:16.374490+0800 OC-NSOperation[2709:117652] 剩余票数:4 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;2020-08-16 13:51:16.574756+0800 OC-NSOperation[2709:117657] 剩余票数:3 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;2020-08-16 13:51:16.574900+0800 OC-NSOperation[2709:117652] 剩余票数:2 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;2020-08-16 13:51:16.778734+0800 OC-NSOperation[2709:117652] 剩余票数:1 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;2020-08-16 13:51:16.778655+0800 OC-NSOperation[2709:117657] 剩余票数:1 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;2020-08-16 13:51:16.980112+0800 OC-NSOperation[2709:117657] 剩余票数:0 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;2020-08-16 13:51:16.980114+0800 OC-NSOperation[2709:117652] 剩余票数:0 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;2020-08-16 13:51:17.183727+0800 OC-NSOperation[2709:117657] 所有火车票均已售完2020-08-16 13:51:17.183727+0800 OC-NSOperation[2709:117652] 所有火车票均已售完 可以看到：在不考虑线程安全，不使用 NSLock 情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。 2）再来看看考虑线程安全的代码:线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set&#x2F;get等等各种方式。这里我们使用 NSLock 对象来解决线程同步问题。NSLock 对象可以通过进入锁时调用 lock 方法，解锁时调用 unlock 方法来保证线程安全。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 线程安全：使用 NSLock 加锁 * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票 */- (void)demo9 &#123; NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程 // 总票数 self.ticketSurplusCount = 10; // 初始化 NSLock 对象 self.lock = [[NSLock alloc] init]; // 1.创建 queue1,queue1 代表北京火车票售卖窗口 NSOperationQueue *queue1 = [[NSOperationQueue alloc] init]; queue1.maxConcurrentOperationCount = 1; // 2.创建 queue2,queue2 代表上海火车票售卖窗口 NSOperationQueue *queue2 = [[NSOperationQueue alloc] init]; queue2.maxConcurrentOperationCount = 1; // 3.创建卖票操作 op1 NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; [self saleTicketSafe]; &#125;]; // 4.创建卖票操作 op2 NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; [self saleTicketSafe]; &#125;]; // 5.添加操作，开始卖票 [queue1 addOperation:op1]; [queue2 addOperation:op2];&#125;/** * 售卖火车票(线程安全) */- (void)saleTicketSafe &#123; while (1) &#123; // 加锁 [self.lock lock]; if (self.ticketSurplusCount &gt; 0) &#123; //如果还有票，继续售卖 self.ticketSurplusCount--; NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%ld 窗口:%@&quot;, (long)self.ticketSurplusCount, [NSThread currentThread]]); [NSThread sleepForTimeInterval:0.2]; &#125; // 解锁 [self.lock unlock]; if (self.ticketSurplusCount &lt;= 0) &#123; NSLog(@&quot;所有火车票均已售完&quot;); break; &#125; &#125;&#125; 打印结果： 12345678910111213142020-08-16 13:56:47.871368+0800 OC-NSOperation[2745:120698] currentThread---&lt;NSThread: 0x6000035a8440&gt;&#123;number = 1, name = main&#125;2020-08-16 13:56:47.872873+0800 OC-NSOperation[2745:120803] 剩余票数:9 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;2020-08-16 13:56:48.075868+0800 OC-NSOperation[2745:120803] 剩余票数:8 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;2020-08-16 13:56:48.276917+0800 OC-NSOperation[2745:120803] 剩余票数:7 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;2020-08-16 13:56:48.477632+0800 OC-NSOperation[2745:120803] 剩余票数:6 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;2020-08-16 13:56:48.683070+0800 OC-NSOperation[2745:120803] 剩余票数:5 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;2020-08-16 13:56:48.887849+0800 OC-NSOperation[2745:120803] 剩余票数:4 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;2020-08-16 13:56:49.093434+0800 OC-NSOperation[2745:120803] 剩余票数:3 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;2020-08-16 13:56:49.295885+0800 OC-NSOperation[2745:120803] 剩余票数:2 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;2020-08-16 13:56:49.501106+0800 OC-NSOperation[2745:120803] 剩余票数:1 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;2020-08-16 13:56:49.704799+0800 OC-NSOperation[2745:120803] 剩余票数:0 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;2020-08-16 13:56:49.909619+0800 OC-NSOperation[2745:120804] 所有火车票均已售完2020-08-16 13:56:49.909621+0800 OC-NSOperation[2745:120803] 所有火车票均已售完 可以看出：在考虑了线程安全，使用 NSLock 加锁、解锁机制的情况下，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。 NSOperation、NSOperationQueue 常用属性和方法归纳1.NSOperation 常用属性和方法 取消操作方法 123456- (void)cancel; 可取消操作，实质是标记 isCancelled 状态。判断操作状态方法- (BOOL)isFinished; 判断操作是否已经结束。- (BOOL)isCancelled; 判断操作是否已经标记为取消。- (BOOL)isExecuting; 判断操作是否正在在运行。- (BOOL)isReady; 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。 操作同步 123456- (void)waitUntilFinished; 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。- (void)setCompletionBlock:(void (^)(void))block; completionBlock 会在当前操作执行完毕时执行 completionBlock。- (void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。- (void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。 2.NSOperationQueue 常用属性和方法 取消&#x2F;暂停&#x2F;恢复操作 1234- (void)cancelAllOperations; 可以取消队列的所有操作。- (BOOL)isSuspended; 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。- (void)setSuspended:(BOOL)b; 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。 操作同步 1- (void)waitUntilAllOperationsAreFinished; 阻塞当前线程，直到队列中的操作全部执行完毕。 添加&#x2F;获取操作 123456789- (void)addOperationWithBlock:(void (^)(void))block; 向队列中添加一个 NSBlockOperation 类型操作对象。- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束- (NSArray *)operations; 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。- (NSUInteger)operationCount; 当前队列中的操作数。作者：行走少年郎链接：https://www.jianshu.com/p/4b1d77054b35来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 获取队列 12+ (id)currentQueue; 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。+ (id)mainQueue; 获取主队列。 注意： 这里的暂停和取消（包括操作的取消和队列的取消）并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"Swift学习：Snapkit使用探索","slug":"Swift/Swift学习：Snapkit使用探索","date":"2020-08-10T16:51:26.000Z","updated":"2023-03-08T22:13:33.535Z","comments":true,"path":"2020/08/11/Swift/Swift学习：Snapkit使用探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/11/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9ASnapkit%E4%BD%BF%E7%94%A8%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"Snapkit简介SnapKit是一个优秀的 第三方自适应布局库，它可以让iOS、OS X应用更简单地实现自动布局 SnapKit集成使用pods方式引入类库，pod &#39;SnapKit&#39; 引入头文件 import SnapKit Snapkit使用方法 通过 snp.makeConstraints 方法给 view 添加约束，约束有几种，分别是 边距、宽、高、左上右下 添加约束后修正 offet、inset、multipliedBy 语法一般为： make.equalTo：等于 make.lessThanOrEqualTo：小于等于 make.greaterThanOrEqaulTo：大于等于 场景 场景1：宽高200 make.width.height.equal(200) 场景2：距离box1 30 make.top.equalTo(box1.snp.top).offset(30) 场景3：一半 make.size.equalTo(box1).multipliedBy(0.5) 场景4：边距 make.edges.equalTo(box1).inset(UIEdgeInsets(10,20,30,40)) SnapKit注意 使用SnapKit添加约束之前，需要在addSubview之后才能使用，否则会导致崩溃 在添加约束时常会出现一些错误，约束出现问题的原因一般就是两种：约束冲突和缺少约束。对于这两种问题，可以通过调试和log排查","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-常用","slug":"Swift-常用","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"OC算法01：冒泡排序探索","slug":"OC数据结构和算法/OC算法01：冒泡排序探索","date":"2020-08-10T11:48:48.000Z","updated":"2023-03-06T10:16:59.351Z","comments":true,"path":"2020/08/10/OC数据结构和算法/OC算法01：冒泡排序探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/10/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9501%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"冒泡排序 基本思路： 重复地走访要排序的元素列，依次比较两个相邻的元素，如果他们的 顺序错误就把他们交换过来。 算法思想： 1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。2）对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。3）针对所有的元素重复以上的步骤，除了最后一个。4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 主要流程： 首先我们需要 双层循环，外层循环控制排序趟数，内存循环控制每趟比较次数以及是否需要交换位置，我们先不关心是否交换位置，我们内层循环每次比较都是取 array[j] 和 array[j+1] 相比较，根据比较结果来判断是否交换位置。 时间复杂度 最好的情况：冒泡排序中最好的情况是数组本身就是正序排列的，并不需要交换，例如：@[1,2,3,4,5]; 当正序数组放入冒泡排序中的时候，只会进行4次比较，分别是1和2，2和3，3和4，4和5。比较完后发现没有任何数需要交换，那么说明数组已经排序正确，不要在进行最外层循环。当正序数组中有 N 个数的时候，那么只需要 N-1 次比较。 而正序数组在冒泡排序中的时间复杂度为O(n)，因为n-1中，在n的基数很大的情况，比如n为1000时，1其实可以忽略不计。所以 冒泡排序中最短的时间**复杂度为O(n)**。 冒泡排序中最坏的情况是数组本身就是逆序排列的，需要每两个数都进行交换，例如：@[5,4,3,2,1]；当逆序数组放入冒泡排序中，最外层的每一次循环都要进行n-1次比较，而逆序数组需要进行n次最外层循环才能正确排序，最终比较次数为(n-1)n&#x2F;2，所以冒泡排序中最长的时间**复杂度为(n²)**，因为当n基数很大时，(n-1)n&#x2F;2 &#x3D; (n² - n)&#x2F;2； n²与n、1&#x2F;2的差距越大，n与1&#x2F;2可以忽略不计。 冒泡排序例子：元数据：@[@”1”,@”3”,@”2”,@”5”,@”4”] 123456789101112NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;5&quot;,@&quot;4&quot;]]; // 外循环控制排序趟数,进行 array.count-1 趟 for (int i = 0; i &lt; arr.count; i ++) &#123; // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序 for (int j = 0; j &lt; arr.count - i - 1; j++) &#123; // 相邻元素比较，若逆序则交换 if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123; [arr exchangeObjectAtIndex:j withObjectAtIndex:j + 1]; &#125; &#125; &#125; 打印结果： 12345672020-08-10 20:29:10.492517+0800 OC冒泡排序[27771:1528609] ( 1, 2, 3, 4, 5) 有序数组冒泡排序的优化如果数据是有序的： 第一种优化方式是设置一个标记位来标记是否发生了交换，如果没有发生交换就提前结束； 12345678910111213141516171819NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;5&quot;,@&quot;4&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;1&quot;]]; int flag = 0; // 外循环控制排序趟数,进行 array.count-1 趟 for (int i = 0; i &lt; arr.count; i ++) &#123; // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序 for (int j = 0; j &lt; arr.count - i - 1; j++) &#123; //相邻元素比较，若逆序则交换 if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123; flag = 1; id temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; if (flag == 0) &#123; break; &#125; &#125; NSLog(@&quot;%@&quot;,arr); 打印结果 12345672020-08-10 20:45:33.770139+0800 OC冒泡排序[28047:1546936] ( 1, 2, 3, 4, 5) 两个数组合并成一个数据，并排序1234567891011121314151617NSArray * ary1 = @[@1,@3,@4,@5,@9];NSArray * ary2 = @[@2,@4,@6,@8];NSMutableArray * res = [NSMutableArray arrayWithCapacity:[ary1 count] + [ary2 count]]; int i = 0, j = 0; // i 表示ary1的下标 j表示ary2的下标 while (i &lt; ary1.count &amp;&amp; j &lt; ary2.count) &#123; int a1 = [ary1[i] intValue]; int a2 = [ary2[j] intValue]; if (a1 &lt;= a2) &#123; [res addObject:ary1[i++]]; &#125;else &#123; [res addObject:ary2[j++]]; &#125; &#125; NSLog(@&quot;%@&quot;,res); 打印 123456789102020-08-10 21:11:11.311203+0800 OC冒泡排序[28372:1568516] ( 1, 2, 3, 4, 4, 5, 6, 8)","categories":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"OC-算法探索篇","slug":"OC-算法探索篇","permalink":"https://www.bboyzj.cn/tags/OC-%E7%AE%97%E6%B3%95%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"OC数据结构01：链表的探索","slug":"OC数据结构和算法/OC数据结构01：链表的探索","date":"2020-08-09T14:39:22.000Z","updated":"2023-03-06T10:15:00.063Z","comments":true,"path":"2020/08/09/OC数据结构和算法/OC数据结构01：链表的探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/09/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"数据结构顺序存储结构 举个例子，数组：1-2-3-4-5-6-7-8-9-10，这个就是一个顺序存储结构，存储是按顺序的。 比如 栈，先进后出，比如 hello world 在栈里面是从 栈底到栈顶的逻辑，依次是 h-e-l-l-o-w-o-r-l-d 这个顺序存储 再比如 队列，先进先出，从头到尾 h-e-l-l-o-w-o-r-l-d 这个顺序排序 链式存储结构-链表链表是一种 物里存储单元上非连续、非顺序的存储结构，数据元素的顺序是通过链表中的 指针 链接次序实现的。链表由 一系列节点组成，在 运行时动态生成。每个节点包括两部分：一个是 数据域，一个是 指针域。 链表链表的组成 链表的数据元素的组成部分：指针域 和 数据域 指针域 用来存放指示数据元素之间的逻辑关系的指针。 数据域 用来存放数据信息。 数据元素这种特殊的存储方式称之为 结点（Node）。 链表的分类链表分为4类： 单链表：一个数据域data、一个后继指针域next。也即：上一个节点指向下一个节点，尾节点next指向nil，首节点pre指向nil。 双向链表：一个数据域data、一个前驱指针域previous、一个后继指针域next。也即：上一个节点和下一个节点互相指向，尾节点next指向nil，首节点pre指向nil。 循环链表：一个数据域data、一个后继指针域next。也即：上一个节点指向下一个节点，尾节点next指向首节点。 双向循环链表：一个数据域data、一个前驱指针域previous、一个后继指针域next。也即：上一个节点和下一个节点互相指向，尾节点和首节点也互相指向。 链表的优缺点 数组： 我们知道，用数组存放数据时，必须事先定义固定的长度（即元素个数）。如果事先难以确定元素个数，则必须把数组定义的足够大，以便存放，显然这样会浪费内存。 而链表可根据需要开辟内存单元，不会浪费内存。 数组 和 链表 的区别？ 数组：数组 静态分配 内存；数组元素在内存上是连续的，可以通过下标查找元素；插入、删除需要移动大量元素，比较使用元素很少变化的情况；数组插入删除操作时间复杂度是 O(n)，数组查询操作时间复杂度是 O(1) 链表：链表 动态分配 内存；链表元素在内存中不是顺序存储的，查找慢；插入、删除只需要对元素指针重新赋值，效率高；链表插入删除操作时间复杂度是 O(1)，链表查询操作时间复杂度是 O(n) 如何检测单链表中是否有环？ 穷举遍历 首先从头节点开始，依次遍历每个节点，每遍历到一个新节点，就从头节点重新遍历新节点之前的所有节点，当 新节点的ID 和 此节点之前的所有节点ID 依次比较，如果发现 ID相同，则证明链表有环。 哈希表缓存 首先创建一个以 节点ID为键 的HashSet集合，用来存储曾经遍历过的节点。然后同样是从头节点开始，依次遍历每一个节点，当新节点和HashSet集合当中存储的节点ID相同，则说明链表右环。 快慢指针 首先创建两个指针，指针1和指针2，同时指向这个头节点，指针1每次向下移动一个节点，指针2向下移动2个节点，比较节点是否相同，如果相同则说明链表有环。如果不同执行下一次循环。 单向链表代码实现 定义节点 12345678910111213141516// 单链表节点@interface SingleLinkNode : NSObject@property (nonatomic,strong)id data; // 数据域@property (nonatomic,strong,nullable)SingleLinkNode * next; // 后继指针域+ (instancetype)constructNodeWithData:(id)data;@end@interface SingleLinkNode ()@end@implementation SingleLinkNode+ (instancetype)constructNodeWithData:(id)data&#123; SingleLinkNode * node = [[SingleLinkNode alloc] init]; node.data = data; node.next = nil; return node;&#125; 构建链表 12// 构建一个单链表SingleLinkNode * headNode = [[SingleLinkNode alloc] init]; 对外接口类 123456789101112131415161718192021222324@interface LinkInterface : NSObject// 单链表：在头部插入节点+ (void)insertNewNodeToHead:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode;// 单链表：在尾部插入节点+ (void)insertNewNodeToTail:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode;// 单链表：在指定位置插入节点+ (void)insertNodeAtIndex:(int)index node:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode;// 单链表：删除指定位置节点+ (void)deleteNodeAtIndex:(int)index headNode:(SingleLinkNode *)headNode;// 单链表：查询指定位置节点+ (SingleLinkNode *)queryNodeAtIndex:(int)index headNode:(SingleLinkNode *)headNode;// 单链表：正序遍历链表+ (NSArray *)printFromHeadWithNode:(SingleLinkNode *)headNode printPrefixText:(NSString *)text;// 单链表：倒叙遍历链表+ (NSMutableArray *)printFromTailWithNode:(SingleLinkNode *)headNode;// 单链表：反转链表+ (SingleLinkNode *)reverseWithNode:(SingleLinkNode *)headNode;// 单链表：两个有序链表合并成一个新的有序链表+ (SingleLinkNode *)combineWithNode:(SingleLinkNode *)headNode otherNode:(SingleLinkNode *)otherNode;// 单链表：判断两个链表是否相交+ (BOOL)intersectWithNode:(SingleLinkNode *)headNode otherNode:(SingleLinkNode *)otherNode;// 单链表：判断链表是否构成环，如果成环，求出环的入口节点+ (SingleLinkNode *)circleWithNode:(SingleLinkNode *)headNode;@end 插入节点 在头部插入节点 12345678910111213141516// 在头部插入节点+ (void)insertNewNodeToHead:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode&#123; // 判空处理 if (!headNode)&#123; return; &#125; // 先把新节点指向头节点的下一个节点，再让头结点指向新节点（比较常用） if (headNode.next == nil) &#123; headNode.next = newNode; &#125;else &#123; // 将下一个节点赋值给新节点 newNode.next = headNode.next; // 再将头节点指向新节点 headNode.next = newNode; &#125;&#125; vc实现： 12345// 插入节点到头部SingleLinkNode * newHeadNode = [SingleLinkNode constructNodeWithData:@1];[LinkInterface insertNewNodeToHead:newHeadNode headNode:headNode];// 正序打印节点[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;构造单链表为：&quot;]; 打印结果： 12022-11-23 16:44:46.140163+0800 单链表[39792:20769651] 单链表为:1 在尾部插入节点 123456789101112131415161718// 在尾部插入节点+ (void)insertNewNodeToTail:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode&#123; // 判空处理 if(!headNode)&#123; return; &#125; // 如果头节点就是尾节点 if(headNode.next == nil) &#123; headNode.next = newNode; &#125;else &#123; // 设置中间变量 SingleLinkNode * pNode = headNode; while (pNode.next != nil) &#123; // 未遍历到尾节点 pNode = pNode.next; &#125; pNode.next = newNode; &#125;&#125; vc实现： 123456789// 插入节点到尾部SingleLinkNode * newTailNode = [SingleLinkNode constructNodeWithData:@2];SingleLinkNode * newTailNode1 = [SingleLinkNode constructNodeWithData:@3];SingleLinkNode * newTailNode2 = [SingleLinkNode constructNodeWithData:@5];[LinkInterface insertNewNodeToTail:newTailNode headNode:headNode];[LinkInterface insertNewNodeToTail:newTailNode1 headNode:headNode];[LinkInterface insertNewNodeToTail:newTailNode2 headNode:headNode];// 正序打印节点[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;]; 打印结果： 12022-11-23 16:46:42.287876+0800 单链表[39960:20772937] 单链表为:1-&gt;2-&gt;3-&gt;5 在指定位置插入 123456789101112131415161718192021// 单链表：在指定位置插入节点+ (void)insertNodeAtIndex:(int)index node:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode&#123; // 判空处理 if(!headNode)&#123; return; &#125; // 如果头节点即尾节点 if (headNode.next == nil)&#123; headNode.next = newNode; &#125;else &#123; SingleLinkNode * pNode = headNode; int i = 1; while (i &lt; index &amp;&amp; pNode.next != nil) &#123; pNode = pNode.next; i ++; &#125; newNode.next = pNode.next; pNode.next = newNode; &#125; &#125; vc实现： 12345// 插入指定位置节点SingleLinkNode * newIndexNode = [SingleLinkNode constructNodeWithData:@4];[LinkInterface insertNodeAtIndex:4 node:newIndexNode headNode:headNode];// 正序打印节点[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;]; 打印结果： 12022-11-23 16:47:38.507939+0800 单链表[40048:20774861] 构造单链表为：:1-&gt;2-&gt;3-&gt;4-&gt;5 删除节点 12345678910111213141516171819202122// 单链表：删除指定位置节点+ (void)deleteNodeAtIndex:(int)index headNode:(SingleLinkNode *)headNode&#123; // 判空处理 if(headNode == nil || !headNode.next || index &lt;= 0)&#123; NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;没有要删除的第%d个节点&quot;,index]); return; &#125; SingleLinkNode * pNode = headNode; SingleLinkNode * p = pNode; // 移动指针 int i = 0; while (i &lt; index &amp;&amp; pNode.next != nil) &#123; p = pNode; pNode = pNode.next; i ++; &#125; if(pNode != nil)&#123; p.next = p.next.next; return; &#125; NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;没有要删除的第%d个节点&quot;,index]);&#125; vc实现： 1234// 删除指定位置的节点[LinkInterface deleteNodeAtIndex:1 headNode:headNode];// 正序打印节点[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;]; 打印结果： 12022-11-23 16:50:48.638460+0800 单链表[40345:20779532] 单链表为:2-&gt;3-&gt;4-&gt;5 查询节点 12345678910111213141516171819// 单链表：查询指定位置节点+ (SingleLinkNode *)queryNodeAtIndex:(int)index headNode:(SingleLinkNode *)headNode&#123; // 判空处理 if (!headNode || !headNode.next) &#123; NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;没有查询到的第%d个节点&quot;,index]); return nil; &#125; SingleLinkNode * pNode = headNode.next; int i = 1; while (i &lt; index &amp;&amp; pNode != nil) &#123; pNode = pNode.next; i ++; &#125; if(pNode != nil)&#123; return pNode; &#125; NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;没有查询到的第%d个节点&quot;,index]); return nil;&#125; vc实现： 1234// 查询指定位置的节点[LinkInterface queryNodeAtIndex:3 headNode:headNode];// 正序打印节点[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;]; 打印结果： 12022-11-23 16:55:10.563221+0800 单链表[40694:20785389] 单链表为:2-&gt;3-&gt;4-&gt;5 遍历链表 正向遍历 1234567891011121314151617// 正序遍历链表+ (NSArray *)printFromHeadWithNode:(SingleLinkNode *)headNode printPrefixText:(NSString *)text&#123; // 判空处理 if (!headNode || !headNode.next) &#123; return nil; &#125; // 设置偏移指针 SingleLinkNode * pNode = headNode.next; NSMutableArray * dataArr = [NSMutableArray array]; while (pNode != nil) &#123; [dataArr addObject:pNode.data]; pNode = pNode.next; // 指向下一个节点 &#125; NSLog(@&quot;%@:%@&quot;,text,[dataArr componentsJoinedByString:@&quot;-&gt;&quot;]); return dataArr;&#125; vc实现： 12// 正序打印节点[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;]; 打印结果： 12022-11-23 16:55:10.563221+0800 单链表[40694:20785389] 单链表为:2-&gt;3-&gt;4-&gt;5 反向遍历 123456789101112131415161718192021// 单链表：倒叙遍历链表+ (NSMutableArray *)printFromTailWithNode:(SingleLinkNode *)headNode&#123; // 判空处理 if(!headNode || !headNode.next)&#123; return nil; &#125; // 遍历指针偏移，每次遍历完一次后，要记录最后一个节点，然后将遍历指针移动到开头重新开始，与记录的最后一个节点作比较 NSMutableArray * items = [NSMutableArray array]; SingleLinkNode * pNode = headNode; SingleLinkNode * lastNode = nil; while (pNode != nil &amp;&amp; lastNode != pNode) &#123; pNode = pNode.next; if (pNode.next == nil || pNode.next == lastNode) &#123; lastNode = pNode; pNode = headNode; [items addObject:lastNode.data]; &#125; &#125; return items;&#125; vc实现： 123// 倒叙打印节点NSMutableArray * tailArr = [LinkInterface printFromTailWithNode:headNode];NSLog(@&quot;tail:%@&quot;,tailArr); 打印结果： 1234562022-11-23 17:00:09.521947+0800 单链表[41100:20791055] tail:( 5, 4, 3, 2) 反转链表 1234567891011121314151617181920212223242526// 单链表：反转链表+ (SingleLinkNode *)reverseWithNode:(SingleLinkNode *)headNode&#123; // 判空处理 if(!headNode|| !headNode.next)&#123; return nil; &#125; // 采用头节点插入的方式反转 // 定义遍历指针 SingleLinkNode * p = headNode.next; // 定义反转后头节点 SingleLinkNode * newHead = [[SingleLinkNode alloc] init]; while (p != nil) &#123; // 记录下一个节点用来往下循环 SingleLinkNode * temp = p.next; // 替换当前节点的next为新头next p.next = newHead.next; // 更新新头节点指向当前节点即可反转 newHead.next = p; // 移动p指针 p = temp; &#125; return newHead;&#125; vc实现： 12// 反转链表SingleLinkNode * reverseNode = [LinkInterface reverseWithNode:headNode]; 合并有序链表（有问题，排序不对） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 两个有序链表合并成一个新的有序链表+ (SingleLinkNode *)combineWithNode:(SingleLinkNode *)headNode otherNode:(SingleLinkNode *)otherNode&#123; // 判空处理 if(!headNode || !headNode.next)&#123; return otherNode; &#125; if(!otherNode || !otherNode.next)&#123; return headNode; &#125; // 一起遍历 SingleLinkNode * p1 = headNode.next; SingleLinkNode * p2 = otherNode.next; // 定义一个新头节点 SingleLinkNode * newHead = [[SingleLinkNode alloc] init]; while (p1 != nil &amp;&amp; p2 != nil) &#123; if([p1.data integerValue] &gt; [p2.data integerValue])&#123; // 移动otherNode节点指向otherNode当前节点的下一个节点 otherNode.next = p2.next; // 将当前otherNode节点链表断掉 p2.next = nil; // 将当前otherNode节点插入到新节点newHead链表的尾部 [self insertNewNodeToTail:p2 headNode:newHead]; // 获取otherNode链表的下一个节点 p2 = otherNode.next; &#125;else &#123; headNode.next = p1.next; p1.next = nil; [self insertNewNodeToTail:p1 headNode:newHead]; p1 = headNode.next; &#125; &#125; // 处理没扫描结束的链表 while (p1 != nil) &#123; headNode.next = p1.next; p1.next = nil; [self insertNewNodeToTail:p1 headNode:newHead]; p1 = headNode.next; &#125; while (p2 != nil) &#123; otherNode.next = p2.next; p2.next = nil; [self insertNewNodeToTail:p2 headNode:newHead]; p2 = otherNode.next; &#125; return newHead;&#125; 判断两个链表是否相交 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 单链表：判断两个链表是否相交+ (BOOL)intersectWithNode:(SingleLinkNode *)headNode otherNode:(SingleLinkNode *)otherNode&#123; // 判空处理 if(!headNode || !headNode.next || !otherNode || !otherNode.next)&#123; return NO; &#125; // 思路：分别获取两个链表的长度，判断谁的链表更长，链表更长的先走完相差的步数，然后再齐步走 SingleLinkNode * p1 = headNode.next; SingleLinkNode * p2 = otherNode.next; int L1 = 1; int L2 = 1; while (p1 != nil) &#123; L1 ++; p1 = p1.next; &#125; while (p2 != nil) &#123; L2 ++; p2 = p2.next; &#125; p1 = headNode.next; // 将p1遍历指针移动到首节点 p2 = headNode.next; // 将p2遍历指针移动到首节点 int i = 0; if (L1 &gt; L2) &#123; while (i &lt; L1 - L2 &amp;&amp; p1 != nil) &#123; // p1先走 p1 = p1.next; i ++; &#125; &#125;else &#123; while (i &lt; L2 - L1 &amp;&amp; p2 != nil) &#123; // p2先走 p2 = p2.next; i ++; &#125; &#125; // p1、p2齐步走 if(i == ABS(L1 - L2))&#123; while (p1 != nil &amp;&amp; p2 != nil) &#123; if(p1.next == p2.next) return YES; p1 = p1.next; p2 = p2.next; &#125; &#125; return NO;&#125; 判断链表是否头程还，如果成环，求出环的入口节点 1234567891011121314151617181920212223242526272829// 单链表：判断链表是否构成环，如果成环，求出环的入口节点+ (SingleLinkNode *)circleWithNode:(SingleLinkNode *)headNode&#123; // 判空处理 if(!headNode || !headNode.next)&#123; return nil; &#125; // 思路：采用快慢指针 // 快指针先走两步，满指针走一步，如果成环，必然重合。 // 走到第一次重合的地点后，重新设置一个指针p指向头节点，并与慢节点同步伐齐步走 // 走到第二次相遇的地方，即为构成环的节点 SingleLinkNode * quick = headNode.next; SingleLinkNode * slow = headNode.next; SingleLinkNode * p = headNode.next; while (quick != nil &amp;&amp; slow != nil) &#123; quick = quick.next.next; slow = slow.next; if (quick == slow) &#123; // 第一次重合，结束循环 break; &#125; &#125; while (p != nil &amp;&amp; slow != nil) &#123; p = p.next; slow = slow.next; if (p == slow) &#123; // 第二次重合，找到成环的入口节点 return p; &#125; &#125; return nil;&#125; 双向链表双向链表：每一个节点前后指针域都和他的上一个节点互相指向，尾节点的next指向nil，首节点的pre指向nil 定义节点 12345678910111213141516@interface DoubleLinkNode : NSObject@property (nonatomic,strong)id data; // 数据域@property (nonatomic,weak,nullable)DoubleLinkNode * pre; // 前驱指针域（防止循环引用）@property (nonatomic,strong,nullable)DoubleLinkNode * next; // 后继指针域+ (instancetype)constructNodeWithData:(id)data;@end@implementation DoubleLinkNode+ (instancetype)constructNodeWithData:(id)data&#123; DoubleLinkNode * node = [[DoubleLinkNode alloc] init]; node.data = data; node.pre = nil; node.next = nil; return node;&#125;@end 构建一个双向链表 123456789// 构造一个双向链表DoubleLinkNode * head = [[DoubleLinkNode alloc] init];DoubleLinkNode * node1 = [DoubleLinkNode constructNodeWithData:@1];DoubleLinkNode * node2 = [DoubleLinkNode constructNodeWithData:@2];head.next = node1;node1.pre = head;node1.next = node2;node2.pre = node1;[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双链表为&quot;]; 打印结果： 12022-11-24 13:38:50.045234+0800 单链表[50291:20937675] 双链表为:1⇄2 在头部插入节点 123456789101112131415161718// 双向链表：向头部插入节点+ (void)insertDoubleNewNodeToHead:(DoubleLinkNode *)newNode headNode:(DoubleLinkNode *)headNode&#123; // 判空处理 if(!headNode)&#123; return; &#125; // 如果只有一个头节点 if(headNode.next == nil)&#123; headNode.next = newNode; newNode.pre = headNode; &#125;else &#123; newNode.next = headNode.next; // 当前节点的后继指向头节点的后继 headNode.next.pre = newNode; // 头结点后继的前驱指向当前节点 newNode.pre = headNode; // 当前节点的前驱指向头结点 headNode.next = newNode; // 头结点的后继指向当前节点 &#125;&#125; vc实现 1234// 在头部插入节点DoubleLinkNode * node0 = [DoubleLinkNode constructNodeWithData:@0];[LinkInterface insertDoubleNewNodeToHead:node0 headNode:head];[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双链表为&quot;]; 打印结果： 12022-11-24 13:53:01.240605+0800 单链表[51484:20953802] 双链表为:0⇄1⇄2 在尾部插入节点 1234567891011121314// 双向链表：向尾部插入节点+ (void)insertDoubleNewNodeToTail:(DoubleLinkNode *)newNode headNode:(DoubleLinkNode *)headNode&#123; // 判空处理 if(!headNode)&#123; return; &#125; // 设置偏移指针 DoubleLinkNode * pNode = headNode.next; while (pNode.next != nil) &#123; pNode = pNode.next; &#125; pNode.next = newNode; newNode.pre = pNode;&#125; vc实现 1234// 在尾部插入节点DoubleLinkNode * node4 = [DoubleLinkNode constructNodeWithData:@4];[LinkInterface insertDoubleNewNodeToTail:node4 headNode:head];[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双向链表为&quot;]; 打印结果 12022-11-24 13:59:04.853558+0800 单链表[52038:20962187] 双向链表为:0⇄1⇄2⇄4 在指定位置插入节点 1234567891011121314151617181920212223242526272829// 双向链表：在指定位置插入节点+(void)insertDoubleNewNodeToIndex:(int)index newNode:(DoubleLinkNode *)newNode headNode:(DoubleLinkNode *)headNode&#123; if(!headNode)&#123; return; &#125; // 如果头结点即尾节点 if (headNode.next == nil)&#123; headNode.next = newNode; newNode.pre = headNode; &#125;else &#123; &#125; // 如果头节点即尾节点 if (headNode.next == nil)&#123; headNode.next = newNode; &#125;else &#123; // 设置偏移指针 DoubleLinkNode * pNode = headNode.next; int i = 1; while (i &lt; index &amp;&amp; pNode.next != nil) &#123; pNode = pNode.next; i ++; &#125; newNode.next = pNode.next; pNode.next.pre = newNode; newNode.pre = pNode; pNode.next = newNode; &#125;&#125; vc实现 1234// 在指定位置插入节点DoubleLinkNode * node3 = [DoubleLinkNode constructNodeWithData:@3];[LinkInterface insertDoubleNewNodeToIndex:3 newNode:node3 headNode:head];[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双向链表为&quot;]; 打印结果 12022-11-24 14:08:41.539116+0800 单链表[52850:20973592] 双向链表为:0⇄1⇄2⇄3⇄4 删除指定位置节点 1234567891011121314151617181920// 双向链表：删除指定位置节点+ (DoubleLinkNode *)deleteDoubleNodeAtIndex:(int)index headNode:(DoubleLinkNode *)headNode&#123; // 判空处理 if(!headNode)&#123; return nil; &#125; // 设置偏移指针 DoubleLinkNode * pNode = headNode.next; int i = 1; while (i &lt; index &amp;&amp; pNode.next != nil) &#123; pNode = pNode.next; i ++; &#125; if(i == index)&#123; pNode.pre.next = pNode.next; pNode.next.pre = pNode.pre; return pNode; &#125; return nil;&#125; vc实现 123// 删除指定位置节点[LinkInterface deleteDoubleNodeAtIndex:1 headNode:head];[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双向链表为&quot;]; 打印结果 12022-11-24 14:15:01.766124+0800 单链表[53365:20980542] 双向链表为:1⇄2⇄3⇄4 遍历并打印链表 // 双向链表：遍历并打印链表 + (void)printDoubleFromHeadWithNode:(DoubleLinkNode *)headNode printPrefixText:(NSString *)text&#123; if(!headNode)&#123; return; &#125; DoubleLinkNode * pNode = headNode.next; NSMutableArray * items = [NSMutableArray array]; while (pNode != nil) &#123; [items addObject:pNode.data]; pNode = pNode.next; &#125; NSLog(@&quot;%@:%@&quot;,text,[items componentsJoinedByString:@&quot;⇄&quot;]); &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.bboyzj.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"OC-数据结构探索篇","slug":"OC-数据结构探索篇","permalink":"https://www.bboyzj.cn/tags/OC-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.bboyzj.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"OC算法03：斐波那契数列探索","slug":"OC数据结构和算法/OC算法03：斐波那契数列探索","date":"2020-08-09T05:56:16.000Z","updated":"2023-03-06T10:44:55.267Z","comments":true,"path":"2020/08/09/OC数据结构和算法/OC算法03：斐波那契数列探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/09/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9503%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"简介斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(1)&#x3D;1，F(2)&#x3D;1, F(n)&#x3D;F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*），用文字来说，就是斐波那契数列由 0 和 1 开始，之后的斐波那契数列系数就由 之前的两数相加。 排列组合问：有一段楼梯有10级台阶，规定每一步只能跨一级或两级，要登上第 10 级台阶有几种不同的走法? 分析：这就是一个斐波那契数列：登上第一级台阶有一种登法；登上两级台阶，有两种登法；登上三级台阶，有三种登法；登上四级台阶，有五种登法……1，2，3，5，8，13…… 所以，登上十级，有 89 种走法。 答： 123456789101112131415161718192021- (void)demo&#123; // 有10级台阶 NSInteger tjNum = 10; NSInteger total = [self getTotalNumOfMethods:tjNum]; NSLog(@&quot;total:%ld&quot;,total);&#125;- (NSInteger)getTotalNumOfMethods:(NSInteger)num&#123; if (num == 0) &#123; return 0; &#125; if (num == 1) &#123; return 1; &#125; if (num == 2) &#123; return 2; &#125; return [self getTotalNumOfMethods:num-1] + [self getTotalNumOfMethods:num - 2];&#125; 打印结果：89 兔子繁殖问题斐波那契数列又因数学家莱昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”。 问：一般而言，兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。如果所有兔子都不死，那么一年以后可以繁殖多少对兔子？ 分析：我们不妨拿新出生的一对小兔子分析一下：第一个月小兔子没有繁殖能力，所以还是一对 两个月后，生下一对小兔对数共有两对 三个月以后，老兔子又生下一对，因为小兔子还没有繁殖能力，所以一共是三对－－－－－－依次类推可以列出下表： 幼仔对数&#x3D;前月成兔对数成兔对数&#x3D;前月成兔对数+前月幼仔对数总体对数&#x3D;本月成兔对数+本月幼仔对数可以看出幼仔对数、成兔对数、总体对数都构成了一个数列。这个数列有关十分明显的特点，那是：前面相邻两项之和，构成了后一项。 答： 1234567891011121314151617181920- (void)demo1&#123; NSInteger month = 12; NSInteger tuTotal = [self getTuTotalNum:month]; NSLog(@&quot;tuTotal:%ld&quot;,tuTotal);&#125;- (NSInteger)getTuTotalNum:(NSInteger)month&#123; if (month == 0) &#123; return 1; &#125; if (month == 1) &#123; return 1; &#125; if (month == 2) &#123; return 2; &#125; return [self getTuTotalNum:month-1] + [self getTuTotalNum:month - 2];&#125; 打印结果：233","categories":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"OC-算法探索篇","slug":"OC-算法探索篇","permalink":"https://www.bboyzj.cn/tags/OC-%E7%AE%97%E6%B3%95%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"OC算法02：插入排序探索","slug":"OC数据结构和算法/OC算法02：插入排序探索","date":"2020-08-07T11:28:01.000Z","updated":"2023-03-06T10:39:36.281Z","comments":true,"path":"2020/08/07/OC数据结构和算法/OC算法02：插入排序探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/07/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9502%EF%BC%9A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"基本思想每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，直到全部对象都插入为止。即边插入边排序，保证子序列中随时都是排好序的。 基本操作有序插入 在有序列序列中插入一个元素，保持序列有序，有序长度不断增加。 可以插入在中间、最前面和最后面 插入排序种类 顺序法定位插入位置 – 直接插入排序 缩小增量多遍插入排序 – 希尔排序 直接插入排序 基本思路：每轮排序把数组分为2部分，一部分为已排序好的数组，一部分为还未排序好的数组。每次取出还未排序好的数组中首元素与已排序好的数组从右往左比较。如果发现从未排序中取出的元素比从已排序中取出的元素大，就把该未排序的元素插入到从已排序中取出元素的后面。这样每一轮就能确定一个未排序元素在已排序数组中的准确位置 算法思想 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到下一位置中 重复步骤2~5 直接插入排序的流程演示 流程举例: 红色的为已排序部分，蓝色的为未排序部分 1）原始数据：首先把原数组从下坐标1开始拆分为2部分， 已排序部分(红色)，未排序部分(蓝色)。默认原数组首元素为已排序元素。 2）第一轮：接着用后面未排序部分的第一个元素与已排序部分的最后一个元素进行比较，这里发现已排序最末尾元素5小于未排序元素第一个元素9.且元素5余元素9的位置是相邻的。不发生插入。把元素9列入已排序数组中。此时已排序好的元素多了一个。 3）第二轮：然后接着用后面未排序部分的第一个元素与已排序部分的最后一个元素进行比较，这里发现已排序最末尾元素9大于未排序元素第一个元素2。并且9不是已排序元素最前面一个元素，所以忽略本次操作，让元素2与已排序元素从右往左的下一个元素进行比较，此时发现已排序元素5大于元素2，但发现元素5是已排序元素中首个元素。则直接把元素2插入到元素5前面。 4）第三轮排序：用后面未排序部分的第一个元素与已排序部分的最后一个元素进行比较，这里发现已排序最末尾元素9小于未排序元素第一个元素15。且两个元素相邻。不发生插入，把元素15加入已排序部分。 5）第四轮排序：用后面未排序部分的第一个元素与已排序部分的最后一个元素进行比较，这里发现已排序最末尾元素15小于未排序元素第一个元素46。且两个元素相邻。不发生插入，把元素46加入已排序部分。 6）最后：依次按照上面的方式递归排序。直到所有元素排序完成。 列子: 代码实现： 1234567891011121314151617181920212223242526272829303132- (void)viewDidLoad &#123; [super viewDidLoad]; NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@15,@2,@5,@10,@20]]; // 插入排序的原理：始终定义第一个元素为有序的，将元素逐个插入到有序的排列中 // 其特点是：不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去 for (int i = 0 ; i &lt; arr.count; i ++) &#123; // temp为待排元素i为其位置 NSNumber * temp = arr[i]; // j为已排元素最后一个元素的位置 int j = i - 1; // 当j&gt;=0时，i为第一个待排元素，取已排元素和待排元素比较，在已经排好序中从后向前扫描 while (j &gt;= 0 &amp;&amp; [arr[j] integerValue] &gt; [temp integerValue]) &#123; // 如果已经排好序的序列中元素大于新元素，则将该元素往右移动一个位置 [arr replaceObjectAtIndex:j+1 withObject:arr[j]]; j --; &#125; // 跳出循环时，j已排元素小于或等于i的元素（待排元素）。插入新元素a[j+1] = temp，即空出来的位置插入待排序的值 [arr replaceObjectAtIndex:j+1 withObject:temp]; NSLog(@&quot;插入排序排序中:%@&quot;,[self getArrayStr:arr]); &#125;&#125;// 将数组中的元素拼接成字符串 - 方便打印- (NSString *)getArrayStr:(NSArray *)array &#123; NSMutableString *strM = [NSMutableString string]; for (NSNumber *num in array) &#123; [strM appendString:[NSString stringWithFormat:@&quot;%@,&quot;,num]]; &#125; return strM.copy;&#125; 打印结果: 123452020-08-07 21:30:38.316438+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:15,2,5,10,20,2020-08-07 21:30:38.316483+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:2,15,5,10,20,2020-08-07 21:30:38.316502+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:2,5,15,10,20,2020-08-07 21:30:38.316519+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:2,5,10,15,20,2020-08-07 21:30:38.316535+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:2,5,10,15,20, 算法分析 直接插入排序的算法性能 时间复杂度 最好的情况（关键字在记录中顺序有序）： 当元素的初始序列为正序时，仅外循环要进行n-1趟排序且每一趟只进行一次比较，没有进入if语句不存在元素之间的交换(移动)。此时比较次数(Cmin)和移动次数(Mmin)达到最小值。 此时时间复杂度为O(n)。 12比较次数：Cmin = n-1;移动次数：Mmin = 0; 举例： 如：1 2 3 4 5比较： 次数 移动第2个元素和第一个元素比较 1 0第3个元素和第二个元素比较 1 0…第n个元素和第n-1个元素比较 1 0比较的次数：n-1移动的次数：0 最坏的情况（关键字在记录序列中逆序有序）： 最差就是逆序。每趟排序中待插入的元素都要和[0,i-1]中的i个元素进行比较且要将这i个元素后移，i个元素后移移动次数当然也就为i了，再加上temp &#x3D; arr[i]与arr[j+1] &#x3D; temp的两次移动，每趟移动的次数为i+2,此时比较次数(Cmin)和移动次数(Mmin)达到最小值。 此时时间复杂度为O(n2)。 12Cmax = 1+2+...+(n-1) = n*(n-1)/2 = O(n2)Mmax = (1+2)+(2+2)+...+(n-1+2) = (n-1)*(n+4)/2 = O(n2) (i取值范围1~n-1) 例子： 如：5 4 3 2 1比较： 次数 移动第2个元素和第1个元素比较 1 1+2第3个元素和前2个元素比较 2 2+2…第n个元素和前n-1个比较 n-1 n-1+2最后： 把1+2+…+n-1加起来求平均值比较的次数：1+2+…+n-1 &#x3D; (n+2)(n-1)&#x2F;2移动的次数：(1+2)+(2+2)+…+(n-1+2) &#x3D; (n-1)*(n+4)&#x2F;2 &#x3D; O(n2) (i取值范围1~n-1) 事件复杂度结论：原始数据越接近有序，排序速度越快 1）最好的情况下（顺序有序）：O(n)2）最坏的情况下（逆序有序）：O(n^2)3）平均情况下，耗时差不多是最坏情况的一般：O(n^2)4）要提高查找速度 减少元素的比较次数减少元素的移动次数 空间复杂度 由直接插入排序算法可知，我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 O(1) 。 算法稳定性 直接插入排序的过程中，不需要改变相等数值元素的位置，所以它是稳定的算法。 插入排序和选择排序的区别 插入排序和选择排序都有两层循环，外循环遍历整个数组 内循环稍有区别： 选择排序的内循环是遍历一组未排过序的数组。 插入排序的内循环是遍历一组已排过序的数组。 希尔排序 简介 希尔排序(Shell Sort)，一听这名字就知道是一个叫希尔的外国人发明的排序。没错，他就是唐纳德 希尔（Donald Shell），一位美国的计算机科学家，他于1959年发明的希尔排序算法。 希尔排序思路 希尔排序相当于 直接插入排序的加强版，在直接插入排序的概念之上加入了 增量 这个概念。 什么是增量？ 插入排序只能与相邻的元素进行比较，而希尔排序则是进行 跳跃 比较，而 增量 就是 跳跃的 间隔数。 所谓增量即是把数组按照一定间隔数分组成不同的数组。例如:@{1,2,3,4,5,6,7},一共有6个元素，假设把数组按照增量3进行分组，那么就是@{1,4,7},@{2,5},@{3,6}各分为一组。因为增量是3，所以每间隔3个下坐标为一组。 按照增量分组后，把每一组的元素按照插入排序进行排序。当按照一个增量分组完成并每组数据按照插入排序完成后，将增量设为原本的二分之一，然后重复上面的步骤进行插入排序。直到增量为1，按照增量为1的最后一次进行分组插入排序。即完成了排序。 希尔排序的流程演示 原始数据：@[@(11),@(10),@(9),@(8),@(7),@(6),@(5),@(4),@(3),@(2),@(1)] 第一次分组： 第一步，数组中有11个元素，把数组除以二，得到5(11&#x2F;2实际是等于5余1，由于取正所以为5，由于有余数，所以按照增量取出来的数组的 组数 有 增量+1 即 5 + 1 = 6组。如果没有余数则组数就是增量数。)，以5为增量，从数组第一个元素开始，每间隔5个数取出来的所有元素分为一组，分为6组，分别是：@{11,7}、@{10,4}、@{9,3}、@{8,2}、@{5,1}、@{6} 第一次排序：每种颜色为一组。接着对每组进行插入排序(具体比较过程就不说了，看过上面插入排序的应该懂)，排序结果为下图(共交换5次):@{7,11}、@{4,10}、@{3,9}、@{2,8}、@{1,5}、@{6} 2)第二次分组：将增量5再次除以2，得到2(实际5&#x2F;2是等于2余1，有余数所以组数为3)。分为3组分别是:@{7,2,11,8}、@{4,1,10,5}、@{3,6,9} 第二次排序：每种颜色为一组，对每组元素进行插入排序。排序结果为(共交换4次)@{2,7,8,11}、@{1,4,5,10}、@{3,6,9} 3)第三次分组：将增量2再次除以1，得到1(实际2&#x2F;2等1，没有余数，所以分为1组)。分组后是@{2,1,3,7,4,6,8,5,9,11,10} 第三次排序：最后对整组数组进行插入排序，排序结果为(共交换7次)： 希尔排序的特点 1）一次移动，移动位置比较大，跳跃式地接近排序后的最终位置2）最后一次只需要少量移动3）增量序列必须是递减的，最后一个必须是14）增量序列应该是互质的 实例 12345678910111213141516171819202122232425262728293031323334353637383940- (void)viewDidLoad &#123; [super viewDidLoad]; NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@(9),@(3),@(8),@(5),@(2),@(4),@(7),@(6),@(1)]]; [self shellSort:arr];&#125;- (void)shellSort:(NSMutableArray *)list&#123; // 起始间隔值gap设置为总数的一半 int gap = (int)list.count / 2; // 直到gap==1结束 while (gap &gt;= 1) &#123; //i为待排元素，以步距gap从后向前扫描 for(int i = gap ; i &lt; [list count]; i++)&#123; //temp为待排元素i为其位置 NSInteger temp = [[list objectAtIndex:i] intValue]; //获取当前位置 int j = i; //然后将此位置之前的元素，按照增量进行跳跃式比较 while (j &gt;= gap &amp;&amp; temp &lt; [[list objectAtIndex:(j - gap)] intValue]) &#123; [list replaceObjectAtIndex:j withObject:[list objectAtIndex:j-gap]]; j -= gap; &#125; //跳出循环时，j元素小于i的元素（待排元素）。插入新元素a[j] = temp，即空出来的位置插入待排序的值 [list replaceObjectAtIndex:j withObject:[NSNumber numberWithInteger:temp]]; &#125; NSLog(@&quot;步长：%d --- 希尔排序:%@&quot;,gap,[self getArrayStr:list]); //步长 gap = gap / 2; &#125;&#125;// 将数组中的元素拼接成字符串 - 方便打印- (NSString *)getArrayStr:(NSArray *)array &#123; NSMutableString *strM = [NSMutableString string]; for (NSNumber *num in array) &#123; [strM appendString:[NSString stringWithFormat:@&quot;%@,&quot;,num]]; &#125; return strM.copy;&#125; 打印结果 1232020-08-09 22:02:14.160098+0800 OC-哈希排序[23997:1116332] 步长：4 --- 希尔排序:1,3,7,5,2,4,8,6,9,2020-08-09 22:02:14.160373+0800 OC-哈希排序[23997:1116332] 步长：2 --- 希尔排序:1,3,2,4,7,5,8,6,9,2020-08-09 22:02:14.160620+0800 OC-哈希排序[23997:1116332] 步长：1 --- 希尔排序:1,2,3,4,5,6,7,8,9, 希尔排序算法分析： 1）希尔排序的时间复杂度与增量的选取有关。例如，当增量为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为O(N²)，而Hibbard增量的希尔排序的时间复杂度为O(N3&#x2F;2)。2）空间复杂度：O(1)3）是一种不稳定的排序算法：","categories":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"OC-算法探索篇","slug":"OC-算法探索篇","permalink":"https://www.bboyzj.cn/tags/OC-%E7%AE%97%E6%B3%95%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"OC三方框架05：MLeaksFinder内存泄露探索","slug":"OC性能优化/性能优化01.1：MLeaksFinder内存泄露检测","date":"2020-08-05T09:08:27.000Z","updated":"2023-03-08T22:57:45.466Z","comments":true,"path":"2020/08/05/OC性能优化/性能优化01.1：MLeaksFinder内存泄露检测/","link":"","permalink":"https://www.bboyzj.cn/2020/08/05/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601.1%EF%BC%9AMLeaksFinder%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B/","excerpt":"","text":"前言 腾讯开源了业界首创 iOS自动内存泄露检测工具 MLeaksFinder，MLeaksFinder 是 iOS 平台的自动内存泄漏检测工具，引进MLeaksFinder 后，就可以在日常的开发，调试业务逻辑的过程中自动地发现并警告内存泄漏。 平常我们都会用 Instrument 的 Leaks / Allocations 或其他一些开源库进行内存泄露的排查，但它们都存在各种问题和不便，我们逐个来看这些工具的使用和存在的问题。 无需修改任何业务逻辑代码，而且只在 debug 下开启，完全不影响你的 release 包。 简介MLeaksFinder 是 iOS 平台的自动内存泄漏检测工具，引进 MLeaksFinder 后，就可以在日常的开发，调试业务逻辑的过程中自动地发现并警告内存泄漏。开发者无需打开 instrument 等工具，也无需为了找内存泄漏而去跑额外的流程。并且，由于开发者是在修改代码之后一跑业务逻辑就能发现内存泄漏的，这使得开发者能很快地意识到是哪里的代码写得问题。这种及时的内存泄漏的发现在很大的程度上降低了修复内存泄漏的成本。 Leaks先看看 Leaks，从苹果的开发者文档里可以看到，一个 app 的内存分三类： Leaked memory: Memory unreferenced by your application that cannot be used again or freed (also detectable by using the Leaks instrument). 真正的内存泄漏:在第一次 pop 的时候报 Memory Leak，在之后的重复 push 并 pop 同一个 ViewController 过程中，不报 Object Deallocated，但每次 pop 之后又报 Memory Leak。这种情况下每回进入并退出一个页面后，就报有新的内存泄漏，同时被报泄漏的对象又从来没有释放过，可以确定是真正的内存泄漏。 Abandoned memory: Memory still referenced by your application that has no useful purpose. 释放不及时：在第一次 pop 的时候报 Memory Leak，在之后的重复 push 并 pop 同一个 ViewController 过程中，对于同一个类不断地报 Object Deallocated 和 Memory Leak。这种情况属于释放不及时的情况。 Cached memory: Memory still referenced by your application that might be used again for better performance. 单例或者被 cache 起来复用：在第一次 pop 的时候报 Memory Leak，在之后的重复 push 并 pop 同一个 ViewController 过程中，即不报 Object Deallocated，也不报 Memory Leak。这种情况下我们可以确定该对象被设计成单例或者 cache 起来了。 总结：其中 Leaked memory 和 Abandoned memory 都属于应该释放而没释放的内存，都是内存泄露，而 Leaks 工具只负责检测 Leaked memory，而不管 Abandoned memory。在 MRC 时代 Leaked memory 很常见，因为很容易忘了调用 release，但在 ARC 时代更常见的内存泄露是循环引用导致的 Abandoned memory，Leaks 工具查不出这类内存泄露，应用有限。 Allocations对于 Abandoned memory，可以用 Instrument 的 Allocations 检测出来。检测方法是用 Mark Generation 的方式，当你每次点击 Mark Generation 时，Allocations 会生成当前 App 的内存快照，而且 Allocations 会记录从上回内存快照到这次内存快照这个时间段内，新分配的内存信息。举一个最简单的例子： 我们可以不断重复 push 和 pop 同一个 UIViewController，理论上来说，push 之前跟 pop 之后，app 会回到相同的状态。因此，在 push 过程中新分配的内存，在 pop 之后应该被 dealloc 掉，除了前几次 push 可能有预热数据和 cache 数据的情况。如果在数次 push 跟 pop 之后，内存还不断增长，则有内存泄露。因此，我们在每回 push 之前跟 pop 之后，都 Mark Generation 一下，以此观察内存是不是无限制增长。 用这种方法来发现内存泄露还是很不方便的： 首先，你得打开 Allocations 其次，你得一个个场景去重复的操作 无法及时得知泄露，得专门做一遍上述操作，十分繁琐 MLeaksFinder介绍MLeaksFinder 提供了内存泄露检测更好的解决方案。只需要引入 MLeaksFinder，就可以自动在 App 运行过程检测到内存泄露的对象并立即提醒，无需打开额外的工具，也无需为了检测内存泄露而一个个场景去重复地操作。MLeaksFinder 目前能自动检测 UIViewController 和 UIView 对象的内存泄露，而且也可以扩展以检测其它类型的对象。 当发生内存泄露时，MLeaksFinder 会中断言，并准确的告诉你哪个对象泄露了。这里设计为中断言而不是打日志让程序继续跑，是因为很多人不会去看日志，断言则能强制开发者注意到并去修改，而不是犯拖延症。 中断言时，控制台会有如下提示，View-ViewController stack 从上往下看，该 stack 告诉你，MyTableViewController 的 UITableView 的 subview UITableViewWrapperView 的 subview MyTableViewCell 没被释放。而且，这里我们可以肯定的是 MyTableViewController，UITableView，UITableViewWrapperView 这三个已经成功释放了。 12345678*** Terminating app due to uncaught exception &#x27;NSInternalInconsistencyException&#x27;, reason: &#x27;Possibly Memory Leak.In case that MyTableViewCell should not be dealloced, override -willDealloc in MyTableViewCell by returning NO.View-ViewController stack: ( MyTableViewController, UITableView, UITableViewWrapperView, MyTableViewCell)&#x27; MLeaksFinder 的优点： 使用简单，不侵入业务逻辑代码，不用打开 Instrument 不需要额外的操作，你只需开发你的业务逻辑，在你运行调试时就能帮你检测 内存泄露发现及时，更改完代码后一运行即能发现（这点很重要，你马上就能意识到哪里写错了） 精准，能准确地告诉你哪个对象没被释放 MLeaksFinder流程 先通过 MLeaksFinder 找到内存泄漏的对象。 做法：MLeaksFinder 一开始从 UIViewController 入手。我们知道，当一个 UIViewController 被 pop 或 dismiss 后，该 UIViewController 包括它的 view，view 的 subviews 等等将很快被释放（除非你把它设计成单例，或者持有它的强引用，但一般很少这样做）。于是，我们只需在一个 ViewController 被 pop 或 dismiss 一小段时间后，看看该 UIViewController，它的 然后再过 FBRetainCycleDetector 检测该对象有没有循环引用。 做法:当传入内存中的任意一个 OC 对象，FBRetainCycleDetector 会递归遍历该对象的所有强引用的对象，以检测以该对象为根结点的强引用树有没有循环引用。 MLeaksFinder原理原理： 为基类 NSObject 添加一个方法 -willDealloc 方法，该方法的作用是，先用一个弱指针指向 self，并在一小段时间(3秒)后，通过这个弱指针调用 -assertNotDealloc，而 -assertNotDealloc 主要作用是直接中断言。当一个 UIViewController 被 pop 或 dismiss 时（我们认为它应该要被释放了），我们遍历该 UIViewController 上的所有 view，依次调 -willDealloc，若3秒后没被释放，就会中断言。 12345678910- (BOOL)willDealloc &#123; __weak id weakSelf = self; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [weakSelf assertNotDealloc]; &#125;); return YES;&#125;- (void)assertNotDealloc &#123; NSAssert(NO, @“”);&#125; 在这里，有几个问题需要解决： 不入侵开发代码这里使用了 AOP 技术，hook 掉 UIViewController 和 UINavigationController 的 pop 跟 dismiss 方法。 遍历相关对象在实际项目中，我们发现有时候一个 UIViewController 被释放了，但它的 view 没被释放，或者一个 UIView 被释放了，但它的某个 subview 没被释放。这种内存泄露的情况很常见，因此，我们有必要遍历基于 UIViewController 的整棵 View-ViewController 树。我们通过 UIViewController 的 presentedViewController 和 view 属性，UIView 的 subviews 属性等递归遍历。对于某些 ViewController，如 UINavigationController，UISplitViewController 等，我们还需要遍历 viewControllers 属性。 构建堆栈信息需要构建 View-ViewController stack 信息以告诉开发者是哪个对象没被释放。在递归遍历 View-ViewController 树时，子节点的 stack 信息由父节点的 stack 信息加上子结点信息即可。 例外机制对于有些 ViewController，在被 pop 或 dismiss 后，不会被释放（比如单例），因此需要提供机制让开发者指定哪个对象不会被释放，这里可以通过重载上面的 -willDealloc 方法，直接 return NO 即可。 特殊情况对于某些特殊情况，释放的时机不大一样（比如系统手势返回时，在划到一半时 hold 住，虽然已被 pop，但这时还不会被释放，ViewController 要等到完全 disappear 后才释放），需要做特殊处理，具体的特殊处理视具体情况而定。 系统View某些系统的私有 View，不会被释放（可能是系统 bug 或者是系统出于某些原因故意这样做的，这里就不去深究了），因此需要建立白名单 手动扩展MLeaksFinder目前只检测 ViewController 跟 View 对象。为此，MLeaksFinder 提供了一个手动扩展的机制，你可以从 UIViewController 跟 UIView 出发，去检测其它类型的对象的内存泄露。如下所示，我们可以检测 UIViewController 底下的 View Model： 12345678- (BOOL)willDealloc &#123; if (![super willDealloc]) &#123; return NO; &#125; MLCheck(self.viewModel); return YES;&#125; 这里的原理跟上面的是一样的，宏 MLCheck() 做的事就是为传进来的对象建立 View-ViewController stack 信息，并对传进来的对象调用 -willDealloc 方法。 MLeaksFinder源码1、MLeaksFinder.hMLeaksFinder.h定义了MLeaksFinder中使用的宏 123456789101112131415161718192021222324#ifdef MEMORY_LEAKS_FINDER_ENABLED //_INTERNAL_MLF_ENABLED 宏用来控制 MLLeaksFinder库 //什么时候开启检测，可以自定义这个时机，默认则是在DEBUG模式下会启动，RELEASE模式下不启动//它是通过预编译来实现的#define _INTERNAL_MLF_ENABLED MEMORY_LEAKS_FINDER_ENABLED #else #define _INTERNAL_MLF_ENABLED DEBUG #endif //_INTERNAL_MLF_RC_ENABLED 宏用来控制 是否开启循环引用的检测#ifdef MEMORY_LEAKS_FINDER_RETAIN_CYCLE_ENABLED #define _INTERNAL_MLF_RC_ENABLED MEMORY_LEAKS_FINDER_RETAIN_CYCLE_ENABLED //COCOAPODS 因为MLLeaksFinder引用了第三库用来检查循环引用，所以必须是当前项目中使用了COCOAPODS，才能使用这个功能。#elif COCOAPODS #define _INTERNAL_MLF_RC_ENABLED COCOAPODS #endif 2.MLeakedObjectProxyMLeakedObjectProxy用来对泄漏对象检查循环引用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//用来检查当前泄漏对象是否已经添加到泄漏对象集合中，如果是，就不再添加也不再提示开发者+ (BOOL)isAnyObjectLeakedAtPtrs:(NSSet *)ptrs&#123; NSAssert([NSThread isMainThread], @&quot;Must be in main thread.&quot;); static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; //全局用于保存泄漏对象的集合 leakedObjectPtrs = [[NSMutableSet alloc] init]; &#125;); if (!ptrs.count) &#123; return NO; &#125; //NSSet求交集 if ([leakedObjectPtrs intersectsSet:ptrs]) &#123; return YES; &#125; else &#123; return NO; &#125;&#125;+ (void)addLeakedObject:(id)object &#123; NSAssert([NSThread isMainThread], @&quot;Must be in main thread.&quot;); //创建用于检查循环引用的objectProxy对象 MLeakedObjectProxy *proxy = [[MLeakedObjectProxy alloc] init]; proxy.object = object; proxy.objectPtr = @((uintptr_t)object); proxy.viewStack = [object viewStack]; static const void *const kLeakedObjectProxyKey = &amp;kLeakedObjectProxyKey; objc_setAssociatedObject(object, kLeakedObjectProxyKey, proxy, OBJC_ASSOCIATION_RETAIN); [leakedObjectPtrs addObject:proxy.objectPtr]; #if _INTERNAL_MLF_RC_ENABLED //带有循环引用检查功能的提示框 [MLeaksMessenger alertWithTitle:@&quot;Memory Leak&quot; message:[NSString stringWithFormat:@&quot;%@&quot;, proxy. viewStack] delegate:proxy additionalButtonTitle:@&quot;Retain Cycle&quot;]; #else //普通提示框 [MLeaksMessenger alertWithTitle:@&quot;Memory Leak&quot; message:[NSString stringWithFormat:@&quot;%@&quot;, proxy. viewStack]]; #endif &#125;- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex &#123; #if _INTERNAL_MLF_RC_ENABLED dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; FBRetainCycleDetector *detector = [FBRetainCycleDetector new]; [detector addCandidate:self.object]; NSSet *retainCycles = [detector findRetainCyclesWithMaxCycleLength:20]; BOOL hasFound = NO; //retainCycles中是找到的所有循环引用的链 for (NSArray *retainCycle in retainCycles) &#123; NSInteger index = 0; for (FBObjectiveCGraphElement *element in retainCycle) &#123; //找到当前内存泄漏对象所在的循环引用的链 if (element.object == object) &#123; //把当前对象调整到第一个的位置，方便查看 NSArray *shiftedRetainCycle = [self shiftArray:retainCycle toIndex:index]; dispatch_async(dispatch_get_main_queue(), ^&#123; [MLeaksMessenger alertWithTitle:@&quot;Retain Cycle&quot; message:[NSString stringWithFormat:@&quot;%@&quot;, shiftedRetainCycle]]; &#125;); hasFound = YES; break; &#125; ++index; &#125; if (hasFound) &#123; break; &#125; &#125; if (!hasFound) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [MLeaksMessenger alertWithTitle:@&quot;Retain Cycle&quot; message:@&quot;Fail to find a retain cycle&quot;]; &#125;); &#125; &#125;); #endif &#125; 3.NSObject+MemoryLeak NSObject+MemoryLeak主要功能存储对象的父子节点的树形结构，method swizzle逻辑 ，白名单以及判断对象是否发生内存泄漏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122- (BOOL)willDealloc &#123; NSString *className = NSStringFromClass([self class]); //通过白名单可以配置哪些对象不纳入检查，例如一些单例 if ([[NSObject classNamesInWhiteList] containsObject:className]) return NO; NSNumber *senderPtr = objc_getAssociatedObject([UIApplication sharedApplication], kLatestSenderKey); if ([senderPtr isEqualToNumber:@((uintptr_t)self)]) return NO; __weak id weakSelf = self; //在特定时间检查对象是否已经发生内存泄漏 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC) ), dispatch_get_main_queue(), ^&#123; __strong id strongSelf = weakSelf; //如果对象已经被释放，strongSelf为nil 调用该方法什么也不发生 [strongSelf assertNotDealloc]; &#125;); return YES;&#125; //改方法被调用说明改对象已经发生内存泄漏- (void)assertNotDealloc &#123; //检查是否已经记录，如果是，不再提示用户 if ([MLeakedObjectProxy isAnyObjectLeakedAtPtrs:[self parentPtrs]]) &#123; return; &#125; [MLeakedObjectProxy addLeakedObject:self]; NSString *className = NSStringFromClass([self class]); NSLog(@&quot;Possibly Memory Leak.\\nIn case that %@ should not be dealloced, override -willDealloc in %@ by returning NO.\\nView-ViewController stack: %@ &quot;, className, className, [self viewStack]); &#125; //主要通过递归来记录每个节点在树形结构中的位置，以及父子节点的指针- (void)willReleaseChildren:(NSArray *)children &#123; NSArray *viewStack = [self viewStack]; NSSet *parentPtrs = [self parentPtrs]; for (id child in children) &#123; NSString *className = NSStringFromClass([child class]); [child setViewStack:[viewStack arrayByAddingObject:className]]; [child setParentPtrs:[parentPtrs setByAddingObject:@((uintptr_t)child)]]; [child willDealloc]; &#125;&#125;+ (void)swizzleSEL:(SEL)originalSEL withSEL:(SEL)swizzledSEL &#123; //通过预编译控制是否hook方法#if _INTERNAL_MLF_ENABLED //通过预编译控制是否检查循环引用#if _INTERNAL_MLF_RC_ENABLED // Just find a place to set up FBRetainCycleDetector. static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [FBAssociationManager hook]; &#125;); &#125;); #endif Class class = [self class]; Method originalMethod = class_getInstanceMethod(class, originalSEL); Method swizzledMethod = class_getInstanceMethod(class, swizzledSEL); BOOL didAddMethod = //class_addMethod主要是用来给某个类添加一个方法，originalSEL相当于是方法名称,method_getIm //plementtation是方法实现, 它返回一个BOOL类型的值 //在当前class中没有叫originalSEL的方法( //具体不是看interface里没有没有声明，而是看implementaion文件里有没有方法实现)， // 并且有swizzledMethod方法的实现 //这个时候该函数会返回true，其他情况均返回false class_addMethod(class, originalSEL, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; //didAddMethod为true 说明swizzledMethod之前不存在，通过class_addMethod函数添加了一个名字叫origninalSEL，实现是swizzledMoethod函数。 class_replaceMethod(class, swizzledSEL, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; //didAddMethod为false 说明swizzledMethod方法已经存在，直接交换二者实现 method_exchangeImplementations(originalMethod, swizzledMethod); &#125; #endif &#125; 4.UINavigationController + MemoryLeak UINavigationController + MemoryLeak 主要是通过UINavigationController的方法去检测子UIViewController页面的生命周期，UIViewController的生命周期由UINavigationController的方法和UIViewController自身的一些方法共同决定的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//现在在具体的类型中添加方法hook，加载load中并且调用dspatch_once来保证只初始化一次，load是必然会调用的，并且category的load方法调用和类自身的load方法调用是分开的，互不干扰。+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [self swizzleSEL:@selector(pushViewController:animated:) withSEL:@ selector(swizzled_pushViewController:animated:)]; [self swizzleSEL:@selector(popViewControllerAnimated:) withSEL:@ selector(swizzled_popViewControllerAnimated:)]; [self swizzleSEL:@selector(popToViewController:animated:) withSEL:@ selector(swizzled_popToViewController:animated:)]; [self swizzleSEL:@selector(popToRootViewControllerAnimated:) withSEL:@ selector(swizzled_popToRootViewControllerAnimated:)]; &#125;);&#125; - (void)swizzled_pushViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; if (self.splitViewController) &#123; //这里主要是考虑到app中有使用splitViewController的情况的时候，下一个根页面push之后， //之前被pop的根页面才会回收 id detailViewController = objc_getAssociatedObject(self, kPoppedDetailVCKey); if ([detailViewController isKindOfClass:[UIViewController class]]) &#123; //回收之前被pop的根页面 [detailViewController willDealloc]; objc_setAssociatedObject(self, kPoppedDetailVCKey, nil, OBJC_ASSOCIATION_RETAIN); &#125; &#125; [self swizzled_pushViewController:viewController animated:animated]; &#125;- (UIViewController *)swizzled_popViewControllerAnimated:(BOOL)animated &#123; UIViewController *poppedViewController = [self swizzled_popViewControllerAnimated:animated]; if (!poppedViewController) &#123; return nil; &#125; //当前页面是spliteViewController根页面 if (self.splitViewController &amp;&amp; self.splitViewController.viewControllers.firstObject == self &amp;&amp; self.splitViewController == poppedViewController.splitViewController) &#123; objc_setAssociatedObject(self, kPoppedDetailVCKey, poppedViewController , OBJC_ASSOCIATION_RETAIN); return poppedViewController; &#125; // VC is not dealloced until disappear when popped using a left-edge swipe gesture extern const void *const kHasBeenPoppedKey; objc_setAssociatedObject(poppedViewController, kHasBeenPoppedKey, @(YES), OBJC_ASSOCIATION_RETAIN); return poppedViewController; &#125; - (NSArray&lt;UIViewController *&gt; *)swizzled_popToViewController:( UIViewController *)viewController animated:(BOOL)animated &#123; NSArray&lt;UIViewController *&gt; *poppedViewControllers = [self swizzled_popToViewController:viewController animated:animated]; //一次性pop多个页面的时候，这些页面的viewDidDisappear估计都没有被调用，直接回收了 for (UIViewController *viewController in poppedViewControllers) &#123; [viewController willDealloc]; &#125; return poppedViewControllers; &#125; 5.UIViewController + MemoryLeak 12345678910111213141516171819202122232425262728293031- (void)swizzled_viewDidDisappear:(BOOL)animated &#123; [self swizzled_viewDidDisappear:animated]; //仅仅当是pop引起viewDidDisappear的时候才释放(当被挡住之后也会调用ViewDidDisappear) if ([objc_getAssociatedObject(self, kHasBeenPoppedKey) boolValue]) &#123; [self willDealloc]; &#125; &#125; - (void)swizzled_dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion &#123; [self swizzled_dismissViewControllerAnimated:flag completion:completion]; //dismiss掉presentedViewController，释放它 (但是什么时候当前viewController被释放呢) UIViewController *dismissedViewController = self.presentedViewController; if (!dismissedViewController &amp;&amp; self.presentingViewController) &#123; //释放自己 dismissedViewController = self; &#125; if (!dismissedViewController) return; //以present出来的viewcontroller，不通过DidDisappear去判断是否释放了 [dismissedViewController willDealloc]; &#125; 实际项目中使用cocoapods集成只需要在podfile文件中加入相关库即可。pod &#39;MLeaksFinder&#39;","categories":[{"name":"OC-三方框架探索篇","slug":"OC-三方框架探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-三方框架探索篇","slug":"OC-三方框架探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC三方框架04：HDCollectionView探索","slug":"OC三方框架/OC三方框架04：HDCollectionView探索","date":"2020-08-04T08:47:31.000Z","updated":"2020-10-17T05:50:14.000Z","comments":true,"path":"2020/08/04/OC三方框架/OC三方框架04：HDCollectionView探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/04/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B604%EF%BC%9AHDCollectionView%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"1.HDCollectionView 初始化 (配置的参数优先级高于默认值) 1234/** HDCollectionView 初始化 (配置的参数优先级高于默认值) */+ (__kindof HDCollectionView*)hd_makeHDCollectionView:(void(^ _Nullable)(HDCollectionViewMaker*maker))maker; 2.刷新colletionView 1234/** 刷新colletionView */- (void)hd_reloadData; 3.一次性初始化所有数据 (完成后会回调 dataChangeFinishedCallBack) 1234/** 一次性初始化所有数据 (完成后会回调 dataChangeFinishedCallBack) */- (void)hd_setAllDataArr:(NSArray&lt;id&lt;HDSectionModelProtocol&gt;&gt;* _Nullable)dataArr; 4.包含所有数据改变相关方法完成后的回调（即setAll&#x2F;append&#x2F;delete&#x2F;change相关的函数完成后都会在此回调） 1234/**包含所有数据改变相关方法完成后的回调（即setAll/append/delete/change相关的函数完成后都会在此回调） */- (void)hd_dataChangeFinishedCallBack:(void(^)(HDDataChangeType changeType))finishCallback; 5.直接添加一个新的secModel (完成后会回调 dataChangeFinishedCallBack) 1234/**直接添加一个新的secModel (完成后会回调 dataChangeFinishedCallBack) */- (void)hd_appendDataWithSecModel:(id&lt;HDSectionModelProtocol&gt;)secModel animated:(BOOL)animated; 6.插入一个secModel到指定位置 index &lt;&#x3D; 0 插入到首段 index &gt;&#x3D; allDataArr.count 添加到最后一段 0 &lt; index &lt; allDataArr.count 插入到index段的前面 1234567/**插入一个secModel到指定位置 index &lt;= 0 插入到首段 index &gt;= allDataArr.count 添加到最后一段 0 &lt; index &lt; allDataArr.count 插入到index段的前面 */- (void)hd_insertDataWithSecModel:(id&lt;HDSectionModelProtocol&gt;)secModel atIndex:(NSInteger)index animated:(BOOL)animated; 7.向某个段内增加cell&#x2F;默认的sectionKey是第几段 该方法目前对于瀑布流元素的增加，内部计算是增量计算的。但对于HDYogaFlowLayout会对该段整体重新计算 如果想增量计算HDYogaFlowLayout，使用hd_appendDataWithSecModel，新增一个新的段。 1234567/** 向某个段内增加cell/默认的sectionKey是第几段 该方法目前对于瀑布流元素的增加，内部计算是增量计算的。但对于HDYogaFlowLayout会对该段整体重新计算 如果想增量计算HDYogaFlowLayout，使用hd_appendDataWithSecModel，新增一个新的段。 */- (void)hd_appendDataWithCellModelArr:(NSArray&lt;id&lt;HDCellModelProtocol&gt;&gt;*)itemArr sectionKey:(NSString*)sectionKey animated:(BOOL)animated animationFinishCallback:(void(^ _Nullable)(void))animationFinish;- (void)hd_appendDataWithCellModelArr:(NSArray&lt;id&lt;HDCellModelProtocol&gt;&gt;*)itemArr sectionKey:(NSString*)sectionKey animated:(BOOL)animated; 8.如果仅仅是向secModel新增cellModel，使用 hd_appendDataWithCellModelArr方法 该方法改变已有的某个section内的数据，比如对sectionDataArr增删 如果设置了SectionModel的sectionKey，则可以通过sectionKey来获取secModel。默认的sectionKey是当前段数 想要刷新一个或几个cell的UI时，调用此方法 123456789/** 如果仅仅是向secModel新增cellModel，使用 hd_appendDataWithCellModelArr方法 该方法改变已有的某个section内的数据，比如对sectionDataArr增删 如果设置了SectionModel的sectionKey，则可以通过sectionKey来获取secModel。默认的sectionKey是当前段数 想要刷新一个或几个cell的UI时，调用此方法 */- (void)hd_changeSectionModelWithKey:(nullable NSString*)sectionKey animated:(BOOL)animated changingIn:(void(^)(id&lt;HDSectionModelProtocol&gt; secModel))changeBlock animationFinishCallback:(void(^ _Nullable)(void))animationFinish;- (void)hd_changeSectionModelWithKey:(nullable NSString*)sectionKey animated:(BOOL)animated changingIn:(void(^)(id&lt;HDSectionModelProtocol&gt; secModel))changeBlock; 9.删除某段的所有内容 12345/** 删除某段的所有内容 */- (void)hd_deleteSectionWithKey:(nullable NSString*)sectionKey animated:(BOOL)animated animationFinishCallback:(void(^ _Nullable)(void))animationFinish;- (void)hd_deleteSectionWithKey:(nullable NSString*)sectionKey animated:(BOOL)animated; 10.某个key的sectionModel是否存在 1234/** 某个key的sectionModel是否存在 */- (BOOL)hd_sectionModelExist:(NSString*)sectionKey; 11.删除某段的所有内容 12345/** 删除某段的所有内容 */- (void)hd_deleteSectionWithKey:(nullable NSString*)sectionKey animated:(BOOL)animated animationFinishCallback:(void(^ _Nullable)(void))animationFinish;- (void)hd_deleteSectionWithKey:(nullable NSString*)sectionKey animated:(BOOL)animated;","categories":[{"name":"OC-三方框架探索篇","slug":"OC-三方框架探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-三方框架探索篇","slug":"OC-三方框架探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC三方框架02：SDCycleScrollView探索","slug":"OC三方框架/OC三方框架02：SDCycleScrollView探索","date":"2020-08-03T01:56:05.000Z","updated":"2023-03-08T22:50:33.223Z","comments":true,"path":"2020/08/03/OC三方框架/OC三方框架02：SDCycleScrollView探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/03/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B602%EF%BC%9ASDCycleScrollView%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"原理SDSycleScrollView 的 原理 是基于 UICollectionView 的 重用机制 和 循环滚动的方式实现图片的轮播滚动功能。 主要功能1.简单易用的图片无限轮播2.支持横向、竖向两种滑动方式3.支持轮播自定义cell的代理方法4.增加禁止拖动手势api 集成 SDSyscleScrollView现在的主流集成方式都是基于依赖管理工具Cocoapods来集成SDSyscleScrollView的，而 SDSyscleScrollView 是依赖 SDWebImage 显示网络数据的，但是这个框架不用我们自己去集成，当你集成 SDSyscleScrollView 时，会自动集成依赖的SDWebImage 库，具体集成流程如下： 首先，保证你的项目是基于Cocoapods依赖管理工具集成的项目，具体的集成文档自行百度。 在终端输入 pod search SDSyscleScrollView 查看这个库的信息： 12mac@MacdeMBP ~ % pod search SDCycleScrollView/System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0/universal-darwin19/rbconfig.rb:229: warning: Insecure world writable dir /usr/local/sbin in PATH, mode 040777 稍等一会，你会看到下面的列表信息： 由列表信息我们知道当前的 SDSyscleScrollView 的版本是 1.80， 且 适配 SDWebImage 5.0.0版本。 3.复制上面的 pod &#39;SDCycleScrollView , 在底部 : 号后面输入 wq，保存并退出，此时你可以到项目中的Podfile文件下 粘贴 你的复制的内容： 注： pod &#39;SDCycleScrollView：意味着你只安装最新的版本 pod &#39;SDCycleScrollView&#39;, &#39;~&gt; 1.80‘：意味着你安装的是固定版本 1.80 cd 到工程主目录下，终端输入 pod install 命令，等待安装完成： 源码解读 在 SDSyscleScrollView 类中可以看到初始化方式有四种： 123456789101112/** 初始轮播图（推荐使用） */+ (instancetype)cycleScrollViewWithFrame:(CGRect)frame delegate:(id&lt;SDCycleScrollViewDelegate&gt;)delegate placeholderImage:(UIImage *)placeholderImage;+ (instancetype)cycleScrollViewWithFrame:(CGRect)frame imageURLStringsGroup:(NSArray *)imageURLStringsGroup;/** 本地图片轮播初始化方式 */+ (instancetype)cycleScrollViewWithFrame:(CGRect)frame imageNamesGroup:(NSArray *)imageNamesGroup;/** 本地图片轮播初始化方式2,infiniteLoop:是否无限循环 */+ (instancetype)cycleScrollViewWithFrame:(CGRect)frame shouldInfiniteLoop:(BOOL)infiniteLoop imageNamesGroup:(NSArray *)imageNamesGroup; 数据源 12345678910////////////////////// 数据源API ///////////////////////** 网络图片 url string 数组 */@property (nonatomic, strong) NSArray *imageURLStringsGroup;/** 每张图片对应要显示的文字数组 */@property (nonatomic, strong) NSArray *titlesGroup;/** 本地图片数组 */@property (nonatomic, strong) NSArray *localizationImageNamesGroup; 滚动控制API 12345678910111213141516171819202122232425262728////////////////////// 滚动控制API ///////////////////////** 自动滚动间隔时间,默认2s */@property (nonatomic, assign) CGFloat autoScrollTimeInterval;/** 是否无限循环,默认Yes */@property (nonatomic,assign) BOOL infiniteLoop;/** 是否自动滚动,默认Yes */@property (nonatomic,assign) BOOL autoScroll;/** 图片滚动方向，默认为水平滚动 */@property (nonatomic, assign) UICollectionViewScrollDirection scrollDirection;@property (nonatomic, weak) id&lt;SDCycleScrollViewDelegate&gt; delegate;/** block方式监听点击 */@property (nonatomic, copy) void (^clickItemOperationBlock)(NSInteger currentIndex);/** block方式监听滚动 */@property (nonatomic, copy) void (^itemDidScrollOperationBlock)(NSInteger currentIndex);/** 可以调用此方法手动控制滚动到哪一个index */- (void)makeScrollViewScrollToIndex:(NSInteger)index;/** 解决viewWillAppear时出现时轮播图卡在一半的问题，在控制器viewWillAppear时调用此方法 */- (void)adjustWhenControllerViewWillAppera; 自定义样式API 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061////////////////////// 自定义样式API ///////////////////////** 轮播图片的ContentMode，默认为 UIViewContentModeScaleToFill */@property (nonatomic, assign) UIViewContentMode bannerImageViewContentMode;/** 占位图，用于网络未加载到图片时 */@property (nonatomic, strong) UIImage *placeholderImage;/** 是否显示分页控件 */@property (nonatomic, assign) BOOL showPageControl;/** 是否在只有一张图时隐藏pagecontrol，默认为YES */@property(nonatomic) BOOL hidesForSinglePage;/** 只展示文字轮播 */@property (nonatomic, assign) BOOL onlyDisplayText;/** pagecontrol 样式，默认为动画样式 */@property (nonatomic, assign) SDCycleScrollViewPageContolStyle pageControlStyle;/** 分页控件位置 */@property (nonatomic, assign) SDCycleScrollViewPageContolAliment pageControlAliment;/** 分页控件距离轮播图的底部间距（在默认间距基础上）的偏移量 */@property (nonatomic, assign) CGFloat pageControlBottomOffset;/** 分页控件距离轮播图的右边间距（在默认间距基础上）的偏移量 */@property (nonatomic, assign) CGFloat pageControlRightOffset;/** 分页控件小圆标大小 */@property (nonatomic, assign) CGSize pageControlDotSize;/** 当前分页控件小圆标颜色 */@property (nonatomic, strong) UIColor *currentPageDotColor;/** 其他分页控件小圆标颜色 */@property (nonatomic, strong) UIColor *pageDotColor;/** 当前分页控件小圆标图片 */@property (nonatomic, strong) UIImage *currentPageDotImage;/** 其他分页控件小圆标图片 */@property (nonatomic, strong) UIImage *pageDotImage;/** 轮播文字label字体颜色 */@property (nonatomic, strong) UIColor *titleLabelTextColor;/** 轮播文字label字体大小 */@property (nonatomic, strong) UIFont *titleLabelTextFont;/** 轮播文字label背景颜色 */@property (nonatomic, strong) UIColor *titleLabelBackgroundColor;/** 轮播文字label高度 */@property (nonatomic, assign) CGFloat titleLabelHeight;/** 轮播文字label对齐方式 */@property (nonatomic, assign) NSTextAlignment titleLabelTextAlignment;/** 滚动手势禁用（文字轮播较实用） */- (void)disableScrollGesture; 缓存 1234567////////////////////// 清除缓存API ///////////////////////** 清除图片缓存（此次升级后统一使用SDWebImage管理图片加载和缓存） */+ (void)clearImagesCache;/** 清除图片缓存（兼容旧版本方法） */- (void)clearCache; 代理 12345678910111213141516171819202122232425@protocol SDCycleScrollViewDelegate &lt;NSObject&gt;@optional/** 点击图片回调 */- (void)cycleScrollView:(SDCycleScrollView *)cycleScrollView didSelectItemAtIndex:(NSInteger)index;/** 图片滚动回调 */- (void)cycleScrollView:(SDCycleScrollView *)cycleScrollView didScrollToIndex:(NSInteger)index;// 不需要自定义轮播cell的请忽略以下两个的代理方法// ========== 轮播自定义cell ==========/** 如果你需要自定义cell样式，请在实现此代理方法返回你的自定义cell的class。 */- (Class)customCollectionViewCellClassForCycleScrollView:(SDCycleScrollView *)view;/** 如果你需要自定义cell样式，请在实现此代理方法返回你的自定义cell的Nib。 */- (UINib *)customCollectionViewCellNibForCycleScrollView:(SDCycleScrollView *)view;/** 如果你自定义了cell样式，请在实现此代理方法为你的cell填充数据以及其它一系列设置 */- (void)setupCustomCell:(UICollectionViewCell *)cell forIndex:(NSInteger)index cycleScrollView:(SDCycleScrollView *)view;@end 由代理可知，实际上有两个功能 回调的滚动和点击事件 自动以cell样式 项目中使用 SDSyscleScrollView由于实际项目中，轮播图的主要应用是展示网络图片，并点击能进入下一个控制器，因此，下面我主要介绍这种类型功能的使用： 声明属性，并初始化（使用推荐方式），设置占位图 1234567891011121314151617181920212223@interface SDSyscleScrollViewVC ()&lt;SDCycleScrollViewDelegate&gt;@property (nonatomic,strong)SDCycleScrollView * scrollV;@property (nonatomic,copy)NSArray * imgsArr;@end#pragma mark -懒加载- (SDCycleScrollView *)scrollV&#123; if (!_scrollV) &#123; _scrollV = [SDCycleScrollView cycleScrollViewWithFrame:CGRectMake(0, kNavAndStatusHeight, kScreenWidth, 200) delegate:self placeholderImage:kImg(@&quot;placeholder&quot;)]; _scrollV.backgroundColor = kRandomColor; &#125; return _scrollV;&#125;- (NSArray *)imgsArr&#123; if (!_imgsArr) &#123; _imgsArr = @[ @&quot;https://user-images.githubusercontent.com/25925248/94383795-9a81d980-0173-11eb-8b6b-df2e3fa7f139.png&quot;, @&quot;https://user-images.githubusercontent.com/25925248/94384327-e719e480-0174-11eb-9a54-797a578b4a3a.png&quot;, @&quot;https://user-images.githubusercontent.com/25925248/94384868-3c0a2a80-0176-11eb-958c-054e19244d4e.png&quot;]; &#125; return _imgsArr;&#125; 添加到要显示的view上 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = kWhiteColor; // scrollV [self.view addSubview:self.scrollV]; &#125; 设置相关API具体可以参照上面API去设置，得到你想要的效果 待网络请求成功，返回图片数据时，设置图片数据 1self.scrollV.imageURLStringsGroup = self.imgArr; 通过代码方法可以得到你要下标和你要跳转的设置 123456789#pragma mark -SDCycleScrollViewDelegate// 点击图片的回调- (void)cycleScrollView:(SDCycleScrollView *)cycleScrollView didSelectItemAtIndex:(NSInteger)index&#123; NSLog(@&quot;index:%ld&quot;,index);&#125;// 图片滚动回调- (void)cycleScrollView:(SDCycleScrollView *)cycleScrollView didScrollToIndex:(NSInteger)index&#123; NSLog(@&quot;index:%ld&quot;,index);&#125; 经过上面的基本设置，已经可以满足你的需求了，如果还未满足，那么你可以自定义cell去实现，是继承自 CollectionViewCell ： .h中实现 1234@interface SDSyscleScrollViewVC ()&lt;SDCycleScrollViewDelegate&gt;@property (nonatomic,strong)SDCycleScrollView * scrollV;@property (nonatomic,copy)NSArray * imgsArr;@end .m中实现 123456789101112131415161718192021222324@implementation SDCell- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; [self initUI]; &#125; return self;&#125;- (void)initUI&#123; [self.contentView addSubview:self.img]; [self.img mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.mas_equalTo(UIEdgeInsetsMake(0, 0, 0, 0)); &#125;];&#125;- (UIImageView *)img&#123; if (!_img) &#123; _img = [UIImageView initImgVWithFrame:CGRectZero bgColor:kRandomColor img:kPlaceholder userInteractionEnabled:YES hidden:NO]; &#125; return _img;&#125;@end 在viewDidLoad中实现 123456789101112// 如果你需要自定义cell样式，请在实现此代理方法返回你的自定义cell的class- (Class)customCollectionViewCellClassForCycleScrollView:(SDCycleScrollView *)view&#123; SDCell * cell = [[SDCell alloc] init]; cell.backgroundColor = kRandomColor; return cell.class;&#125;// 如果你自定义了cell样式，请在实现此代理方法为你的cell填充数据以及其它一系列设置- (void)setupCustomCell:(UICollectionViewCell *)cell forIndex:(NSInteger)index cycleScrollView:(SDCycleScrollView *)view&#123; SDCell * sdCell = (SDCell *)cell; [sdCell.img sd_setImageWithURL:kUrl(self.imgsArr[index])];&#125;","categories":[{"name":"OC-三方框架探索篇","slug":"OC-三方框架探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-三方框架探索篇","slug":"OC-三方框架探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC：YYWebImage基本用法","slug":"OC三方框架/OC三方框架01：YYWebImage探索","date":"2020-08-02T08:27:33.000Z","updated":"2020-10-17T05:50:01.000Z","comments":true,"path":"2020/08/02/OC三方框架/OC三方框架01：YYWebImage探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/02/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B601%EF%BC%9AYYWebImage%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"","categories":[{"name":"OC-三方框架探索篇","slug":"OC-三方框架探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-三方框架探索篇","slug":"OC-三方框架探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC学习14：cocoapods探索","slug":"OC学习/OC学习14：cocoapods探索","date":"2020-08-01T08:33:41.000Z","updated":"2023-03-08T23:03:05.125Z","comments":true,"path":"2020/08/01/OC学习/OC学习14：cocoapods探索/","link":"","permalink":"https://www.bboyzj.cn/2020/08/01/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A014%EF%BC%9Acocoapods%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"CocoaPods 简介每种语言发展到一个阶段，就会出现响应的 依赖管理工具,例如Java的Maven，nodejs的nmp，随着iOS开发者的增多，业界出现了为iOS程序提供依赖管理工具，它的名字叫做：Cocoapods。 Cocoapods项目源码存放在Github上进行管理，我们在开发iOS项目时，不可避免的要使用第三方开源库，Cocoapods的出现使我们节省了设置和更新第三方开源库的时间。 从Github上我们可以看到它是用Ruby写的，主要依赖于Ruby环境，Ruby 是一种真正的面向对象编程语言，它是由日本的松本行弘（まつもとゆきひろ/Yukihiro Matsumoto）创建于1993年，与Perl、Python等类似，是一种脚本语言。 Ruby查看在安装Cocoapods管理依赖工具前，我们需要保证Ruby环境是最新的，否则会出现一些安装问题 默认情况下，MacOS 系统已经安装好 Ruby，默认安装在/System/Library/Frameworks/Ruby.framework/Versions/Current 目录下，但不是最新的环境 在终端可以直接通过以下命令，确认系统的Ruby的版本信息: 12mac@MacdeMBP ~ % ruby -vruby 2.6.3p62 (2019-04-16 revision 67580) [universal.x86_64-darwin19] 但是，由于默认的 Ruby 安装在 /System 目录下，过深的、与 linux 约定不同的目录结构对日常的开发、维护都带来许多不便。 所以，在 MacOS 上推荐使用 homebrew 来安装、管理 Ruby 的版本。 homebrew 安装 Ruby1.安装 homebrew 在终端下，执行下面的命令，即可完成homebrew的安装（注:安装过程中提示输入当前用户的密码）： 1ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&quot; 该命令将会从 homebrew 的 GitHub 仓库抓取最新版本并自动完成安装。安装成功后，即可使用 brew 命令来安装 Ruby 的最新版本，以及其他工具。 homebrew 的默认安装目录为 /usr/local，所有通过 brew 安装的程序都会默认安装到 /usr/local/Cellars/程序名/版本号/ 目录下。 2.通过 brew 安装 Ruby 最新版本在终端下执行以下命令，即可自动完成最新版本Ruby的安装： 12brew updatebrew install ruby 说明: brew update 将会从 GitHub 上更新 brew 所支持的所有软件的版本信息，保证你能够安装到最新的版本 brew install ruby 将会从 Ruby 的 GitHub 仓库抓取最新版本的代码，并编译安装 3.安装成功后，重新执行 ruby -v 确认已成功安装了最新版本的 Ruby： 12ruby -vruby 2.6.3p62 (2019-04-16 revision 67580) [universal.x86_64-darwin19] 替换镜像源默认的镜像资源服务器被天朝给墙了。所以需要先更换源地址，然后再安装。 1.移除原先的 Ruby 源： 1$ gem sources --remove https://rubygems.org/ 2.指定为 Ruby China 的镜像源： 1$ gem sources --add https://gems.ruby-china.com/ 3.验证新源是否替换成功 1234$ gem sources -l*** CURRENT SOURCES ***https://gems.ruby-china.com/ Cocoapods 安装使用 ruby 的 gem 命令下载并安装 CocoaPods。 1.macOS Catalina系统版本之前用：$sudo gem install cocoapods；macOS Catalina系统版本之前版本后需要改为 : $ sudo gem install -n /usr/local/bin cocoapods 2.安装$ pod setup 所有项目的 Podspec 文件都托管在 https://github.com/CocoaPods/Specs 中。第一次执行 pod setup 时，CocoaPods 会将这些 Podspec 索引文件更新到本地的 ~/.cocoapods/目录下，该索引文件较大且更新非常缓慢。 可以替换镜像，有两种方式：gitcafe 或者 occhina 镜像： 123pod repo remove masterpod repo add master https://gitcafe.com/akuandev/Specs.gitpod repo update 也可以将以上代码中的 https://gitcafe.com/akuandev/Specs.git 替换成 http://git.oschina.net/akuandev/Specs.git 即可使用 occhina 上的镜像。 搜索相关框架打开终端，输入以下命令：pod search 框架名，如搜索网络框架 AFNetworking 1$ pod search AFNetworking 移除 trunk 源如果执行 pod 相关命令时，显示 CDN 无法连接、连接超时之类的情况，可以移除 trunk 源，然后在 Podfile 文件中第一行指明依赖库的来源地址，不使用默认 CDN。 1$ pod repo remove trunk 项目中的使用1、创建Podfile文件 新建 Xcode 项目，在终端里 cd 到项目的主文件夹(就是包含 项目.xcodeproj 的文件)。执行命令： 123# 1. 创建 Podfile 文件$ pod init 2.编辑 Podfile 文件有两种方式： 【方法一】：终端编辑 vim Podfile执行 vim Podfile 命令后，会打开上一步骤创建的 Podfile 文件，你需要通过 vim 编辑此文件，默认进入命令模式。 键盘命令 i :input，输入模式 键盘命令 ESC : 从输入模式退出到命令模式 键盘命令 shift + : : 在命令模式下，输入该键盘组合命令，就会进入末行模式 键盘命令 wq : 在末行模式下，输入 wq ，即 write and quit，保存并退出！ 【方法二】：直接打开项目文件 Podfile 3.保存文件后，安装第三方库 更新依赖库，执行 pod update（记得cd 到项目主文件下）。 安装依赖库，执行 pod install。 4.安装完成，此时项目文件中会多出 .xcworkspace 文件，以后就通过它来打开项目。 Podfile 文件示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 指明依赖库的来源地址，不使用默认 CDNsource &#x27;[https://github.com/CocoaPods/Specs.git](https://github.com/CocoaPods/Specs.git)&#x27;# Uncomment this line to define a global platform for your projectplatform :ios, &#x27;9.0&#x27;# 屏蔽所有第三方框架警告inhibit_all_warnings! target &#x27;ProjectName&#x27; do # Uncomment this line if you&#x27;re using Swift or would like to use dynamic frameworks # use_frameworks! # Pods for ProjectName # 网络库 pod &#x27;AFNetworking&#x27; pod &#x27;SDWebImage&#x27; pod &#x27;Reachability&#x27; # 服务类 pod &#x27;Bugly&#x27; # UI pod &#x27;Masonry&#x27; pod &#x27;MBProgressHUD&#x27; pod &#x27;MJRefresh&#x27; pod &#x27;EAIntroView&#x27; pod &#x27;SDCycleScrollView&#x27; pod &#x27;DZNEmptyDataSet&#x27; pod &#x27;XLForm&#x27; pod &#x27;SHSPhoneComponent&#x27; pod &#x27;BEMCheckBox&#x27; pod &#x27;SCLAlertView-Objective-C&#x27; # 工具组件类 pod &#x27;ChameleonFramework&#x27; pod &#x27;FDFullscreenPopGesture&#x27; pod &#x27;IQKeyboardManager&#x27; pod &#x27;YYKit&#x27; pod &#x27;UIAlertController+Blocks&#x27; pod &#x27;LBXScan/LBXNative&#x27; pod &#x27;LBXScan/UI&#x27; pod &#x27;UITableView+FDTemplateLayoutCell&#x27;endtarget &#x27;ProjectNameTests&#x27; do inherit! :search_pathsend&quot;Podfile&quot; 52L, 999C 三方库常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354###### 安装 Cocoapods ####### 更新 gem 版本$ sudo gem update --system# 查看已安装的 Ruby 版本$ gem -v# 替换 Ruby 源$ gem sources --remove [https://rubygems.org/](https://rubygems.org/)$ gem sources -add [https://gems.ruby-china.com/](https://gems.ruby-china.com/)# 查看验证镜像源$ gem sources -l# 卸载 Cocoapods$ sudo gem uninstall cocoapods# 重新安装 Cocoapods 到指定目录$ sudo gem install cocoapods -n /usr/local/bin# 查看当前 Cocoapods 版本$ pod --version# 更新本地的 Cocoapods 列表$ pod repo update# 移除 trunk 源$ pod repo remove trunk###### 项目中使用 ####### 搜索框架$ pod search 框架名# 终端导航到项目目录下$ cd [Project]# 创建 Podfile 文件$ pod init# 编辑 Podfile 文件$ vim Podfile# 安装$ pod install# 更新所有依赖的开源库$ pod update$ pod install --no-repo-update$ pod update --no-repo-update# 查看依赖库版本信息$ pod install --verbose --no-repo-update","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-基础","slug":"OC-基础","permalink":"https://www.bboyzj.cn/tags/OC-%E5%9F%BA%E7%A1%80/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OCRunloop01：Runloop底层原理","slug":"OCRuntime&Runloop/OCRunloop01：Runloop底层原理","date":"2020-07-29T15:26:45.000Z","updated":"2023-03-07T04:02:52.618Z","comments":true,"path":"2020/07/29/OCRuntime&Runloop/OCRunloop01：Runloop底层原理/","link":"","permalink":"https://www.bboyzj.cn/2020/07/29/OCRuntime&Runloop/OCRunloop01%EF%BC%9ARunloop%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","excerpt":"","text":"什么是Runloop? runloop不仅仅是一个运行循环，还是一个对象，这个对象管理其需要处理的事件和消息，并提供了一个入口函数，通过这个入口函数，程序进入do…while循环，保证程序持续运行，不会退出。 验证：下载源码,查看CFRunloop.c文件，找到CFRunLoopRun源码可知：确实是do…while循环。 1234567void CFRunLoopRun(void) &#123; /* DOES CALLOUT */ int32_t result; do &#123; result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); CHECK_FOR_FORK(); &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);&#125; 官方文档：也有详细的说明: Runloop不是线程安全的 Runloop的作用？ 保持程序的持续运行。 处理APP中各种事件（触摸、定时器、performSelector）。 节省CPU资源，提高程序性能：该做事时做事，该休息时休息。 程序中main函数的UIApplicationMain函数主要作用就是创建了一个主运行循环，主线程几乎所有的事情都是交给runloop去完成，如UI界面的刷新、点击事件的处理、performSelector等等，但并非所有的任务都是由runloop完成。 Runloop对象对象：iOS中有2套API来访问和使用RunLoop OC语言：Foundation – NSRunloop C语言： Core Foundaton – CFRunloopRefNSRunLoop是基于CFRunLoopRef的一层OC包装。获取RunLoop对象： 1234567Foundation[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象Core FoundationCFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象CFRunLoopGetMain(); // 获得主线程的RunLoop对象 Runloop相关的类1.Core Foundation中关于Runloop的5个类： CFRunloopRef： Runloop的对象 CFRunloopModeRef： 模式 CFRunloopSourceRef： 输入源&#x2F;事件源 CFRunloopTimerRef： Timer事件 CFRunloopObserveRef： 监听这，监听Runloop的状态改变 2.CFRunloopRef: CFRunloopRef是Runloop的对象 3.CFRunloopModeRef： 123456typedef struct __CFRunLoopMode *CFRunLoopModeRef;struct __CFRunLoopMode &#123; CFMutableSetRef _sources0; CFMutableSetRef _sources1; CFMutableArrayRef _observers; CFMutableArrayRef _timers; 由上述源码和图可知: CFRunLoopModeRef代表RunLoop的运行模式，一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer，RunLoop启动时只能选择其中一个Mode，作为currentMode，如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入，不同组的Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer能分隔开来，互不影响，如果Mode里没有任何Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer，RunLoop会立马退出。 2) NSRunloopRef常见的几种Mode:代码去打印一下: 123456// CFRunloopModel研究CFRunLoopRef lp = CFRunLoopGetCurrent();CFRunLoopMode mode = CFRunLoopCopyCurrentMode(lp);NSLog(@&quot;mode:%@&quot;,mode);CFArrayRef modeArr = CFRunLoopCopyAllModes(lp);NSLog(@&quot;modeArr:%@&quot;,modeArr); kCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App的默认Mode，通常主线程是在这个Mode下运行; UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 NSRunLoopCommonModes：并不是一个真正的模式,只是一个标记 GSEventReceiveRunLoopMode 4.CFRunloopSourceRef：触摸事件：source0 由上面的截图可知：runloop处理source0事件是调用的*CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION*函数。我们来看一下源码： 1234567static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__() __attribute__((noinline));static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(void (*perform)(void *), void *info) &#123; if (perform) &#123; perform(info); &#125; asm __volatile__(&quot;&quot;); // thwart tail-call optimization&#125; 5.CFRunloopTimerRef：timer类型: 123[NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123; NSLog(@&quot;小老弟&quot;); &#125;]; 由上面的截图可知：runloop处理timer事件是调用的__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__*函数进行事件处理：再看一下源码： 1234567static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__() __attribute__((noinline));static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(CFRunLoopTimerCallBack func, CFRunLoopTimerRef timer, void *info) &#123; if (func) &#123; func(timer, info); &#125; asm __volatile__(&quot;&quot;); // thwart tail-call optimization&#125; 6.CFRunloopObserveRef：用来监听runloop的活动： 12345678910/ Run Loop Observer Activities */typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理timers kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理sources kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), //即将推出Loop kCFRunLoopAllActivities = 0x0FFFFFFFU&#125;; 添加Observer监听RunLoop的所有状态 123456789101112131415161718192021222324252627282930// 创建监听者CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; switch (activity) &#123; case kCFRunLoopEntry: NSLog(@&quot;kCFRunLoopEntry&quot;); break; case kCFRunLoopBeforeTimers: NSLog(@&quot;kCFRunLoopBeforeTimers&quot;); break; case kCFRunLoopBeforeSources: NSLog(@&quot;kCFRunLoopBeforeSources&quot;); break; case kCFRunLoopBeforeWaiting: NSLog(@&quot;kCFRunLoopBeforeWaiting&quot;); break; case kCFRunLoopAfterWaiting: NSLog(@&quot;kCFRunLoopAfterWaiting&quot;); break; case kCFRunLoopExit: NSLog(@&quot;kCFRunLoopExit&quot;); break; default: break; &#125;&#125;);// 添加Observer到RunLoop中CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);// 释放CFRelease(observer); 7.Mode中各个成员的含义: source0:1）触摸事件(TouchUp)2）performSelector :OnThread source11）基于Port的线程间通信2）系统事件的捕捉 Timer1）NSTimer2）performSelector :afterDelay &#x2F;&#x2F; 这句代码的本质是往Runloop中添加定时器 Observers1）监听runloop的状态2）UI刷新(在runloop休眠之前)3）自动释放池(在runloop休眠之前) 8.runloop处理items事件的总结:runloop处理items以下事件调用函数的总结: 123456* block:__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__* timer:__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__* source0:__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__* source1:__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__* gcd主队列:_CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()* observe源：__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ Runloop与线程的关系？ 每一条线程都有一个与之对应runloop对象。 查看源码验证，线程和runloop是一一对应的关系: 123456CFRunLoopRef CFRunLoopGetMain(void) &#123; CHECK_FOR_FORK(); static CFRunLoopRef __main = NULL; // no retain needed if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed return __main;&#125; 继续查找 123456789101112131415161718CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123; if (pthread_equal(t, kNilPthreadT)) &#123; t = pthread_main_thread_np(); &#125; __CFLock(&amp;loopsLock); if (!__CFRunLoops) &#123; __CFUnlock(&amp;loopsLock); CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks); //获取mainloop CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); //通过key value方式一一对应 CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123; CFRelease(dict); &#125; CFRelease(mainLoop); __CFLock(&amp;loopsLock); &#125; runloop保存在全局的NSMutableDictionaryRef字典当中，以线程为key，runloop为value。由上面的源码可验证。 主线程的Runloop系统自动获取（创建），子线程默认没有开启runloop。看代码：问下面的子线程 timer会打印么？答:不会，因为子线程的runloop默认没有开启，需要开启子线程的runloop 123456789NSThread * thread = [[NSThread alloc] initWithBlock:^&#123; NSLog(@&quot;hello:%@&quot;,[NSThread currentThread]); [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123; NSLog(@&quot;子线程 timer&quot;); &#125;];&#125;]; thread.name = @&quot;zj&quot;;[thread start]; 问：那要怎么写才能开启？并能控制其打印?答：通过[[NSRunLoop currentRunLoop] run];获取子线程的runloop并开启子线程的runloop。通过控制线程退出-&gt;控制runloop退出-&gt;控制timer不打印 1234567891011121314151617181920212223242526272829@interface ViewController ()@property (nonatomic,assign)BOOL isStop;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.isStop = NO; NSThread * thread = [[NSThread alloc] initWithBlock:^&#123; NSLog(@&quot;hello:%@&quot;,[NSThread currentThread]); [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123; NSLog(@&quot;子线程 timer&quot;); if (self.isStop) &#123; [NSThread exit]; &#125; &#125;]; [[NSRunLoop currentRunLoop] run]; &#125;]; thread.name = @&quot;zj&quot;; [thread start];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; self.isStop = YES;&#125; 线程刚创建时是没有runloop对象，runloop会在第一次获取时创建。 runloop在线程销毁时销毁。 timer和runloop？ 问：视图在滑动的时候为什么NSTimer会不走？ 答：因为默认在主线程NSTimer是加入到kCFRunLoopDefaultMode下的，而视图滑动的时候主线程的mode会切换到UITrackingRunLoopMode模式下，导致NSTimer不走，因而需要将NSTimer加入到UITrackingRunLoopMode或者KCFRunloopCommonMode下。 代码如下: 1234NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123; NSLog(@&quot;aaaaa&quot;);&#125;];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 问NSTimer是怎么加入到UITrackingRunLoopMode或者KCFRunloopCommonMode下就不会造成卡顿? 答:NSTimer通过底层函数CFRunLoopAddTimer加入到items中。然后再runloopRun运行的时候，通过while循环遍历item找到timer的mode是否和当前的mode相等或等于commonMode，如果相等调用block函数返回执行。 自己去写代码验证一下： 12345678910111213141516171819202122232425- (void)cftimerDemo&#123; CFRunLoopTimerContext context = &#123; 0, ((__bridge void *)self), NULL, NULL, NULL &#125;; CFRunLoopRef rlp = CFRunLoopGetCurrent(); /* 参数一：用于分配对象的内存 参数二：在什么时候触发 参数三：每隔多少时间触发一次 参数四：未来参数 参数五：CFRunloopObserver的优先级，当Runloop同一运行阶段中有多少CFRunloopObserver 正常情况下使用0 参数六：回调，比如触发事件，我们就会来到这里 参数七：上下文记录信息 */ CFRunLoopTimerRef timerRef = CFRunLoopTimerCreate(kCFAllocatorDefault, 0, 1, 0, 0, zjRunloopTimerCallBack, &amp;context); CFRunLoopAddTimer(rlp, timerRef, kCFRunLoopDefaultMode);&#125;void zjRunloopTimerCallBack(CFRunLoopTimerRef timer,void * info) &#123; NSLog(@&quot;%@---%@&quot;,timer,info);&#125; Observer和runloopRunloop运行流程1.NSRunLoop: 是基于 CFRunLoopRef 的OC封装，提供了面向对象的 API，但不是线程安全的，CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，是线程安全的，CoreFoundation是开源的(CoreFoundation 源码地址) 2.runloop的运行逻辑 Runloop实际应用","categories":[{"name":"OC-Runloop探索篇","slug":"OC-Runloop探索篇","permalink":"https://www.bboyzj.cn/categories/OC-Runloop%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-Runloop探索篇","slug":"OC-Runloop探索篇","permalink":"https://www.bboyzj.cn/categories/OC-Runloop%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC：Block底层探索","slug":"OC学习/OC学习17：Block","date":"2020-07-25T18:22:36.000Z","updated":"2023-03-09T19:18:00.483Z","comments":true,"path":"2020/07/26/OC学习/OC学习17：Block/","link":"","permalink":"https://www.bboyzj.cn/2020/07/26/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A017%EF%BC%9ABlock/","excerpt":"","text":"Block初探什么是Block？Block是将函数及其上下文封装起来的对象。 什么是Block调用?Block调用即函数的调用。 Block的分类？根据内存分布 全局Block(NSGlobalBlock): 全局Block存储在已初始化静态(.data)区。 例子1： 123456// 全局block __NSGlobalBlock__void (^block)(void) = ^&#123; NSLog(@&quot;张建&quot;);&#125;;block();NSLog(@&quot;%@&quot;,block); 打印结果： 12020-08-01 23:57:47.626190+0800 OC-Block初探[14671:824715] &lt;__NSGlobalBlock__: 0x10556c038&gt; 例子2：在实际开发中往往是这样的 12345678910[self testBlock:^(id data) &#123; NSLog(@&quot;我来了&quot;);&#125;];- (void)testBlock:(void(^)(id data))block&#123; NSLog(@&quot;%@&quot;,block); if (block) &#123; block(@&quot;zj&quot;); &#125;&#125; 栈Block(NSStackBlock):栈Block存储在栈(stack)区。 例子： 12345// 栈block __NSStackBlock__int b = 20;NSLog(@&quot;%@&quot;,^&#123; NSLog(@&quot;%d&quot;,b);&#125;); 打印结果: 12345// 栈block __NSStackBlock__int b = 20;NSLog(@&quot;%@&quot;,^&#123; NSLog(@&quot;%d&quot;,b);&#125;); 堆Block(NSMallocBlock):堆Block存储在堆(heap)区。 例子： 1234567// 堆block __NSMallocBlock__int a = 10;void (^ZJBlock)(void) = ^&#123; NSLog(@&quot;%d&quot;,a);&#125;;ZJBlock();NSLog(@&quot;%@&quot;,ZJBlock); 打印结果 122020-08-02 00:23:32.061735+0800 OC-Block初探[14930:847689] 102020-08-02 00:23:34.873090+0800 OC-Block初探[14930:847689] &lt;__NSMallocBlock__: 0x6000029ef510&gt; Block底层原理 block的本质block本质上是一个OC对象，它内部也有isa指针，这个对象封装了函数调用地址以及函数调用环境(函数参数、返回值、捕获的外部变量等)。当我们定义一个block，在编译后它的底层存储结构是怎样的呢？下面我们来看一个例子，定义了一个block，并在block里面访问量block外面的变量age，它底层存储结构如下图所示，block底层就是一个结构体__main_block_impl_0。 impl-&gt;isa：就是isa指针，可见它就是一个OC对象。 impl-&gt;FuncPtr：是一个函数指针，也就是底层将block中要执行的代码封装成了一个函数，然后用这个指针指向那个函数。 Desc-&gt;Block_size：block占用的内存大小。 age：捕获的外部变量age，可见block会捕获外部变量并将其存储在block的底层结构体中。 当我们调用block时(block())，实际上就是通过函数指针FuncPtr找到封装的函数并将block的地址作为参数传给这个函数进行执行，把block传给函数是因为函数执行中需要用到的某些数据是存在block的结构体中的(比如捕获的外部变量)。如果定义的是带参数的block，调用block时是将block地址和block的参数一起传给封装好的函数。 block的变量捕获机制 block外部的变量是可以被block捕获的，这样就可以在block内部使用外部的变量了。不同类型的变量的捕获机制是不一样的。下面我们来看一个示例： 123456789101112131415161718192021222324252627int c = 1000; // 全局变量static int d = 10000; // 静态全局变量int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; int a = 10; // 局部变量 static int b = 100; // 静态局部变量 void (^block)(void) = ^&#123; NSLog(@&quot;a = %d&quot;,a); NSLog(@&quot;b = %d&quot;,b); NSLog(@&quot;c = %d&quot;,c); NSLog(@&quot;d = %d&quot;,d); &#125;; a = 20; b = 200; c = 2000; d = 20000; block(); &#125; return 0;&#125;// ***************打印结果***************2020-07-07 15:08:37.541840+0800 CommandLine[70672:7611766] a = 102020-07-07 15:08:37.542168+0800 CommandLine[70672:7611766] b = 2002020-07-07 15:08:37.542201+0800 CommandLine[70672:7611766] c = 20002020-07-07 15:08:37.542222+0800 CommandLine[70672:7611766] d = 20000 关于运行结果我们后面再做讲解，我们先来看一下定义的这个block的在编译后底层存储结构是怎么样的呢？(可以在命令行运行xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m将这个main.m文件转成编译后的c&#x2F;c++文件，然后在这个文件搜索__main_block_impl_0就可以找到这个block的结构体)。struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int a; int *b;};我们可以发现，我定义了4个变量，结果只有2个局部变量被捕获了，而且2个局部变量的捕获方式还不一样。为什么会这样呢？下面来一一解释： 2.1 全局变量的捕获不管是普通全局变量还是静态全局变量，block都不会捕获。因为全局变量在哪里都可以访问，所以block内部不捕获也是可以直接访问全局变量的，所以外部更改全局变量的值时，block内部打印的就是最新更改的值。 2.2 静态局部变量的捕获我们发现定义的静态局部变量b被block捕获后，在block结构体里面是以int *b;的形式来存储的，也就是说block其实是捕获的变量b的地址，block内部是通过b的地址去获取或修改b的值，所以block外部更改b的值会影响block里面获取的b的值，block里面更改b的值也会影响block外面b的值。所以上面会打印b &#x3D; 200。 2.3 普通局部变量的捕获所谓的普通局部变量就是在一个函数或代码块中定义的类似int a &#x3D; 10;的变量，它其实是省略了auto关键字，等价于auto int a &#x3D; 10，所以也叫auto变量。和静态局部变量不同的是，普通局部变量被block捕获后再block底层结构体中是以int a;的形式存储，也就是说block捕获的其实是a的值(也就是10)，并且在block内部重新定义了一个变量来存储这个值，这个时候block外部和里面的a其实是2个不同的变量，所以外面更改a的值不会影响block里面的a。所以打印的结果是a &#x3D; 10。那有人可能就有疑问了，为什么普通局部变量要捕获值，跟静态局部变量一样捕获地址不行吗？是的，不行。因为普通局部变量a在出了大括号后就会被释放掉了，这个时候如果我们在大括号外面调用这个block，block内部通过a的指针去访问a的值就会抛出异常，因为a已经被释放了。而静态局部变量的生命周期是和整个程序的生命周期是一样的，也就是说在整个程序运行过程中都不会释放b，所以不会出现这种情况。那有人又有疑问了，既然静态局部变量一直都不会被释放，那block为什么还要捕获它，直接拿来用不就可以了吗？这是因为静态局部变量作用域只限制在这个大括号类，出了这个大括号，虽然它还存在，但是外面无法访问它。而前面已经介绍过，block里面的代码在底层是被封装成了一个函数，那这个函数肯定是在b所在的大括号外面，所以这个函数是无法直接访问到b的，所以block必须将其捕获。 2.4 block捕获变量小结 全局变量–不会捕获，是直接访问。静态局部变量–是捕获变量地址。普通局部变量–是捕获变量的值。 所以我们判断一个变量是否会被block捕获关键就在于这个变量是局部变量还是全局变量。那我们来看一下以下几种情况中block是否会捕获self: 1234567891011121314151617181920212223- (void)blockTest&#123; // 第一种 void (^block1)(void) = ^&#123; NSLog(@&quot;%p&quot;,self); &#125;; // 第二种 void (^block2)(void) = ^&#123; self.name = @&quot;Jack&quot;; &#125;; // 第三种 void (^block3)(void) = ^&#123; NSLog(@&quot;%@&quot;,_name); &#125;; // 第四种 void (^block4)(void) = ^&#123; [self name]; &#125;;&#125; 要搞清楚这个问题，我们主要是要搞清楚self是局部变量还是全局变量。可能很多人以为它是全局变量，其实他是一个局部变量。再强调一遍，self是局部变量。那有人就疑惑了，它为什么是局部变量？它是在哪里定义的。要搞清楚这个问题，我们需要对OC的方法调用机制有一定了解。OC中一个对象调用方法，其实就是给这个这个对象发送消息。比如我调用[self blockTest]，它转成C语言后就变成了objc_msgSend(self, @selector(blockTest))。OC的blockTest方法是没有参数的，但是转成objc_msgSend后就多出来了2个参数，一个就是self，是指向函数调用者的，另一个参数就是要调用的这个方法。所以对于所有的OC方法来说，它们都有这2个默认的参数，第一个参数就是self，所以self就是这么通过参数的形式传进来的，它的确是一个局部变量。这个问题解决了，那上面几种情况就简单了，这4中情况下block都会捕获self。对第一、二、四这3种情况都好理解，第三种情况可能有人会有疑惑，block里面都没有用到self为什么还会捕获self呢。其实_name这种写法并不是没有self，它只是将self给省略了，它其实等同于self-&gt;_name，所以这种情况要格外注意。 block的类型 block既然是一个OC对象,那它就有类，那它的类时什么呢？我们可以通过调用block的class方法或object_getClass()函数来得到block的类。 12345678910111213141516171819202122- (void)test&#123; int age = 10; void (^block1)(void) = ^&#123; NSLog(@&quot;-----&quot;); &#125;; NSLog(@&quot;block1的类：%@&quot;,[block1 class]); NSLog(@&quot;block2的类：%@&quot;,[^&#123; NSLog(@&quot;----%d&quot;,age); &#125; class]); NSLog(@&quot;block3的类：%@&quot;,[[^&#123; NSLog(@&quot;----%d&quot;,age); &#125; copy] class]);&#125;// ***************打印结果***************2020-07-08 09:07:46.253895+0800 AppTest[72445:7921459] block1的类：__NSGlobalBlock__2020-07-08 09:07:46.254027+0800 AppTest[72445:7921459] block2的类：__NSStackBlock__2020-07-08 09:07:46.254145+0800 AppTest[72445:7921459] block3的类：__NSMallocBlock__ block的类有三种，就是上面打印的结果：__NSGlobalBlock__、__NSStackBlock__、__NSMallocBlock__。有人可能会疑惑，打印第2和3这两个block时为不像block1那样先定义一个block1然后再打印block1。这是因为在ARC模式下，如果一个__NSStackBlock__类型的block被一个强指针指着，那系统会自动对这个block进行一次copy操作将这个block变成__NSMallocBlock__类型，这样会影响运行的结果。下面我们一一介绍一下这三种类型的区别： 1__NSGlobalBlock__ 如果一个block里面没有访问普通局部变量(也就是说block里面没有访问任何外部变量或者访问的是静态局部变量或者访问的是全局变量)，那这个block就是__NSGlobalBlock__。__NSGlobalBlock__类型的block在内存中是存在数据区的(也叫全局区或静态区，全局变量和静态变量是存在这个区域的)。__NSGlobalBlock__类型的block调用copy方法的话什么都不会做。下面我们再来看下__NSGlobalBlock__的继承链： 12345678910111213141516- (void)test&#123; void (^block)(void) = ^&#123; NSLog(@&quot;-----&quot;); &#125;; NSLog(@&quot;--- %@&quot;,[block class]); NSLog(@&quot;--- %@&quot;,[[block class] superclass]); NSLog(@&quot;--- %@&quot;,[[[block class] superclass] superclass]); NSLog(@&quot;--- %@&quot;,[[[[block class] superclass] superclass] superclass]);&#125;// ***************打印结果***************2020-07-08 11:03:34.331652+0800 AppTest[72667:7957820] --- __NSGlobalBlock__2020-07-08 11:03:34.331777+0800 AppTest[72667:7957820] --- __NSGlobalBlock2020-07-08 11:03:34.331883+0800 AppTest[72667:7957820] --- NSBlock2020-07-08 11:03:34.331950+0800 AppTest[72667:7957820] --- NSObject看了block最终也是继承自NSObject，__NSGlobalBlock__的继承链为：__NSGlobalBlock__ : __NSGlobalBlock : NSBlock : NSObject。 3.2__NSStackBlock__ 如果一个block里面访问了普通的局部变量，那它就是一个__NSStackBlock__，它在内存中存储在栈区，栈区的特点就是其释放不受开发者控制，都是由系统管理释放操作的，所以在调用__NSStackBlock__类型block时要注意，一定要确保它还没被释放。如果对一个__NSStackBlock__类型block做copy操作，那会将这个block从栈复制到堆上。NSStackBlock__的继承链是：__NSStackBlock : __NSStackBlock : NSBlock : NSObject。 3.3__NSMallocBlock__ 一个__NSStackBlock__类型block做调用copy，那会将这个block从栈复制到堆上，堆上的这个block类型就是__NSMallocBlock__，所以__NSMallocBlock__类型的block是存储在堆区。如果对一个__NSMallocBlock__类型block做copy操作，那这个block的引用计数+1。NSMallocBlock__的继承链是：__NSMallocBlock : __NSMallocBlock : NSBlock : NSObject。 在ARC环境下，编译器会根据情况，自动将栈上的block复制到堆上。有一下4种情况会将栈block复制到堆上：a. block作为函数返回值时： 12345678typedef void (^MyBlock)(void);- (MyBlock)createBlock&#123; int a = 10; return ^&#123; NSLog(@&quot;******%d&quot;,a); &#125;;&#125; b. 将block赋值给强指针时：将定义的栈上的block赋值给强指针myBlock，就变成了堆block。 123456789- (void)test&#123; int a = 10; // 局部变量 void (^myBlock)(void) = ^&#123; NSLog(@&quot;a = %d&quot;,a); &#125;; block();&#125; c. 当block作为参数传给Cocoa API时：比如： 1234[UIView animateWithDuration:1.0f animations:^&#123; &#125;]; d. block作为GCD的API的参数时：比如： 1234dispatch_async(dispatch_get_main_queue(), ^&#123; &#125;); 另外在MRC环境下，定义block属性建议使用copy关键字，这样会将栈区的block复制到堆区。@property (copy,nonatomic) void(^block)void;在ARC环境下，定义block属性用copy或strong关键字都会将栈区block复制到堆上，所以这两种写法都可以。@property (strong, nonatomic) void (^block)(void);@property (copy, nonatomic) void (^block)(void); block对对象型的局部变量的捕获block对对象类型和对基本数据类型变量的捕获是不一样的，对象类型的变量涉及到强引用和弱引用的问题，强引用和弱引用在block底层是怎么处理的呢？如果block是在栈上，不管捕获的对象时强指针还是弱指针，block内部都不会对这个对象产生强引用。所以我们主要来看下block在堆上的情况。首先来看下强引用的对象被block捕获后在底层结构体中是如何存储的。这里用下面这条命令来将OC代码转成c&#x2F;c++代码：xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime&#x3D;ios-8.0.0 main.m &#x2F;&#x2F; OC代码 123456789101112131415int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *person = [[Person alloc] init]; person.age = 20; void (^block)(void) = ^&#123; NSLog(@&quot;age--- %ld&quot;,person.age); &#125;; block(); &#125; return 0;&#125; 1234567// 底层结构体struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; Person *__strong person;&#125;; 可以看到和基本数据类型不同的是，person对象被block捕获后，在结构体中多了一个修饰关键字__strong。我们再来看下弱引用对象被捕获后是什么样的：&#x2F;&#x2F; OC代码 1234567891011121314151617181920212223int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *person = [[Person alloc] init]; person.age = 20; __weak Person *weakPerson = person; void (^block)(void) = ^&#123; NSLog(@&quot;age--- %ld&quot;,weakPerson.age); &#125;; block(); &#125; return 0;&#125;// 底层blockstruct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; Person *__weak weakPerson;&#125;; 可见此时block中weakPerson的关键字变成了__weak。在block中修饰被捕获的对象类型变量的关键字除了__strong、__weak外还有一个__unsafe_unretained。那这结果关键字起什么作用呢？当block被拷贝到堆上时是调用的copy函数，copy函数内部会调用_Block_object_assign函数，_Block_object_assign函数就会根据这3个关键字来进行操作。 如果关键字是__strong，那block内部就会对这个对象进行一次retain操作，引用计数+1，也就是block会强引用这个对象。也正是这个原因，导致在使用block时很容易造成循环引用。如果关键字是__weak或__unsafe_unretained，那block对这个对象是弱引用，不会造成循环引用。所以我们通常在block外面定义一个__weak或__unsafe_unretained修饰的弱指针指向对象，然后在block内部使用这个弱指针来解决循环引用的问题。 block从堆上移除时，则会调用block内部的dispose函数，dispose函数内部调用_Block_object_dispose函数会自动释放强引用的变量。 __block修饰符的作用在介绍__block之前，我们先来看下下面这段代码： 1234567- (void)test&#123; int age = 10; void (^block)(void) = ^&#123; age = 20; &#125;;&#125; 这段代码有什么问题吗？编译器会直接报错，在block中不可以修改这个age的值。为什么呢？因为age是一个局部变量，它的作用域和生命周期就仅限在是test方法里面，而前面也介绍过了，block底层会将大括号中的代码封装成一个函数，也就相当于现在是要在另外一个函数中访问test方法中的局部变量，这样肯定是不行的，所以会报错。如果我想在block里面更改age的值要怎么做呢？我们可以将age定义成静态局部变量static int age &#x3D; 10;。虽然静态局部变量的作用域也是在test方法里面，但是它的生命周期是和程序一样的，而且block捕获静态局部变量实际是捕获的age的地址，所以block里面也是通过age的地址去更改age的值，所以是没有问题的。但我们并不推荐这样做，因为静态局部变量在程序运行过程中是不会被释放的，所以还是要尽量少用。那还有什么别的方法来实现这个需求呢？这就是我们要讲的__block关键字。 123456789- (void)test1&#123; __block int age = 10; void (^block)(void) = ^&#123; age = 20; &#125;; block(); NSLog(@&quot;%d&quot;,age);&#125; 当我们用__block关键字修饰后，底层到底做了什么让我们能在block里面访问age呢？下面我们来看下上面代码转成c++代码后block的存储结构是什么样的。 123456struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_age_0 *age; // by ref&#125;; 1234567struct __Block_byref_age_0 &#123; void *__isa; // isa指针__Block_byref_age_0 *__forwarding; // 如果这block是在堆上那么这个指针就是指向它自己，如果这个block是在栈上，那这个指针是指向它拷贝到堆上后的那个block int __flags; int __size; // 结构体大小 int age; // 真正捕获到的age&#125;; 我们可以看到，age用__block修饰后，在block的结构体中变成了__Block_byref_age_0 *age;，而__Block_byref_age_0是个结构体，里面有个成员int age;，这个才是真正捕获到的外部变量age，实际上外部的age的地址也是指向这里的，所以不管是外面还是block里面修改age时其实都是通过地址找到这里来修改的。所以age用__block修饰后它就不再是一个test1方法内部的局部变量了，而是被包装成了一个对象，age就被存储在这个对象中。之所以说是包装成一个对象，是因为__Block_byref_age_0这个结构体的第一个成员就是isa指针。 __block修饰变量的内存管理:__block不管是修饰基础数据类型还是修饰对象数据类型，底层都是将它包装成一个对象(我这里取个名字叫__blockObj)，然后block结构体中有个指针指向__blockObj。既然是一个对象，那block内部如何对它进行内存管理呢？当block在栈上时，block内部并不会对__blockObj产生强引用。当block调用copy函数从栈拷贝到堆中时，它同时会将__blockObj也拷贝到堆上，并对__blockObj产生强引用。当block从堆中移除时，会调用block内部的dispose函数，dispose函数内部又会调用_Block_object_dispose函数来释放__blockObj。 Block循环引用Block面试题 block既然是对象，那么用copy修饰还是strong修饰呢？答：用copy和strong都可以，因为在ARC下有自动copy效果。 变量截取面试题下面代码能正常编译吗？不能的话是那些代码不能通过编译呢？ 1234567891011121314151617181920212223int d = 1000; // 全局变量static int e = 10000; // 静态全局变量- (void)test&#123; int a = 10; // 局部变量 static int b = 100; // 静态局部变量 __block int c = 1000; NSMutableArray *array1 = nil; __block NSMutableArray *array2 = nil; void (^block)(void) = ^&#123; a = 20; b = 200; c = 2000; d = 20000; e = 200000; array1 = [NSMutableArray array]; [array1 addObject:@&quot;111&quot;]; array2 = [NSMutableArray array]; [array2 addObject:@&quot;222&quot;]; &#125;; block();&#125; 解答：1)a &#x3D; 20;无法通过编译，因为a是局部变量，其作用域和生命周期仅限于它所在的大括号内部，而block底层是将块中的代码封装到了一个函数中，在那个函数中修改a就相当于在一个函数中去修改另外一个函数中的局部变量，这样肯定是无法通过编译。 2)array1 &#x3D; [NSMutableArray array];无法通过编译。原因和上面一样，array1是一个指针，这里是想在一个函数中去给另外一个函数中的变量重新赋值一个指针，所以无法通过编译。 3)其它的都可以通过编译。 4)全局变量在哪里都可以访问到，所以在block里面可以修改，实际上block并不会捕获全局变量存到block内部。 5)__block修饰的变量(以变量c为例)是被包装成了一个对象，c就存储在对象中，block外面 的c的地址实际上就是这个对象中存储的c的地址，而block里面也存储着一个指针指向这个对象进而能访问到这个对象中的c，所以是可以直接修改的。 6)[array1 addObject:@”111”];可以通过编译是因为block捕获了array1的值(也就是数组的地址)存储在block里面，这里是通过这个地址找到数组，然后对数组中的元素进行操作，所以是可以通过编译的。所以对于一个对象类型的变量，block内部只要不是想修改这个变量的值，都不需要用__block来修饰这个变量(比如增、删、修改集合类型对象里面的元素，或者修改一个实例对象的属性等都不需要用__block修饰)。 睡眠有关1.下面代码运行结果是什么？ 123456789101112131415161718192021222324- (void)test&#123; __block Person *person = [[Person alloc] init]; person.age = 20; __weak Person *weakPerson = person; self.block = ^&#123; NSLog(@&quot;block-begin:%@ age = %d&quot;,[NSThread currentThread],weakPerson.age); [NSThread sleepForTimeInterval:1.0f]; NSLog(@&quot;block-eng:%@ age = %d&quot;,[NSThread currentThread],weakPerson.age); &#125;; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; self.block(); &#125;); [NSThread sleepForTimeInterval:0.2f]; NSLog(@&quot;test-end:%@&quot;,[NSThread currentThread]);&#125;// ***************打印结果***************2020-08-11 11:59:08.632317+0800 OC-Block变量截获的原理[32169:1868943] block-begin:&lt;NSThread: 0x60000324eec0&gt;&#123;number = 4, name = (null)&#125; age = 202020-08-11 11:59:08.833335+0800 OC-Block变量截获的原理[32169:1868876] test-end:&lt;NSThread: 0x600003200200&gt;&#123;number = 1, name = main&#125;2020-08-11 11:59:09.635217+0800 OC-Block变量截获的原理[32169:1868943] block-eng:&lt;NSThread: 0x60000324eec0&gt;&#123;number = 4, name = (null)&#125; age = 0 weakPerson是一个弱指针，所以self.block对person是弱引用。然后在并发队列中通过异步函数添加一个任务来执行self.block();，所以是开启了一个子线程来执行这个任务，此时打印age值是20，然后子线程开始睡眠1秒钟。与此同时主线程也睡眠0.2秒，0.2秒后主线程执行完最后的打印操作，test函数就执行完了。而由于person是一个局部变量，而且self.block对它也是弱引用，所以在test函数执行完后person对象就被释放了。再过0.8秒钟，子线程结束睡眠，此时weakPerson所指向的对象已经变成了nil，所以打印的age是0。 此时如果将主线程的睡眠时间改的比子线程睡眠时间长的话结果又不一样，因为子线程睡眠结束时主线程还在睡眠睡眠，也就是test方法还没执行完，那person对象就还存在，所以子线程睡眠前后打印的age都是20。 123456// 主线程睡眠时间改为：[NSThread sleepForTimeInterval:1.2f];// ***************打印结果***************2020-08-11 12:00:01.276795+0800 OC-Block变量截获的原理[32192:1869873] block-begin:&lt;NSThread: 0x600003987680&gt;&#123;number = 6, name = (null)&#125; age = 202020-08-11 12:00:02.277239+0800 OC-Block变量截获的原理[32192:1869873] block-eng:&lt;NSThread: 0x600003987680&gt;&#123;number = 6, name = (null)&#125; age = 202020-08-11 12:00:02.476903+0800 OC-Block变量截获的原理[32192:1869745] test-end:&lt;NSThread: 0x6000039bc240&gt;&#123;number = 1, name = main&#125; 线程有关1.下面代码运行结果是什么？ 123456789101112131415161718192021222324252627- (void)test&#123; __block Person *person = [[Person alloc] init]; person.age = 20; __weak Person *weakPerson = person; self.block = ^&#123; __strong Person *strongPerson = weakPerson; NSLog(@&quot;block-begin:%@ age = %d&quot;,[NSThread currentThread],strongPerson.age); [NSThread sleepForTimeInterval:1.0f]; NSLog(@&quot;block-eng:%@ age = %d&quot;,[NSThread currentThread],strongPerson.age); &#125;; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self test1]; &#125;); NSLog(@&quot;test - end&quot;);&#125;- (void)test1&#123; self.block();&#125;// ***************打印结果***************2020-08-11 11:41:03.530846+0800 OC-Block变量截获的原理[32030:1857989] test - end2020-08-11 11:41:03.641728+0800 OC-Block变量截获的原理[32030:1857989] block-begin:&lt;NSThread: 0x6000025303c0&gt;&#123;number = 1, name = main&#125; age = 02020-08-11 11:41:04.688181+0800 OC-Block变量截获的原理[32030:1857989] block-eng:&lt;NSThread: 0x6000025303c0&gt;&#123;number = 1, name = main&#125; age = 0 解释：在并发队列中通过异步函数添加任务执行test1，是开启一个新线程来执行，而新线程是先睡眠0.1秒再执行test1，所以会先执行异步函数后面的代码，所以等到开始执行test1时，test已经执行结束了，所以在执行block之前person就已经被释放了，这种情况下__strong修饰符是不起作用的。 2.如果我将并发队列换成串行队列会怎么样？ 123456789dispatch_async(dispatch_queue_create(&quot;testQueue&quot;, DISPATCH_QUEUE_SERIAL), ^&#123; [NSThread sleepForTimeInterval:0.1f]; [self test1]; &#125;); // ***************打印结果***************2020-08-11 11:51:06.899764+0800 OC-Block变量截获的原理[32094:1863643] test - end2020-08-11 11:51:07.000155+0800 OC-Block变量截获的原理[32094:1863824] block-begin:&lt;NSThread: 0x600000891040&gt;&#123;number = 4, name = (null)&#125; age = 02020-08-11 11:51:08.001081+0800 OC-Block变量截获的原理[32094:1863824] block-eng:&lt;NSThread: 0x600000891040&gt;&#123;number = 4, name = (null)&#125; age = 0 其实这里不管是改成主队列还是自定义的串行队列结果都一样，只要保证是异步函数就行，异步函数不会阻塞当前线程，所以执行test1时test已经执行完了。 3.这种情况下如果我将异步函数换成同步函数，其他地方不变： 12345678910dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123; [NSThread sleepForTimeInterval:0.1f]; [self test1]; &#125;); // ***************打印结果***************2020-08-11 11:52:16.707598+0800 OC-Block变量截获的原理[32121:1864960] block-begin:&lt;NSThread: 0x600002a346c0&gt;&#123;number = 1, name = main&#125; age = 202020-08-11 11:52:17.709068+0800 OC-Block变量截获的原理[32121:1864960] block-eng:&lt;NSThread: 0x600002a346c0&gt;&#123;number = 1, name = main&#125; age = 202020-08-11 11:52:17.709353+0800 OC-Block变量截获的原理[32121:1864960] test - end 因为同步函数会阻塞当前线程，所以是等test1执行结束后，test才会继续执行后面的代码，所以person是在block执行结束后才被释放的。 计时器有关下面代码会造成什么上面后果： 12345678910111213141516171819202122232425- (void)test&#123; __block Person *person = [[Person alloc] init]; person.age = 20; __weak Person *weakPerson = person; self.block = ^&#123; __strong Person *strongPerson = weakPerson; NSLog(@&quot;block-begin:%@ age = %d&quot;,[NSThread currentThread],strongPerson.age); [NSThread sleepForTimeInterval:1.0f]; NSLog(@&quot;block-eng:%@ age = %d&quot;,[NSThread currentThread],strongPerson.age); &#125;; [self performSelector:@selector(test1) withObject:nil afterDelay:.0f]; NSLog(@&quot;test - end&quot;);&#125;- (void)test1&#123; self.block();&#125;// ***************打印结果***************2020-08-11 11:41:03.530846+0800 OC-Block变量截获的原理[32030:1857989] test - end2020-08-11 11:41:03.641728+0800 OC-Block变量截获的原理[32030:1857989] block-begin:&lt;NSThread: 0x6000025303c0&gt;&#123;number = 1, name = main&#125; age = 02020-08-11 11:41:04.688181+0800 OC-Block变量截获的原理[32030:1857989] block-eng:&lt;NSThread: 0x6000025303c0&gt;&#123;number = 1, name = main&#125; age = 0 解释： performSelector:withObject:afterDelay这个方法底层实现实际上是将一个定时器添加到了runloop中，然后等时间到了后就执行test1方法。虽然这里最后一个参数传的是0，也就是等待0秒后执行test1，但它并不是立马执行，因为需要先唤醒runloop，这是要耗一定时间的，所以会先执行后面的方法。所以等到开始执行test1是test已经执行结束了，person已经释放 内存泄漏下面代码会造成什么上面后果： 12345678- (void)test&#123; self.age = 20; self.block = ^&#123; NSLog(@&quot;%d&quot;,self.age); &#125;; self.block();&#125; 解答： 会因循环引用而导致内存泄露。因为self通过一个强指针指向了block，而block内部又捕获了self而且用强指针指向self，所以self和block互相强引用对方而造成循环引用。 解决这个问题很简单，只需要定义一个弱指针指向self，然后block内部就是用一个若指针指向self，所以结果是self强引用block，block弱引用self，所以不会造成循环引用。 123456789- (void)test&#123; self.age = 20; __weak typeof(self) weakSelf = self; self.block = ^&#123; NSLog(@&quot;%d&quot;,weakSelf.age); &#125;; self.block();&#125; 这里说明一点，我们判断会不会造成循环引用关键看block有没有捕获并强引用self。我们只需要记住以下下几点：1.如果block内部使用到了某个变量，而且这个变量是局部变量，那么block会捕获这个变量并存储到block底层的结构体中。2.如果捕获的这个变量是用__weak或__unsafe_unretained修饰的，那么block内部就是用弱指针指向这个变量(也就是block不持有这个对象)，否则block内部就是用强指针指向这个对象(也就是block持有这个对象)。3.self是一个局部变量。因为self是所有OC方法的一个隐藏参数，所以它是一个局部变量。如果self并不持有这个block，block内部怎么引用self都不会造成循环引用。 循环引用面试题，1.下面代码是否会造成循环引用： 123456- (void)test&#123; self.age = 20; self.block = ^&#123; NSLog(@&quot;%d&quot;,self.age); &#125;;&#125; 解答：会造成循环引用，这里虽然没有调用block，但并不影响它们相互引用的结果。 2.下面代码是否会造成循环引用： 123456789- (void)test1&#123; self.age = 20; self.block = ^&#123; NSLog(@&quot;%d&quot;,_age); &#125;; self.block();&#125; 解答： 会造成循环引用。block里面虽然看不到self，实际上_age这种写法只是省略了self，完整写法是self-&gt;_age，所以是会造成循环引用的。这一点开发中要格外注意。 3.下面代码是否会造成循环引用： 1234567- (void)test&#123; self.block = ^&#123; [self setAge:10]; &#125;; self.block();&#125; 解答： 会造成循环引用。OC中调用方法就是给某个对象发送消息，所以调用方法时是需要用到self的，所以block会捕获self并强引用它。 4.下面代码是否会造成循环引用： 1234567dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;%d&quot;,self.age);&#125;); [UIView animateWithDuration:1.0f animations:^&#123; NSLog(@&quot;%d&quot;,self.age);&#125;]; 解答： 不会造成循环引用。当block是某个函数的参数时，虽然block内部是对self强引用的，但self并不持有block，所以不会造成循环引用。 5.下面代码是否会造成循环引用： 123456789- (void)test1&#123; dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123; self.block = ^&#123; NSLog(@&quot;%d&quot;,self.age); &#125;; self.block(); &#125;);&#125; 解答： 会造成循环引用。这是一个嵌套的block，虽然外层block不会循环引用，但是里面的block会造成循环引用。 6.下面代码是否会造成循环引用： 123456789101112131415typedef void(^MyBlock)(void);- (void)test&#123; dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123; self.age = [self testWithBlock:^&#123; NSLog(@&quot;%d&quot;,self.age); &#125;]; &#125;);&#125;- (int)testWithBlock:(MyBlock)myBlock&#123; myBlock(); return 10;&#125; 解答： 不会造成循环引用。这也是嵌套的block。外层block并没有被self持有，所以不会造成循环引用。我们主要看下里面那个block，其实里面的block就是一个函数的参数，self并不持有它，所以不会造成循环引用。 7.下面代码是否会造成循环引用： 123456789101112131415- (void)test1&#123; self.block = [self blockWithBlock:^&#123; NSLog(@&quot;%d&quot;,self.age); &#125;]; self.block();&#125;- (MyBlock)blockWithBlock:(MyBlock)myBlock&#123; myBlock(); return ^&#123; NSLog(@&quot;block作为返回值&quot;); &#125;;&#125; 解答： 不会造成循环引用。这道题很具有迷惑性。有人会觉得self是持有block的，而block内部又强引用了self，所以会造成循环引用。其实仔细观察会发现这里有2个不同的block，self持有的是一个block，而强引用self的又是另外一个block，所以它们并不会造成循环引用。 8.下面代码是否会造成循环引用： 1234567891011121314- (void)test1&#123; self.block = [self blockWithBlock:^&#123; NSLog(@&quot;作为参数的block&quot;); &#125;]; self.block();&#125;- (MyBlock)blockWithBlock:(MyBlock)myBlock&#123; myBlock(); return ^&#123; NSLog(@&quot;block作为返回值--%d&quot;,_age); &#125;;&#125; 解答： 会造成循环引用。这道题同样具有迷惑性。表面上看起来self持有的是一个block，作为参数的又是另外一个block，而且这个block里面也没有用到self。其实这里的关键在于第二个函数的返回值，它返回的就是一个block，这个block里面强引用了self，而且将这个block赋值给了self的block，所以self是强指针指向这个返回的block的。所以它们构成了循环引用。","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.bboyzj.cn/tags/iOS/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OCRuntime03：方法的本质","slug":"OCRuntime&Runloop/OCRuntime03：方法的本质","date":"2020-07-14T17:31:22.000Z","updated":"2020-10-17T05:11:21.000Z","comments":true,"path":"2020/07/15/OCRuntime&Runloop/OCRuntime03：方法的本质/","link":"","permalink":"https://www.bboyzj.cn/2020/07/15/OCRuntime&Runloop/OCRuntime03%EF%BC%9A%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8/","excerpt":"","text":"OC方法的本质1.方法的类别 对象方法 类方法 2.为了方便我们去探索OC方法调用的本质，首先：我们创建一个命令行项目，并新建一个Person类和Student类，里面声明两个方法，一个带参数的和一个不带参数的方法，并实现两个方法，在main.m中去调用以下这两个方法，如下: Student.h中 1234@interface Student : Person- (void)run; //实例方法+ (void)walk:(NSString *)distance; //类方法@end Student.m中 1234567- (void)run&#123; NSLog(@&quot;run&quot;);&#125;+ (void)walk:(NSString *)distance&#123; NSLog(@&quot;walk:%@&quot;,distance); &#125; main.m中代码 12345Student * s = [Student new];//实例对象方法[s run];//类方法[Student walk:@&quot;走路&quot;]; 2.通过clang编译mian.m文件为main.cpp文件去查看到底是通过什么方式调用方法的：xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o mian.cpp 12345Student * s = ((Student *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;Student&quot;), sel_registerName(&quot;new&quot;));((void (*)(id, SEL))(void *)objc_msgSend)((id)s, sel_registerName(&quot;run&quot;));((void (*)(id, SEL, NSString * _Nonnull))(void *)objc_msgSend)((id)objc_getClass(&quot;Student&quot;), sel_registerName(&quot;walk:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_wr_2dt58x1n67bbb3g292d9ygy80000gn_T_main_a4c800_mi_0); 3.由上面的代码可知：方法的本质是&#x3D;&#x3D;发送消息&#x3D;&#x3D;,任何的方法的调用都会编译成消息。即消息的组成: objc_msgSend(id self, SEL _cmd, …)1）id self：消息接受者(调用方法的对象),分为实例对象和类对象2）SEL _cmd：方法编号3）…：参数 id self:可以理解为调用方法的对象，消息接受者，即上文中的 ： 实例对象：p。 类对象：objc_getClass(“Person”)。 SEL _cmd 为方法名，传入类似sel_registerName(“MethodName”)，即下文中的”[p run];”方法。若方法中需要传入参数，就在后面拼接，即下文中的 “[p walk:]”方法。 4.获取SEL的三种方法： Runtime提供的sel_registerName(“MethodName”) Objective-C编译器提供的 @selector(方法名) NSObject提供的NSSelectorFromString(“MethodName”) 5.获取类对象的方法objc_getClass(“Person”) 6.SEL与IMP(implementation)的关系：sel_registerName(“MethodName”)为方法编号，通过方法编号找到方法对应的&#x3D;&#x3D;IMP是函数实现的指针&#x3D;&#x3D;，最后直接调用函数。比喻：通过书页(SEL) 找到该页的具体内容 (IMP) 实际应用为了能够使用objc_msgSend，需要修改配置objc_msgSend Calls改为No如下： 1.实例对象调用方法 123456//实例对象方法底层编译[s run];objc_msgSend(s, @selector(run));objc_msgSend(s, sel_registerName(&quot;run&quot;));NSLog(@&quot;%p---%p&quot;,@selector(run),sel_registerName(&quot;run&quot;));//0x7fff79c49a9b---0x7fff79c49a9b说明这两个方法作用相同 @selector(run)和sel_registerName(“run”)都是SEL 2.类对象调用方法：实际上是向类对象发送消息:objc_getClass(“Person”)获取类对象的意思 12345//2.类方法底层编译[Student walk:@&quot;走路&quot;];objc_msgSend(objc_getClass(&quot;Student&quot;), @selector(walk:), @&quot;Hello World&quot;);objc_msgSend(objc_getClass(&quot;Student&quot;), sel_registerName(&quot;walk:&quot;), @&quot;Hello World&quot;);NSLog(@&quot;%@&quot;,objc_getClass(&quot;Student&quot;));//返回的是类对象Student 3.向父类方法发送消息必须引入头文件#import &lt;objc/message.h&gt;1）对象方法 12345//对象方法struct objc_super mySuper;mySuper.receiver = s; //确定消息发送的对象smySuper.super_class = class_getSuperclass([s class]);//获取父类的类对象objc_msgSendSuper(&amp;mySuper, @selector(run)); 2）类方法 12345//类方法struct objc_super myClassSuper;myClassSuper.receiver = [s class];//消息发送者为类对象myClassSuper.super_class = class_getSuperclass(object_getClass([s class]));//获取元类对象objc_msgSendSuper(&amp;myClassSuper, @selector(walk)); 4.这里要介绍一下objc_getClass(const chat *aClassName)、object_getClass(id obj)和(class)class的区别：1)objc_getClass：传入类名，返回类对象2)object_getClass:传入对象 传入instance对象，返回class对象 传入class对象，返回meta-class对象 传入是meta-class对象，返回NSObject（基类）的meta-class对象3)class 返回的就是类对象 问题1.对象方法和类方法分别存在哪?答：对象方法存在类中。 类方法存在元类中 2.“类方法”在元类中是以什么样的姿态存在？答：以实例方法存在，因为对象在类中是实例，而类在元类中也是实例。","categories":[{"name":"OC-Runloop探索篇","slug":"OC-Runloop探索篇","permalink":"https://www.bboyzj.cn/categories/OC-Runloop%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-Runloop探索篇","slug":"OC-Runloop探索篇","permalink":"https://www.bboyzj.cn/categories/OC-Runloop%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OCRuntime03：对象的本质","slug":"OCRuntime&Runloop/OCRuntime02：对象的本质","date":"2020-07-13T09:15:17.000Z","updated":"2020-10-17T05:11:17.000Z","comments":true,"path":"2020/07/13/OCRuntime&Runloop/OCRuntime02：对象的本质/","link":"","permalink":"https://www.bboyzj.cn/2020/07/13/OCRuntime&Runloop/OCRuntime02%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/","excerpt":"","text":"OC对象的本质1.我们平时编写的Object-C代码，底层实现其实都是C&#x2F;C++代码。所以Objective-C的面向对象都是基于C&#x2F;C++的数据结构实现的 2.由于OC对象内部可以容纳不同数据类型的数据，因此可以推断OC对象的底层数据结构就是&#x3D;&#x3D;结构体&#x3D;&#x3D;。 1typedef struct objc_object Person; //说明Person的本质就是结构体 将OC代码转化成C&#x2F;C++代码那么我们就把OC代码尝试着转化成C&#x2F;C++代码，来看一下到底是不是结构体。1.新建一个MacOS命令行项目1)打开Xcode并新建一个Commend Line Tool命令行项目，如下： 2.为了进一步研究OC对象的本质，我们使用苹果Xcode内置的LLVM编译器前端clang中-rewrite-objc 将我们的OC代码转为C&#x2F;C++实现。 1）打开终端，cd到main.m文件夹下，将OC代码转化成C/C++: xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc OC源文件 -o 输出的cpp文件2）由于不同平台支持的代码肯定是不一样的，目前我们关注点是iOS开发，建议在将OC代码转成C&#x2F;C++代码指定平台：xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp 3)生成main.cpp文件如下: 4）通过生成的C&#x2F;C++代码，我们编写的OC对象NSObject的底层实现为: 说明:NSObject在内存中布局就是一个指向struct objc_class类型结构体的指针isa,由于内部只有一个成员，那么isa的地址就是NSObject结构体在内存中的地址。 问题：一个NSObject对象占用多少内存？根据上面NSObject内存本质的分析，我们应该会认为NSObject对象在内存中占用了8个字节（在64位的环境下占8个字节，在32环境上占4个字节，因为我们所使用的是64位架构的），那么实际上并不是，而是16个字节，为什么呢？让我们来进一步分析：1.在runtime中有个class_getInstanceSize方法获取实例的大小，首先导入头文件#import &lt;objc&#x2F;runtime.h&gt;2.还有一个获取内存大小的malloc_size方法，导入头文件#import &lt;malloc&#x2F;malloc.h&gt;3.那么我们来打印一下看看： 1234567891011121314#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;#import &lt;malloc/malloc.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSObject * obj = [[NSObject alloc] init]; //获取实例的大小 NSLog(@&quot;class_getInstanceSize:%ld&quot;,class_getInstanceSize([NSObject class])); //获取内存大小 NSLog(@&quot;:%ld&quot;,malloc_size((__bridge const void *)obj)); &#125; return 0;&#125; 输出结果为： 122020-07-21 19:07:40.772581+0800 NSObject对象的本质[21818:1404119] class_getInstanceSize:82020-07-21 19:07:40.773072+0800 NSObject对象的本质[21818:1404119] :16 根据上面的两个方法获取的内存大小不一样,class_getInstanceSize获取的大小为8个字节，malloc_size获取的大小是16个字节。为什么会出现两种不同的情况呢，不要着急，我们来进一步分析,我们可以去runtime的源码里面，看一下class_getInstanceSize具体是怎么实现的。往下看。 4.OC所有开放的源码地址我们找到runtime源码位置然后下载下来: 点进去然后下载数字最大的。下载完成，打开项目，然后找到class_getInstanceSize的实现: 全局搜索class_getInstanceSize方法，在objc_class.mm这个c++文件夹下： 我们点下去看下实现： 1234// Class&#x27;s ivar size rounded up to a pointer-size boundary. uint32_t alignedInstanceSize() const &#123; return word_align(unalignedInstanceSize()); &#125; 可以从注释上看出来返回的是Class’s ivar size,类的成员变量的大小，而alignedInstanceSize()表示内存对齐，因为NSObject对象只有一个isa成员变量，因此返回的是8个字节。 5.我们还可以从源码的另外一个角度来分析一下为什么malloc_size开辟16个字节的内存空间1）事实上，查看源码看一下alloc的时候分配了多大的内存大小，我们还是搜索刚才的源码allocWithZone: 2）这个方法中返回的是_objc_rootAllocWithZone(self, (malloc_zone_t *)zone),然后搜索找到这个方法源码： 3）这个方法返回_class_createInstanceFromZone(Class cls,size_t,)终于找到了，从上述代码注释中可以看到，CF要求所有对象至少得返回16个字节的内存大小。 4）而系统开辟的内存空间通过malloc_zone_calloc或calloc方式开辟至少16bytes字节或16字节的倍数的内存空间。 6.总结从上面的所有分析来看，我们很容易能回答出文中最开始提出的问题一个NSObject占用多少内存？答：1、系统分配了16个字节给NSObject对象（可以通过malloc_size函数得到）2、但NSObject对象内部只使用了8个字节空间（在64bit环境下，可以通过class_getInstanceSize函数获得） 如果一个Person对象继承NSObject类，那么Person类的对象占多少内存？1.分析： 新建Person类，添加成员变量。通过clang反编译main.m，打开main.cpp文件找到Person类的底层实现。 12mac@192 Person对象的本质 % cd /Users/mac/Desktop/iOS学习/iOS中进阶高/OC对象的本 质/Person对象的本质/Person对象的本质mac@192 Person对象的本质 % xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp 2.由上图可知，Person对象其实是一个指向objc_object结构体的指针，objc_object里面也有一个isa指针,如下图： 3.而且若一个类继承自另一个类，则它的底层会将父类的成员变量放在结构体的最前面，此后依次放置本类的成员变量，如下图： 而从之前的分析可知，NSObject_IMPL的本质就是一个装有成员变量isa的结构体。因此，Person类对象所占的内存为isa的内存8加上Person类成员变量所占的空间。若不满16个字节，会强制分配到16个字节。 4.我们来验证一下：如果Person对象中有两个属性和两个实例变量： 12345678@interface Person : NSObject&#123; int add; NSString * sex;&#125;@property (nonatomic,copy)NSString * name;@property (nonatomic,assign)int age;@end 此时我们打印一下： 12345678910int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person * p = [[Person alloc] init]; //实例对象的内存大小 NSLog(@&quot;class_getInstanceSize:%ld&quot;,class_getInstanceSize([Person class])); //系统给对象开辟的内存大小,OC对象转C对象，需要__bridge桥接 NSLog(@&quot;malloc_size:%ld&quot;,malloc_size((__bridge const void *)p)); &#125; return 0;&#125; 输出结果： 122020-07-22 02:20:36.303506+0800 Person对象的本质[23797:1588297] class_getInstanceSize:402020-07-22 02:20:36.305285+0800 Person对象的本质[23797:1588297] malloc_size:48 5.结果：说明：属性name和age各占了8个字节的内存空间，实例变量add和sex也各占了8个字节；但是系统每次开辟的内存空间为16的倍数既3*16。 那么alloc和init都做了些什么呢？1.alloc我们通过LLDB调试可以看到，对象alloc时，在汇编中调用了_objc_rootAlloc，明显这就是在苹果源码中的调用入口。 我们去源码中查看一下，调用流程：发现_objc_rootAlloc调用的是callAlloc;继续跳转调用的是_objc_rootAllocWithZone；继续跳转调用的是class_createInstance；继续跳转调用的是_class_createInstanceFromZone 1234567891011121314151617181920212223242526272829303132333435363738394041424344+ (id)alloc &#123; return _objc_rootAlloc(self);&#125;// ************* 跳转 **************_objc_rootAlloc(Class cls)&#123; return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);&#125;// ************* 跳转 **************callAlloc(Class cls, bool checkNil, bool allocWithZone=false)&#123;#if __OBJC2__ if (slowpath(checkNil &amp;&amp; !cls)) return nil; if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123; return _objc_rootAllocWithZone(cls, nil); //调用的是这个 &#125;#endif // No shortcuts available. if (allocWithZone) &#123; return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil); &#125; return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));&#125;// ************* 跳转 **************_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)&#123; id obj; if (fastpath(!zone)) &#123; obj = class_createInstance(cls, 0); //调用的是这个 &#125; else &#123; obj = class_createInstanceFromZone(cls, 0, zone); &#125; if (slowpath(!obj)) obj = _objc_callBadAllocHandler(cls); return obj;&#125;// ************* 跳转 **************static id _class_createInstance(Class cls, size_t extraBytes)&#123; return _class_createInstanceFromZone (cls, extraBytes, nil);&#125; 最终会来到这里 12345678910111213141516171819202122232425_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone)&#123; void *bytes; size_t size; // Can&#x27;t create something for nothing if (!cls) return nil; // Allocate and initialize // 内存对齐，对象实际是8个字节 size = cls-&gt;alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16 bytes. // 系统分配16个字节 if (size &lt; 16) size = 16; if (zone) &#123; bytes = malloc_zone_calloc((malloc_zone_t *)zone, 1, size); &#125; else &#123; // 开辟内存空间 bytes = calloc(1, size); &#125; return objc_constructInstance(cls, bytes);&#125; 2.init呢？实际上 init 只是一个抽象方法，并没有做什么操作。 123456_objc_rootInit(id obj)&#123; // In practice, it will be hard to rely on this function. // Many classes do not properly chain -init calls. return obj;&#125; 3.new呢？调用的是callAlloc,和上面的alloc其实一样 123+ (id)new &#123; return [callAlloc(self, false/*checkNil*/) init];&#125;","categories":[{"name":"OC-Runloop探索篇","slug":"OC-Runloop探索篇","permalink":"https://www.bboyzj.cn/categories/OC-Runloop%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-Runloop探索篇","slug":"OC-Runloop探索篇","permalink":"https://www.bboyzj.cn/categories/OC-Runloop%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]},{"title":"OC底层原理：我的中级到高级进阶之路","slug":"OC进阶/OC底层原理：我的中级到高级进阶之路","date":"2020-07-12T08:56:40.000Z","updated":"2022-04-21T05:58:06.000Z","comments":true,"path":"2020/07/12/OC进阶/OC底层原理：我的中级到高级进阶之路/","link":"","permalink":"https://www.bboyzj.cn/2020/07/12/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9A%E6%88%91%E7%9A%84%E4%B8%AD%E7%BA%A7%E5%88%B0%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/","excerpt":"","text":"源码和开发文档 OC源码下载地址 苹果开发文档地址 OC 底层探索篇 底层分析：LLDB &amp; 查找源码三种方式 OC底层原理00：LLDB常用命令 OC底层原理01：查找源码有三种方式 底层分析：源码 &amp; alloc OC底层原理02：Objc4源码编译 OC底层原理03：alloc&amp;init&amp;new源码分析 OC底层原理04：Optimization-Level-优化等级 OC底层原理05：objc-alloc探索 OC底层原理06：内存对齐探索 OC底层原理07：malloc源码探索 底层分析：isa &amp; 类 &amp; 结构体 OC底层原理08：isa和类关联探索 OC底层原理09：isa走向&amp;继承分析 OC底层原理10：类 &amp; 类结构分析 OC底层原理11：类 &amp; isa 底层面试题分析 OC底层原理12：copy-strong-weak底层分析 底层分析：cache-t &amp; 消息流程 OC底层原理13：cache-t底层原理分析 OC底层原理14-1：消息流程分析之快速查找 OC底层原理14-2：消息流程分析之快速查找 OC底层原理14-3：消息流程分析之动态方法决议&amp;消息转发 底层分析：dyld &amp; 类 OC底层原理15：dyld源码分析 OC底层原理16：dyld与objc的关联 OC底层原理17：类的加载（上） OC底层原理18：类的加载（下） OC底层原理19：类扩展与关联对象 OC底层原理20：OC底层面试题解析 OC底层原理21：Method-Swizzling方法交换 底层分析：KVC &amp; KVO * 内存五大区 OC底层原理22：KVC底层原理分析 OC底层原理23：KVO底层原理分析 OC底层原理24：内存五大区 底层分析：多线程 &amp; 锁 * Block OC底层原理25：多线程原理探索 OC底层原理26：GCD之函数与队列 OC底层原理27：GCD之 NSThread &amp; GCD &amp; NSOperation OC底层原理28：GCD之底层原理分析 OC底层原理29：锁的原理 OC底层原理30：Block底层原理 底层分析：启动优化 OC底层原理31：LLVM编译流程-Cland插件开发 OC底层原理32：启动优化（一）基本概念 OC底层原理33：启动优化（二）优化建议 OC底层原理34：启动优化（三）二进制重排 底层分析：内存管理 OC底层原理35：内存管理（一）TaggedPointer-retain-release-dealloc-retainCount-底层分析 OC底层原理36：内存管理（二）強引用分析 OC底层原理37：内存管理（三）AutoReleasePool-NSRunLoop-底层分析 底层分析：App优化 OC底层原理38：界面优化方案 OC底层原理39：组件化（一）方案 OC底层原理40：组件化（二）组件间通讯方式 OC底层原理41：内存优化（一）野指针探测","categories":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}],"tags":[{"name":"iOS-OC","slug":"iOS-OC","permalink":"https://www.bboyzj.cn/tags/iOS-OC/"}],"keywords":[{"name":"OC-底层原理探索篇","slug":"OC-底层原理探索篇","permalink":"https://www.bboyzj.cn/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"}]}]}