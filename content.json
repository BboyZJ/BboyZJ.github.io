{"meta":{"title":"张建的博客","subtitle":"成功的道路上只有荆棘，没有坦途","description":"我是小J，关注我","author":"小J","url":"https://www.bboyzj.cn"},"pages":[{"title":"categories","date":"2023-03-01T04:01:29.000Z","updated":"2023-03-01T04:01:29.226Z","comments":true,"path":"categories/index.html","permalink":"https://www.bboyzj.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-01T03:07:03.000Z","updated":"2023-03-01T03:07:47.616Z","comments":true,"path":"tags/index.html","permalink":"https://www.bboyzj.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"性能优化02：卡顿检测","slug":"性能优化02：卡顿检测","date":"2023-03-02T15:32:46.000Z","updated":"2023-03-02T15:32:46.851Z","comments":true,"path":"2023/03/02/性能优化02：卡顿检测/","link":"","permalink":"https://www.bboyzj.cn/2023/03/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602%EF%BC%9A%E5%8D%A1%E9%A1%BF%E6%A3%80%E6%B5%8B/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"性能优化01：内存泄漏检测","slug":"性能优化01：内存泄漏检测","date":"2023-03-02T15:32:21.000Z","updated":"2023-03-02T15:32:21.654Z","comments":true,"path":"2023/03/02/性能优化01：内存泄漏检测/","link":"","permalink":"https://www.bboyzj.cn/2023/03/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"OC学习03：内存管理","slug":"OC学习03：内存管理","date":"2023-03-02T10:51:48.000Z","updated":"2023-03-02T14:38:06.386Z","comments":true,"path":"2023/03/02/OC学习03：内存管理/","link":"","permalink":"https://www.bboyzj.cn/2023/03/02/OC%E5%AD%A6%E4%B9%A003%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"前言本文主要介绍 内存的五大区 、函数栈 和 内存管理 内存五大区在iOS中，内存主要分为 栈区、堆区、全局区、常量区、代码区 五个区域，如下图所示： 栈区定义 栈是 系统数据结构，其对应的 进程或者线程是唯一的 栈是 向低地址扩展 的数据结构 栈是一块 连续的内存区域，遵循 先进后出（FILO） 原则 栈区一般在 运行时 分配 存储 栈区是由 编译器自动分配并释放的，主要用来存储 局部变量 函数的参数，例如函数的隐藏参数（id self, SEL _cmd） 优缺点 优点：因为栈是由 编译器自动分配并释放 的，不会产生内存碎片，所以 快速高效 确定：栈的 内存大小有限制，数据不灵活 iOS主线程大小是1MB 其他线程是 512KB MAC 只有 8MB 以上内存大小的说明，在Threading Programming Guide中有相关说明，如下图： 堆区定义 堆是 向高地址扩展 的数据结构 堆是 不连续的内存区域，类似于 链表结构（便于增删，不便于查询），遵循 先进先出（FIFO）原则 堆的 地址空间 在iOS中是是动态的 堆区的分配一般是以在 运行时分配 存储 堆区是 由程序员动态分配和释放 的，如果程序员不释放，程序结束后，可能由操作系统回收，主要用于存放： OC 中使用 alloc 、 new 开辟空间创建 对象 ，或者 block经过copy后 C 语言中使用 malloc、calloc、realloc 分配的空间，需要 free 释放 一般一个 new/alloc 就要对应一个 release，在 ARC 下编译器会自动在合适位置为 OC 对象添加 release 操作，会在当前 线程Runloop退出或休眠时销毁这些对象。MRC 则需程序员手动释放。 优缺点 优点：灵活方便，数据适应面广泛 缺点：需 手动管理、速度慢，容易产生内存碎片 当需要访问堆中数据时，一般需要 先通过对象读取到栈区的指针地址，然后通过 指针地址访问堆区 全局区（静态区，即.bss &amp; .data）全局区是 编译时分配 的内存空间，在程序运行过程中，此内存中的数据一直存在，程序结束后由系统释放，主要存放： 未初始化的全局变量和静态变量，即BSS区（.bss） 已初始化的全局变量和静态变量，即DATA区（.data） 其中，全局变量 是指变量值可以在 运行时被动态修改，而 静态变量 是 static 修饰的变量，包含 静态局部变量 和 静态全局变量 常量区（即.rodata）常量区是 编译时分配 的内存空间，在 程序结束后由系统释放，主要存放： 已经使用了的，且没有指向的 字符串常量 字符串常量因为可能在程序中被多次使用，所以在程序运行之前就会提前分配内存 代码区（即.text）代码区是 由编译时分配，主要用于存放 程序运行时的代码，代码会被编译成 二进制存进内存 的 内存五大区验证运行下面的一段代码，看看变量在内存中是如何分配的： 1234567891011121314int a = 10; // 全局区（已初始化的全局变量）char * b; // 全局区(未初始化的全局变量)- (void)test&#123; NSInteger i = 123; // 栈区（局部变量） NSLog(@&quot;i的内存地址：%p&quot;, &amp;i); NSString *string = @&quot;ZJ&quot;; // 常量区（字符串常量） NSLog(@&quot;string的内存地址：%p&quot;, string); NSLog(@&quot;&amp;string的内存地址：%p&quot;, &amp;string); NSObject *obj = [[NSObject alloc] init]; // 堆区（alloc对象） NSLog(@&quot;obj的内存地址：%p&quot;, obj); NSLog(@&quot;&amp;obj的内存地址：%p&quot;, &amp;obj); &#125; 运行结果如下： 123452022-03-11 14:34:25.438913+0800 内存五大区[70321:4340509] i的内存地址：0x16f6f5a182022-03-11 14:34:25.438976+0800 内存五大区[70321:4340509] string的内存地址：0x1007100982022-03-11 14:34:25.438997+0800 内存五大区[70321:4340509] &amp;string的内存地址：0x16f6f5a102022-03-11 14:34:25.439014+0800 内存五大区[70321:4340509] obj的内存地址：0x280fa0bc02022-03-11 14:34:25.439031+0800 内存五大区[70321:4340509] &amp;obj的内存地址：0x16f6f5a08 对于 局部变量i， 存放在栈区 对于 字符串对象string，分别打印了 string得对象地址 和 string对象的指针地址 string的 对象地址 是是存放在 常量区 string 对象的指针地址，是存放在 栈区 对于 alloc创建的对象obj，分别打印了 obj得对象地址 和 obj对象的指针地址 obj的 对象地址 是存放在 堆区 obj 对象的指针地址 是存放在 栈区 函数栈 函数栈 又称为 栈区，在内存中从高地址往低地址分配，与堆区相对，具体图示请看上面 栈帧 是指 函数（运行中且未完成）占用的一块独立的连续内存区域 应用中新创建的 每个线程都有专用的栈空间，栈可以在线程期间自由使用，而线程中有千千万万的函数调用，这些函数 共享 进程的这个 栈空间。每个函数所使用的栈空间是一个栈帧，所有栈帧就组成了这个线程完成的栈 函数调用是发生在栈上 的，每个 函数的相关信息（例如局部变量、调用记录等）都 存储在一个栈帧 中，每执行一次 函数调用，就会生成一个与其相关的栈帧，然后将其 栈帧压入函数栈，而当函数 执行结束，则将此函数对应的 栈帧出栈并释放掉 如下图所示，是经典图- ARM的栈帧布局方式 其中 main stack frame 为调用函数的栈帧 func1 stack frame 为当前 当前函数（被调用者）的栈帧 栈底 在 高 地址，栈向下增长 FP 就是 栈基址，它指向函数的 栈帧起始地址 SP 则是函数的 栈指针，它指向 栈顶 的位置 ARM压栈 的 顺序 很是规则（也比较容易被黑客攻破），依次为 当前函数指针PC、返回指针LR、栈指针SP、栈基址FP、传入参数个数及指针、本地变量 和 临时变量。如果函数准备调用另一个函数，跳转之前临时变量区先要保存另一个函数的参数 ARM 也可以 用栈基址和栈指针明确标示栈帧的位置，栈指针SP一直移动，ARM的特点是，两个栈空间内的地址（SP+FP）前面，必然有两个代码地址（PC+LP）明确标示着调用函数位置内的某个地址 堆栈溢出一般情况下应用程序是不需要考虑堆和栈的大小的，但是事实上堆和栈不是无上限的，过多的递归会导致栈溢出，过多的alloc变量会导致堆溢出 所以 预防堆栈溢出 的方法： 避免层次过深 的 递归 调用 不要使用过多的局部变量，控制局部变量的大小 避免分配 占用空间 太大的对象，并 及时释放 实在不行，适当的情景下 调用系统API修改线程的堆栈大小 栈帧示例描述下面代码的栈帧变化 栈帧程序示例 1234567891011int Add(int x,int y) &#123; int z = 0; z = x + y; return z;&#125;int main() &#123; int a = 10; int b = 20; int ret = Add(a, b);&#125; 程序执行时，栈区中栈帧的变化如下图所示： 内存管理概述 在iOS中开发中，我们或多或少都听说过内存管理。iOS的内存管理一般指的是OC对象的内存管理，因为OC对象分配在堆内存，堆内存需要程序员自己去动态分配和回收；基础数据类型(非OC对象)则分配在栈内存中，超过作用域就会由系统检测回收。如果我们在开发过程中，对内存管理得不到位，就有可能造成内存泄露。 我们通常讲的内存管理，实际上从发展的角度来说，分为两个阶段：MRC和ARC。 MRC指的是 手动内存管理，在开发过程中需要开发者手动去编写内存管理的代码； ARC指的是 自动内存管理，在此内存管理模式下由LLVM编译器和OC运行时库生成相应内存管理的代码。 引用计数 在 OC 中，使用 引用计数 来 进行内存管理。 每个对象都有一个与其相对应的引用计数器，当持有一个对象，这个对象的引用计数就会递增；当这个对象的某个持有被释放，这个对象的引用计数就会递减。当这个对象的引用计数变为0，那么这个对象就会被系统回收。 当一个对象使用完没有释放，此时其引用计数永远大于1。该对象就会一直占用其分配在堆内存的空间，就会导致内存泄露。内存泄露到一定程度有可能导致内存溢出，进而导致程序崩溃。 MRC 简介 全称 Manual Reference Counting，管理通过使用 retain, release, 以及 autorelease 的消息发送来实现。 retain: 持有（拥有）对象，对象引用数加 1 release: 释放对象，对象引用数减 1 autorelease: 通知系统，在 @autoreleasepool 代码块结束时，对对象调用 release 管理原则 自己创建的对象，自己获得拥有权 在苹果规定中，使用 alloc/new/copy/mutableCopy 创建返回的对象归调用者所有，例如以下 1234/* NSMutableArray类对象A */NSMutableArray *array = [[NSMutableArray alloc] init]; NSLog(@&quot;%p&quot;, array);[array release]; // 释放 由于对象 A 由 alloc 生成，符合苹果规定，指针变量array指向并持有对象A，引用计数器会加 1。另外，array在使用完对象A后需要对其进行释放。当调用release后，释放了其对对象A的引用，计数器减1。对象A此时引用计数值为零，所以对象A被回收。不能访问已经被回收的对象，会发生崩溃。 别人创建的对象，可以通过 retain 来获得拥有权 123456789// 例如已有 fooArray, 通过 array 方法获得其引用NSArray *bar = [fooArray array];// 不可以直接调用 release，因为没有拥有权// [bar release];// 需要先 retain 来获得拥有权，然后才能释放[bar retain];[bar release]; 你所拥有的对象不再需要使用时，必须将其释放 不能释放你不拥有的对象 retain retain和属性 我们可以通过属性来保存对象，如果一个属性为强引用，我们就可以通过属性的实例变量和存取方法来对某个对象进行操作，例如某个属性的setter方法如下： 12345678910- (void)setPerson:(Person *)person &#123; [person retain]; [_person release]; _person = person; &#125; 我们通过 retain新值，release旧值，再给实例变量更新值。 需要注意的一点是：需要先retain新值，再release旧值。因为如果新旧值是同一个对象的话，先release就有可能导致该对象被系统回收，再去retain就没有任何意义了。例如下面这个例子： 123456789101112131415161718192021222324252627282930#import &quot;ViewController.h&quot;#import &quot;Person.h&quot;@interface ViewController ()@property (nonatomic, strong)Person *person;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // 实例变量持有Person类对象(P对象)。这样赋值不会调用set方法 _person = [[Person alloc] init]; // 调用set方法 self.person = _person; &#125;- (void)setPerson:(Person *)person &#123; // release释放对P对象的引用，P对象引用计数值变为零，则P对象被系统回收 [_person release]; // 由于P对象已经被回收，再去retain就容易出问题 [person retain]; _person = person;&#125;@end 由于P对象被回收，对应其所分配的内存被置于 可用内存池 中。如果该内存未被覆写，那么P对象依然有效；如果内存被覆写，那么实例变量_person就会指向一个被覆写的未知对象的指针，那么实例变量就变成一个 悬挂指针。 retain和数组 如果我们把一个对象加入到一个数组中，那么该数组的addObject方法会对该对象调用retain方法。例如以下代码： 12345678// person获得并持有P对象，P对象引用计数为1Person *person = [[Person alloc] init]; // Person类对象生成的P对象 NSMutableArray *array = [NSMutableArray array]; // person被加入到数组，对象P引用计数值为2[array addObject:person]; 此时，对象P被person和array两个变量同时持有。 release 自己持有的对象自己释放 当我们持有一个对象，如果在不需要继续使用该对象，我们需要对其进行释放(release)。例如以下代码： 12345678// array获得并持有NSArray类对象NSArray *array = [[NSArray alloc] init]; // 当不再需要使用该对象时，需要释放[array release]; // obj获得但不持有该对象id obj = [NSArray array]; 非自己持有的对象不要释放 当我们不持有某个对象，却对该对象进行释放，应用程序就会崩溃。 12345678// 获得并持有A对象Person *p = [[Person alloc] init]; // Person类对象A // 对象A引用计数为零，所以对象A被回收[p release];// 释放非自己持有的对象[p release]; 另外，我们也不能访问某个已经被释放的对象，该对象所占的堆空间如果被覆写就会发生崩溃的情况。 autorelease autorelease 指的是自动释放，当一个对象收到 autorelease 的时候，该 对象就会被注册到当前处于栈顶的自动释放池（autorelease pool）。如果没有主动生成自动释放池，则当前自动释放池对应的是主运行循环的自动释放池。在当前线程的RunLoop进入休眠前，就会对被注册到该自动释放池的所有对象进行一次release操作。 autorelease和release的区别是： release：是马上释放对某个对象的强引用； autorelease：是延迟释放某个对象的生命周期。 12345678910111213141516171819202122232425&#123; // 外部调用 Person *p = [Person person]; NSLog(@&quot;%p&quot;, p); //使用无须retain // 持有则需要retain [p retain]; _person = p; [_person release];&#125;// Person类内部定义+ (id)person &#123; //创建的Person类对象由person获得并持有 Person *person = [[Person alloc] init]; // [person release]; // 将 person 对象放入自动释放池 [person autorelease]; return person;&#125; 在外部调用，从方法名person知道，创建的对象由p指针变量获得但不持有。在函数内部，person获得并持有了Person类对象，所返回的person对象的引用计数加1。换句话说，调用者需要额外处理这多出来的一个持有操作。另外，我们不能在函数内部调用release，不然对象还没返回就已经被系统回收。这时候使用autorelease就能很好地解决这个问题。 只要把要返回的对象调用autorelease方法，注册到自动释放池就能延长person对象的生命周期，使其在 autorelease pool销毁(drain)前依然能够存活。 另外，person对象在返回时调用了 autorelease方法。该对象已经在自动释放池中，我们可以直接使用对象p，无须再通过[p retain]访问；不过，如果要用实例变量持有该对象，则需要对变量p进行一次retain操作，实例变量使用完该对象需要释放该对象。 autorelease pool autorelease pool 和 RunLoop(运行循环) 当应用程序启动，系统默认会 开启一条线程，该线程就是 主线程。主线程也有一个与之对应的自动释放池。 每条线程都包含一个与其对应的自动释放池，当某条线程被终止的时候，对应该线程的自动释放池会被销毁。同时，处于该自动释放池的对象将会进行一次 release 操作。 ，例如我们常见的 ARC 下的 main.h 文件： 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 该自动释放池用来释放在主线程下注册到该自动释放池的对象。 需要注意的是，当我们 开启一条子线程，并且在该线程 开启RunLoop 的时候，需要为其增加一个autorelease pool，这样有助于保证内存的安全。 autorelease pool和降低内存峰值 当我们执行一些复杂的操作，特别是如果这些复杂的操作要被循环执行，那么中间会免不了会产生一些临时变量。当被加到主线程自动释放池的对象越来越来多，却没有得到及时释放，就会导致内存溢出。这个时候，我们可以手动添加自动释放池来解决这个问题。如以下例子所示： 123456789101112for (int i = 0; i &lt; largeNumber; i++) &#123; // 创建自动释放池 NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init]; // 产生许多被注册到自动释放池的临时对象 id obj = [Person personWithComplexOperation]; // 释放池中对象 [pool drain]; &#125; 如上述例子所示，我们执行的循环次数是一个非常大的数字。并且调用personWithComplexOperation方法的过程中会产生许多临时对象，所产生的临时对象有可能会被注册到自动释放池中。我们通过手动生成一个自动释放池，并且在每次循环结束前把该自动释放池的对象执行release操作释放掉，这样就能有效地降低内存的峰值了。 ARC 概述 Automatic Reference Counting，自动引用计数，即 ARC，WWDC2011 和 iOS5 所引入的最大的变革和最激动人心的变化。ARC是新的LLVM 3.0编译器的一项特性，使用ARC，可以说举解决了广大iOS开发者所憎恨的手动内存管理的麻烦。 此处的 A 就是 automatic。其实 ARC 只是比 MRC 多了一步，就是在 编译时编译器自动帮开发者添加 retain, release 以及 autorelease 的调用，底层的内存管理机制还是和 MRC 一样。 在 ARC 模式下，我们通常在对象变量的声明里用 属性标记符 来指引 ARC 机制来管理我们的对象变量，它们是：strong, retain, weak, copy, assign。默认标记是 strong 标记符的区别 strong: 顾名思义，就是 强引用，对应 MRC 下的 retain，即引用数加 1 retain: 同 strong weak: 弱引用，不增加引用数，引用的对象被释放后变为 nil copy: 对对象进行 copy 后再赋值，因此对象必须遵循 NSCopying 协议。如： 123@property(copy)Foo *foo;...self.foo = bar; // 相当于 self.foo = [bar copy]; assign: 一般用于原始数据类型（primitive type）的赋值。可以用于对象，效果相当于 weak，可是有一个坑是当对象被释放后，assign 属性的变量不会变成 nil，而是成为 野指针（dangling pointer），因此不建议使用在对象上。 借助以上的属性标记符，我们可以在对象声明的时候集中制定它们的内存管理策略，清晰明了。 ARC的判断原则 ARC判断一个对象是否需要释放不是通过引用计数来进行判断的，而是通过强指针来进行判断的。那么什么是强指针? 强指针 默认所有对象的指针变量都是强指针 被__strong修饰的指针 12Person *p1 = [[Person alloc] init];__strong Person *p2 = [[Person alloc] init]; 弱指针 被 __weak 修饰的指针 1__weak Person *p = [[Person alloc] init]; ARC如何通过强指针来判断？ 只要还有一个强指针变量指向对象，对象就会保持在内存中 ARC的使用 123456int main(int argc, const char * argv[]) &#123; // 不用写release, main函数执行完毕后p会被自动释放 Person *p = [[Person alloc] init]; return 0;&#125; ARC的注意点 不允许调用对象的 release方法 不允许调用 autorelease方法 重写父类的dealloc方法时，不能再调用 [super dealloc]; ARC下单对象内存管理 局部变量释放对象随之被释放 12345678int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *p = [[Person alloc] init]; &#125; // 执行到这一行局部变量p释放 // 由于没有强指针指向对象, 所以对象也释放 return 0;&#125; 清空指针对象随之被释放 12345678int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *p = [[Person alloc] init]; p = nil; // 执行到这一行, 由于没有强指针指向对象, 所以对象被释放 &#125; return 0;&#125; 默认清空所有指针都是强指针 123456789int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // p1和p2都是强指针 Person *p1 = [[Person alloc] init]; __strong Person *p2 = [[Person alloc] init]; &#125; return 0;&#125; 弱指针需要明确说明 注意: 千万不要使用弱指针保存新创建的对象 12345678int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // p是弱指针, 对象会被立即释放 __weak Person *p1 = [[Person alloc] init]; NSLog(@&quot;%@&quot;,p); &#125; return 0;&#125; 打印结果： 12020-07-31 18:02:51.021697+0800 iOS-OC之ARC[2134:984503] (null) ARC下多对象内存管理 ARC和MRC一样, 想拥有某个对象必须用强指针保存对象, 但是不需要在dealloc方法中release 1234567@interface Person : NSObject// MRC写法//@property (nonatomic, retain) Dog *dog;// ARC写法@property (nonatomic, strong) Dog *dog;@end 自动释放池 概述 AutoreleasePool（自动释放池）是 OC 中的一种 内存自动回收机制。 当向一个对象发送 autorelease 消息时，会将对象加入到自动释放池，这个对象不会立即释放，而是等到 runloop休眠或超出autoreleasepool作用域 之后进行 释放。 MRC 下使用自动释放池 在MRC环境中使用自动释放池需要用到 NSAutoreleasePool 对象，其生命周期就相当于C语言变量的作用域。对于所有调用过 autorelease方法的对象，在废弃NSAutoreleasePool对象时，都将调用release实例方法。用源代码表示如下： 12345678910111213// MRC环境下的测试：// 第一步：生成并持有释放池NSAutoreleasePool对象;NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];// 第二步：调用对象的autorelease实例方法;id obj = [[NSObject alloc] init];[obj autorelease];// 第三步：废弃NSAutoreleasePool对象;[pool drain]; // 向pool管理的所有对象发送消息，相当于[obj release]// obj已经释放，再次调用会崩溃(Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT))NSLog(@&quot;打印obj：%@&quot;, obj); ARC 下使用自动释放池 ARC环境不能使用NSAutoreleasePool类也不能调用autorelease方法，代替它们实现对象自动释放的是 @autoreleasepool块。 12345// ARC环境下的测试：@autoreleasepool &#123; id obj = [[NSObject alloc] init]; NSLog(@&quot;打印obj：%@&quot;, obj); &#125; ARC 下 AutoReleasePool 内部实现使用@autoreleasepool{}我们在main函数中写入自动释放池相关的测试代码如下： 123456int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125; 为了探究释放池的底层实现，我们在终端使用 clang -rewrite-objc + 文件名命令将上述OC代码转化为 C++ 源码： 123456789int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_d37e0d_mi_0); &#125; // 大括号对应释放池的作用域 return 0;&#125; 在经过编译器 clang 命令转化后，我们看到的所谓的 @autoreleasePool块，其实对应着__AtAutoreleasePool的结构体。 分析结构体 __AtAutoreleasePool 的具体实现在源码中找到 __AtAutoreleasePool结构体 的实现代码，具体如下： 12345678extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; void * atautoreleasepoolobj;&#125;; __AtAutoreleasePool结构体包含了：构造函数、析构函数和一个对象； 构造函数内部调用：objc_autoreleasePoolPush() 方法，返回对象atautoreleasepoolobj 析构函数内部调用：objc_autoreleasePoolPop() 方法，传入对象atautoreleasepoolobj 分析main函数中 __autoreleasepool结构体实例的生命周期是这样的： __autoreleasepool是一个自动变量，其构造函数是在程序执行到声明这个对象的位置时调用的，而其析构函数则是在程序执行到离开这个对象的作用域时调用。所以，我们可以将上面main函数的代码简化如下： 12345678int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; void *atautoreleasepoolobj = objc_autoreleasePoolPush(); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kb_06b822gn59df4d1zt99361xw0000gn_T_main_d39a79_mi_0); objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; return 0;&#125; objc_autoreleasePoolPush 与 objc_autoreleasePoolPop进一步观察自动释放池构造函数与析构函数的实现，其实它们都只是对AutoreleasePoolPage 对应静态方法 push 和 pop 的封装： 1234567void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; 理解 AutoreleasePoolPageAutoreleasePoolPage 是一个 C++ 中的类，打开Runtime的源码工程，在NSObject.mm文件中可以找到它的定义，摘取其中的关键代码如下： 123456789101112131415161718192021class AutoreleasePoolPage &#123;# define EMPTY_POOL_PLACEHOLDER ((id*)1) // 空池占位# define POOL_BOUNDARY nil // 即哨兵对象 static pthread_key_t const key = AUTORELEASE_POOL_KEY; static uint8_t const SCRIBBLE = 0xA3; // 0xA3A3A3A3 after releasing static size_t const SIZE = #if PROTECT_AUTORELEASEPOOL PAGE_MAX_SIZE; // must be multiple of vm page size#else PAGE_MAX_SIZE; // size and alignment, power of 2#endif static size_t const COUNT = SIZE / sizeof(id); magic_t const magic; // 校验AutoreleasePagePoolPage结构是否完整 id *next; // 指向新加入的autorelease对象的下一个位置，初始化时指向begin() pthread_t const thread; // 当前所在线程，AutoreleasePool是和线程一一对应的 AutoreleasePoolPage * const parent; // 指向父节点page，第一个结点的parent值为nil AutoreleasePoolPage *child; // 指向子节点page，最后一个结点的child值为nil uint32_t const depth; // 链表深度，节点个数 uint32_t hiwat; // 数据容纳的一个上限 //......&#125;; AutoreleasePoolPage 中拥有 parent 和 child 指针，分别指向上一个和下一个 page；当前一个page的空间被占满(每个AutorelePoolPage的大小为4096字节)时，就会新建一个AutorelePoolPage对象并连接到链表中，后来的Autorelease对象也会添加到新的page中；另外，当next&#x3D;&#x3D; begin()时，表示AutoreleasePoolPage为空；当next &#x3D;&#x3D; end()，表示AutoreleasePoolPage已满。 理解 哨兵对象(POOL_BOUNDARY)的作用，而它的作用事实上也就是为了 起到一个标识的作用。 每当自动释放池初始化调用 objc_autoreleasePoolPush 方法时，总会通过 AutoreleasePoolPage 的 push 方法，将 POOL_BOUNDARY 放到当前 page 的栈顶，并且返回这个对象 atautoreleasepoolobj； 而在自动释放池释放调用 objc_autoreleasePoolPop 方法时，又会将 atautoreleasepoolobj对象 以参数传入，这样自动释放池就会向释放池中对象发送release消息，直至找到第一个边界对象为止。 理解 objc_autoreleasePoolPush 方法经过前面的分析，objc_autoreleasePoolPush 最终调用的是 AutoreleasePoolPage 的 push 方法，该方法的具体实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static inline void *push() &#123; return autoreleaseFast(POOL_BOUNDARY);&#125;static inline id *autoreleaseFast(id obj)&#123; AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123; return page-&gt;add(obj); &#125; else if (page) &#123; return autoreleaseFullPage(obj, page); &#125; else &#123;1. return autoreleaseNoPage(obj); &#125;&#125;// 压栈操作：将对象加入AutoreleaseNoPage并移动栈顶的指针id *add(id obj) &#123; id *ret = next; *next = obj; next++; return ret;&#125;// 当前hotPage已满时调用static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123; do &#123; if (page-&gt;child) page = page-&gt;child; else page = new AutoreleasePoolPage(page); &#125; while (page-&gt;full()); setHotPage(page); return page-&gt;add(obj);&#125;// 当前hotpage不存在时调用static id *autoreleaseNoPage(id obj) &#123; AutoreleasePoolPage *page = new AutoreleasePoolPage(nil); setHotPage(page); if (obj != POOL_SENTINEL) &#123; page-&gt;add(POOL_SENTINEL); &#125; return page-&gt;add(obj);&#125; 观察上述代码，每次调用 push 其实就是 创建一个新的AutoreleasePoolPage，在对应的AutoreleasePoolPage中插入一个 POOL_BOUNDARY ，并且返回插入的 POOL_BOUNDARY 的内存地址。自动释放池最终都会通过 page-&gt;add(obj) 方法 将对象添加到page中，而这一过程被分为三种情况： * 当前page存在且不满，调用 `page-&gt;add(obj)` 方法将 `对象` 添加至page的栈中，即next指向的位置 * 当前page存在但是已满，调用 autoreleaseFullPage 初始化一个新的 page，调用page-&gt;add(obj)方法将对象添加至page的栈中 * 当前page不存在时，调用 autoreleaseNoPage 创建一个 hotPage，再调用page-&gt;add(obj) 方法将对象添加至page的栈中 理解 objc_autoreleasePoolPop 方法 AutoreleasePool 的释放调用的是 objc_autoreleasePoolPop 方法，此时需要传入 atautoreleasepoolobj 对象作为参数。 同理，我们找到 objc_autoreleasePoolPop 最终调用的方法，即 AutoreleasePoolPage 的pop方法，该方法的具体实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041static inline void pop(void *token) // POOL_BOUNDARY的地址&#123; AutoreleasePoolPage *page; id *stop; page = pageForPointer(token); // 通过POOL_BOUNDARY找到对应的page stop = (id *)token; if (DebugPoolAllocation &amp;&amp; *stop != POOL_SENTINEL) &#123; // This check is not valid with DebugPoolAllocation off // after an autorelease with a pool page but no pool in place. _objc_fatal(&quot;invalid or prematurely-freed autorelease pool %p; &quot;, token); &#125; if (PrintPoolHiwat) printHiwat(); // 记录最高水位标记 page-&gt;releaseUntil(stop); // 向栈中的对象发送release消息，直到遇到第一个哨兵对象 // memory: delete empty children // 删除空掉的节点 if (DebugPoolAllocation &amp;&amp; page-&gt;empty()) &#123; // special case: delete everything during page-per-pool debugging AutoreleasePoolPage *parent = page-&gt;parent; page-&gt;kill(); setHotPage(parent); &#125; else if (DebugMissingPools &amp;&amp; page-&gt;empty() &amp;&amp; !page-&gt;parent) &#123; // special case: delete everything for pop(top) // when debugging missing autorelease pools page-&gt;kill(); setHotPage(nil); &#125; else if (page-&gt;child) &#123; // hysteresis: keep one empty child if page is more than half full if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125; &#125;&#125; 【总结】【结构】： 自动释放池的压栈和出栈，通过结构体的构造函数和析构函数实现： 压栈：调用 objc_autoreleasePoolPush() 函数，内部调用的是 AutoreleasePoolPage 的 push() 方法，返回 atautoreleasepoolobj 对象 出栈：调用 objc_autoreleasePololPop() 函数，内部调用的是 AutoreleasePoolPage 的 pop() 方法，传入 atautoreleasepoolobj 对象 【容量】： 池页大小为4096字节，每一页都包含56字节的成员变量，但一个自动释放池中，只会压栈一个哨兵对象，占8字节 【原理】： 自动释放池的本质是 __AtAutoreleasePool 结构体，包含构造函数和析构函数 结构体声明，触发构造函数，调用 objc_autoreleasePoolPush() 函数，对象压栈 如果存在page，并且没有存满，调用add函数 将对象压栈 如果存在page，但存储已满，调用autoreleaseFullPage函数 遍历链表，找到最后一个空白的子页面 对其进行创建新页 设置为热页面 添加对象 否则，不存在page，调用autoreleaseNoPage函数 通过父类AutoreleasePoolPageData进行初始化 begin：获取对象压栈的起始位置 objc_thread_self：通过tls获取当前线程 链接双向链表 设置为热页面 pushExtraBoundary为YES，哨兵对象压栈 对象压栈 结构体出作用域，触发析构函数，调用 objc_autoreleasePoolPop() 函数，对象出栈 调用popPage函数，传入stop为哨兵对象的位置 当前页中对象出栈，到stop位置停止 调用kill函数，销毁当前页面 AutoreleasePool在主线程上的释放时机 分析主线程RunLoop管理自动释放池并释放对象的详细过程，我们在如下Demo中的主线程中设置断点，并执行lldb命令：po [NSRunLoop currentRunLoop]，具体效果如下： 我们看到主线程RunLoop中有两个与自动释放池相关的Observer,对应CFRunLoopActivity的类型如下: 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), //0x1，启动Runloop循环 kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //0xa0，即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), kCFRunLoopExit = (1UL &lt;&lt; 7), //0xa0，退出RunLoop循环 kCFRunLoopAllActivities = 0x0FFFFFFFU &#125;; 结合RunLoop监听的事件类型，分析主线程上自动释放池的使用过程如下： App启动后，苹果在主线程RunLoop里注册了两个Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler(); 第一个Observer监视的事件 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush()创建自动释放池。 第二个Observer监视了两个事件 : BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop()和_objc_autoreleasePoolPush()释放旧的池并创建新池； Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop()来释放自动释放池。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄漏，开发者也不必显示创建AutoreleasePool了; 之后的时机 程序启动到加载完成后，主线程对应的RunLoop会停下来等待用户交互 用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。 RunLoop检测到事件后，就会创建自动释放池; 所有的延迟释放对象都会被添加到这个池子中; 在一次完整的运行循环结束之前，会向池中所有对象发送release消息，然后自动释放池被销毁; AutoreleasePool子线程上的释放时机子线程默认不开启RunLoop，那么其中的延时对象该如何释放呢？其实这依然要从Thread和AutoreleasePool的关系来考虑： 就是说，每一个线程都会维护自己的 Autoreleasepool栈，所以子线程虽然默认没有开启RunLoop，但是依然存在AutoreleasePool，在 子线程退出 的时候会去释放autorelease对象。 前面讲到过，ARC会根据一些情况进行优化，添加__autoreleasing修饰符，其实这就相当于对需要延时释放的对象调用了autorelease方法。从源码分析的角度来看，如果子线程中没有创建AutoreleasePool ，而一旦产生了Autorelease对象，就会调用autoreleaseNoPage方法自动创建hotpage，并将对象加入到其栈中。所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。 AutoreleasePool需要手动添加的情况 尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建 AutoreleasePool，而其中的延时对象将在当前释放池的作用域结束时释放。苹果文档中说明了三种情况，我们可能会需要手动添加自动释放池： 编写的不是基于UI框架的程序，例如命令行工具； 通过循环方式创建大量临时对象； 使用非Cocoa程序创建的子线程； 而在ARC环境下的实际开发中，我们最常遇到的也是第二种情况，以下面的代码为例： 1234567- (void)viewDidLoad &#123; [super viewDidLoad]; for (int i = 0; i &lt; 1000000; i++) &#123; NSObject *obj = [[NSObject alloc] init]; NSLog(@&quot;打印obj：%@&quot;, obj); &#125; &#125; 上述代码中，obj因为离开作用域所以会被加入最近一次创建的自动释放池中，而这个释放池就是主线程上的RunLoop管理的；因为for循环在当前线程没有执行完毕，Runloop也就没有完成当前这一次的迭代，所以导致大量对象被延时释放。释放池中的对象将会在viewDidAppear方法执行前就被销毁。在此情况下，我们就有必要通过手动干预的方式及时释放不需要的对象，减少内存消耗；优化的代码如下： 123456789- (void)viewDidLoad &#123; [super viewDidLoad]; for (int i = 0; i &lt; 1000000; i++) &#123; @autoreleasepool&#123; NSObject *obj = [[NSObject alloc] init]; NSLog(@&quot;打印obj：%@&quot;, obj); &#125; &#125; &#125;","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习02：文件导入#include,#import,@class区别","slug":"OC学习02：文件导入#include,#import,@class区别","date":"2023-03-02T08:39:08.000Z","updated":"2023-03-02T10:13:48.926Z","comments":true,"path":"2023/03/02/OC学习02：文件导入#include,#import,@class区别/","link":"","permalink":"https://www.bboyzj.cn/2023/03/02/OC%E5%AD%A6%E4%B9%A002%EF%BC%9A%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5#include,#import,@class%E5%8C%BA%E5%88%AB/","excerpt":"","text":"前言 #include 、 #import 和 @class 都是用来 包含头文件 C/C++ 只能用 #include 包含头文件，没有 #import 和 @class OC 中 #include 、 #import 和 @class 都可以用 那么问题来了，三种包含头文件方式在 OC 中有什么区别呢？ include、import #include 会重复导入头文件，重复导入会报重复定义的错误；#import 不会重复导入头文件，允许交叉编译 #include &lt;xxx.h&gt; 或 #import &lt;xxx.h&gt; ：用于导入 系统自带文件，在 系统文件目录下查找 #include “xxx.h” 或 #import “xxx.h” ：用于导入 用户自定义的文件，查找顺序：用户文件目录 -&gt; 安装文件目录 -&gt; 系统文件目录，所以 “xxx.h” 一般用来导入用户自定义的文件 class @class XXXClassName ： 用于声明一个类，用于解决互相引用的问题（A引用B，B引用A） include 示例 A文件导入两次B文件：报重复定义错误 12345678910#import &lt;UIKit/UIKit.h&gt;// include 不允许重复导入两次#include &quot;VB.h&quot;#include &quot;VB.h&quot;NS_ASSUME_NONNULL_BEGIN@interface VA : UIView@end command + b 编译报错： A引用B，B引用C，A再引用C：同样 报重复定义错误，相当于A引用了两次C import 示例 导入两次A文件，不报错 123// 导入两次A文件#import &quot;A.h&quot;#import &quot;A.h&quot; class 使用场景 A类引用B类，B类引用A：互相引用报错 A.h文件 12345#import &lt;UIKit/UIKit.h&gt;#import &quot;B.h&quot;@interface A : UIView@property (nonatomic,strong)B * b;@end B.h文件 12345#import &lt;UIKit/UIKit.h&gt;#import &quot;A.h&quot;@interface B : UIView@property (nonatomic,strong)A * a;@end 可以用 @class 方式进行引用，一个用@class或者两个都用 @class 1234//#import &quot;A.h&quot;// class声明A@class A;","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"Blog-05：Picgo+Gitee图床","slug":"Blog-05：Picgo-Gitee图床","date":"2023-03-01T11:25:22.000Z","updated":"2023-03-02T16:23:50.879Z","comments":true,"path":"2023/03/01/Blog-05：Picgo-Gitee图床/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog-05%EF%BC%9APicgo-Gitee%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"背景最近发现上传到 GitHub 上的图片大部分不能使用了，然后上网查了一下，应该是 DNS 的问题，网上也有很多解决方案，有兴趣的可以去网上找找，本文主要介绍 Picgo + Gitee 做图床。 Picgo 介绍picgo 是一款功能实用、操作简捷的图床工具，图床工具简单来说就是本地图片上传自动转换成链接的一款工具。 picgo 本体支持如下图床： 七牛图床 v1.0 腾讯云 COS v4\\v5 版本 v1.1 &amp; v1.5.0 又拍云 v1.2.0 GitHub v1.5.0 SM.MS V2 v2.3.0-beta.0 阿里云 OSS v1.6.0 Imgur v1.6.0 Tips: 本体不再增加默认的图床支持。你可以自行开发第三方图床插件。 特色功能 支持拖拽图片上传 支持快捷键上传剪贴板里第一张图片 Windows 和 macOS 支持右键图片文件通过菜单上传 (v2.1.0+) 上传图片后自动复制链接到剪贴板 支持自定义复制到剪贴板的链接格式 支持修改快捷键，默认快速上传快捷键：command+shift+p（macOS） | control+shift+p（Windows\\Linux） 支持插件系统，已有插件支持 Gitee、青云等第三方图床 Tips: 请确保你安装了 Node.js， 并且版本 &gt;&#x3D; 8。 默认上传图床为 SM.MS。picgo 上传之后，会自动将上传成功的 URL复制到你的剪贴板，支持5种复制格式。 Mini窗口只支持Windows（圆形）和Linux（方形），macOS可以使用顶部栏图标。（因为Windows和Linux的任务栏不支持拖拽事件） 准备 nodejs 环境 picgo 客户端 picgo 的 Gitee 上传插件 git、Gitee 账号和一个公开仓库 安装 nodejs官网 安装 点击链接下载安装 nodejs，安装完成后，查看版本 12345mac@bogon ~ % node -vv18.14.2mac@bogon ~ % npm -vmac@bogon ~ % npm -v9.5.0 安装 picgo 客户端 picgo安装链接 如果电脑是 Intel 就选 x64，如果电脑是 M1 就选 arm64 安装 git Mac 默认是已经安装好了 git 注册&#x2F;登录 Gitee 账号 Gitee 首页按要求自行注册&#x2F;登录即可 新建一个 Gitee 仓库 仓库名：随意，如 Picgo私有创建 将仓库 开源 由于创建仓库的时候只能 私有，所以此步配置 开源 操作如下： 进入仓库 -&gt; 管理 -&gt; 基本信息 -&gt; 开源（空仓库不允许） -&gt; 保存 生成 Token Token 用于 picgo 操作 Gitee repository： 点击头像 -&gt; 设置 -&gt; 私人令牌 -&gt; 生成新令牌 -&gt; 提交 复制你生成的令牌，只显示一次，再次刷新则看不见了，因此你要保存好 配置 picgo 启动 picgo -&gt; 插件设置 -&gt; 搜索 Gitee -&gt; 点击插件图标 安装 即可，本文使用 gitee 2.0.5 插件来进行演示 Tips： 插件装完后，重启生效 配置 Gitee 插件进入 图床设置 -&gt; gitee， 依次填入相关配置如下所示，填写如下： repo： 用户名&#x2F;仓库名（必填）， bboy-zhang-jian/picgo path: 上传路径，仓库里的图片保存路径（非必填） token: 私人令牌（必填），刚才保存的 token message: 提交消息（非必填） path: 上传路径，仓库里的图片保存路径（非必填） customPath: 定制路径（非必填） customUrl: 图片定制URL（非必填） 将仓库开源头像 -&gt; 仓库 -&gt; 管理 -&gt; 公开 -&gt; 仓库公开须知全部 勾选 上传图片 将图片拖动到 上传区 里 快捷键 Ctrl + shift + p ERROR Plugin load failed: hexo-renderer-scss1mac@bogon Blog % npm install hexo-renderer-scss 出现 Error: Cannot find module ‘node-sass’1mac@bogon Blog % npm install node-sass 不用管了，版本不一致导致的","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"OC学习01：事件传递链和响应链","slug":"OC学习01：事件传递链和响应链","date":"2023-03-01T09:30:34.000Z","updated":"2023-03-02T08:54:15.933Z","comments":true,"path":"2023/03/01/OC学习01：事件传递链和响应链/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/","excerpt":"","text":"前言在 iOS 中只有继承 UIResponder 的 对象 才能够接收并处理事件，UIResponder 是所有响应对象的 基类。继承关系如下： UIApplication -&gt; UIResponder -&gt; NSObject UIViewController -&gt; UIResponder -&gt; NSObject UIWindow -&gt; UIViww -&gt; UIResponder -&gt; NSObject UIButton -&gt; UIControl -&gt; UIView -&gt; UIResponder -&gt; NSObject UIView -&gt; UIResponder -&gt; NSObject 事件链 传递链：由系统向离用户最近的view传递。顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; RootViewController -&gt; subViews 响应链：由离用户最近的view向系统传递。顺序： superViews –&gt; RootViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate 传递链 事件传递的两个核心方法 1234// 返回哪个视图进行事件响应- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event; // 判断某一个点击的位置是否在视图范围内- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event; 其中 UIView 不接受事件处理的情况有 hidden &#x3D; YES 视图被隐藏 userInteractionEnabled &#x3D; NO 不接受响应事件 alpha &lt;&#x3D; 0.01,透明视图不接收响应事件 子视图超出父视图范围 需响应视图被其他视图盖住 是否重写了其父视图以及自身的hitTest方法 是否重写了其父视图以及自身的pointInside方法 流程描述 当iOS程序发生触摸事件后，系统会利用 Runloop 将事件加入到 UIApplication 的任务队列中 UIApplication 分发触摸事件到 UIWindow 然后 UIWindow 依次向下分发给 UIView UIView 调用 hitTest:withEvent: 方法返回一个最终响应的视图 在 hitTest:withEvent: 方法中就会去调用 pointInside: withEvent: 去判断当前点击的 point 是否在 UIView 范围内，如果是的话，就会去 逆序遍历 它的子视图来查找最终响应的 子视图 遍历的方式是使用 倒序 的方式来遍历子视图，也就是说最后添加的子视图会最先遍历，在每一个视图中都会去调用它的 hitTest:withEvent: 方法，可以理解为是一个 递归调用 最终会返回一个响应视图，如果返回视图有值，那么这个视图就作为最终响应视图，结束整个事件传递；如果没有值，那么就会将UIView作为响应者 响应链响应者链的事件传递过程 如果 view 的控制器存在，就传递给控制器处理；如果控制器不存在，则传递给它的 父视图 在视图层次结构的最顶层，如果也不能处理收到的事件，则将事件传递给 UIWindow 对象进行处理 如果 UIWindow 对象也不处理，则将事件传递给 UIApplication 对象 如果 UIApplication 也不能处理该事件，则将该事件丢弃 面试题 实现一个按钮的点击范围扩大效果 思路：自定义一个按钮，重写 poinstInSide 方法，增大内边距，返回一个新的bounds 1234567891011#import &quot;ZJBtn.h&quot;@implementation ZJBtn- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; // 当前btn大小 CGRect btnBounds = self.bounds; // 扩大按钮的点击范围，增大内边距 btnBounds = CGRectInset(btnBounds, -50, -50); // 若点击的点在新的bounds里，返回YES return CGRectContainsPoint(btnBounds, point);&#125;@end 子视图超过父视图部分仍然能响应 思路：正常情况下子视图超出部分是不能响应事件的，需重写 hitTest:withEvent 方法，指定 子视图 可点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#import &quot;VA.h&quot;@interface VA ()@property (nonatomic,strong)UIButton * btn;@end@implementation VA- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; [self addSubview:self.btn]; &#125; return self;&#125;- (void)clickBtn&#123; NSLog(@&quot;%s&quot;,__func__);&#125;- (UIButton *)btn&#123; if (!_btn) &#123; _btn = [[UIButton alloc] initWithFrame:CGRectMake(-50, 20, self.frame.size.width + 100, 100)]; _btn.backgroundColor = [UIColor blueColor]; [_btn addTarget:self action:@selector(clickBtn) forControlEvents:UIControlEventTouchUpInside]; &#125; return _btn;&#125;/* 子视图超过父视图部分，需要点击超出范围的部分也有相应 */- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // 判断btn能否接收事件 if (self.btn.userInteractionEnabled == NO || self.btn.hidden == YES || self.btn.alpha &lt;= 0.01) &#123; return nil; &#125; // 把当前点转换成btn坐标系上的点 CGPoint btnP = [self convertPoint:point toView:self.btn]; // 当触摸点在btn上时，才让按钮相应事件 if ([self.btn pointInside:btnP withEvent:event]) &#123; NSLog(@&quot;%@&quot;,NSStringFromCGPoint(btnP)); return self.btn; &#125; NSLog(@&quot;父视图相应&quot;); return [super hitTest:point withEvent:event];&#125;@end","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"iOS面试题：Swift","slug":"iOS面试题：Swift","date":"2023-03-01T08:57:50.000Z","updated":"2023-03-02T06:41:01.704Z","comments":true,"path":"2023/03/01/iOS面试题：Swift/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASwift/","excerpt":"","text":"swift 和 oc 的区别？ swift 是静态语言，有类型判断。OC 是动态语言。 swift 可以面向 函数、协议、对象 编程；oc以面向 对象 编程为主，可以引入 Reactive Cocoa类库 来进行函数式编程 Swift 是 类型安全 的语言。OC 不是类型安全的语言。 Swift 大部分都是 值类型，少部分是 Class引用类型。OC 有的是 值类型，有的是 指针类型。 swift类型？Swiift 值类型 和 引用类型的区别？特点？ swift的类型分为 值类型 和 引用类型。 值类型：在swift中定义的很多类型都是值类型：如 struct、enum、Int、Float、Bool、String、Array、Dictionary、String 等都是 值类型。 引用类型：只有 class 为引用类型 区别 值类型：传递和赋值时是一个 副本，使用过程中不会影响 源数据 引用类型：传递和赋值是 本身（内存地址），使用过程中会影响源数据 常用的关键字 final： 只能用于 类 中，修饰的 方法、属性，不能被重写 final 修饰的类，不能被继承 inout： 将值类型 转为 引用类型 mutating： 涉及到修改自身内存用 #available 用来判断平台和操作系统 @available 用于修饰 方法、属性、协议、扩展，用来表达它的可用性","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-面试题","slug":"Swift-面试题","permalink":"https://www.bboyzj.cn/tags/Swift-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"iOS面试题：OC","slug":"iOS面试题：OC","date":"2023-03-01T08:57:33.000Z","updated":"2023-03-02T15:56:12.401Z","comments":true,"path":"2023/03/01/iOS面试题：OC/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AOC/","excerpt":"","text":"OC算法1. 冒泡排序1）依次比较相邻两个元素，顺序错误则交换位置；需要两层循环，外层循环控制趟数，内层循环控制比较次数 2）例子： 123456789101112NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;5&quot;,@&quot;4&quot;]]; // 外循环控制排序趟数,进行 array.count-1 趟 for (int i = 0; i &lt; arr.count; i ++) &#123; // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序 for (int j = 0; j &lt; arr.count - i - 1; j++) &#123; // 相邻元素比较，若逆序则交换 if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123; [arr exchangeObjectAtIndex:j withObjectAtIndex:j + 1]; &#125; &#125; &#125; 2. 选择排序1）从第一个元素与其他元素比较找到最小值，重复操作，直到最后一位结束；需要两层循环，外层循环趟数，里层循环比较次数 2）例子 1234567891011NSMutableArray * arr = [NSMutableArray arrayWithObjects:@&quot;2&quot;,@&quot;1&quot;,@&quot;5&quot;,@&quot;3&quot;, nil];// 外循环控制排序趟数,进行 array.count-1 趟for (int i = 0; i &lt; arr.count; i ++) &#123; // 里循环获比较换位 for (int j = i + 1; j &lt; arr.count; j ++) &#123; if ([arr[i] intValue] &gt; [arr[j] intValue]) &#123; [arr exchangeObjectAtIndex:i withObjectAtIndex:j]; &#125; &#125;&#125;NSLog(@&quot;arr:%@&quot;,arr); 3. 直接插入排序1） 始终定义第一个元素为 已排序 的，将剩余元素定义为 未排序 逐个插入到 已排序 的排列中；不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去 2）例子 12345678910111213141516171819NSMutableArray * arr = @[@2,@1,@3,@5,@4].mutableCopy;// 插入排序的原理：始终定义第一个元素为有序的，将元素逐个插入到有序的排列中// 其特点是：不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去for(int i = 0;i &lt; arr.count;i++)&#123; // 待排序值 NSNumber * temp = arr[i]; // 已排序下标 int j = i - 1; // 待排序与已排序比较，从后向前比较 while (j &gt;= 0 &amp;&amp; [arr[j] integerValue] &gt; [temp integerValue]) &#123; // 如果已排序的 &gt; 待排序的 往后移动一个位置 [arr replaceObjectAtIndex:(j + 1) withObject:arr[j]]; j --; &#125; // 空出来的位置插入新元素 [arr replaceObjectAtIndex:(j + 1) withObject:temp]; NSLog(@&quot;arr:%@&quot;,arr);&#125; 打印结果： 12345672022-12-13 10:26:19.242271+0800 插入排序[4184:77845] arr:( 1, 2, 3, 4, 5) 4. 希尔排序1）希尔排序相当于 直接插入排序加强版，引入了 增量 的概念；直到增量为 1 时，再进行直接插入排序 2）例子 1234567891011121314151617181920212223NSMutableArray * arr = @[@7,@3,@8,@5,@2,@6,@1,@4].mutableCopy;// 其实间隔值设值为总数的一半int gap = arr.count/2;// 直到间隔小于1时结束while (gap &gt;= 1) &#123; // i 待排元素，以 步距 gap 从后向前扫描 for(int i = 0;i &lt; arr.count;i++)&#123; // 待排元素 NSNumber * temp = arr[i]; // 当前位置 int j = i; // 跳跃式比较 while (j &gt;= gap &amp;&amp; [arr[j - gap] integerValue] &gt; [temp integerValue] ) &#123; [arr replaceObjectAtIndex:j withObject:arr[j - gap]]; j -= gap; &#125; // 空出来位置，插入待排序 [arr replaceObjectAtIndex:j withObject:temp]; &#125; // 改变步长 gap = gap/2;&#125;NSLog(@&quot;arr:%@&quot;,arr); 打印结果： 123456789102022-12-13 10:22:41.910840+0800 插入排序[4124:74568] arr:( 1, 2, 3, 4, 5, 6, 7, 8) 5. 斐波那契数列1）也就是 兔子数列，当前数是前两个数列之和 2）例子 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; NSInteger num = 10; NSInteger total = [self getTotalNum:num]; NSLog(@&quot;total:%ld&quot;,total);&#125;- (NSInteger)getTotalNum:(NSInteger)num&#123; if(num == 0)&#123; return 0; &#125; if(num == 1)&#123; return 1; &#125; return [self getTotalNum:num-2] + [self getTotalNum:num-1];&#125; 打印结果： 12022-12-13 10:28:32.672554+0800 斐波那契数列[4285:80606] total:89 6. 二分查找1）有序的数组，将数组分割成两份，利用查找的值跟中间值进行比较，如果查找的值大于中间值，就在数组的右边进行查找；如果查找的值小于中间值，就在数组的左边进行查找。如此循环的执行下去，最终找到符合的值。 2）例子 123456789101112131415161718192021222324NSArray * arr = @[@(1),@(3),@(5),@(6),@(8),@(10)];int key = [@(5) intValue];int min = 0;int max = arr.count - 1;int mid;while (min &lt;= max) &#123; // 计算中间下标 mid = (min + max) / 2; // 如果目标值 &gt; 中间下标的中间值 if (key &gt; [arr[mid] intValue]) &#123; //最小变为中间下标+1 min = mid + 1; &#125; // 如果目标值 &lt; 中间下标的中间值 else if (key &lt; [arr[mid] intValue])&#123; //最大变为中间下标-1 max = max - 1; &#125; // 否则，正好 else &#123; NSLog(@&quot;key:%d&quot;,mid); break; &#125;&#125; 打印结果： 12022-12-13 10:33:18.661324+0800 二分查找[4607:86953] key:2 7. 递归算法递归求和1+2+..+n? 1234567891011121314- (void)viewDidLoad &#123; [super viewDidLoad]; int sum = [self sum:4]; NSLog(@&quot;sum:%d&quot;,sum);&#125;- (int)sum:(int)n&#123; if (n == 1) &#123; return 1; &#125;else &#123; return [self sum:n-1] + n; &#125;&#125; 链表OC数据结构01：链表的探索 二叉树OC数据结构02：二叉树探索 OC常见的面试题什么是野指针？是一个没有指向 任何内存 的 指针，尝试使用它会导致 应用程序崩溃 什么是内存泄漏？一个 对象 没有被释放，会 内存泄漏，内存泄漏会导致应用程序占用的内存会越来越大，直到应用程序无内存可用时，会导致 应用程序崩溃 iOS 关键词有哪些？各有什么作用？ 重点 readwrite 可读可写 特性，同时生成get方法和set方法的声明和实现 readonly 只读 特性，只会生成get方法的声明和实现，不希望属性在类外改变 retain 持有 特性，retaincount 会 +1,用于 MRC nonatomic 非原子 特性 atomic 原子 特性，默认属性 atomic不是绝对线程安全的，只是对 setter/getter 方法使用了 自旋锁(spinlock_t)，内部使用 互斥锁(os_unfair_lock)，保证了 读/写 安全。 atomic并不能保证 整个对象 是线程安全的，需要对 整个对象 进行 加锁 来保证线程安全： * NSLock（互斥锁） * dispathch_semaphore（信号量） * @synchronized（互斥递归锁） assign 可以修饰 基本数据类型和对象。 通常用于修饰 基本数据类型，如Int、CGFloat、Double等，这是因为 基本数据类型放在栈区，栈由编译器自动分配和释放内存，栈先进后出，基本数据类型出栈后，assign修饰的基本数据类型就不存在了，不会出现 野指针 修饰对象，如NSString、实例对象等，引用计数不会增加，但 assign 修饰对象释放后，指针 不会被系统置为nil，会产生 野指针 或 EXC_BAD_ACCESS 错误。 strong 强引用，只修饰对象，属性默认修饰符 指向并持有该对象，其修饰的对象引用计数会 +1，引用计数不为 0 则不会被销毁，需要将其置为 nil 可以销毁。否则会出现 内存泄漏。 weak 弱引用，只修饰对象。 指向但并不拥有该对象，引用计数不增加。该对象自动在内存中销毁。 copy 用于修饰 不可变的对象。 比如NSString、NSDictionary、NSArray等。 浅拷贝和深拷贝 重点 浅拷贝 浅拷贝，拷贝了一个新的指针，与原对象指针指向同一块内存，引用计数 + 1；(A,CopyA &#x3D; [A copy]，A 变化，CopyA 的值也变化) 深拷贝 深拷贝，拷贝了一个新的对象，指向新的内存，新对象的 引用计数为 1，源对象引用计数不变；(A,MutableA &#x3D; [A mutbleCopy]，A 变化，MutableA 的值不变)。 NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？重点 对于不可变NSString&#x2F;NSArray&#x2F;NSDictionary，copy浅拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝) 对于可变NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary，copy深拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝) 自定义对象的copy和mutableCopy？ 重点 copy和mutableCopy都是深拷贝(属性：浅拷贝） 属性用copy还是strong？ 重点 对于不可变属性，推荐用copy，目的是为了 让本属性不受外界影响，无论给我传入可变还是不可变对象，我本身持有的就是一个不可变的副本，被set时，改变的是这个副本。 对于可变属性，推荐用strong，因为copy修饰后，会变成不可变对象，再调用可变对象函数时会 crash 一个APP是如何唤醒另一个APP的？ 重点URL Scheme：iOS有一个特性就是将 自身绑定 到一个自定义的 URL Scheme 上，该 scheme 用于从 浏览器或其他应用中启动本应用。 单例的写法和作用？ 重点单例模式的作用：可以保证程序运行过程中，一个类只返回一个实例，供外界访问；static保证类只分配一次内存；dispatch_once方法保证调用一次，并自动加锁，线程安全 12345678910111213141516static id _instance = nil; // 定义static全局变量，保证只分配一次内存+ (id)shareInstance&#123; return [[self alloc] init];&#125;+ (id)copyWithZone:(struct _NSZone *)zone&#123; static dispatch_once_t onceToken; // 声明一个静态的GcD单次任务 // 保证只执行一次 dispatch_once(&amp;onceToken,^&#123; // _instance = [super allocWithZone:zone]; &#125;); return p;&#125;``` 这么写可以保证下面两种方式返回同一个实例 Single * p1 &#x3D; [Single shareInstance];Single * p2 &#x3D; [[Single alloc] init];NSLog(@”%d”,p1&#x3D;&#x3D;p2); &#x2F;&#x2F; 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165## HTTPS和HTTP的区别？ **重点*** HTTP：超文本传输协议，信息明文传输；端口号80；响应速度快（使用TCP三次握手，客户端和服务端需要交换3个包）；* HTTPS：是由 HTTP+SSL/TLS 加密传输；端口号443；响应速度慢（除了使用TCP三个包，还要加上SSL握手的9个包）；需要到CA申请证书## TCP 和 UDP 区别? **重点*** 都是 `传输层` 协议* TCP协议是 `面向连接的可靠的传输层协议`。UDP协议是 `面向非连接的传输层协议`* TCP需要 `建立连接和断开连接`。UDP不需要连接。* TCP传 `输数据没有大小限制`。UDP `传输数据有大小限制`。* TCP会 `处理数据丢包重发`。UDP不会处理。# HTTP和socket区别？ **重点*** `HTTP` 应用层协议；`socket` 不属于协议范畴，而是一个接口（API），是对TCP/IP协议的封装* `HTTP` 是基于 `请求-响应` 形式 `短连接`，即客户端发送一次请求，服务端响应后立即 `断开连接`；socket 是基于TCP协议的 `长链接`，理论上 客户端和服务端一旦建立连接将不会主动断开* HTTP 传输慢，数据量大，安全差；socket 数据可自定义，数据量小，安全性高，适合信息实时交互（推送、聊天等）## staitc 和 const 的区别？ **重点*** const：表示 `只读` 的意思 * `const` 放在 `类型` 前：可以改变指针的指向，可以改变指针指向的内容 * `const` 放在 `变量` 前：不可以改变指针的指向，不可以改变指针指向的内容* static： `静态变量`，可修饰 `局部变量和全局变量`，可修饰方法 * `static` 可修饰 `局部/全局变量`，称为 `局部静态变量和全局静态变量`，只初始化一次，只分配一次内存，生命周期被改变，不再是作用域内 * `static` 修饰的 `方法`，可以在不同文件下重名，互不影响运行## 通用链接（Universal Links）**重点*** 服务端配置 `HTTPS` 证书 和添加 `apple-app-site-association` 地址关联文件* 移动端在plist添加 `Associated Domains` 关联域权限## 简述GET和POST请求的区别？ **重点*** GET 传输数据 `有缓存`；POST 传输数据 `没有缓存`* GET的 `参数` 放在 `URL` 的后面，并且第一个参数用 `?` 号拼接，后面的从第二个参数开始，直到最后一个，用 `&amp;` 分割；POST的 `参数` 放在 `请求体` 里面，并且第一个参数用 `,` 号拼接，后面从第二开始，直到最后用 `&amp;` 分割;* GET一般用于 `获取数据`；POST一般用于 `向服务器提交数据`* `GET` 的参数是暴漏在 `地址栏` 的，不安全；`POST` 的参数隐藏在 `请求体` 里面，相对安全一点;* GET请求提交数据受浏览器限制 `1k`，POST请求理论上无限制。## iOS中几种常见的设计模式？ **重点*** `代理模式`一对一的依赖关系，当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。* `观察者模式`KVO机制 和 Notification通知机制* `单例模式`保证程序运行过程中，一个类只返回一个实例，供外界访问* `工厂模式`通过一个类方法，`根据已有模板批量生产对象`。* `MVC模式`Model即数据模型view即视图controller即控制器## RunLoop是什么？ **重点*** 概念 `RunLoop` 又叫 `运行循环`，内部就是一个 `do-while循环`，在这个循环内部不断 `处理各种任务，保证程序持续运行`。* 目的RunLoop存在的目的： 就是当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，`提高程序性能，节省CPU资源`，该做事的时候做事，该休息的时候休息## RunLoop的作用？ **重点*** `保持程序持续运行`。 App一启动就会开启主线程，主线程在开启的时候就会开启主线程对应的RunLoop，RunLoop能保证线程不被销毁，主线程不销毁，程序就会持续运行。* `处理App中各类事件`。 事件响应、手势识别、界面刷新、AutoreleasePool自动释放池、NSTimer等事件处理。* `节省CPU资源，提高程序性能`。 如概述所述，当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，提高程序性能，节省资源，该做事的时候做事，该休息的时候休息。## 可以用Runloop实现什么功能？ **重点*** tableView 滚动时图片不加载SDWebImage + Runloop，图片延迟加载,滑动不加载图片* 线程保活往 `runloop` 中添加 `[[NSPort alloc] init]` 事件，* 解决NSTimer在滑动时停止工作的问题`default` 模式改为 `common` 模式* 检测卡顿`displaylink + runloop 进行卡顿检测，将数值和页面绑定上传到服务器`## RunLoop接收几种输入源，系统默认定义了几种模式？ **重点*** 输入源有两种基于 `端口` 的输入源（port）`自定义` 的输入源（custom）* 系统定义的RunLoop模式有五种，最常用的有三种，如下所示：NSDefaultRunLoopMode默认模式，主线程中默认是NSDefaultRunLoopModeUITrackingRunLoopMode视图滚动模式，RunLoop会处于该模式下NSRunLoopCommonModes并不是真正意义上的Mode，是一个占位用的“Mode”，默认包含了NSDefaultRunLoopMode和UITrackingRunLoopMode两种模式## RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？ **重点*** 每一个线程都有一个runloop，主线程的runloop默认启动。子线程的runloop默认不启动* mode：主要用来指定事件在运行时循环的优先级* 作用：保持程序的持续运行、随时处理各种事件、节省cpu资源(没事件休息释放资源)，提高程序的性能。## 怎么理解Objective-C是动态运行时语言。 **重点**主要是 `将数据类型的确定和函数的调用由编译时推迟到了运行时`。这个问题其实浅涉及到两个概念，`运行时和多态`。* 运行时：简单来说，运行时机制使我们 `直到运行时才去确定数据类型和要调用的函数`。* 多态：`不同对象以自己的方式响应相同的消息的能力` 叫做多态。## runtime项目中具体应用？ **重点*** `方法交换`。* 给 `分类添加属性`。 * 动态添加方法。* 字典转模型。* 数组越界。* 动态获取成员属性、成员变量、实例方法## KVC是什么？**重点**`KVC` 全程 `Key Value Coding`，中文 `键值编码`，是由 `NSKeyValueCoding` 非正式协议启动的一种机制，`对象` 采用该协议来 `间接访问对象的属性`。 (nullable id)valueForKey:(NSString *)key; (nullable id)valueForKeyPath:(NSString *)keyPath; (void)setValue:(nullable id)value forKey:(NSString *)key; (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; 1234567891011121314151617181920212223242526272829[KVC底层原理：](http://www.bboyzj.cn/2021/01/17/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8622%EF%BC%9AKVC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/)## KVO是什么？**重点**`KVO` 全程 `Key Value Observing`，中文 `键值观察`，它 `用于监听实例对象属性的变化`。## KVO的实现原理？(KVO的本质是什么？) **重点**当一个 `实例对象` 的 `属性注册了KVO`，实例对象 `isa指针` 的指向在注册KVO观察者之后，由 `原有类` 改为 `中间类(NSKVONotifing_类名)`；`中间类` 重写了 `属性setter方法、class、dealloc、_isKVOA` 方法；`dealloc` 方法中，移除 `KVO` 观察者之后，实例对象isa 指向由 `中间类` 更改为 `原有类`;中间类 从创建后就 `一直存在内存中`，不会被销毁。## KVO实际应用 **重点*** 观察 `实例对象` 的 `属性` 变化* 观察 `实例对象` 的 `容器` 变化 观察容器用： `mutableArrayValueForKey` [KVO底层原理：](http://www.bboyzj.cn/2021/01/25/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8623%EF%BC%9AKVO%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/) ## category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？**重点*** `category` 原则上它 `只能增加方法`，`不能增加成员（实例）变量`。可以添加属性，但是不会自动生成实例变量_name和setter和getter方法。可以添加方法* `扩展` 主要用来为一个类添加额外的原来没有的 `实例变量、方法和属性`。extension常用的形式并不是以一个单独的.h文件存在，而是寄生在类的.m文件中。类扩展中： @interface Person (){ int age; &#x2F;&#x2F;实例变量}@property (nonatomic,copy)NSString * name;&#x2F;&#x2F;属性 (void)run;&#x2F;&#x2F;方法@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475## iOS开发中有多少类型的线程？ **重点*** pthread一套用于 `C` 的多线程 `API`、适用于 `Unix / Linux / Windows` 等系统、跨平台、可移植、使用难度大* NSThread使用更加面向对象、简单易用，可直接操作线程对象* GCD旨在替代NSThread等线程技术、充分利用设备的 `多核`、基于 `C` 的底层的 API* NSOperation`NSOperation` 是基于 `GCD` 之上的更高一层的封装， `NSOpetation` 需要配合 `NSOpetationQueue` 来实现多线程## 根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？ **重点**dispatch_group_t + dispatch_group_enter + dispatch_group_leave + dispatch_group_notify## 10个网络请求顺序回调? GCD如何实现？**重点**dispatch_group_t + dispatch_semaphore_t：信号量（dispatch_semaphore_wait + dispatch_group_leave）## GCD和NSOperation的区别？ **重点*** `GCD执行效率更高`，而且由于队列中执行的是由block构成的任务，这是一个轻量级的数据结构，写起来更方便* GCD只支持FIFO的队列，而 `NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序`* NSOperationQueue甚至可以跨队列设置依赖关系，但是GCD只能通过设置串行队列，或者在队列内添加barrier(dispatch_barrier_async)任务，才能控制执行顺序,较为复杂* `NSOperationQueue因为面向对象`，所以 `支持KVO`，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished）、是否取消（isCanceld）具体的底层看 [OC底层原理27：GCD之 NSThread &amp; GCD &amp; NSOperation](http://www.bboyzj.cn/2021/03/23/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8627%EF%BC%9AGCD%E4%B9%8B%2520NSThread%2520&amp;%2520GCD%2520&amp;%2520NSOperation/)## 什么是Block？ **重点**`Block` 是将 `函数及其上下文封装起来的对象`## Block的本质 **重点** * block 的 `本质` 是 `对象、函数、结构`体，由于block函数没有名称，也被称为 `匿名函数`## Block的分类？ **重点*** 分为 `全局Block(_NSConcreteGlobalBlock)、栈Block(_NSConcreteStackBlock)、堆Block(_NSConcreteMallocBlock)` 三种形式。* 其中 `栈Block存储在栈(stack)区`，`堆Block存储在堆(heap)区`，`全局Block存储在已初始化数据(.data)区`。 * 堆：动态分配内存，需要程序员自己申请，程序员自己管理 * 栈：自动分配内存，自动销毁，先入后出，栈上的内容存在自动销毁的情况具体看底层原理 [OC底层原理30：Block底层原理](http://www.bboyzj.cn/2021/04/22/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8630%EF%BC%9ABlock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/)# 循环引用的几种情况和解决方式？ **重点*** Block原因： `self` 强引用了 `block`，而 `block` 内部又调用了 `self`解决： 使用 `Weak-Strong Dance`* Delegate原因：委托者和被委托人之间的相互强引用问题 `strong`解决：用 `weak` 进行弱引用 `或者` 通过中间对象(代理对象)的方式来解决(效率更加高的中间对象NSProxy：不需要进行发送消息和动态解析，直接进行消息转发)* NSTimer原因：self → timer → self(target) 的循环持有链解决：在适当的时机销毁 [_timer invalidate];_timer &#x3D; nil; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142# OC 如何进行内存管理的？ **重点*** 手动内存管理 MRC* 自动内存管理 ARC LLVM + Runtime 会为我们代码自动插入 retain 和 release 以及 autorelease等代码,不需要我们手动管理 * 自动释放池# 自动释放池原理 **重点*** 自动释放池的本质是 `__AtAutoreleasePool` 结构体，包含构造函数和析构函数* 结构体声明，触发构造函数，调用 `objc_autoreleasePoolPush()` 函数，对象压栈* 结构体出作用域，触发析构函数，调用 `objc_autoreleasePoolPop()` 函数，对象出栈# 内存优化 **重点*** cell复用* 绘制的话：用CAShaperLayer，渲染快，内存使用高效* 按需加载：懒加载* 合理利用缓存：比如三方图片压缩缓存* 尽量使用透明View：控件有背景色增大内存消耗# 启动优化 **重点*** pre-main 阶段：`二进制重排` * 尽量 `少用外部动态库`，苹果官方建议自定义的动态库最好 `不要超过6个`，如果超过6个，需要 `合并` 动态库 * 减少 `OC` 类，因为类越多，越耗时 * 将不必须在 `+load` 方法中做的事情延迟到 `+initialize` 中，尽量不要用 `C++` 虚函数* main 阶段：mian -&gt; didFinishLaunching * 减少启动初始化的流程，`能懒加载的懒加载，能延迟的延迟，能放后台初始化的放后台`，尽量少占用主线程的启动时间 * 优化代码逻辑，去除非必须的代码逻辑，减少每个流程的消耗时间 * 启动阶段能 `使用多线程` 来初始化的，就使用多线程 * 尽量 `使用纯代码` 来进行UI框架的搭建，尤其是主UI框架，例如 UITabBarController，尽量避免使用Xib或者SB，相比纯代码而言，这种更耗时 * 删除废弃类、方法 ## 卡顿监听 **重点****主要是用displayLink + Runloop进行FPS监测**主要从减轻 `CPU` 和 `GPU` 消耗入手，保证写一个 `VSync` 到来时，`CPU` 和 `GPU` 能够写作完成下一帧的渲染并缓存到帧缓冲区* 卡顿优化在 `CPU` 层面：1）尽量用轻量级的对象，比如 `用不到事件处理` 的地方，可以考虑使用 `CALayer` 取代 `UIView`2）不要频繁地调用 `UIView` 的相关属性，比如 `frame、bounds、transform` 等属性，尽量减少不必要的修改3）尽量 `提前计算好布局`，在有需要时一次性调整对应的属性，不要多次修改属性4）图片的 `size` 最好刚好跟 `UIImageView` 的 `size` 保持一致5）`控制`一下线程的最大并发数量6）尽量把 `耗时的操作放到子线程`：如text宽高获取等* 卡顿优化在 GPU层面：1）GPU能处理的 `最大纹理` 尺寸是 `4096x4096`，一旦超过这个尺寸，就会占用 `CPU` 资源进行处理，所以纹理尽量不要超过这个尺寸2）尽量 `减少视图数量和层次`3）`减少透明的视图`（alpha&lt;1），不透明的就设置 `opaque` 为 `YES`4）尽量 `避免出现离屏渲染`：圆角、阴影、遮罩等 ## 卡顿优化：tableView优化 **重点*** 最常用的就是`cell的复用`， 注册复用标识符* `避免cell的重新布局`，初始化时就布局好* `提前计算并缓存cell的高度`* `减少cell中控件的数量`，少动态添加 view* `避免背景透明`* 能`使用局部更新` 的就使用 `局部更新`* 加载网络数据，`下载图片，使用异步加载`，并缓存* `按需加载cell`：cell滚动很快时，只加载范围内的cell* `不要实现无用的代理方法`，tableView只遵守两个协议 # 网络优化 **重点*** DNS优化：即域名解析优化，缓存 ip* 资源优化： * 图片webp，比png/jpg小 * 数据传输用ProtocolBuffer代替json，数据小，序列化和反序列化也简单* 请求压缩、请求合并* 数据缓存* 网络环境监测 * 针对性请求重试## TCP三次握手，四次挥手过程？**重点**1. 为什么是三次握手，而不是二次握手？三次握手是为了建立一个可靠的数据传输通道：* 刚开始客户端和服务端处于关闭状态，而且服务端B一直处于监听状态，时刻监听是否有建立连接的请求* 当客户端需要建立连接的时候就会发送一个 `请求连接` 的报文，此报文是 `同步报文SYN=1`，并且会生成一个 `随机的序号seq=x`，这是第一次握手* 当服务端接收到请求连接报文时，会发送一个 `确认连接` 的报文，此报文是 `同步报文SYN=1`，并且 `确认报文ACK=1`，同时服务端也会生成一个 `随机的序号seq=y`，并且将 `确认报文确认号ack=x+1`，回传给客户端，这是第二次握手* 当客户端接收到服务端的 `ACK确认报文后`，会回复一个 `ACK确认报文`，用于确认确认报文已经收到，此报文 `ACK=1，seq=x+1，ack=y+1`，这是第三次握手2. 四次挥手四次挥手则是为了保证数据传输完成接收再关闭连接。* 客户端断开连接时会发送一个 `请求断开连接` 的报文，此报文是 `FIN=1`，并且会生成一个 `随机的序号seq=u`，发送给服务端，这是第一次挥手* 服务端接收到请求断开连接 `FIN报文` 后，回复一个 `确认断开连接` 报文 `ACK=1,seq=v,ack=u+1`，这是第二次挥手* 当服务端数据发送完后，再发送一个FIN报文给客户端，通知客户端，服务端准备关闭连接，此报文 `FIN=1,ACK=1,ack=u+1,seq=w`，这是第三次挥手* 当客户端收到 `FIN确认报文`，再发送一个FIN确认报文 `ACK=1,seq=u+1,ack=w+1`，并进入` TIME-WAIT` 等待，等待 `2MSL` 后关闭连接，这是第四次挥手 # 事件链 **重点**[OC学习01：事件传递链和响应链](https://www.bboyzj.cn/2023/03/01/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/)* 传递链：由系统向离用户最近的view传递。 顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; ViewController -&gt; subViews* 响应链：由离用户最近的view向系统传递。 顺序： superViews –&gt; ViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate# 事件传递的两个核心方法？ **重点** &#x2F;&#x2F; 返回最适合处理事件的视图 (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;&#x2F;&#x2F; 判断点是否在这个View内部 (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event; 1234567* 第一个方法返回的是一个 `UIView`，是用来寻找最终哪一个视图来响应这个事件* 第二个方法是用来判断某一个点击的位置是否在视图范围内，如果在就返回YES# 实现一个按钮的点击范围扩大效果 **重点**自定义一个按钮，继承UIButton，重写 `pointInside:withEvent:` 方法， (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{ &#x2F;&#x2F; 当前btn大小 CGRect btnBounds &#x3D; self.bounds; &#x2F;&#x2F; 扩大按钮的点击范围，增大内边距 btnBounds &#x3D; CGRectInset(btnBounds, -10, -10); &#x2F;&#x2F; 若点击的点在新的bounds里，返回YES return CGRectContainsPoint(btnBounds, point);} 12345# 子视图超过父视图部分仍然能响应 **重点**重写 `hitTest:withEvent` 方法，让 `子视图` 去相应事件 (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{ &#x2F;&#x2F; 判断btn能否接收事件 if (self.btn.userInteractionEnabled &#x3D;&#x3D; NO || self.btn.hidden &#x3D;&#x3D; YES || self.btn.alpha &lt;&#x3D; 0.01) { return nil; } &#x2F;&#x2F; 把当前点转换成btn坐标系上的点 CGPoint btnP &#x3D; [self convertPoint:point toView:self.btn]; &#x2F;&#x2F; 当触摸点在btn上时，才让按钮相应事件 if ([self.btn pointInside:btnP withEvent:event]) { NSLog(@”%@”,NSStringFromCGPoint(btnP)); return self.btn; } NSLog(@”父视图相应”); return [super hitTest:point withEvent:event];} &#96;&#96;&#96; 面试官问还有什么想问的？ 重点技术面不问薪资待遇，人事面问薪资待遇 问岗位： 在这个岗位上，会直接 接触到哪些类型的项目？ 这个岗位的主要职责是什么？主要的KPI是什么？ 这个岗位如何评估绩效，试用期需要达到什么指标？ 这个岗位的最大挑战是什么？ 问团队： 团队的基本情况？ 这个团队在公司的角色是什么？ 可以跟我介绍一下我的领导吗？ 问公司 公司的文化氛围是什么样的？ 员工的晋升机制是什么样的？我这个岗位的晋升机会如何？ 这个岗位所在的团队如何支持公司目标的实现？","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-面试题","slug":"OC-面试题","permalink":"https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"Blog-04：主题完善","slug":"Blog-04：主题完善","date":"2023-03-01T02:54:01.000Z","updated":"2023-03-01T17:50:03.426Z","comments":true,"path":"2023/03/01/Blog-04：主题完善/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog-04%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/","excerpt":"","text":"前言我们以 Snippet 主题问例 下载安装1mac@bogon Blog % $ git clone git://github.com/shenliyang/hexo-theme-snippet.git themes/hexo-theme-snippet 安装主题插件1mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S 部署主题具体部署看下面的链接：1、2、3步骤可省略 Snippet","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"Blog-03：Github域名绑定阿里云域名","slug":"Blog-03：Github域名绑定阿里云域名","date":"2023-03-01T02:17:25.000Z","updated":"2023-03-01T11:26:07.736Z","comments":true,"path":"2023/03/01/Blog-03：Github域名绑定阿里云域名/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog-03%EF%BC%9AGithub%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/","excerpt":"","text":"注册域名去 阿里云 注册账号、并购买域名，具体流程这里就不一一介绍了 域名解析 在终端 ping 一下之前配置的静态页面地址,可以获取到对应的ip地址: 123456mac@bogon ~ % ping BboyZJ.github.ioPING bboyzj.github.io (185.199.109.153): 56 data bytes64 bytes from 185.199.109.153: icmp_seq=0 ttl=50 time=261.217 ms64 bytes from 185.199.109.153: icmp_seq=1 ttl=50 time=337.547 ms64 bytes from 185.199.109.153: icmp_seq=2 ttl=50 time=260.716 ms... @解析 记录类型：A主机记录：@解析请求来源：默认记录值：185.199.109.153TTL：10分钟 点击确定 www解析 记录类型：CNAME主机记录：www解析线路来源：默认记录值：BboyZJ.github.ioTTL：10分钟 点击确定 配置项目 CNAME 在 Blog/source 目录下，新建 CNAME 文件，内容输入阿里云申请的域名 www.bboyzj.cn 12mac@bogon ~ % cd /Users/mac/Desktop/Blog/source mac@bogon source % touch CNAME 配置 Blog 目录下 _config.yml 文件，URL 模块 123456789# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://www.bboyzj.cnroot: /BboyZJ.github.io/permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks 执行 123mac@bogon ~ % hexo cleanmac@bogon ~ % hexo gmac@bogon ~ % hexo d 提交陈成功后，就可以在 GitHub 和 www.bboyzj.cn 个人域名绑定上了","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/tags/Blog/"}],"keywords":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Blog-02：部署博客到GitHub","slug":"Blog-02：部署博客到GitHub","date":"2023-03-01T01:12:01.000Z","updated":"2023-03-01T13:45:55.546Z","comments":true,"path":"2023/03/01/Blog-02：部署博客到GitHub/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog-02%EF%BC%9A%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0GitHub/","excerpt":"","text":"注册GitHub账号前往 Github 网站，注册一个新用户。用邮箱注册的一定前往邮箱去验证邮件。 部署到 GitHub 上 新建 reponsity 仓库 仓库名设置成 用户名.github.io ，比如我的是 BboyZJ.github.io，选择 Public，勾选 Add a README file ，最后 Create respository 配置秘钥 查看秘钥 123$ cd ~/.ssh$ ls$ cat id_rsa.pub 添加SSH秘钥：头像 -&gt; Setting -&gt; SSH and GPG keys Title 随意写，Key 需要填写刚才复制的 秘钥 文本内容 添加完成，验证链接 123mac@bogon ~ % ssh -T git@github.comHi BboyZJ! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 上传文件到 GitHub 配置 Blog 下 _config.yml 中的 Deployment 模块 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repository: https://github.com/BboyZJ/BboyZJ.github.io.git branch: master 安装部署插件 通过 Hexo 发布到 GitHub，需要安装部署插件 1mac@bogon ~ % npm install hexo-deployer-git --save 部署 123mac@bogon ~ % cd /Users/mac/Desktop/Blogmac@bogon ~ % hexo gmac@bogon ~ % hexo d 访问 这时我们的 GitHub 域名 https://BboyZJ.github.io 就可以看到 Hexo 网站了，如果没显示出来就 刷新 一下","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-02-28T23:51:10.086Z","updated":"2023-02-28T23:51:10.086Z","comments":true,"path":"2023/03/01/hello-world/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"Blog-01：Hexo个人博客搭建","slug":"Blog-01：Hexo个人博客搭建","date":"2023-02-28T23:39:40.000Z","updated":"2023-03-02T16:02:08.849Z","comments":true,"path":"2023/03/01/Blog-01：Hexo个人博客搭建/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog-01%EF%BC%9AHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Hexo 什么是Hexo？ 简介：Hexo 是一个快速、简洁且高效的博客框架。想要详细的了解 Hexo，去官网学习。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提 检查是否安装 homebrew 12345mac@bogon ~ % brew -vHomebrew 3.6.21-28-ge6548a8Homebrew/homebrew-core (git revision 5434c8344e8; last commit 2023-02-09)Homebrew/homebrew-cask (git revision 15c2c1fa53; last commit 2023-02-09)mac@bogon ~ % 如果顺利显示版本号，说明homebrew已经安装。否则，输入以下命令进行安装： 1mac@bogon ~ % ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装过程如果出现下面的问题 1curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused 解决: 1mac@bogon ~ % /usr/bin/ruby -e &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)&quot; 安装 Node.js 123mac@bogon ~ % brew install nodemac@bogon ~ % node -vv18.14.2 安装GitMac系统默认已经安装好了，所以不需要再安装 安装Hexo如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往安装 Hexo 步骤。 使用npm完成 hexo 安装 12345678910111213141516171819202122mac@bogon ~ % npm install -g hexo-climac@bogon ~ % hexo -vhexo-cli: 4.1.0os: Darwin 21.6.0 darwin x64node: 12.16.1v8: 7.8.279.23-node.31uv: 1.34.0zlib: 1.2.11brotli: 1.0.7ares: 1.15.0modules: 72nghttp2: 1.40.0napi: 5llhttp: 2.0.4http_parser: 2.9.3openssl: 1.1.1dcldr: 35.1icu: 64.2tz: 2019cunicode: 12.1mac@bogon ~ % 建站 桌面新建 Blog 文件夹，打开终端，cd到 Blog 下，执行: 123456789101112mac@bogon ~ % cd /Users/mac/Desktop/Blog mac@bogon Blog % hexo initINFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO Install dependenciesnpm notice npm notice New major version of npm available! 7.3.0 -&gt; 9.5.1npm notice Changelog: https://github.com/npm/cli/releases/tag/v9.5.1npm notice Run npm install -g npm@9.5.1 to update!npm notice INFO Start blogging with Hexo!mac@bogon Blog % 【目录文件】： _config.landscape.yml：网站本地配置信息_config.yml：网站的配置信息，可以在此配置大部分的参数source–posts：存放 md 文件themes：主题文件夹，常用主题 会放入这里public：Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 hexo 测试 生成静态页面 1mac@bogon Blog % hexo g 会在根目录 Blog\\ 下生成 public 文件夹，里面包含相应的 html 页面。 启动服务器 1mac@bogon Blog % hexo s 打开浏览器，输入网址: http://localhost:4000 ，即可看到hexo生成的静态页面。 停止服务器 Ctrl + C 主题hexo提供了很多主题可以参考，下面以 hexo-theme-casual 主题为例 安装主题插件 hexo-theme-redefine 1无 hexo-theme-casual 1mac@bogon Blog % $ npm install --save hexo-renderer-jade hexo-renderer-scss hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-generator-search hexo-theme-redefine 1mac@bogon Blog % $ npm install --save hexo-renderer-jade hexo-renderer-scss hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-generator-search hexo-theme-snippet 1mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S hexo-theme-butterfly 12mac@bogon Blog % $ git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterflymac@bogon Blog % $ npm install hexo-renderer-pug hexo-renderer-stylus 下载主题 进入主题的 github 下载页，点击 code -&gt; clone，复制 https 下载链接，进入 博库Blog目录，运行下面的命令： 123mac@bogon Blog % cd /Users/mac/Desktop/Blog mac@bogon Blog % cd themes mac@bogon themes % git clone https://github.com/littlewin-wang/hexo-theme-casual.git 【注】：主题存放的目录是 Blog/themes，为了方便管理，每一个下载的主题都建一个单独的目录，我这个主题的目录是 hexo-theme-casual，可以下载多个主题: 主题应用 找到 博客Blog 目录下的配置文件 _config.yml，找到 Extensions 模块，修改 theme 字段： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-casual 启动本地服务器 1234567891011mac@bogon Blog % hexo sINFO Validating configINFO Start processingINFO Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.[Browsersync] Access URLs: ---------------------------------- UI: http://localhost:3001 ---------------------------------- UI External: http://localhost:3001 ---------------------------------- 查看效果 通过 http://localhost:4000/ 查看修改后的效果 主题更新 这一步不是必须的，如果主题有优化，我们需要在本地同步更新一下 12mac@bogon Blog % /Users/mac/Desktop/Blog/themes/casual mac@bogon Blog % git pull 其他命令 清除旧的内容 hexo clean 生成静态发布页面 hexo g 发布页面 hexo d","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"Swift学习14：在Swift里如何处理算术结果溢出","slug":"Swift学习14：在Swift里如何处理算术结果溢出","date":"2023-02-22T17:31:22.000Z","updated":"2023-03-01T17:30:15.039Z","comments":true,"path":"2023/02/23/Swift学习14：在Swift里如何处理算术结果溢出/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A014%EF%BC%9A%E5%9C%A8Swift%E9%87%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%AE%97%E6%9C%AF%E7%BB%93%E6%9E%9C%E6%BA%A2%E5%87%BA/","excerpt":"","text":"溢出运算符 在默认情况下，当向一个整数赋超出它容量的值时，swift 会报错而不是生成一个无效的数，给我们操作过大或过小的数时提供了额外的安全性 同时提供三个算术溢出运算符来让系统支持整数溢出运算 溢出加法 &amp;+ 溢出减法 &amp;- 溢出乘法 &amp;* 值溢出 数值可以出现向上溢出或向下溢出 溢出也会发生在有符号整型数值上 对于无符号与有符号整型数值来说，当出现溢出时，它们会从数值所能容纳的最大数变成最小的数，同样的，当发生下溢时，它们会从所能容纳的最小数变成最大的数 代码示例 上溢出 下溢出","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习13：赋值和算术运算符","slug":"Swift学习13：赋值和算术运算符","date":"2023-02-22T17:30:48.000Z","updated":"2023-03-01T17:25:29.347Z","comments":true,"path":"2023/02/23/Swift学习13：赋值和算术运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A013%EF%BC%9A%E8%B5%8B%E5%80%BC%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"基本概念 一元运算符对一个目标进行操作。一元前缀运算符（如!b），一元后缀运算符（b!） 二元运算符对两个目标进行操作（a+b）同时因为它们出现在两个目标之间，所以是中缀 三元运算符操作三个目标，swift 语言也仅有一个 三元运算符，三元条件运算符（a?b:c） swift 运算符的改进 swift在支持 c 中的大多数标准运算符的同时也增加了一些排除常见代码错误的能力 赋值符号 = 不会返回值，以防止它被无用于等于符号 == 算术符号 +、-、*、/、% 以及其他可以监测并阻止值溢出，以避免你在操作比存储类型允许的范围更大或更小的数字时得到各种奇怪的结果 赋值运算符 赋值运算符将一个值赋值给另外一个值 如果赋值符号右侧是拥有多个值的元组，它的元素将会一次性地拆分成常量或者变量 Swift 的赋值符号自身不会返回值 算术运算符-标准运算符 标准算术运算符 + - * / 算术运算符同时也支持 String 的拼接 swift 算术运算符默认不允许值溢出 算术运算符 - 余数运算符 余数运算符 a%b 可以求出多少个 b 的倍数能够刚好放进 a 中并且返回剩下的值（就是我们所谓的余数） 当 a 是负数时也适用相同的方法来进行计算 当 b 为负数时它的正负号被忽略掉。这意味着 a%b 与 a%-b 能够获得相同的答案 12345678let c = 9 % 4print(c)let d = 9 % -4print(d)let e = -9 % 4print(e) 算术运算符 - 一元 数字值的正负号可以用前缀 - 来切换，我们称之为一元减号运算符 一元减号运算符 - 直接在要进行操作的值前边放置，不加任何空格 一元加号运算符 + 直接返回它操作的值，不会对其进行任何的修改","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习12：获取子串和字符串比较","slug":"Swift学习12：获取子串和字符串比较","date":"2023-02-21T18:59:39.000Z","updated":"2023-03-01T17:25:21.832Z","comments":true,"path":"2023/02/22/Swift学习12：获取子串和字符串比较/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A012%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AD%90%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/","excerpt":"","text":"子字符串 使用下标或者类似 prefix(_:) 的方法得到的子字符串是 Substring 类型 Substring 拥有 String 的大部分方法 Substring 可以转成 String 类型 1234let str = &quot;hello,world&quot;let index = str.firstIndex(of: &quot;,&quot;) ?? str.endIndexlet begin = str[..&lt;index]let new = String(begin) 子字符串重用一部分原字符串的内存 修改字符串或子字符串之前都不需要花费拷贝内存的代价 String 和 Substring 都遵循 StringProtocol 协议，也就是说它基本上都能很方便的兼容所有接受 StringProtocol 值的字符串操作函数 字符串的比较 字符串和字符相等性 == 和 != 前缀相等性 hasPrefis(_:) 后缀相等性 hasSubffix(_:) 12345var str1 = &quot;1&quot;var str2 = &quot;2&quot;print(str1 == str2)print(str1.hasPrefix(&quot;1&quot;))print(str2.hasSuffix(&quot;2&quot;))","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习11：索引访问和修改字符串","slug":"Swift学习11：索引访问和修改字符串","date":"2023-02-21T18:59:05.000Z","updated":"2023-03-01T17:18:31.138Z","comments":true,"path":"2023/02/22/Swift学习11：索引访问和修改字符串/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A011%EF%BC%9A%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串索引 每一个 String 值都有相关的索引类型，String.Index，他相当于每个 Character 在字符串中的位置 startIndex 属性来访问 String 中第一个 Character 的位置。endIndex 属性就是 String 中最后一个字符串的位置 endIndex 属性并不是字符串下标脚本的合法实际参数 如果 String 为空，则 startIndex 与 endIndex 相等 使用 index(before:) 和 index(after:) 方法来访问给定索引的前后 要访问给定索引更远的索引，你可以使用 index(_:offetBy:) 使用 indices 属性来访问字符串中每个字符的索引 123456var greeting = &quot;Hello, playground&quot;greeting[greeting.startIndex]greeting[greeting.index(before: greeting.endIndex)]greeting[greeting.index(after: greeting.startIndex)]let index = greeting.index(greeting.startIndex, offsetBy: 7)greeting[index] 插入 插入字符，使用 insert(_:at:) 方法 插入到另一个字符串的内容到特定的索引，使用 insert(contentsOf:at:) 方法 1234var str = &quot;hello&quot;str.insert(&quot;!&quot;, at: str.endIndex)str.insert(contentsOf: &quot; world&quot;, at: str.firstIndex(of: &quot;!&quot;)!)print(str) 删除 移除字符，使用 remove(at:) 方法 12var str = &quot;hello&quot;str.remove(at: str.index(before: str.endIndex)) 移除一小段特定范围的字符串，使用 removeSubrange(_:) 方法 123var str = &quot;hello&quot;let range = str.index(str.endIndex, offsetBy: -str.count)..&lt;str.endIndexstr.removeSubrange(range)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习10：字符串常见操作","slug":"Swift学习10：字符串常见操作","date":"2023-02-21T18:58:45.000Z","updated":"2023-03-01T17:15:30.150Z","comments":true,"path":"2023/02/22/Swift学习10：字符串常见操作/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A010%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/","excerpt":"","text":"字符串的可变性 var 指定的可以修改 let 指定的不可修改 对比 Object-C (NSString 和 NSMutableString) 字符串是 值类型 String 值在传递给方法或函数的时候会被复制过去 赋值给常量或变量的时候也是一样 Swift 编译器优化了字符串使用的资源，实际上拷贝只会在确实需要的时候才进行 123456var str1 = &quot;hello&quot;var str2 = str1print(str1 == str2)str1.append(&quot;,world&quot;)print(str1)print(str2) 操作字符 for in 循环遍历 String 中的每一个独立的 Character Character 类型 String 值可以通过传入 Character 数组来构造 1234var str = &quot;hello&quot;for c in str&#123; print(c)&#125; 字符串的拼接 使用加运算符 + 创建新字符串 使用 + 赋值符号 += 在已经存在的 String 值末尾追加一个 String 值 使用 String 类型的 append() 方法来可以给一个 String 变量的末尾追加 Character 值 字符串插值 字符串插值是一种从混合常量、变量、字面量和表达式的字符串字面量构造新 String 值的方法 每一个你插入到字符串字面量的元素都要被一对圆括号包裹，然后使用反斜杠前缀 \\() 类似于 NSString 的 stringWithFormat 方法，但是更加简便，更强大 可以在扩展字符串分割符中创建一个包含在其他情况下会被当做字符串插值的字符 要在使用扩展分隔符的字符串中使用字符串插值，在反斜杠后使用匹配首尾井号数量的井号 12let str = &quot;6 * 7 = \\(6 * 7)&quot;print(str)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习09：字符串创建和使用","slug":"Swift学习09：字符串创建和使用","date":"2023-02-21T18:58:24.000Z","updated":"2023-03-01T17:06:09.757Z","comments":true,"path":"2023/02/22/Swift学习09：字符串创建和使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A009%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"初始化空串 字面量 初始化器语法 isEmpty 检查是否为空串 123456var emptyString = &quot;&quot;var anotherEmptyString = String()if emptyString.isEmpty &#123; print(&quot;Nothing to see here&quot;)&#125; 字面量 字符串字面量是被双引号 “” 包裹的固定顺序文本字符 Swift 会为 str 常量推断类型为 String 1let str = &quot;some string&quot; 多行字面量 多行字符串字面量是用三个双引号引起来的一系列字符 多行字符串字面量把所有行包括在引号内，开始和结束默认不会有换行符 如果为了书写美观而不换行在后面加 \\ 12345678let someStr = &quot;&quot;&quot;1\\2\\345&quot;&quot;&quot;print(someStr) 要让多行字符串字面量起始或结束于换行，就在第一或最后一行写一个空行 多行字符串可以 缩进 以匹配周围的代码。双引号（”””）前的空格会告诉Swift其他行前应该有多少空白是需要忽略的 如果你在某行的空格超过了结束的双引号（”””），那么这些空格会被包含 12345678 let someStr = &quot;&quot;&quot; 1 2 3 4 5 &quot;&quot;&quot;print(someStr) 字符串里的特殊字符 转义特殊字符 \\o（空字符）,\\（反斜杠），\\t（水平制表符），\\n（换行符），\\r（回车符），\\”（双引号）以及 &#39;（单引号） 任意的 Unicode 标量，写作 \\u&#123;&#125;n，里边的 n 是一个 1-8 位的16进制数字，其值是合法 Unicode 值 1let str = &quot;\\u&#123;24&#125;&quot; 可以在多行字符串字面量中包含双引号（”）而不需要转义。要在多行字符串中包含文本 “”””””，转义至少一个双引号 扩展字符串分隔符(Raw String) 在字符串字面量中放置扩展分隔符来使 包含特殊字符的字符串 不让他们真的生效 把字符串放在双引号 (“) 内并由 (#) 包裹 12let str = #&quot;1\\n2\\n3\\n&quot;#print(str) 如果字符串里面有 &quot;# 则首尾需要两个 ## 12let str = ##&quot;1\\&quot;#n2\\#n3\\#n&quot;##print(str) 如果你需要字符串中某个特殊符号的效果，使用匹配你包裹的 # 号数量的 # 号，并在前面写转义符号 \\ 12let str = #&quot;1\\#n2\\#n3\\#n&quot;#print(str)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习08：Optional的使用Optional实现原理探索","slug":"Swift学习08：Optional的使用Optional实现原理探索","date":"2023-02-21T18:56:00.000Z","updated":"2023-03-01T17:03:15.837Z","comments":true,"path":"2023/02/22/Swift学习08：Optional的使用Optional实现原理探索/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A008%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8Optional%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"Optional-实现探究 Optional 其实是一个标准库里的一个 public 的 enum 类型，而且是 泛型 的，泛型的类型是 Wrapped 用标准库实现语言特性的典型 Optional.none 就是 nil Optional.some 则包装了实际的值 12345var str:Optional&lt;String&gt; = &quot;abc&quot;if let actualStr = str &#123; let count = actualStr.count print(count)&#125; Optional-解包实现 泛型属性 unsafelyUnwrapped 理论上我我们可以直接调用 unsafelyUnwrapped 获取可选项的值 123var str:String? = &quot;abc&quot;let count = str.unsafelyUnwrapped.countprint(count)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习07：Optional的使用","slug":"Swift学习07：Optional的使用","date":"2023-02-21T18:55:20.000Z","updated":"2023-03-01T16:54:26.902Z","comments":true,"path":"2023/02/22/Swift学习07：Optional的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A007%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"为什么需要 Optional？ Object-C 里的 nil 是无类型的指针 Object-C 里面的数组、字典、集合等不允许放入 nil Object-C 所有 对象的变量 都可以为 nil Object-C 只能用在对象上，而在其他地方又用其他特殊值（例如NSNotFound）表示值的缺失 Optional 通过在 变量类型 后面加 ? 表示 这里有一个值，它等于 x 或者 这里根本没有值 你可以通过给可选变量赋值一个 nil 来将之设置为没有值 在 Object-C 中 nil 是一个指向不存在对象的指针 在 Swift 中，nil 不是指针，它是 值缺失的一种特殊类型，任何类型的可选项都可以设置成 nil 而不仅仅是对象 只有可选项才能设置为 nil 12var str: String = nilvar str1: String? = nil Optional-If 语句以及强制解包 可选项是没法直接使用的 需要用 ! 号强制解包后才能使用（意思是我知道这个可选项里面有值，使用吧） 12var str: String? = &quot;abc&quot;let count = str.count 需要改成如下代码，才能正确执行 12var str: String? = &quot;abc&quot;let count = str!.count 或 1234var str: String? = &quot;abc&quot;if str != nil &#123; let count = str!.count&#125; Optional-绑定 可以使用 可选绑定 来判断可选项是否包含值，如果包含就把赋值给一个临时的 常量或变量 可选绑定可以与 if 和 while 的语句使用来检查可选项内部的值，并赋值给一个变量或常量 同一个 if 语句中包含多可选项绑定，用逗号分割即可。如果任一可选绑定结果是 nil 或者 布尔值 为 false ，那么整个 if 判断会被看做 false 12345var str:String? = &quot;abc&quot;if let actualStr = str &#123; let count = actualStr.count print(count)&#125; Optional - 隐士解包 有些可选项一旦被设定值之后，就会一直拥有值，在这种情况下，就可以去掉检查的需求，也不必每次访问的时候都进行解包 通过有声明的类型后边添加一个叹号（String!）而非问号（String?）来书写隐士解包可选项 123var str:String! = &quot;abc&quot;let count = str.countprint(count) 隐士解包可选项主要被用在Swift 类 的初始化过程中 Optional-可选链 可选项后面加问号 如果可选项不为nil，返回一个可选项结果，否则为nil 123var str:String? = &quot;abc&quot;let count = str?.countlet lastIndex = count - 1 将上面的代码改为： 1234567var str:String? = &quot;abc&quot;let count = str?.count//let lastIndex = count - 1if count != nil &#123; let lastIndex = count! - 1 print(lastIndex)&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习06：Tuple元组","slug":"Swift学习06：Tuple元组","date":"2023-02-21T18:54:43.000Z","updated":"2023-03-01T16:48:14.682Z","comments":true,"path":"2023/02/22/Swift学习06：Tuple元组/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A006%EF%BC%9ATuple%E5%85%83%E7%BB%84/","excerpt":"","text":"Tuple 元组 把多个值合并成单一的复合型的值 元组 内的值可以是任何类型，而且可以不必是统一类型 123let error = (1,&quot;没有权限&quot;)print(error.0)print(error.1) 元素命名 元组中的每一个元素可以指定对应的元素名称 123let error = (errorCode:1,errorMessage:&quot;没有权限&quot;)print(error.errorCode)print(error.errorMessage) 如果没有指定名称的元素也可以使用下标的方式来引用 123let error = (1,&quot;没有权限&quot;)print(error.0)print(error.1) Tuple 修改 用 var 定义的元组就是可变元组，let 定义的元组就是不可变元组 不管是可变还是不可变元组，元组在创建后就不能增加和删除元素 可以对可变元组的元素进行修改，但是不能改变其类型 123var error = (errorCode:1,errorMessage:&quot;没有权限&quot;)error.errorCode = 2error.errorMessage = &quot;2&quot; any 类型可以改为任何类型 12345var error: (Any,String) = (1,&quot;没有权限&quot;)error.0 = 2print(error)error.0 = &quot;abc&quot;print(error) Tuple 分解 将一个元组的内容分解成单独的常量或变量 1234let error = (1,&quot;没有权限&quot;)let (errorCode,errorMessage) = errorprint(errorCode)print(errorMessage) 如果只需要使用其中的一部分数据，不需要的数据可以用下划线 _ 代替 123let error = (1,&quot;没有权限&quot;)let (_,errorMessage) = errorprint(errorMessage) 作为函数返回值 使用 Tuple 为函数返回多个值 返回值的 Tuple 可以再函数的返回类型部分被命名 12345func writeToFile(content:String) -&gt; (errorCode:Int,errorMessage:String) &#123; return (1,&quot;没有权限&quot;)&#125;let error = writeToFile(content: &quot;&quot;)print(error)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习05：数值类型","slug":"Swift学习05：数值类型","date":"2023-02-21T18:53:56.000Z","updated":"2023-03-01T16:43:16.134Z","comments":true,"path":"2023/02/22/Swift学习05：数值类型/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A005%EF%BC%9A%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"整数 Swift 提供了 8，16，32，64 位编码的有符号和无符号整数 命名方式：例如 8位无符号整数的类型是 UInt8，32位有符号整数的类型是 Int32 通过 min 和 max 属性来访问每个整数类型的最小值和最大值 Swift 提供了一个额外的整数类型：Int，它拥有与当前平台的原生字相同的长度 同时 Swift 也提供 UInt 类型，来表示平台长度相关的无符号整型 建议在用到证书的地方都使用 Int 浮点类型 Double：64位浮点数，至少有 15 位数字的精度 Float：32位浮点数，至少有 6 为数字的精度 在两种类型都可以的情况下，推荐使用 Double 类型 数值范围 123let a = 8let b: UInt8 = 240print(&quot;UInt8 min \\(UInt8.min),UInt8 max \\(UInt8.max)&quot;) Bool Bool：true 和 false Swift 的类型安全机制会阻止你用一个非布尔量的值替换掉 Bool 1234let i = 1if i &#123; print(i)&#125; 我们修改一下 类型别名 类型别名是一个为 已存在类型 定义的一个 可选择的名字 你可以用关键字 typealias 定义一个类型的别名 当你想通过在一个在上下文中看起来更合适可具有表达行的名字来引用一个已存在的类型时，这时别名就非常有用了 123// 音频采样率typealias AudioSample = UInt8let sample:AudioSample = 32","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习04：变量和常量","slug":"Swift学习04：变量和常量","date":"2023-02-21T18:12:27.000Z","updated":"2023-03-01T16:40:54.558Z","comments":true,"path":"2023/02/22/Swift学习04：变量和常量/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A004%EF%BC%9A%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/","excerpt":"","text":"声明变量和常量 使用关键字 let 声明常量 12let a = 1a = 2 由于 x 是常量，不能给常量赋值，会报错 使用关键字 var 声明变量 12var b = 1b = 2 可以在一行中声明多个变量和常量，用逗号分割 1var x = 0.0,y = 1.0,z = 2.0 类型标注 在声明一个变量或常量时提供类型标注，来明确变量或常量能够存储值的类型 添加 类型标注 的方法是在 变量或常量 的名字后面加一个 冒号，再跟一个 空格，最后加上使用的 类型名称 可以在一行中定义多个相关的变量为相同的类型，用 逗号 分割，只要在最后的变量名字后加上类型标注 123var a: Stringa = &quot;hello&quot;a = 10 常量和变量命名 常量和变量的名字几乎可以使用任何字符，甚至包括 Unicode 字符 常量和变量的名字不能包含 空白字符、数学符号、箭头、保留的（或者无效的）Unicode码位、连线和制表符。也不能以 数字 开头，尽管数字几乎可以使用在名字其他的任何地方 123let π = 3.1415let 你好 = &quot;你好世界&quot;let 🐶🐂 = &quot;dog,cow&quot; 打印常量和变量 print(_:separator:teminator) 字符串插入 用 \\() 来插入 123456let π = 3.1415let 你好 = &quot;你好世界&quot;let 🐶🐂 = &quot;dog,cow&quot;print(π)print(&quot;\\(你好)&quot;)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习03：Playgorund使用","slug":"Swift学习03：Playground使用","date":"2023-02-21T16:41:59.000Z","updated":"2023-03-01T16:37:15.616Z","comments":true,"path":"2023/02/22/Swift学习03：Playground使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A003%EF%BC%9APlayground%E4%BD%BF%E7%94%A8/","excerpt":"","text":"简介 Swift 的 Playgorund 是为了让人人都能愉快的学习 swift 编程 但发展至今，这个工具越来越强大 Playgorund 使用 创建一个 Playgorund 应用 Next，默认名 MyPlayground 可以通过 New -&gt; Playground Page 创建多个 Playground 来学习 注：快捷键 command + option + n 创建 Playground Page command + shift + enter 快速运行程序 简单使用 写一个求和的函数 12345678// 求和函数func sum(a:Int,b:Int) -&gt; Int &#123; return a+b&#125;// 调用求和函数 赋值给 常量 clet c = sum(a: 1, b: 2)// 打印常量 cprint(c)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习02：REPL交互式解释器","slug":"Swift学习02：REPL交互式解释器","date":"2023-02-21T16:41:38.000Z","updated":"2023-03-01T17:50:48.372Z","comments":true,"path":"2023/02/22/Swift学习02：REPL交互式解释器/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A002%EF%BC%9AREPL%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%99%A8/","excerpt":"","text":"介绍 xcode 6.1 引进了另外一种以交互式的方式来体验 Swift 的方法 Read Eval PrintLoop，简称REPL 使用REPL 除了可以 定义常量和变量 外，还是可 定义函数 打开终端输入 12mac@bogon ~ % swiftmac@bogon ~ % swift repl 定义变量 定义函数 REPL 其他命令 退出：:quit 帮助：:help 将光标移动到当前行的开始处：Control + A 将光标移动到当前行的结束处：Control + E","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习01：Swift编译流程","slug":"Swift学习01：Swift编译过程","date":"2023-02-21T15:49:55.000Z","updated":"2023-03-01T17:50:40.800Z","comments":true,"path":"2023/02/21/Swift学习01：Swift编译过程/","link":"","permalink":"https://www.bboyzj.cn/2023/02/21/Swift%E5%AD%A6%E4%B9%A001%EF%BC%9ASwift%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","excerpt":"","text":"编译器架构Swift编译过程和OC基本类似，仅仅是前端编译器不一样。 OC/C 前端编译器是 Clang Swift 先解析成 Swift AST（抽象语法树），通过 swiftc 这个命令行参数，编译成 Swift IL OC 和 Swift 最后均编译成 LLVM IR 中间层表示 OC 和 Swift 最终通过 后端编译器 LLVM compiler ，编译成最终的在具体地址上可以执行的二进制，包括x86、arm和other 详细编译流程 Swift 先解析成 AST（抽象语法树） 经过一系列工具编程 Swift 的 SIL(中间语言) 再经过 分析、IR工具 转成 LLVM IR(中间表示层) 最终通过 后端编译器 LLVM compiler 编译成 .o 目标文件 命令行流程使用终端创建一个简单的 main.swift 文件 12mac@bogon ~ % cd Desktopmac@bogon Desktop % touch main.swift 此时你可以在桌面看到一个 main.swift 文件 在该文件下写下两个数相加的一个函数 123456func sum(a:Int,b:Int) -&gt; Int &#123; return a + b&#125;let value = sum(a: 1, b: 2)print(value) 打开命令行工具 mac@bogon ~ % cd Desktop 生成 AST 抽象语法树 mac@bogon ~ % swiftc main.swift -dump-ast 生成 SIL 中间语言 mac@bogon ~ % swiftc main.swift -emit-sil 生成 LLVM IR 中间表示层 mac@bogon ~ % swiftc main.swift -emit-ir 生成 Assembly Language 汇编语言 mac@bogon ~ % swiftc main.swift -emit-assembly 生成二进制文件 mac@bogon ~ % swiftc -o main.out main.swift 命令行输入： 1234mac@bogon ~ % cd /Users/mac/Desktop/01swift编译流程 mac@bogon 01swift编译流程 % swiftc -o main.out main.swiftmac@bogon 01swift编译流程 % ./main.out3","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习00：简介","slug":"Swift学习00：简介","date":"2020-08-22T13:17:43.000Z","updated":"2023-03-01T17:50:37.544Z","comments":true,"path":"2020/08/22/Swift学习00：简介/","link":"","permalink":"https://www.bboyzj.cn/2020/08/22/Swift%E5%AD%A6%E4%B9%A000%EF%BC%9A%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Swift介绍Swift是Apple在2014年6月WWDC发布的全新的编程语言。 Swift是一种高性能系统编程语言，提供了对现有C和OC代码框架的无缝访问，并且是内存安全的。 Swift语言更加简洁，是一门类型安全的语言。 Swift和OC的区别 编程范式 Swift可以 面试协议编程、函数式编程和面向对象编程 OC以 面向对象编程 为主，当然你可以引入 Reactive Cocoa 的类库来进行函数式编程 类型安全 Swift是一门 类型安全的语言。鼓励程序员在代码中清楚明确值的类型。如果代码中使用一个字符串String，那么你不能错误地传递一个整型Int给它。因为Swift是类型安全的，它会在代码编译的时候做类型检查，并且把所有不匹配的类型作为一个错误标记出来。这样使得程序员在开发中尽可能早地发现和修正错误。 而OC则 不是类型安全的语言，你声明一个NSString变量，仍然可以传递一个NSNumber给它，尽管编译器会抱怨，但是你仍然可以作为NSNumber来使用它。 值类型的增强 在Swift中，典型的有 struct、enum 以及 元祖tuple 都是值类型。而平时使用的Int、Double、Float 、String 、Array 、Dictionary、Set其实都是用结构体实现的，也是 值类型。 OC中，NSNumber、NSString以及集合类对象都是指针类型。 枚举增强 Swift的枚举可以使用 整型、浮点型、字符串等，还能拥有 属性和方法，甚至支持 泛型、协议、扩展等。 OC里面的枚举则鸡肋很多。 泛型 Swift中 支持泛型，也支持泛型的类型约束等特性 苹果推出了Swift2.0版本，为了让开发者从OC更好的国度到Swift上，苹果也为OC带来了Gennerics泛型支持，不过OC的泛型约束也仅停留在编译器警告阶段。 协议和扩展 Swift对协议的支持更加丰富，配合扩展（extension）、泛型、关联类型等可以实现面向协议编程，从而大大提高代码的灵活性。同时swift中的protocol还可以用于值类型，如结构体和枚举 OC的协议却反强约束，提供optional特性往往成为很多问题得来源，而如果放弃optional又会让实现代价过大。 函数和闭包 Swift函数是一等公民，可以直接定义函数类型变量，可以作为其他函数参数传递，可以作为函数的返回值类型。 OC里面函数仍然是次等公民，需要selector封装或者使用block才能模拟Swift中类似的效果。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]}]}