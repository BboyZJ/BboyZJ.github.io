{"meta":{"title":"张建的博客","subtitle":"成功的道路上只有荆棘，没有坦途","description":"我是小J，关注我","author":"小J","url":"https://www.bboyzj.cn"},"pages":[{"title":"tags","date":"2023-03-01T03:07:03.000Z","updated":"2023-03-01T03:07:47.616Z","comments":true,"path":"tags/index.html","permalink":"https://www.bboyzj.cn/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-03-01T04:01:29.000Z","updated":"2023-03-01T04:01:29.226Z","comments":true,"path":"categories/index.html","permalink":"https://www.bboyzj.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Blog-04：Picgo+Gitee图床","slug":"Blog-04：Picgo-Gitee图床","date":"2023-03-01T11:25:22.000Z","updated":"2023-03-01T16:16:05.484Z","comments":true,"path":"2023/03/01/Blog-04：Picgo-Gitee图床/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog-04%EF%BC%9APicgo-Gitee%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"背景最近发现上传到 GitHub 上的图片大部分不能使用了，然后上网查了一下，应该是 DNS 的问题，网上也有很多解决方案，有兴趣的可以去网上找找，本文主要介绍 Picgo + Gitee 做图床。 Picgo 介绍picgo 是一款功能实用、操作简捷的图床工具，图床工具简单来说就是本地图片上传自动转换成链接的一款工具。 picgo 本体支持如下图床： 七牛图床 v1.0 腾讯云 COS v4\\v5 版本 v1.1 &amp; v1.5.0 又拍云 v1.2.0 GitHub v1.5.0 SM.MS V2 v2.3.0-beta.0 阿里云 OSS v1.6.0 Imgur v1.6.0 Tips: 本体不再增加默认的图床支持。你可以自行开发第三方图床插件。 特色功能 支持拖拽图片上传 支持快捷键上传剪贴板里第一张图片 Windows 和 macOS 支持右键图片文件通过菜单上传 (v2.1.0+) 上传图片后自动复制链接到剪贴板 支持自定义复制到剪贴板的链接格式 支持修改快捷键，默认快速上传快捷键：command+shift+p（macOS） | control+shift+p（Windows\\Linux） 支持插件系统，已有插件支持 Gitee、青云等第三方图床 Tips: 请确保你安装了 Node.js， 并且版本 &gt;&#x3D; 8。 默认上传图床为 SM.MS。picgo 上传之后，会自动将上传成功的 URL复制到你的剪贴板，支持5种复制格式。 Mini窗口只支持Windows（圆形）和Linux（方形），macOS可以使用顶部栏图标。（因为Windows和Linux的任务栏不支持拖拽事件） 准备 nodejs 环境 picgo 客户端 picgo 的 Gitee 上传插件 git、Gitee 账号和一个公开仓库 安装 nodejs官网 安装 点击链接下载安装 nodejs，安装完成后，查看版本 12345mac@bogon ~ % node -vv18.14.2mac@bogon ~ % npm -vmac@bogon ~ % npm -v9.5.0 安装 picgo 客户端 picgo安装链接 如果电脑是 Intel 就选 x64，如果电脑是 M1 就选 arm64 安装 git Mac 默认是已经安装好了 git 注册&#x2F;登录 Gitee 账号 Gitee 首页按要求自行注册&#x2F;登录即可 新建一个 Gitee 仓库 仓库名：随意，如 Picgo私有创建 将仓库 开源 由于创建仓库的时候只能 私有，所以此步配置 开源 操作如下： 进入仓库 -&gt; 管理 -&gt; 基本信息 -&gt; 开源（空仓库不允许） -&gt; 保存 生成 Token Token 用于 picgo 操作 Gitee repository： 点击头像 -&gt; 设置 -&gt; 私人令牌 -&gt; 生成新令牌 -&gt; 提交 复制你生成的令牌，只显示一次，再次刷新则看不见了，因此你要保存好 配置 picgo 启动 picgo -&gt; 插件设置 -&gt; 搜索 Gitee -&gt; 点击插件图标 安装 即可，本文使用 gitee 2.0.5 插件来进行演示 Tips： 插件装完后，重启生效 配置 Gitee 插件进入 图床设置 -&gt; gitee， 依次填入相关配置如下所示，填写如下： repo： 用户名&#x2F;仓库名（必填）， bboy-zhang-jian/picgo path: 上传路径，仓库里的图片保存路径（非必填） token: 私人令牌（必填），刚才保存的 token message: 提交消息（非必填） path: 上传路径，仓库里的图片保存路径（非必填） customPath: 定制路径（非必填） customUrl: 图片定制URL（非必填） 将仓库开源头像 -&gt; 仓库 -&gt; 管理 -&gt; 公开 -&gt; 仓库公开须知全部 勾选 上传图片 将图片拖动到 上传区 里 快捷键 Ctrl + shift + p 出现 Error: Cannot find module ‘node-sass’1mac@bogon Blog % npm install node -sass -save 不用管了，版本不一致导致的","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"OC学习01：事件传递链和响应链","slug":"OC学习01：事件传递链和响应链","date":"2023-03-01T09:30:34.000Z","updated":"2023-03-01T10:40:20.250Z","comments":true,"path":"2023/03/01/OC学习01：事件传递链和响应链/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/","excerpt":"","text":"前言在 iOS 中只有继承 UIResponder 的 对象 才能够接收并处理事件，UIResponder 是所有响应对象的 基类。继承关系如下： UIApplication -&gt; UIResponder -&gt; NSObject UIViewController -&gt; UIResponder -&gt; NSObject UIWindow -&gt; UIViww -&gt; UIResponder -&gt; NSObject UIButton -&gt; UIControl -&gt; UIView -&gt; UIResponder -&gt; NSObject UIView -&gt; UIResponder -&gt; NSObject 事件链 响应链：由离用户最近的view向系统传递。顺序： superViews –&gt; RootViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate 传递链：由系统向离用户最近的view传递。顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; RootViewController -&gt; subViews 传递链 事件传递的两个核心方法 1234// 返回哪个视图进行事件响应- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event; // 判断某一个点击的位置是否在视图范围内- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event; 其中 UIView 不接受事件处理的情况有 hidden &#x3D; YES 视图被隐藏 userInteractionEnabled &#x3D; NO 不接受响应事件 alpha &lt;&#x3D; 0.01,透明视图不接收响应事件 子视图超出父视图范围 需响应视图被其他视图盖住 是否重写了其父视图以及自身的hitTest方法 是否重写了其父视图以及自身的pointInside方法 流程描述 当iOS程序发生触摸事件后，系统会利用 Runloop 将事件加入到 UIApplication 的任务队列中 UIApplication 分发触摸事件到 UIWindow 然后 UIWindow 依次向下分发给 UIView UIView 调用 hitTest:withEvent: 方法返回一个最终响应的视图 在 hitTest:withEvent: 方法中就会去调用 pointInside: withEvent: 去判断当前点击的 point 是否在 UIView 范围内，如果是的话，就会去 逆序遍历 它的子视图来查找最终响应的 子视图 遍历的方式是使用 倒序 的方式来遍历子视图，也就是说最后添加的子视图会最先遍历，在每一个视图中都会去调用它的 hitTest:withEvent: 方法，可以理解为是一个 递归调用 最终会返回一个响应视图，如果返回视图有值，那么这个视图就作为最终响应视图，结束整个事件传递；如果没有值，那么就会将UIView作为响应者 响应链响应者链的事件传递过程 如果 view 的控制器存在，就传递给控制器处理；如果控制器不存在，则传递给它的 父视图 在视图层次结构的最顶层，如果也不能处理收到的事件，则将事件传递给 UIWindow 对象进行处理 如果 UIWindow 对象也不处理，则将事件传递给 UIApplication 对象 如果 UIApplication 也不能处理该事件，则将该事件丢弃 面试题 实现一个按钮的点击范围扩大效果 思路：自定义一个按钮，重写 poinstInSide 方法，增大内边距，返回一个新的bounds 1234567891011#import &quot;ZJBtn.h&quot;@implementation ZJBtn- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; // 当前btn大小 CGRect btnBounds = self.bounds; // 扩大按钮的点击范围，增大内边距 btnBounds = CGRectInset(btnBounds, -50, -50); // 若点击的点在新的bounds里，返回YES return CGRectContainsPoint(btnBounds, point);&#125;@end 子视图超过父视图部分仍然能响应 思路：正常情况下子视图超出部分是不能响应事件的，需重写 hitTest:withEvent 方法，指定 子视图 可点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#import &quot;VA.h&quot;@interface VA ()@property (nonatomic,strong)UIButton * btn;@end@implementation VA- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; [self addSubview:self.btn]; &#125; return self;&#125;- (void)clickBtn&#123; NSLog(@&quot;%s&quot;,__func__);&#125;- (UIButton *)btn&#123; if (!_btn) &#123; _btn = [[UIButton alloc] initWithFrame:CGRectMake(-50, 20, self.frame.size.width + 100, 100)]; _btn.backgroundColor = [UIColor blueColor]; [_btn addTarget:self action:@selector(clickBtn) forControlEvents:UIControlEventTouchUpInside]; &#125; return _btn;&#125;/* 子视图超过父视图部分，需要点击超出范围的部分也有相应 */- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // 判断btn能否接收事件 if (self.btn.userInteractionEnabled == NO || self.btn.hidden == YES || self.btn.alpha &lt;= 0.01) &#123; return nil; &#125; // 把当前点转换成btn坐标系上的点 CGPoint btnP = [self convertPoint:point toView:self.btn]; // 当触摸点在btn上时，才让按钮相应事件 if ([self.btn pointInside:btnP withEvent:event]) &#123; NSLog(@&quot;%@&quot;,NSStringFromCGPoint(btnP)); return self.btn; &#125; NSLog(@&quot;父视图相应&quot;); return [super hitTest:point withEvent:event];&#125;@end","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"iOS面试题：Swift","slug":"iOS面试题：Swift","date":"2023-03-01T08:57:50.000Z","updated":"2023-03-01T17:19:07.358Z","comments":true,"path":"2023/03/01/iOS面试题：Swift/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASwift/","excerpt":"","text":"swift 和 oc 的区别？ swift 是静态语言，有类型判断。OC 是动态语言。 swift可以面向 函数、协议、对象 编程；oc以面向 对象 编程为主，可以引入 Reactive Cocoa类库 来进行函数式编程 Swift 是类型安全的语言。OC 不是类型安全的语言。 Swift 大部分都是 值类型。OC 有的是 值类型，有的是 指针类型。 swift类型？Swiift 值类型 和 引用类型的区别？特点？ swift的类型分为 值类型 和 引用类型。 值类型：在swift中定义的很多类型都是值类型：如struct、enum、Int、Bool、String、Array、Dictionary、String等都是值类型。 class 为引用类型 区别 值类型：即每个实例只保存一份数据拷贝 引用类型：即每个实例共享一份数据拷贝 特点 值类型：传递和赋值时进行复制，即新对象和源对象独立，当改变新对象属性时，源对象不会受到影响 引用类型：新对象属性改变时，源对象也改变","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-面试题","slug":"Swift-面试题","permalink":"https://www.bboyzj.cn/tags/Swift-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"iOS面试题：OC","slug":"iOS面试题：OC","date":"2023-03-01T08:57:33.000Z","updated":"2023-03-01T10:58:01.183Z","comments":true,"path":"2023/03/01/iOS面试题：OC/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AOC/","excerpt":"","text":"OC算法1. 冒泡排序1）依次比较相邻两个元素，顺序错误则交换位置；需要两层循环，外层循环控制趟数，内层循环控制比较次数 2）例子： 123456789101112NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;5&quot;,@&quot;4&quot;]]; // 外循环控制排序趟数,进行 array.count-1 趟 for (int i = 0; i &lt; arr.count; i ++) &#123; // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序 for (int j = 0; j &lt; arr.count - i - 1; j++) &#123; // 相邻元素比较，若逆序则交换 if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123; [arr exchangeObjectAtIndex:j withObjectAtIndex:j + 1]; &#125; &#125; &#125; 2. 选择排序1）从第一个元素与其他元素比较找到最小值，重复操作，直到最后一位结束；需要两层循环，外层循环趟数，里层循环比较次数 2）例子 1234567891011NSMutableArray * arr = [NSMutableArray arrayWithObjects:@&quot;2&quot;,@&quot;1&quot;,@&quot;5&quot;,@&quot;3&quot;, nil];// 外循环控制排序趟数,进行 array.count-1 趟for (int i = 0; i &lt; arr.count; i ++) &#123; // 里循环获比较换位 for (int j = i + 1; j &lt; arr.count; j ++) &#123; if ([arr[i] intValue] &gt; [arr[j] intValue]) &#123; [arr exchangeObjectAtIndex:i withObjectAtIndex:j]; &#125; &#125;&#125;NSLog(@&quot;arr:%@&quot;,arr); 3. 直接插入排序1） 始终定义第一个元素为 已排序 的，将剩余元素定义为 未排序 逐个插入到 已排序 的排列中；不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去 2）例子 12345678910111213141516171819NSMutableArray * arr = @[@2,@1,@3,@5,@4].mutableCopy;// 插入排序的原理：始终定义第一个元素为有序的，将元素逐个插入到有序的排列中// 其特点是：不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去for(int i = 0;i &lt; arr.count;i++)&#123; // 待排序值 NSNumber * temp = arr[i]; // 已排序下标 int j = i - 1; // 待排序与已排序比较，从后向前比较 while (j &gt;= 0 &amp;&amp; [arr[j] integerValue] &gt; [temp integerValue]) &#123; // 如果已排序的 &gt; 待排序的 往后移动一个位置 [arr replaceObjectAtIndex:(j + 1) withObject:arr[j]]; j --; &#125; // 空出来的位置插入新元素 [arr replaceObjectAtIndex:(j + 1) withObject:temp]; NSLog(@&quot;arr:%@&quot;,arr);&#125; 打印结果： 12345672022-12-13 10:26:19.242271+0800 插入排序[4184:77845] arr:( 1, 2, 3, 4, 5) 4. 希尔排序1）希尔排序相当于 直接插入排序加强版，引入了 增量 的概念；直到增量为 1 时，再进行直接插入排序 2）例子 1234567891011121314151617181920212223NSMutableArray * arr = @[@7,@3,@8,@5,@2,@6,@1,@4].mutableCopy;// 其实间隔值设值为总数的一半int gap = arr.count/2;// 直到间隔小于1时结束while (gap &gt;= 1) &#123; // i 待排元素，以 步距 gap 从后向前扫描 for(int i = 0;i &lt; arr.count;i++)&#123; // 待排元素 NSNumber * temp = arr[i]; // 当前位置 int j = i; // 跳跃式比较 while (j &gt;= gap &amp;&amp; [arr[j - gap] integerValue] &gt; [temp integerValue] ) &#123; [arr replaceObjectAtIndex:j withObject:arr[j - gap]]; j -= gap; &#125; // 空出来位置，插入待排序 [arr replaceObjectAtIndex:j withObject:temp]; &#125; // 改变步长 gap = gap/2;&#125;NSLog(@&quot;arr:%@&quot;,arr); 打印结果： 123456789102022-12-13 10:22:41.910840+0800 插入排序[4124:74568] arr:( 1, 2, 3, 4, 5, 6, 7, 8) 5. 斐波那契数列1）也就是 兔子数列，当前数是前两个数列之和 2）例子 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; NSInteger num = 10; NSInteger total = [self getTotalNum:num]; NSLog(@&quot;total:%ld&quot;,total);&#125;- (NSInteger)getTotalNum:(NSInteger)num&#123; if(num == 0)&#123; return 0; &#125; if(num == 1)&#123; return 1; &#125; return [self getTotalNum:num-2] + [self getTotalNum:num-1];&#125; 打印结果： 12022-12-13 10:28:32.672554+0800 斐波那契数列[4285:80606] total:89 6. 二分查找1）有序的数组，将数组分割成两份，利用查找的值跟中间值进行比较，如果查找的值大于中间值，就在数组的右边进行查找；如果查找的值小于中间值，就在数组的左边进行查找。如此循环的执行下去，最终找到符合的值。 2）例子 123456789101112131415161718192021222324NSArray * arr = @[@(1),@(3),@(5),@(6),@(8),@(10)];int key = [@(5) intValue];int min = 0;int max = arr.count - 1;int mid;while (min &lt;= max) &#123; // 计算中间下标 mid = (min + max) / 2; // 如果目标值 &gt; 中间下标的中间值 if (key &gt; [arr[mid] intValue]) &#123; //最小变为中间下标+1 min = mid + 1; &#125; // 如果目标值 &lt; 中间下标的中间值 else if (key &lt; [arr[mid] intValue])&#123; //最大变为中间下标-1 max = max - 1; &#125; // 否则，正好 else &#123; NSLog(@&quot;key:%d&quot;,mid); break; &#125;&#125; 打印结果： 12022-12-13 10:33:18.661324+0800 二分查找[4607:86953] key:2 7. 递归算法递归求和1+2+..+n? 1234567891011121314- (void)viewDidLoad &#123; [super viewDidLoad]; int sum = [self sum:4]; NSLog(@&quot;sum:%d&quot;,sum);&#125;- (int)sum:(int)n&#123; if (n == 1) &#123; return 1; &#125;else &#123; return [self sum:n-1] + n; &#125;&#125; 链表OC数据结构01：链表的探索 二叉树OC数据结构02：二叉树探索 OC常见的面试题什么是野指针？是一个没有指向 任何内存 的指针，尝试使用它会导致 应用程序崩溃 什么是内存泄漏？一个 对象 没有被释放，会 内存泄漏，内存泄漏会导致应用程序占用的内存会越来越大，直到应用程序无内存可用时，会导致 应用程序崩溃 iOS 关键词有哪些？各有什么作用？ 重点 readwrite 可读可写 特性，同时生成get方法和set方法的声明和实现 readonly 只读 特性，只会生成get方法的声明和实现，不希望属性在类外改变 retain 持有 特性，retaincount 会 +1,用于 MRC nonatomic 非原子 特性 atomic 原子 特性，默认属性 atomic不是绝对线程安全的，只是对 setter/getter 方法使用了 自旋锁(spinlock_t)，内部使用 互斥锁(os_unfair_lock)，保证了 读/写 安全。 atomic并不能保证 整个对象 是线程安全的，需要对 整个对象 进行 加锁 来保证线程安全： * NSLock（互斥锁） * dispathch_semaphore（信号量） * @synchronized（互斥递归锁） assign 可以修饰 基本数据类型和对象。 通常用于修饰 基本数据类型，如Int、CGFloat、Double等，这是因为 基本数据类型放在栈区，栈由编译器自动分配和释放内存，栈先进后出，基本数据类型出栈后，assign修饰的基本数据类型就不存在了，不会出现 野指针 修饰对象，如NSString、实例对象等，引用计数不会增加，但 assign 修饰对象释放后，指针 不会被系统置为nil，会产生 野指针 或 EXC_BAD_ACCESS 错误。 strong 强引用，只修饰对象，属性默认修饰符 指向并持有该对象，其修饰的对象引用计数会 +1，引用计数不为 0 则不会被销毁，需要将其置为 nil 可以销毁。否则会出现 内存泄漏。 weak 弱引用，只修饰对象。 指向但并不拥有该对象，引用计数不增加。该对象自动在内存中销毁。 copy 用于修饰 不可变的对象。 比如NSString、NSDictionary、NSArray等。 浅拷贝和深拷贝 重点 浅拷贝 浅拷贝，拷贝了一个新的指针，与原对象指针指向同一块内存，引用计数 + 1；(A,CopyA &#x3D; [A copy]，A 变化，CopyA 的值也变化) 深拷贝 深拷贝，拷贝了一个新的对象，指向新的内存，新对象的 引用计数为 1，源对象引用计数不变；(A,MutableA &#x3D; [A mutbleCopy]，A 变化，MutableA 的值不变)。 NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？重点 对于不可变NSString&#x2F;NSArray&#x2F;NSDictionary，copy浅拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝) 对于可变NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary，copy深拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝) 自定义对象的copy和mutableCopy？ 重点 copy和mutableCopy都是深拷贝(属性：浅拷贝） 属性用copy还是strong？ 重点 对于不可变属性，推荐用copy，目的是为了 让本属性不受外界影响，无论给我传入可变还是不可变对象，我本身持有的就是一个不可变的副本，被set时，改变的是这个副本。 对于可变属性，推荐用strong，因为copy修饰后，会变成不可变对象，再调用可变对象函数时会 crash 一个APP是如何唤醒另一个APP的？ 重点URL Scheme：iOS有一个特性就是将 自身绑定 到一个自定义的 URL Scheme 上，该 scheme 用于从 浏览器或其他应用中启动本应用。 单例的写法和作用？ 重点单例模式的作用：可以保证程序运行过程中，一个类只返回一个实例，供外界访问；static保证类只分配一次内存；dispatch_once方法保证调用一次，并自动加锁，线程安全 12345678910111213141516static id _instance = nil; // 定义static全局变量，保证只分配一次内存+ (id)shareInstance&#123; return [[self alloc] init];&#125;+ (id)copyWithZone:(struct _NSZone *)zone&#123; static dispatch_once_t onceToken; // 声明一个静态的GcD单次任务 // 保证只执行一次 dispatch_once(&amp;onceToken,^&#123; // _instance = [super allocWithZone:zone]; &#125;); return p;&#125;``` 这么写可以保证下面两种方式返回同一个实例 Single * p1 &#x3D; [Single shareInstance];Single * p2 &#x3D; [[Single alloc] init];NSLog(@”%d”,p1&#x3D;&#x3D;p2); &#x2F;&#x2F; 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161## HTTPS和HTTP的区别？ **重点*** HTTP：超文本传输协议，信息明文传输；端口号80；响应速度快（使用TCP三次握手，客户端和服务端需要交换3个包）；* HTTPS：是由 HTTP+SSL/TLS 加密传输；端口号443；响应速度慢（除了使用TCP三个包，还要加上SSL握手的9个包）；需要到CA申请证书## TCP 和 UDP 区别? **重点*** 都是 `传输层` 协议* TCP协议是 `面向连接的可靠的传输层协议`。UDP协议是 `面向非连接的传输层协议`* TCP需要 `建立连接和断开连接`。UDP不需要连接。* TCP传 输数据没有大小限制。UDP 传输数据有大小限制。* TCP会 `处理数据丢包重发`。UDP不会处理。# HTTP和socket区别？ **重点*** `HTTP` 应用层协议；`socket` 不属于协议范畴，而是一个接口（API），是对TCP/IP协议的封装* `HTTP` 是基于 `请求-响应` 形式 `短连接`，即客户端发送一次请求，服务端响应后立即 `断开连接`；socket 是基于TCP协议的 `长链接`，理论上 客户端和服务端一旦建立连接将不会主动断开* HTTP传输慢，数据量大，安全差；socket数据可自定义，数据量小，安全性高，适合信息实时交互（推送、聊天等）## staitc 和 const 的区别？ **重点*** const：表示 `只读` 的意思 * `const` 放在 `类型` 前：可以改变指针的指向，可以改变指针指向的内容 * `const` 放在 `变量` 前：不可以改变指针的指向，不可以改变指针指向的内容* static： `静态变量`，可修饰 `局部变量和全局变量`，可修饰方法 * `static` 可修饰 `局部/全局变量`，称为 `局部静态变量和全局静态变量`，只初始化一次，只分配一次内存，生命周期被改变，不再是作用域内 * `static` 修饰的 `方法`，可以在不同文件下重名，互不影响运行## 通用链接（Universal Links）**重点*** 服务端配置 `HTTPS` 证书 和添加 `apple-app-site-association` 地址关联文件* 移动端在plist添加 `Associated Domains` 关联域权限## 简述GET和POST请求的区别？ **重点*** GET 传输数据 `有缓存`；POST 传输数据 `没有缓存`* GET的 `参数` 放在 `URL` 的后面，并且第一个参数用 `?` 号拼接，后面的从第二个参数开始，直到最后一个，用 `&amp;` 分割；POST的 `参数` 放在 `请求体` 里面，并且第一个参数用 `,` 号拼接，后面从第二开始，直到最后用 `&amp;` 分割;* GET一般用于 `获取数据`；POST一般用于 `向服务器提交数据`* `GET` 的参数是暴漏在 `地址栏` 的，不安全；`POST` 的参数隐藏在 `请求体` 里面，相对安全一点;* GET请求提交数据受浏览器限制 `1k`，POST请求理论上无限制。## iOS中几种常见的设计模式？ **重点*** `代理模式`一对一的依赖关系，当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。* `观察者模式`KVO机制 和 Notification通知机制* `单例模式`保证程序运行过程中，一个类只返回一个实例，供外界访问* `工厂模式`通过一个类方法，`根据已有模板批量生产对象`。* `MVC模式`Model即数据模型view即视图controller即控制器## RunLoop是什么？ **重点*** 概念 `RunLoop` 又叫 `运行循环`，内部就是一个 `do-while循环`，在这个循环内部不断 `处理各种任务，保证程序持续运行`。* 目的RunLoop存在的目的： 就是当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，`提高程序性能，节省CPU资源`，该做事的时候做事，该休息的时候休息## RunLoop的作用？ **重点*** `保持程序持续运行`。 App一启动就会开启主线程，主线程在开启的时候就会开启主线程对应的RunLoop，RunLoop能保证线程不被销毁，主线程不销毁，程序就会持续运行。* `处理App中各类事件`。 事件响应、手势识别、界面刷新、AutoreleasePool自动释放池、NSTimer等事件处理。* `节省CPU资源，提高程序性能`。 如概述所述，当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，提高程序性能，节省资源，该做事的时候做事，该休息的时候休息。## 可以用Runloop实现什么功能？ **重点*** 线程保活往 `runloop` 中添加 `[[NSPort alloc] init]` 事件，* 解决NSTimer在滑动时停止工作的问题`default` 模式改为 `common` 模式* 检测卡顿如果我们要利用 `RunLoop` 原理来监控卡顿的话，就是要关注这两个阶段。RunLoop 在进入睡眠之前和唤醒后的两个 `loop` 状态定义的值，分别是 `kCFRunLoopBeforeWaiting` 和 `kCFRunLoopAfterWaiting` ，也就是要触发 `Source0` 回调和接收 `mach_port` 消息两个状态。## RunLoop接收几种输入源，系统默认定义了几种模式？ **重点*** 输入源有两种基于 `端口` 的输入源（port）`自定义` 的输入源（custom）* 系统定义的RunLoop模式有五种，最常用的有三种，如下所示：NSDefaultRunLoopMode默认模式，主线程中默认是NSDefaultRunLoopModeUITrackingRunLoopMode视图滚动模式，RunLoop会处于该模式下NSRunLoopCommonModes并不是真正意义上的Mode，是一个占位用的“Mode”，默认包含了NSDefaultRunLoopMode和UITrackingRunLoopMode两种模式## RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？ **重点*** 每一个线程都有一个runloop，主线程的runloop默认启动。子线程的runloop默认不启动* mode：主要用来指定事件在运行时循环的优先级* 作用：保持程序的持续运行、随时处理各种事件、节省cpu资源(没事件休息释放资源)，提高程序的性能。## 怎么理解Objective-C是动态运行时语言。 **重点**主要是 `将数据类型的确定和函数的调用由编译时推迟到了运行时`。这个问题其实浅涉及到两个概念，`运行时和多态`。* 运行时：简单来说，运行时机制使我们 `直到运行时才去确定数据类型和要调用的函数`。* 多态：`不同对象以自己的方式响应相同的消息的能力` 叫做多态。## runtime项目中具体应用？ **重点*** `方法交换`。* 给 `分类添加属性`。 * 动态添加方法。* 字典转模型。* 数组越界。* 动态获取成员属性、成员变量、实例方法## KVC是什么？**重点**`KVC` 全程 `Key Value Coding`，中文 `键值编码`，是由 `NSKeyValueCoding` 非正式协议启动的一种机制，`对象` 采用该协议来 `间接访问对象的属性`。 (nullable id)valueForKey:(NSString *)key; (nullable id)valueForKeyPath:(NSString *)keyPath; (void)setValue:(nullable id)value forKey:(NSString *)key; (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; 1234567891011121314151617181920212223242526272829[KVC底层原理：](http://www.bboyzj.cn/2021/01/17/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8622%EF%BC%9AKVC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/)## KVO是什么？**重点**`KVO` 全程 `Key Value Observing`，中文 `键值观察`，它 `用于监听实例对象属性的变化`。## KVO的实现原理？(KVO的本质是什么？) **重点**当一个 `实例对象` 的 `属性注册了KVO`，实例对象 `isa指针` 的指向在注册KVO观察者之后，由 `原有类` 改为 `中间类(NSKVONotifing_类名)`；`中间类` 重写了 `属性setter方法、class、dealloc、_isKVOA` 方法；`dealloc` 方法中，移除 `KVO` 观察者之后，实例对象isa 指向由 `中间类` 更改为 `原有类`;中间类 从创建后就 `一直存在内存中`，不会被销毁。## KVO实际应用 **重点*** 观察 `实例对象` 的 `属性` 变化* 观察 `实例对象` 的 `容器` 变化 观察容器用： `mutableArrayValueForKey` [KVO底层原理：](http://www.bboyzj.cn/2021/01/25/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8623%EF%BC%9AKVO%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/) ## category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？**重点*** `category` 原则上它 `只能增加方法`，`不能增加成员（实例）变量`。可以添加属性，但是不会自动生成实例变量_name和setter和getter方法。可以添加方法* `扩展` 主要用来为一个类添加额外的原来没有的 `实例变量、方法和属性`。extension常用的形式并不是以一个单独的.h文件存在，而是寄生在类的.m文件中。类扩展中： @interface Person (){ int age; &#x2F;&#x2F;实例变量}@property (nonatomic,copy)NSString * name;&#x2F;&#x2F;属性 (void)run;&#x2F;&#x2F;方法@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475## iOS开发中有多少类型的线程？ **重点*** pthread一套用于 `C` 的多线程 `API`、适用于 `Unix / Linux / Windows` 等系统、跨平台、可移植、使用难度大* NSThread使用更加面向对象、简单易用，可直接操作线程对象* GCD旨在替代NSThread等线程技术、充分利用设备的 `多核`、基于 `C` 的底层的 API* NSOperation`NSOperation` 是基于 `GCD` 之上的更高一层的封装， `NSOpetation` 需要配合 `NSOpetationQueue` 来实现多线程## 根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？ **重点**dispatch_group_t + dispatch_group_enter + dispatch_group_leave + dispatch_group_notify## 10个网络请求顺序回调? GCD如何实现？**重点**dispatch_group_t + dispatch_semaphore_t：信号量（dispatch_semaphore_wait + dispatch_group_leave）## GCD和NSOperation的区别？ **重点*** `GCD执行效率更高`，而且由于队列中执行的是由block构成的任务，这是一个轻量级的数据结构，写起来更方便* GCD只支持FIFO的队列，而 `NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序`* NSOperationQueue甚至可以跨队列设置依赖关系，但是GCD只能通过设置串行队列，或者在队列内添加barrier(dispatch_barrier_async)任务，才能控制执行顺序,较为复杂* `NSOperationQueue因为面向对象`，所以 `支持KVO`，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished）、是否取消（isCanceld）具体的底层看 [OC底层原理27：GCD之 NSThread &amp; GCD &amp; NSOperation](http://www.bboyzj.cn/2021/03/23/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8627%EF%BC%9AGCD%E4%B9%8B%2520NSThread%2520&amp;%2520GCD%2520&amp;%2520NSOperation/)## 什么是Block？ **重点**`Block` 是将 `函数及其上下文封装起来的对象`## Block的本质 **重点** * block 的 `本质` 是 `对象、函数、结构`体，由于block函数没有名称，也被称为 `匿名函数`## Block的分类？ **重点*** 分为 `全局Block(_NSConcreteGlobalBlock)、栈Block(_NSConcreteStackBlock)、堆Block(_NSConcreteMallocBlock)` 三种形式。* 其中 `栈Block存储在栈(stack)区`，`堆Block存储在堆(heap)区`，`全局Block存储在已初始化数据(.data)区`。 * 堆：动态分配内存，需要程序员自己申请，程序员自己管理 * 栈：自动分配内存，自动销毁，先入后出，栈上的内容存在自动销毁的情况具体看底层原理 [OC底层原理30：Block底层原理](http://www.bboyzj.cn/2021/04/22/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8630%EF%BC%9ABlock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/)# 循环引用的几种情况和解决方式？ **重点*** Block原因： `self` 强引用了 `block`，而 `block` 内部又调用了 `self`解决： 使用 `Weak-Strong Dance`* Delegate原因：委托者和被委托人之间的相互强引用问题 `strong`解决：用 `weak` 进行弱引用 `或者` 通过中间对象(代理对象)的方式来解决(效率更加高的中间对象NSProxy：不需要进行发送消息和动态解析，直接进行消息转发)* NSTimer原因：self → timer → self(target) 的循环持有链解决：在适当的时机销毁 [_timer invalidate];_timer &#x3D; nil; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131# OC 如何进行内存管理的？ **重点*** 自动内存管理 ARC* 手动内存管理* 自动释放池# 内存优化 **重点*** cell复用* 绘制的话：用CAShaperLayer，渲染快，内存使用高效* 按需加载：懒加载* 合理利用缓存：比如三方图片压缩缓存* 尽量使用透明View：控件有背景色增大内存消耗# 启动优化 **重点*** pre-main 阶段：`二进制重排` * 尽量 `少用外部动态库`，苹果官方建议自定义的动态库最好 `不要超过6个`，如果超过6个，需要 `合并` 动态库 * 减少 `OC` 类，因为类越多，越耗时 * 将不必须在 `+load` 方法中做的事情延迟到 `+initialize` 中，尽量不要用 `C++` 虚函数* main 阶段：mian -&gt; didFinishLaunching * 减少启动初始化的流程，`能懒加载的懒加载，能延迟的延迟，能放后台初始化的放后台`，尽量少占用主线程的启动时间 * 优化代码逻辑，去除非必须的代码逻辑，减少每个流程的消耗时间 * 启动阶段能 `使用多线程` 来初始化的，就使用多线程 * 尽量 `使用纯代码` 来进行UI框架的搭建，尤其是主UI框架，例如 UITabBarController，尽量避免使用Xib或者SB，相比纯代码而言，这种更耗时 * 删除废弃类、方法 ## 屏幕卡顿优化 **重点****主要是用Runloop进行FPS监测**主要从减轻 `CPU` 和 `GPU` 消耗入手，保证写一个 `VSync` 到来时，`CPU` 和 `GPU` 能够写作完成下一帧的渲染并缓存到帧缓冲区* 卡顿优化在 `CPU` 层面：1）尽量用轻量级的对象，比如 `用不到事件处理` 的地方，可以考虑使用 `CALayer` 取代 `UIView`2）不要频繁地调用 `UIView` 的相关属性，比如 `frame、bounds、transform` 等属性，尽量减少不必要的修改3）尽量 `提前计算好布局`，在有需要时一次性调整对应的属性，不要多次修改属性4）图片的 `size` 最好刚好跟 `UIImageView` 的 `size` 保持一致5）`控制`一下线程的最大并发数量6）尽量把 `耗时的操作放到子线程`：如text宽高获取等* 卡顿优化在 GPU层面：1）GPU能处理的 `最大纹理` 尺寸是 `4096x4096`，一旦超过这个尺寸，就会占用 `CPU` 资源进行处理，所以纹理尽量不要超过这个尺寸2）尽量 `减少视图数量和层次`3）`减少透明的视图`（alpha&lt;1），不透明的就设置 `opaque` 为 `YES`4）尽量 `避免出现离屏渲染`：圆角、阴影、遮罩等 ## 卡顿优化：tableView优化 **重点*** 最常用的就是`cell的复用`， 注册复用标识符* `避免cell的重新布局`，初始化时就布局好* `提前计算并缓存cell的高度`* `减少cell中控件的数量`，少动态添加 view* `避免背景透明`* 能`使用局部更新` 的就使用 `局部更新`* 加载网络数据，`下载图片，使用异步加载`，并缓存* `按需加载cell`：cell滚动很快时，只加载范围内的cell* `不要实现无用的代理方法`，tableView只遵守两个协议 # 网络优化 **重点*** DNS优化：即域名解析优化，缓存 ip* 资源优化： * 图片webp，比png/jpg小 * 数据传输用ProtocolBuffer代替json，数据小，序列化和反序列化也简单* 请求压缩、请求合并* 数据缓存* 网络环境监测 * 针对性请求重试## TCP三次握手，四次挥手过程？**重点**1. 为什么是三次握手，而不是二次握手？三次握手是为了建立一个可靠的数据传输通道：* 刚开始客户端和服务端处于关闭状态，而且服务端B一直处于监听状态，时刻监听是否有建立连接的请求* 当客户端需要建立连接的时候就会发送一个 `请求连接` 的报文，此报文是 `同步报文SYN=1`，并且会生成一个 `随机的序号seq=x`，这是第一次握手* 当服务端接收到请求连接报文时，会发送一个 `确认连接` 的报文，此报文是 `同步报文SYN=1`，并且 `确认报文ACK=1`，同时服务端也会生成一个 `随机的序号seq=y`，并且将 `确认报文确认号ack=x+1`，回传给客户端，这是第二次握手* 当客户端接收到服务端的 `ACK确认报文后`，会回复一个 `ACK确认报文`，用于确认确认报文已经收到，此报文 `ACK=1，seq=x+1，ack=y+1`，这是第三次握手2. 四次挥手四次挥手则是为了保证数据传输完成接收再关闭连接。* 客户端断开连接时会发送一个 `请求断开连接` 的报文，此报文是 `FIN=1`，并且会生成一个 `随机的序号seq=u`，发送给服务端，这是第一次挥手* 服务端接收到请求断开连接 `FIN报文` 后，回复一个 `确认断开连接` 报文 `ACK=1,seq=v,ack=u+1`，这是第二次挥手* 当服务端数据发送完后，再发送一个FIN报文给客户端，通知客户端，服务端准备关闭连接，此报文 `FIN=1,ACK=1,ack=u+1,seq=w`，这是第三次挥手* 当客户端收到 `FIN确认报文`，再发送一个FIN确认报文 `ACK=1,seq=u+1,ack=w+1`，并进入` TIME-WAIT` 等待，等待 `2MSL` 后关闭连接，这是第四次挥手 # 事件链 **重点**[OC学习01：事件传递链和响应链](https://www.bboyzj.cn/2023/03/01/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/)* 传递链：由系统向离用户最近的view传递。 顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; ViewController -&gt; subViews* 响应链：由离用户最近的view向系统传递。 顺序： superViews –&gt; ViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate# 事件传递的两个核心方法？ **重点** &#x2F;&#x2F; 返回最适合处理事件的视图 (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;&#x2F;&#x2F; 判断点是否在这个View内部 (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event; 1234567* 第一个方法返回的是一个 `UIView`，是用来寻找最终哪一个视图来响应这个事件* 第二个方法是用来判断某一个点击的位置是否在视图范围内，如果在就返回YES# 实现一个按钮的点击范围扩大效果 **重点**自定义一个按钮，继承UIButton，重写 `pointInside:withEvent:` 方法， (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{ &#x2F;&#x2F; 当前btn大小 CGRect btnBounds &#x3D; self.bounds; &#x2F;&#x2F; 扩大按钮的点击范围，增大内边距 btnBounds &#x3D; CGRectInset(btnBounds, -10, -10); &#x2F;&#x2F; 若点击的点在新的bounds里，返回YES return CGRectContainsPoint(btnBounds, point);} 12345# 子视图超过父视图部分仍然能响应 **重点**重写 `hitTest:withEvent` 方法，让 `子视图` 去相应事件 (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{ &#x2F;&#x2F; 判断btn能否接收事件 if (self.btn.userInteractionEnabled &#x3D;&#x3D; NO || self.btn.hidden &#x3D;&#x3D; YES || self.btn.alpha &lt;&#x3D; 0.01) { return nil; } &#x2F;&#x2F; 把当前点转换成btn坐标系上的点 CGPoint btnP &#x3D; [self convertPoint:point toView:self.btn]; &#x2F;&#x2F; 当触摸点在btn上时，才让按钮相应事件 if ([self.btn pointInside:btnP withEvent:event]) { NSLog(@”%@”,NSStringFromCGPoint(btnP)); return self.btn; } NSLog(@”父视图相应”); return [super hitTest:point withEvent:event];} &#96;&#96;&#96; 面试官问还有什么想问的？ 重点技术面不问薪资待遇，人事面问薪资待遇 问岗位： 在这个岗位上，会直接 接触到哪些类型的项目？ 这个岗位的主要职责是什么？主要的KPI是什么？ 这个岗位如何评估绩效，试用期需要达到什么指标？ 这个岗位的最大挑战是什么？ 问团队： 团队的基本情况？ 这个团队在公司的角色是什么？ 可以跟我介绍一下我的领导吗？ 问公司 公司的文化氛围是什么样的？ 员工的晋升机制是什么样的？我这个岗位的晋升机会如何？ 这个岗位所在的团队如何支持公司目标的实现？","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-面试题","slug":"OC-面试题","permalink":"https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"Blog-04：主题完善","slug":"Blog-04：主题完善","date":"2023-03-01T02:54:01.000Z","updated":"2023-03-01T04:06:27.852Z","comments":true,"path":"2023/03/01/Blog-04：主题完善/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog-04%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/","excerpt":"","text":"前言我们以 Snippet 主题问例 下载安装1mac@bogon Blog % $ git clone git://github.com/shenliyang/hexo-theme-snippet.git themes/hexo-theme-snippet 安装主题插件1mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S 部署主题具体部署看下面的链接：1、2、3步骤可省略 Snippet","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/tags/Blog/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"Blog-03：Github域名绑定阿里云域名","slug":"Blog-03：Github域名绑定阿里云域名","date":"2023-03-01T02:17:25.000Z","updated":"2023-03-01T11:26:07.736Z","comments":true,"path":"2023/03/01/Blog-03：Github域名绑定阿里云域名/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog-03%EF%BC%9AGithub%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/","excerpt":"","text":"注册域名去 阿里云 注册账号、并购买域名，具体流程这里就不一一介绍了 域名解析 在终端 ping 一下之前配置的静态页面地址,可以获取到对应的ip地址: 123456mac@bogon ~ % ping BboyZJ.github.ioPING bboyzj.github.io (185.199.109.153): 56 data bytes64 bytes from 185.199.109.153: icmp_seq=0 ttl=50 time=261.217 ms64 bytes from 185.199.109.153: icmp_seq=1 ttl=50 time=337.547 ms64 bytes from 185.199.109.153: icmp_seq=2 ttl=50 time=260.716 ms... @解析 记录类型：A主机记录：@解析请求来源：默认记录值：185.199.109.153TTL：10分钟 点击确定 www解析 记录类型：CNAME主机记录：www解析线路来源：默认记录值：BboyZJ.github.ioTTL：10分钟 点击确定 配置项目 CNAME 在 Blog/source 目录下，新建 CNAME 文件，内容输入阿里云申请的域名 www.bboyzj.cn 12mac@bogon ~ % cd /Users/mac/Desktop/Blog/source mac@bogon source % touch CNAME 配置 Blog 目录下 _config.yml 文件，URL 模块 123456789# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://www.bboyzj.cnroot: /BboyZJ.github.io/permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks 执行 123mac@bogon ~ % hexo cleanmac@bogon ~ % hexo gmac@bogon ~ % hexo d 提交陈成功后，就可以在 GitHub 和 www.bboyzj.cn 个人域名绑定上了","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/tags/Blog/"}],"keywords":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Blog-02：部署博客到GitHub","slug":"Blog-02：部署博客到GitHub","date":"2023-03-01T01:12:01.000Z","updated":"2023-03-01T13:45:55.546Z","comments":true,"path":"2023/03/01/Blog-02：部署博客到GitHub/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog-02%EF%BC%9A%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0GitHub/","excerpt":"","text":"注册GitHub账号前往 Github 网站，注册一个新用户。用邮箱注册的一定前往邮箱去验证邮件。 部署到 GitHub 上 新建 reponsity 仓库 仓库名设置成 用户名.github.io ，比如我的是 BboyZJ.github.io，选择 Public，勾选 Add a README file ，最后 Create respository 配置秘钥 查看秘钥 123$ cd ~/.ssh$ ls$ cat id_rsa.pub 添加SSH秘钥：头像 -&gt; Setting -&gt; SSH and GPG keys Title 随意写，Key 需要填写刚才复制的 秘钥 文本内容 添加完成，验证链接 123mac@bogon ~ % ssh -T git@github.comHi BboyZJ! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 上传文件到 GitHub 配置 Blog 下 _config.yml 中的 Deployment 模块 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repository: https://github.com/BboyZJ/BboyZJ.github.io.git branch: master 安装部署插件 通过 Hexo 发布到 GitHub，需要安装部署插件 1mac@bogon ~ % npm install hexo-deployer-git --save 部署 123mac@bogon ~ % cd /Users/mac/Desktop/Blogmac@bogon ~ % hexo gmac@bogon ~ % hexo d 访问 这时我们的 GitHub 域名 https://BboyZJ.github.io 就可以看到 Hexo 网站了，如果没显示出来就 刷新 一下","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-02-28T23:51:10.086Z","updated":"2023-02-28T23:51:10.086Z","comments":true,"path":"2023/03/01/hello-world/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/hello-world/","excerpt":"","text":"Welcome to Hexo ! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub . Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"Blog-01：Hexo个人博客搭建","slug":"Blog-01：Hexo个人博客搭建","date":"2023-02-28T23:39:40.000Z","updated":"2023-03-01T15:11:35.907Z","comments":true,"path":"2023/03/01/Blog-01：Hexo个人博客搭建/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog-01%EF%BC%9AHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Hexo 什么是Hexo？ 简介：Hexo 是一个快速、简洁且高效的博客框架。想要详细的了解 Hexo ，去官网学习。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提 检查是否安装 homebrew 12345mac@bogon ~ % brew -vHomebrew 3.6.21-28-ge6548a8Homebrew/homebrew-core (git revision 5434c8344e8; last commit 2023-02-09)Homebrew/homebrew-cask (git revision 15c2c1fa53; last commit 2023-02-09)mac@bogon ~ % 如果顺利显示版本号，说明homebrew已经安装。否则，输入以下命令进行安装： 1mac@bogon ~ % ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装过程如果出现下面的问题 1curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused 解决: 1mac@bogon ~ % /usr/bin/ruby -e &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)&quot; 安装 Node.js 123mac@bogon ~ % brew install nodemac@bogon ~ % node -vv18.14.2 安装GitMac系统默认已经安装好了，所以不需要再安装 安装Hexo如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往安装 Hexo 步骤。 使用npm完成 hexo 安装 12345678910111213141516171819202122mac@bogon ~ % npm install -g hexo-climac@bogon ~ % hexo -vhexo-cli: 4.1.0os: Darwin 21.6.0 darwin x64node: 12.16.1v8: 7.8.279.23-node.31uv: 1.34.0zlib: 1.2.11brotli: 1.0.7ares: 1.15.0modules: 72nghttp2: 1.40.0napi: 5llhttp: 2.0.4http_parser: 2.9.3openssl: 1.1.1dcldr: 35.1icu: 64.2tz: 2019cunicode: 12.1mac@bogon ~ % 建站 桌面新建 Blog 文件夹，打开终端，cd到 Blog 下，执行: 123456789101112mac@bogon ~ % cd /Users/mac/Desktop/Blog mac@bogon Blog % hexo initINFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO Install dependenciesnpm notice npm notice New major version of npm available! 7.3.0 -&gt; 9.5.1npm notice Changelog: https://github.com/npm/cli/releases/tag/v9.5.1npm notice Run npm install -g npm@9.5.1 to update!npm notice INFO Start blogging with Hexo!mac@bogon Blog % 【目录文件】： _config.landscape.yml：网站本地配置信息_config.yml：网站的配置信息，可以在此配置大部分的参数source–posts：存放 md 文件themes：主题文件夹，常用主题 会放入这里public：Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 hexo 测试 生成静态页面 1mac@bogon Blog % hexo g 会在根目录 Blog\\ 下生成 public 文件夹，里面包含相应的 html 页面。 启动服务器 1mac@bogon Blog % hexo s 打开浏览器，输入网址: http://localhost:4000 ，即可看到hexo生成的静态页面。 停止服务器 Ctrl + C 主题hexo提供了很多主题可以参考，下面以 hexo-theme-casual 主题为例 安装主题插件 hexo-theme-redefine 1无 hexo-theme-casual 1mac@bogon Blog % $ npm install --save hexo-renderer-jade hexo-renderer-scss hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-generator-search hexo-theme-redefine 1mac@bogon Blog % $ npm install --save hexo-renderer-jade hexo-renderer-scss hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-generator-search hexo-theme-snippet 1mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S hexo-theme-butterfly 1mac@bogon Blog % $ npm install hexo-renderer-pug hexo-renderer-stylus 下载主题 进入主题的 github 下载页，点击 code -&gt; clone，复制 https 下载链接，进入 博库Blog目录，运行下面的命令： 123mac@bogon Blog % cd /Users/mac/Desktop/Blog mac@bogon Blog % cd themes mac@bogon themes % git clone https://github.com/littlewin-wang/hexo-theme-casual.git 【注】：主题存放的目录是 Blog/themes，为了方便管理，每一个下载的主题都建一个单独的目录，我这个主题的目录是 hexo-theme-casual，可以下载多个主题: 主题应用 找到 博客Blog 目录下的配置文件 _config.yml，找到 Extensions 模块，修改 theme 字段： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-casual 启动本地服务器 1234567891011mac@bogon Blog % hexo sINFO Validating configINFO Start processingINFO Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.[Browsersync] Access URLs: ---------------------------------- UI: http://localhost:3001 ---------------------------------- UI External: http://localhost:3001 ---------------------------------- 查看效果 通过 http://localhost:4000/ 查看修改后的效果 主题更新 这一步不是必须的，如果主题有优化，我们需要在本地同步更新一下 12mac@bogon Blog % /Users/mac/Desktop/Blog/themes/casual mac@bogon Blog % git pull 其他命令 清除旧的内容 hexo clean 生成静态发布页面 hexo g 发布页面 hexo d","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"Swift学习14：在Swift里如何处理算术结果溢出","slug":"Swift学习14：在Swift里如何处理算术结果溢出","date":"2023-02-22T17:31:22.000Z","updated":"2023-03-01T17:30:15.039Z","comments":true,"path":"2023/02/23/Swift学习14：在Swift里如何处理算术结果溢出/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A014%EF%BC%9A%E5%9C%A8Swift%E9%87%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%AE%97%E6%9C%AF%E7%BB%93%E6%9E%9C%E6%BA%A2%E5%87%BA/","excerpt":"","text":"溢出运算符 在默认情况下，当向一个整数赋超出它容量的值时，swift 会报错而不是生成一个无效的数，给我们操作过大或过小的数时提供了额外的安全性 同时提供三个算术溢出运算符来让系统支持整数溢出运算 溢出加法 &amp;+ 溢出减法 &amp;- 溢出乘法 &amp;* 值溢出 数值可以出现向上溢出或向下溢出 溢出也会发生在有符号整型数值上 对于无符号与有符号整型数值来说，当出现溢出时，它们会从数值所能容纳的最大数变成最小的数，同样的，当发生下溢时，它们会从所能容纳的最小数变成最大的数 代码示例 上溢出 下溢出","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习13：赋值和算术运算符","slug":"Swift学习13：赋值和算术运算符","date":"2023-02-22T17:30:48.000Z","updated":"2023-03-01T17:25:29.347Z","comments":true,"path":"2023/02/23/Swift学习13：赋值和算术运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A013%EF%BC%9A%E8%B5%8B%E5%80%BC%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"基本概念 一元运算符对一个目标进行操作。一元前缀运算符（如!b），一元后缀运算符（b!） 二元运算符对两个目标进行操作（a+b）同时因为它们出现在两个目标之间，所以是中缀 三元运算符操作三个目标，swift 语言也仅有一个 三元运算符，三元条件运算符（a?b:c） swift 运算符的改进 swift在支持 c 中的大多数标准运算符的同时也增加了一些排除常见代码错误的能力 赋值符号 = 不会返回值，以防止它被无用于等于符号 == 算术符号 +、-、*、/、% 以及其他可以监测并阻止值溢出，以避免你在操作比存储类型允许的范围更大或更小的数字时得到各种奇怪的结果 赋值运算符 赋值运算符将一个值赋值给另外一个值 如果赋值符号右侧是拥有多个值的元组，它的元素将会一次性地拆分成常量或者变量 Swift 的赋值符号自身不会返回值 算术运算符-标准运算符 标准算术运算符 + - * / 算术运算符同时也支持 String 的拼接 swift 算术运算符默认不允许值溢出 算术运算符 - 余数运算符 余数运算符 a%b 可以求出多少个 b 的倍数能够刚好放进 a 中并且返回剩下的值（就是我们所谓的余数） 当 a 是负数时也适用相同的方法来进行计算 当 b 为负数时它的正负号被忽略掉。这意味着 a%b 与 a%-b 能够获得相同的答案 12345678let c = 9 % 4print(c)let d = 9 % -4print(d)let e = -9 % 4print(e) 算术运算符 - 一元 数字值的正负号可以用前缀 - 来切换，我们称之为一元减号运算符 一元减号运算符 - 直接在要进行操作的值前边放置，不加任何空格 一元加号运算符 + 直接返回它操作的值，不会对其进行任何的修改","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习12：获取子串和字符串比较","slug":"Swift学习12：获取子串和字符串比较","date":"2023-02-21T18:59:39.000Z","updated":"2023-03-01T17:25:21.832Z","comments":true,"path":"2023/02/22/Swift学习12：获取子串和字符串比较/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A012%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AD%90%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/","excerpt":"","text":"子字符串 使用下标或者类似 prefix(_:) 的方法得到的子字符串是 Substring 类型 Substring 拥有 String 的大部分方法 Substring 可以转成 String 类型 1234let str = &quot;hello,world&quot;let index = str.firstIndex(of: &quot;,&quot;) ?? str.endIndexlet begin = str[..&lt;index]let new = String(begin) 子字符串重用一部分原字符串的内存 修改字符串或子字符串之前都不需要花费拷贝内存的代价 String 和 Substring 都遵循 StringProtocol 协议，也就是说它基本上都能很方便的兼容所有接受 StringProtocol 值的字符串操作函数 字符串的比较 字符串和字符相等性 == 和 != 前缀相等性 hasPrefis(_:) 后缀相等性 hasSubffix(_:) 12345var str1 = &quot;1&quot;var str2 = &quot;2&quot;print(str1 == str2)print(str1.hasPrefix(&quot;1&quot;))print(str2.hasSuffix(&quot;2&quot;))","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习11：索引访问和修改字符串","slug":"Swift学习11：索引访问和修改字符串","date":"2023-02-21T18:59:05.000Z","updated":"2023-03-01T17:18:31.138Z","comments":true,"path":"2023/02/22/Swift学习11：索引访问和修改字符串/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A011%EF%BC%9A%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串索引 每一个 String 值都有相关的索引类型，String.Index，他相当于每个 Character 在字符串中的位置 startIndex 属性来访问 String 中第一个 Character 的位置。endIndex 属性就是 String 中最后一个字符串的位置 endIndex 属性并不是字符串下标脚本的合法实际参数 如果 String 为空，则 startIndex 与 endIndex 相等 使用 index(before:) 和 index(after:) 方法来访问给定索引的前后 要访问给定索引更远的索引，你可以使用 index(_:offetBy:) 使用 indices 属性来访问字符串中每个字符的索引 123456var greeting = &quot;Hello, playground&quot;greeting[greeting.startIndex]greeting[greeting.index(before: greeting.endIndex)]greeting[greeting.index(after: greeting.startIndex)]let index = greeting.index(greeting.startIndex, offsetBy: 7)greeting[index] 插入 插入字符，使用 insert(_:at:) 方法 插入到另一个字符串的内容到特定的索引，使用 insert(contentsOf:at:) 方法 1234var str = &quot;hello&quot;str.insert(&quot;!&quot;, at: str.endIndex)str.insert(contentsOf: &quot; world&quot;, at: str.firstIndex(of: &quot;!&quot;)!)print(str) 删除 移除字符，使用 remove(at:) 方法 12var str = &quot;hello&quot;str.remove(at: str.index(before: str.endIndex)) 移除一小段特定范围的字符串，使用 removeSubrange(_:) 方法 123var str = &quot;hello&quot;let range = str.index(str.endIndex, offsetBy: -str.count)..&lt;str.endIndexstr.removeSubrange(range)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习10：字符串常见操作","slug":"Swift学习10：字符串常见操作","date":"2023-02-21T18:58:45.000Z","updated":"2023-03-01T17:15:30.150Z","comments":true,"path":"2023/02/22/Swift学习10：字符串常见操作/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A010%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/","excerpt":"","text":"字符串的可变性 var 指定的可以修改 let 指定的不可修改 对比 Object-C (NSString 和 NSMutableString) 字符串是 值类型 String 值在传递给方法或函数的时候会被复制过去 赋值给常量或变量的时候也是一样 Swift 编译器优化了字符串使用的资源，实际上拷贝只会在确实需要的时候才进行 123456var str1 = &quot;hello&quot;var str2 = str1print(str1 == str2)str1.append(&quot;,world&quot;)print(str1)print(str2) 操作字符 for in 循环遍历 String 中的每一个独立的 Character Character 类型 String 值可以通过传入 Character 数组来构造 1234var str = &quot;hello&quot;for c in str&#123; print(c)&#125; 字符串的拼接 使用加运算符 + 创建新字符串 使用 + 赋值符号 += 在已经存在的 String 值末尾追加一个 String 值 使用 String 类型的 append() 方法来可以给一个 String 变量的末尾追加 Character 值 字符串插值 字符串插值是一种从混合常量、变量、字面量和表达式的字符串字面量构造新 String 值的方法 每一个你插入到字符串字面量的元素都要被一对圆括号包裹，然后使用反斜杠前缀 \\() 类似于 NSString 的 stringWithFormat 方法，但是更加简便，更强大 可以在扩展字符串分割符中创建一个包含在其他情况下会被当做字符串插值的字符 要在使用扩展分隔符的字符串中使用字符串插值，在反斜杠后使用匹配首尾井号数量的井号 12let str = &quot;6 * 7 = \\(6 * 7)&quot;print(str)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习09：字符串创建和使用","slug":"Swift学习09：字符串创建和使用","date":"2023-02-21T18:58:24.000Z","updated":"2023-03-01T17:06:09.757Z","comments":true,"path":"2023/02/22/Swift学习09：字符串创建和使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A009%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"初始化空串 字面量 初始化器语法 isEmpty 检查是否为空串 123456var emptyString = &quot;&quot;var anotherEmptyString = String()if emptyString.isEmpty &#123; print(&quot;Nothing to see here&quot;)&#125; 字面量 字符串字面量是被双引号 “” 包裹的固定顺序文本字符 Swift 会为 str 常量推断类型为 String 1let str = &quot;some string&quot; 多行字面量 多行字符串字面量是用三个双引号引起来的一系列字符 多行字符串字面量把所有行包括在引号内，开始和结束默认不会有换行符 如果为了书写美观而不换行在后面加 \\ 12345678let someStr = &quot;&quot;&quot;1\\2\\345&quot;&quot;&quot;print(someStr) 要让多行字符串字面量起始或结束于换行，就在第一或最后一行写一个空行 多行字符串可以 缩进 以匹配周围的代码。双引号（”””）前的空格会告诉Swift其他行前应该有多少空白是需要忽略的 如果你在某行的空格超过了结束的双引号（”””），那么这些空格会被包含 12345678 let someStr = &quot;&quot;&quot; 1 2 3 4 5 &quot;&quot;&quot;print(someStr) 字符串里的特殊字符 转义特殊字符 \\o（空字符）,\\（反斜杠），\\t（水平制表符），\\n（换行符），\\r（回车符），\\”（双引号）以及 &#39;（单引号） 任意的 Unicode 标量，写作 \\u&#123;&#125;n，里边的 n 是一个 1-8 位的16进制数字，其值是合法 Unicode 值 1let str = &quot;\\u&#123;24&#125;&quot; 可以在多行字符串字面量中包含双引号（”）而不需要转义。要在多行字符串中包含文本 “”””””，转义至少一个双引号 扩展字符串分隔符(Raw String) 在字符串字面量中放置扩展分隔符来使 包含特殊字符的字符串 不让他们真的生效 把字符串放在双引号 (“) 内并由 (#) 包裹 12let str = #&quot;1\\n2\\n3\\n&quot;#print(str) 如果字符串里面有 &quot;# 则首尾需要两个 ## 12let str = ##&quot;1\\&quot;#n2\\#n3\\#n&quot;##print(str) 如果你需要字符串中某个特殊符号的效果，使用匹配你包裹的 # 号数量的 # 号，并在前面写转义符号 \\ 12let str = #&quot;1\\#n2\\#n3\\#n&quot;#print(str)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习08：Optional的使用Optional实现原理探索","slug":"Swift学习08：Optional的使用Optional实现原理探索","date":"2023-02-21T18:56:00.000Z","updated":"2023-03-01T17:03:15.837Z","comments":true,"path":"2023/02/22/Swift学习08：Optional的使用Optional实现原理探索/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A008%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8Optional%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"Optional-实现探究 Optional 其实是一个标准库里的一个 public 的 enum 类型，而且是 泛型 的，泛型的类型是 Wrapped 用标准库实现语言特性的典型 Optional.none 就是 nil Optional.some 则包装了实际的值 12345var str:Optional&lt;String&gt; = &quot;abc&quot;if let actualStr = str &#123; let count = actualStr.count print(count)&#125; Optional-解包实现 泛型属性 unsafelyUnwrapped 理论上我我们可以直接调用 unsafelyUnwrapped 获取可选项的值 123var str:String? = &quot;abc&quot;let count = str.unsafelyUnwrapped.countprint(count)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习07：Optional的使用","slug":"Swift学习07：Optional的使用","date":"2023-02-21T18:55:20.000Z","updated":"2023-03-01T16:54:26.902Z","comments":true,"path":"2023/02/22/Swift学习07：Optional的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A007%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"为什么需要 Optional？ Object-C 里的 nil 是无类型的指针 Object-C 里面的数组、字典、集合等不允许放入 nil Object-C 所有 对象的变量 都可以为 nil Object-C 只能用在对象上，而在其他地方又用其他特殊值（例如NSNotFound）表示值的缺失 Optional 通过在 变量类型 后面加 ? 表示 这里有一个值，它等于 x 或者 这里根本没有值 你可以通过给可选变量赋值一个 nil 来将之设置为没有值 在 Object-C 中 nil 是一个指向不存在对象的指针 在 Swift 中，nil 不是指针，它是 值缺失的一种特殊类型，任何类型的可选项都可以设置成 nil 而不仅仅是对象 只有可选项才能设置为 nil 12var str: String = nilvar str1: String? = nil Optional-If 语句以及强制解包 可选项是没法直接使用的 需要用 ! 号强制解包后才能使用（意思是我知道这个可选项里面有值，使用吧） 12var str: String? = &quot;abc&quot;let count = str.count 需要改成如下代码，才能正确执行 12var str: String? = &quot;abc&quot;let count = str!.count 或 1234var str: String? = &quot;abc&quot;if str != nil &#123; let count = str!.count&#125; Optional-绑定 可以使用 可选绑定 来判断可选项是否包含值，如果包含就把赋值给一个临时的 常量或变量 可选绑定可以与 if 和 while 的语句使用来检查可选项内部的值，并赋值给一个变量或常量 同一个 if 语句中包含多可选项绑定，用逗号分割即可。如果任一可选绑定结果是 nil 或者 布尔值 为 false ，那么整个 if 判断会被看做 false 12345var str:String? = &quot;abc&quot;if let actualStr = str &#123; let count = actualStr.count print(count)&#125; Optional - 隐士解包 有些可选项一旦被设定值之后，就会一直拥有值，在这种情况下，就可以去掉检查的需求，也不必每次访问的时候都进行解包 通过有声明的类型后边添加一个叹号（String!）而非问号（String?）来书写隐士解包可选项 123var str:String! = &quot;abc&quot;let count = str.countprint(count) 隐士解包可选项主要被用在Swift 类 的初始化过程中 Optional-可选链 可选项后面加问号 如果可选项不为nil，返回一个可选项结果，否则为nil 123var str:String? = &quot;abc&quot;let count = str?.countlet lastIndex = count - 1 将上面的代码改为： 1234567var str:String? = &quot;abc&quot;let count = str?.count//let lastIndex = count - 1if count != nil &#123; let lastIndex = count! - 1 print(lastIndex)&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习06：Tuple元组","slug":"Swift学习06：Tuple元组","date":"2023-02-21T18:54:43.000Z","updated":"2023-03-01T16:48:14.682Z","comments":true,"path":"2023/02/22/Swift学习06：Tuple元组/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A006%EF%BC%9ATuple%E5%85%83%E7%BB%84/","excerpt":"","text":"Tuple 元组 把多个值合并成单一的复合型的值 元组 内的值可以是任何类型，而且可以不必是统一类型 123let error = (1,&quot;没有权限&quot;)print(error.0)print(error.1) 元素命名 元组中的每一个元素可以指定对应的元素名称 123let error = (errorCode:1,errorMessage:&quot;没有权限&quot;)print(error.errorCode)print(error.errorMessage) 如果没有指定名称的元素也可以使用下标的方式来引用 123let error = (1,&quot;没有权限&quot;)print(error.0)print(error.1) Tuple 修改 用 var 定义的元组就是可变元组，let 定义的元组就是不可变元组 不管是可变还是不可变元组，元组在创建后就不能增加和删除元素 可以对可变元组的元素进行修改，但是不能改变其类型 123var error = (errorCode:1,errorMessage:&quot;没有权限&quot;)error.errorCode = 2error.errorMessage = &quot;2&quot; any 类型可以改为任何类型 12345var error: (Any,String) = (1,&quot;没有权限&quot;)error.0 = 2print(error)error.0 = &quot;abc&quot;print(error) Tuple 分解 将一个元组的内容分解成单独的常量或变量 1234let error = (1,&quot;没有权限&quot;)let (errorCode,errorMessage) = errorprint(errorCode)print(errorMessage) 如果只需要使用其中的一部分数据，不需要的数据可以用下划线 _ 代替 123let error = (1,&quot;没有权限&quot;)let (_,errorMessage) = errorprint(errorMessage) 作为函数返回值 使用 Tuple 为函数返回多个值 返回值的 Tuple 可以再函数的返回类型部分被命名 12345func writeToFile(content:String) -&gt; (errorCode:Int,errorMessage:String) &#123; return (1,&quot;没有权限&quot;)&#125;let error = writeToFile(content: &quot;&quot;)print(error)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习05：数值类型","slug":"Swift学习05：数值类型","date":"2023-02-21T18:53:56.000Z","updated":"2023-03-01T16:43:16.134Z","comments":true,"path":"2023/02/22/Swift学习05：数值类型/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A005%EF%BC%9A%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"整数 Swift 提供了 8，16，32，64 位编码的有符号和无符号整数 命名方式：例如 8位无符号整数的类型是 UInt8，32位有符号整数的类型是 Int32 通过 min 和 max 属性来访问每个整数类型的最小值和最大值 Swift 提供了一个额外的整数类型：Int，它拥有与当前平台的原生字相同的长度 同时 Swift 也提供 UInt 类型，来表示平台长度相关的无符号整型 建议在用到证书的地方都使用 Int 浮点类型 Double：64位浮点数，至少有 15 位数字的精度 Float：32位浮点数，至少有 6 为数字的精度 在两种类型都可以的情况下，推荐使用 Double 类型 数值范围 123let a = 8let b: UInt8 = 240print(&quot;UInt8 min \\(UInt8.min),UInt8 max \\(UInt8.max)&quot;) Bool Bool：true 和 false Swift 的类型安全机制会阻止你用一个非布尔量的值替换掉 Bool 1234let i = 1if i &#123; print(i)&#125; 我们修改一下 类型别名 类型别名是一个为 已存在类型 定义的一个 可选择的名字 你可以用关键字 typealias 定义一个类型的别名 当你想通过在一个在上下文中看起来更合适可具有表达行的名字来引用一个已存在的类型时，这时别名就非常有用了 123// 音频采样率typealias AudioSample = UInt8let sample:AudioSample = 32","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习04：变量和常量","slug":"Swift学习04：变量和常量","date":"2023-02-21T18:12:27.000Z","updated":"2023-03-01T16:40:54.558Z","comments":true,"path":"2023/02/22/Swift学习04：变量和常量/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A004%EF%BC%9A%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/","excerpt":"","text":"声明变量和常量 使用关键字 let 声明常量 12let a = 1a = 2 由于 x 是常量，不能给常量赋值，会报错 使用关键字 var 声明变量 12var b = 1b = 2 可以在一行中声明多个变量和常量，用逗号分割 1var x = 0.0,y = 1.0,z = 2.0 类型标注 在声明一个变量或常量时提供类型标注，来明确变量或常量能够存储值的类型 添加 类型标注 的方法是在 变量或常量 的名字后面加一个 冒号，再跟一个 空格，最后加上使用的 类型名称 可以在一行中定义多个相关的变量为相同的类型，用 逗号 分割，只要在最后的变量名字后加上类型标注 123var a: Stringa = &quot;hello&quot;a = 10 常量和变量命名 常量和变量的名字几乎可以使用任何字符，甚至包括 Unicode 字符 常量和变量的名字不能包含 空白字符、数学符号、箭头、保留的（或者无效的）Unicode码位、连线和制表符。也不能以 数字 开头，尽管数字几乎可以使用在名字其他的任何地方 123let π = 3.1415let 你好 = &quot;你好世界&quot;let 🐶🐂 = &quot;dog,cow&quot; 打印常量和变量 print(_:separator:teminator) 字符串插入 用 \\() 来插入 123456let π = 3.1415let 你好 = &quot;你好世界&quot;let 🐶🐂 = &quot;dog,cow&quot;print(π)print(&quot;\\(你好)&quot;)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习03：Playgorund使用","slug":"Swift学习03：Playground使用","date":"2023-02-21T16:41:59.000Z","updated":"2023-03-01T16:37:15.616Z","comments":true,"path":"2023/02/22/Swift学习03：Playground使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A003%EF%BC%9APlayground%E4%BD%BF%E7%94%A8/","excerpt":"","text":"简介 Swift 的 Playgorund 是为了让人人都能愉快的学习 swift 编程 但发展至今，这个工具越来越强大 Playgorund 使用 创建一个 Playgorund 应用 Next，默认名 MyPlayground 可以通过 New -&gt; Playground Page 创建多个 Playground 来学习 注：快捷键 command + option + n 创建 Playground Page command + shift + enter 快速运行程序 简单使用 写一个求和的函数 12345678// 求和函数func sum(a:Int,b:Int) -&gt; Int &#123; return a+b&#125;// 调用求和函数 赋值给 常量 clet c = sum(a: 1, b: 2)// 打印常量 cprint(c)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习02：REPL交互式解释器","slug":"Swift学习02：REPL交互式解释器","date":"2023-02-21T16:41:38.000Z","updated":"2023-03-01T16:34:05.335Z","comments":true,"path":"2023/02/22/Swift学习02：REPL交互式解释器/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A002%EF%BC%9AREPL%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%99%A8/","excerpt":"","text":"介绍 xcode 6.1 引进了另外一种以交互式的方式来体验 Swift 的方法 Read Eval PrintLoop，简称REPL 使用REPL 除了可以 定义常量和变量 外，还是可 定义函数 打开终端输入 12mac@bogon ~ % swiftmac@bogon ~ % swift repl 定义变量 定义函数 REPL 其他命令 退出：:quit 帮助：:help 将光标移动到当前行的开始处：Control + A 将光标移动到当前行的结束处：Control + E","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习01：Swift编译流程","slug":"Swift学习01：Swift编译过程","date":"2023-02-21T15:49:55.000Z","updated":"2023-03-01T16:30:28.349Z","comments":true,"path":"2023/02/21/Swift学习01：Swift编译过程/","link":"","permalink":"https://www.bboyzj.cn/2023/02/21/Swift%E5%AD%A6%E4%B9%A001%EF%BC%9ASwift%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","excerpt":"","text":"编译器架构Swift编译过程和OC基本类似，仅仅是前端编译器不一样。 OC/C 前端编译器是 Clang Swift 先解析成 Swift AST（抽象语法树），通过 swiftc 这个命令行参数，编译成 Swift IL OC 和 Swift 最后均编译成 LLVM IR 中间层表示 OC 和 Swift 最终通过 后端编译器 LLVM compiler ，编译成最终的在具体地址上可以执行的二进制，包括x86、arm和other 详细编译流程 Swift 先解析成 AST（抽象语法树） 经过一系列工具编程 Swift 的 SIL(中间语言) 再经过 分析、IR工具 转成 LLVM IR(中间表示层) 最终通过 后端编译器 LLVM compiler 编译成 .o 目标文件 命令行流程使用终端创建一个简单的 main.swift 文件 12mac@bogon ~ % cd Desktopmac@bogon Desktop % touch main.swift 此时你可以在桌面看到一个 main.swift 文件 在该文件下写下两个数相加的一个函数 123456func sum(a:Int,b:Int) -&gt; Int &#123; return a + b&#125;let value = sum(a: 1, b: 2)print(value) 打开命令行工具 mac@bogon ~ % cd Desktop 生成 AST 抽象语法树 mac@bogon ~ % swiftc main.swift -dump-ast 生成 SIL 中间语言 mac@bogon ~ % swiftc main.swift -emit-sil 生成 LLVM IR 中间表示层 mac@bogon ~ % swiftc main.swift -emit-ir 生成 Assembly Language 汇编语言 mac@bogon ~ % swiftc main.swift -emit-assembly 生成二进制文件 mac@bogon ~ % swiftc -o main.out main.swift 命令行输入： 1234mac@bogon ~ % cd /Users/mac/Desktop/01swift编译流程 mac@bogon 01swift编译流程 % swiftc -o main.out main.swiftmac@bogon 01swift编译流程 % ./main.out3","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习00：简介","slug":"Swift学习00：简介","date":"2020-08-22T13:17:43.000Z","updated":"2023-03-01T16:24:09.919Z","comments":true,"path":"2020/08/22/Swift学习00：简介/","link":"","permalink":"https://www.bboyzj.cn/2020/08/22/Swift%E5%AD%A6%E4%B9%A000%EF%BC%9A%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Swift介绍Swift是Apple在2014年6月WWDC发布的全新的编程语言。 Swift是一种高性能系统编程语言，提供了对现有C和OC代码框架的无缝访问，并且是内存安全的。 Swift语言更加简洁，是一门类型安全的语言。 Swift和OC的区别 编程范式 Swift可以 面试协议编程、函数式编程和面向对象编程 OC以 面向对象编程 为主，当然你可以引入 Reactive Cocoa 的类库来进行函数式编程 类型安全 Swift是一门 类型安全的语言。鼓励程序员在代码中清楚明确值的类型。如果代码中使用一个字符串String，那么你不能错误地传递一个整型Int给它。因为Swift是类型安全的，它会在代码编译的时候做类型检查，并且把所有不匹配的类型作为一个错误标记出来。这样使得程序员在开发中尽可能早地发现和修正错误。 而OC则 不是类型安全的语言，你声明一个NSString变量，仍然可以传递一个NSNumber给它，尽管编译器会抱怨，但是你仍然可以作为NSNumber来使用它。 值类型的增强 在Swift中，典型的有 struct、enum 以及 元祖tuple 都是值类型。而平时使用的Int、Double、Float 、String 、Array 、Dictionary、Set其实都是用结构体实现的，也是 值类型。 OC中，NSNumber、NSString以及集合类对象都是指针类型。 枚举增强 Swift的枚举可以使用 整型、浮点型、字符串等，还能拥有 属性和方法，甚至支持 泛型、协议、扩展等。 OC里面的枚举则鸡肋很多。 泛型 Swift中 支持泛型，也支持泛型的类型约束等特性 苹果推出了Swift2.0版本，为了让开发者从OC更好的国度到Swift上，苹果也为OC带来了Gennerics泛型支持，不过OC的泛型约束也仅停留在编译器警告阶段。 协议和扩展 Swift对协议的支持更加丰富，配合扩展（extension）、泛型、关联类型等可以实现面向协议编程，从而大大提高代码的灵活性。同时swift中的protocol还可以用于值类型，如结构体和枚举 OC的协议却反强约束，提供optional特性往往成为很多问题得来源，而如果放弃optional又会让实现代价过大。 函数和闭包 Swift函数是一等公民，可以直接定义函数类型变量，可以作为其他函数参数传递，可以作为函数的返回值类型。 OC里面函数仍然是次等公民，需要selector封装或者使用block才能模拟Swift中类似的效果。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]}]}