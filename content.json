{"meta":{"title":"张建的博客","subtitle":"成功的道路上只有荆棘，没有坦途","description":"我是小J，关注我","author":"小J","url":"https://www.bboyzj.cn"},"pages":[{"title":"categories","date":"2023-03-01T04:01:29.000Z","updated":"2023-03-01T04:01:29.226Z","comments":true,"path":"categories/index.html","permalink":"https://www.bboyzj.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-01T03:07:03.000Z","updated":"2023-03-01T03:07:47.616Z","comments":true,"path":"tags/index.html","permalink":"https://www.bboyzj.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"OC组件化03：面向协议Protocol Class的使用","slug":"OC组件化03：面向协议Protocol-Class的使用","date":"2023-03-04T08:16:42.000Z","updated":"2023-03-04T13:10:48.149Z","comments":true,"path":"2023/03/04/OC组件化03：面向协议Protocol-Class的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AEProtocol-Class%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"面向接口 Protocol Class 在 URL Scheme路由 和 target-action 方案中，都存在 硬编码、参数不明确问题：URL 、Target_ 、 Action_ 的硬编码，参数都是通过字典的形式传递，类型不明确。 面向接口 的方式能够很好的解决这两个问题。 实现方式 中间件先注册 Protocol 和 Class 对应关系，将 protocol 和 对应的类 进行 字典 匹配 中间件返回 Protocol 对应的 Class，然后动态创建实例 解决硬编码问题 示例 创建 ZJProtocol.h 协议类文件 12345678910// 将各个模块的协议统一放在一个文件中 ，在各个模块中依赖这个文件，实现其协议@protocol OneMoudleProtocol &lt;NSObject&gt;@required // 返回模块one+ (UIViewController *)oneMoudleVC;@end@protocol OneDetailMoudleProtocol &lt;NSObject&gt;@required+ (UIViewController *)oneDetailMoudleVC;@end 创建 ZJMediator 协议管理类 ZJMediator.h 文件下： 12345678@interface ZJMediator : NSObject// 单例+ (instancetype)shareManager;// 注册绑定- (void)registerProtocol:(Protocol *)protocol class:(Class)cls;// 获取类- (Class)classFromProtocol:(Protocol *)protocol;@end ZJMediator.m 文件下： 1234567891011121314151617181920212223242526272829303132#import &quot;ZJMediator.h&quot;@interface ZJMediator ()@property (nonatomic,strong)NSMutableDictionary * protocolCache;@end@implementation ZJMediator+ (instancetype)shareManager&#123; static ZJMediator * mediator; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; mediator = [[ZJMediator alloc] init]; &#125;); return mediator;&#125;// 注册绑定- (void)registerProtocol:(Protocol *)protocol class:(Class)cls&#123; if (protocol &amp;&amp; cls) &#123; [self.protocolCache setObject:cls forKey:NSStringFromProtocol(protocol)]; &#125;&#125;// 获取类- (Class)classFromProtocol:(Protocol *)protocol&#123; return [self.protocolCache objectForKey:NSStringFromProtocol(protocol)];&#125;// 懒加载- (NSMutableDictionary *)protocolCache&#123; if (!_protocolCache) &#123; _protocolCache = @&#123;&#125;.mutableCopy; &#125; return _protocolCache;&#125;@end 创建 OneDetailMoudleEntry 模块 12345678910111213141516#import &quot;OneDetailMoudleEntry.h&quot;#import &quot;ZJOneDetailViewController.h&quot;@interface OneDetailMoudleEntry ()&lt;OneDetailMoudleProtocol&gt;@end@implementation OneDetailMoudleEntry+ (void)load&#123; [[ZJMediator shareManager] registerProtocol:@protocol(OneDetailMoudleProtocol) class:[self class]];&#125;// 继承+ (UIViewController *)oneDetailMoudleVC&#123; ZJOneDetailViewController * detailVC = [[ZJOneDetailViewController alloc] init]; return detailVC;&#125;@end 在任何地方调用 1234567//下一页的点击事件- (void)next:(UIButton *)sender&#123; Class cls = [[ZJMediator shareManager] classFromProtocol:@protocol(OneDetailMoudleProtocol)]; UIViewController * detailVC = [cls oneDetailMoudleVC]; [self.navigationController pushViewController:detailVC animated:YES];&#125;","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"OC组件化03：基于RuntTime的target-action的使用","slug":"OC组件化03：基于RuntTime的target-action的使用","date":"2023-03-04T08:16:13.000Z","updated":"2023-03-04T08:36:56.954Z","comments":true,"path":"2023/03/04/OC组件化03：基于RuntTime的target-action的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E5%9F%BA%E4%BA%8ERuntTime%E7%9A%84target-action%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"优缺点 优点： 缺点：硬编码问题、参数不明确问题，参数都是通过字典的形式传递，类型不明确。","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"OC组件化02：基于URL Scheme的使用","slug":"OC组件化02：基于URL-Scheme的使用","date":"2023-03-04T08:15:30.000Z","updated":"2023-03-04T08:33:30.674Z","comments":true,"path":"2023/03/04/OC组件化02：基于URL-Scheme的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%9602%EF%BC%9A%E5%9F%BA%E4%BA%8EURL-Scheme%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"URL Scheme 路由 使 URL Scheme 处理本地的跳转 通过中间层进行注册 &amp; 调用（load方法里面把被调用者注册到中间层） 注册表无需使用反射 非懒加载 | 注册表的维护 | 参数 原理目前iOS上大部分路由工具都是基于URL进行匹配或命名的，通过runtime方法进行动态调用 优缺点 优点：实现简单 缺点：存在硬编码问题，参数都是通过字典的形式传递，类型不明确 URL Scheme 路由示例1","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"OC组件化01：组件化介绍","slug":"OC组件化01：组件化介绍","date":"2023-03-04T06:05:40.000Z","updated":"2023-03-04T08:19:35.267Z","comments":true,"path":"2023/03/04/OC组件化01：组件化介绍/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%9601%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"什么组件化 组件化开发就是将一个臃肿的、单一的项目，根据 功能/业务/技术 等进行拆分，形成一个个独立的功能组件，然后借助 Cocoapods 管理工具将其任意组合，集成一个完整的项目。 你可以将 AFNetworking、SDWebImage、Bugly、MLeaksFinder 等三方库理解为工程的一部分，属于 基础组件模块，我们要做的就是将项目划分多个独立功能模块，再集成一个完整的项目。 组件化组件化能够帮助我们将大部分项目拆解成数个小组件，开发者只需要关注组件所依赖的其他组件，而无需关心完整项目的其他部分，每个组件可以自己采取所习惯的架构模式：MVC、MVVM等，就行开发一款个人独立的App那样自由 非组件化： 代码高耦合度、高依赖 项目复杂、臃肿、编译时间过长（影响调试） 难以融合、集成其他产品 … 组件化： 代码复用性提高，可方便集成到其他项目 项目可配置，方便集成和功能回退 方便组件并行开发 可方便单元测试 … 组件化分层项目组件化，最难的就是 粒度 问题，需要开发者根据自己的经验把控。这里给出个人认为的层次划分： 【基础组件】：宏定义&#x2F;常量&#x2F;自定义工具类，如常用的自定义分类【功能组件】：项目中常用的功能，如地图&#x2F;消息推送&#x2F;分享&#x2F;登录等【业务组件】：项目中的模块&#x2F;业务，如文章详情&#x2F;个人中心等【中间组件】：负责项目中的路由&#x2F;消息通知&#x2F;传参&#x2F;回调等【宿主工程】：项目容器，用来集成组件，调整各个组件之间的消息传递容器 中间层几种方案在组件化中，中间层是各个组件的通信桥梁，中间层在组件化过程中扮演着非常重要的角色。 中间层的三种方式： 基于 URL Scheme 的 路由 基于 Runtime 的 target-action 面向接口 的 Protocol - Class 基于 URL Scheme 的三方库iOS 中支持的 URL Scheme 让我们能够在 应用之间、应用内部传递消息。 JLRoutes routable-ios HHRouter 具体怎么使用，可以自行去探索 基于 Runtime 的 target-action相比 url scheme 的提前注册、实现服务，CTMediator 借助 OC 运行时的特性，现实组件之间服务的自动发现，无需提前注册即可实现组件间的调用，因此，这种方案的可维护性、可读性、扩展性相对较高。 CTMediator 面向接口 Protocol - Class Protocol - Class 面向接口的方案通常由两部分组成，一个是用来管理接口协议的类（ModuleManager），一个是具体的接口协议（ComponentProtocol）。 ModuleManager 负责消息的调用和转发，ComponentProtocol 文件定义了业务组件可以提供的功能服务。 组件化的核心工具 组件化工程，需要一个宿主工程，负责集成所有的组件。每个组件都是一个单独的工程，通过 Git 私有仓库来管理。 所有组件都上传到 Git 仓库并支持 cocoapods 集成。主工程通过配置 Podfile 文件，然后一键 pod update 即可。使用 Cocoapods 来管理组件主要因为其本身功能强大，方便的集成整个项目，解放对依赖库的管理。使用组件化的集成方式，可以很好的避免传统项目中的代码冲突问题。 组件化的核心工具就是 CocoaPods ，我们要做的就是将组件项目上传到 Gitee码云 或者 Gitlab极狐，编写项目的 podSpec 文件让组件支持 CocoaPods 集成即可。","categories":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}],"tags":[{"name":"组件化开发","slug":"组件化开发","permalink":"https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"}],"keywords":[{"name":"Component","slug":"Component","permalink":"https://www.bboyzj.cn/categories/Component/"}]},{"title":"Swift学习36：对象","slug":"Swift学习36：对象","date":"2023-03-03T16:37:01.000Z","updated":"2023-03-03T16:37:01.597Z","comments":true,"path":"2023/03/04/Swift学习36：对象/","link":"","permalink":"https://www.bboyzj.cn/2023/03/04/Swift%E5%AD%A6%E4%B9%A036%EF%BC%9A%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习35：函数式编程","slug":"Swift学习35：函数式编程","date":"2023-03-03T14:56:24.000Z","updated":"2023-03-03T14:56:24.662Z","comments":true,"path":"2023/03/03/Swift学习35：函数式编程/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A035%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习34：闭包","slug":"Swift学习34：闭包","date":"2023-03-03T14:56:01.000Z","updated":"2023-03-03T16:29:27.954Z","comments":true,"path":"2023/03/03/Swift学习34：闭包/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A034%EF%BC%9A%E9%97%AD%E5%8C%85/","excerpt":"","text":"","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习33：函数","slug":"Swift学习33：函数","date":"2023-03-03T14:54:55.000Z","updated":"2023-03-03T17:08:35.520Z","comments":true,"path":"2023/03/03/Swift学习33：函数/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A033%EF%BC%9A%E5%87%BD%E6%95%B0/","excerpt":"","text":"Swift中如何定义和使用函数基本概念 函数是一个独立的代码块，用来执行特定的任务。通过给函数一个名字来定义它的功能，并且在需要的时候，通过这个名字来 调用 函数执行它的任务 Swift统一的函数语法十分灵活。可以从简单的无形式参数到复杂的每个形式参数都带有局部和外部形式参数名。形式参数提供一个默认值来简化函数的调用，可被当做输入输出形式参数被传递，在函数执行完成时修改传递进来的变量。 Swift中每一个函数都有类型，由函数的形式参数类型和返回类型组成 。可以像swift中其它类型来使用它。可以将函数当一个形式参数传递到另外一个函数中。也可以在一个函数中返回另一个函数。同时也可以写在其他函数内部在内嵌范围封装有用的功能。 函数是 引用类型 的，不是值类型的 定义和调用函数 当你定义一个函数时，可以 选择定义一个或多个形式参数类型，也可以定义返回类型 每个函数都有函数名，藐视执行的任务。 使用函数可通过 函数名 并且 传入 函数的 实际参数 （即形式参数类型的输入值 ）来 调用函数。 实际参数顺序必须符合形式参数的列表顺序 无形式参数的函数 函数不要求必须传入一个参数，可以没有形式参数 函数定义需要在名字的后面加一个圆括号，即使没有形式参数也得加 调用函数的时候也要在函数的名字后面加一个圆括号 多形式参数的函数 函数可以输入多个形式参数，写在圆括号内，用逗号分割 123func manyPara(a:Int,b:Int) &#123; pring(&quot;\\(a) \\(b)&quot;)&#125; 无返回值的函数 函数定义可以没有返回类型，即没有返回箭头 -&gt; 或返回类型 严格上，函数还是有一个返回类型的，尽管没有定义返回值，实际上返回一个特殊的类型 void。它是一个空的元组，作用相当于没有元素的元组，写作() 123func manyTuple() -&gt; void &#123; return nil&#125; 多返回值的函数 可以让函数返回多个值作为一个复合的返回值，你可以使用元组类型作为返回类型 123func manyTuple() -&gt; (a:Int,b:String) &#123; return (1,&quot;aaa&quot;)&#125; 可选元组返回类型 如果在函数返回类型中元组可能 没有值，可以用可选元组说明元组可能是 nil 写法是可选元组圆括号后面加一个问号 ？，例如 (Int,Int)? 或 (String,Int,Bool)? 示例： 1234567891011121314151617181920212223// 返回元组func minMax(arr: [Int]) -&gt; (min:Int,max:Int)? &#123; if arr.isEmpty &#123; return nil &#125; var minValue = arr[0] var maxValue = arr[0] for value in arr &#123; if value &lt; minValue &#123; minValue = value &#125; if value &gt; maxValue &#123; maxValue = value &#125; &#125; return (minValue,maxValue)&#125;// 绑定if let minMaxValue = minMax(arr: [1,3,4,2,5]) &#123; print(&quot;min is \\(minMaxValue.min),max is \\(minMaxValue.max)&quot;)&#125; 编译运行，查看打印结果： 1min is 1,max is 5 隐士返回函数 如果整个函数体是一个单一的表达式，那么函数隐士返回这个表达式 1234func greet(person: String) -&gt; String&#123; &quot;Hello,&quot; + person + &quot;!&quot;&#125;print(&quot;\\(greet(person: &quot;World&quot;))&quot;) 打印结果 1Hello,World! Swift形式参数和返回值实参标签和形参名 每一个函数的形式参数都包含实际参数标签和形式参数名。 形式参数必须有唯一的名字，有助于代码易读 1234func someFunc(firstParamName:Int,secondParamName:Int)&#123; // 形式参数 firstParamName secondParamName&#125;someFunc(firstParamName: 1, secondParamName: 2) 指定实际参数标签 形式参数名之前写实际参数标签，用 空格 分割 如果你为 形式参数 定义了 实际参数标签，那么在调用函数的时候必须使用 实际参数标签 实际参数标签能够让函数的调用更加明确，更像自然语言，更可读，更清晰表达你的意图 12345// 实际参数标签 homefunc greet(person: String, from home: String) -&gt; String &#123; return &quot;Hello \\(person)! my home is \\(home)&quot;&#125;print(greet(person: &quot;ZJ&quot;,from: &quot;BeiJing&quot;)) 打印结果： 1Hello ZJ! my home is BeiJing 省略实际参数标签 可以利用下划线 _ 替代显示的实际参数标签 1234func greet(_ person: String, _ home: String) -&gt; String &#123; return &quot;Hello \\(person)! my home is \\(home)&quot;&#125;print(greet(person: &quot;ZJ&quot;,from: &quot;BeiJing&quot;)) 默认形式参数值 可以在形式参数类型后，给类型定义一个默认值 如果定义了默认值，你就可以在调用的时候省略这个形式参数 123456789func someFunc(paramDefault: Int = 10) &#123; print(&quot;\\(paramDefault)&quot;)&#125;someFunc(paramDefault: 6)someFunc()===========610 可变形式参数 一个可变的形式参数可以接受零或多个特定类型的值。 通过在形式参数类型名后插入三个点符号 ... 来书写可变形式参数。 传入到可变参数中的值在函数的主体中被当做是对应类型的 数组。 1234567891011func changeFunc(_ numbers: Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total / Double(numbers.count)&#125;changeFunc(1,2,3,4,5)=============3 输入输出形式参数 可变形式参数只能在函数的内部做改变。如果你想函数能修改一个形式参数的值，而且这些改变在函数结束之后依然生效，那么就需要将形式参数定义为输入输出形式参数 输入输出形式参数：在形式参数前边加 inout 关键字。 只能把 变量 作为输入输出形式参数的 实际参数，在将变量作为实际参数传入给输入输出形式参数时，在它前边添加一个符号 &amp; 来明确可以被函数修改 输入输出形式参数不能有默认值，可变形式参数不能被标记为 inout 12345678910111213// 输入输出形式参数func swapTwoInt(_ a: inout Int, _ b: inout Int) &#123; let temp = a a = b b = temp&#125;var one = 10var two = 20swapTwoInt(&amp;one,&amp;two)print(&quot;\\(one) \\(two)&quot;)=========20 10 函数类型和内嵌函数","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习32：Dictionary字典底层实现探索","slug":"Swift学习32：Dictionary字典底层实现探索","date":"2023-03-03T14:54:19.000Z","updated":"2023-03-03T14:54:19.622Z","comments":true,"path":"2023/03/03/Swift学习32：Dictionary字典底层实现探索/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A032%EF%BC%9ADictionary%E5%AD%97%E5%85%B8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习32：Dictionary字典","slug":"Swift学习32：Dictionary字典","date":"2023-03-03T14:54:00.000Z","updated":"2023-03-03T14:54:00.489Z","comments":true,"path":"2023/03/03/Swift学习32：Dictionary字典/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A032%EF%BC%9ADictionary%E5%AD%97%E5%85%B8/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习31：Set底层实现探究","slug":"Swift学习31：Set底层实现探究","date":"2023-03-03T14:53:34.000Z","updated":"2023-03-03T14:53:34.196Z","comments":true,"path":"2023/03/03/Swift学习31：Set底层实现探究/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A031%EF%BC%9ASet%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%A9%B6/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习30：Set集合","slug":"Swift学习30：Set集合","date":"2023-03-03T14:52:43.000Z","updated":"2023-03-03T14:52:43.195Z","comments":true,"path":"2023/03/03/Swift学习30：Set集合/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A030%EF%BC%9ASet%E9%9B%86%E5%90%88/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习29：如何用数组来实现栈和队列","slug":"Swift学习29：如何用数组来实现栈和队列","date":"2023-03-03T14:51:03.000Z","updated":"2023-03-03T14:51:03.634Z","comments":true,"path":"2023/03/03/Swift学习29：如何用数组来实现栈和队列/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A029%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习28：数组的底层实现","slug":"Swift学习28：数组的底层实现","date":"2023-03-03T14:50:24.000Z","updated":"2023-03-03T14:50:24.173Z","comments":true,"path":"2023/03/03/Swift学习28：数组的底层实现/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A028%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习27：访问和操作数组","slug":"Swift学习27：访问和操作数组","date":"2023-03-03T14:49:55.000Z","updated":"2023-03-03T14:49:55.779Z","comments":true,"path":"2023/03/03/Swift学习27：访问和操作数组/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A027%EF%BC%9A%E8%AE%BF%E9%97%AE%E5%92%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Swift学习26：创建数组的几种方式","slug":"Swift学习26：创建数组的几种方式","date":"2023-03-03T14:49:30.000Z","updated":"2023-03-03T14:49:30.624Z","comments":true,"path":"2023/03/03/Swift学习26：创建数组的几种方式/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A026%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"OC三方框架01：bugly搜集Crash","slug":"OC三方框架01：bugly搜集Crash","date":"2023-03-03T08:17:48.000Z","updated":"2023-03-03T12:11:09.074Z","comments":true,"path":"2023/03/03/OC三方框架01：bugly搜集Crash/","link":"","permalink":"https://www.bboyzj.cn/2023/03/03/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B601%EF%BC%9Abugly%E6%90%9C%E9%9B%86Crash/","excerpt":"","text":"Bugly 介绍为了能够快速并准确的定位用户 App 发生 Crash 的代码位置，Bugly 使用 符号表文件 对发生 Crash 的程序 堆栈 进行 解析和还原 举例： Bugly 上传方式 Bugly 已不再支持直接上传dSYM文件，需要 下载工具包手动上传 本文主要介绍 下载工具包手动上传 安装java运行环境 终端查看是否已安装 1234zhangjian@zhangjiandeMBP ~ % java -versionjava version &quot;1.8.0_291&quot;Java(TM) SE Runtime Environment (build 1.8.0_291-b10)Java HotSpot(TM) 64-Bit Server VM (build 25.291-b10, mixed mode) 上面的显示表示已安装 未安装的情况如下： 到 Java官网 下载 jdk，如下图： 下载完成之后打开 dmg，安装、一路下一步即可安装成功。 在终端输入 java -version 可以查看 java 版本，如果输出信息和上面类似，表示安装成功 获取 dSYM 文件 什么是 dSYM 文件？ 在 iOS 平台中，dSYM文件是指 具有调试信息的目标文件，文件名通常为 xxx.app.dSYM 【注】：为了方便找回 Crash 对应的 dSYM文件 和 还原堆栈，建议每次 构建或发布App版本 时，备份好 dSYM文件 获取 dSYM 方式 我们可以配置 Edit Scheme -&gt; Archives 打包 Debug 和 Release 两种环境，去获取 dSYM文件，本文以 Release 发布环境为例 配置打包环境 Release Show in Finder -&gt; 显示包内容，找到 dSYM文件 最后，在桌面或任意位置，新建一个文件夹如 appdSYM ，将 xxx.app.dSYM 拷贝进来 至此，获取 dSYM文件 完成 工具手动上传符号表 下载 Bugly iOS 符号表 上传工具，如下图： 我们需要用到的是 buglySymboliOS.jar 文件，单独放在一个新建的空文件夹如 buglySymboliOS 里面 下载后得到 buglyqq-upload-symbol 文件，解压里面 jar包，得到 buglySymboliOS.jar 包 通过终端命令行上传 1java -jar buglyqq-upload-symbol.jar -appid c4f4e4dc67 -appkey cb791b15-dbe1-44d9-bd33-b3fe558b773b -bundleid cn.epod.srsf -version 1.6.2 -platform IOS -inputSymbol /Users/mac/Desktop/appdSYM/中图云书房.app.dSYM 【参数说明】： -addid ：在 bugly 上对应的 appid c4f4e4dc67-appkey ：在 bugly 上对应的 appkey-bundleid ： iOS平台的 bundle id cn.epod.srsf-version ：版本号 1.6.2-platform ：平台（注意大小写）IOS Android-inputSymbol ：dSYM调试文件 &#x2F;Users&#x2F;mac&#x2F;Desktop&#x2F;appdSYM&#x2F;中图云书房.app.dSYM 项目中使用 项目需要集成cocoapods三方依赖管理工具，用cocoapods集成 Bugly SDK 12345678910111213141516171819202122232425platform :ios, &#x27;9.0&#x27;# 忽略所有警告inhibit_all_warnings!target &#x27;SRSF&#x27; do # Comment the next line if you don&#x27;t want to use dynamic frameworks use_frameworks! # Pods for SRSF # 官方提示：三方动态库最好最多是6个 # Bugly pod &#x27;Bugly&#x27; target &#x27;SRSFTests&#x27; do inherit! :search_paths # Pods for testing end target &#x27;SRSFUITests&#x27; do # Pods for testing endend 使用 1234567#pragma mark -Bugly- (void)startBugly&#123; BuglyConfig * config = [[BuglyConfig alloc] init]; config.debugMode = YES; // Debug信息开关 config.reportLogLevel = BuglyLogLevelWarn; // 设置为BuglyLogLevelWarn，则在崩溃时会上报Warn、Error接口打印的日志 [Bugly startWithAppId:@&quot;AppId&quot; config:config];&#125;","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-三方框架","slug":"OC-三方框架","permalink":"https://www.bboyzj.cn/tags/OC-%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"性能优化02：卡顿检测","slug":"性能优化02：卡顿检测","date":"2023-03-02T15:32:46.000Z","updated":"2023-03-02T15:32:46.851Z","comments":true,"path":"2023/03/02/性能优化02：卡顿检测/","link":"","permalink":"https://www.bboyzj.cn/2023/03/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602%EF%BC%9A%E5%8D%A1%E9%A1%BF%E6%A3%80%E6%B5%8B/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"性能优化01：内存泄漏检测","slug":"性能优化01：内存泄漏检测","date":"2023-03-02T15:32:21.000Z","updated":"2023-03-02T15:32:21.654Z","comments":true,"path":"2023/03/02/性能优化01：内存泄漏检测/","link":"","permalink":"https://www.bboyzj.cn/2023/03/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"OC学习03：内存管理","slug":"OC学习03：内存管理","date":"2023-03-02T10:51:48.000Z","updated":"2023-03-03T08:09:37.232Z","comments":true,"path":"2023/03/02/OC学习03：内存管理/","link":"","permalink":"https://www.bboyzj.cn/2023/03/02/OC%E5%AD%A6%E4%B9%A003%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"前言本文主要介绍 内存的五大区 、函数栈 和 内存管理 内存五大区在iOS中，内存主要分为 栈区、堆区、全局区、常量区、代码区 五个区域，如下图所示： 栈区定义 栈是 系统数据结构，其对应的 进程或者线程是唯一的 栈是 向低地址扩展 的数据结构 栈是一块 连续的内存区域，遵循 先进后出（FILO） 原则 栈区一般在 运行时 分配 存储 栈区是由 编译器自动分配并释放的，主要用来存储 局部变量 函数的参数，例如函数的隐藏参数（id self, SEL _cmd） 优缺点 优点：因为栈是由 编译器自动分配并释放 的，不会产生内存碎片，所以 快速高效 确定：栈的 内存大小有限制，数据不灵活 iOS主线程大小是1MB 其他线程是 512KB MAC 只有 8MB 以上内存大小的说明，在Threading Programming Guide 中有相关说明，如下图： 堆区定义 堆是 向高地址扩展 的数据结构 堆是 不连续的内存区域，类似于 链表结构（便于增删，不便于查询），遵循 先进先出（FIFO）原则 堆的 地址空间 在iOS中是是动态的 堆区的分配一般是以在 运行时分配 存储 堆区是 由程序员动态分配和释放 的，如果程序员不释放，程序结束后，可能由操作系统回收，主要用于存放： OC 中使用 alloc 、 new 开辟空间创建 对象 ，或者 block经过copy后 C 语言中使用 malloc、calloc、realloc 分配的空间，需要 free 释放 一般一个 new/alloc 就要对应一个 release，在 ARC 下编译器会自动在合适位置为 OC 对象添加 release 操作，会在当前 线程Runloop退出或休眠时销毁这些对象。MRC 则需程序员手动释放。 优缺点 优点：灵活方便，数据适应面广泛 缺点：需 手动管理、速度慢，容易产生内存碎片 当需要访问堆中数据时，一般需要 先通过对象读取到栈区的指针地址，然后通过 指针地址访问堆区 全局区（静态区，即.bss &amp; .data）全局区是 编译时分配 的内存空间，在程序运行过程中，此内存中的数据一直存在，程序结束后由系统释放，主要存放： 未初始化的全局变量和静态变量，即BSS区（.bss） 已初始化的全局变量和静态变量，即DATA区（.data） 其中，全局变量 是指变量值可以在 运行时被动态修改，而 静态变量 是 static 修饰的变量，包含 静态局部变量 和 静态全局变量 常量区（即.rodata）常量区是 编译时分配 的内存空间，在 程序结束后由系统释放，主要存放： 已经使用了的，且没有指向的 字符串常量 字符串常量因为可能在程序中被多次使用，所以在程序运行之前就会提前分配内存 代码区（即.text）代码区是 由编译时分配，主要用于存放 程序运行时的代码，代码会被编译成 二进制存进内存 的 内存五大区验证运行下面的一段代码，看看变量在内存中是如何分配的： 1234567891011121314int a = 10; // 全局区（已初始化的全局变量）char * b; // 全局区(未初始化的全局变量)- (void)test&#123; NSInteger i = 123; // 栈区（局部变量） NSLog(@&quot;i的内存地址：%p&quot;, &amp;i); NSString *string = @&quot;ZJ&quot;; // 常量区（字符串常量） NSLog(@&quot;string的内存地址：%p&quot;, string); NSLog(@&quot;&amp;string的内存地址：%p&quot;, &amp;string); NSObject *obj = [[NSObject alloc] init]; // 堆区（alloc对象） NSLog(@&quot;obj的内存地址：%p&quot;, obj); NSLog(@&quot;&amp;obj的内存地址：%p&quot;, &amp;obj); &#125; 运行结果如下： 123452022-03-11 14:34:25.438913+0800 内存五大区[70321:4340509] i的内存地址：0x16f6f5a182022-03-11 14:34:25.438976+0800 内存五大区[70321:4340509] string的内存地址：0x1007100982022-03-11 14:34:25.438997+0800 内存五大区[70321:4340509] &amp;string的内存地址：0x16f6f5a102022-03-11 14:34:25.439014+0800 内存五大区[70321:4340509] obj的内存地址：0x280fa0bc02022-03-11 14:34:25.439031+0800 内存五大区[70321:4340509] &amp;obj的内存地址：0x16f6f5a08 对于 局部变量i， 存放在栈区 对于 字符串对象string，分别打印了 string得对象地址 和 string对象的指针地址 string的 对象地址 是是存放在 常量区 string 对象的指针地址，是存放在 栈区 对于 alloc创建的对象obj，分别打印了 obj得对象地址 和 obj对象的指针地址 obj的 对象地址 是存放在 堆区 obj 对象的指针地址 是存放在 栈区 函数栈 函数栈 又称为 栈区，在内存中从高地址往低地址分配，与堆区相对，具体图示请看上面 栈帧 是指 函数（运行中且未完成）占用的一块独立的连续内存区域 应用中新创建的 每个线程都有专用的栈空间，栈可以在线程期间自由使用，而线程中有千千万万的函数调用，这些函数 共享 进程的这个 栈空间。每个函数所使用的栈空间是一个栈帧，所有栈帧就组成了这个线程完成的栈 函数调用是发生在栈上 的，每个 函数的相关信息（例如局部变量、调用记录等）都 存储在一个栈帧 中，每执行一次 函数调用，就会生成一个与其相关的栈帧，然后将其 栈帧压入函数栈，而当函数 执行结束，则将此函数对应的 栈帧出栈并释放掉 如下图所示，是经典图- ARM的栈帧布局方式 其中 main stack frame 为调用函数的栈帧 func1 stack frame 为当前 当前函数（被调用者）的栈帧 栈底 在 高 地址，栈向下增长 FP 就是 栈基址，它指向函数的 栈帧起始地址 SP 则是函数的 栈指针，它指向 栈顶 的位置 ARM压栈 的 顺序 很是规则（也比较容易被黑客攻破），依次为 当前函数指针PC、返回指针LR、栈指针SP、栈基址FP、传入参数个数及指针、本地变量 和 临时变量。如果函数准备调用另一个函数，跳转之前临时变量区先要保存另一个函数的参数 ARM 也可以 用栈基址和栈指针明确标示栈帧的位置，栈指针SP一直移动，ARM的特点是，两个栈空间内的地址（SP+FP）前面，必然有两个代码地址（PC+LP）明确标示着调用函数位置内的某个地址 堆栈溢出一般情况下应用程序是不需要考虑堆和栈的大小的，但是事实上堆和栈不是无上限的，过多的递归会导致栈溢出，过多的alloc变量会导致堆溢出 所以 预防堆栈溢出 的方法： 避免层次过深 的 递归 调用 不要使用过多的局部变量，控制局部变量的大小 避免分配 占用空间 太大的对象，并 及时释放 实在不行，适当的情景下 调用系统API修改线程的堆栈大小 栈帧示例描述下面代码的栈帧变化 栈帧程序示例 1234567891011int Add(int x,int y) &#123; int z = 0; z = x + y; return z;&#125;int main() &#123; int a = 10; int b = 20; int ret = Add(a, b);&#125; 程序执行时，栈区中栈帧的变化如下图所示： 内存管理概述 在iOS中开发中，我们或多或少都听说过内存管理。iOS的内存管理一般指的是OC对象的内存管理，因为OC对象分配在堆内存，堆内存需要程序员自己去动态分配和回收；基础数据类型(非OC对象)则分配在栈内存中，超过作用域就会由系统检测回收。如果我们在开发过程中，对内存管理得不到位，就有可能造成内存泄露。 我们通常讲的内存管理，实际上从发展的角度来说，分为两个阶段：MRC和ARC。 MRC指的是 手动内存管理，在开发过程中需要开发者手动去编写内存管理的代码； ARC指的是 自动内存管理，在此内存管理模式下由LLVM编译器和OC运行时库生成相应内存管理的代码。 引用计数 在 OC 中，使用 引用计数 来 进行内存管理。 每个对象都有一个与其相对应的引用计数器，当持有一个对象，这个对象的引用计数就会递增；当这个对象的某个持有被释放，这个对象的引用计数就会递减。当这个对象的引用计数变为0，那么这个对象就会被系统回收。 当一个对象使用完没有释放，此时其引用计数永远大于1。该对象就会一直占用其分配在堆内存的空间，就会导致内存泄露。内存泄露到一定程度有可能导致内存溢出，进而导致程序崩溃。 MRC 简介 全称 Manual Reference Counting，管理通过使用 retain, release, 以及 autorelease 的消息发送来实现。 retain: 持有（拥有）对象，对象引用数加 1 release: 释放对象，对象引用数减 1 autorelease: 通知系统，在 @autoreleasepool 代码块结束时，对对象调用 release 管理原则 自己创建的对象，自己获得拥有权 在苹果规定中，使用 alloc/new/copy/mutableCopy 创建返回的对象归调用者所有，例如以下 1234/* NSMutableArray类对象A */NSMutableArray *array = [[NSMutableArray alloc] init]; NSLog(@&quot;%p&quot;, array);[array release]; // 释放 由于对象 A 由 alloc 生成，符合苹果规定，指针变量array指向并持有对象A，引用计数器会加 1。另外，array在使用完对象A后需要对其进行释放。当调用release后，释放了其对对象A的引用，计数器减1。对象A此时引用计数值为零，所以对象A被回收。不能访问已经被回收的对象，会发生崩溃。 别人创建的对象，可以通过 retain 来获得拥有权 123456789// 例如已有 fooArray, 通过 array 方法获得其引用NSArray *bar = [fooArray array];// 不可以直接调用 release，因为没有拥有权// [bar release];// 需要先 retain 来获得拥有权，然后才能释放[bar retain];[bar release]; 你所拥有的对象不再需要使用时，必须将其释放 不能释放你不拥有的对象 retain retain和属性 我们可以通过属性来保存对象，如果一个属性为强引用，我们就可以通过属性的实例变量和存取方法来对某个对象进行操作，例如某个属性的setter方法如下： 12345678910- (void)setPerson:(Person *)person &#123; [person retain]; [_person release]; _person = person; &#125; 我们通过 retain新值，release旧值，再给实例变量更新值。 需要注意的一点是：需要先retain新值，再release旧值。因为如果新旧值是同一个对象的话，先release就有可能导致该对象被系统回收，再去retain就没有任何意义了。例如下面这个例子： 123456789101112131415161718192021222324252627282930#import &quot;ViewController.h&quot;#import &quot;Person.h&quot;@interface ViewController ()@property (nonatomic, strong)Person *person;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // 实例变量持有Person类对象(P对象)。这样赋值不会调用set方法 _person = [[Person alloc] init]; // 调用set方法 self.person = _person; &#125;- (void)setPerson:(Person *)person &#123; // release释放对P对象的引用，P对象引用计数值变为零，则P对象被系统回收 [_person release]; // 由于P对象已经被回收，再去retain就容易出问题 [person retain]; _person = person;&#125;@end 由于P对象被回收，对应其所分配的内存被置于 可用内存池 中。如果该内存未被覆写，那么P对象依然有效；如果内存被覆写，那么实例变量_person就会指向一个被覆写的未知对象的指针，那么实例变量就变成一个 悬挂指针。 retain和数组 如果我们把一个对象加入到一个数组中，那么该数组的addObject方法会对该对象调用retain方法。例如以下代码： 12345678// person获得并持有P对象，P对象引用计数为1Person *person = [[Person alloc] init]; // Person类对象生成的P对象 NSMutableArray *array = [NSMutableArray array]; // person被加入到数组，对象P引用计数值为2[array addObject:person]; 此时，对象P被person和array两个变量同时持有。 release 自己持有的对象自己释放 当我们持有一个对象，如果在不需要继续使用该对象，我们需要对其进行释放(release)。例如以下代码： 12345678// array获得并持有NSArray类对象NSArray *array = [[NSArray alloc] init]; // 当不再需要使用该对象时，需要释放[array release]; // obj获得但不持有该对象id obj = [NSArray array]; 非自己持有的对象不要释放 当我们不持有某个对象，却对该对象进行释放，应用程序就会崩溃。 12345678// 获得并持有A对象Person *p = [[Person alloc] init]; // Person类对象A // 对象A引用计数为零，所以对象A被回收[p release];// 释放非自己持有的对象[p release]; 另外，我们也不能访问某个已经被释放的对象，该对象所占的堆空间如果被覆写就会发生崩溃的情况。 autorelease autorelease 指的是自动释放，当一个对象收到 autorelease 的时候，该 对象就会被注册到当前处于栈顶的自动释放池（autorelease pool）。如果没有主动生成自动释放池，则当前自动释放池对应的是主运行循环的自动释放池。在当前线程的RunLoop进入休眠前，就会对被注册到该自动释放池的所有对象进行一次release操作。 autorelease和release的区别是： release：是马上释放对某个对象的强引用； autorelease：是延迟释放某个对象的生命周期。 12345678910111213141516171819202122232425&#123; // 外部调用 Person *p = [Person person]; NSLog(@&quot;%p&quot;, p); //使用无须retain // 持有则需要retain [p retain]; _person = p; [_person release];&#125;// Person类内部定义+ (id)person &#123; //创建的Person类对象由person获得并持有 Person *person = [[Person alloc] init]; // [person release]; // 将 person 对象放入自动释放池 [person autorelease]; return person;&#125; 在外部调用，从方法名person知道，创建的对象由p指针变量获得但不持有。在函数内部，person获得并持有了Person类对象，所返回的person对象的引用计数加1。换句话说，调用者需要额外处理这多出来的一个持有操作。另外，我们不能在函数内部调用release，不然对象还没返回就已经被系统回收。这时候使用autorelease就能很好地解决这个问题。 只要把要返回的对象调用autorelease方法，注册到自动释放池就能延长person对象的生命周期，使其在 autorelease pool销毁(drain)前依然能够存活。 另外，person对象在返回时调用了 autorelease方法。该对象已经在自动释放池中，我们可以直接使用对象p，无须再通过[p retain]访问；不过，如果要用实例变量持有该对象，则需要对变量p进行一次retain操作，实例变量使用完该对象需要释放该对象。 autorelease pool autorelease pool 和 RunLoop(运行循环) 当应用程序启动，系统默认会 开启一条线程，该线程就是 主线程。主线程也有一个与之对应的自动释放池。 每条线程都包含一个与其对应的自动释放池，当某条线程被终止的时候，对应该线程的自动释放池会被销毁。同时，处于该自动释放池的对象将会进行一次 release 操作。 ，例如我们常见的 ARC 下的 main.h 文件： 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 该自动释放池用来释放在主线程下注册到该自动释放池的对象。 需要注意的是，当我们 开启一条子线程，并且在该线程 开启RunLoop 的时候，需要为其增加一个autorelease pool，这样有助于保证内存的安全。 autorelease pool和降低内存峰值 当我们执行一些复杂的操作，特别是如果这些复杂的操作要被循环执行，那么中间会免不了会产生一些临时变量。当被加到主线程自动释放池的对象越来越来多，却没有得到及时释放，就会导致内存溢出。这个时候，我们可以手动添加自动释放池来解决这个问题。如以下例子所示： 123456789101112for (int i = 0; i &lt; largeNumber; i++) &#123; // 创建自动释放池 NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init]; // 产生许多被注册到自动释放池的临时对象 id obj = [Person personWithComplexOperation]; // 释放池中对象 [pool drain]; &#125; 如上述例子所示，我们执行的循环次数是一个非常大的数字。并且调用personWithComplexOperation方法的过程中会产生许多临时对象，所产生的临时对象有可能会被注册到自动释放池中。我们通过手动生成一个自动释放池，并且在每次循环结束前把该自动释放池的对象执行release操作释放掉，这样就能有效地降低内存的峰值了。 ARC 概述 Automatic Reference Counting，自动引用计数，即 ARC，WWDC2011 和 iOS5 所引入的最大的变革和最激动人心的变化。ARC是新的LLVM 3.0编译器的一项特性，使用ARC，可以说举解决了广大iOS开发者所憎恨的手动内存管理的麻烦。 此处的 A 就是 automatic。其实 ARC 只是比 MRC 多了一步，就是在 编译时编译器自动帮开发者添加 retain, release 以及 autorelease 的调用，底层的内存管理机制还是和 MRC 一样。 在 ARC 模式下，我们通常在对象变量的声明里用 属性标记符 来指引 ARC 机制来管理我们的对象变量，它们是：strong, retain, weak, copy, assign。默认标记是 strong 标记符的区别 strong: 顾名思义，就是 强引用，对应 MRC 下的 retain，即引用数加 1 retain: 同 strong weak: 弱引用，不增加引用数，引用的对象被释放后变为 nil copy: 对对象进行 copy 后再赋值，因此对象必须遵循 NSCopying 协议。如： 123@property(copy)Foo *foo;...self.foo = bar; // 相当于 self.foo = [bar copy]; assign: 一般用于原始数据类型（primitive type）的赋值。可以用于对象，效果相当于 weak，可是有一个坑是当对象被释放后，assign 属性的变量不会变成 nil，而是成为 野指针（dangling pointer），因此不建议使用在对象上。 借助以上的属性标记符，我们可以在对象声明的时候集中制定它们的内存管理策略，清晰明了。 ARC的判断原则 ARC判断一个对象是否需要释放不是通过引用计数来进行判断的，而是通过强指针来进行判断的。那么什么是强指针? 强指针 默认所有对象的指针变量都是强指针 被__strong修饰的指针 12Person *p1 = [[Person alloc] init];__strong Person *p2 = [[Person alloc] init]; 弱指针 被 __weak 修饰的指针 1__weak Person *p = [[Person alloc] init]; ARC如何通过强指针来判断？ 只要还有一个强指针变量指向对象，对象就会保持在内存中 ARC的使用 123456int main(int argc, const char * argv[]) &#123; // 不用写release, main函数执行完毕后p会被自动释放 Person *p = [[Person alloc] init]; return 0;&#125; ARC的注意点 不允许调用对象的 release方法 不允许调用 autorelease方法 重写父类的dealloc方法时，不能再调用 [super dealloc]; ARC下单对象内存管理 局部变量释放对象随之被释放 12345678int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *p = [[Person alloc] init]; &#125; // 执行到这一行局部变量p释放 // 由于没有强指针指向对象, 所以对象也释放 return 0;&#125; 清空指针对象随之被释放 12345678int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *p = [[Person alloc] init]; p = nil; // 执行到这一行, 由于没有强指针指向对象, 所以对象被释放 &#125; return 0;&#125; 默认清空所有指针都是强指针 123456789int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // p1和p2都是强指针 Person *p1 = [[Person alloc] init]; __strong Person *p2 = [[Person alloc] init]; &#125; return 0;&#125; 弱指针需要明确说明 注意: 千万不要使用弱指针保存新创建的对象 12345678int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // p是弱指针, 对象会被立即释放 __weak Person *p1 = [[Person alloc] init]; NSLog(@&quot;%@&quot;,p); &#125; return 0;&#125; 打印结果： 12020-07-31 18:02:51.021697+0800 iOS-OC之ARC[2134:984503] (null) ARC下多对象内存管理 ARC和MRC一样, 想拥有某个对象必须用强指针保存对象, 但是不需要在dealloc方法中release 1234567@interface Person : NSObject// MRC写法//@property (nonatomic, retain) Dog *dog;// ARC写法@property (nonatomic, strong) Dog *dog;@end 自动释放池 概述 AutoreleasePool（自动释放池）是 OC 中的一种 内存自动回收机制。 当向一个对象发送 autorelease 消息时，会将对象加入到自动释放池，这个对象不会立即释放，而是等到 runloop休眠或超出autoreleasepool作用域 之后进行 释放。 MRC 下使用自动释放池 在MRC环境中使用自动释放池需要用到 NSAutoreleasePool 对象，其生命周期就相当于C语言变量的作用域。对于所有调用过 autorelease方法的对象，在废弃NSAutoreleasePool对象时，都将调用release实例方法。用源代码表示如下： 12345678910111213// MRC环境下的测试：// 第一步：生成并持有释放池NSAutoreleasePool对象;NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];// 第二步：调用对象的autorelease实例方法;id obj = [[NSObject alloc] init];[obj autorelease];// 第三步：废弃NSAutoreleasePool对象;[pool drain]; // 向pool管理的所有对象发送消息，相当于[obj release]// obj已经释放，再次调用会崩溃(Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT))NSLog(@&quot;打印obj：%@&quot;, obj); ARC 下使用自动释放池 ARC环境不能使用NSAutoreleasePool类也不能调用autorelease方法，代替它们实现对象自动释放的是 @autoreleasepool块。 12345// ARC环境下的测试：@autoreleasepool &#123; id obj = [[NSObject alloc] init]; NSLog(@&quot;打印obj：%@&quot;, obj); &#125; ARC 下 AutoReleasePool 内部实现使用@autoreleasepool{}我们在main函数中写入自动释放池相关的测试代码如下： 123456int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125; 为了探究释放池的底层实现，我们在终端使用 clang -rewrite-objc + 文件名命令将上述OC代码转化为 C++ 源码： 123456789int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_d37e0d_mi_0); &#125; // 大括号对应释放池的作用域 return 0;&#125; 在经过编译器 clang 命令转化后，我们看到的所谓的 @autoreleasePool块，其实对应着__AtAutoreleasePool的结构体。 分析结构体 __AtAutoreleasePool 的具体实现在源码中找到 __AtAutoreleasePool结构体 的实现代码，具体如下： 12345678extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; void * atautoreleasepoolobj;&#125;; __AtAutoreleasePool结构体包含了：构造函数、析构函数和一个对象； 构造函数内部调用：objc_autoreleasePoolPush() 方法，返回对象atautoreleasepoolobj 析构函数内部调用：objc_autoreleasePoolPop() 方法，传入对象atautoreleasepoolobj 分析main函数中 __autoreleasepool结构体实例的生命周期是这样的： __autoreleasepool是一个自动变量，其构造函数是在程序执行到声明这个对象的位置时调用的，而其析构函数则是在程序执行到离开这个对象的作用域时调用。所以，我们可以将上面main函数的代码简化如下： 12345678int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; void *atautoreleasepoolobj = objc_autoreleasePoolPush(); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kb_06b822gn59df4d1zt99361xw0000gn_T_main_d39a79_mi_0); objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; return 0;&#125; objc_autoreleasePoolPush 与 objc_autoreleasePoolPop进一步观察自动释放池构造函数与析构函数的实现，其实它们都只是对AutoreleasePoolPage 对应静态方法 push 和 pop 的封装： 1234567void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; 理解 AutoreleasePoolPageAutoreleasePoolPage 是一个 C++ 中的类，打开Runtime的源码工程，在NSObject.mm文件中可以找到它的定义，摘取其中的关键代码如下： 123456789101112131415161718192021class AutoreleasePoolPage &#123;# define EMPTY_POOL_PLACEHOLDER ((id*)1) // 空池占位# define POOL_BOUNDARY nil // 即哨兵对象 static pthread_key_t const key = AUTORELEASE_POOL_KEY; static uint8_t const SCRIBBLE = 0xA3; // 0xA3A3A3A3 after releasing static size_t const SIZE = #if PROTECT_AUTORELEASEPOOL PAGE_MAX_SIZE; // must be multiple of vm page size#else PAGE_MAX_SIZE; // size and alignment, power of 2#endif static size_t const COUNT = SIZE / sizeof(id); magic_t const magic; // 校验AutoreleasePagePoolPage结构是否完整 id *next; // 指向新加入的autorelease对象的下一个位置，初始化时指向begin() pthread_t const thread; // 当前所在线程，AutoreleasePool是和线程一一对应的 AutoreleasePoolPage * const parent; // 指向父节点page，第一个结点的parent值为nil AutoreleasePoolPage *child; // 指向子节点page，最后一个结点的child值为nil uint32_t const depth; // 链表深度，节点个数 uint32_t hiwat; // 数据容纳的一个上限 //......&#125;; AutoreleasePoolPage 中拥有 parent 和 child 指针，分别指向上一个和下一个 page；当前一个page的空间被占满(每个AutorelePoolPage的大小为4096字节)时，就会新建一个AutorelePoolPage对象并连接到链表中，后来的Autorelease对象也会添加到新的page中；另外，当next&#x3D;&#x3D; begin()时，表示AutoreleasePoolPage为空；当next &#x3D;&#x3D; end()，表示AutoreleasePoolPage已满。 理解 哨兵对象(POOL_BOUNDARY)的作用，而它的作用事实上也就是为了 起到一个标识的作用。 每当自动释放池初始化调用 objc_autoreleasePoolPush 方法时，总会通过 AutoreleasePoolPage 的 push 方法，将 POOL_BOUNDARY 放到当前 page 的栈顶，并且返回这个对象 atautoreleasepoolobj； 而在自动释放池释放调用 objc_autoreleasePoolPop 方法时，又会将 atautoreleasepoolobj对象 以参数传入，这样自动释放池就会向释放池中对象发送release消息，直至找到第一个边界对象为止。 理解 objc_autoreleasePoolPush 方法经过前面的分析，objc_autoreleasePoolPush 最终调用的是 AutoreleasePoolPage 的 push 方法，该方法的具体实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static inline void *push() &#123; return autoreleaseFast(POOL_BOUNDARY);&#125;static inline id *autoreleaseFast(id obj)&#123; AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123; return page-&gt;add(obj); &#125; else if (page) &#123; return autoreleaseFullPage(obj, page); &#125; else &#123;1. return autoreleaseNoPage(obj); &#125;&#125;// 压栈操作：将对象加入AutoreleaseNoPage并移动栈顶的指针id *add(id obj) &#123; id *ret = next; *next = obj; next++; return ret;&#125;// 当前hotPage已满时调用static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123; do &#123; if (page-&gt;child) page = page-&gt;child; else page = new AutoreleasePoolPage(page); &#125; while (page-&gt;full()); setHotPage(page); return page-&gt;add(obj);&#125;// 当前hotpage不存在时调用static id *autoreleaseNoPage(id obj) &#123; AutoreleasePoolPage *page = new AutoreleasePoolPage(nil); setHotPage(page); if (obj != POOL_SENTINEL) &#123; page-&gt;add(POOL_SENTINEL); &#125; return page-&gt;add(obj);&#125; 观察上述代码，每次调用 push 其实就是 创建一个新的AutoreleasePoolPage，在对应的AutoreleasePoolPage中插入一个 POOL_BOUNDARY ，并且返回插入的 POOL_BOUNDARY 的内存地址。自动释放池最终都会通过 page-&gt;add(obj) 方法 将对象添加到page中，而这一过程被分为三种情况： * 当前page存在且不满，调用 `page-&gt;add(obj)` 方法将 `对象` 添加至page的栈中，即next指向的位置 * 当前page存在但是已满，调用 autoreleaseFullPage 初始化一个新的 page，调用page-&gt;add(obj)方法将对象添加至page的栈中 * 当前page不存在时，调用 autoreleaseNoPage 创建一个 hotPage，再调用page-&gt;add(obj) 方法将对象添加至page的栈中 理解 objc_autoreleasePoolPop 方法 AutoreleasePool 的释放调用的是 objc_autoreleasePoolPop 方法，此时需要传入 atautoreleasepoolobj 对象作为参数。 同理，我们找到 objc_autoreleasePoolPop 最终调用的方法，即 AutoreleasePoolPage 的pop方法，该方法的具体实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041static inline void pop(void *token) // POOL_BOUNDARY的地址&#123; AutoreleasePoolPage *page; id *stop; page = pageForPointer(token); // 通过POOL_BOUNDARY找到对应的page stop = (id *)token; if (DebugPoolAllocation &amp;&amp; *stop != POOL_SENTINEL) &#123; // This check is not valid with DebugPoolAllocation off // after an autorelease with a pool page but no pool in place. _objc_fatal(&quot;invalid or prematurely-freed autorelease pool %p; &quot;, token); &#125; if (PrintPoolHiwat) printHiwat(); // 记录最高水位标记 page-&gt;releaseUntil(stop); // 向栈中的对象发送release消息，直到遇到第一个哨兵对象 // memory: delete empty children // 删除空掉的节点 if (DebugPoolAllocation &amp;&amp; page-&gt;empty()) &#123; // special case: delete everything during page-per-pool debugging AutoreleasePoolPage *parent = page-&gt;parent; page-&gt;kill(); setHotPage(parent); &#125; else if (DebugMissingPools &amp;&amp; page-&gt;empty() &amp;&amp; !page-&gt;parent) &#123; // special case: delete everything for pop(top) // when debugging missing autorelease pools page-&gt;kill(); setHotPage(nil); &#125; else if (page-&gt;child) &#123; // hysteresis: keep one empty child if page is more than half full if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125; &#125;&#125; 【总结】【结构】： 自动释放池的压栈和出栈，通过结构体的构造函数和析构函数实现： 压栈：调用 objc_autoreleasePoolPush() 函数，内部调用的是 AutoreleasePoolPage 的 push() 方法，返回 atautoreleasepoolobj 对象 出栈：调用 objc_autoreleasePololPop() 函数，内部调用的是 AutoreleasePoolPage 的 pop() 方法，传入 atautoreleasepoolobj 对象 【容量】： 池页大小为4096字节，每一页都包含56字节的成员变量，但一个自动释放池中，只会压栈一个哨兵对象，占8字节 【原理】： 自动释放池的本质是 __AtAutoreleasePool 结构体，包含构造函数和析构函数 结构体声明，触发构造函数，调用 objc_autoreleasePoolPush() 函数，对象压栈 如果存在page，并且没有存满，调用add函数 将对象压栈 如果存在page，但存储已满，调用autoreleaseFullPage函数 遍历链表，找到最后一个空白的子页面 对其进行创建新页 设置为热页面 添加对象 否则，不存在page，调用autoreleaseNoPage函数 通过父类AutoreleasePoolPageData进行初始化 begin：获取对象压栈的起始位置 objc_thread_self：通过tls获取当前线程 链接双向链表 设置为热页面 pushExtraBoundary为YES，哨兵对象压栈 对象压栈 结构体出作用域，触发析构函数，调用 objc_autoreleasePoolPop() 函数，对象出栈 调用popPage函数，传入stop为哨兵对象的位置 当前页中对象出栈，到stop位置停止 调用kill函数，销毁当前页面 AutoreleasePool在主线程上的释放时机 分析主线程RunLoop管理自动释放池并释放对象的详细过程，我们在如下Demo中的主线程中设置断点，并执行lldb命令：po [NSRunLoop currentRunLoop]，具体效果如下： 我们看到主线程RunLoop中有两个与自动释放池相关的Observer,对应CFRunLoopActivity的类型如下: 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), //0x1，启动Runloop循环 kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //0xa0，即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), kCFRunLoopExit = (1UL &lt;&lt; 7), //0xa0，退出RunLoop循环 kCFRunLoopAllActivities = 0x0FFFFFFFU &#125;; 结合RunLoop监听的事件类型，分析主线程上自动释放池的使用过程如下： App启动后，苹果在主线程RunLoop里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler(); 第一个Observer监视的事件 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。 第二个Observer监视了两个事件 : BeforeWaiting(准备进入休眠) 时调用 _objc_autoreleasePoolPop() 和_objc_autoreleasePoolPush() 释放旧的池并创建新池； Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄漏，开发者也不必显示创建AutoreleasePool了; 之后的时机 程序启动到加载完成后，主线程对应的RunLoop会停下来等待用户交互 用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。 RunLoop检测到事件后，就会创建自动释放池; 所有的延迟释放对象都会被添加到这个池子中; 在一次完整的运行循环结束之前，会向池中所有对象发送release消息，然后自动释放池被销毁; AutoreleasePool子线程上的释放时机子线程默认不开启RunLoop，那么其中的延时对象该如何释放呢？其实这依然要从Thread和AutoreleasePool的关系来考虑： 就是说，每一个线程都会维护自己的 Autoreleasepool栈，所以子线程虽然默认没有开启RunLoop，但是依然存在AutoreleasePool，在 子线程退出 的时候会去释放autorelease对象。 前面讲到过，ARC会根据一些情况进行优化，添加__autoreleasing修饰符，其实这就相当于对需要延时释放的对象调用了autorelease方法。从源码分析的角度来看，如果子线程中没有创建AutoreleasePool ，而一旦产生了Autorelease对象，就会调用autoreleaseNoPage方法自动创建hotpage，并将对象加入到其栈中。所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。 AutoreleasePool需要手动添加的情况 尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建 AutoreleasePool，而其中的延时对象将在当前释放池的作用域结束时释放。苹果文档中说明了三种情况，我们可能会需要手动添加自动释放池： 编写的不是基于UI框架的程序，例如命令行工具； 通过循环方式创建大量临时对象； 使用非Cocoa程序创建的子线程； 而在ARC环境下的实际开发中，我们最常遇到的也是第二种情况，以下面的代码为例： 1234567- (void)viewDidLoad &#123; [super viewDidLoad]; for (int i = 0; i &lt; 1000000; i++) &#123; NSObject *obj = [[NSObject alloc] init]; NSLog(@&quot;打印obj：%@&quot;, obj); &#125; &#125; 上述代码中，obj因为离开作用域所以会被加入最近一次创建的自动释放池中，而这个释放池就是主线程上的RunLoop管理的；因为for循环在当前线程没有执行完毕，Runloop也就没有完成当前这一次的迭代，所以导致大量对象被延时释放。释放池中的对象将会在viewDidAppear方法执行前就被销毁。在此情况下，我们就有必要通过手动干预的方式及时释放不需要的对象，减少内存消耗；优化的代码如下： 123456789- (void)viewDidLoad &#123; [super viewDidLoad]; for (int i = 0; i &lt; 1000000; i++) &#123; @autoreleasepool&#123; NSObject *obj = [[NSObject alloc] init]; NSLog(@&quot;打印obj：%@&quot;, obj); &#125; &#125; &#125;","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"OC学习02：文件导入#include,#import,@class区别","slug":"OC学习02：文件导入#include,#import,@class区别","date":"2023-03-02T08:39:08.000Z","updated":"2023-03-02T10:13:48.926Z","comments":true,"path":"2023/03/02/OC学习02：文件导入#include,#import,@class区别/","link":"","permalink":"https://www.bboyzj.cn/2023/03/02/OC%E5%AD%A6%E4%B9%A002%EF%BC%9A%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5#include,#import,@class%E5%8C%BA%E5%88%AB/","excerpt":"","text":"前言 #include 、 #import 和 @class 都是用来 包含头文件 C/C++ 只能用 #include 包含头文件，没有 #import 和 @class OC 中 #include 、 #import 和 @class 都可以用 那么问题来了，三种包含头文件方式在 OC 中有什么区别呢？ include、import #include 会重复导入头文件，重复导入会报重复定义的错误；#import 不会重复导入头文件，允许交叉编译 #include &lt;xxx.h&gt; 或 #import &lt;xxx.h&gt; ：用于导入 系统自带文件，在 系统文件目录下查找 #include “xxx.h” 或 #import “xxx.h” ：用于导入 用户自定义的文件，查找顺序：用户文件目录 -&gt; 安装文件目录 -&gt; 系统文件目录，所以 “xxx.h” 一般用来导入用户自定义的文件 class @class XXXClassName ： 用于声明一个类，用于解决互相引用的问题（A引用B，B引用A） include 示例 A文件导入两次B文件：报重复定义错误 12345678910#import &lt;UIKit/UIKit.h&gt;// include 不允许重复导入两次#include &quot;VB.h&quot;#include &quot;VB.h&quot;NS_ASSUME_NONNULL_BEGIN@interface VA : UIView@end command + b 编译报错： A引用B，B引用C，A再引用C：同样 报重复定义错误，相当于A引用了两次C import 示例 导入两次A文件，不报错 123// 导入两次A文件#import &quot;A.h&quot;#import &quot;A.h&quot; class 使用场景 A类引用B类，B类引用A：互相引用报错 A.h文件 12345#import &lt;UIKit/UIKit.h&gt;#import &quot;B.h&quot;@interface A : UIView@property (nonatomic,strong)B * b;@end B.h文件 12345#import &lt;UIKit/UIKit.h&gt;#import &quot;A.h&quot;@interface B : UIView@property (nonatomic,strong)A * a;@end 可以用 @class 方式进行引用，一个用@class或者两个都用 @class 1234//#import &quot;A.h&quot;// class声明A@class A;","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"Blog-05：Picgo+Gitee图床","slug":"Blog-05：Picgo-Gitee图床","date":"2023-03-01T11:25:22.000Z","updated":"2023-03-02T16:23:50.879Z","comments":true,"path":"2023/03/01/Blog-05：Picgo-Gitee图床/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog-05%EF%BC%9APicgo-Gitee%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"背景最近发现上传到 GitHub 上的图片大部分不能使用了，然后上网查了一下，应该是 DNS 的问题，网上也有很多解决方案，有兴趣的可以去网上找找，本文主要介绍 Picgo + Gitee 做图床。 Picgo 介绍picgo 是一款功能实用、操作简捷的图床工具，图床工具简单来说就是本地图片上传自动转换成链接的一款工具。 picgo 本体支持如下图床： 七牛图床 v1.0 腾讯云 COS v4\\v5 版本 v1.1 &amp; v1.5.0 又拍云 v1.2.0 GitHub v1.5.0 SM.MS V2 v2.3.0-beta.0 阿里云 OSS v1.6.0 Imgur v1.6.0 Tips: 本体不再增加默认的图床支持。你可以自行开发第三方图床插件。 特色功能 支持拖拽图片上传 支持快捷键上传剪贴板里第一张图片 Windows 和 macOS 支持右键图片文件通过菜单上传 (v2.1.0+) 上传图片后自动复制链接到剪贴板 支持自定义复制到剪贴板的链接格式 支持修改快捷键，默认快速上传快捷键：command+shift+p（macOS） | control+shift+p（Windows\\Linux） 支持插件系统，已有插件支持 Gitee、青云等第三方图床 Tips: 请确保你安装了 Node.js， 并且版本 &gt;&#x3D; 8。 默认上传图床为 SM.MS。picgo 上传之后，会自动将上传成功的 URL复制到你的剪贴板，支持5种复制格式。 Mini窗口只支持Windows（圆形）和Linux（方形），macOS可以使用顶部栏图标。（因为Windows和Linux的任务栏不支持拖拽事件） 准备 nodejs 环境 picgo 客户端 picgo 的 Gitee 上传插件 git、Gitee 账号和一个公开仓库 安装 nodejs官网 安装 点击链接下载安装 nodejs，安装完成后，查看版本 12345mac@bogon ~ % node -vv18.14.2mac@bogon ~ % npm -vmac@bogon ~ % npm -v9.5.0 安装 picgo 客户端 picgo安装链接 如果电脑是 Intel 就选 x64，如果电脑是 M1 就选 arm64 安装 git Mac 默认是已经安装好了 git 注册&#x2F;登录 Gitee 账号 Gitee 首页按要求自行注册&#x2F;登录即可 新建一个 Gitee 仓库 仓库名：随意，如 Picgo私有创建 将仓库 开源 由于创建仓库的时候只能 私有，所以此步配置 开源 操作如下： 进入仓库 -&gt; 管理 -&gt; 基本信息 -&gt; 开源（空仓库不允许） -&gt; 保存 生成 Token Token 用于 picgo 操作 Gitee repository： 点击头像 -&gt; 设置 -&gt; 私人令牌 -&gt; 生成新令牌 -&gt; 提交 复制你生成的令牌，只显示一次，再次刷新则看不见了，因此你要保存好 配置 picgo 启动 picgo -&gt; 插件设置 -&gt; 搜索 Gitee -&gt; 点击插件图标 安装 即可，本文使用 gitee 2.0.5 插件来进行演示 Tips： 插件装完后，重启生效 配置 Gitee 插件进入 图床设置 -&gt; gitee， 依次填入相关配置如下所示，填写如下： repo： 用户名&#x2F;仓库名（必填）， bboy-zhang-jian/picgo path: 上传路径，仓库里的图片保存路径（非必填） token: 私人令牌（必填），刚才保存的 token message: 提交消息（非必填） path: 上传路径，仓库里的图片保存路径（非必填） customPath: 定制路径（非必填） customUrl: 图片定制URL（非必填） 将仓库开源头像 -&gt; 仓库 -&gt; 管理 -&gt; 公开 -&gt; 仓库公开须知全部 勾选 上传图片 将图片拖动到 上传区 里 快捷键 Ctrl + shift + p ERROR Plugin load failed: hexo-renderer-scss1mac@bogon Blog % npm install hexo-renderer-scss 出现 Error: Cannot find module ‘node-sass’1mac@bogon Blog % npm install node-sass 不用管了，版本不一致导致的","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"OC学习01：事件传递链和响应链","slug":"OC学习01：事件传递链和响应链","date":"2023-03-01T09:30:34.000Z","updated":"2023-03-02T08:54:15.933Z","comments":true,"path":"2023/03/01/OC学习01：事件传递链和响应链/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/","excerpt":"","text":"前言在 iOS 中只有继承 UIResponder 的 对象 才能够接收并处理事件，UIResponder 是所有响应对象的 基类。继承关系如下： UIApplication -&gt; UIResponder -&gt; NSObject UIViewController -&gt; UIResponder -&gt; NSObject UIWindow -&gt; UIViww -&gt; UIResponder -&gt; NSObject UIButton -&gt; UIControl -&gt; UIView -&gt; UIResponder -&gt; NSObject UIView -&gt; UIResponder -&gt; NSObject 事件链 传递链：由系统向离用户最近的view传递。顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; RootViewController -&gt; subViews 响应链：由离用户最近的view向系统传递。顺序： superViews –&gt; RootViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate 传递链 事件传递的两个核心方法 1234// 返回哪个视图进行事件响应- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event; // 判断某一个点击的位置是否在视图范围内- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event; 其中 UIView 不接受事件处理的情况有 hidden &#x3D; YES 视图被隐藏 userInteractionEnabled &#x3D; NO 不接受响应事件 alpha &lt;&#x3D; 0.01,透明视图不接收响应事件 子视图超出父视图范围 需响应视图被其他视图盖住 是否重写了其父视图以及自身的hitTest方法 是否重写了其父视图以及自身的pointInside方法 流程描述 当iOS程序发生触摸事件后，系统会利用 Runloop 将事件加入到 UIApplication 的任务队列中 UIApplication 分发触摸事件到 UIWindow 然后 UIWindow 依次向下分发给 UIView UIView 调用 hitTest:withEvent: 方法返回一个最终响应的视图 在 hitTest:withEvent: 方法中就会去调用 pointInside: withEvent: 去判断当前点击的 point 是否在 UIView 范围内，如果是的话，就会去 逆序遍历 它的子视图来查找最终响应的 子视图 遍历的方式是使用 倒序 的方式来遍历子视图，也就是说最后添加的子视图会最先遍历，在每一个视图中都会去调用它的 hitTest:withEvent: 方法，可以理解为是一个 递归调用 最终会返回一个响应视图，如果返回视图有值，那么这个视图就作为最终响应视图，结束整个事件传递；如果没有值，那么就会将UIView作为响应者 响应链响应者链的事件传递过程 如果 view 的控制器存在，就传递给控制器处理；如果控制器不存在，则传递给它的 父视图 在视图层次结构的最顶层，如果也不能处理收到的事件，则将事件传递给 UIWindow 对象进行处理 如果 UIWindow 对象也不处理，则将事件传递给 UIApplication 对象 如果 UIApplication 也不能处理该事件，则将该事件丢弃 面试题 实现一个按钮的点击范围扩大效果 思路：自定义一个按钮，重写 poinstInSide 方法，增大内边距，返回一个新的bounds 1234567891011#import &quot;ZJBtn.h&quot;@implementation ZJBtn- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; // 当前btn大小 CGRect btnBounds = self.bounds; // 扩大按钮的点击范围，增大内边距 btnBounds = CGRectInset(btnBounds, -50, -50); // 若点击的点在新的bounds里，返回YES return CGRectContainsPoint(btnBounds, point);&#125;@end 子视图超过父视图部分仍然能响应 思路：正常情况下子视图超出部分是不能响应事件的，需重写 hitTest:withEvent 方法，指定 子视图 可点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#import &quot;VA.h&quot;@interface VA ()@property (nonatomic,strong)UIButton * btn;@end@implementation VA- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; [self addSubview:self.btn]; &#125; return self;&#125;- (void)clickBtn&#123; NSLog(@&quot;%s&quot;,__func__);&#125;- (UIButton *)btn&#123; if (!_btn) &#123; _btn = [[UIButton alloc] initWithFrame:CGRectMake(-50, 20, self.frame.size.width + 100, 100)]; _btn.backgroundColor = [UIColor blueColor]; [_btn addTarget:self action:@selector(clickBtn) forControlEvents:UIControlEventTouchUpInside]; &#125; return _btn;&#125;/* 子视图超过父视图部分，需要点击超出范围的部分也有相应 */- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // 判断btn能否接收事件 if (self.btn.userInteractionEnabled == NO || self.btn.hidden == YES || self.btn.alpha &lt;= 0.01) &#123; return nil; &#125; // 把当前点转换成btn坐标系上的点 CGPoint btnP = [self convertPoint:point toView:self.btn]; // 当触摸点在btn上时，才让按钮相应事件 if ([self.btn pointInside:btnP withEvent:event]) &#123; NSLog(@&quot;%@&quot;,NSStringFromCGPoint(btnP)); return self.btn; &#125; NSLog(@&quot;父视图相应&quot;); return [super hitTest:point withEvent:event];&#125;@end","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-学习","slug":"OC-学习","permalink":"https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"iOS面试题：Swift","slug":"iOS面试题：Swift","date":"2023-03-01T08:57:50.000Z","updated":"2023-03-03T17:04:42.180Z","comments":true,"path":"2023/03/01/iOS面试题：Swift/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASwift/","excerpt":"","text":"swift 和 oc 的区别？ swift 是静态语言，有类型判断。OC 是动态语言。 swift 可以面向 函数、协议、对象 编程；oc以面向 对象 编程为主，可以引入 Reactive Cocoa类库 来进行函数式编程 Swift 是 类型安全 的语言。OC 不是类型安全的语言。 Swift 大部分都是 值类型，少部分是 引用类型。OC 有的是 值类型，有的是 指针类型。 swift类型？Swiift 值类型 和 引用类型的区别？特点？ swift的类型分为 值类型 和 引用类型。 值类型：在swift中定义的很多类型都是值类型：如 struct、enum、Int、Float、Bool、String、Array、Dictionary、String 等都是 值类型。 引用类型： class类型、closure闭包、函数 为引用类型 区别 值类型：传递和赋值时是一个 副本，使用过程中不会影响 源数据 引用类型：传递和赋值是 本身（内存地址），使用过程中会影响源数据 常用的关键字 final： 只能用于 类 中，修饰的 方法、属性，不能被重写 final 修饰的类，不能被继承 inout：输入输出形式参数 将函数的参数由 值类型 转为 引用类型 mutating： 涉及到修改自身内存用 #available 用来判断平台和操作系统 @available 用于修饰 方法、属性、协议、扩展，用来表达它的可用性 闭包的类型常用的三方框架 Alamofire：网络加载 SwiftyJSON：JSON解析 R.swift：使用资源文件 Snapkit：自动布局 MonkeyKing：将内容分享到社交平台 Kingfisher：网络图片加载和缓存","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-面试题","slug":"Swift-面试题","permalink":"https://www.bboyzj.cn/tags/Swift-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"iOS面试题：OC","slug":"iOS面试题：OC","date":"2023-03-01T08:57:33.000Z","updated":"2023-03-03T06:58:57.652Z","comments":true,"path":"2023/03/01/iOS面试题：OC/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AOC/","excerpt":"","text":"OC算法1. 冒泡排序1）依次比较相邻两个元素，顺序错误则交换位置；需要两层循环，外层循环控制趟数，内层循环控制比较次数 2）例子： 123456789101112NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;5&quot;,@&quot;4&quot;]]; // 外循环控制排序趟数,进行 array.count-1 趟 for (int i = 0; i &lt; arr.count; i ++) &#123; // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序 for (int j = 0; j &lt; arr.count - i - 1; j++) &#123; // 相邻元素比较，若逆序则交换 if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123; [arr exchangeObjectAtIndex:j withObjectAtIndex:j + 1]; &#125; &#125; &#125; 2. 选择排序1）从第一个元素与其他元素比较找到最小值，重复操作，直到最后一位结束；需要两层循环，外层循环趟数，里层循环比较次数 2）例子 1234567891011NSMutableArray * arr = [NSMutableArray arrayWithObjects:@&quot;2&quot;,@&quot;1&quot;,@&quot;5&quot;,@&quot;3&quot;, nil];// 外循环控制排序趟数,进行 array.count-1 趟for (int i = 0; i &lt; arr.count; i ++) &#123; // 里循环获比较换位 for (int j = i + 1; j &lt; arr.count; j ++) &#123; if ([arr[i] intValue] &gt; [arr[j] intValue]) &#123; [arr exchangeObjectAtIndex:i withObjectAtIndex:j]; &#125; &#125;&#125;NSLog(@&quot;arr:%@&quot;,arr); 3. 直接插入排序1） 始终定义第一个元素为 已排序 的，将剩余元素定义为 未排序 逐个插入到 已排序 的排列中；不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去 2）例子 12345678910111213141516171819NSMutableArray * arr = @[@2,@1,@3,@5,@4].mutableCopy;// 插入排序的原理：始终定义第一个元素为有序的，将元素逐个插入到有序的排列中// 其特点是：不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去for(int i = 0;i &lt; arr.count;i++)&#123; // 待排序值 NSNumber * temp = arr[i]; // 已排序下标 int j = i - 1; // 待排序与已排序比较，从后向前比较 while (j &gt;= 0 &amp;&amp; [arr[j] integerValue] &gt; [temp integerValue]) &#123; // 如果已排序的 &gt; 待排序的 往后移动一个位置 [arr replaceObjectAtIndex:(j + 1) withObject:arr[j]]; j --; &#125; // 空出来的位置插入新元素 [arr replaceObjectAtIndex:(j + 1) withObject:temp]; NSLog(@&quot;arr:%@&quot;,arr);&#125; 打印结果： 12345672022-12-13 10:26:19.242271+0800 插入排序[4184:77845] arr:( 1, 2, 3, 4, 5) 4. 希尔排序1）希尔排序相当于 直接插入排序加强版，引入了 增量 的概念；直到增量为 1 时，再进行直接插入排序 2）例子 1234567891011121314151617181920212223NSMutableArray * arr = @[@7,@3,@8,@5,@2,@6,@1,@4].mutableCopy;// 其实间隔值设值为总数的一半int gap = arr.count/2;// 直到间隔小于1时结束while (gap &gt;= 1) &#123; // i 待排元素，以 步距 gap 从后向前扫描 for(int i = 0;i &lt; arr.count;i++)&#123; // 待排元素 NSNumber * temp = arr[i]; // 当前位置 int j = i; // 跳跃式比较 while (j &gt;= gap &amp;&amp; [arr[j - gap] integerValue] &gt; [temp integerValue] ) &#123; [arr replaceObjectAtIndex:j withObject:arr[j - gap]]; j -= gap; &#125; // 空出来位置，插入待排序 [arr replaceObjectAtIndex:j withObject:temp]; &#125; // 改变步长 gap = gap/2;&#125;NSLog(@&quot;arr:%@&quot;,arr); 打印结果： 123456789102022-12-13 10:22:41.910840+0800 插入排序[4124:74568] arr:( 1, 2, 3, 4, 5, 6, 7, 8) 5. 斐波那契数列1）也就是 兔子数列，当前数是前两个数列之和 2）例子 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; NSInteger num = 10; NSInteger total = [self getTotalNum:num]; NSLog(@&quot;total:%ld&quot;,total);&#125;- (NSInteger)getTotalNum:(NSInteger)num&#123; if(num == 0)&#123; return 0; &#125; if(num == 1)&#123; return 1; &#125; return [self getTotalNum:num-2] + [self getTotalNum:num-1];&#125; 打印结果： 12022-12-13 10:28:32.672554+0800 斐波那契数列[4285:80606] total:89 6. 二分查找1）有序的数组，将数组分割成两份，利用查找的值跟中间值进行比较，如果查找的值大于中间值，就在数组的右边进行查找；如果查找的值小于中间值，就在数组的左边进行查找。如此循环的执行下去，最终找到符合的值。 2）例子 123456789101112131415161718192021222324NSArray * arr = @[@(1),@(3),@(5),@(6),@(8),@(10)];int key = [@(5) intValue];int min = 0;int max = arr.count - 1;int mid;while (min &lt;= max) &#123; // 计算中间下标 mid = (min + max) / 2; // 如果目标值 &gt; 中间下标的中间值 if (key &gt; [arr[mid] intValue]) &#123; //最小变为中间下标+1 min = mid + 1; &#125; // 如果目标值 &lt; 中间下标的中间值 else if (key &lt; [arr[mid] intValue])&#123; //最大变为中间下标-1 max = max - 1; &#125; // 否则，正好 else &#123; NSLog(@&quot;key:%d&quot;,mid); break; &#125;&#125; 打印结果： 12022-12-13 10:33:18.661324+0800 二分查找[4607:86953] key:2 7. 递归算法递归求和1+2+..+n? 1234567891011121314- (void)viewDidLoad &#123; [super viewDidLoad]; int sum = [self sum:4]; NSLog(@&quot;sum:%d&quot;,sum);&#125;- (int)sum:(int)n&#123; if (n == 1) &#123; return 1; &#125;else &#123; return [self sum:n-1] + n; &#125;&#125; 链表OC数据结构01：链表的探索 二叉树OC数据结构02：二叉树探索 OC常见的面试题什么是野指针？是一个没有指向 任何内存 的 指针，尝试使用它会导致 应用程序崩溃 什么是内存泄漏？一个 对象 没有被释放，会 内存泄漏，内存泄漏会导致应用程序占用的内存会越来越大，直到应用程序无内存可用时，会导致 应用程序崩溃 iOS 关键词有哪些？各有什么作用？ 重点 readwrite 可读可写 特性，同时生成get方法和set方法的声明和实现 readonly 只读 特性，只会生成get方法的声明和实现，不希望属性在类外改变 retain 持有 特性，retaincount 会 +1,用于 MRC nonatomic 非原子 特性 atomic 原子 特性，默认属性 atomic不是绝对线程安全的，只是对 setter/getter 方法使用了 自旋锁(spinlock_t)，内部使用 互斥锁(os_unfair_lock)，保证了 读/写 安全。 atomic并不能保证 整个对象 是线程安全的，需要对 整个对象 进行 加锁 来保证线程安全： * NSLock（互斥锁） * dispathch_semaphore（信号量） * @synchronized（互斥递归锁） assign 可以修饰 基本数据类型和对象。 通常用于修饰 基本数据类型，如Int、CGFloat、Double等，这是因为 基本数据类型放在栈区，栈由编译器自动分配和释放内存，栈先进后出，基本数据类型出栈后，assign修饰的基本数据类型就不存在了，不会出现 野指针 修饰对象，如NSString、实例对象等，引用计数不会增加，但 assign 修饰对象释放后，指针 不会被系统置为nil，会产生 野指针 或 EXC_BAD_ACCESS 错误。 strong 强引用，只修饰对象，属性默认修饰符 指向并持有该对象，其修饰的对象引用计数会 +1，引用计数不为 0 则不会被销毁，需要将其置为 nil 可以销毁。否则会出现 内存泄漏。 weak 弱引用，只修饰对象。 指向但并不拥有该对象，引用计数不增加。该对象自动在内存中销毁。 copy 用于修饰 不可变的对象。 比如NSString、NSDictionary、NSArray等。 浅拷贝和深拷贝 重点 浅拷贝 浅拷贝，拷贝了一个新的指针，与原对象指针指向同一块内存，引用计数 + 1；(A,CopyA &#x3D; [A copy]，A 变化，CopyA 的值也变化) 深拷贝 深拷贝，拷贝了一个新的对象，指向新的内存，新对象的 引用计数为 1，源对象引用计数不变；(A,MutableA &#x3D; [A mutbleCopy]，A 变化，MutableA 的值不变)。 NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？重点 对于不可变NSString&#x2F;NSArray&#x2F;NSDictionary，copy浅拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝) 对于可变NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary，copy深拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝) 自定义对象的copy和mutableCopy？ 重点 copy和mutableCopy都是深拷贝(属性：浅拷贝） 属性用copy还是strong？ 重点 对于不可变属性，推荐用copy，目的是为了 让本属性不受外界影响，无论给我传入可变还是不可变对象，我本身持有的就是一个不可变的副本，被set时，改变的是这个副本。 对于可变属性，推荐用strong，因为copy修饰后，会变成不可变对象，再调用可变对象函数时会 crash 一个APP是如何唤醒另一个APP的？ 重点URL Scheme：iOS有一个特性就是将 自身绑定 到一个自定义的 URL Scheme 上，该 scheme 用于从 浏览器或其他应用中启动本应用。 单例的写法和作用？ 重点单例模式的作用：可以保证程序运行过程中，一个类只返回一个实例，供外界访问；static保证类只分配一次内存；dispatch_once方法保证调用一次，并自动加锁，线程安全 123456789101112static id _instance = nil; // 定义static全局变量，保证只分配一次内存+ (id)shareInstance&#123; return [[self alloc] init];&#125;+ (id)copyWithZone:(struct _NSZone *)zone&#123; static dispatch_once_t onceToken; // 声明一个静态的GcD单次任务 // 保证只执行一次 dispatch_once(&amp;onceToken,^&#123; // _instance = [super allocWithZone:zone]; &#125;); return p;&#125; 这么写可以保证下面两种方式返回同一个实例： 123Single * p1 = [Single shareInstance];Single * p2 = [[Single alloc] init];NSLog(@&quot;%d&quot;,p1==p2); // 1 HTTPS和HTTP的区别？ 重点 HTTP：超文本传输协议，信息明文传输；端口号80；响应速度快（使用TCP三次握手，客户端和服务端需要交换3个包）； HTTPS：是由 HTTP+SSL&#x2F;TLS 加密传输；端口号443；响应速度慢（除了使用TCP三个包，还要加上SSL握手的9个包）；需要到CA申请证书 TCP 和 UDP 区别? 重点 都是 传输层 协议 TCP协议是 面向连接的可靠的传输层协议。UDP协议是 面向非连接的传输层协议 TCP需要 建立连接和断开连接。UDP不需要连接。 TCP传 输数据没有大小限制。UDP 传输数据有大小限制。 TCP会 处理数据丢包重发。UDP不会处理。 HTTP和socket区别？ 重点 HTTP 应用层协议；socket 不属于协议范畴，而是一个接口（API），是对TCP&#x2F;IP协议的封装 HTTP 是基于 请求-响应 形式 短连接，即客户端发送一次请求，服务端响应后立即 断开连接；socket 是基于TCP协议的 长链接，理论上 客户端和服务端一旦建立连接将不会主动断开 HTTP 传输慢，数据量大，安全差；socket 数据可自定义，数据量小，安全性高，适合信息实时交互（推送、聊天等） staitc 和 const 的区别？ 重点 const：表示 只读 的意思 const 放在 类型 前：可以改变指针的指向，可以改变指针指向的内容 const 放在 变量 前：不可以改变指针的指向，不可以改变指针指向的内容 static： 静态变量，可修饰 局部变量和全局变量，可修饰方法 static 可修饰 局部/全局变量，称为 局部静态变量和全局静态变量，只初始化一次，只分配一次内存，生命周期被改变，不再是作用域内 static 修饰的 方法，可以在不同文件下重名，互不影响运行 通用链接（Universal Links）重点 服务端配置 HTTPS 证书 和添加 apple-app-site-association 地址关联文件 移动端在plist添加 Associated Domains 关联域权限 简述GET和POST请求的区别？ 重点 GET 传输数据 有缓存；POST 传输数据 没有缓存 GET的 参数 放在 URL 的后面，并且第一个参数用 ? 号拼接，后面的从第二个参数开始，直到最后一个，用 &amp; 分割；POST的 参数 放在 请求体 里面，并且第一个参数用 , 号拼接，后面从第二开始，直到最后用 &amp; 分割; GET一般用于 获取数据；POST一般用于 向服务器提交数据 GET 的参数是暴漏在 地址栏 的，不安全；POST 的参数隐藏在 请求体 里面，相对安全一点; GET请求提交数据受浏览器限制 1k，POST请求理论上无限制。 iOS中几种常见的设计模式？ 重点 代理模式 一对一的依赖关系，当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。 观察者模式 KVO机制 和 Notification通知机制 单例模式 保证程序运行过程中，一个类只返回一个实例，供外界访问 工厂模式 通过一个类方法，根据已有模板批量生产对象。 MVC模式 Model即数据模型 view即视图 controller即控制器 RunLoop是什么？ 重点 概念 RunLoop 又叫 运行循环，内部就是一个 do-while循环，在这个循环内部不断 处理各种任务，保证程序持续运行。 目的 RunLoop存在的目的： 就是当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，提高程序性能，节省CPU资源，该做事的时候做事，该休息的时候休息 RunLoop的作用？ 重点 保持程序持续运行。 App一启动就会开启主线程，主线程在开启的时候就会开启主线程对应的RunLoop，RunLoop能保证线程不被销毁，主线程不销毁，程序就会持续运行。 处理App中各类事件。 事件响应、手势识别、界面刷新、AutoreleasePool自动释放池、NSTimer等事件处理。 节省CPU资源，提高程序性能。 如概述所述，当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，提高程序性能，节省资源，该做事的时候做事，该休息的时候休息。 可以用Runloop实现什么功能？ 重点 tableView 滚动时图片不加载 SDWebImage + Runloop，图片延迟加载，滑动不加载图片 线程保活 往 runloop 中添加 [[NSPort alloc] init] 事件， 解决NSTimer在滑动时停止工作的问题 default 模式改为 common 模式 检测卡顿 displaylink + runloop 进行卡顿检测，将数值和页面绑定上传到服务器 RunLoop接收几种输入源，系统默认定义了几种模式？ 重点 输入源有两种基于 端口 的输入源（port）自定义 的输入源（custom） 系统定义的RunLoop模式有五种，最常用的有三种，如下所示：NSDefaultRunLoopMode默认模式，主线程中默认是NSDefaultRunLoopModeUITrackingRunLoopMode视图滚动模式，RunLoop会处于该模式下NSRunLoopCommonModes并不是真正意义上的Mode，是一个占位用的“Mode”，默认包含了NSDefaultRunLoopMode和UITrackingRunLoopMode两种模式 RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？ 重点 每一个线程都有一个runloop，主线程的runloop默认启动。子线程的runloop默认不启动 mode：主要用来指定事件在运行时循环的优先级 作用：保持程序的持续运行、随时处理各种事件、节省cpu资源(没事件休息释放资源)，提高程序的性能。 怎么理解Objective-C是动态运行时语言。 重点主要是 将数据类型的确定和函数的调用由编译时推迟到了运行时。这个问题其实浅涉及到两个概念，运行时和多态。 运行时：简单来说，运行时机制使我们 直到运行时才去确定数据类型和要调用的函数。 多态：不同对象以自己的方式响应相同的消息的能力 叫做多态。 runtime项目中具体应用？ 重点 方法交换。 给 分类添加属性。 动态添加方法。 字典转模型。 数组越界。 动态获取成员属性、成员变量、实例方法 KVC是什么？重点KVC 全程 Key Value Coding，中文 键值编码，是由 NSKeyValueCoding 非正式协议启动的一种机制，对象 采用该协议来 间接访问对象的属性。 12345- (nullable id)valueForKey:(NSString *)key; - (nullable id)valueForKeyPath:(NSString *)keyPath; - (void)setValue:(nullable id)value forKey:(NSString *)key;- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; KVC底层原理： KVO是什么？重点KVO 全程 Key Value Observing，中文 键值观察，它 用于监听实例对象属性的变化。 KVO的实现原理？(KVO的本质是什么？) 重点当一个 实例对象 的 属性注册了KVO，实例对象 isa指针 的指向在注册KVO观察者之后，由 原有类 改为 中间类(NSKVONotifing_类名)；中间类 重写了 属性setter方法、class、dealloc、_isKVOA 方法；dealloc 方法中，移除 KVO 观察者之后，实例对象isa 指向由 中间类 更改为 原有类;中间类 从创建后就 一直存在内存中，不会被销毁。 KVO实际应用 重点 观察 实例对象 的 属性 变化 观察 实例对象 的 容器 变化 观察容器用： mutableArrayValueForKey KVO底层原理： category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？重点 category 原则上它 只能增加方法，不能增加成员（实例）变量。可以添加属性，但是不会自动生成实例变量_name和setter和getter方法。可以添加方法 扩展 主要用来为一个类添加额外的原来没有的 实例变量、方法和属性。extension常用的形式并不是以一个单独的.h文件存在，而是寄生在类的.m文件中。 类扩展中： 123456@interface Person ()&#123; int age; //实例变量&#125;@property (nonatomic,copy)NSString * name;//属性- (void)run;//方法@end iOS开发中有多少类型的线程？ 重点 pthread 一套用于 C 的多线程 API、适用于 Unix / Linux / Windows 等系统、跨平台、可移植、使用难度大 NSThread 使用更加面向对象、简单易用，可直接操作线程对象 GCD 旨在替代NSThread等线程技术、充分利用设备的 多核、基于 C 的底层的 API NSOperation NSOperation 是基于 GCD 之上的更高一层的封装， NSOpetation 需要配合 NSOpetationQueue 来实现多线程 根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？ 重点dispatch_group_t + dispatch_group_enter + dispatch_group_leave + dispatch_group_notify 10个网络请求顺序回调? GCD如何实现？重点dispatch_group_t + dispatch_semaphore_t：信号量（dispatch_semaphore_wait + dispatch_group_leave） GCD和NSOperation的区别？ 重点 GCD执行效率更高，而且由于队列中执行的是由block构成的任务，这是一个轻量级的数据结构，写起来更方便 GCD只支持FIFO的队列，而 NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序 NSOperationQueue甚至可以跨队列设置依赖关系，但是GCD只能通过设置串行队列，或者在队列内添加barrier(dispatch_barrier_async)任务，才能控制执行顺序,较为复杂 NSOperationQueue因为面向对象，所以 支持KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished）、是否取消（isCanceld） 具体的底层看 OC底层原理27：GCD之 NSThread &amp; GCD &amp; NSOperation 什么是Block？ 重点Block 是将 函数及其上下文封装起来的对象 Block的本质 重点 block 的 本质 是 对象、函数、结构体，由于block函数没有名称，也被称为 匿名函数 Block的分类？ 重点 分为 全局Block(_NSConcreteGlobalBlock)、栈Block(_NSConcreteStackBlock)、堆Block(_NSConcreteMallocBlock) 三种形式。 其中 栈Block存储在栈(stack)区，堆Block存储在堆(heap)区，全局Block存储在已初始化数据(.data)区。 堆：动态分配内存，需要程序员自己申请，程序员自己管理 栈：自动分配内存，自动销毁，先入后出，栈上的内容存在自动销毁的情况 具体看底层原理 OC底层原理30：Block底层原理 循环引用的几种情况和解决方式？ 重点 Block 原因： self 强引用了 block，而 block 内部又调用了 self解决： 使用 Weak-Strong Dance Delegate 原因：委托者和被委托人之间的相互强引用问题 strong解决：用 weak 进行弱引用 或者 通过中间对象(代理对象)的方式来解决(效率更加高的中间对象NSProxy：不需要进行发送消息和动态解析，直接进行消息转发) NSTimer 原因：self → timer → self(target) 的循环持有链解决：在适当的时机销毁 12[_timer invalidate];_timer = nil; OC 如何进行内存管理的？ 重点 手动内存管理 MRC 自动内存管理 ARC LLVM + Runtime 会为我们代码自动插入 retain 和 release 以及 autorelease等代码,不需要我们手动管理 自动释放池 自动释放池原理 重点 自动释放池的本质是 __AtAutoreleasePool 结构体，包含构造函数和析构函数 结构体声明，触发构造函数，调用 objc_autoreleasePoolPush() 函数，对象压栈 结构体出作用域，触发析构函数，调用 objc_autoreleasePoolPop() 函数，对象出栈 内存优化 重点 cell复用 绘制的话：用CAShaperLayer，渲染快，内存使用高效 按需加载：懒加载 合理利用缓存：比如三方图片压缩缓存 尽量使用透明View：控件有背景色增大内存消耗 启动优化 重点 pre-main 阶段：二进制重排 尽量 少用外部动态库，苹果官方建议自定义的动态库最好 不要超过6个，如果超过6个，需要 合并 动态库 减少 OC 类，因为类越多，越耗时 将不必须在 +load 方法中做的事情延迟到 +initialize 中，尽量不要用 C++ 虚函数 main 阶段：mian -&gt; didFinishLaunching 减少启动初始化的流程，能懒加载的懒加载，能延迟的延迟，能放后台初始化的放后台，尽量少占用主线程的启动时间 优化代码逻辑，去除非必须的代码逻辑，减少每个流程的消耗时间 启动阶段能 使用多线程 来初始化的，就使用多线程 尽量 使用纯代码 来进行UI框架的搭建，尤其是主UI框架，例如 UITabBarController，尽量避免使用Xib或者SB，相比纯代码而言，这种更耗时 删除废弃类、方法 卡顿监听 重点主要是用 displayLink + Runloop 进行FPS监测 主要从减轻 CPU 和 GPU 消耗入手，保证写一个 VSync 到来时，CPU 和 GPU 能够写作完成下一帧的渲染并缓存到帧缓冲区 卡顿优化在 CPU 层面： 1）尽量用轻量级的对象，比如 用不到事件处理 的地方，可以考虑使用 CALayer 取代 UIView2）不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改3）尽量 提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性4）图片的 size 最好刚好跟 UIImageView 的 size 保持一致5）控制一下线程的最大并发数量6）尽量把 耗时的操作放到子线程：如text宽高获取等 卡顿优化在 GPU层面： 1）GPU能处理的 最大纹理 尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸2）尽量 减少视图数量和层次3）减少透明的视图（alpha&lt;1），不透明的就设置 opaque 为 YES4）尽量 避免出现离屏渲染：圆角、阴影、遮罩等 tableView卡顿优化 重点 最常用的就是cell的复用， 注册复用标识符 避免cell的重新布局，初始化时就布局好 提前计算并缓存cell的高度 减少cell中控件的数量，少动态添加 view 避免背景透明 能使用局部更新 的就使用 局部更新 加载网络数据，下载图片，使用异步加载，并缓存 按需加载cell：cell滚动很快时，只加载范围内的cell 不要实现无用的代理方法，tableView只遵守两个协议 网络优化 重点 DNS优化：即域名解析优化，缓存 ip 资源优化： 图片webp，比png&#x2F;jpg小 数据传输用ProtocolBuffer代替json，数据小，序列化和反序列化也简单 请求压缩、请求合并 数据缓存 网络环境监测 针对性请求重试 TCP三次握手，四次挥手过程？重点 为什么是三次握手，而不是二次握手？ 三次握手是为了建立一个可靠的数据传输通道： 刚开始客户端和服务端处于关闭状态，而且服务端B一直处于监听状态，时刻监听是否有建立连接的请求 当客户端需要建立连接的时候就会发送一个 请求连接 的报文，此报文是 同步报文SYN=1，并且会生成一个 随机的序号seq=x，这是第一次握手 当服务端接收到请求连接报文时，会发送一个 确认连接 的报文，此报文是 同步报文SYN=1，并且 确认报文ACK=1，同时服务端也会生成一个 随机的序号seq=y，并且将 确认报文确认号ack=x+1，回传给客户端，这是第二次握手 当客户端接收到服务端的 ACK确认报文后，会回复一个 ACK确认报文，用于确认确认报文已经收到，此报文 ACK=1，seq=x+1，ack=y+1，这是第三次握手 四次挥手 四次挥手则是为了保证数据传输完成接收再关闭连接。 客户端断开连接时会发送一个 请求断开连接 的报文，此报文是 FIN=1，并且会生成一个 随机的序号seq=u，发送给服务端，这是第一次挥手 服务端接收到请求断开连接 FIN报文 后，回复一个 确认断开连接 报文 ACK=1,seq=v,ack=u+1，这是第二次挥手 当服务端数据发送完后，再发送一个FIN报文给客户端，通知客户端，服务端准备关闭连接，此报文 FIN=1,ACK=1,ack=u+1,seq=w，这是第三次挥手 当客户端收到 FIN确认报文，再发送一个FIN确认报文 ACK=1,seq=u+1,ack=w+1，并进入 TIME-WAIT 等待，等待 2MSL 后关闭连接，这是第四次挥手 事件链 重点OC学习01：事件传递链和响应链 传递链：由系统向离用户最近的view传递。顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; ViewController -&gt; subViews 响应链：由离用户最近的view向系统传递。顺序： superViews –&gt; ViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate 事件传递的两个核心方法？ 重点1234// 返回最适合处理事件的视图- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event; // 判断点是否在这个View内部- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event; 第一个方法返回的是一个 UIView，是用来寻找最终哪一个视图来响应这个事件 第二个方法是用来判断某一个点击的位置是否在视图范围内，如果在就返回YES 实现一个按钮的点击范围扩大效果 重点自定义一个按钮，继承UIButton，重写 pointInside:withEvent: 方法， 12345678- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; // 当前btn大小 CGRect btnBounds = self.bounds; // 扩大按钮的点击范围，增大内边距 btnBounds = CGRectInset(btnBounds, -10, -10); // 若点击的点在新的bounds里，返回YES return CGRectContainsPoint(btnBounds, point);&#125; 子视图超过父视图部分仍然能响应 重点重写 hitTest:withEvent 方法，让 子视图 去相应事件 123456789101112131415- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // 判断btn能否接收事件 if (self.btn.userInteractionEnabled == NO || self.btn.hidden == YES || self.btn.alpha &lt;= 0.01) &#123; return nil; &#125; // 把当前点转换成btn坐标系上的点 CGPoint btnP = [self convertPoint:point toView:self.btn]; // 当触摸点在btn上时，才让按钮相应事件 if ([self.btn pointInside:btnP withEvent:event]) &#123; NSLog(@&quot;%@&quot;,NSStringFromCGPoint(btnP)); return self.btn; &#125; NSLog(@&quot;父视图相应&quot;); return [super hitTest:point withEvent:event];&#125; 面试官问还有什么想问的？ 重点技术面不问薪资待遇，人事面问薪资待遇 问岗位： 在这个岗位上，会直接 接触到哪些类型的项目？ 这个岗位的主要职责是什么？主要的KPI是什么？ 这个岗位如何评估绩效，试用期需要达到什么指标？ 这个岗位的最大挑战是什么？ 问团队： 团队的基本情况？ 这个团队在公司的角色是什么？ 可以跟我介绍一下我的领导吗？ 问公司 公司的文化氛围是什么样的？ 员工的晋升机制是什么样的？我这个岗位的晋升机会如何？ 这个岗位所在的团队如何支持公司目标的实现？","categories":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}],"tags":[{"name":"OC-面试题","slug":"OC-面试题","permalink":"https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"OC","slug":"OC","permalink":"https://www.bboyzj.cn/categories/OC/"}]},{"title":"Blog-04：主题完善","slug":"Blog-04：主题完善","date":"2023-03-01T02:54:01.000Z","updated":"2023-03-01T17:50:03.426Z","comments":true,"path":"2023/03/01/Blog-04：主题完善/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog-04%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/","excerpt":"","text":"前言我们以 Snippet 主题问例 下载安装1mac@bogon Blog % $ git clone git://github.com/shenliyang/hexo-theme-snippet.git themes/hexo-theme-snippet 安装主题插件1mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S 部署主题具体部署看下面的链接：1、2、3步骤可省略 Snippet","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"Blog-03：Github域名绑定阿里云域名","slug":"Blog-03：Github域名绑定阿里云域名","date":"2023-03-01T02:17:25.000Z","updated":"2023-03-01T11:26:07.736Z","comments":true,"path":"2023/03/01/Blog-03：Github域名绑定阿里云域名/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog-03%EF%BC%9AGithub%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/","excerpt":"","text":"注册域名去 阿里云 注册账号、并购买域名，具体流程这里就不一一介绍了 域名解析 在终端 ping 一下之前配置的静态页面地址,可以获取到对应的ip地址: 123456mac@bogon ~ % ping BboyZJ.github.ioPING bboyzj.github.io (185.199.109.153): 56 data bytes64 bytes from 185.199.109.153: icmp_seq=0 ttl=50 time=261.217 ms64 bytes from 185.199.109.153: icmp_seq=1 ttl=50 time=337.547 ms64 bytes from 185.199.109.153: icmp_seq=2 ttl=50 time=260.716 ms... @解析 记录类型：A主机记录：@解析请求来源：默认记录值：185.199.109.153TTL：10分钟 点击确定 www解析 记录类型：CNAME主机记录：www解析线路来源：默认记录值：BboyZJ.github.ioTTL：10分钟 点击确定 配置项目 CNAME 在 Blog/source 目录下，新建 CNAME 文件，内容输入阿里云申请的域名 www.bboyzj.cn 12mac@bogon ~ % cd /Users/mac/Desktop/Blog/source mac@bogon source % touch CNAME 配置 Blog 目录下 _config.yml 文件，URL 模块 123456789# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://www.bboyzj.cnroot: /BboyZJ.github.io/permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks 执行 123mac@bogon ~ % hexo cleanmac@bogon ~ % hexo gmac@bogon ~ % hexo d 提交陈成功后，就可以在 GitHub 和 www.bboyzj.cn 个人域名绑定上了","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/tags/Blog/"}],"keywords":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Blog-02：部署博客到GitHub","slug":"Blog-02：部署博客到GitHub","date":"2023-03-01T01:12:01.000Z","updated":"2023-03-01T13:45:55.546Z","comments":true,"path":"2023/03/01/Blog-02：部署博客到GitHub/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog-02%EF%BC%9A%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0GitHub/","excerpt":"","text":"注册GitHub账号前往 Github 网站，注册一个新用户。用邮箱注册的一定前往邮箱去验证邮件。 部署到 GitHub 上 新建 reponsity 仓库 仓库名设置成 用户名.github.io ，比如我的是 BboyZJ.github.io，选择 Public，勾选 Add a README file ，最后 Create respository 配置秘钥 查看秘钥 123$ cd ~/.ssh$ ls$ cat id_rsa.pub 添加SSH秘钥：头像 -&gt; Setting -&gt; SSH and GPG keys Title 随意写，Key 需要填写刚才复制的 秘钥 文本内容 添加完成，验证链接 123mac@bogon ~ % ssh -T git@github.comHi BboyZJ! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 上传文件到 GitHub 配置 Blog 下 _config.yml 中的 Deployment 模块 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repository: https://github.com/BboyZJ/BboyZJ.github.io.git branch: master 安装部署插件 通过 Hexo 发布到 GitHub，需要安装部署插件 1mac@bogon ~ % npm install hexo-deployer-git --save 部署 123mac@bogon ~ % cd /Users/mac/Desktop/Blogmac@bogon ~ % hexo gmac@bogon ~ % hexo d 访问 这时我们的 GitHub 域名 https://BboyZJ.github.io 就可以看到 Hexo 网站了，如果没显示出来就 刷新 一下","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-02-28T23:51:10.086Z","updated":"2023-02-28T23:51:10.086Z","comments":true,"path":"2023/03/01/hello-world/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/hello-world/","excerpt":"","text":"Welcome to Hexo ! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub . Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"Blog-01：Hexo个人博客搭建","slug":"Blog-01：Hexo个人博客搭建","date":"2023-02-28T23:39:40.000Z","updated":"2023-03-02T17:14:57.071Z","comments":true,"path":"2023/03/01/Blog-01：Hexo个人博客搭建/","link":"","permalink":"https://www.bboyzj.cn/2023/03/01/Blog-01%EF%BC%9AHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Hexo 什么是Hexo？ 简介：Hexo 是一个快速、简洁且高效的博客框架。想要详细的了解 Hexo ，去官网学习。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提 检查是否安装 homebrew 12345mac@bogon ~ % brew -vHomebrew 3.6.21-28-ge6548a8Homebrew/homebrew-core (git revision 5434c8344e8; last commit 2023-02-09)Homebrew/homebrew-cask (git revision 15c2c1fa53; last commit 2023-02-09)mac@bogon ~ % 如果顺利显示版本号，说明homebrew已经安装。否则，输入以下命令进行安装： 1mac@bogon ~ % ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装过程如果出现下面的问题 1curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused 解决: 1mac@bogon ~ % /usr/bin/ruby -e &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)&quot; 安装 Node.js 123mac@bogon ~ % brew install nodemac@bogon ~ % node -vv18.14.2 安装GitMac系统默认已经安装好了，所以不需要再安装 安装Hexo如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往安装 Hexo 步骤。 使用npm完成 hexo 安装 12345678910111213141516171819202122mac@bogon ~ % npm install -g hexo-climac@bogon ~ % hexo -vhexo-cli: 4.1.0os: Darwin 21.6.0 darwin x64node: 12.16.1v8: 7.8.279.23-node.31uv: 1.34.0zlib: 1.2.11brotli: 1.0.7ares: 1.15.0modules: 72nghttp2: 1.40.0napi: 5llhttp: 2.0.4http_parser: 2.9.3openssl: 1.1.1dcldr: 35.1icu: 64.2tz: 2019cunicode: 12.1mac@bogon ~ % 建站 桌面新建 Blog 文件夹，打开终端，cd到 Blog 下，执行: 123456789101112mac@bogon ~ % cd /Users/mac/Desktop/Blog mac@bogon Blog % hexo initINFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO Install dependenciesnpm notice npm notice New major version of npm available! 7.3.0 -&gt; 9.5.1npm notice Changelog: https://github.com/npm/cli/releases/tag/v9.5.1npm notice Run npm install -g npm@9.5.1 to update!npm notice INFO Start blogging with Hexo!mac@bogon Blog % 【目录文件】： _config.landscape.yml：网站本地配置信息_config.yml：网站的配置信息，可以在此配置大部分的参数source–posts：存放 md 文件themes：主题文件夹，常用主题 会放入这里public：Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 hexo 测试 生成静态页面 1mac@bogon Blog % hexo g 会在根目录 Blog\\ 下生成 public 文件夹，里面包含相应的 html 页面。 启动服务器 1mac@bogon Blog % hexo s 打开浏览器，输入网址: http://localhost:4000 ，即可看到hexo生成的静态页面。 停止服务器 Ctrl + C 主题hexo提供了很多主题可以参考，下面以 hexo-theme-casual 主题为例 安装主题插件 hexo-theme-redefine 1无 hexo-theme-casual 1mac@bogon Blog % $ npm install --save hexo-renderer-jade hexo-renderer-scss hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-generator-search hexo-theme-snippet 1mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S hexo-theme-butterfly 12mac@bogon Blog % $ git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterflymac@bogon Blog % $ npm install hexo-renderer-pug hexo-renderer-stylus 下载主题 进入主题的 github 下载页，点击 code -&gt; clone，复制 https 下载链接，进入 博库Blog目录，运行下面的命令： 123mac@bogon Blog % cd /Users/mac/Desktop/Blog mac@bogon Blog % cd themes mac@bogon themes % git clone https://github.com/littlewin-wang/hexo-theme-casual.git 【注】：主题存放的目录是 Blog/themes，为了方便管理，每一个下载的主题都建一个单独的目录，我这个主题的目录是 hexo-theme-casual，可以下载多个主题: 主题应用 找到 博客Blog 目录下的配置文件 _config.yml，找到 Extensions 模块，修改 theme 字段： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-casual 启动本地服务器 1234567891011mac@bogon Blog % hexo sINFO Validating configINFO Start processingINFO Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.[Browsersync] Access URLs: ---------------------------------- UI: http://localhost:3001 ---------------------------------- UI External: http://localhost:3001 ---------------------------------- 查看效果 通过 http://localhost:4000/ 查看修改后的效果 主题更新 这一步不是必须的，如果主题有优化，我们需要在本地同步更新一下 12mac@bogon Blog % /Users/mac/Desktop/Blog/themes/casual mac@bogon Blog % git pull 其他命令 清除旧的内容 hexo clean 生成静态发布页面 hexo g 发布页面 hexo d","categories":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://www.bboyzj.cn/categories/Blog/"}]},{"title":"Swift学习25：Swift中的模式和模式匹配","slug":"Swift学习25：Swift中的模式和模式匹配","date":"2023-02-23T13:36:05.000Z","updated":"2023-03-03T14:33:00.959Z","comments":true,"path":"2023/02/23/Swift学习25：Swift中的模式和模式匹配/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A025%EF%BC%9ASwift%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/","excerpt":"","text":"模式 模式代表 单个值或复合值 的 结构， 可以用模式来匹配各种各样的值，例如：(x,y) 匹配 元组(1,2) 可以从复合值中取出部分或全部值，然后把值绑定一个常量或变量，例如：(let x,y) 提取 (1,2) 模式分类Swift 中模式分为两类： 一种能成功匹配任何类型的值；另一种在运行时匹配某个特定值可能会失败 第一种模式用于解构简单的常量、变量和可选绑定中的值 第二种模式用于全模式匹配。 模式分类： 通配符模式（Wildcard Pattern） 标识符模式（Identifier Pattern） 值绑定模式（Value-Binding Pattern） 元组模式（Tuple Pattern） 枚举用例模式（Enumeratinal Case Pattern） 可选项模式（Optional Pattern） 类型转换模式（Type-Casting Pattern） 表达式模式（Expression Pattern） 通配符模式（Wildcard Pattern） 通配符模式（Wildcard Pattern） 用一个下划线 _ 构成，用于匹配并忽略任何职 123for _ in 1...3 &#123;&#125; 标识符模式（Identifier Pattern） 标识符模式匹配任何值，并将匹配的值和一个变量或常量绑定起来 1let someValue = 42 值绑定模式（Value-Binding Pattern） 把匹配到的值绑定给一个 变量let或常量var 123456let point = (2,3)switch point &#123;// 将 point 中的元素绑定到 x 和 ycase let (x,y): print(&quot;\\(x),\\(y)&quot;)&#125; 元组模式（Tuple Pattern） 元组模式由逗号分割，具有零个或多个模式的列表，由一对圆括号括起来。 1234let points = [(0,0),(0,1),(1,1)]for (x,0) in points &#123; print(&quot;&quot;)&#125; 枚举用例模式（Enumeratinal Case Pattern） 匹配现有某个枚举类型的某个用例，体现在 switch 中 case 标签中，及 if、while、guard 和 for in 的 case 中 可选项模式（Optional Pattern） 匹配 Optional&lt;Wrapped&gt; 枚举在 some&lt;Wrapped&gt; 中包装的值 可选项模式为 for in 语句提供了一种迭代数组的简便方式，只为数组中的非 nil 元素执行循环体 12345678let someNum: Int? = 10if case .some(let x) = someNum &#123; print(x)&#125;if case let x? = someNum &#123; print(x)&#125; 类型转换模式（Type-Casting Pattern） 有两种：is模式 和 as模式，is 模式只出现在 switch 语句 case 标签中 is 类型：仅当一个值类型在运行时和 is模式 右边指定的类型一致，或子类下，才匹配值，没有返回类型 模式 as 类型：仅当一个值类型在运行时和 as模式 右边指定的类型一致，或子类下，才匹配值，如果匹配成功，被转换成 as模式右边指定的类型 12345678910111213141516171819202122232425262728protocol Animal &#123; var name:String &#123; get &#125;&#125;struct Dog:Animal &#123; var name:String &#123; return &quot;dog&quot; &#125; var runSpeed:Int&#125;struct Bird:Animal &#123; var name:String&#123; return &quot;bird&quot; &#125; var flightHeight:Int&#125;let animals:[Any] = [Dog(runSpeed:40),Bird(flightHeight:500)]for animal in animals &#123; switch animal&#123; case let dog as Dog: print(&quot;\\(dog.name) run at \\(dog.runSpeed)&quot;) case let bird as Bird: print(&quot;\\(bird.name) swip at \\(bird.flightHeight)&quot;) default: break &#125;&#125; 表达式模式（Expression Pattern） 表达式模式代表表达式的值，只出现在 switch 语句中的 case 标签中 可重载 ~= 运算符来提供自定义的表达式匹配行为 自定义类或结构体类型 默认也是无法进行表达式模式匹配的，也需要重载 ~= 运算符 123456789101112131415struct Employee&#123; var salary:Int&#125;func ~= (left:ClosedRange&lt;Int&gt;,right:Employee) -&gt; Bool&#123; return left.contains(right.salary)&#125;var e: Employee = Employee(salary:2000)switch e&#123;case 0...1000: print(&quot;吃不饱&quot;)case 1000...5000: print(&quot;勉强度日&quot;)default: break&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习24：如何在Swift里面进行控制转移","slug":"Swift学习24：如何在Swift里面进行控制转移","date":"2023-02-23T13:35:34.000Z","updated":"2023-03-03T14:25:43.191Z","comments":true,"path":"2023/02/23/Swift学习24：如何在Swift里面进行控制转移/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A024%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8Swift%E9%87%8C%E9%9D%A2%E8%BF%9B%E8%A1%8C%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB/","excerpt":"","text":"控制转移 continue break fallthrough return throw continue continue 告诉我不再继续当前循环遍历了，再次从头开始下一次遍历 break break 会立即结束整个控制流语句，即跳出整个循环 fallthrough 你确定要贯穿行为，你可以在 switch 每个 case 末尾 使用 fallthrough 关键字 12345678910let num = 5var des = &quot;the num \\(num) is&quot;switch num &#123;case 2,3,5,7: des += &quot;a prime number&quot; fallthroughdefault: des += &quot; also a int&quot;&#125;print(des) 语句标签 可以用 k 来给循环语句或条件语句做标记。 配合 break 或 continue 来结束被标记的语句 12345678910111213141516171819var num = 10whileLoop: while num &gt; 0 &#123; switch num &#123; case 9: print(&quot;9&quot;) case 10: var sum = 0 for i in 0...10 &#123; sum += i if i == 9 &#123; print(sum) break whileLoop &#125; &#125; default: print(&quot;default&quot;) &#125; num -= 1&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习23：更加强大的switch","slug":"Swift学习23：更加强大的switch","date":"2023-02-23T13:35:07.000Z","updated":"2023-03-03T14:24:22.291Z","comments":true,"path":"2023/02/23/Swift学习23：更加强大的switch/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A023%EF%BC%9A%E6%9B%B4%E5%8A%A0%E5%BC%BA%E5%A4%A7%E7%9A%84switch/","excerpt":"","text":"swift switch 语句会将一个值与多个可能匹配的模式匹配，然后基于第一个成功匹配的模式来执行合适的代码块 switch 语句一定得是全面的。给定类型里的每一个值都得匹配到一个 switch 的 case。你可以定义一个默认匹配的 case 来匹配所有未明确的值，用关键字 default 标记 OC 中 switch 语句不全面，仍然可以运行 1234567let c:Character = &quot;z&quot;switch c &#123;case &quot;a&quot;: print(&quot;the first letter is alphabet&quot;)case &quot;z&quot;: print(&quot;the last letter is alphabet&quot;)&#125; 修改 123456789let c:Character = &quot;z&quot;switch c &#123;case &quot;a&quot;: print(&quot;the first letter is alphabet&quot;)case &quot;z&quot;: print(&quot;the last letter is alphabet&quot;)default: print(&quot;other&quot;)&#125; 没有隐私贯穿 相比 OC 和 C ，Swift 里的 Switch 不会默认从匹配的 case 末尾 贯穿到下一个 case 里 相反，整个 Switch 在匹配到第一个 case 执行完毕之后退出，不再需要显示 break 每一个 case 的函数体必须包含至少一个可执行的语句 在一个 Switch 的 case 中匹配多个值可以用 逗号分割，并且可以写成多行 123456789let c = &quot;a&quot;switch c &#123;case &quot;a&quot;,&quot;e&quot;,&quot;i&quot;: print(&quot;元音字母&quot;)case &quot;b&quot;,&quot;c&quot;: print(&quot;符印字母&quot;)default: print(&quot;其他字符&quot;)&#125; 区间匹配 Switch 的 case 的值可以再一个区间中匹配 123456789101112let count = 43switch count&#123;case 0: print(&quot;none&quot;)case 1...25: print(&quot;1~25&quot;)case 26..&lt;51: print(&quot;26~50&quot;)default: print(&quot;other&quot;)&#125; 元组匹配 你可以使用元组来在一个 switch 中测试有多个值 使用下划线 _ 来表明匹配所有可能的值 1234567891011121314let point = (1,1)switch point&#123;case (0,0): print(&quot;point at origin&quot;)case (_,0): print(&quot;point at x&quot;)case (0,_): print(&quot;point at y&quot;)case (-2...2,-2...2): print(&quot;point at box&quot;)default: print(0,0)&#125; 值绑定 switch 的 case 可以将匹配到的值临时 绑定 到一个 常量或变量，来给 case 的函数体使用 如果使用 var 关键字，临时的变量就会以合适的值来创建并初始化。对这个变量的任何改变都只会在 case 的函数体内有效 123456789let point = (1,0)switch point&#123;case (let x,0): print(&quot;x is \\(x) when y is 0&quot;)case (0,let y): print(&quot;y is \\(y) when x is 0&quot;)default: print(&quot;other&quot;)&#125; where 语句 switch case 可以使用 where 语句来检查是否符合特定的约束 123456789let point = (1,-1)switch point&#123;case (let x,let y) where x == y: print(&quot;x == y&quot;)case (let x,let y) where x == -y: print(&quot;x == -y&quot;)default: print(&quot;other&quot;)&#125; 复合匹配 case 后可以写多个模式来复合，在每个模式间用 , 号分割 复合匹配 - 值绑定 复合匹配同样可以包含 值绑定。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习22：如何在Swift里进行循环控制","slug":"Swift学习22：如何在Swift里进行循环控制","date":"2023-02-23T13:34:50.000Z","updated":"2023-03-03T14:20:09.738Z","comments":true,"path":"2023/02/23/Swift学习22：如何在Swift里进行循环控制/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A022%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8Swift%E9%87%8C%E8%BF%9B%E8%A1%8C%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6/","excerpt":"","text":"for in 循环 使用 for in 循环来遍历序列，比如一个范围的数字，数组中元素或者字符串中的字符 如果你不需要序列的每一个值，你可以使用下划线 _ 来取代遍历名 123456789101112131415// 遍历for i in 0...3&#123; print(i)&#125;// 遍历字符串for c in &quot;hello,world&quot; &#123; print(c)&#125;// 遍历数组let letter = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]for str in letter &#123; print(str)&#125; for in 遍历字典 当遍历字典时，每一个元素都返回一个 (key,value) 元组，你可以在 for in 循环体中使用显示命名常量来分解 (key,value) 元组成员 1234567let nums = [&quot;age&quot;:&quot;30&quot;,&quot;sex&quot;:&quot;男&quot;]for (key,value) in nums &#123; print(&quot;key is \\(key),value is \\(value)&quot;)&#125;for t in nums &#123; print(&quot;key is \\(t.0),value is \\(t.1)&quot;)&#125; for in 分段区间 使用 stride(from:to:by) 函数来跳过不想要的标记（开区间） 123for i in stride(from: 0, to: 50, by: 10) &#123; print(i)&#125; 闭区间 也同样适用，使用 stride(from:through:by:) 即可 123for i in stride(from: 0, through: 50, by: 10) &#123; print(i)&#125; while 循环 repeat-while 循环 （oc 中是 do-while）","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习21：如何在swift中自定义运算符","slug":"Swift学习21：如何在swift中自定义运算符","date":"2023-02-22T20:03:04.000Z","updated":"2023-03-03T14:18:08.194Z","comments":true,"path":"2023/02/23/Swift学习21：如何在swift中自定义运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A021%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8swift%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"自定义运算符 除了实现标准的运算符，在 swift 当中还可以声明和实现自定义运算符（custom operators） 新的运算符要在全局作用域内，使用 operator 关键字进行声明，同时还要指定 prefix、infix 或者 postfix 限定符 【示例1】：一元运算符 123456789101112131415struct Vector2D &#123; var x = 0.0,y = 0.0&#125;// 声明一元运算符prefix operator +++// 扩展extension Vector2D &#123; static prefix func +++ (vector: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: vector.x + vector.x,y: vector.y + vector.y) &#125;&#125;let vectorToDouble = Vector2D(x: 1.0,y: 2.0)let doubleVector = +++vectorToDoubleprint(&quot;\\(doubleVector.x) \\(doubleVector.y)&quot;) 编译运行，查看打印结果 12.0 4.0 【示例2】： 1234567891011121314// 中缀运算符struct Vector2D &#123; var x = 0.0,y = 0.0&#125;infix operator +-: AdditionPrecedenceextension Vector2D &#123; static func +- (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x,y: left.y - right.y) &#125;&#125;let firstVector = Vector2D(x: 1.0,y: 3.0)let secondVector = Vector2D(x: 2.0,y: 5.0)let result = firstVector +- secondVectorprint(&quot;\\(result.x) \\(result.y)&quot;) 编译运行，查看打印结果： 13.0 -2.0 【示例3】： 1234567891011121314// 中缀运算符struct Vector2D &#123; var x = 0.0,y = 0.0&#125;infix operator *^: MultiplicationPrecedenceextension Vector2D &#123; static func *^ (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x * right.x,y: left.y * left.y + right.y * right.y) &#125;&#125;let firstVector = Vector2D(x: 1.0,y: 3.0)let secondVector = Vector2D(x: 2.0,y: 5.0)let result = firstVector *^ secondVectorprint(&quot;\\(result.x) \\(result.y)&quot;) 编译运行，查看打印结果： 12.0 34.0 自定义中缀运算符的优先级和结合性 自定义 中缀（infix） 运算符也可以指定优先级和结核性 每一个自定义的中缀运算符都属于一个 优先级组 优先级组指定了自定义中缀运算符和其他中缀运算符的关系 【示例】： 123456789101112131415161718192021// 优先级和结合性struct Vector2D &#123; var x = 0.0,y = 0.0&#125;infix operator +-: AdditionPrecedenceextension Vector2D &#123; static func +- (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x,y: left.y - right.y) &#125;&#125;infix operator *^: MultiplicationPrecedenceextension Vector2D &#123; static func *^ (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x * right.x,y: left.y * left.y + right.y * right.y) &#125;&#125;let firstVector = Vector2D(x: 1.0,y: 2.0)let secondVector = Vector2D(x: 2.0,y: 3.0)let thirdVector = Vector2D(x: 3.0,y: 4.0)let result = firstVector +- secondVector *^ thirdVectorprint(&quot;\\(result.x) \\(result.y)&quot;) 编译运行，查看打印结果： 17.0 -23.0 【注】：先计算 *^ 优先级组，再计算 +- 优先级组 x: 2 * 3 &#x3D; 6 + 1 &#x3D; 7.0y: 3 * 3 + 4 * 4 &#x3D; 2 - 25 &#x3D; -23 接下来我们自己定义一个优先级组 123456789101112131415161718192021222324252627282930// 自定义优先级和结合性struct Vector2D &#123; var x = 0.0,y = 0.0&#125;infix operator +-: AdditionPrecedenceextension Vector2D &#123; static func +- (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x,y: left.y - right.y) &#125;&#125;infix operator *^: MyPrecedencegroup// 我的优先级组precedencegroup MyPrecedencegroup &#123; // 结合性 associativity: left // 优先级 lowerThan: AdditionPrecedence&#125;extension Vector2D &#123; static func *^ (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x * right.x,y: left.y * left.y + right.y * right.y) &#125;&#125;let firstVector = Vector2D(x: 1.0,y: 2.0)let secondVector = Vector2D(x: 2.0,y: 3.0)let thirdVector = Vector2D(x: 3.0,y: 4.0)let result = firstVector +- secondVector *^ thirdVectorprint 编译运行，查看打印结果： 19.0 17.0 【注】：先计算 *^ 优先级组，再计算 +- 优先级组 x：1 + 2 &#x3D; 3 * 3 &#x3D; 9.0y：2 - 3 &#x3D; -1 * -1 + 4 * 4 &#x3D; 17.0","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习20：如何为类和结构体自定义运算符","slug":"Swift学习20：如何为类和结构体自定义运算符","date":"2023-02-22T20:02:46.000Z","updated":"2023-03-03T13:32:17.035Z","comments":true,"path":"2023/02/23/Swift学习20：如何为类和结构体自定义运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A020%EF%BC%9A%E5%A6%82%E4%BD%95%E4%B8%BA%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"运算符重载 类和结构体 可以为现有的运算符提供自定义的实现，称为 运算符重载 1234567struct Vector2D &#123; var x = 0.0,y = 0.0&#125;let vector = Vector2D(x: 1.0,y: 2.0)let anotherVertor = Vector2D(x: 3.0,y: 1.0)let thirdVertor = vector + anotherVertor 运算符重载 1234567891011121314struct Vector2D &#123; var x = 0.0,y = 0.0&#125;extension Vector2D &#123; static func + (left:Vector2D,right:Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x,y: left.y + right.y) &#125;&#125;let vector = Vector2D(x: 1.0,y: 2.0)let anotherVertor = Vector2D(x: 3.0,y: 1.0)let thirdVector = vector + anotherVertorprint(&quot;x is \\(thirdVector.x),y is \\(thirdVector.y)&quot;) 编译运行，查看打印结果： 1x is 4.0,y is 3.0 一元运算符的重载 类和结构体 也能提供 标准一元运算符 的实现 要实现 前缀 或者 后缀 运算符，需要在声明运算符函数的时候在 func 关键字之前指定 prefix 或者 postfix 限定符 1234567891011struct Vector2D &#123; var x = 0.0,y = 0.0&#125;extension Vector2D &#123; static prefix func - (vector:Vector2D) -&gt; Vector2D &#123; return Vector2D(x: -vector.x,y: -vector.y) &#125;&#125;let vector = Vector2D(x: 1.0,y: 2.0)let vector2 = -vectorprint(&quot;x is \\(vector2.x),y is \\(vector2.y)&quot;) 编译运行，查看打印结果： 1x is -1.0,y is -2.0 组合赋值运算符重载 组合赋值运算符将赋值运算符 = 与其他运算符进行结合 在实现的时候，需要把运算符的左参数设置成 inout 类型，因为这个参数的值会在运算符函数内直接被修改 123456789extension Vector2D &#123; static func += (left: inout Vector2D,right:Vector2D) &#123; left = Vector2D(x: left.x + right.x,y: left.y + right.y) &#125;&#125;var vector3 = Vector2D(x: 1.0, y: 2.0)let vector4 = Vector2D(x: 2.0,y: 3.0)vector3 += vector4print(&quot;x is \\(vector3.x),y is \\(vector3.y)&quot;) 编译运行，查看打印结果： 1x is 3.0,y is 5.0 等价运算符重载 自定义类和结构体不接收等价运算符的默认实现，也就是所谓的 等于 运算符 == 和 不等于 运算符 != 要使用等价运算符来检查你自己类型的等价，需要和其他 中缀运算符 一样提供一个 等于 运算符重载，并且遵循标准库的 Equatable 协议 swift 为一下自定义类型提供等价运算符合成实现 只有遵循 Equatable 协议存储属性的 结构体 只拥有遵循 Equatable 协议关联类型的 枚举 没有关联类型的枚举 123456789101112// 等价运算符struct Vector2D &#123; var x = 0.0,y = 0.0&#125;extension Vector2D: Equatable &#123; static func == (left:Vector2D,right:Vector2D) -&gt; Bool &#123; return (left.x == right.x) &amp;&amp; (left.y == right.y) &#125;&#125;var vector1 = Vector2D(x: 1.0, y: 2.0)let vector2 = Vector2D(x: 2.0,y: 3.0)print(vector1 == vector2) 编译运行，查看打印结果： 1false 自定义中缀运算符的优先级和结合性 自定义的中缀 infix 运算符也可以指定优先级和结合性 每一个自定义的中缀运算符都属于一个优先级组 优先级组指定了自定义中缀运算符和其他中缀运算符的关系","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习19：运算符优先级和结合性","slug":"Swift学习19：运算符优先级和结合性","date":"2023-02-22T20:02:16.000Z","updated":"2023-03-03T10:52:29.250Z","comments":true,"path":"2023/02/23/Swift学习19：运算符优先级和结合性/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A019%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7/","excerpt":"","text":"运算符优先级和结合性 运算符的优先级使得一些运算符优先于其他运算符，高优先级的运算符会先被计算 结合性定义了具有相同优先级的运算符是如何结合（或关联）的 一一 是左边结合为一组，还是与右边结合为一组。可以这样理解：它们是与左边的表达式结合的 或者 它们是与右边的表示式结合的 运算符优先级-显示括号 2 + 3 % 4 * 5 等价于 2 + ((3 % 4) * 5) swift 语言中逻辑运算符 &amp;&amp; 和 || 是左相关的，这意味着多个逻辑运算符组合的表达式会首先计算最左边的","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习18：运算符应用举例","slug":"Swift学习18：运算符应用举例","date":"2023-02-22T17:32:43.000Z","updated":"2023-03-03T10:51:44.692Z","comments":true,"path":"2023/02/23/Swift学习18：运算符应用举例/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A018%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/","excerpt":"","text":"两个数字交换 不借助临时变量，交换两个变量的值 1234567var a = 1var b = 2a = a ^ bb = a ^ ba = a ^ bprint(a)print(b) 求无符号整数二进制中 1 的个数 给定一个无符号整型 UInt 变量，求其二进制表中 1 的个数，要求算法执行效率尽可能的高 思路：看一个八位整数 10 100 001 ，先判断最后一位是否为 1 ，而 与 操作可以达到目前。可以把这个 八位数字 与 00 0000 01 进行 与 操作，如果结果为 1，则表示当前八位数的最后一位为 1，否则为 0 。怎么判断第 二 位呢？向右移位，再延续前面的判断即可 12345678910111213// 有几个 1func countsOfOnes(num:UInt) -&gt; UInt &#123; var count:UInt = 0 var temp = num while temp != 0 &#123; // 如果都是位 1 才累加 count += temp &amp; 1 // 右移 temp = temp &gt;&gt; 1 &#125; return count&#125;countsOfOnes(num: 8) 如果整数的二进制中有较多的 0，那么我们每一次右移做判断会很浪费，怎么改进前面的算法呢？有没有办法让算法的复杂度只有与 1 的个数有关？ 思路：为了简化这个问题，我们考虑只有高位 1 的情况。例如：11 000 000，如何跳过前面低位的 6 个 0 ，而直接判断第 七 位的 1？我们可以设计 11 000 000 和 10 111 111（也就是 11 000 000 - 1）做 与 操作，消去最低位的 1。如果得到的结果为 0，说明我们已经找到或消去里面最后一个 1，如果不为 0，那么说明我们消去了最低位的 1，但是二进制中还有其他的 1，我们的计数器需要加 1，然后继续上面的操作 计数器 count &#x3D; 0 步骤一：整数不为0，说明二进制里面肯定有1，count &#x3D; 1 11 000 000 &amp; 10 111 111 &#x3D; 10 000 000 (消去第7位的1) 步骤二：结果不为 0，说明二进制里还有 1，count &#x3D; 2 10 000 000 &amp; 01 111 111 &#x3D; 0（消去第8位的1） 12345678910func countsOfOnes2(num:UInt) -&gt; UInt &#123; var count:UInt = 0 var temp = num while temp != 0 &#123; count += 1 temp = temp &amp; (temp - 1) &#125; return count&#125;countsOfOnes2(num: 3) 引申：如果判断一个征收为2的整数次幂 给定一个无符号整型 UInt 变量，判断是否为 2 的整数次幂 思路：一个整数如果是 2 的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位都是 0，根据前面的分析，把这个整数减去 1 后再和它自己做 &amp; 运算，这个整数中唯一的 1 就变成 0 了，也就是得到的结果是 0 12345// 2的整数次幂func isPowerTwo(num:UInt) -&gt; Bool &#123; return (num &amp; (num - 1)) == 0&#125;isPowerTwo(num: 18) 缺失的数字 很多成对出现的正整数保存在磁盘文件中，注意成对数字不一定是相邻的，如果 2、3、4、3、4、2、..，由于意外有一个数字消失了，如何尽快找到是哪个数字消失了？ 思路：考虑 ^ 异或操作的定义，当两个操作的数对应位不相同时，改数的对应位就为1。也就是说如果是相等的两个数 ^异或，得到的结果就是 0，而 0 与任何数字 ^异或，得到的是那个数字本身。所以我们考虑将所有的数字做 ^异或操作，因为只有一个数字消失，那么其他俩俩出现的数字 ^异或后为0，0与仅有的一个的数字做 ^异或，我们就得到了消失的数字是哪个？ 123456789// 缺失的数字func findLostNum(nums:[UInt]) -&gt; UInt &#123; var lostNum:UInt = 0 for num in nums &#123; lostNum = lostNum ^ num &#125; return lostNum&#125;findLostNum(nums: [1,3,2,4,2,1,3]) 如果有两个数字意外丢失了（丢失的不是相等的数字），改如何找到丢失的两个数字？ 思路：假设题目中这两个只出现1次的数字分别是A和B，如果能将A，B分开到二个数组中，那显然符合 异或 解法的关键点了，因此这个题目的关键点事将A和B分开到二个数组中。由于A，B肯定是不相等的，因此在二进制上肯定有一位是不同的。根据这一位是 0 还是 1 可以将A和B分开到A组合B组。而这个数组中其它数字那么就属于A组，要么就属于B组。再对A组 和 B组 分别执行 异或 解法，就可以得到A,B了。而要判断A，B在哪一位上不相同，只要根据 A ^ B 的结果就可以知道了，这个结果在二进制上为 1 的位都说明 A，B在这一位上是不同的 12345678910111213141516171819202122232425// 丢失的两个不同数func findTwoLostNum(nums:[UInt]) -&gt; (UInt,UInt) &#123; var lostNum1:UInt = 0 var lostNum2:UInt = 0 var temp:UInt = 0 // 计算两个数的异或结果 for num in nums &#123; temp = temp ^ num &#125; // 找到第一个为 1 的位 var flag:UInt = 1 while ((flag &amp; temp) == 0) &#123; flag = flag &lt;&lt; 1 &#125; // 找到两个丢失的数字 for num in nums &#123; if (num &amp; flag) == 0 &#123; lostNum1 = lostNum1 ^ num &#125;else &#123; lostNum2 = lostNum2 ^ num &#125; &#125; return (lostNum1,lostNum2)&#125;findTwoLostNum(nums: [1,2,3,4,2,1])","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习17：位运算符","slug":"Swift学习17：位运算符","date":"2023-02-22T17:32:26.000Z","updated":"2023-03-03T10:39:50.002Z","comments":true,"path":"2023/02/23/Swift学习17：位运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A017%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"位取反运算符 位取反运算符 ~ 是对所有位的数字进行取反操作 123let n1:UInt8 = 255let n2 = ~n1print(n2) 位与运算符 位与运算符 &amp; 可以对两个数的比特位进行合并，它会返回一个新的数，只有当这两个数都是 1 时才能返回 1 123456let n1:UInt8 = 255let n2 = ~n1let n3 = n1 &amp; n2let n4 = n1 | n2print(n3)print(n4) 位或运算符 位或运算符 | 可以对两个比特位进行比较，然后返回一个新的数，只要两个操作位任意一个为 1 时，那么对应的位数就为 1 位异或运算符 位异或运算符，或者说 互斥或 ^ 可以对两个数的比特位进行比较，它返回一个新的数，当两个操作数的对应位不同时，该数的对应位就为 1 1234let n1:UInt8 = 255let n2 = ~n1let n5 = n1 ^ n2print(n5) 位左移和右移运算符 位左移运算符 &lt;&lt; 和位右移运算符 &gt;&gt; 可以把所有位数的数字向左或向右移动一个确定的位数 位 左移和右移 具有给 整数乘以或除以二 的效果，将一个数 左移 一位相当于把这个 数翻倍，将一个数 右移 相当于把这个数 减半 无符号整数的位移操作 已经存在的比特位按指定的位数进行左移和右移 任何移动超出整型存储边界的位都会被丢弃 用 0 来填充向左或向右移动后产生的空白位 有符号整数的位移操作 有符号整数使用它的第一位（所谓的符号位）来表示这个整数是正数还是负数，符号位 0 表示 正数，1 表示 负数 其余的位数（所谓的数值位）存储了实际的值，有符号正整数和无符号数的存储方式是一样的，都是从 0 开始算起 但是负数的存储方式略有不同，它存储的是 2 的 n 次方减去它的绝对值，这里的 n 为数值位的位数 示例： 123let n6: Int = 8print(n6 &lt;&lt; 1)print(n6 &gt;&gt; 1) 补码表示的优点 首先，如果想给 -4 加个 -1，只需要将这两个数的全部 8 个比特位相加（包括符号位），并且将计算结果中超出的部分丢掉 其次，使用二进制补码可以使负数位的位左移和右移操作得到根正数同样的效果，即每向左移一位就将自身的数值 乘以2 ，每向右移一位就将自身的数值 除以2，要达到此目的，对 有符号的整数 的右移有一个额外的规则：当对整数进行位右移操作时，遵循与无符号整数相同的规则，但是对于位移产生的空白位使用符号进行填充，而不是 0","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习16：区间运算符","slug":"Swift学习16：区间运算符","date":"2023-02-22T17:32:10.000Z","updated":"2023-03-03T10:24:08.818Z","comments":true,"path":"2023/02/23/Swift学习16：区间运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A016%EF%BC%9A%E5%8C%BA%E9%97%B4%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"闭区间运算符 闭区间运算符 a...b 定义了从 a 到 b 的一组范围，并且包含 a 和 b ，a 的值不能大于 b 12345// 闭区间let range = 0...5for index in range &#123; print(index)&#125; 半开区间运算符 半开区间运算符 a..&lt;b 定义了从 a 到 b 但不包括 b 的区间 12345// 半开半闭区间let range = 0..&lt;5for index in range &#123; print(index)&#125; 如同闭区间运算符，a 的值也不能大于 b ，如果 a 与 b 的值相等，那返回的区间将会是空的 单侧区间 闭区间运算符有另外一种形式来让区间朝一个方向尽可能的远，这种区间叫做单侧区间 12345// 单侧闭区间let names = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]for name in names[...2] &#123; print(name)&#125; 半开区间运算符同样可以有单侧形式，只需要写它最终的值 12345// 单侧半开半闭区间let names = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]for name in names[..&lt;2] &#123; print(name)&#125; 比如说，一个包含数组所有元素的区间，从索引 2 到数组的结束，在这种情况下，你可以省略区间运算符一侧的值 123for name in names[2...] &#123; print(name)&#125; 单侧区间可以再其他上下文中使用，不仅仅是下标 不能变量省略了第一个值的单侧区间，因为遍历根本不知道该从哪里开始，你可以遍历省略了最终值的单侧区间 字符串索引区间 字符串范围可以使用区间运算符 12345// 字符串索引区间var str = &quot;hello,world&quot;let range = str.startIndex...str.index(str.endIndex, offsetBy: -6)str.removeSubrange(range)print(str) 倒叙索引 通过 reversed() 方法，我们可以将一个正序循环变成逆序循环 1234// 逆序for i in (0...4).reversed() &#123; print(i)&#125; Comparable 区别 区间运算符可以作用在 Comparable 类型上，返回闭区间和半闭区间 1234567var str = &quot;hello,world&quot;let range = &quot;a&quot;...&quot;z&quot;for c:Character in str &#123; if !range.contains(String(c)) &#123; print(&quot;\\(c) 不是小写字符&quot;) &#125; &#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习15：为了Optional，合并空置运算符","slug":"Swift学习15：为了Optional，合并空置运算符","date":"2023-02-22T17:31:50.000Z","updated":"2023-03-01T17:27:39.187Z","comments":true,"path":"2023/02/23/Swift学习15：为了Optional，合并空置运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A015%EF%BC%9A%E4%B8%BA%E4%BA%86Optional%EF%BC%8C%E5%90%88%E5%B9%B6%E7%A9%BA%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"合并空值运算符 合并空值运算符 a ?? b 如果可选项 a 有值则展开，如果没有值是 nil，则返回默认值 b 表达式 a 必须是一个可选类型，表达式 b 必须与 a 的存储类型相同 实际上是 三元运算符 作用到 Optional 上的缩写 a != nil ? a : b 如果 a 的值是非空的，b 的值将不会被考虑，也就是合并空值运算符是短路的 可选值为nil时，不能强制解包 可以用 if 判断实现 123456789101112131415161718let a:Int? = nillet b = 2func sum(x:Int?,y:Int?) -&gt; Int&#123;// return x! + y! if x != nil &#123; if y != nil &#123; return x! + y! &#125;else &#123; return x! &#125; &#125;else &#123; if y != nil &#123; return y! &#125;else &#123; return 0 &#125; &#125;&#125; 也可以用 ?? 来实现 1return (a ?? 0) + b","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习14：在Swift里如何处理算术结果溢出","slug":"Swift学习14：在Swift里如何处理算术结果溢出","date":"2023-02-22T17:31:22.000Z","updated":"2023-03-01T17:30:15.039Z","comments":true,"path":"2023/02/23/Swift学习14：在Swift里如何处理算术结果溢出/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A014%EF%BC%9A%E5%9C%A8Swift%E9%87%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%AE%97%E6%9C%AF%E7%BB%93%E6%9E%9C%E6%BA%A2%E5%87%BA/","excerpt":"","text":"溢出运算符 在默认情况下，当向一个整数赋超出它容量的值时，swift 会报错而不是生成一个无效的数，给我们操作过大或过小的数时提供了额外的安全性 同时提供三个算术溢出运算符来让系统支持整数溢出运算 溢出加法 &amp;+ 溢出减法 &amp;- 溢出乘法 &amp;* 值溢出 数值可以出现向上溢出或向下溢出 溢出也会发生在有符号整型数值上 对于无符号与有符号整型数值来说，当出现溢出时，它们会从数值所能容纳的最大数变成最小的数，同样的，当发生下溢时，它们会从所能容纳的最小数变成最大的数 代码示例 上溢出 下溢出","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习13：赋值和算术运算符","slug":"Swift学习13：赋值和算术运算符","date":"2023-02-22T17:30:48.000Z","updated":"2023-03-01T17:25:29.347Z","comments":true,"path":"2023/02/23/Swift学习13：赋值和算术运算符/","link":"","permalink":"https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A013%EF%BC%9A%E8%B5%8B%E5%80%BC%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"基本概念 一元运算符对一个目标进行操作。一元前缀运算符（如!b），一元后缀运算符（b!） 二元运算符对两个目标进行操作（a+b）同时因为它们出现在两个目标之间，所以是中缀 三元运算符操作三个目标，swift 语言也仅有一个 三元运算符，三元条件运算符（a?b:c） swift 运算符的改进 swift在支持 c 中的大多数标准运算符的同时也增加了一些排除常见代码错误的能力 赋值符号 = 不会返回值，以防止它被无用于等于符号 == 算术符号 +、-、*、/、% 以及其他可以监测并阻止值溢出，以避免你在操作比存储类型允许的范围更大或更小的数字时得到各种奇怪的结果 赋值运算符 赋值运算符将一个值赋值给另外一个值 如果赋值符号右侧是拥有多个值的元组，它的元素将会一次性地拆分成常量或者变量 Swift 的赋值符号自身不会返回值 算术运算符-标准运算符 标准算术运算符 + - * / 算术运算符同时也支持 String 的拼接 swift 算术运算符默认不允许值溢出 算术运算符 - 余数运算符 余数运算符 a%b 可以求出多少个 b 的倍数能够刚好放进 a 中并且返回剩下的值（就是我们所谓的余数） 当 a 是负数时也适用相同的方法来进行计算 当 b 为负数时它的正负号被忽略掉。这意味着 a%b 与 a%-b 能够获得相同的答案 12345678let c = 9 % 4print(c)let d = 9 % -4print(d)let e = -9 % 4print(e) 算术运算符 - 一元 数字值的正负号可以用前缀 - 来切换，我们称之为一元减号运算符 一元减号运算符 - 直接在要进行操作的值前边放置，不加任何空格 一元加号运算符 + 直接返回它操作的值，不会对其进行任何的修改","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习12：获取子串和字符串比较","slug":"Swift学习12：获取子串和字符串比较","date":"2023-02-21T18:59:39.000Z","updated":"2023-03-01T17:25:21.832Z","comments":true,"path":"2023/02/22/Swift学习12：获取子串和字符串比较/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A012%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AD%90%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/","excerpt":"","text":"子字符串 使用下标或者类似 prefix(_:) 的方法得到的子字符串是 Substring 类型 Substring 拥有 String 的大部分方法 Substring 可以转成 String 类型 1234let str = &quot;hello,world&quot;let index = str.firstIndex(of: &quot;,&quot;) ?? str.endIndexlet begin = str[..&lt;index]let new = String(begin) 子字符串重用一部分原字符串的内存 修改字符串或子字符串之前都不需要花费拷贝内存的代价 String 和 Substring 都遵循 StringProtocol 协议，也就是说它基本上都能很方便的兼容所有接受 StringProtocol 值的字符串操作函数 字符串的比较 字符串和字符相等性 == 和 != 前缀相等性 hasPrefis(_:) 后缀相等性 hasSubffix(_:) 12345var str1 = &quot;1&quot;var str2 = &quot;2&quot;print(str1 == str2)print(str1.hasPrefix(&quot;1&quot;))print(str2.hasSuffix(&quot;2&quot;))","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习11：索引访问和修改字符串","slug":"Swift学习11：索引访问和修改字符串","date":"2023-02-21T18:59:05.000Z","updated":"2023-03-01T17:18:31.138Z","comments":true,"path":"2023/02/22/Swift学习11：索引访问和修改字符串/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A011%EF%BC%9A%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串索引 每一个 String 值都有相关的索引类型，String.Index，他相当于每个 Character 在字符串中的位置 startIndex 属性来访问 String 中第一个 Character 的位置。endIndex 属性就是 String 中最后一个字符串的位置 endIndex 属性并不是字符串下标脚本的合法实际参数 如果 String 为空，则 startIndex 与 endIndex 相等 使用 index(before:) 和 index(after:) 方法来访问给定索引的前后 要访问给定索引更远的索引，你可以使用 index(_:offetBy:) 使用 indices 属性来访问字符串中每个字符的索引 123456var greeting = &quot;Hello, playground&quot;greeting[greeting.startIndex]greeting[greeting.index(before: greeting.endIndex)]greeting[greeting.index(after: greeting.startIndex)]let index = greeting.index(greeting.startIndex, offsetBy: 7)greeting[index] 插入 插入字符，使用 insert(_:at:) 方法 插入到另一个字符串的内容到特定的索引，使用 insert(contentsOf:at:) 方法 1234var str = &quot;hello&quot;str.insert(&quot;!&quot;, at: str.endIndex)str.insert(contentsOf: &quot; world&quot;, at: str.firstIndex(of: &quot;!&quot;)!)print(str) 删除 移除字符，使用 remove(at:) 方法 12var str = &quot;hello&quot;str.remove(at: str.index(before: str.endIndex)) 移除一小段特定范围的字符串，使用 removeSubrange(_:) 方法 123var str = &quot;hello&quot;let range = str.index(str.endIndex, offsetBy: -str.count)..&lt;str.endIndexstr.removeSubrange(range)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习10：字符串常见操作","slug":"Swift学习10：字符串常见操作","date":"2023-02-21T18:58:45.000Z","updated":"2023-03-01T17:15:30.150Z","comments":true,"path":"2023/02/22/Swift学习10：字符串常见操作/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A010%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/","excerpt":"","text":"字符串的可变性 var 指定的可以修改 let 指定的不可修改 对比 Object-C (NSString 和 NSMutableString) 字符串是 值类型 String 值在传递给方法或函数的时候会被复制过去 赋值给常量或变量的时候也是一样 Swift 编译器优化了字符串使用的资源，实际上拷贝只会在确实需要的时候才进行 123456var str1 = &quot;hello&quot;var str2 = str1print(str1 == str2)str1.append(&quot;,world&quot;)print(str1)print(str2) 操作字符 for in 循环遍历 String 中的每一个独立的 Character Character 类型 String 值可以通过传入 Character 数组来构造 1234var str = &quot;hello&quot;for c in str&#123; print(c)&#125; 字符串的拼接 使用加运算符 + 创建新字符串 使用 + 赋值符号 += 在已经存在的 String 值末尾追加一个 String 值 使用 String 类型的 append() 方法来可以给一个 String 变量的末尾追加 Character 值 字符串插值 字符串插值是一种从混合常量、变量、字面量和表达式的字符串字面量构造新 String 值的方法 每一个你插入到字符串字面量的元素都要被一对圆括号包裹，然后使用反斜杠前缀 \\() 类似于 NSString 的 stringWithFormat 方法，但是更加简便，更强大 可以在扩展字符串分割符中创建一个包含在其他情况下会被当做字符串插值的字符 要在使用扩展分隔符的字符串中使用字符串插值，在反斜杠后使用匹配首尾井号数量的井号 12let str = &quot;6 * 7 = \\(6 * 7)&quot;print(str)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习09：字符串创建和使用","slug":"Swift学习09：字符串创建和使用","date":"2023-02-21T18:58:24.000Z","updated":"2023-03-01T17:06:09.757Z","comments":true,"path":"2023/02/22/Swift学习09：字符串创建和使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A009%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"初始化空串 字面量 初始化器语法 isEmpty 检查是否为空串 123456var emptyString = &quot;&quot;var anotherEmptyString = String()if emptyString.isEmpty &#123; print(&quot;Nothing to see here&quot;)&#125; 字面量 字符串字面量是被双引号 “” 包裹的固定顺序文本字符 Swift 会为 str 常量推断类型为 String 1let str = &quot;some string&quot; 多行字面量 多行字符串字面量是用三个双引号引起来的一系列字符 多行字符串字面量把所有行包括在引号内，开始和结束默认不会有换行符 如果为了书写美观而不换行在后面加 \\ 12345678let someStr = &quot;&quot;&quot;1\\2\\345&quot;&quot;&quot;print(someStr) 要让多行字符串字面量起始或结束于换行，就在第一或最后一行写一个空行 多行字符串可以 缩进 以匹配周围的代码。双引号（”””）前的空格会告诉Swift其他行前应该有多少空白是需要忽略的 如果你在某行的空格超过了结束的双引号（”””），那么这些空格会被包含 12345678 let someStr = &quot;&quot;&quot; 1 2 3 4 5 &quot;&quot;&quot;print(someStr) 字符串里的特殊字符 转义特殊字符 \\o（空字符）,\\（反斜杠），\\t（水平制表符），\\n（换行符），\\r（回车符），\\”（双引号）以及 &#39;（单引号） 任意的 Unicode 标量，写作 \\u&#123;&#125;n，里边的 n 是一个 1-8 位的16进制数字，其值是合法 Unicode 值 1let str = &quot;\\u&#123;24&#125;&quot; 可以在多行字符串字面量中包含双引号（”）而不需要转义。要在多行字符串中包含文本 “”””””，转义至少一个双引号 扩展字符串分隔符(Raw String) 在字符串字面量中放置扩展分隔符来使 包含特殊字符的字符串 不让他们真的生效 把字符串放在双引号 (“) 内并由 (#) 包裹 12let str = #&quot;1\\n2\\n3\\n&quot;#print(str) 如果字符串里面有 &quot;# 则首尾需要两个 ## 12let str = ##&quot;1\\&quot;#n2\\#n3\\#n&quot;##print(str) 如果你需要字符串中某个特殊符号的效果，使用匹配你包裹的 # 号数量的 # 号，并在前面写转义符号 \\ 12let str = #&quot;1\\#n2\\#n3\\#n&quot;#print(str)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习08：Optional的使用Optional实现原理探索","slug":"Swift学习08：Optional的使用Optional实现原理探索","date":"2023-02-21T18:56:00.000Z","updated":"2023-03-01T17:03:15.837Z","comments":true,"path":"2023/02/22/Swift学习08：Optional的使用Optional实现原理探索/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A008%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8Optional%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/","excerpt":"","text":"Optional-实现探究 Optional 其实是一个标准库里的一个 public 的 enum 类型，而且是 泛型 的，泛型的类型是 Wrapped 用标准库实现语言特性的典型 Optional.none 就是 nil Optional.some 则包装了实际的值 12345var str:Optional&lt;String&gt; = &quot;abc&quot;if let actualStr = str &#123; let count = actualStr.count print(count)&#125; Optional-解包实现 泛型属性 unsafelyUnwrapped 理论上我我们可以直接调用 unsafelyUnwrapped 获取可选项的值 123var str:String? = &quot;abc&quot;let count = str.unsafelyUnwrapped.countprint(count)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习07：Optional的使用","slug":"Swift学习07：Optional的使用","date":"2023-02-21T18:55:20.000Z","updated":"2023-03-01T16:54:26.902Z","comments":true,"path":"2023/02/22/Swift学习07：Optional的使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A007%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"为什么需要 Optional？ Object-C 里的 nil 是无类型的指针 Object-C 里面的数组、字典、集合等不允许放入 nil Object-C 所有 对象的变量 都可以为 nil Object-C 只能用在对象上，而在其他地方又用其他特殊值（例如NSNotFound）表示值的缺失 Optional 通过在 变量类型 后面加 ? 表示 这里有一个值，它等于 x 或者 这里根本没有值 你可以通过给可选变量赋值一个 nil 来将之设置为没有值 在 Object-C 中 nil 是一个指向不存在对象的指针 在 Swift 中，nil 不是指针，它是 值缺失的一种特殊类型，任何类型的可选项都可以设置成 nil 而不仅仅是对象 只有可选项才能设置为 nil 12var str: String = nilvar str1: String? = nil Optional-If 语句以及强制解包 可选项是没法直接使用的 需要用 ! 号强制解包后才能使用（意思是我知道这个可选项里面有值，使用吧） 12var str: String? = &quot;abc&quot;let count = str.count 需要改成如下代码，才能正确执行 12var str: String? = &quot;abc&quot;let count = str!.count 或 1234var str: String? = &quot;abc&quot;if str != nil &#123; let count = str!.count&#125; Optional-绑定 可以使用 可选绑定 来判断可选项是否包含值，如果包含就把赋值给一个临时的 常量或变量 可选绑定可以与 if 和 while 的语句使用来检查可选项内部的值，并赋值给一个变量或常量 同一个 if 语句中包含多可选项绑定，用逗号分割即可。如果任一可选绑定结果是 nil 或者 布尔值 为 false ，那么整个 if 判断会被看做 false 12345var str:String? = &quot;abc&quot;if let actualStr = str &#123; let count = actualStr.count print(count)&#125; Optional - 隐士解包 有些可选项一旦被设定值之后，就会一直拥有值，在这种情况下，就可以去掉检查的需求，也不必每次访问的时候都进行解包 通过有声明的类型后边添加一个叹号（String!）而非问号（String?）来书写隐士解包可选项 123var str:String! = &quot;abc&quot;let count = str.countprint(count) 隐士解包可选项主要被用在Swift 类 的初始化过程中 Optional-可选链 可选项后面加问号 如果可选项不为nil，返回一个可选项结果，否则为nil 123var str:String? = &quot;abc&quot;let count = str?.countlet lastIndex = count - 1 将上面的代码改为： 1234567var str:String? = &quot;abc&quot;let count = str?.count//let lastIndex = count - 1if count != nil &#123; let lastIndex = count! - 1 print(lastIndex)&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习06：Tuple元组","slug":"Swift学习06：Tuple元组","date":"2023-02-21T18:54:43.000Z","updated":"2023-03-01T16:48:14.682Z","comments":true,"path":"2023/02/22/Swift学习06：Tuple元组/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A006%EF%BC%9ATuple%E5%85%83%E7%BB%84/","excerpt":"","text":"Tuple 元组 把多个值合并成单一的复合型的值 元组 内的值可以是任何类型，而且可以不必是统一类型 123let error = (1,&quot;没有权限&quot;)print(error.0)print(error.1) 元素命名 元组中的每一个元素可以指定对应的元素名称 123let error = (errorCode:1,errorMessage:&quot;没有权限&quot;)print(error.errorCode)print(error.errorMessage) 如果没有指定名称的元素也可以使用下标的方式来引用 123let error = (1,&quot;没有权限&quot;)print(error.0)print(error.1) Tuple 修改 用 var 定义的元组就是可变元组，let 定义的元组就是不可变元组 不管是可变还是不可变元组，元组在创建后就不能增加和删除元素 可以对可变元组的元素进行修改，但是不能改变其类型 123var error = (errorCode:1,errorMessage:&quot;没有权限&quot;)error.errorCode = 2error.errorMessage = &quot;2&quot; any 类型可以改为任何类型 12345var error: (Any,String) = (1,&quot;没有权限&quot;)error.0 = 2print(error)error.0 = &quot;abc&quot;print(error) Tuple 分解 将一个元组的内容分解成单独的常量或变量 1234let error = (1,&quot;没有权限&quot;)let (errorCode,errorMessage) = errorprint(errorCode)print(errorMessage) 如果只需要使用其中的一部分数据，不需要的数据可以用下划线 _ 代替 123let error = (1,&quot;没有权限&quot;)let (_,errorMessage) = errorprint(errorMessage) 作为函数返回值 使用 Tuple 为函数返回多个值 返回值的 Tuple 可以再函数的返回类型部分被命名 12345func writeToFile(content:String) -&gt; (errorCode:Int,errorMessage:String) &#123; return (1,&quot;没有权限&quot;)&#125;let error = writeToFile(content: &quot;&quot;)print(error)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习05：数值类型","slug":"Swift学习05：数值类型","date":"2023-02-21T18:53:56.000Z","updated":"2023-03-01T16:43:16.134Z","comments":true,"path":"2023/02/22/Swift学习05：数值类型/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A005%EF%BC%9A%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"整数 Swift 提供了 8，16，32，64 位编码的有符号和无符号整数 命名方式：例如 8位无符号整数的类型是 UInt8，32位有符号整数的类型是 Int32 通过 min 和 max 属性来访问每个整数类型的最小值和最大值 Swift 提供了一个额外的整数类型：Int，它拥有与当前平台的原生字相同的长度 同时 Swift 也提供 UInt 类型，来表示平台长度相关的无符号整型 建议在用到证书的地方都使用 Int 浮点类型 Double：64位浮点数，至少有 15 位数字的精度 Float：32位浮点数，至少有 6 为数字的精度 在两种类型都可以的情况下，推荐使用 Double 类型 数值范围 123let a = 8let b: UInt8 = 240print(&quot;UInt8 min \\(UInt8.min),UInt8 max \\(UInt8.max)&quot;) Bool Bool：true 和 false Swift 的类型安全机制会阻止你用一个非布尔量的值替换掉 Bool 1234let i = 1if i &#123; print(i)&#125; 我们修改一下 类型别名 类型别名是一个为 已存在类型 定义的一个 可选择的名字 你可以用关键字 typealias 定义一个类型的别名 当你想通过在一个在上下文中看起来更合适可具有表达行的名字来引用一个已存在的类型时，这时别名就非常有用了 123// 音频采样率typealias AudioSample = UInt8let sample:AudioSample = 32","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习04：变量和常量","slug":"Swift学习04：变量和常量","date":"2023-02-21T18:12:27.000Z","updated":"2023-03-01T16:40:54.558Z","comments":true,"path":"2023/02/22/Swift学习04：变量和常量/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A004%EF%BC%9A%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/","excerpt":"","text":"声明变量和常量 使用关键字 let 声明常量 12let a = 1a = 2 由于 x 是常量，不能给常量赋值，会报错 使用关键字 var 声明变量 12var b = 1b = 2 可以在一行中声明多个变量和常量，用逗号分割 1var x = 0.0,y = 1.0,z = 2.0 类型标注 在声明一个变量或常量时提供类型标注，来明确变量或常量能够存储值的类型 添加 类型标注 的方法是在 变量或常量 的名字后面加一个 冒号，再跟一个 空格，最后加上使用的 类型名称 可以在一行中定义多个相关的变量为相同的类型，用 逗号 分割，只要在最后的变量名字后加上类型标注 123var a: Stringa = &quot;hello&quot;a = 10 常量和变量命名 常量和变量的名字几乎可以使用任何字符，甚至包括 Unicode 字符 常量和变量的名字不能包含 空白字符、数学符号、箭头、保留的（或者无效的）Unicode码位、连线和制表符。也不能以 数字 开头，尽管数字几乎可以使用在名字其他的任何地方 123let π = 3.1415let 你好 = &quot;你好世界&quot;let 🐶🐂 = &quot;dog,cow&quot; 打印常量和变量 print(_:separator:teminator) 字符串插入 用 \\() 来插入 123456let π = 3.1415let 你好 = &quot;你好世界&quot;let 🐶🐂 = &quot;dog,cow&quot;print(π)print(&quot;\\(你好)&quot;)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习03：Playgorund使用","slug":"Swift学习03：Playground使用","date":"2023-02-21T16:41:59.000Z","updated":"2023-03-01T16:37:15.616Z","comments":true,"path":"2023/02/22/Swift学习03：Playground使用/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A003%EF%BC%9APlayground%E4%BD%BF%E7%94%A8/","excerpt":"","text":"简介 Swift 的 Playgorund 是为了让人人都能愉快的学习 swift 编程 但发展至今，这个工具越来越强大 Playgorund 使用 创建一个 Playgorund 应用 Next，默认名 MyPlayground 可以通过 New -&gt; Playground Page 创建多个 Playground 来学习 注：快捷键 command + option + n 创建 Playground Page command + shift + enter 快速运行程序 简单使用 写一个求和的函数 12345678// 求和函数func sum(a:Int,b:Int) -&gt; Int &#123; return a+b&#125;// 调用求和函数 赋值给 常量 clet c = sum(a: 1, b: 2)// 打印常量 cprint(c)","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习02：REPL交互式解释器","slug":"Swift学习02：REPL交互式解释器","date":"2023-02-21T16:41:38.000Z","updated":"2023-03-01T17:50:48.372Z","comments":true,"path":"2023/02/22/Swift学习02：REPL交互式解释器/","link":"","permalink":"https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A002%EF%BC%9AREPL%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%99%A8/","excerpt":"","text":"介绍 xcode 6.1 引进了另外一种以交互式的方式来体验 Swift 的方法 Read Eval PrintLoop，简称REPL 使用REPL 除了可以 定义常量和变量 外，还是可 定义函数 打开终端输入 12mac@bogon ~ % swiftmac@bogon ~ % swift repl 定义变量 定义函数 REPL 其他命令 退出：:quit 帮助：:help 将光标移动到当前行的开始处：Control + A 将光标移动到当前行的结束处：Control + E","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Swift学习01：Swift编译流程","slug":"Swift学习01：Swift编译过程","date":"2023-02-21T15:49:55.000Z","updated":"2023-03-01T17:50:40.800Z","comments":true,"path":"2023/02/21/Swift学习01：Swift编译过程/","link":"","permalink":"https://www.bboyzj.cn/2023/02/21/Swift%E5%AD%A6%E4%B9%A001%EF%BC%9ASwift%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","excerpt":"","text":"编译器架构Swift编译过程和OC基本类似，仅仅是前端编译器不一样。 OC/C 前端编译器是 Clang Swift 先解析成 Swift AST（抽象语法树），通过 swiftc 这个命令行参数，编译成 Swift IL OC 和 Swift 最后均编译成 LLVM IR 中间层表示 OC 和 Swift 最终通过 后端编译器 LLVM compiler ，编译成最终的在具体地址上可以执行的二进制，包括x86、arm和other 详细编译流程 Swift 先解析成 AST（抽象语法树） 经过一系列工具编程 Swift 的 SIL(中间语言) 再经过 分析、IR工具 转成 LLVM IR(中间表示层) 最终通过 后端编译器 LLVM compiler 编译成 .o 目标文件 命令行流程使用终端创建一个简单的 main.swift 文件 12mac@bogon ~ % cd Desktopmac@bogon Desktop % touch main.swift 此时你可以在桌面看到一个 main.swift 文件 在该文件下写下两个数相加的一个函数 123456func sum(a:Int,b:Int) -&gt; Int &#123; return a + b&#125;let value = sum(a: 1, b: 2)print(value) 打开命令行工具 mac@bogon ~ % cd Desktop 生成 AST 抽象语法树 mac@bogon ~ % swiftc main.swift -dump-ast 生成 SIL 中间语言 mac@bogon ~ % swiftc main.swift -emit-sil 生成 LLVM IR 中间表示层 mac@bogon ~ % swiftc main.swift -emit-ir 生成 Assembly Language 汇编语言 mac@bogon ~ % swiftc main.swift -emit-assembly 生成二进制文件 mac@bogon ~ % swiftc -o main.out main.swift 命令行输入： 1234mac@bogon ~ % cd /Users/mac/Desktop/01swift编译流程 mac@bogon 01swift编译流程 % swiftc -o main.out main.swiftmac@bogon 01swift编译流程 % ./main.out3","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]},{"title":"Flutter面试题：Flutter总结","slug":"Flutter面试题01：Flutter面试题","date":"2023-02-15T17:21:00.000Z","updated":"2023-03-03T06:19:14.597Z","comments":true,"path":"2023/02/16/Flutter面试题01：Flutter面试题/","link":"","permalink":"https://www.bboyzj.cn/2023/02/16/Flutter%E9%9D%A2%E8%AF%95%E9%A2%9801%EF%BC%9AFlutter%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"什么是flutter？原理是什么？ flutter 是 google 推出并 开源的移动应用开发框架，通过 dart 语言开发APP，一套代码可以同时运行在 iOS 和 Android 平台。 flutter 底层使用 skia 作为 2D渲染引擎，通过自己的渲染引擎来 绘制widget(组件)，dart 语言借鉴了 Java 和 JavaScript 同时加入了一些 现代编程语言 特性。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://www.bboyzj.cn/categories/Flutter/"}],"tags":[{"name":"Flutter-面试题","slug":"Flutter-面试题","permalink":"https://www.bboyzj.cn/tags/Flutter-%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"keywords":[{"name":"Flutter","slug":"Flutter","permalink":"https://www.bboyzj.cn/categories/Flutter/"}]},{"title":"Swift学习00：简介","slug":"Swift学习00：简介","date":"2020-08-22T13:17:43.000Z","updated":"2023-03-01T17:50:37.544Z","comments":true,"path":"2020/08/22/Swift学习00：简介/","link":"","permalink":"https://www.bboyzj.cn/2020/08/22/Swift%E5%AD%A6%E4%B9%A000%EF%BC%9A%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Swift介绍Swift是Apple在2014年6月WWDC发布的全新的编程语言。 Swift是一种高性能系统编程语言，提供了对现有C和OC代码框架的无缝访问，并且是内存安全的。 Swift语言更加简洁，是一门类型安全的语言。 Swift和OC的区别 编程范式 Swift可以 面试协议编程、函数式编程和面向对象编程 OC以 面向对象编程 为主，当然你可以引入 Reactive Cocoa 的类库来进行函数式编程 类型安全 Swift是一门 类型安全的语言。鼓励程序员在代码中清楚明确值的类型。如果代码中使用一个字符串String，那么你不能错误地传递一个整型Int给它。因为Swift是类型安全的，它会在代码编译的时候做类型检查，并且把所有不匹配的类型作为一个错误标记出来。这样使得程序员在开发中尽可能早地发现和修正错误。 而OC则 不是类型安全的语言，你声明一个NSString变量，仍然可以传递一个NSNumber给它，尽管编译器会抱怨，但是你仍然可以作为NSNumber来使用它。 值类型的增强 在Swift中，典型的有 struct、enum 以及 元祖tuple 都是值类型。而平时使用的Int、Double、Float 、String 、Array 、Dictionary、Set其实都是用结构体实现的，也是 值类型。 OC中，NSNumber、NSString以及集合类对象都是指针类型。 枚举增强 Swift的枚举可以使用 整型、浮点型、字符串等，还能拥有 属性和方法，甚至支持 泛型、协议、扩展等。 OC里面的枚举则鸡肋很多。 泛型 Swift中 支持泛型，也支持泛型的类型约束等特性 苹果推出了Swift2.0版本，为了让开发者从OC更好的国度到Swift上，苹果也为OC带来了Gennerics泛型支持，不过OC的泛型约束也仅停留在编译器警告阶段。 协议和扩展 Swift对协议的支持更加丰富，配合扩展（extension）、泛型、关联类型等可以实现面向协议编程，从而大大提高代码的灵活性。同时swift中的protocol还可以用于值类型，如结构体和枚举 OC的协议却反强约束，提供optional特性往往成为很多问题得来源，而如果放弃optional又会让实现代价过大。 函数和闭包 Swift函数是一等公民，可以直接定义函数类型变量，可以作为其他函数参数传递，可以作为函数的返回值类型。 OC里面函数仍然是次等公民，需要selector封装或者使用block才能模拟Swift中类似的效果。","categories":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}],"tags":[{"name":"Swift-学习篇","slug":"Swift-学习篇","permalink":"https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"https://www.bboyzj.cn/categories/Swift/"}]}]}