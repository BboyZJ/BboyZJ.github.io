<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="我是小J，关注我">
    <meta name="author" content="张建">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://www.bboyzj.cn/2021/01/25/oc底层原理/oc底层原理23：kvo底层原理分析/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    <meta property="og:type" content="article">
    <meta property="og:title" content="OC底层原理23：KVO底层原理分析">
    <meta property="og:description" content="我是小J，关注我">
    <meta property="og:url" content="https://www.bboyzj.cn2021/01/25/OC底层原理/OC底层原理23：KVO底层原理分析/">
    <meta property="og:image" content="/images/redefine-logo.svg">
    <meta property="og:site_name" content="BboyZJ">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="OC底层原理23：KVO底层原理分析">
    <meta name="twitter:description" content="我是小J，关注我">
    <meta name="twitter:image" content="/images/redefine-logo.svg">
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/BboyZJ.github.io/images/redefine-logo.svg">
    
    <title>
        
            OC底层原理23：KVO底层原理分析 -
        
        BboyZJ
    </title>
    
<link rel="stylesheet" href="/BboyZJ.github.io/css/style.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/assets/fonts.css">

    
    
    
    
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"www.bboyzj.cn","root":"/BboyZJ.github.io/","language":"en","path":"search.xml"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/head_img.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"学无止境 学而不思则罔 思而不学则殆","custom_font":{"enable":false,"font_family":null,"font_url":null}},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_block":{"copy":true,"style":"mac","custom_font":{"enable":false,"font_family":null,"font_url":null}},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"1.1.5","friend_links":{"columns":2},"home_article":{"date_format":"auto","category":{"enable":true,"limit":3},"tag":{"enable":true,"limit":3}},"plugins":{"aplayer":{"enable":false,"audio":[{"name":null,"artist":null,"url":null,"cover":null},{"name":null,"artist":null,"url":null,"cover":null}]}}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/BboyZJ.github.io/atom.xml" title="张建的博客" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="menu-wrapper">
    
    <div class="menu-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                BboyZJ
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        首页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/tags/"  >
                                    
                                        
                                            <i class="fa-regular fa-tags"></i>
                                        
                                        标签
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/categories/"  >
                                    
                                        
                                            <i class="fa-regular fa-categories"></i>
                                        
                                        分类
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="menu-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                首页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/tags/"  >
                             
                                
                                    <i class="fa-regular fa-tags"></i>
                                
                                标签
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/categories/"  >
                             
                                
                                    <i class="fa-regular fa-categories"></i>
                                
                                分类
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">OC底层原理23：KVO底层原理分析</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/BboyZJ.github.io/images/head_img.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">张建</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2021-01-25 16:34:11</span>
        <span class="mobile">2021-01-25 16:34</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="pc">2022-04-25 11:21:28</span>
            <span class="mobile">2022-04-25 11:21</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/BboyZJ.github.io/categories/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/">OC-底层原理探索篇</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/BboyZJ.github.io/tags/iOS-OC/">iOS-OC</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>KVO</code> 全称 <code>Key Value Observing</code>，中文名为 <code>键值观察</code>，KVO是一种机制，它 <code>允许将其他对象的指定属性的更改通知给对象</code></p>
<p>在 <a class="link"   target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOBasics.html#//apple_ref/doc/uid/20002252-BAJEAIEE" >key Value Observing Programming Guide <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 官方文档中，有这么一句话：<code>理解KVO之前，必须先理解 KVC</code>（即KVO是基于KVC基础之上）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In order to understand key-value observing, you must first understand key-value coding.</span><br><span class="line"></span><br><span class="line">KVC是键值编码，在对象创建完成后，可以动态的给对象属性赋值，而KVO是键值观察，提供了一种监听机制，当指定的对象的属性被修改后，则对象会收到通知，所以可以看出KVO是基于KVC的基础上对属性动态变化的监听</span><br></pre></td></tr></table></figure></div>

<p>在iOS日常开发中，经常 <code>使用KVO来监听对象属性的变化</code>，并及时作出响应，即当指定的被观察对象属性被修改后，<code>KVO</code> 会自动通知响应的管擦着，那么 <code>KVO</code> 与 <code>NSNotificationCenter</code> 有什么区别呢？</p>
<ul>
<li><p>相同点</p>
<ul>
<li>两者的实现原理 <code>都是观察者模式</code>，都是用于 <code>监听</code></li>
<li>都能 <code>实现一对多</code> 的操作</li>
</ul>
</li>
<li><p>不同点</p>
<ul>
<li><code>KVO只能用于监听对象属性的变化</code>，并且属性名都是通过 <code>NSString</code> 来查找，编译器不会帮你检测对错和补全，纯手敲会比较容易出错</li>
<li><code>NSNotification</code> 的 <code>发送监听（post）</code> 的操作 <code>我们可以控制</code>，<code>KVO由系统控制</code></li>
<li><code>KVO</code> 可以 <code>记录新旧值变化</code></li>
</ul>
</li>
</ul>
<h1 id="KVO-使用"><a href="#KVO-使用" class="headerlink" title="KVO 使用"></a>KVO 使用</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>KVO的基本使用主要分为三步：</p>
<ul>
<li>注册观察者 <code>addObserver:forKeyPath:option:context</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br></pre></td></tr></table></figure></div>

<ul>
<li>实现KVO回调 <code>observerValueForKeyPath:ofObject:change:context</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;name&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>移除观察者 <code>removeObserver:forKeyPath:context</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.person removeObserver:self forKeyPath:@&quot;name&quot; context:NULL];</span><br></pre></td></tr></table></figure></div>

<h2 id="context-使用"><a href="#context-使用" class="headerlink" title="context 使用"></a>context 使用</h2><p>在官方文档中，针对 <code>参数context</code> 有如下说明：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25925248/160746846-6937a586-15d2-4d2c-ace8-dad2e559d00e.png"
                     
                ></p>
<p>大致含义就是：<code>addObserver:forKeyPath:option:context:</code> 方法中的 <code>上下文context</code> 指针包含任意数据，这些数据将在响应的更改通知中传递回观察者。可以通过 <code>指定context为NULL</code>，从而 <code>依靠keyPath</code> 即 <code>键路径字符串</code> 传来的确定更改通知的来源，但是这种方法可能导致对象的父类由于不同的原因也观察到相同的键路径而导致问题。所以可以为每个观察到的 <code>keyPath</code> 创建一个不同的 <code>context</code>，从而 <code>完全不需要进行字符串比较</code>，从而可以更有效地进行通知解析</p>
<p>通俗的讲，<code>context上下文</code> 主要是用于 <code>区分不同对象的同名属性</code>，从而在KVO回调方法中可以 <code>直接使用context进行区分，可以大大提高性能，以及代码的可读性，并且更加安全</code></p>
<p><strong>context使用总结</strong></p>
<ul>
<li>不使用 <code>context</code>，使用 <code>keyPath</code> 区分通知来源</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// context的类型是 nullable void *，应该是NULL，而不是nil</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用 context 区分通知来源</li>
</ul>
<p>Person类中增加两个属性</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,copy)NSString * name;</span><br><span class="line">@property (nonatomic,copy)NSString * nick;</span><br></pre></td></tr></table></figure></div>

<p>DetailViewController类中代码实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 定义context</span><br><span class="line">static void * PersonNickContext = &amp;PersonNickContext;</span><br><span class="line">static void * PersonNameContext = &amp;PersonNameContext;</span><br><span class="line"></span><br><span class="line">// 注册观察者</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;nick&quot; options:NSKeyValueObservingOptionNew context:PersonNickContext];</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:PersonNameContext];</span><br><span class="line">    </span><br><span class="line">// KVO回调</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if (context == PersonNickContext) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;else if (context == PersonNameContext)&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// KVO移除</span><br><span class="line">[self.person removeObserver:self forKeyPath:@&quot;name&quot;];</span><br><span class="line">[self.person removeObserver:self forKeyPath:@&quot;nick&quot;];</span><br></pre></td></tr></table></figure></div>

<h2 id="移除KVO通知的必要性"><a href="#移除KVO通知的必要性" class="headerlink" title="移除KVO通知的必要性"></a>移除KVO通知的必要性</h2><p>在官方文档中，针对 <code>KVO移除</code> 有以下几点说明：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25925248/160746851-ed7e0343-880b-445c-8aff-0c4ab592de47.png"
                     
                ></p>
<p>删除观察者时，请记住以下几点：</p>
<ul>
<li><p>要求被移除为观察者（如果尚未注册为观察者）会导致 <code>NSRangeException</code>，您可以对 <code>removeObserver:forKeyPath:context:</code> 进行一次调用，以对应对 <code>addObserver:forKeyPath:option:context:</code> 的调用，或者如果在您的应用中不可行，则将 <code>removeObserver:forKeyPath:context:</code> 调用在 <code>try/catch块</code> 内处理潜在的异常</p>
</li>
<li><p><code>释放后，观察者不会自动将其自身移除</code>。被观察对象继续发送通知，而或略了观察者的状态。但是，与发送到已释放对象的任何其他消息一样，更改通知会触发内存访问异常。因此，您 <code>可以确保观察者在从内存中消失之前将自己移除</code></p>
</li>
<li><p>该协议无法询问对象是观察者还是被观察者。构造代码以避免发布相关的错误。一种典型的模式是在观察者初始化期间（例如，<code>在init或viewDidLoad中注册为观察者</code>），并在释放过程中（通常 <code>在dealloc中注销</code>），以确保成对和有序添加和删除观察者，并确保观察者在注册之前被取消注册，从内存中释放出来</p>
</li>
</ul>
<p>所以，总的来说，<code>KVO注册观察者和移除观察者时需要成对出现的</code>，如果 <code>只注册不移除</code>，<code>会出现类似野指针的崩溃（EXC_BAD_ACCESS）</code>，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25925248/160746861-ac7dcc0b-5307-4cf7-bc71-45e0792c0dd3.jpg"
                     
                ></p>
<p>崩溃的原因是，由于 <code>第一次注册KVO观察者没有移除</code>，再次进入页面，会 <code>第二次注册KVO观察者</code>，导致 <code>KVO观察者的重复注册</code>，而且第一次的通知对象还在内存中，没有进行释放，此时接收到属性值变化的通知，会出现 <code>找不到原有的通知对象，只能找到现有的通知对象</code>，即第二次KVO注册的观察者，所以 <code>导致了类似野指针的崩溃</code>，即一直保持着一个 <code>野通知</code>，且一直在监听</p>
<p>注：这里的崩溃案例是通过 <code>单例对象</code> 实现（崩溃有很大的几率，不是每次必现），因为单例对象在内存是常驻的，针对一般的类对象，貌似不移除也是可以的，但是为了防止线上意外，建议还是移除比较好</p>
<h2 id="KVO的自动触发与手动触发"><a href="#KVO的自动触发与手动触发" class="headerlink" title="KVO的自动触发与手动触发"></a>KVO的自动触发与手动触发</h2><p>KVO观察者的 <code>开启和关闭</code> 有两种方式：<code>自动和手动</code></p>
<ul>
<li>自动开关，返回 <code>NO</code> 就是监听不到，返回 <code>YES</code> 表示监听</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 自动开关</span><br><span class="line">+ (BOOL) automaticallyNotifiesObserversForKey:(NSString *)key&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>自动开关关闭的时候，可以通过 <code>手动开关监听</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 自动关闭时，手动开启</span><br><span class="line">- (void)setName:(NSString *)name&#123;</span><br><span class="line">    // 手动开关</span><br><span class="line">    [self willChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">    _name = name; // 父类的setter方法</span><br><span class="line">    [self didChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查看打印结果</span><br><span class="line">2022-03-09 10:27:56.006156+0800 KVO_Demo[4580:3263311] &#123;</span><br><span class="line">    kind = 1;</span><br><span class="line">    new = &quot;hello world&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用手动开关的好处就是你想监听就监听，不想监听关闭即可，比自动触发更方便灵活</p>
<h2 id="KVO观察：一对多"><a href="#KVO观察：一对多" class="headerlink" title="KVO观察：一对多"></a>KVO观察：一对多</h2><p>KVO观察中的 <code>一对多</code>，意思是通过 <code>注册一个KVO观察者</code>，可以 <code>监听多个属性的变化</code></p>
<p>以下载进度为例，比如目前有一个需求，需要根据 <code>总的下载量totalData</code> 和 <code>当前下载量currentData</code> 来计算 <code>当前的下载进度downloadProcess</code>，实现如下：</p>
<p><strong>【合二为一观察法】：</strong></p>
<ul>
<li>分别观察 <code>总的下载量totalData</code> 和 <code>当前下载量currentData</code> 两个属性，当其中一个发生变化 <code>计算当前下载量进度downloadProcess</code>，实现 <code>keyPathsForValueAffectingValueForKey</code> 方法，将两个观察合为一个观察，即 <code>观察当前下载进度currentProcess</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic,copy)NSString * name;</span><br><span class="line">@property (nonatomic,copy)NSString * nick;</span><br><span class="line">@property (nonatomic,assign)double totalData;</span><br><span class="line">@property (nonatomic,assign)double currentData;</span><br><span class="line">@property (nonatomic,copy)NSString * downloadProcess; // 下载进度</span><br><span class="line">@property (nonatomic,strong)NSMutableArray * mArr; // 可变数组</span><br><span class="line">+ (instancetype)shareInstance;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">+ (instancetype)shareInstance&#123;</span><br><span class="line">    static Person * person = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        person = [[Person alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -2.合二为一的观察法</span><br><span class="line">+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key&#123;</span><br><span class="line">    NSSet * keyPaths = [super keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    if ([key isEqualToString:@&quot;downloadProcess&quot;]) &#123;</span><br><span class="line">        NSArray * affectingKeys = @[@&quot;totalData&quot;,@&quot;currentData&quot;];</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    return keyPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>

<ul>
<li>注册KVO观察者，当 <code>currentData改变</code> 时，计算 <code>当前下载进度downloadProcess</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 2.合二为一的观察法</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;downloadProcess&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br><span class="line">    </span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 2.合二为一的观察法</span><br><span class="line">    self.person.currentData += 1;</span><br><span class="line">    self.person.totalData = 100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -KVO回调</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    // 2.合二为一的观察法</span><br><span class="line">    Person * person = (Person *)object;</span><br><span class="line">    NSLog(@&quot;%f&quot;,person.currentData/person.totalData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -delloc</span><br><span class="line">-(void)dealloc&#123;    </span><br><span class="line">    // 2.合二为一的观察法</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;downloadProcess&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="KVO观察可变数组"><a href="#KVO观察可变数组" class="headerlink" title="KVO观察可变数组"></a>KVO观察可变数组</h2><p><code>KVO</code> 是 <code>基于KVC</code> 基础 <code>之上</code> 的，所以 <code>可变数组</code> 如果 <code>直接添加数据</code>，是 <code>不会调用setter方法</code> 的，所有 <code>对可变数组的KVO观察</code> 下面这种方式 <code>是不生效</code> 的，即直接通过 <code>[self.person.mArr addObject:@&quot;1&quot;];</code> 像数组添加元素，是 <code>不会触发KVO</code> 通知回调的，如下代码是不会通知回调的：</p>
<ul>
<li><code>Person.h</code> 中</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic,strong)NSMutableArray * mArr; // 可变数组</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>DetailViewController.m</code> 中</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 可变数组</span><br><span class="line">self.person.mArr = [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;mArr&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 可变数组</span><br><span class="line">    [self.person.mArr addObject:@&quot;1&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -KVO回调</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    // 可变数组</span><br><span class="line">    NSLog(@&quot;%@&quot;,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)dealloc&#123;</span><br><span class="line">    // 可变数组</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;mArr&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 KVC官方文档中，针对 <code>可变数组的集合</code> 类型，有如下说明，即访问集合对象需要通过 <code>mutableArrayValueForKey</code> 方法，这样才能 <code>将元素添加到可变数组中</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25925248/160746894-fceaad2c-bd75-417a-b9a2-7937ead83d1f.png"
                     
                ></p>
<p>因此，需要将上面 <code>可变数组</code> 添加元素的方法，改为如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 可变数组</span><br><span class="line">    [[self.person mutableArrayValueForKey:@&quot;mArr&quot;] addObject:@&quot;1&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果如下，可以看到，<code>元素被添加到可变数组了</code>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2022-03-09 10:11:24.697680+0800 KVO_Demo[4557:3255716] &#123;</span><br><span class="line">    indexes = &quot;&lt;_NSCachedIndexSet: 0x2826d91c0&gt;[number of indexes: 1 (in 1 ranges), indexes: (0)]&quot;;</span><br><span class="line">    kind = 2; // 插入</span><br><span class="line">    new =     (</span><br><span class="line">        1</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中的 <code>kind</code> 表示 <code>键值变化的类型</code>，是一个枚举，主要有以下 <code>4</code> 种：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, NSKeyValueChange) &#123;</span><br><span class="line">    NSKeyValueChangeSetting = 1,        // 设值</span><br><span class="line">    NSKeyValueChangeInsertion = 2,      // 插入</span><br><span class="line">    NSKeyValueChangeRemoval = 3,        // 移除</span><br><span class="line">    NSKeyValueChangeReplacement = 4,    // 替换</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>一般的 <code>属性</code> 与 <code>集合</code> 的KVO观察是由区别的，其 <code>kind不同</code>，以 <code>属性name</code> 和 <code>可变数组</code> 为例</p>
<ul>
<li><code>属性</code> 的 <code>kind</code> 一般是 <code>设值</code></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25925248/160746909-b6aff51a-7aee-48b7-aa13-ccd04482ac3c.jpg"
                     
                ></p>
<ul>
<li><code>可变数组</code> 的 <code>kind</code> 一般是 <code>插入</code></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25925248/160746915-1745aa00-450c-4ae7-9e1c-c767fbba828e.jpg"
                     
                ></p>
<h1 id="KVO的底层原理探索"><a href="#KVO的底层原理探索" class="headerlink" title="KVO的底层原理探索"></a>KVO的底层原理探索</h1><p>官方文档说明</p>
<p>在KVO的官方文档使用指南中，有如下说明</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25925248/160746922-6b230564-1bc2-4a3a-839a-15abde252490.png"
                     
                ></p>
<ul>
<li><p><code>KVO</code> 是使用 <code>isa-swizzling</code> 的技术实现的</p>
</li>
<li><p>顾名思义，<code>isa指针指向维护分配表的对象的类</code>。该分配表实质上包含指向该类实现的方法的指针以及其他数据</p>
</li>
<li><p>当为对象的属性 <code>注册观察者时</code>，将 <code>修改</code> 观察者对象的 <code>isa指针</code>，指向中间类 <code>而不是真实类</code>。结果，<code>isa</code> 指针的值不一定反映实例的实际类</p>
</li>
<li><p>你不应该依靠isa指针来确定类的成员变量，相反，你应该 <code>使用class方法来确定对象实例的类</code></p>
</li>
</ul>
<h1 id="代码调式探索"><a href="#代码调式探索" class="headerlink" title="代码调式探索"></a>代码调式探索</h1><h2 id="KVO只对属性观察"><a href="#KVO只对属性观察" class="headerlink" title="KVO只对属性观察"></a>KVO只对属性观察</h2><p>在 <code>ZJPerson</code> 中有一个 <code>成员变量name</code> 和 <code>属性nick</code>，分别注册KVO观察者，触发属性变化时，会有什么现象？</p>
<ul>
<li>创建 <code>ZJPerson</code> 类，声明 <code>成员变量name</code> 和 <code>属性nick</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">    NSString * name;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic,copy)NSString * nick;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>

<ul>
<li>分别为 <code>成员变量name</code> 和 <code>属性nick</code> 注册观察者</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor orangeColor];</span><br><span class="line">    </span><br><span class="line">    self.person = [[ZJPerson alloc] init];</span><br><span class="line">    </span><br><span class="line">    [self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br><span class="line">    [self.person addObserver:self forKeyPath:@&quot;nick&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>KVO触发通知操作</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    self.person-&gt;name = @&quot;ZJ&quot;;</span><br><span class="line">    self.person.nick = @&quot;XJ&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>KVO接收通知操作</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>运行结果如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2022-03-09 14:33:59.443356+0800 002--KVO原理探讨[4675:3328750] &#123;</span><br><span class="line">    kind = 1; </span><br><span class="line">    new = XJ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>结论</strong>：KVO对 <code>成员变量name不观察</code>，只对 <code>属性name观察</code>，属性和成员变量的区别在于 <code>属性多了一个setter方法</code>，而 <code>KVO恰好观察的是setter方法</code></p>
<h2 id="中间类"><a href="#中间类" class="headerlink" title="中间类"></a>中间类</h2><p>根据官方文档所述，在 <code>注册KVO观察者后，观察者对象的isa指针指向会发生改变</code></p>
<ul>
<li>注册观察者之前： <code>实例对象person</code> 的 <code>isa</code> 指针指向 <code>ZJPerson</code></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25925248/160746946-a965acac-9bed-432f-b9d9-6c14a22d17b5.jpg"
                     
                ></p>
<ul>
<li>注册观察者之后：<code>实例对象person</code> 的 <code>isa</code> 指针指向 <code>NSKVONotifing_ZJPerson</code></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25925248/160746974-2227abf4-5850-4b8f-a73c-64c2c1856eaa.jpg"
                     
                ></p>
<p>综上所述，在注册观察者后，<code>实例对象</code> 的 <code>isa</code> 指针 <code>指向</code> 由 <code>ZJPerson类</code> 变为了 <code>NSKVONotifying_ZJPerson中间类</code>，即实例对象的 <code>isa</code> 指针指向发生了变化</p>
<h2 id="判断中间类是否是-派生类-即-子类？"><a href="#判断中间类是否是-派生类-即-子类？" class="headerlink" title="判断中间类是否是 派生类 即 子类？"></a>判断中间类是否是 <code>派生类</code> 即 子类？</h2><p>那么这个动态生成的中间类 <code>NSKVONotifying_ZJPerson</code> 和 <code>ZJPerson</code> 有什么关系？下面通过代码来验证</p>
<p>可以通过下面封装的方法，获取ZJPerson的相关类</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 添加KVO之前</span><br><span class="line">[self printClasses:[ZJPerson class]];</span><br><span class="line">    </span><br><span class="line">// 添加观察者</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;nick&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br><span class="line">    </span><br><span class="line">// 添加KVO之后</span><br><span class="line">[self printClasses:[ZJPerson class]];</span><br><span class="line"></span><br><span class="line">#pragma mark -遍历类以及子类</span><br><span class="line">- (void)printClasses:(Class)cls&#123;</span><br><span class="line">    // 注册类的总数</span><br><span class="line">    int count = objc_getClassList(NULL, 0);</span><br><span class="line">    // 创建一个数组， 其中包含给定对象</span><br><span class="line">    NSMutableArray * mArr = [NSMutableArray arrayWithObject:cls];</span><br><span class="line">    // 获取所有已注册的类</span><br><span class="line">    Class * classes = (Class*)malloc(sizeof(Class)*count);</span><br><span class="line">    objc_getClassList(classes, count);</span><br><span class="line">    for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">        if (cls == class_getSuperclass(classes[i])) &#123;</span><br><span class="line">            [mArr addObject:classes[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(classes);</span><br><span class="line">    NSLog(@&quot;classes = %@&quot;, mArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>打印结果如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25925248/160747000-ede43dee-9514-4387-aeb3-e73220fffaef.jpg"
                     
                ></p>
<p>从打印结果可以得出，<code>NSKVONotifying_ZJPerson</code> 是 <code>ZJPerson</code> 的子类</p>
<h2 id="中间类中有什么？"><a href="#中间类中有什么？" class="headerlink" title="中间类中有什么？"></a>中间类中有什么？</h2><p>可以通过下面的方法获取 <code>NSKVONotifying_ZJPerson</code> 类中的所有方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 遍历方法</span><br><span class="line">[self printClassAllMethod:objc_getClass(&quot;NSKVONotifying_ZJPerson&quot;)];</span><br><span class="line">    </span><br><span class="line">#pragma mark -遍历方法</span><br><span class="line">- (void)printClassAllMethod:(Class)cls&#123;</span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    // 获取一个类中的所有实例方法</span><br><span class="line">    Method * methodList = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">        // 获取单个方法</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        // 方法编号</span><br><span class="line">        SEL sel = method_getName(method);</span><br><span class="line">        // 方法实现</span><br><span class="line">        IMP imp = class_getMethodImplementation(cls, sel);</span><br><span class="line">        NSLog(@&quot;%@ - %p&quot;,NSStringFromSelector(sel),imp);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>查看打印结果</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25925248/160747013-29f9e86f-4641-4f75-8d7a-4ec033f7c1d7.jpg"
                     
                ></p>
<p>从结果中可以看出有四个方法，分别是 <code>setNick、class、dealloc、_isKVOA</code>，这些方法是 <code>继承</code> 还是 <code>重写</code>？</p>
<ul>
<li>在 <code>ZJStudent(继承自ZJPerson)</code> 中重写 <code>setNick</code> 方法，获取 <code>ZJStudent</code> 类的所有方法</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25925248/160747029-cb6389e3-faae-4fb8-b248-67c4ce185378.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25925248/160747037-0c297291-98a3-4e8e-bff7-e84db481aafd.jpg"
                     
                ></p>
<p>由打印结果可知，如果是继承那么 <code>NSKVONotifying_ZJPerson</code> 打印的方法应该与 <code>ZJPerson</code> 打印的结果一致</p>
<ul>
<li>获取 <code>ZJPerson</code> 和 <code>NSKVONotifying_ZJPerson</code> 的方法列表进行对比</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25925248/160747047-7900c4b7-e62d-40a6-9811-ff63be5ca592.jpg"
                     
                ></p>
<p><strong>【结论】</strong> 综上所述，有如下结论：</p>
<ul>
<li><p><code>NSKVONotifying_ZJPerson</code> 中间类 <code>重写</code> 了 <code>父类ZJPerson</code> 的 <code>setNick</code> 方法</p>
</li>
<li><p><code>NSKVONotifying_ZJPerson</code> 中间类 <code>重写</code> 了 <code>基类NSObject</code> 的 <code>class、dealloc、_isKVOA</code> 方法</p>
<ul>
<li>其中 <code>dealloc</code> 是释放方法</li>
<li><code>_isKVOA</code> 判断当前是否是 <code>KVO类</code></li>
</ul>
</li>
</ul>
<h2 id="dealloc中移除观察者后，isa指向谁，以及中间类是否会销毁？"><a href="#dealloc中移除观察者后，isa指向谁，以及中间类是否会销毁？" class="headerlink" title="dealloc中移除观察者后，isa指向谁，以及中间类是否会销毁？"></a>dealloc中移除观察者后，isa指向谁，以及中间类是否会销毁？</h2><ul>
<li>移除观察者前：<code>实例对象的isa</code> 指向仍是 <code>NSKVONotifying_ZJPerson中间类</code></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25925248/160747072-cbfc301c-f0e9-448c-a502-999ab225df54.jpg"
                     
                ></p>
<ul>
<li>移除观察者之后：实例对象的isa指针指向更改为 <code>ZJPerson类</code></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25925248/160747086-afb0048f-be74-4a27-b1cf-c7f77d426307.jpg"
                     
                ></p>
<p>所以，在 <code>移除KVO观察者后</code>，<code>isa</code> 的指向由 <code>KSKVONotifying_ZJPerson</code> 变成了 <code>ZJPerson</code></p>
<h2 id="那么中间类从创建后，到dealloc方法中移除观察者之后，KSKVONotifying-ZJPerson-是否还存在？"><a href="#那么中间类从创建后，到dealloc方法中移除观察者之后，KSKVONotifying-ZJPerson-是否还存在？" class="headerlink" title="那么中间类从创建后，到dealloc方法中移除观察者之后，KSKVONotifying_ZJPerson 是否还存在？"></a>那么中间类从创建后，到dealloc方法中移除观察者之后，KSKVONotifying_ZJPerson 是否还存在？</h2><ul>
<li>在上一个界面打印 <code>ZJPerson</code> 的子类情况，用于判断中间类是否销毁</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-images.githubusercontent.com/25925248/160747103-6f0b7570-53a5-45f7-b76f-f2c7fceb7712.jpg"
                     
                ></p>
<p>通过子类的打印结果可以看出，中间类一旦生成，没有移除，没有销毁，还在内存中，主要是考虑 <code>重用</code> 的想法，即 <code>中间类注册到内存中，为了考虑后续的重用问题，所以中间类一直存在</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，关于 中间类，有如下说明：</p>
<ul>
<li><p><code>实例对象isa</code> 的指向 <code>在注册KVO观察者之后</code>，由 <code>原有类</code> 更改为 <code>中间类</code></p>
</li>
<li><p><code>中间类</code> 重写了观察 <code>属性setter方法、class、dealloc、_isKVOA</code> 方法</p>
</li>
<li><p><code>dealloc</code> 方法中，<code>移除KVO观察者之后</code>，<code>实例对象isa</code> 指向由 <code>中间类</code> 更改为 <code>原有类</code></p>
</li>
<li><p><code>中间类</code> 从创建后，就一直 <code>存在内存中</code>，<code>不会被销毁</code></p>
</li>
</ul>
<h1 id="自定义KVO"><a href="#自定义KVO" class="headerlink" title="自定义KVO"></a>自定义KVO</h1><p>自定义KVO的流程，只是在系统的基础上针对其部分做了一些优化处理。</p>
<ul>
<li>模拟系统</li>
<li>实现 <code>KVO自动销毁机制</code></li>
<li>将 <code>响应式和函数式</code> 整合</li>
</ul>
<p>在系统中，注册观察者和KVO响应属于 <code>响应式编程</code>，是分开写的，在自定义为了代码更好的协调，使用 <code>block</code> 的形式，将注册和回调的逻辑组合在一起，即采用 <code>函数式变成</code> 方式</p>
<p>那么如何实现自定义KVO呢？分为以下几个步骤：</p>
<ul>
<li>注册观察者</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 定义blcock</span><br><span class="line">typedef void(^ZJKVOBlock)(id observer,NSString * keyPath,id oldValue,id newValue);</span><br><span class="line"></span><br><span class="line">// 创建一个 NSObject+ZJKVO的分类，注册观察者</span><br><span class="line">@interface NSObject (ZJKVO)</span><br><span class="line">- (void)zj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath block:(ZJKVOBlock)block;</span><br><span class="line">- (void)zj_removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>

<ul>
<li>KVO监听</li>
</ul>
<p>这部分主要是通过 <code>重写setter方法</code>，在中间类的setter方法中，通过 <code>block</code> 方式传递给外部进行响应</p>
<ul>
<li>移除观察者</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)zj_removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure></div>

<h2 id="注册观察者"><a href="#注册观察者" class="headerlink" title="注册观察者"></a>注册观察者</h2><p>在注册观察者步骤中，主要有以下几步操作：</p>
<ul>
<li>1、验证是否存在 <code>setter</code> 方法，目的是 <code>不让实例进来</code></li>
<li>2、动态生成子类，将需要重写的 <code>class</code> 方法添加到中间类中</li>
<li>3、 <code>isa</code> 指向原有类，改为 <code>指向中间类</code></li>
<li>4、 保存信息：这里用的是数组，也可以使用map，需要创建信息的 <code>model模型类</code></li>
</ul>
<p><strong>【注意】：</strong></p>
<p>关于 <code>objc_msgSend</code> 的检查关闭：<code>target -&gt; Build Setting -&gt; Enable Strict Checking of objc_msgsend Calls</code> 设置为 <code>NO</code></p>
<h2 id="KVO响应"><a href="#KVO响应" class="headerlink" title="KVO响应"></a>KVO响应</h2><ol>
<li><p>主要是给 <code>子类</code> 动态添加 <code>setter</code> 方法，其目的是为了在 <code>setter方法</code> 中向父类发送消息，告知其属性值的变化</p>
</li>
<li><p>通过系统的 <code>objc_msgSendSuper</code> 强制类型转换自定义的消息发送 <code>zj_msgSendSuper</code></p>
</li>
<li><p>告知vc去响应：获取信息，通过block传递</p>
</li>
</ol>
<h2 id="移除观察者"><a href="#移除观察者" class="headerlink" title="移除观察者"></a>移除观察者</h2><p>为了避免在外界不断的调用 <code>removeObserver</code> 方法，在自定义 <code>KVO</code> 中实现 <code>自动移除观察者</code></p>
<ul>
<li><p>1、实现 <code>zj_removeObserver:forKeyPath:</code> 方法，主要是清空数组，以及 <code>isa</code> 指向更改</p>
</li>
<li><p>2、在子类中重写 <code>dealloc</code> 方法，当子类销毁时，会自动调用dealloc方法（在动态生成子类的方法中添加）</p>
</li>
</ul>
<p>其主要原理是：<code>ZJPerson</code> 发送消息释放即 <code>dealloc</code> 了，就会自动走到重写的 <code>zj_dealloc</code> 方法中（原因是person对象的 <code>isa</code> 指向变了），指向中间类，但是实例对象的地址是不变的，所以子类的释放，相当于释放了外界的person，而重写的 <code>zj_dealloc</code> 相当于是 <code>重写了ZJPerson</code> 的 <code>dealloc</code> 方法，所以会走到 <code>zj_dealloc</code> 方法中，达到自动移除观察者的目的。</p>
<h2 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h2><ul>
<li><strong>【NSObject+ZJKVO.h】</strong></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^ZJKVOBlock)(id observer,NSString *keyPath,id oldValue,id newValue);</span><br><span class="line"></span><br><span class="line">@interface NSObject (LGKVO)</span><br><span class="line">- (void)zj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath block:(LGKVOBlock)block;</span><br><span class="line">- (void)zj_removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>【NSObject+ZJKVO.m】</strong></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSObject+ZJKVO.h&quot;</span><br><span class="line">#import &lt;objc/message.h&gt;</span><br><span class="line"></span><br><span class="line">static NSString *const kZJKVOPrefix = @&quot;ZJKVONotifying_&quot;;</span><br><span class="line">static NSString *const kZJKVOAssiociateKey = @&quot;kZJKVO_AssiociateKey&quot;;</span><br><span class="line"></span><br><span class="line">#*****信息model*****</span><br><span class="line">@interface ZJInfo : NSObject</span><br><span class="line">@property (nonatomic,weak)NSObject * observer;</span><br><span class="line">@property (nonatomic,copy)NSString * keyPath;</span><br><span class="line">@property (nonatomic,copy)ZJKVOBlock handleBlock;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJInfo</span><br><span class="line">- (instancetype)initWitObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath handleBlock:(ZJKVOBlock)block&#123;</span><br><span class="line">    if (self=[super init]) &#123;</span><br><span class="line">        _observer = observer;</span><br><span class="line">        _keyPath  = keyPath;</span><br><span class="line">        _handleBlock = block;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSObject (ZJKVO)</span><br><span class="line">- (void)zj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath block:(ZJKVOBlock)block&#123;</span><br><span class="line">    // 1.验证是否存在setter方法：不让实例进来</span><br><span class="line">    [self judgeSetterMethodFromKeyPath:keyPath];</span><br><span class="line">    // 2.动态生成子类</span><br><span class="line">    Class newClass = [self createChildClassWithKeyPath:keyPath];</span><br><span class="line">    // 3.isa的指向 : ZJKVONotifying_ZJPerson</span><br><span class="line">    object_setClass(self, newClass);</span><br><span class="line">    // 4.保存信息</span><br><span class="line">    ZJInfo * info = [[ZJInfo alloc] initWitObserver:observer forKeyPath:keyPath handleBlock:block];</span><br><span class="line">    NSMutableArray * mArray = objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kZJKVOAssiociateKey));</span><br><span class="line">    if (!mArray) &#123;</span><br><span class="line">        mArray = [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">        objc_setAssociatedObject(self, (__bridge const void * _Nonnull)(kZJKVOAssiociateKey), mArray, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    [mArray addObject:info];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -移除观察者</span><br><span class="line">- (void)zj_removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath&#123;</span><br><span class="line">    NSMutableArray *observerArr = objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kZJKVOAssiociateKey));</span><br><span class="line">    if (observerArr.count&lt;=0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (ZJInfo *info in observerArr) &#123;</span><br><span class="line">        if ([info.keyPath isEqualToString:keyPath]) &#123;</span><br><span class="line">            [observerArr removeObject:info];</span><br><span class="line">            objc_setAssociatedObject(self, (__bridge const void * _Nonnull)(kZJKVOAssiociateKey), observerArr, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (observerArr.count&lt;=0) &#123;</span><br><span class="line">        // 指回给父类</span><br><span class="line">        Class superClass = [self class];</span><br><span class="line">        object_setClass(self, superClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 验证是否存在setter方法</span><br><span class="line">- (void)judgeSetterMethodFromKeyPath:(NSString *)keyPath&#123;</span><br><span class="line">    Class superClass    = object_getClass(self); // 获取类Person</span><br><span class="line">    SEL setterSeletor   = NSSelectorFromString(setterForGetter(keyPath));</span><br><span class="line">    Method setterMethod = class_getInstanceMethod(superClass, setterSeletor);</span><br><span class="line">    if (!setterMethod) &#123;</span><br><span class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException reason:[NSString stringWithFormat:@&quot;老铁没有当前%@的setter&quot;,keyPath] userInfo:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -动态生成子类</span><br><span class="line">- (Class)createChildClassWithKeyPath:(NSString *)keyPath&#123;</span><br><span class="line">    // 获取原本的类名（Person）</span><br><span class="line">    NSString * oldClassName = NSStringFromClass([self class]);</span><br><span class="line">    // 拼接子类类名（ZJKVONotifying_Person）</span><br><span class="line">    NSString * newClassName = [NSString stringWithFormat:@&quot;%@%@&quot;,kZJKVOPrefix,oldClassName];</span><br><span class="line">    // 获取子类</span><br><span class="line">    Class newClass = NSClassFromString(newClassName);</span><br><span class="line">    // 防止重复创建生成新类</span><br><span class="line">    if (newClass) return newClass;</span><br><span class="line">    /**</span><br><span class="line">     * 如果内存不存在,创建生成</span><br><span class="line">     * 参数一: 父类</span><br><span class="line">     * 参数二: 新类的名字</span><br><span class="line">     * 参数三: 新类的开辟的额外空间</span><br><span class="line">     */</span><br><span class="line">    // 2.1 : 申请类（ZJKVONotifying_Person）</span><br><span class="line">    newClass = objc_allocateClassPair([self class], newClassName.UTF8String, 0);</span><br><span class="line">    </span><br><span class="line">    // 2.2 : 注册类</span><br><span class="line">    objc_registerClassPair(newClass);</span><br><span class="line">    </span><br><span class="line">    // 2.3.1 : 添加class : class的指向是ZJPerson</span><br><span class="line">    SEL classSEL = NSSelectorFromString(@&quot;class&quot;);</span><br><span class="line">    Method classMethod = class_getInstanceMethod([self class], classSEL);</span><br><span class="line">    const char *classTypes = method_getTypeEncoding(classMethod);</span><br><span class="line">    class_addMethod(newClass, classSEL, (IMP)zj_class, classTypes);</span><br><span class="line">    </span><br><span class="line">    // 2.3.2 : 添加setter</span><br><span class="line">    SEL setterSEL = NSSelectorFromString(setterForGetter(keyPath)); // 获取sel</span><br><span class="line">    Method setterMethod = class_getInstanceMethod([self class], setterSEL); // 获取setter实例方法</span><br><span class="line">    const char *setterTypes = method_getTypeEncoding(setterMethod); // 方法签名</span><br><span class="line">    class_addMethod(newClass, setterSEL, (IMP)zj_setter, setterTypes); // 添加一个setter方法</span><br><span class="line">    </span><br><span class="line">    // 2.3.3 : 添加dealloc</span><br><span class="line">    SEL deallocSEL = NSSelectorFromString(@&quot;dealloc&quot;);</span><br><span class="line">    Method deallocMethod = class_getInstanceMethod([self class], deallocSEL);</span><br><span class="line">    const char *deallocTypes = method_getTypeEncoding(deallocMethod);</span><br><span class="line">    class_addMethod(newClass, deallocSEL, (IMP)zj_dealloc, deallocTypes);</span><br><span class="line">    </span><br><span class="line">    return newClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -重写class方法，为了与系统类对外保持一致</span><br><span class="line">Class zj_class(id self,SEL _cmd)&#123;</span><br><span class="line">    return class_getSuperclass(object_getClass(self));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -添加setter方法</span><br><span class="line">static void zj_setter(id self,SEL _cmd,id newValue)&#123;</span><br><span class="line">    NSString *keyPath = getterForSetter(NSStringFromSelector(_cmd));</span><br><span class="line">    id oldValue = [self valueForKey:keyPath];</span><br><span class="line">    // 4: 消息转发 : 转发给父类</span><br><span class="line">    // 通过系统强制类型转换自定义objc_msgSendSuper</span><br><span class="line">    void (*zj_msgSendSuper)(void *,SEL , id) = (void *)objc_msgSendSuper;</span><br><span class="line">    // 定义一个结构体</span><br><span class="line">    struct objc_super superStruct = &#123;</span><br><span class="line">        .receiver = self, // 消息接收者为当前的self</span><br><span class="line">        .super_class = class_getSuperclass(object_getClass(self)), // 当第一次快捷查找的类为父类</span><br><span class="line">    &#125;;</span><br><span class="line">    // 调用自定义的放消息函数</span><br><span class="line">    zj_msgSendSuper(&amp;superStruct,_cmd,newValue);</span><br><span class="line">    </span><br><span class="line">    // 5: 信息数据回调</span><br><span class="line">    NSMutableArray *mArray = objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kZJKVOAssiociateKey));</span><br><span class="line">    for (ZJInfo *info in mArray) &#123;</span><br><span class="line">        if ([info.keyPath isEqualToString:keyPath] &amp;&amp; info.handleBlock) &#123;</span><br><span class="line">            info.handleBlock(info.observer, keyPath, oldValue, newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 从get方法获取set方法的名称 key -&gt; setKey:</span><br><span class="line">static NSString *setterForGetter(NSString *getter)&#123;</span><br><span class="line">    if (getter.length &lt;= 0) &#123; return nil;&#125;</span><br><span class="line">    NSString *firstString = [[getter substringToIndex:1] uppercaseString];</span><br><span class="line">    NSString *leaveString = [getter substringFromIndex:1];</span><br><span class="line">    </span><br><span class="line">    return [NSString stringWithFormat:@&quot;set%@%@:&quot;,firstString,leaveString];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 从set方法获取getter方法的名称 set&lt;Key&gt;:===&gt; key</span><br><span class="line">static NSString *getterForSetter(NSString *setter)&#123;</span><br><span class="line">    if (setter.length &lt;= 0 || ![setter hasPrefix:@&quot;set&quot;] || ![setter hasSuffix:@&quot;:&quot;]) &#123; return nil;&#125;</span><br><span class="line">    NSRange range = NSMakeRange(3, setter.length-4);</span><br><span class="line">    NSString *getter = [setter substringWithRange:range];</span><br><span class="line">    NSString *firstString = [[getter substringToIndex:1] lowercaseString];</span><br><span class="line">    </span><br><span class="line">    return  [getter stringByReplacingCharactersInRange:NSMakeRange(0, 1) withString:firstString];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -重写dealloc</span><br><span class="line">static void zj_dealloc(id self,SEL _cmd)&#123;</span><br><span class="line">    NSLog(@&quot;[%@ dealloc]&quot;,self);</span><br><span class="line">    Class superClass = [self class];</span><br><span class="line">    object_setClass(self, superClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>

<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>综上所述，自定义KVO大致分为一下几步：</p>
<ul>
<li><p>注册观察者 &amp; 响应</p>
<ul>
<li>验证是否存在 <code>setter</code> 方法</li>
<li>动态生成子类，需要重写 <code>class、setter</code> 方法</li>
<li>在子类的setter方法中向父类发消息，即 <code>自定义消息发送</code></li>
<li>isa原有类指向中间类</li>
<li>保存信息</li>
<li>让观察者 <code>响应</code></li>
</ul>
</li>
<li><p>移除观察者</p>
<ul>
<li>更改 <code>isa指向</code> 为原有类</li>
<li>重写子类的 <code>dealloc</code> 方法</li>
</ul>
</li>
</ul>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：OC底层原理23：KVO底层原理分析</li>
        <li>Post author：张建</li>
        <li>Create time：2021-01-25 16:34:11</li>
        <li>
            Post link：https://redefine.ohevan.com/2021/01/25/OC底层原理/OC底层原理23：KVO底层原理分析/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/BboyZJ.github.io/tags/iOS-OC/">#iOS-OC</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/BboyZJ.github.io/2021/02/14/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8624%EF%BC%9A%E5%86%85%E5%AD%98%E4%BA%94%E5%A4%A7%E5%8C%BA/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">OC底层原理24：内存五大区</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/BboyZJ.github.io/2021/01/17/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8622%EF%BC%9AKVC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">OC底层原理22：KVC底层原理分析</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">OC底层原理23：KVO底层原理分析</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#KVO-%E4%BD%BF%E7%94%A8"><span class="nav-text">KVO 使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-text">基本使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#context-%E4%BD%BF%E7%94%A8"><span class="nav-text">context 使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4KVO%E9%80%9A%E7%9F%A5%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="nav-text">移除KVO通知的必要性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KVO%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91%E4%B8%8E%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="nav-text">KVO的自动触发与手动触发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KVO%E8%A7%82%E5%AF%9F%EF%BC%9A%E4%B8%80%E5%AF%B9%E5%A4%9A"><span class="nav-text">KVO观察：一对多</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KVO%E8%A7%82%E5%AF%9F%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84"><span class="nav-text">KVO观察可变数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#KVO%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2"><span class="nav-text">KVO的底层原理探索</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%B0%83%E5%BC%8F%E6%8E%A2%E7%B4%A2"><span class="nav-text">代码调式探索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#KVO%E5%8F%AA%E5%AF%B9%E5%B1%9E%E6%80%A7%E8%A7%82%E5%AF%9F"><span class="nav-text">KVO只对属性观察</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E7%B1%BB"><span class="nav-text">中间类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%AD%E9%97%B4%E7%B1%BB%E6%98%AF%E5%90%A6%E6%98%AF-%E6%B4%BE%E7%94%9F%E7%B1%BB-%E5%8D%B3-%E5%AD%90%E7%B1%BB%EF%BC%9F"><span class="nav-text">判断中间类是否是 派生类 即 子类？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E7%B1%BB%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">中间类中有什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dealloc%E4%B8%AD%E7%A7%BB%E9%99%A4%E8%A7%82%E5%AF%9F%E8%80%85%E5%90%8E%EF%BC%8Cisa%E6%8C%87%E5%90%91%E8%B0%81%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%AD%E9%97%B4%E7%B1%BB%E6%98%AF%E5%90%A6%E4%BC%9A%E9%94%80%E6%AF%81%EF%BC%9F"><span class="nav-text">dealloc中移除观察者后，isa指向谁，以及中间类是否会销毁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%A3%E4%B9%88%E4%B8%AD%E9%97%B4%E7%B1%BB%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%90%8E%EF%BC%8C%E5%88%B0dealloc%E6%96%B9%E6%B3%95%E4%B8%AD%E7%A7%BB%E9%99%A4%E8%A7%82%E5%AF%9F%E8%80%85%E4%B9%8B%E5%90%8E%EF%BC%8CKSKVONotifying-ZJPerson-%E6%98%AF%E5%90%A6%E8%BF%98%E5%AD%98%E5%9C%A8%EF%BC%9F"><span class="nav-text">那么中间类从创建后，到dealloc方法中移除观察者之后，KSKVONotifying_ZJPerson 是否还存在？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89KVO"><span class="nav-text">自定义KVO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E8%A7%82%E5%AF%9F%E8%80%85"><span class="nav-text">注册观察者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KVO%E5%93%8D%E5%BA%94"><span class="nav-text">KVO响应</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E8%A7%82%E5%AF%9F%E8%80%85"><span class="nav-text">移除观察者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-text">完整的代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-text">总结</span></a></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2019</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">张建</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        VISITOR COUNT&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        TOTAL PAGE VIEWS&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a></span>
                <br> 
            <span class="theme-version-container">THEME&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v1.1.5</a>
        </div>
        
        
        
            <div id="start_time_div" style="display:none">
                2019/8/17 11:45:14
            </div>
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="unfolded-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="fa-regular fa-arrow-up"></i>
            </li>
        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="folded-tools-list">
        <li class="right-bottom-tools tool-toggle-show flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>




<script src="/BboyZJ.github.io/js/utils.js"></script>

<script src="/BboyZJ.github.io/js/main.js"></script>

<script src="/BboyZJ.github.io/js/layouts/menu-shrink.js"></script>

<script src="/BboyZJ.github.io/js/tools/go-top-bottom.js"></script>

<script src="/BboyZJ.github.io/js/tools/dark-light-toggle.js"></script>



    
<script src="/BboyZJ.github.io/js/tools/local-search.js"></script>




    
<script src="/BboyZJ.github.io/js/tools/code-block.js"></script>




    
<script src="/BboyZJ.github.io/js/layouts/lazyload.js"></script>




    
<script src="/BboyZJ.github.io/js/tools/runtime.js"></script>

    
<script src="/BboyZJ.github.io/js/layouts/odometer.min.js"></script>

    
<link rel="stylesheet" href="/BboyZJ.github.io/assets/odometer-theme-minimal.css">





<div class="post-scripts pjax">
    
        
<script src="/BboyZJ.github.io/js/tools/toc-toggle.js"></script>

<script src="/BboyZJ.github.io/js/libs/anime.min.js"></script>

<script src="/BboyZJ.github.io/js/layouts/toc.js"></script>

<script src="/BboyZJ.github.io/js/plugins/tabs.js"></script>

    
    
</div>


    
<script src="/BboyZJ.github.io/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>




<script src="/BboyZJ.github.io/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
