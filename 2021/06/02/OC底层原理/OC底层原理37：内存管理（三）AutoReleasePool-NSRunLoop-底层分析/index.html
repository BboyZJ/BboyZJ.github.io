<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="我是小J，关注我">
    <meta name="author" content="张建">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://www.bboyzj.cn/2021/06/02/oc底层原理/oc底层原理37：内存管理（三）autoreleasepool-nsrunloop-底层分析/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    <meta property="og:type" content="article">
    <meta property="og:title" content="OC底层原理37：内存管理（三）AutoReleasePool &amp; NSRunLoop 底层分析">
    <meta property="og:description" content="我是小J，关注我">
    <meta property="og:url" content="https://www.bboyzj.cn2021/06/02/OC底层原理/OC底层原理37：内存管理（三）AutoReleasePool-NSRunLoop-底层分析/">
    <meta property="og:image" content="/images/redefine-logo.svg">
    <meta property="og:site_name" content="BboyZJ">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="OC底层原理37：内存管理（三）AutoReleasePool &amp; NSRunLoop 底层分析">
    <meta name="twitter:description" content="我是小J，关注我">
    <meta name="twitter:image" content="/images/redefine-logo.svg">
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/BboyZJ.github.io/images/redefine-logo.svg">
    
    <title>
        
            OC底层原理37：内存管理（三）AutoReleasePool &amp; NSRunLoop 底层分析 -
        
        BboyZJ
    </title>
    
<link rel="stylesheet" href="/BboyZJ.github.io/css/style.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/assets/fonts.css">

    
    
    
    
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"www.bboyzj.cn","root":"/BboyZJ.github.io/","language":"en","path":"search.xml"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/head_img.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"学无止境 学而不思则罔 思而不学则殆","custom_font":{"enable":false,"font_family":null,"font_url":null}},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_block":{"copy":true,"style":"mac","custom_font":{"enable":false,"font_family":null,"font_url":null}},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"1.1.5","friend_links":{"columns":2},"home_article":{"date_format":"auto","category":{"enable":true,"limit":3},"tag":{"enable":true,"limit":3}},"plugins":{"aplayer":{"enable":false,"audio":[{"name":null,"artist":null,"url":null,"cover":null},{"name":null,"artist":null,"url":null,"cover":null}]}}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/BboyZJ.github.io/atom.xml" title="张建的博客" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="menu-wrapper">
    
    <div class="menu-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                BboyZJ
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        首页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/tags/"  >
                                    
                                        
                                            <i class="fa-regular fa-tags"></i>
                                        
                                        标签
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/categories/"  >
                                    
                                        
                                            <i class="fa-regular fa-categories"></i>
                                        
                                        分类
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="menu-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                首页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/tags/"  >
                             
                                
                                    <i class="fa-regular fa-tags"></i>
                                
                                标签
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/categories/"  >
                             
                                
                                    <i class="fa-regular fa-categories"></i>
                                
                                分类
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">OC底层原理37：内存管理（三）AutoReleasePool &amp; NSRunLoop 底层分析</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/BboyZJ.github.io/images/head_img.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">张建</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2021-06-02 14:48:31</span>
        <span class="mobile">2021-06-02 14:48</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="pc">2023-04-22 11:08:52</span>
            <span class="mobile">2023-04-22 11:08</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/BboyZJ.github.io/categories/OC/">OC</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/BboyZJ.github.io/tags/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/">OC-底层原理探索篇</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要分析 <code>AutoReleasePool</code> 以及 <code>NSRunLoop </code> 的底层实现</p>
<h1 id="AutoReleasePool-自动释放池"><a href="#AutoReleasePool-自动释放池" class="headerlink" title="AutoReleasePool 自动释放池"></a>AutoReleasePool 自动释放池</h1><p><code>自动释放池</code> 是OC中的一种 <code>内存自动回收机制</code>，它可以将加入 <code>AutoReleasePool</code> 中的 <code>变量release的时机延迟</code>，简单来说，就是当创建一个 <code>对象</code>，在正常情况下，变量会在超出其作用域的时，立即release。如果对象加入到了自动释放池中，这个对象并 <code>不会立即释放</code>，会 <code>等到runloop休眠/超出autoreleasepool&#123;&#125;作用域</code> 之后才能 <code>被释放</code>。其机制如下图所示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16499858677848.png"
                     
                ></p>
<ul>
<li><p>从程序启动到加载完成，主线程对应的 <code>runloop</code> 会处于 <code>休眠</code> 状态，等待用户交互来唤醒runloop</p>
</li>
<li><p>用户的每一次 <code>交互</code> 都会启动一次 <code>runloop</code>，用于处理用户的 <code>所有点击、触摸事件等</code></p>
</li>
<li><p><code>runloop</code> 在 <code>监听到交互事件</code> 后，就会 <code>创建</code> 自动释放池，并将所有 <code>延迟释放</code> 的对象添加到自动释放池</p>
</li>
<li><p>在一次完整的runloop结束之前，会向自动释放池中所有对象 <code>发送release消息</code>，然后 <code>销毁</code> 自动释放池</p>
</li>
</ul>
<h2 id="clang分析"><a href="#clang分析" class="headerlink" title="clang分析"></a>clang分析</h2><p>根据之前源码分析经验，我们先通过 <code>clang</code> 来分析</p>
<ul>
<li>定义如下代码</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>通过clang编译成底层实现，命令为：<code>xcrun -sdk iphonesimulator clang -arch x86_64 - rewrite-objc main.m</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//*********__AtAutoreleasePool**********</span><br><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">    //构造函数</span><br><span class="line">    __AtAutoreleasePool() &#123;</span><br><span class="line">            atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">    &#125;</span><br><span class="line">    //析构函数</span><br><span class="line">    ~__AtAutoreleasePool() &#123;</span><br><span class="line">            objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">     &#125;</span><br><span class="line">      void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//*********main*********</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">   &#123; </span><br><span class="line">        // 是一个结构体</span><br><span class="line">        __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>简单来说，自动释放池其本质也是一个 <code>对象</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;&#125;</span><br><span class="line">//等价于</span><br><span class="line">&#123;__AtAutoreleasePool __autoreleasepool; &#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>__AtAutoreleasePool</code> 是一个 <code>结构体</code>，由 <code>构造函数 + 析构函数</code>，结构体定义的对象在作用域结束后，会自动调用析构函数</p>
</li>
<li><p>其中 <code>&#123;&#125;</code> 是作用域，优点是 <code>结构清晰，可读性强</code>，可以 <code>及时创建销毁</code></p>
</li>
</ul>
<p>关于涉及的构造和析构函数的调用时机，可以通过下面一个案例来验证</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct ZJTest&#123;</span><br><span class="line">    ZJTest</span><br><span class="line">()&#123;</span><br><span class="line">        printf(&quot;123 - %s\n&quot;, __func__);</span><br><span class="line">    &#125;</span><br><span class="line">    ~ZJTest()&#123;</span><br><span class="line">        printf(&quot;456 - %s\n&quot;, __func__);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        ZJTest test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//**********运行结果**********</span><br><span class="line">123 - ZJTest</span><br><span class="line">456 - ~ZJTest</span><br></pre></td></tr></table></figure></div>

<p>从而可以得出，在 <code>ZJTest</code> 创建对象时，会自动调用 <code>构造函数</code>，在出了{}作用域后，会自动调用析构函数</p>
<h2 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h2><ul>
<li>在main代码部分加断点，运行程序，并开启汇编调试</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16499903608932.jpg"
                     
                ></p>
<p>通过调试结果发现，证明了我们clang分析的结果</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p><code>autoreleasepool</code> 其本质是一个 <code>结构体对象</code>，一个自动释放池对象就是页，是 <code>栈结构存储</code>，符合 <code>先进后出</code> 的原则</p>
</li>
<li><p>页的栈底是一个 <code>56</code> 字节大小的 <code>空占位符</code>，一页总大小为 <code>4096</code> 字节</p>
</li>
<li><p>只有 <code>第一页</code> 有 <code>哨兵</code> 对象，最多存储 <code>504</code> 个对象，从第二页开始最多存储 <code>505</code> 个对象</p>
</li>
<li><p><code>autoreleasepool</code> 在加入要释放的对象时，底层调用的是 <code>objc_autoreleasePoolPush</code> 方法</p>
</li>
<li><p><code>autoreleasepool</code> 在调用析构函数释放时，内部的实现时调用 <code>objc_autoreleasePoolPop</code> 方法</p>
</li>
</ul>
<h1 id="底层分析"><a href="#底层分析" class="headerlink" title="底层分析"></a>底层分析</h1><p>在 <code>objc</code> 源码中，对 <code>AutoreleasePool</code> 的解释如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Autorelease pool implementation</span><br><span class="line"></span><br><span class="line">- A thread&#x27;s autorelease pool is a stack of pointers. </span><br><span class="line">线程的自动释放池是指针的堆栈</span><br><span class="line"></span><br><span class="line">- Each pointer is either an object to release, or POOL_BOUNDARY which is an autorelease pool boundary.</span><br><span class="line">每个指针都是要释放的对象，或者是POOL_BOUNDARY，它是自动释放池的边界。</span><br><span class="line"></span><br><span class="line">- A pool token is a pointer to the POOL_BOUNDARY for that pool. When the pool is popped, every object hotter than the sentinel is released.</span><br><span class="line">池令牌是指向该池的POOL_BOUNDARY的指针。弹出池后，将释放比哨点更热的每个对象。</span><br><span class="line"></span><br><span class="line">- The stack is divided into a doubly-linked list of pages. Pages are added and deleted as necessary. </span><br><span class="line">堆栈分为两个双向链接的页面列表。根据需要添加和删除页面。</span><br><span class="line"></span><br><span class="line">- Thread-local storage points to the hot page, where newly autoreleased objects are stored. </span><br><span class="line">线程本地存储指向热页面，该页面存储新自动释放的对象。</span><br></pre></td></tr></table></figure></div>

<p><strong>通过描述。有以下几点说明：</strong></p>
<ul>
<li><p><code>自动释放池</code> 是一个关于 <code>指针</code> 的 <code>堆栈</code></p>
</li>
<li><p>其中的指针是指要 <code>释放的对象</code> 或者 <code>pool_boundary</code> 哨兵（现在经常被称为 <code>边界</code>）</p>
</li>
<li><p>自动释放池是一个 <code>页</code>  的结构（细腻内存中提及），而且这个 <code>页</code> 是一个 <code>双向链接</code>（表示父节点和子节点，在类中提及过，即类的继承链）</p>
</li>
<li><p><code>自动释放池</code> 和 <code>线程</code> 有关系</p>
</li>
</ul>
<p><strong>对于 <code>自动释放池</code>，我们主要关心的点有以下三点：</strong></p>
<ul>
<li><p>自动释放池是什么时候 <code>创建</code>？</p>
</li>
<li><p>对象时 <code>如何加入到自动释放池</code> 的？</p>
</li>
<li><p><code>哪些对象才会加入</code> 自动释放池？</p>
</li>
</ul>
<p>下面带着这些问题，我们来进一步探索自动释放池的底层原理</p>
<h1 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h1><ul>
<li>从最初的 <code>clang</code> 或者 <code>汇编</code> 分析我们了解了自动释放池其底层是调用的 <code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code> 两个方法，其源码实现如下：</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//***********push方法***********</span><br><span class="line">void *</span><br><span class="line">objc_autoreleasePoolPush(void)</span><br><span class="line">&#123;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//***********pop方法***********</span><br><span class="line">void</span><br><span class="line">objc_autoreleasePoolPop(void *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>从源码中我们发现，都是调用的 <code>AutoreleasePoolPage</code> 的 <code>push</code> 和 <code>pop</code>，以下是其定义，从定义中可以看出，自动释放池是一个 <code>页</code>，同时也是一个 <code>对象</code>，这个 <code>页</code> 的大小是 <code>4096字节</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">//************宏定义************</span><br><span class="line">#define PAGE_MIN_SIZE           PAGE_SIZE</span><br><span class="line">#define PAGE_SIZE               I386_PGBYTES</span><br><span class="line">#define I386_PGBYTES            4096            /* bytes per 80386 page */</span><br><span class="line"></span><br><span class="line">//************类定义************</span><br><span class="line">class AutoreleasePoolPage : private AutoreleasePoolPageData</span><br><span class="line">&#123;</span><br><span class="line">    friend struct thread_data_t;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    //页的大小</span><br><span class="line">    static size_t const SIZE =</span><br><span class="line">#if PROTECT_AUTORELEASEPOOL</span><br><span class="line">        PAGE_MAX_SIZE;  // must be multiple of vm page size</span><br><span class="line">#else</span><br><span class="line">        PAGE_MIN_SIZE;  // size and alignment, power of 2</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    //构造函数</span><br><span class="line">    AutoreleasePoolPage(AutoreleasePoolPage *newParent) :</span><br><span class="line">        AutoreleasePoolPageData(begin(),//开始存储的位置</span><br><span class="line">                                objc_thread_self(),//传的是当前线程，当前线程时通过tls获取的</span><br><span class="line">                                newParent,</span><br><span class="line">                                newParent ? 1+newParent-&gt;depth : 0,//如果是第一页深度为0，往后是前一个的深度+1</span><br><span class="line">                                newParent ? newParent-&gt;hiwat : 0)</span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //析构函数</span><br><span class="line">    ~AutoreleasePoolPage() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    //页的开始位置</span><br><span class="line">    id * begin() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //页的结束位置</span><br><span class="line">    id * end() &#123;...&#125;</span><br><span class="line">   </span><br><span class="line">    //页是否为空</span><br><span class="line">    bool empty() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //页是否满了</span><br><span class="line">    bool full() &#123;...&#125;</span><br><span class="line">   </span><br><span class="line">    //页的存储是否少于一半</span><br><span class="line">    bool lessThanHalfFull() &#123;...&#125;</span><br><span class="line">     </span><br><span class="line">     //添加释放对象</span><br><span class="line">    id *add(id obj)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //释放所有对象</span><br><span class="line">    void releaseAll() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //释放到stop位置之前的所有对象</span><br><span class="line">    void releaseUntil(id *stop) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //杀掉</span><br><span class="line">    void kill() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //释放本地线程存储空间</span><br><span class="line">    static void tls_dealloc(void *p) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //获取AutoreleasePoolPage</span><br><span class="line">    static AutoreleasePoolPage *pageForPointer(const void *p) &#123;...&#125;</span><br><span class="line">    static AutoreleasePoolPage *pageForPointer(uintptr_t p)  &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //是否有空池占位符</span><br><span class="line">    static inline bool haveEmptyPoolPlaceholder() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //设置空池占位符</span><br><span class="line">    static inline id* setEmptyPoolPlaceholder()&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //获取当前操作页</span><br><span class="line">    static inline AutoreleasePoolPage *hotPage()&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //设置当前操作页</span><br><span class="line">    static inline void setHotPage(AutoreleasePoolPage *page) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //获取coldPage</span><br><span class="line">    static inline AutoreleasePoolPage *coldPage() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //快速释放</span><br><span class="line">    static inline id *autoreleaseFast(id obj)&#123;...&#125;</span><br><span class="line">   </span><br><span class="line">   //添加自动释放对象，当页满的时候调用这个方法</span><br><span class="line">    static __attribute__((noinline))</span><br><span class="line">    id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //添加自动释放对象，当没页的时候使用这个方法</span><br><span class="line">    static __attribute__((noinline))</span><br><span class="line">    id *autoreleaseNoPage(id obj)&#123;...&#125;</span><br><span class="line">   </span><br><span class="line">   //创建新页</span><br><span class="line">    static __attribute__((noinline))</span><br><span class="line">    id *autoreleaseNewPage(id obj) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    //自动释放</span><br><span class="line">    static inline id autorelease(id obj)&#123;...&#125;</span><br><span class="line">   </span><br><span class="line">    //入栈</span><br><span class="line">    static inline void *push() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //兼容老的 SDK 出栈方法</span><br><span class="line">    __attribute__((noinline, cold))</span><br><span class="line">    static void badPop(void *token)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //出栈页面</span><br><span class="line">    template&lt;bool allowDebug&gt;</span><br><span class="line">    static void</span><br><span class="line">    popPage(void *token, AutoreleasePoolPage *page, id *stop)&#123;...&#125;</span><br><span class="line">    __attribute__((noinline, cold))</span><br><span class="line">    static void</span><br><span class="line">    popPageDebug(void *token, AutoreleasePoolPage *page, id *stop)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //出栈</span><br><span class="line">    static inline void</span><br><span class="line">    pop(void *token)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    static void init()&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //打印</span><br><span class="line">    __attribute__((noinline, cold))</span><br><span class="line">    void print()&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //打印所有</span><br><span class="line">    __attribute__((noinline, cold))</span><br><span class="line">    static void printAll()&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //打印Hiwat</span><br><span class="line">    __attribute__((noinline, cold))</span><br><span class="line">    static void printHiwat()&#123;...&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>从其定义中发现，<code>AutoreleasePoolPage</code> 是集成自 <code>AutoreleasePoolPageData</code>，且该类的属性也是来自父类，以下是 <code>AutoreleasePoolPage</code> 的定义：</p>
<ul>
<li>发现其中有 <code>AutoreleasePoolPage</code> 对象，所以有以下关系链 <code>AutoreleasePoolPage -&gt; AutoreleasePoolPageData -&gt; AutoreleasePoolPage</code>，从这里可以说明自动释放池除了是一个 <code>页</code> ，还是一个 <code>双向链表</code> 结构</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage;</span><br><span class="line">struct AutoreleasePoolPageData</span><br><span class="line">&#123;</span><br><span class="line">    // 用来校验AutoreleasePoolPage的结构是否完整</span><br><span class="line">    magic_t const magic;//16个字节</span><br><span class="line">    // 指向最新添加的autoreleased对象的下一个位置，初始化时指向begin()</span><br><span class="line">    __unsafe_unretained id *next;//8字节</span><br><span class="line">    // 指向当前线程</span><br><span class="line">    pthread_t const thread;//8字节</span><br><span class="line">    // 指向父节点，第一个结点的parent值为nil</span><br><span class="line">    AutoreleasePoolPage * const parent;//8字节</span><br><span class="line">    // 指向子节点，最后一个结点的child值为nil</span><br><span class="line">    AutoreleasePoolPage *child;//8字节</span><br><span class="line">    // 表示深度，从0开始，往后递增1</span><br><span class="line">    uint32_t const depth;//4字节</span><br><span class="line">    // 表示high water mark 最大入栈数量标记</span><br><span class="line">    uint32_t hiwat;//4字节</span><br><span class="line"></span><br><span class="line">    // 初始化</span><br><span class="line">    AutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat)</span><br><span class="line">        : magic(), next(_next), thread(_thread),</span><br><span class="line">          parent(_parent), child(nil),</span><br><span class="line">          depth(_depth), hiwat(_hiwat)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>AutoreleasePoolPageData</code> 结构体的内存大小为 <code>56</code> 字节：</p>
<ul>
<li><p>属性 <code>magic</code> 的类型是 <code>magic_t</code> 结构体，所占内存大小为 <code>m[4]</code>，所占内存（即<code>4*4=16</code>字节）</p>
</li>
<li><p>属性 <code>next</code>（指针）、<code>thread</code>（对象）、<code>parent</code>（对象）、<code>child</code>（对象）均占 <code>8</code> 字节（即<code>4*8=32</code>字节）</p>
</li>
<li><p>属性 <code>depth、hiwat</code> 类型为 <code>unit32_t</code>，实际类型是 <code>unsigned int</code> 类型，均占 <code>4</code> 字节（即<code>2*4=8</code>字节）</p>
</li>
</ul>
<h1 id="objc-autoreleasePoolPush-源码分析"><a href="#objc-autoreleasePoolPush-源码分析" class="headerlink" title="objc_autoreleasePoolPush 源码分析"></a>objc_autoreleasePoolPush 源码分析</h1><p>进入 <code>push</code> 源码实现，有以下逻辑</p>
<ul>
<li><p>判断是否为有 <code>pool</code></p>
<ul>
<li><p>如果没有，则通过 <code>autoreleaseNewPage</code> 方法创建</p>
</li>
<li><p>如果有，则通过 <code>autoreleaseFast</code> 压栈 <code>哨兵对象</code></p>
</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 入栈</span><br><span class="line">static inline void *push() </span><br><span class="line">&#123;</span><br><span class="line">    id *dest;</span><br><span class="line">    // 判断是否有pool</span><br><span class="line">    if (slowpath(DebugPoolAllocation)) &#123;</span><br><span class="line">        // Each autorelease pool starts on a new pool page.自动释放池从新池页面开始</span><br><span class="line">        // 如果没有，则创建</span><br><span class="line">        dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 压栈一个POOL_BOUNDARY，即压栈哨兵</span><br><span class="line">        dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="创建页-autoreleaseNewPage"><a href="#创建页-autoreleaseNewPage" class="headerlink" title="创建页 autoreleaseNewPage"></a>创建页 autoreleaseNewPage</h2><ul>
<li><p>进入 <code>objc_autoreleasePoolPush -&gt; push -&gt; autoreleaseNewPage</code> 源码实现，主要是通过 <code>hotPage</code> 获取当前页，判断当前页是否存在</p>
<ul>
<li><p>如果存在，则通过 <code>autoreleaseFullPage</code> 方法 <code>压栈对象</code></p>
</li>
<li><p>如果不存在，则通过 <code>autoreleaseNoPage</code> 方法 <code>创建页</code></p>
</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">//创建新页</span><br><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseNewPage(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    //获取当前操作页</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    //如果存在，则压栈对象</span><br><span class="line">    if (page) return autoreleaseFullPage(obj, page);</span><br><span class="line">    //如果不存在，则创建页</span><br><span class="line">    else return autoreleaseNoPage(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//******** hotPage方法 ********</span><br><span class="line">//获取当前操作页</span><br><span class="line">static inline AutoreleasePoolPage *hotPage() </span><br><span class="line">&#123;</span><br><span class="line">    //获取当前页</span><br><span class="line">    AutoreleasePoolPage *result = (AutoreleasePoolPage *)</span><br><span class="line">        tls_get_direct(key);</span><br><span class="line">    //如果是一个空池，则返回nil，否则，返回当前线程的自动释放池</span><br><span class="line">    if ((id *)result == EMPTY_POOL_PLACEHOLDER) return nil;</span><br><span class="line">    if (result) result-&gt;fastcheck();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//******** autoreleaseNoPage方法 ********</span><br><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseNoPage(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    // &quot;No page&quot; could mean no pool has been pushed</span><br><span class="line">    // or an empty placeholder pool has been pushed and has no contents yet</span><br><span class="line">    ASSERT(!hotPage());</span><br><span class="line"></span><br><span class="line">    bool pushExtraBoundary = false;</span><br><span class="line">    //判断是否是空占位符，如果是，则压栈哨兵标识符置为YES</span><br><span class="line">    if (haveEmptyPoolPlaceholder()) &#123;</span><br><span class="line">        // We are pushing a second pool over the empty placeholder pool</span><br><span class="line">        // or pushing the first object into the empty placeholder pool.</span><br><span class="line">        // Before doing that, push a pool boundary on behalf of the pool </span><br><span class="line">        // that is currently represented by the empty placeholder.</span><br><span class="line">        pushExtraBoundary = true;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果对象不是哨兵对象，且没有Pool，则报错</span><br><span class="line">    else if (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        // We are pushing an object with no pool in place, </span><br><span class="line">        // and no-pool debugging was requested by environment.</span><br><span class="line">        _objc_inform(&quot;MISSING POOLS: (%p) Object %p of class %s &quot;</span><br><span class="line">                     &quot;autoreleased with no pool in place - &quot;</span><br><span class="line">                     &quot;just leaking - break on &quot;</span><br><span class="line">                     &quot;objc_autoreleaseNoPool() to debug&quot;, </span><br><span class="line">                     objc_thread_self(), (void*)obj, object_getClassName(obj));</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果对象是哨兵对象，且没有申请自动释放池内存，则设置一个空占位符存储在tls中，其目的是为了节省内存</span><br><span class="line">    else if (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) &#123;//如果传入参数为哨兵</span><br><span class="line">        // We are pushing a pool with no pool in place,</span><br><span class="line">        // and alloc-per-pool debugging was not requested.</span><br><span class="line">        // Install and return the empty pool placeholder.</span><br><span class="line">        return setEmptyPoolPlaceholder();//设置空的占位符</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We are pushing an object or a non-placeholder&#x27;d pool.</span><br><span class="line"></span><br><span class="line">    // Install the first page.</span><br><span class="line">    //初始化第一页</span><br><span class="line">    AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);</span><br><span class="line">    //设置page为当前聚焦页</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    </span><br><span class="line">    // Push a boundary on behalf of the previously-placeholder&#x27;d pool.</span><br><span class="line">    //压栈哨兵的标识符为YES，则压栈哨兵对象</span><br><span class="line">    if (pushExtraBoundary) &#123;</span><br><span class="line">        //压栈哨兵</span><br><span class="line">        page-&gt;add(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Push the requested object or pool.</span><br><span class="line">    //压栈对象</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>autoreleaseNoPage</code> 方法中发现 <code>当前线程的自动释放池</code> 是通过 <code>AutoreleasePoolPage</code> 创建的，其定义中有 <code>构造方法</code>，而构造方法的实现是通过父类 <code>AutoreleasePoolPageData</code> 的初始化方法（从上面的定义中可以得知）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//**********AutoreleasePoolPage构造方法**********</span><br><span class="line">    AutoreleasePoolPage(AutoreleasePoolPage *newParent) :</span><br><span class="line">        AutoreleasePoolPageData(begin(),//开始存储的位置</span><br><span class="line">                                objc_thread_self(),//传的是当前线程，当前线程时通过tls获取的</span><br><span class="line">                                newParent,</span><br><span class="line">                                newParent ? 1+newParent-&gt;depth : 0,//如果是第一页深度为0，往后是前一个的深度+1</span><br><span class="line">                                newParent ? newParent-&gt;hiwat : 0)</span><br><span class="line">&#123; </span><br><span class="line">    if (parent) &#123;</span><br><span class="line">        parent-&gt;check();</span><br><span class="line">        ASSERT(!parent-&gt;child);</span><br><span class="line">        parent-&gt;unprotect();</span><br><span class="line">        //this 表示 新建页面，将当前页面的子节点 赋值为新建页面</span><br><span class="line">        parent-&gt;child = this;</span><br><span class="line">        parent-&gt;protect();</span><br><span class="line">    &#125;</span><br><span class="line">    protect();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//**********AutoreleasePoolPageData初始化方法**********</span><br><span class="line">AutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat)</span><br><span class="line">        : magic(), next(_next), thread(_thread),</span><br><span class="line">          parent(_parent), child(nil),</span><br><span class="line">          depth(_depth), hiwat(_hiwat)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>AutoreleasePoolPageData</code> 方法传入的参数含义为：</p>
<ul>
<li><code>begin()</code> 表示 <code>压栈</code> 的位置（即下一个要释放对象的压栈地址）。可以通过源码调式 begin，发现其具体实现等于 <code>页首地址+56</code>，其中的 <code>56</code> 就是结构体 <code>AutoreleasePoolPageData</code> 的内存大小</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16504313207573.jpg"
                     
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//********begin()********</span><br><span class="line">//页的开始位置</span><br><span class="line">id * begin() &#123;</span><br><span class="line">    //等于 首地址+56（AutoreleasePoolPage类所占内存大小）</span><br><span class="line">    return (id *) ((uint8_t *)this+sizeof(*this));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>objc_thread_self()</code> 表示的是 <code>当前线程</code>，而当前线程时通过tls获取的</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((const))</span><br><span class="line">static inline pthread_t objc_thread_self()</span><br><span class="line">&#123;</span><br><span class="line">    //通过tls获取当前线程</span><br><span class="line">    return (pthread_t)tls_get_direct(_PTHREAD_TSD_SLOT_PTHREAD_SELF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>newParent</code> 表示 <code>父节点</code></p>
</li>
<li><p>后续两个参数是 <code>通过父节点的深度、最大入栈个数</code> 计算 <code>depth</code> 以及 <code>hiwat</code></p>
</li>
</ul>
<h2 id="查看自动释放池内存结构"><a href="#查看自动释放池内存结构" class="headerlink" title="查看自动释放池内存结构"></a>查看自动释放池内存结构</h2><p>由于在ARC模式下，是无法手动调用 <code>autorelease</code>，所以将Demo切换至MRC模式（<code>Build Settings -&gt; Object-C Automatic Refrence Counting</code> 设置为 <code>NO</code>）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16504316576585.png"
                     
                ></p>
<ul>
<li>定义如下代码</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//************打印自动释放池结构************</span><br><span class="line">extern void _objc_autoreleasePoolPrint(void);</span><br><span class="line"></span><br><span class="line">//************运行代码************</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        //循环创建对象，并加入自动释放池</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">             NSObject *objc = [[NSObject alloc] sutorelease];</span><br><span class="line">        &#125;</span><br><span class="line">        //调用</span><br><span class="line">        _objc_autoreleasePoolPrint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果如下，发现是6个，但是我们压栈的对象其实只有5个，其中的 <code>POOL</code> 表示 <code>哨兵</code>，即 <code>边界</code>，其目的是 <code>为了防止越界</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16504317957435.jpg"
                     
                ></p>
<p>查看自动释放池的内存结构，发现，页的首地址与 <code>哨兵对象</code> 相差 <code>0x38</code>，转换成十进制刚好是 <code>56</code>，也就是 <code>AutoreleasePoolPage</code> 自己本身的内存大小</p>
<ul>
<li>将上述的测试代码的数据改为 <code>505</code>，其内存结构如下，发现第一页满了，存储了 <code>504</code> 个要释放的对象，第二页只存储了一个</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16504324748465.png"
                     
                ></p>
<ul>
<li>在将数据改为 <code>505+506</code>，来验证第二页是否也是存储了 <code>504</code> 个对象</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16504325130777.jpg"
                     
                ></p>
<p>通过运行发现，第一页存储 <code>504</code>，第二页存储 <code>505</code>，第三页存储 <code>2个</code></p>
<p><strong>结论</strong></p>
<p>所以通过上述测试，可以得出以下结论：</p>
<ul>
<li><p>第一页可以存放 <code>504</code> 个对象，且 <code>只有第一页有哨兵</code>，当第一页压栈满了，就会开辟新的一页</p>
</li>
<li><p>第二页开始，最多可以存放 <code>505</code> 个对象</p>
</li>
<li><p>一页的大小等于 <code>505 * 8 = 4040</code></p>
</li>
</ul>
<p>这个结论同样可以通过 <code>AutoreleasePoolPage</code> 中的 <code>SIZE</code> 来得到印证，从其定义中我们可以得出，一页的大小是 <code>4096</code> 字节，而在其构造函数中 <code>对象的压栈位置</code>，是从 <code>首地址+56</code> 开始的，所以可以一页中实际可以存储 <code>4096 - 56= 4040字节</code>，转换成对象时 <code>4040/8 = 505</code> 个，即一页最多可以 <code>存储505个对象</code>，其中 <code>第一页有哨兵对象</code>，只能存储 <code>504</code> 个对象，其结构图示如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16504377810811.png"
                     
                ></p>
<h2 id="面试题：哨兵在一个自动释放池有几个"><a href="#面试题：哨兵在一个自动释放池有几个" class="headerlink" title="面试题：哨兵在一个自动释放池有几个"></a>面试题：哨兵在一个自动释放池有几个</h2><ul>
<li><p>只有一个哨兵对象，且哨兵在第一页</p>
</li>
<li><p>第一页最多可存 <code>504</code> 个对象，第二页开始最多存 <code>505</code> 个</p>
</li>
</ul>
<h1 id="压栈对象-autoreleaseFast"><a href="#压栈对象-autoreleaseFast" class="headerlink" title="压栈对象 autoreleaseFast"></a>压栈对象 autoreleaseFast</h1><ul>
<li><p>进入 autoreleaseFast 源码，主要有以下几步：</p>
<ul>
<li><p>获取当前操作页，并判断页是否存在以及是否满了</p>
</li>
<li><p>如果 <code>页存在，且未满</code>，则通过 <code>add</code> 方法压栈对象</p>
</li>
<li><p>如果 <code>页存在，且满了</code>，则通过 <code>autoreleaseFullPage</code> 方法安排新的页</p>
</li>
<li><p>如果 <code>页不存在</code>，则通过 <code>autoreleaseNoPage</code> 方法创建新页</p>
</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> static inline id *autoreleaseFast(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    //获取当前操作页</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    //判断页是否满了</span><br><span class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        //如果未满，则压栈</span><br><span class="line">        return page-&gt;add(obj);</span><br><span class="line">    &#125; else if (page) &#123;</span><br><span class="line">        //如果满了，则安排新的页面</span><br><span class="line">        return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //页不存在，则新建页</span><br><span class="line">        return autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></div>

<h2 id="autoreleaseFullPage-方法"><a href="#autoreleaseFullPage-方法" class="headerlink" title="autoreleaseFullPage 方法"></a>autoreleaseFullPage 方法</h2><p>这个方法主要是用于判断当前页是否已经存储满了，如果当前页已经满了，通过 <code>do-while循环</code> 查找 <code>子节点对应的页</code>，如果不存在，则 <code>新建页</code>，并 <code>压栈对象</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//添加自动释放对象，当页满的时候调用这个方法</span><br><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)</span><br><span class="line">&#123;</span><br><span class="line">    // The hot page is full. </span><br><span class="line">    // Step to the next non-full page, adding a new page if necessary.</span><br><span class="line">    // Then add the object to that page.</span><br><span class="line">    ASSERT(page == hotPage());</span><br><span class="line">    ASSERT(page-&gt;full()  ||  DebugPoolAllocation);</span><br><span class="line">    </span><br><span class="line">    //do-while遍历循环查找界面是否满了</span><br><span class="line">    do &#123;</span><br><span class="line">        //如果子页面存在，则将页面替换为子页面</span><br><span class="line">        if (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        //如果子页面不存在，则新建页面</span><br><span class="line">        else page = new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; while (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    //设置为当前操作页面</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    //对象压栈</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从 <code>autoreleasePoolPage</code> 初始化方法中可以看出，主要是通过操作 <code>child</code> 对象，将 <code>当前页的child指向新建页面</code>，由此可以得出 <code>页是通过双向链表链接</code></p>
<h2 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h2><p>这个方法主要是 <code>添加释放对象</code>，其底层的实现时通过 <code>next</code> 指针存储释放对象，并将 next指针递增，表示下一个释放对象存储的位置，从这里可以看出 <code>页</code> 是通过 <code>栈结构存储</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//添加释放对象</span><br><span class="line">id *add(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!full());</span><br><span class="line">    unprotect();</span><br><span class="line">    //传入对象存储的位置</span><br><span class="line">    id *ret = next;  // faster than `return next-1` because of aliasing</span><br><span class="line">    //将obj压栈到next指针位置，然后next进行++，即下一个对象存储的位置</span><br><span class="line">    *next++ = obj;</span><br><span class="line">    protect();</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="autorelease底层分析"><a href="#autorelease底层分析" class="headerlink" title="autorelease底层分析"></a>autorelease底层分析</h1><p>在demo中，我们通过 <code>autorelease</code> 方法，在MRC模式下，将对象压栈到自动释放池，下面分析其底层实现</p>
<ul>
<li><p>查看 <code>autorelease</code> 方法源码</p>
<ul>
<li><p>如果不是对象 或者 是小对象，则直接返回</p>
</li>
<li><p>如果是对象，则调用对象的 <code>autorelease</code> 进行释放</p>
</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((aligned(16), flatten, noinline))</span><br><span class="line">id</span><br><span class="line">objc_autorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    //如果不是对象，则直接返回</span><br><span class="line">    if (!obj) return obj;</span><br><span class="line">    //如果是小对象，也直接返回</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return obj;</span><br><span class="line">    return obj-&gt;autorelease();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>进入对象的 autorelease 实现</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">👇</span><br><span class="line">inline id </span><br><span class="line">objc_object::autorelease()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    //判断是否是自定义类</span><br><span class="line">    if (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        return rootAutorelease();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ((id(*)(objc_object *, SEL))objc_msgSend)(this, @selector(autorelease));</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">inline id </span><br><span class="line">objc_object::rootAutorelease()</span><br><span class="line">&#123;</span><br><span class="line">    //如果是小对象，直接返回</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line">    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;</span><br><span class="line"></span><br><span class="line">    return rootAutorelease2();</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">__attribute__((noinline,used))</span><br><span class="line">id </span><br><span class="line">objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    return AutoreleasePoolPage::autorelease((id)this);</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">static inline id autorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line">    ASSERT(!obj-&gt;isTaggedPointer());</span><br><span class="line">    //autoreleaseFast 压栈操作</span><br><span class="line">    id *dest __unused = autoreleaseFast(obj);</span><br><span class="line">    ASSERT(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从这里看出，无论是 <code>压栈哨兵对象，还是普通对象</code>，都会来到 <code>autorelease</code> 方法，只是 <code>区别标识不同</code> 而已</p>
<h1 id="objc-autoreleasePoolPop-源码分析"><a href="#objc-autoreleasePoolPop-源码分析" class="headerlink" title="objc_autoreleasePoolPop 源码分析"></a>objc_autoreleasePoolPop 源码分析</h1><p>在 <code>objc_autoreleasePoolPop</code> 方法中有个参数，在clang分析时，发现传入的参数是 <code>push</code> 压栈后返回的哨兵对象，即 <code>ctxt</code>，其目的是 <code>避免出栈混乱，防止将别的对象出栈</code></p>
<ul>
<li><p>进入 <code>pop</code> 源码实现，主要有以下几步</p>
<ul>
<li><p>空页面的处理，并 根据token获取page</p>
</li>
<li><p>容错处理</p>
</li>
<li><p>通过 popPage 出栈页</p>
</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//出栈</span><br><span class="line">static inline void</span><br><span class="line">pop(void *token)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line">   //判断对象是否是空占位符</span><br><span class="line">    if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        //如果当是空占位符</span><br><span class="line">        // Popping the top-level placeholder pool.</span><br><span class="line">        //获取当前页</span><br><span class="line">        page = hotPage();</span><br><span class="line">        if (!page) &#123;</span><br><span class="line">            // Pool was never used. Clear the placeholder.</span><br><span class="line">            //如果当前页不存在，则清除空占位符</span><br><span class="line">            return setHotPage(nil);</span><br><span class="line">        &#125;</span><br><span class="line">        // Pool was used. Pop its contents normally.</span><br><span class="line">        // Pool pages remain allocated for re-use as usual.</span><br><span class="line">        //如果当前页存在，则将当前页设置为coldPage,token设置为coldPage的开始位置</span><br><span class="line">        page = coldPage();</span><br><span class="line">        token = page-&gt;begin();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //获取token所在的页</span><br><span class="line">        page = pageForPointer(token);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    //判断最后一个位置，是否是哨兵</span><br><span class="line">    if (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">        //最后一个位置不是哨兵，即最后一个位置是一个对象</span><br><span class="line">        if (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            //如果是第一个位置，且没有父节点，什么也不做</span><br><span class="line">            // Start of coldest page may correctly not be POOL_BOUNDARY:</span><br><span class="line">            // 1. top-level pool is popped, leaving the cold page in place</span><br><span class="line">            // 2. an object is autoreleased with no pool</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果是第一个位置，且有父节点，则出现了混乱</span><br><span class="line">            // Error. For bincompat purposes this is not </span><br><span class="line">            // fatal in executables built with old SDKs.</span><br><span class="line">            return badPop(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) &#123;</span><br><span class="line">        return popPageDebug(token, page, stop);</span><br><span class="line">    &#125;</span><br><span class="line">    //出栈页</span><br><span class="line">    return popPage&lt;false&gt;(token, page, stop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>进入 <code>popPage</code> 源码，其中传入的 <code>allowDebug</code> 为false，则通过 <code>releaseUntil</code> 出栈当前页 <code>stop</code> 位置之前的所有对象，即出栈中的对象 <code>发送release消息</code>，直到遇到传入的 <code>哨兵对象</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//出栈页面</span><br><span class="line">template&lt;bool allowDebug&gt;</span><br><span class="line">    static void</span><br><span class="line">    popPage(void *token, AutoreleasePoolPage *page, id *stop)</span><br><span class="line">&#123;</span><br><span class="line">    if (allowDebug &amp;&amp; PrintPoolHiwat) printHiwat();</span><br><span class="line">    //出栈当前操作页面对象</span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    // memory: delete empty children 删除空子项</span><br><span class="line">    if (allowDebug &amp;&amp; DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        // special case: delete everything during page-per-pool debugging</span><br><span class="line">        //调试期间删除每个特殊情况下的所有池</span><br><span class="line">        //获取当前页面的父节点</span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        //将当前页面杀掉</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        //设置操作页面为父节点页面</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (allowDebug &amp;&amp; DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        // special case: delete everything for pop(top)</span><br><span class="line">        // when debugging missing autorelease pools</span><br><span class="line">        //特殊情况：调试丢失的自动释放池时删除pop（top）的所有内容</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (page-&gt;child) &#123;</span><br><span class="line">        // hysteresis: keep one empty child if page is more than half full 如果页面已满一半以上，则保留一个空子级</span><br><span class="line">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>进入 <code>releaseUntil</code> 实现，主要是通过 <code>循环遍历</code>，判断对象是否等于stop，其目的是    释放stop之前的所有的对象</p>
<ul>
<li><p>首先通过 <code>获取page的next释放对象（即page的最后一个对象）</code>，并对 <code>next</code> 进行 <code>递减</code>，获取 <code>上一个对象</code></p>
</li>
<li><p>判断 <code>是否哨兵对象</code>，如果不是则自动调用 <code>objc_release</code> 释放</p>
</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//释放到stop位置之前的所有对象</span><br><span class="line">void releaseUntil(id *stop) </span><br><span class="line">&#123;</span><br><span class="line">    // Not recursive: we don&#x27;t want to blow out the stack  不是递归的：我们不想破坏堆栈</span><br><span class="line">    // if a thread accumulates a stupendous amount of garbage</span><br><span class="line">    //判断下一个对象是否等于stop，如果不等于，则进入while循环</span><br><span class="line">    while (this-&gt;next != stop) &#123;</span><br><span class="line">        // Restart from hotPage() every time, in case -release </span><br><span class="line">        // autoreleased more objects 每次从hotPage（）重新启动，以防-release自动释放更多对象</span><br><span class="line">        //获取当前操作页面，即hot页面</span><br><span class="line">        AutoreleasePoolPage *page = hotPage();</span><br><span class="line"></span><br><span class="line">        // fixme I think this `while` can be `if`, but I can&#x27;t prove it</span><br><span class="line">        //如果当前页是空的</span><br><span class="line">        while (page-&gt;empty()) &#123;</span><br><span class="line">            //将page赋值为父节点页</span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            //并设置当前页为父节点页</span><br><span class="line">            setHotPage(page);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page-&gt;unprotect();</span><br><span class="line">        //next进行--操作，即出栈</span><br><span class="line">        id obj = *--page-&gt;next;</span><br><span class="line">        //将页索引位置置为SCRIBBLE，表示已经被释放</span><br><span class="line">        memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));</span><br><span class="line">        page-&gt;protect();</span><br><span class="line"></span><br><span class="line">        if (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">            //释放</span><br><span class="line">            objc_release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置当前页</span><br><span class="line">    setHotPage(this);</span><br><span class="line"></span><br><span class="line">#if DEBUG</span><br><span class="line">    // we expect any children to be completely empty</span><br><span class="line">    for (AutoreleasePoolPage *page = child; page; page = page-&gt;child) &#123;</span><br><span class="line">        ASSERT(page-&gt;empty());</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>进入 <code>kill</code> 实现，主要是销毁当前页，将 <code>当前页赋值为父节点页</code>，并将 <code>父节点页的child对象指针置为nil</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//销毁</span><br><span class="line">void kill() </span><br><span class="line">&#123;</span><br><span class="line">    // Not recursive: we don&#x27;t want to blow out the stack </span><br><span class="line">    // if a thread accumulates a stupendous amount of garbage</span><br><span class="line">    AutoreleasePoolPage *page = this;</span><br><span class="line">    //获取最后一个页</span><br><span class="line">    while (page-&gt;child) page = page-&gt;child;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage *deathptr;</span><br><span class="line">    do &#123;</span><br><span class="line">        deathptr = page;</span><br><span class="line">        //子节点 变成 父节点</span><br><span class="line">        page = page-&gt;parent;</span><br><span class="line">        if (page) &#123;</span><br><span class="line">            page-&gt;unprotect();</span><br><span class="line">            //子节点为nil</span><br><span class="line">            page-&gt;child = nil;</span><br><span class="line">            page-&gt;protect();</span><br><span class="line">        &#125;</span><br><span class="line">        delete deathptr;</span><br><span class="line">    &#125; while (deathptr != this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>通过上面的分析，针对自动释放池的push和pop，总结如下：</p>
<ul>
<li><p>在自动释放池的 压栈（即push）操作中</p>
<ul>
<li>当没有pool，即只有空占位符（存储在tls中）时，则创建页，压栈哨兵对象</li>
<li>在页中 压栈普通对象 主要是通过 next 指针 递增 进行的</li>
<li>当 页满 了时，需要设置页的 child 对象为 新建页</li>
</ul>
</li>
</ul>
<p>所以，综上所述，autorelease 和 objc_autoreleasePush 的整体底层的流程如下图所示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16504439133624.png"
                     
                ></p>
<ul>
<li><p>在自动释放池的 <code>出栈（即 pop</code>）操作中</p>
<ul>
<li>在页中 <code>出栈普通对象</code> 主要是通过 <code>next</code> 指针 <code>递减</code> 进行的</li>
<li>当 <code>页空</code> 了时，需要赋值页的 <code>parent</code> 对象为 <code>当前页</code></li>
</ul>
</li>
</ul>
<p>综上所述，<code>objc_autoreleasePoolPop</code> 出栈的流程如下所示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16504440127961.png"
                     
                ></p>
<h1 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h1><p>对于Runloop，主要关心的点有以下几个</p>
<ul>
<li><p>runoop是什么？</p>
</li>
<li><p>runloop和线程是什么关系？</p>
</li>
<li><p>runloop是什么时候创建的？</p>
</li>
</ul>
<h2 id="Runloop介绍"><a href="#Runloop介绍" class="headerlink" title="Runloop介绍"></a>Runloop介绍</h2><p><code>Runloop</code> 是时间接收和分发机制的一个实现，是线程相关的基础框架的一部分，一个<code>Runloop就是一个时间处理的循环</code>，用来不停的调度工作以及处理输入事件。</p>
<p><code>Runloop</code> 本质是一个 <code>do-while循环</code>，没事做就休息，来活了就干活。与普通的 <code>while</code> 循环时有区别的，普通的 <code>while循环</code> 会导致CPU进入 <code>忙等待状态</code>，即一直消耗cpu，而Runloop则不会，Runloop是一种 <code>闲等待</code>，即Runloop具备 <code>休眠功能</code>。</p>
<h2 id="Runloop的作用"><a href="#Runloop的作用" class="headerlink" title="Runloop的作用"></a>Runloop的作用</h2><ul>
<li><p>保持程序的持续运行</p>
</li>
<li><p>处理APP中的各种事件（触摸、定时器、performSelector（一种方法的调用方式））</p>
</li>
<li><p>节省CPU资源，提高程序的性能，该做事就做事，该休息就休息</p>
</li>
</ul>
<h1 id="Runloop源码分析"><a href="#Runloop源码分析" class="headerlink" title="Runloop源码分析"></a>Runloop源码分析</h1><p>Runloop源码的<a class="link"   target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/CF/" >下载地址 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，在其中找到最新版本下载即可</p>
<h2 id="Runloop和线程的关系"><a href="#Runloop和线程的关系" class="headerlink" title="Runloop和线程的关系"></a>Runloop和线程的关系</h2><p>一般在日常开发中，对于 <code>Runloop的获取</code> 主要有以下两种方式</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 主运行循环</span><br><span class="line">CFRunLoopRef mainRunloop = CFRunLoopGetMain();</span><br><span class="line">// 当前运行循环</span><br><span class="line">CFRunLoopRef currentRunloop = CFRunLoopGetCurrent();</span><br></pre></td></tr></table></figure></div>

<ul>
<li>进入 <code>CFRunLoopGetMain</code> 源码</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    static CFRunLoopRef __main = NULL; // no retain needed</span><br><span class="line">    // pthread_main_thread_np 主线程</span><br><span class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</span><br><span class="line">    return __main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>进入 <code>_CFRunLoopGet0</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// should only be called by Foundation</span><br><span class="line">// t==0 is a synonym for &quot;main thread&quot; that always works</span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    //如果t不存在，则标记为主线程（即默认情况，默认是主线程）</span><br><span class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    if (!__CFRunLoops) &#123;</span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">        </span><br><span class="line">        //创建全局字典，标记为kCFAllocatorSystemDefault</span><br><span class="line">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        //通过主线程 创建主运行循环</span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        //利用dict，进行key-value绑定操作，即可以说明，线程和runloop是一一对应的</span><br><span class="line">        // dict : key value</span><br><span class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">        </span><br><span class="line">        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">            CFRelease(dict);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        CFRelease(mainLoop);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    //通过其他线程获取runloop</span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        //如果没有获取到，则新建一个运行循环</span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">        if (!loop) &#123;</span><br><span class="line">            //将新建的runloop 与 线程进行key-value绑定</span><br><span class="line">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">            loop = newLoop;</span><br><span class="line">        &#125;</span><br><span class="line">        // don&#x27;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">        CFRelease(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    if (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</span><br><span class="line">        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从这里可以说明，<code>Runloop</code> 只有 <code>两种</code>，一种是 <code>主线程的</code>，一种是 <code>其他线程的</code>。即<code>Runloop和线程是一一对应的</code></p>
<h2 id="Runloop的创建"><a href="#Runloop的创建" class="headerlink" title="Runloop的创建"></a>Runloop的创建</h2><ul>
<li>进入 <code>__CFRunLoopCreate</code> 源码，其中主要是对runloop属性的赋值操作</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static CFRunLoopRef __CFRunLoopCreate(pthread_t t) &#123;</span><br><span class="line">    CFRunLoopRef loop = NULL;</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    uint32_t size = sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase);</span><br><span class="line">    loop = (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopTypeID, size, NULL);</span><br><span class="line">    //如果loop为空，则直接返回NULL</span><br><span class="line">    if (NULL == loop) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    //runloop属性配置</span><br><span class="line">    (void)__CFRunLoopPushPerRunData(loop);</span><br><span class="line">    __CFRunLoopLockInit(&amp;loop-&gt;_lock);</span><br><span class="line">    loop-&gt;_wakeUpPort = __CFPortAllocate();</span><br><span class="line">    if (CFPORT_NULL == loop-&gt;_wakeUpPort) HALT;</span><br><span class="line">    __CFRunLoopSetIgnoreWakeUps(loop);</span><br><span class="line">    loop-&gt;_commonModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode);</span><br><span class="line">    loop-&gt;_commonModeItems = NULL;</span><br><span class="line">    loop-&gt;_currentMode = NULL;</span><br><span class="line">    loop-&gt;_modes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    loop-&gt;_blocks_head = NULL;</span><br><span class="line">    loop-&gt;_blocks_tail = NULL;</span><br><span class="line">    loop-&gt;_counterpart = NULL;</span><br><span class="line">    loop-&gt;_pthread = t;</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">    loop-&gt;_winthread = GetCurrentThreadId();</span><br><span class="line">#else</span><br><span class="line">    loop-&gt;_winthread = 0;</span><br><span class="line">#endif</span><br><span class="line">    rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);</span><br><span class="line">    if (NULL != rlm) __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>进入 <code>CFRunLoopRef</code> 的定义，根据定义得知，其实 <code>RunLoop也是一个对象</code>。是 <code>__CFRunLoop</code> 结构体的 <code>指针类型</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __CFRunLoop * CFRunLoopRef;</span><br><span class="line">👇</span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;            /* locked for accessing mode list */</span><br><span class="line">    __CFPort _wakeUpPort;            // used for CFRunLoopWakeUp</span><br><span class="line">    Boolean _unused;</span><br><span class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    uint32_t _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    struct _block_item *_blocks_head;</span><br><span class="line">    struct _block_item *_blocks_tail;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>从定义中可以得出，<code>一个RunLoop依赖于多个Mode</code>，意味着一个RunLoop需要处理多个事务，即 <code>一个Mode对应多个item</code>，而一个item包含了 <code>timer、source、observer</code>，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16505035096425.png"
                     
                ></p>
<h2 id="Mode类型"><a href="#Mode类型" class="headerlink" title="Mode类型"></a>Mode类型</h2><p>其中 <code>mode</code> 在苹果文档中提及的有五个，而在iOS中公开暴露出来的只有 <code>NSDefaultRunLoopMode</code> 和 <code>NSRunLoopCommonModes</code>。<code>NSRunLoopCommonModes</code> 实际上是一个 <code>Mode</code> 的集合，默认包括 <code>NSDefaultRunLoopMode</code> 和 <code>NSEventTrackingRunLoopMode</code></p>
<ul>
<li><p><code>NSDefaultRunLoopMode</code>：默认的 <code>mode</code>，正常情况下都是在这个mode</p>
</li>
<li><p><code>NSConnectionReplyMode</code></p>
</li>
<li><p><code>NSModalPanelRunLoopMode</code></p>
</li>
<li><p><code>NSEventTrackingRunLoopMode</code>：使用这个mode去跟踪来自用户交互的事件（比如UITableView上下滑动）</p>
</li>
<li><p><code>NSRunLoopCommonModes</code>：伪模式，灵活性更好</p>
</li>
</ul>
<h2 id="Source-amp-Timer-amp-Observer"><a href="#Source-amp-Timer-amp-Observer" class="headerlink" title="Source &amp; Timer &amp; Observer"></a>Source &amp; Timer &amp; Observer</h2><ul>
<li><p><code>source</code>： 表示可以 <code>唤醒runloop的一些事件</code>，例如用户点击了屏幕，就会创建一个runloop，主要分为 <code>source0</code> 和 <code>source1</code></p>
<ul>
<li><code>source0</code> 表示 <code>非系统事件</code>，即用户自定义的事件</li>
<li><code>source1</code> 表示 <code>系统事件</code>，主要负责底层的通讯，具备唤醒能力</li>
</ul>
</li>
<li><p><code>timer</code>： 就是常用的 <code>NSTimer</code> 定时器一类</p>
</li>
<li><p><code>observer</code>：主要用于监听runloop的状态变化，并作出一定响应，主要有以下一些状态</p>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    //进入RunLoop</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),</span><br><span class="line">    //即将处理Timers</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</span><br><span class="line">    //即将处理Source</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</span><br><span class="line">    //即将进入休眠</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</span><br><span class="line">    //被唤醒</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</span><br><span class="line">    //退出RunLoop</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="验证：runloop和mode是一对多"><a href="#验证：runloop和mode是一对多" class="headerlink" title="验证：runloop和mode是一对多"></a>验证：runloop和mode是一对多</h2><p>下面，通过上面的代码调式来验证我们上面提及的关系</p>
<ul>
<li><p>通过lldb命令获取 <code>mainRunLoop、currentRunLoop</code> 的 <code>currentMode</code></p>
<ul>
<li>po CFRunLoopCopyCurrentMode(mainRunloop)</li>
<li>po CFRunLoopCopyCurrentMode(currentRunloop)</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16505046382407.jpg"
                     
                ></p>
<p>从这里，可以说明，runloop在运行时的mode只有一个</p>
<ul>
<li>获取 <code>mainRunloop</code> 的所有模型，即 <code>po CFRunLoopCopyAllModes(mainRunloop)</code></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16505047055014.jpg"
                     
                ></p>
<p>从结果可以验证 <code>runloop</code> 和 <code>CFRunloopMode</code> 具有 <code>一对多</code> 的关系</p>
<h2 id="验证：mode和item也是一对多"><a href="#验证：mode和item也是一对多" class="headerlink" title="验证：mode和item也是一对多"></a>验证：mode和item也是一对多</h2><ul>
<li>在上述代码中，加断点，通过bt查看堆栈信息，从这里看出timer的item类型如下所示：</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16505050509921.jpg"
                     
                ></p>
<ul>
<li><p>在 <code>runloop</code> 源码中查看 <code>item</code> 类型，有以下几种</p>
<ul>
<li><p>block应用：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK</strong></p>
</li>
<li><p>调用timer：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong></p>
</li>
<li><p>响应source0：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong></p>
</li>
<li><p>响应source1：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</strong></p>
</li>
<li><p>GCD主队列：<strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong></p>
</li>
<li><p>observer：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</strong></p>
</li>
</ul>
<p>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16505052599469.jpg"
                     
                ></p>
</li>
<li><p>在这里以 <code>timer</code> 为例，一般初始化timer时，都会将timer通过 <code>addTimer:forMode:</code> 方法添加到runloop中，于是在源码中查找 <code>addTimer</code> 的相关方法，即 <code>CFRunLoopAddTimer</code> 方法，其源码实现如下，其实现主要判断是否是 <code>kCFRunLoopCommonModes</code> ，然后查找runloop的mode进行匹配处理</p>
<ul>
<li><p>其中 <code>kCFRunLoopCommonModes</code> 不是一种模式，是一种抽象的 <code>伪模式</code> ，比 <code>defaultMode</code> 更加灵活</p>
</li>
<li><p>通过 <code>CFSetAddValue(rl-&gt;_commonModeItems, rlt);</code> 可以得知，<code>runloop</code> 与 <code>mode</code> 是 <code>一对多</code> 的，同时可以得出 <code>mode</code> 与 <code>item</code> 也是 <code>一对多</code> 的</p>
</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</span><br><span class="line">    if (!__CFIsValid(rlt) || (NULL != rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop != rl)) return;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    </span><br><span class="line">    // 重点 : kCFRunLoopCommonModes</span><br><span class="line">    if (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">        //如果是kCFRunLoopCommonModes 类型</span><br><span class="line">       </span><br><span class="line">        CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</span><br><span class="line">        </span><br><span class="line">        if (NULL == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">            rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        &#125;</span><br><span class="line">        //runloop与mode 是一对多的， mode与item也是一对多的</span><br><span class="line">        CFSetAddValue(rl-&gt;_commonModeItems, rlt);</span><br><span class="line">        if (NULL != set) &#123;</span><br><span class="line">            CFTypeRef context[2] = &#123;rl, rlt&#125;;</span><br><span class="line">            /* add new item to all common-modes */</span><br><span class="line">            //执行</span><br><span class="line">            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</span><br><span class="line">            CFRelease(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //如果是非commonMode类型</span><br><span class="line">        //查找runloop的模型</span><br><span class="line">        CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);</span><br><span class="line">        if (NULL != rlm) &#123;</span><br><span class="line">            if (NULL == rlm-&gt;_timers) &#123;</span><br><span class="line">                CFArrayCallBacks cb = kCFTypeArrayCallBacks;</span><br><span class="line">                cb.equal = NULL;</span><br><span class="line">                rlm-&gt;_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;cb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断mode是否匹配</span><br><span class="line">        if (NULL != rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) &#123;</span><br><span class="line">            __CFRunLoopTimerLock(rlt);</span><br><span class="line">            if (NULL == rlt-&gt;_runLoop) &#123;</span><br><span class="line">                rlt-&gt;_runLoop = rl;</span><br><span class="line">            &#125; else if (rl != rlt-&gt;_runLoop) &#123;</span><br><span class="line">                __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">                __CFRunLoopModeUnlock(rlm);</span><br><span class="line">                __CFRunLoopUnlock(rl);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果匹配，则将runloop加进去，而runloop的执行依赖于  [runloop run]</span><br><span class="line">            CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name);</span><br><span class="line">            __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">            __CFRunLoopTimerFireTSRLock();</span><br><span class="line">            __CFRepositionTimerInMode(rlm, rlt, false);</span><br><span class="line">            __CFRunLoopTimerFireTSRUnlock();</span><br><span class="line">            if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) &#123;</span><br><span class="line">                // Normally we don&#x27;t do this on behalf of clients, but for</span><br><span class="line">                // backwards compatibility due to the change in timer handling...</span><br><span class="line">                if (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (NULL != rlm) &#123;</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="RunLoop执行"><a href="#RunLoop执行" class="headerlink" title="RunLoop执行"></a>RunLoop执行</h2><p>众所周知，runloop的执行依赖于 <code>run</code> 方法，从下面的堆栈信息中可以看出，其底层执行的是 <code>__CFRunLoopRun</code> 方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16505067486223.png"
                     
                ></p>
<ul>
<li><p>进入 __CFRunLoopRun 源码，针对不同的对象，有不同的处理</p>
<ul>
<li><p>如果有 observer，则调用 __CFRunLoopDoOnservers</p>
</li>
<li><p>如果有 block，则调用 __CFRunLoopDoBlocks</p>
</li>
<li><p>如果有 timer，则调用 __CFRunLoopDoTimers</p>
</li>
<li><p>如果是 source0，则调用 __CFRunLoopDoSources0</p>
</li>
<li><p>如果是 source1，则调用 __CFRunLoopDoSources1</p>
</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/* rl, rlm are locked on entrance and exit */</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    do&#123;</span><br><span class="line">        ...</span><br><span class="line">         //通知 Observers: 即将处理timer事件</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        //通知 Observers: 即将处理Source事件</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        //处理Blocks</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        //处理sources0</span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        //处理sources0返回为YES</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            // 处理Blocks</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        //如果是timer</span><br><span class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                // Re-arm the next timer, because we apparently fired early</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        //如果是source1</span><br><span class="line">        CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">        if (rls) &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">            mach_msg_header_t *reply = NULL;</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">            if (NULL != reply) &#123;</span><br><span class="line">                (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</span><br><span class="line">                CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">            &#125;</span><br><span class="line">#elif DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    &#125;while (0 == retVal);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>进入 __CFRunLoopDoTimers 源码，主要是通过for循环，对单个timer进行处理</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) &#123;    /* DOES CALLOUT */</span><br><span class="line">    ...</span><br><span class="line">    //循环遍历，做下层单个timer的执行</span><br><span class="line">    for (CFIndex idx = 0, cnt = timers ? CFArrayGetCount(timers) : 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx);</span><br><span class="line">        Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt);</span><br><span class="line">        timerHandled = timerHandled || did;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>进入 <code>__CFRunLoopDoTimer</code> 源码，主要逻辑是 <code>timer</code> 执行完毕后，会主动调用 <code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</code> 函数，正好与timer堆栈调用的一致</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16505069926108.jpg"
                     
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// mode and rl are locked on entry and exit</span><br><span class="line">static Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt) &#123; </span><br><span class="line">    ...</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-&gt;_callout, rlt, context_info);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="timer执行总结"><a href="#timer执行总结" class="headerlink" title="timer执行总结"></a>timer执行总结</h2><ul>
<li><p>为自定义的timer，设置mode，并将其加入 runloop 中</p>
</li>
<li><p>在runloop的 run 方法执行时，会调用 __CFRunLoopDoTimers 执行所有的timer</p>
</li>
<li><p>在 __CFRunLoopDoTimers 方法中，会通过for循环执行单个timer的操作</p>
</li>
<li><p>在 __CFRunLoopDoTimer 方法中，timer执行完毕后，会执行对应的timer回调函数</p>
</li>
</ul>
<p>以上，是针对 <code>timer</code> 的执行分析，对于 <code>observer、block、source0、source1</code>，其执行原理与timer是类似的，这里就不再重复说明，一下是 <a class="link"   target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" >苹果官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 针对runloop处理不同源的图示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16505072624441.jpg"
                     
                ></p>
<h2 id="RunLoop底层管理"><a href="#RunLoop底层管理" class="headerlink" title="RunLoop底层管理"></a>RunLoop底层管理</h2><p>从上述的堆栈信息中可以看出，run在底层的实现路径为 <code>CFRunLoopRun -&gt; CFRunLoopRun -&gt; __CFRunLoopRun</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopRun(void) &#123;    /* DOES CALLOUT */</span><br><span class="line">    int32_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        // 1.0e10 : 科学技术 1*10^10</span><br><span class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>进入 <code>CFRunLoopRunSpecific</code> 源码，，首先根据modeName找到对应的mode，然后主要分为三种情况：</p>
<ul>
<li><p>如果是 <code>entry</code>，则通知observer，即将 <code>进入runloop</code></p>
</li>
<li><p>如果是 <code>exit</code>，则通过observer，即将 <code>退出runloop</code></p>
</li>
<li><p>如果是其他中间状态，主要是通过runloop处理各种源</p>
</li>
</ul>
</li>
</ul>
<p>其伪代码表示如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    </span><br><span class="line">    //首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);</span><br><span class="line">    </span><br><span class="line">    // 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    // 内部函数，进入loop</span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    // 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>进入 <code>__CFRunLoopRun</code> 源码，由于这部分代码较多，于是这里用伪代码代替。其主要逻辑是 <code>根据不同的事件源进行不同的处理</code>，当RunLoop休眠时，可以通过相应的事件唤醒RunLoop</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">//核心函数</span><br><span class="line">/* rl, rlm are locked on entrance and exit */</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode)&#123;</span><br><span class="line">    </span><br><span class="line">    //通过GCD开启一个定时器，然后开始跑圈</span><br><span class="line">    dispatch_source_t timeout_timer = NULL;</span><br><span class="line">    ...</span><br><span class="line">    dispatch_resume(timeout_timer);</span><br><span class="line">    </span><br><span class="line">    int32_t retVal = 0;</span><br><span class="line">    </span><br><span class="line">    //处理事务,即处理items</span><br><span class="line">    do &#123;</span><br><span class="line">        </span><br><span class="line">        // 通知 Observers: 即将处理timer事件</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        </span><br><span class="line">        // 通知 Observers: 即将处理Source事件</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources)</span><br><span class="line">        </span><br><span class="line">        // 处理Blocks</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        // 处理sources0</span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        </span><br><span class="line">        // 处理sources0返回为YES</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            // 处理Blocks</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 判断有无端口消息(Source1)</span><br><span class="line">        if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) &#123;</span><br><span class="line">            // 处理消息</span><br><span class="line">            goto handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        // 通知 Observers: 即将进入休眠</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        // 等待被唤醒</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</span><br><span class="line">        </span><br><span class="line">        // user callouts now OK again</span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        // 通知 Observers: 被唤醒，结束休眠</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    handle_msg:</span><br><span class="line">        if (被timer唤醒) &#123;</span><br><span class="line">            // 处理Timers</span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time())；</span><br><span class="line">        &#125;else if (被GCD唤醒)&#123;</span><br><span class="line">            // 处理gcd</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125;else if (被source1唤醒)&#123;</span><br><span class="line">            // 被Source1唤醒，处理Source1</span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 处理block</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;//处理源</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;//超时</span><br><span class="line">        &#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal = kCFRunLoopRunStopped;//停止</span><br><span class="line">        &#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped = false;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;//停止</span><br><span class="line">        &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunFinished;//结束</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;while (0 == retVal);</span><br><span class="line">    </span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>所以，综上所述，RunLoop的执行流程，如下所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/BboyZJ.github.io/assets/16505074680640.png"
                     
                ></p>
<h1 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h1><h2 id="AutoreleasePool相关"><a href="#AutoreleasePool相关" class="headerlink" title="AutoreleasePool相关"></a>AutoreleasePool相关</h2><h3 id="面试题1：临时变量什么时候释放"><a href="#面试题1：临时变量什么时候释放" class="headerlink" title="面试题1：临时变量什么时候释放"></a>面试题1：临时变量什么时候释放</h3><ul>
<li><p>如果在 <code>正常情况下</code>，一般是 <code>超出作用域就会立即释放</code></p>
</li>
<li><p>如果将临时变量加入了 <code>自动释放池</code>，会延迟释放，即在 <code>runloop休眠/超出autoreleasePool作用域之后会释放</code></p>
</li>
</ul>
<h3 id="面试题2：AutoreleasePool原理"><a href="#面试题2：AutoreleasePool原理" class="headerlink" title="面试题2：AutoreleasePool原理"></a>面试题2：AutoreleasePool原理</h3><ul>
<li><p>自动释放池的本质是一个 <code>autoreleasePoolPage结构体对象</code>，是一个 <code>栈结构存储的页</code>，每一个 <code>autoreleasePoolPage</code> 都是以 <code>双向链表</code> 的形式链接</p>
</li>
<li><p>自动释放池的 <code>压栈</code> 和 <code>出栈</code> 主要是通过结构体的 <code>构造函数</code> 和 <code>析构函数</code> 调用底层的 <code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code>，实际上调用的是 <code>autoreleasePoolPage</code> 的 <code>push</code> 和 <code>pop</code> 两个方法</p>
</li>
<li><p>每次调用 <code>push</code> 操作其实就是创建一个新的 <code>autoreleasePoolPage</code>，而 <code>autoreleasePoolPage</code> 的具体操作就是插入一个 <code>POOL_BOUNDARY</code>,并返回插入 <code>POOL_BOUNDARY</code> 的内存地址。而 <code>push</code> 内部调用 <code>autoreleaseFast</code> 方法处理，主要有以下三种情况</p>
<ul>
<li><p>当 <code>page存在且不满</code> 时，调用add方法将对象添加至page的next指针处，并next递增</p>
</li>
<li><p>当 <code>page存在且已满</code> 时，调用 <code>autoreleaseFullPage</code> 初始化一个新的page，然后调用add方法将对象添加至page栈中</p>
</li>
<li><p>当 <code>page不存在</code> 时，调用 <code>autoreleaseNoPage</code> 创建一个hotPage，然后调用add方法将对象添加至page栈中</p>
</li>
</ul>
</li>
<li><p>当执行 <code>pop</code> 时，会传入一个值，这个值就是push操作的返回值，即 <code>POOL_BOUNDARY</code> 的内存地址 <code>token</code>，所以pop内部的实现就是根据token找到哨兵对象所处的page中，然后使用 <code>objc_release</code> 释放token之前的对象，并把next指针指到正确的位置</p>
</li>
</ul>
<h3 id="面试题3：autoreleasePool能否嵌套使用？"><a href="#面试题3：autoreleasePool能否嵌套使用？" class="headerlink" title="面试题3：autoreleasePool能否嵌套使用？"></a>面试题3：autoreleasePool能否嵌套使用？</h3><ul>
<li><p>可以嵌套使用，其目的是可以 控制应用程序的内存峰值，使其不要太高</p>
</li>
<li><p>可以嵌套的原因是因为自动释放池是以栈为节点，通过双向链表的形式链接的，且是和线程一一对应的</p>
</li>
<li><p>自动释放池的 多层嵌套 其实就是不停的 push哨兵对象，在pop时，会先释放里面的，在释放外面的</p>
</li>
</ul>
<h3 id="面试题4：哪些对象可以加入autoreleasePool？alloc创建可以吗？"><a href="#面试题4：哪些对象可以加入autoreleasePool？alloc创建可以吗？" class="headerlink" title="面试题4：哪些对象可以加入autoreleasePool？alloc创建可以吗？"></a>面试题4：哪些对象可以加入autoreleasePool？alloc创建可以吗？</h3><ul>
<li><p>使用 <code>alloc、new、copy</code> 关键字生成的对象和 <code>retain</code> 了的对象 <code>需要手动释放</code>，不会被添加到自动释放池</p>
</li>
<li><p>设置为 <code>autorelease</code> 的对象 不需要手动释放，会直接进入自动释放池</p>
</li>
<li><p>所有 <code>autorelease</code> 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中</p>
</li>
</ul>
<h3 id="面试题5：autoreleasePool的释放实际是什么时候？"><a href="#面试题5：autoreleasePool的释放实际是什么时候？" class="headerlink" title="面试题5：autoreleasePool的释放实际是什么时候？"></a>面试题5：autoreleasePool的释放实际是什么时候？</h3><ul>
<li><p>APP启动后，苹果主线程 <code>runloop</code> 里面注册了两个 <code>observer</code>，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p>
</li>
<li><p>第一个 <code>observer</code> 监视的事件是 <code>Entry</code>（即将键入loop），其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池，其 order 是 -2147483647，优先级最高，保证创建释放池发生在其他所有回调之前</p>
</li>
<li><p>第二个 <code>observer</code> 监视了两个事件：<code>BeforeWaiting</code>(准备进入休眠)时 调用<code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> <code>释放旧的池创建新的池子</code>。 <code>Exit（即退出loop）时调用 _objc_autoreleasePoolPop()来释放自动释放池</code>。这个observer的order是214748647，<code>优先级最低</code>，保证其释放池子发生在其他所有回调之后。</p>
</li>
</ul>
<h3 id="面试题6：thread和autoreleasePool的关系？"><a href="#面试题6：thread和autoreleasePool的关系？" class="headerlink" title="面试题6：thread和autoreleasePool的关系？"></a>面试题6：thread和autoreleasePool的关系？</h3><p>在 <a class="link"   target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsautoreleasepool#//apple_ref/doc/uid/TP40003623" >官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 中，找到如下说明：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects (see Threads). As new pools are created, they get added to the top of the stack. When pools are deallocated, they are removed from the stack. Autoreleased objects are placed into the top autorelease pool for the current thread. When a thread terminates, it automatically drains all of the autorelease pools associated with itself.</span><br></pre></td></tr></table></figure></div>

<p>大致意思是：</p>
<ul>
<li><p><code>每个线程</code>，包括 <code>主线程</code> 在内都维护了 <code>自己的自动释放池堆栈结构</code></p>
</li>
<li><p><code>新的</code> 自动释放池在被创建时，会被添加到 <code>栈顶</code>，当自动释放池 <code>销毁时</code>，会 <code>从栈中移除</code></p>
</li>
<li><p>对于 <code>当前线程</code> 来说，会 <code>将自动释放池的对象</code> 放入自动释放池的 <code>栈顶</code>，在线程停止时，会 <code>自动释放掉与该线程相关联的所有自动释放池</code></p>
</li>
</ul>
<p><strong>总结：</strong> 每个线程都有与之关联的自动释放池堆栈结构，新的pool在创建时会被压栈到栈顶，pool销毁时，会被出栈，对于当前线程来说，释放对象会被压栈到栈顶，线程停止时，会自动释放与之相关联的自动释放池</p>
<h3 id="面试题7：runloop和autorelease的关系"><a href="#面试题7：runloop和autorelease的关系" class="headerlink" title="面试题7：runloop和autorelease的关系"></a>面试题7：runloop和autorelease的关系</h3><p>在 <a class="link"   target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsautoreleasepool#//apple_ref/doc/uid/TP40003623" >官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 中，找到如下说明</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</span><br></pre></td></tr></table></figure></div>

<p>大致意思如下：</p>
<ul>
<li><p>主线程的 <code>runloop</code> 在每次事件循环之前，会自动创建一个 <code>autoreleasePool</code></p>
</li>
<li><p>并且会在 <code>事件循环</code> 结束时，执行 <code>drain</code> 操作，释放其中的对象</p>
</li>
</ul>
<h2 id="RunLoop相关"><a href="#RunLoop相关" class="headerlink" title="RunLoop相关"></a>RunLoop相关</h2><h3 id="面试题1：当前有个子线程，子线程中有个timer，timer是否能够执行，并进行持续大打印？"><a href="#面试题1：当前有个子线程，子线程中有个timer，timer是否能够执行，并进行持续大打印？" class="headerlink" title="面试题1：当前有个子线程，子线程中有个timer，timer是否能够执行，并进行持续大打印？"></a>面试题1：当前有个子线程，子线程中有个timer，timer是否能够执行，并进行持续大打印？</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ZJThread *thread = [[ZJThread alloc] initWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">       // thread.name = nil 因为这个变量只是捕捉</span><br><span class="line">       // ZJThread *thread = nil</span><br><span class="line">       // thread = 初始化 捕捉一个nil进来</span><br><span class="line">       NSLog(@&quot;%@---%@&quot;,[NSThread currentThread],[[NSThread currentThread] name]);</span><br><span class="line">       [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">           NSLog(@&quot;hello word&quot;);            </span><br><span class="line">           // 退出线程--结果runloop也停止了</span><br><span class="line">           if (self.isStopping) &#123;</span><br><span class="line">               [NSThread exit];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;];</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   thread.name = @&quot;lgcode.com&quot;;</span><br><span class="line">   [thread start];</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不可以，因为 子线程的runloop默认是不启动的，需要 runloop run 启动，需要将上述代码改成下面：</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ZJThread *thread = [[ZJThread alloc] initWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">        // thread.name = nil 因为这个变量只是捕捉</span><br><span class="line">        // ZJThread *thread = nil</span><br><span class="line">        // thread = 初始化 捕捉一个nil进来</span><br><span class="line">        NSLog(@&quot;%@---%@&quot;,[NSThread currentThread],[[NSThread currentThread] name]);</span><br><span class="line">        [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">            NSLog(@&quot;hello word&quot;);            </span><br><span class="line">            // 退出线程--结果runloop也停止了</span><br><span class="line">            if (self.isStopping) &#123;</span><br><span class="line">                [NSThread exit];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        [[NSRunLoop currentRunLoop] run];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    thread.name = @&quot;lgcode.com&quot;;</span><br><span class="line">    [thread start];</span><br></pre></td></tr></table></figure></div>

<h3 id="面试题2：runloop和线程的关系"><a href="#面试题2：runloop和线程的关系" class="headerlink" title="面试题2：runloop和线程的关系"></a>面试题2：runloop和线程的关系</h3><ul>
<li><p>每个线程都有一个与之对应的runloop，所以 <code>runloop与线程是一一对应的</code>，其绑定关系通过一个 <code>全局的Dictionary存储</code>，线程为 <code>key</code>，runloop为 <code>value</code></p>
</li>
<li><p>线程中的runloop主要用来里线程的，当线程runloop开启后，会在执行完任务后进行休眠状态，当有事件触发唤醒时，又开始工作，即 <code>有活时干活，没活就休息</code>。</p>
</li>
<li><p><code>主线程</code> 的 <code>runloop</code> 是 <code>默认开启的</code>，在程序启动之后，会一直运行，不会退出</p>
</li>
<li><p>其他线程的 <code>runloop默认是不开启的</code>，如果需要，则手动开启</p>
</li>
</ul>
<h3 id="面试题3：NSRunLoop-和-CFRunLoopRef区别"><a href="#面试题3：NSRunLoop-和-CFRunLoopRef区别" class="headerlink" title="面试题3：NSRunLoop 和 CFRunLoopRef区别"></a>面试题3：NSRunLoop 和 CFRunLoopRef区别</h3><ul>
<li><p><code>NSRunLoop</code> 是 <code>基于CFRunLoopRef</code> 面向对象的 <code>API</code>，是 <code>不安全</code> 的。</p>
</li>
<li><p><code>CFRunLoopRef</code> 是 <code>基于C</code> 语言的，是 <code>线程安全</code> 的</p>
</li>
</ul>
<h3 id="面试题4：RunLoop的mode作用是什么？"><a href="#面试题4：RunLoop的mode作用是什么？" class="headerlink" title="面试题4：RunLoop的mode作用是什么？"></a>面试题4：RunLoop的mode作用是什么？</h3><p>mode 主要是用于指定runloop中事件优先级的</p>
<h3 id="面试题5：以-scheduledTimerWithTimeInterval-的方式触发的timer，在滑动页面上的利润表时，timer会暂停回调，为什么？如何解决？"><a href="#面试题5：以-scheduledTimerWithTimeInterval-的方式触发的timer，在滑动页面上的利润表时，timer会暂停回调，为什么？如何解决？" class="headerlink" title="面试题5：以 +scheduledTimerWithTimeInterval: 的方式触发的timer，在滑动页面上的利润表时，timer会暂停回调，为什么？如何解决？"></a>面试题5：以 +scheduledTimerWithTimeInterval: 的方式触发的timer，在滑动页面上的利润表时，timer会暂停回调，为什么？如何解决？</h3><ul>
<li><p>timer停止的原因是因为滑动 <code>scrollView</code> 时，主线程的runloop会从 <code>NSDefaultRunLoopMode</code> 切换到 <code>NSTrackingRunLoopMode</code> ，而 <code>timer</code> 是添加在 <code>NSDefaultRunLoopMode</code> 上的，所以timer不会执行</p>
</li>
<li><p>将 <code>timer</code> 放入 <code>NSRunLoopCommonModes</code> 中执行</p>
</li>
</ul>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：OC底层原理37：内存管理（三）AutoReleasePool &amp; NSRunLoop 底层分析</li>
        <li>Post author：张建</li>
        <li>Create time：2021-06-02 14:48:31</li>
        <li>
            Post link：https://redefine.ohevan.com/2021/06/02/OC底层原理/OC底层原理37：内存管理（三）AutoReleasePool-NSRunLoop-底层分析/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/BboyZJ.github.io/tags/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/">#OC-底层原理探索篇</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/BboyZJ.github.io/2021/06/09/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8638%EF%BC%9A%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">OC底层原理38：界面优化方案</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/BboyZJ.github.io/2021/05/29/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8636%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BC%B7%E5%BC%95%E7%94%A8%E5%88%86%E6%9E%90/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">OC底层原理36：内存管理（二）強引用分析</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">OC底层原理37：内存管理（三）AutoReleasePool &amp; NSRunLoop 底层分析</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AutoReleasePool-%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0"><span class="nav-text">AutoReleasePool 自动释放池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#clang%E5%88%86%E6%9E%90"><span class="nav-text">clang分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90"><span class="nav-text">汇编分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90"><span class="nav-text">底层分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AutoreleasePoolPage"><span class="nav-text">AutoreleasePoolPage</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#objc-autoreleasePoolPush-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">objc_autoreleasePoolPush 源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%A1%B5-autoreleaseNewPage"><span class="nav-text">创建页 autoreleaseNewPage</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-text">查看自动释放池内存结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%93%A8%E5%85%B5%E5%9C%A8%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E6%9C%89%E5%87%A0%E4%B8%AA"><span class="nav-text">面试题：哨兵在一个自动释放池有几个</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%8B%E6%A0%88%E5%AF%B9%E8%B1%A1-autoreleaseFast"><span class="nav-text">压栈对象 autoreleaseFast</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#autoreleaseFullPage-%E6%96%B9%E6%B3%95"><span class="nav-text">autoreleaseFullPage 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#add%E6%96%B9%E6%B3%95"><span class="nav-text">add方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#autorelease%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90"><span class="nav-text">autorelease底层分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#objc-autoreleasePoolPop-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">objc_autoreleasePoolPop 源码分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Runloop"><span class="nav-text">Runloop</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Runloop%E4%BB%8B%E7%BB%8D"><span class="nav-text">Runloop介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runloop%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">Runloop的作用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Runloop%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">Runloop源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Runloop%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">Runloop和线程的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runloop%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">Runloop的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mode%E7%B1%BB%E5%9E%8B"><span class="nav-text">Mode类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Source-amp-Timer-amp-Observer"><span class="nav-text">Source &amp; Timer &amp; Observer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%EF%BC%9Arunloop%E5%92%8Cmode%E6%98%AF%E4%B8%80%E5%AF%B9%E5%A4%9A"><span class="nav-text">验证：runloop和mode是一对多</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%EF%BC%9Amode%E5%92%8Citem%E4%B9%9F%E6%98%AF%E4%B8%80%E5%AF%B9%E5%A4%9A"><span class="nav-text">验证：mode和item也是一对多</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop%E6%89%A7%E8%A1%8C"><span class="nav-text">RunLoop执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#timer%E6%89%A7%E8%A1%8C%E6%80%BB%E7%BB%93"><span class="nav-text">timer执行总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop%E5%BA%95%E5%B1%82%E7%AE%A1%E7%90%86"><span class="nav-text">RunLoop底层管理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">相关面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AutoreleasePool%E7%9B%B8%E5%85%B3"><span class="nav-text">AutoreleasePool相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%981%EF%BC%9A%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8A%E6%94%BE"><span class="nav-text">面试题1：临时变量什么时候释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%982%EF%BC%9AAutoreleasePool%E5%8E%9F%E7%90%86"><span class="nav-text">面试题2：AutoreleasePool原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%983%EF%BC%9AautoreleasePool%E8%83%BD%E5%90%A6%E5%B5%8C%E5%A5%97%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-text">面试题3：autoreleasePool能否嵌套使用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%984%EF%BC%9A%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%8A%A0%E5%85%A5autoreleasePool%EF%BC%9Falloc%E5%88%9B%E5%BB%BA%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F"><span class="nav-text">面试题4：哪些对象可以加入autoreleasePool？alloc创建可以吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%985%EF%BC%9AautoreleasePool%E7%9A%84%E9%87%8A%E6%94%BE%E5%AE%9E%E9%99%85%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%EF%BC%9F"><span class="nav-text">面试题5：autoreleasePool的释放实际是什么时候？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%986%EF%BC%9Athread%E5%92%8CautoreleasePool%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-text">面试题6：thread和autoreleasePool的关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%987%EF%BC%9Arunloop%E5%92%8Cautorelease%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">面试题7：runloop和autorelease的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop%E7%9B%B8%E5%85%B3"><span class="nav-text">RunLoop相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%981%EF%BC%9A%E5%BD%93%E5%89%8D%E6%9C%89%E4%B8%AA%E5%AD%90%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%9C%89%E4%B8%AAtimer%EF%BC%8Ctimer%E6%98%AF%E5%90%A6%E8%83%BD%E5%A4%9F%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%B9%B6%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E5%A4%A7%E6%89%93%E5%8D%B0%EF%BC%9F"><span class="nav-text">面试题1：当前有个子线程，子线程中有个timer，timer是否能够执行，并进行持续大打印？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%982%EF%BC%9Arunloop%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">面试题2：runloop和线程的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%983%EF%BC%9ANSRunLoop-%E5%92%8C-CFRunLoopRef%E5%8C%BA%E5%88%AB"><span class="nav-text">面试题3：NSRunLoop 和 CFRunLoopRef区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%984%EF%BC%9ARunLoop%E7%9A%84mode%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">面试题4：RunLoop的mode作用是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%985%EF%BC%9A%E4%BB%A5-scheduledTimerWithTimeInterval-%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A6%E5%8F%91%E7%9A%84timer%EF%BC%8C%E5%9C%A8%E6%BB%91%E5%8A%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E5%88%A9%E6%B6%A6%E8%A1%A8%E6%97%B6%EF%BC%8Ctimer%E4%BC%9A%E6%9A%82%E5%81%9C%E5%9B%9E%E8%B0%83%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-text">面试题5：以 +scheduledTimerWithTimeInterval: 的方式触发的timer，在滑动页面上的利润表时，timer会暂停回调，为什么？如何解决？</span></a></li></ol></li></ol></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2019</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">张建</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        VISITOR COUNT&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        TOTAL PAGE VIEWS&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a></span>
                <br> 
            <span class="theme-version-container">THEME&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v1.1.5</a>
        </div>
        
        
        
            <div id="start_time_div" style="display:none">
                2019/8/17 11:45:14
            </div>
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="unfolded-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="fa-regular fa-arrow-up"></i>
            </li>
        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="folded-tools-list">
        <li class="right-bottom-tools tool-toggle-show flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>




<script src="/BboyZJ.github.io/js/utils.js"></script>

<script src="/BboyZJ.github.io/js/main.js"></script>

<script src="/BboyZJ.github.io/js/layouts/menu-shrink.js"></script>

<script src="/BboyZJ.github.io/js/tools/go-top-bottom.js"></script>

<script src="/BboyZJ.github.io/js/tools/dark-light-toggle.js"></script>



    
<script src="/BboyZJ.github.io/js/tools/local-search.js"></script>




    
<script src="/BboyZJ.github.io/js/tools/code-block.js"></script>




    
<script src="/BboyZJ.github.io/js/layouts/lazyload.js"></script>




    
<script src="/BboyZJ.github.io/js/tools/runtime.js"></script>

    
<script src="/BboyZJ.github.io/js/layouts/odometer.min.js"></script>

    
<link rel="stylesheet" href="/BboyZJ.github.io/assets/odometer-theme-minimal.css">





<div class="post-scripts pjax">
    
        
<script src="/BboyZJ.github.io/js/tools/toc-toggle.js"></script>

<script src="/BboyZJ.github.io/js/libs/anime.min.js"></script>

<script src="/BboyZJ.github.io/js/layouts/toc.js"></script>

<script src="/BboyZJ.github.io/js/plugins/tabs.js"></script>

    
    
</div>


    
<script src="/BboyZJ.github.io/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>




<script src="/BboyZJ.github.io/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
