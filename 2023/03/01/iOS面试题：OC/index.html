<!DOCTYPE HTML>
<html lang="en">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="张建的博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.3.0">
    <meta name="root" content="/BboyZJ.github.io/">
    <link rel="dns-prefetch" href="https://www.bboyzj.cn">
    <!--SEO-->

<meta name="keywords" content="OC-面试题" />


<meta name="description" content="OC算法1. 冒泡排序1）依次比较相邻两个元素，顺序错误则交换位置；需要两层循环，外层循环控制趟数，内层循环控制比较次数
2）例子：
123456789101112NSMutableArray ..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    iOS面试题：OC |
    
    张建的博客
</title>

<link rel="alternate" href="/atom.xml" title="张建的博客" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    


<link rel="stylesheet" href="/BboyZJ.github.io/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/BboyZJ.github.io/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/BboyZJ.github.io/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<meta name="generator" content="Hexo 6.3.0"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    https://hexo-theme-snippet-1251680922.cos.ap-beijing.myqcloud.com/img/banner.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='小J'>
            <img src="/BboyZJ.github.io/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <img src="/BboyZJ.github.io/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="https://www.bboyzj.cn">
                        张建的博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                Home</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/OC/"><i class="fa "></i>
                                OC</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/Swift/"><i class="fa "></i>
                                Swift</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/Blog/"><i class="fa "></i>
                                Blog</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/Flutter/"><i class="fa "></i>
                                Flutter</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa "></i>
                                时间轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="iOS面试题：OC">
            
            iOS面试题：OC
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/BboyZJ.github.io/categories/OC/">OC</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-none-link" href="/BboyZJ.github.io/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">OC-面试题</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2023/03/01</span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <h1 id="OC算法"><a href="#OC算法" class="headerlink" title="OC算法"></a>OC算法</h1><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><p>1）依次比较相邻两个元素，顺序错误则交换位置；需要两层循环，外层循环控制趟数，内层循环控制比较次数</p>
<p>2）例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;5&quot;,@&quot;4&quot;]];</span><br><span class="line">    // 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">    for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序</span><br><span class="line">        for (int j = 0; j &lt; arr.count - i - 1; j++) &#123;</span><br><span class="line">            // 相邻元素比较，若逆序则交换</span><br><span class="line">            if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123;</span><br><span class="line">                [arr exchangeObjectAtIndex:j withObjectAtIndex:j + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h2><p>1）从第一个元素与其他元素比较找到最小值，重复操作，直到最后一位结束；需要两层循环，外层循环趟数，里层循环比较次数</p>
<p>2）例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithObjects:@&quot;2&quot;,@&quot;1&quot;,@&quot;5&quot;,@&quot;3&quot;, nil];</span><br><span class="line">// 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">    // 里循环获比较换位</span><br><span class="line">    for (int j = i + 1; j &lt; arr.count; j ++) &#123;</span><br><span class="line">        if ([arr[i] intValue] &gt; [arr[j] intValue]) &#123;</span><br><span class="line">            [arr exchangeObjectAtIndex:i withObjectAtIndex:j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;arr:%@&quot;,arr);</span><br></pre></td></tr></table></figure>

<h2 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3. 直接插入排序"></a>3. 直接插入排序</h2><p>1） 始终定义第一个元素为 <code>已排序</code> 的，将剩余元素定义为 <code>未排序</code> 逐个插入到 <code>已排序</code> 的排列中；不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去</p>
<p>2）例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = @[@2,@1,@3,@5,@4].mutableCopy;</span><br><span class="line">// 插入排序的原理：始终定义第一个元素为有序的，将元素逐个插入到有序的排列中</span><br><span class="line">// 其特点是：不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去</span><br><span class="line">for(int i = 0;i &lt; arr.count;i++)&#123;</span><br><span class="line">    // 待排序值</span><br><span class="line">    NSNumber * temp = arr[i];</span><br><span class="line">    // 已排序下标</span><br><span class="line">    int j = i - 1;</span><br><span class="line">    // 待排序与已排序比较，从后向前比较</span><br><span class="line">    while (j &gt;= 0 &amp;&amp; [arr[j] integerValue] &gt; [temp integerValue]) &#123;</span><br><span class="line">        // 如果已排序的 &gt; 待排序的 往后移动一个位置</span><br><span class="line">        [arr replaceObjectAtIndex:(j + 1) withObject:arr[j]];</span><br><span class="line">        j --;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 空出来的位置插入新元素</span><br><span class="line">    [arr replaceObjectAtIndex:(j + 1) withObject:temp];</span><br><span class="line">    NSLog(@&quot;arr:%@&quot;,arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:26:19.242271+0800 插入排序[4184:77845] arr:(</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><p>1）希尔排序相当于 <code>直接插入排序加强版</code>，引入了 <code>增量</code> 的概念；直到增量为 <code>1</code> 时，再进行直接插入排序</p>
<p>2）例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = @[@7,@3,@8,@5,@2,@6,@1,@4].mutableCopy;</span><br><span class="line">// 其实间隔值设值为总数的一半</span><br><span class="line">int gap = arr.count/2;</span><br><span class="line">// 直到间隔小于1时结束</span><br><span class="line">while (gap &gt;= 1) &#123;</span><br><span class="line">    // i 待排元素，以 步距 gap 从后向前扫描</span><br><span class="line">    for(int i = 0;i &lt; arr.count;i++)&#123;</span><br><span class="line">        // 待排元素</span><br><span class="line">        NSNumber * temp = arr[i];</span><br><span class="line">        // 当前位置</span><br><span class="line">        int j = i;</span><br><span class="line">        // 跳跃式比较</span><br><span class="line">        while (j &gt;= gap &amp;&amp; [arr[j - gap] integerValue] &gt; [temp integerValue] ) &#123;</span><br><span class="line">            [arr replaceObjectAtIndex:j withObject:arr[j - gap]];</span><br><span class="line">            j -= gap;</span><br><span class="line">        &#125;</span><br><span class="line">        // 空出来位置，插入待排序</span><br><span class="line">        [arr replaceObjectAtIndex:j withObject:temp];</span><br><span class="line">    &#125;</span><br><span class="line">    // 改变步长</span><br><span class="line">    gap = gap/2;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;arr:%@&quot;,arr);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:22:41.910840+0800 插入排序[4124:74568] arr:(</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5,</span><br><span class="line">    6,</span><br><span class="line">    7,</span><br><span class="line">    8</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="5-斐波那契数列"><a href="#5-斐波那契数列" class="headerlink" title="5. 斐波那契数列"></a>5. 斐波那契数列</h2><p>1）也就是 <code>兔子数列</code>，当前数是前两个数列之和</p>
<p>2）例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    NSInteger num = 10;</span><br><span class="line">    NSInteger total = [self getTotalNum:num];</span><br><span class="line">    NSLog(@&quot;total:%ld&quot;,total);</span><br><span class="line">&#125;</span><br><span class="line">- (NSInteger)getTotalNum:(NSInteger)num&#123;</span><br><span class="line">    if(num == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(num == 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return [self getTotalNum:num-2] + [self getTotalNum:num-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:28:32.672554+0800 斐波那契数列[4285:80606] total:89</span><br></pre></td></tr></table></figure>

<h2 id="6-二分查找"><a href="#6-二分查找" class="headerlink" title="6. 二分查找"></a>6. 二分查找</h2><p>1）<code>有序的数组</code>，将数组分割成两份，利用查找的值跟中间值进行比较，如果查找的值大于中间值，就在数组的右边进行查找；如果查找的值小于中间值，就在数组的左边进行查找。如此循环的执行下去，最终找到符合的值。</p>
<p>2）例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NSArray * arr = @[@(1),@(3),@(5),@(6),@(8),@(10)];</span><br><span class="line">int key = [@(5) intValue];</span><br><span class="line">int min = 0;</span><br><span class="line">int max = arr.count - 1;</span><br><span class="line">int mid;</span><br><span class="line">while (min &lt;= max) &#123;</span><br><span class="line">    // 计算中间下标</span><br><span class="line">    mid = (min + max) / 2;</span><br><span class="line">    // 如果目标值 &gt; 中间下标的中间值</span><br><span class="line">    if (key &gt; [arr[mid] intValue]) &#123;</span><br><span class="line">        //最小变为中间下标+1</span><br><span class="line">        min = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果目标值 &lt; 中间下标的中间值</span><br><span class="line">    else if (key &lt; [arr[mid] intValue])&#123;</span><br><span class="line">        //最大变为中间下标-1</span><br><span class="line">        max = max - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 否则，正好</span><br><span class="line">    else &#123;</span><br><span class="line">        NSLog(@&quot;key:%d&quot;,mid);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:33:18.661324+0800 二分查找[4607:86953] key:2</span><br></pre></td></tr></table></figure>

<h2 id="7-递归算法"><a href="#7-递归算法" class="headerlink" title="7. 递归算法"></a>7. 递归算法</h2><p>递归求和1+2+..+n?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    int sum = [self sum:4];</span><br><span class="line">    NSLog(@&quot;sum:%d&quot;,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)sum:(int)n&#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return [self sum:n-1] + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><a href="http://www.bboyzj.cn/2020/08/09/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8E%A2%E7%B4%A2/">OC数据结构01：链表的探索</a></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p><a href="http://www.bboyzj.cn/2020/08/26/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%A2%E7%B4%A2/">OC数据结构02：二叉树探索</a></p>
<h1 id="OC常见的面试题"><a href="#OC常见的面试题" class="headerlink" title="OC常见的面试题"></a>OC常见的面试题</h1><h2 id="什么是野指针？"><a href="#什么是野指针？" class="headerlink" title="什么是野指针？"></a>什么是野指针？</h2><p>是一个没有指向 <code>任何内存</code> 的 <code>指针</code>，尝试使用它会导致 <code>应用程序崩溃</code></p>
<h2 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h2><p>一个 <code>对象</code> 没有被释放，会 <code>内存泄漏</code>，内存泄漏会导致应用程序占用的内存会越来越大，直到应用程序无内存可用时，会导致 <code>应用程序崩溃</code></p>
<h2 id="iOS-关键词有哪些？各有什么作用？-重点"><a href="#iOS-关键词有哪些？各有什么作用？-重点" class="headerlink" title="iOS 关键词有哪些？各有什么作用？ 重点"></a>iOS 关键词有哪些？各有什么作用？ <strong>重点</strong></h2><ul>
<li>readwrite</li>
</ul>
<p><code>可读可写</code> 特性，同时生成get方法和set方法的声明和实现</p>
<ul>
<li>readonly</li>
</ul>
<p><code>只读</code> 特性，只会生成get方法的声明和实现，不希望属性在类外改变</p>
<ul>
<li>retain</li>
</ul>
<p><code>持有</code> 特性，retaincount 会 +1,用于 <code>MRC</code></p>
<ul>
<li>nonatomic</li>
</ul>
<p><code>非原子</code> 特性</p>
<ul>
<li>atomic</li>
</ul>
<p><code>原子</code> 特性，默认属性</p>
<p>atomic不是绝对线程安全的，只是对 <code>setter/getter</code> 方法使用了 <code>自旋锁(spinlock_t)</code>，内部使用 <code>互斥锁(os_unfair_lock)</code>，保证了 <code>读/写</code> 安全。</p>
<p>atomic并不能保证 <code>整个对象</code> 是线程安全的，需要对 <code>整个对象</code> 进行 <code>加锁</code> 来保证线程安全：</p>
<pre><code>*  NSLock（互斥锁）
*  dispathch_semaphore（信号量）
*  @synchronized（互斥递归锁）
</code></pre>
<ul>
<li>assign</li>
</ul>
<p>可以修饰 <code>基本数据类型和对象</code>。</p>
<p>通常用于修饰 <code>基本数据类型</code>，如Int、CGFloat、Double等，这是因为 <code>基本数据类型放在栈区</code>，栈由编译器自动分配和释放内存，栈先进后出，基本数据类型出栈后，assign修饰的基本数据类型就不存在了，不会出现 <code>野指针</code></p>
<p>修饰对象，如NSString、实例对象等，引用计数不会增加，但 <code>assign</code> 修饰对象释放后，<code>指针</code> 不会被系统置为nil，会产生 <code>野指针</code> 或 <code>EXC_BAD_ACCESS</code> 错误。</p>
<ul>
<li>strong</li>
</ul>
<p>强引用，<code>只修饰对象</code>，属性默认修饰符</p>
<p><code>指向并持有该对象</code>，其修饰的对象引用计数会 <code>+1</code>，引用计数不为 <code>0</code> 则不会被销毁，需要将其置为 <code>nil</code> 可以销毁。否则会出现 <code>内存泄漏</code>。</p>
<ul>
<li>weak</li>
</ul>
<p>弱引用，<code>只修饰对象</code>。</p>
<p><code>指向但并不拥有该对象</code>，引用计数不增加。该对象自动在内存中销毁。</p>
<ul>
<li>copy</li>
</ul>
<p>用于修饰 <code>不可变的对象</code>。</p>
<p>比如NSString、NSDictionary、NSArray等。</p>
<h2 id="浅拷贝和深拷贝-重点"><a href="#浅拷贝和深拷贝-重点" class="headerlink" title="浅拷贝和深拷贝 重点"></a>浅拷贝和深拷贝 <strong>重点</strong></h2><ul>
<li>浅拷贝</li>
</ul>
<p>浅拷贝，拷贝了一个新的指针，与原对象指针指向同一块内存，<code>引用计数 + 1</code>；(A,CopyA &#x3D; [A copy]，A 变化，CopyA 的值也变化)</p>
<ul>
<li>深拷贝</li>
</ul>
<p>深拷贝，拷贝了一个新的对象，指向新的内存，新对象的 <code>引用计数为 1</code>，源对象引用计数不变；(A,MutableA &#x3D; [A mutbleCopy]，A 变化，MutableA 的值不变)。</p>
<h2 id="NSString-x2F-NSArray-x2F-NSDictionary和NSMutableString-x2F-NSMutableArray-x2F-NSMutableDictionary-进行copy和mutableCopy区别？重点"><a href="#NSString-x2F-NSArray-x2F-NSDictionary和NSMutableString-x2F-NSMutableArray-x2F-NSMutableDictionary-进行copy和mutableCopy区别？重点" class="headerlink" title="NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？重点"></a>NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？<strong>重点</strong></h2><ul>
<li><p>对于不可变NSString&#x2F;NSArray&#x2F;NSDictionary，copy浅拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝)</p>
</li>
<li><p>对于可变NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary，copy深拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝)</p>
</li>
</ul>
<h2 id="自定义对象的copy和mutableCopy？-重点"><a href="#自定义对象的copy和mutableCopy？-重点" class="headerlink" title="自定义对象的copy和mutableCopy？ 重点"></a>自定义对象的copy和mutableCopy？ <strong>重点</strong></h2><ul>
<li>copy和mutableCopy都是深拷贝(属性：浅拷贝）</li>
</ul>
<h1 id="属性用copy还是strong？-重点"><a href="#属性用copy还是strong？-重点" class="headerlink" title="属性用copy还是strong？ 重点"></a>属性用copy还是strong？ <strong>重点</strong></h1><ul>
<li><p>对于不可变属性，推荐用copy，目的是为了 <code>让本属性不受外界影响</code>，无论给我传入可变还是不可变对象，我本身持有的就是一个不可变的副本，被set时，改变的是这个副本。</p>
</li>
<li><p>对于可变属性，推荐用strong，因为copy修饰后，会变成不可变对象，再调用可变对象函数时会 crash</p>
</li>
</ul>
<h2 id="一个APP是如何唤醒另一个APP的？-重点"><a href="#一个APP是如何唤醒另一个APP的？-重点" class="headerlink" title="一个APP是如何唤醒另一个APP的？ 重点"></a>一个APP是如何唤醒另一个APP的？ <strong>重点</strong></h2><p>URL Scheme：iOS有一个特性就是将 <code>自身绑定</code> 到一个自定义的 <code>URL Scheme</code> 上，该 <code>scheme</code> 用于从 <code>浏览器或其他应用中启动本应用</code>。</p>
<h2 id="单例的写法和作用？-重点"><a href="#单例的写法和作用？-重点" class="headerlink" title="单例的写法和作用？ 重点"></a>单例的写法和作用？ <strong>重点</strong></h2><p>单例模式的作用：可以保证程序运行过程中，一个类只返回一个实例，供外界访问；static保证类只分配一次内存；dispatch_once方法保证调用一次，并自动加锁，线程安全</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static id _instance = nil; // 定义static全局变量，保证只分配一次内存</span><br><span class="line">+ (id)shareInstance&#123;</span><br><span class="line">    return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">+ (id)copyWithZone:(struct _NSZone *)zone&#123;</span><br><span class="line">    static dispatch_once_t onceToken; // 声明一个静态的GcD单次任务</span><br><span class="line">    // 保证只执行一次</span><br><span class="line">    dispatch_once(&amp;onceToken,^&#123; // </span><br><span class="line">        _instance = [super allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">这么写可以保证下面两种方式返回同一个实例</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Single * p1 &#x3D; [Single shareInstance];<br>Single * p2 &#x3D; [[Single alloc] init];<br>NSLog(@”%d”,p1&#x3D;&#x3D;p2); &#x2F;&#x2F; 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## HTTPS和HTTP的区别？ **重点**</span><br><span class="line"></span><br><span class="line">* HTTP：超文本传输协议，信息明文传输；端口号80；响应速度快（使用TCP三次握手，客户端和服务端需要交换3个包）；</span><br><span class="line"></span><br><span class="line">* HTTPS：是由 HTTP+SSL/TLS 加密传输；端口号443；响应速度慢（除了使用TCP三个包，还要加上SSL握手的9个包）；需要到CA申请证书</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## TCP 和 UDP 区别? **重点**</span><br><span class="line"></span><br><span class="line">* 都是 `传输层` 协议</span><br><span class="line"></span><br><span class="line">* TCP协议是 `面向连接的可靠的传输层协议`。UDP协议是 `面向非连接的传输层协议`</span><br><span class="line"></span><br><span class="line">* TCP需要 `建立连接和断开连接`。UDP不需要连接。</span><br><span class="line"></span><br><span class="line">* TCP传 `输数据没有大小限制`。UDP `传输数据有大小限制`。</span><br><span class="line"></span><br><span class="line">* TCP会 `处理数据丢包重发`。UDP不会处理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># HTTP和socket区别？ **重点**</span><br><span class="line"></span><br><span class="line">* `HTTP` 应用层协议；`socket` 不属于协议范畴，而是一个接口（API），是对TCP/IP协议的封装</span><br><span class="line">* `HTTP` 是基于 `请求-响应` 形式 `短连接`，即客户端发送一次请求，服务端响应后立即 `断开连接`；socket 是基于TCP协议的 `长链接`，理论上 客户端和服务端一旦建立连接将不会主动断开</span><br><span class="line">* HTTP 传输慢，数据量大，安全差；socket 数据可自定义，数据量小，安全性高，适合信息实时交互（推送、聊天等）</span><br><span class="line"></span><br><span class="line">## staitc 和 const 的区别？ **重点**</span><br><span class="line"></span><br><span class="line">* const：表示 `只读` 的意思</span><br><span class="line"></span><br><span class="line">    * `const` 放在 `类型` 前：可以改变指针的指向，可以改变指针指向的内容</span><br><span class="line">    </span><br><span class="line">    * `const` 放在 `变量` 前：不可以改变指针的指向，不可以改变指针指向的内容</span><br><span class="line"></span><br><span class="line">* static： `静态变量`，可修饰 `局部变量和全局变量`，可修饰方法</span><br><span class="line"></span><br><span class="line">    * `static` 可修饰 `局部/全局变量`，称为 `局部静态变量和全局静态变量`，只初始化一次，只分配一次内存，生命周期被改变，不再是作用域内</span><br><span class="line"></span><br><span class="line">    * `static` 修饰的 `方法`，可以在不同文件下重名，互不影响运行</span><br><span class="line"></span><br><span class="line">## 通用链接（Universal Links）**重点**</span><br><span class="line"></span><br><span class="line">* 服务端配置 `HTTPS` 证书 和添加 `apple-app-site-association` 地址关联文件</span><br><span class="line"></span><br><span class="line">* 移动端在plist添加 `Associated Domains` 关联域权限</span><br><span class="line"></span><br><span class="line">## 简述GET和POST请求的区别？ **重点**</span><br><span class="line"></span><br><span class="line">* GET 传输数据 `有缓存`；POST 传输数据 `没有缓存`</span><br><span class="line"></span><br><span class="line">* GET的 `参数` 放在 `URL` 的后面，并且第一个参数用 `?` 号拼接，后面的从第二个参数开始，直到最后一个，用 `&amp;` 分割；POST的 `参数` 放在 `请求体` 里面，并且第一个参数用 `,` 号拼接，后面从第二开始，直到最后用 `&amp;` 分割;</span><br><span class="line"></span><br><span class="line">* GET一般用于 `获取数据`；POST一般用于 `向服务器提交数据`</span><br><span class="line"></span><br><span class="line">* `GET` 的参数是暴漏在 `地址栏` 的，不安全；`POST` 的参数隐藏在 `请求体` 里面，相对安全一点;</span><br><span class="line"></span><br><span class="line">* GET请求提交数据受浏览器限制 `1k`，POST请求理论上无限制。</span><br><span class="line"></span><br><span class="line">## iOS中几种常见的设计模式？  **重点**</span><br><span class="line"></span><br><span class="line">* `代理模式`</span><br><span class="line"></span><br><span class="line">一对一的依赖关系，当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。</span><br><span class="line"></span><br><span class="line">* `观察者模式`</span><br><span class="line"></span><br><span class="line">KVO机制 和 Notification通知机制</span><br><span class="line"></span><br><span class="line">* `单例模式`</span><br><span class="line"></span><br><span class="line">保证程序运行过程中，一个类只返回一个实例，供外界访问</span><br><span class="line"></span><br><span class="line">* `工厂模式`</span><br><span class="line"></span><br><span class="line">通过一个类方法，`根据已有模板批量生产对象`。</span><br><span class="line"></span><br><span class="line">* `MVC模式`</span><br><span class="line"></span><br><span class="line">Model即数据模型</span><br><span class="line"></span><br><span class="line">view即视图</span><br><span class="line"></span><br><span class="line">controller即控制器</span><br><span class="line"></span><br><span class="line">## RunLoop是什么？ **重点**</span><br><span class="line"></span><br><span class="line">* 概念 </span><br><span class="line"></span><br><span class="line">`RunLoop` 又叫 `运行循环`，内部就是一个 `do-while循环`，在这个循环内部不断 `处理各种任务，保证程序持续运行`。</span><br><span class="line"></span><br><span class="line">* 目的</span><br><span class="line"></span><br><span class="line">RunLoop存在的目的： 就是当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，`提高程序性能，节省CPU资源`，该做事的时候做事，该休息的时候休息</span><br><span class="line"></span><br><span class="line">## RunLoop的作用？ **重点**</span><br><span class="line"></span><br><span class="line">* `保持程序持续运行`。</span><br><span class="line">   App一启动就会开启主线程，主线程在开启的时候就会开启主线程对应的RunLoop，RunLoop能保证线程不被销毁，主线程不销毁，程序就会持续运行。</span><br><span class="line"></span><br><span class="line">* `处理App中各类事件`。</span><br><span class="line">   事件响应、手势识别、界面刷新、AutoreleasePool自动释放池、NSTimer等事件处理。</span><br><span class="line"></span><br><span class="line">* `节省CPU资源，提高程序性能`。</span><br><span class="line">   如概述所述，当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，提高程序性能，节省资源，该做事的时候做事，该休息的时候休息。</span><br><span class="line"></span><br><span class="line">## 可以用Runloop实现什么功能？ **重点**</span><br><span class="line"></span><br><span class="line">* tableView 滚动时图片不加载</span><br><span class="line"></span><br><span class="line">SDWebImage + Runloop，图片延迟加载,滑动不加载图片</span><br><span class="line"></span><br><span class="line">* 线程保活</span><br><span class="line"></span><br><span class="line">往 `runloop` 中添加 `[[NSPort alloc] init]` 事件，</span><br><span class="line"></span><br><span class="line">* 解决NSTimer在滑动时停止工作的问题</span><br><span class="line"></span><br><span class="line">`default` 模式改为 `common` 模式</span><br><span class="line"></span><br><span class="line">* 检测卡顿</span><br><span class="line"></span><br><span class="line">`displaylink + runloop 进行卡顿检测，将数值和页面绑定上传到服务器`</span><br><span class="line"></span><br><span class="line">## RunLoop接收几种输入源，系统默认定义了几种模式？ **重点**</span><br><span class="line"></span><br><span class="line">* 输入源有两种</span><br><span class="line">基于 `端口` 的输入源（port）</span><br><span class="line">`自定义` 的输入源（custom）</span><br><span class="line"></span><br><span class="line">* 系统定义的RunLoop模式有五种，最常用的有三种，如下所示：</span><br><span class="line">NSDefaultRunLoopMode</span><br><span class="line">默认模式，主线程中默认是NSDefaultRunLoopMode</span><br><span class="line">UITrackingRunLoopMode</span><br><span class="line">视图滚动模式，RunLoop会处于该模式下</span><br><span class="line">NSRunLoopCommonModes</span><br><span class="line">并不是真正意义上的Mode，是一个占位用的“Mode”，默认包含了NSDefaultRunLoopMode和UITrackingRunLoopMode两种模式</span><br><span class="line"></span><br><span class="line">## RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？ **重点**</span><br><span class="line"></span><br><span class="line">* 每一个线程都有一个runloop，主线程的runloop默认启动。子线程的runloop默认不启动</span><br><span class="line">* mode：主要用来指定事件在运行时循环的优先级</span><br><span class="line">* 作用：保持程序的持续运行、随时处理各种事件、节省cpu资源(没事件休息释放资源)，提高程序的性能。</span><br><span class="line"></span><br><span class="line">## 怎么理解Objective-C是动态运行时语言。 **重点**</span><br><span class="line"></span><br><span class="line">主要是 `将数据类型的确定和函数的调用由编译时推迟到了运行时`。这个问题其实浅涉及到两个概念，`运行时和多态`。</span><br><span class="line"></span><br><span class="line">* 运行时：简单来说，运行时机制使我们 `直到运行时才去确定数据类型和要调用的函数`。</span><br><span class="line"></span><br><span class="line">* 多态：`不同对象以自己的方式响应相同的消息的能力` 叫做多态。</span><br><span class="line"></span><br><span class="line">## runtime项目中具体应用？ **重点**</span><br><span class="line"></span><br><span class="line">* `方法交换`。</span><br><span class="line">* 给 `分类添加属性`。 </span><br><span class="line">* 动态添加方法。</span><br><span class="line">* 字典转模型。</span><br><span class="line">* 数组越界。</span><br><span class="line">* 动态获取成员属性、成员变量、实例方法</span><br><span class="line"></span><br><span class="line">## KVC是什么？**重点**</span><br><span class="line"></span><br><span class="line">`KVC` 全程 `Key Value Coding`，中文 `键值编码`，是由 `NSKeyValueCoding` 非正式协议启动的一种机制，`对象` 采用该协议来 `间接访问对象的属性`。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(nullable id)valueForKey:(NSString *)key;     </p>
</li>
<li><p>(nullable id)valueForKeyPath:(NSString *)keyPath; </p>
</li>
<li><p>(void)setValue:(nullable id)value forKey:(NSString *)key;</p>
</li>
<li><p>(void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[KVC底层原理：](http://www.bboyzj.cn/2021/01/17/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8622%EF%BC%9AKVC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/)</span><br><span class="line"></span><br><span class="line">## KVO是什么？**重点**</span><br><span class="line"></span><br><span class="line">`KVO` 全程 `Key Value Observing`，中文 `键值观察`，它 `用于监听实例对象属性的变化`。</span><br><span class="line"></span><br><span class="line">## KVO的实现原理？(KVO的本质是什么？) **重点**</span><br><span class="line"></span><br><span class="line">当一个 `实例对象` 的 `属性注册了KVO`，实例对象 `isa指针` 的指向在注册KVO观察者之后，由 `原有类` 改为 `中间类(NSKVONotifing_类名)`；`中间类` 重写了 `属性setter方法、class、dealloc、_isKVOA` 方法；`dealloc` 方法中，移除 `KVO` 观察者之后，实例对象isa 指向由 `中间类` 更改为 `原有类`;中间类 从创建后就 `一直存在内存中`，不会被销毁。</span><br><span class="line"></span><br><span class="line">## KVO实际应用 **重点**</span><br><span class="line"></span><br><span class="line">* 观察 `实例对象` 的 `属性` 变化</span><br><span class="line"></span><br><span class="line">* 观察 `实例对象` 的 `容器` 变化</span><br><span class="line"></span><br><span class="line">   观察容器用： `mutableArrayValueForKey`</span><br><span class="line">   </span><br><span class="line">[KVO底层原理：](http://www.bboyzj.cn/2021/01/25/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8623%EF%BC%9AKVO%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/) </span><br><span class="line"></span><br><span class="line">## category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？**重点**</span><br><span class="line"></span><br><span class="line">* `category` 原则上它 `只能增加方法`，`不能增加成员（实例）变量`。可以添加属性，但是不会自动生成实例变量_name和setter和getter方法。可以添加方法</span><br><span class="line"></span><br><span class="line">* `扩展` 主要用来为一个类添加额外的原来没有的 `实例变量、方法和属性`。extension常用的形式并不是以一个单独的.h文件存在，而是寄生在类的.m文件中。</span><br><span class="line"></span><br><span class="line">类扩展中：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>@interface Person (){<br>  int age; &#x2F;&#x2F;实例变量<br>}<br>@property (nonatomic,copy)NSString * name;&#x2F;&#x2F;属性</p>
</li>
<li><p>(void)run;&#x2F;&#x2F;方法<br>@end</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## iOS开发中有多少类型的线程？  **重点**</span><br><span class="line"></span><br><span class="line">* pthread</span><br><span class="line"></span><br><span class="line">一套用于 `C` 的多线程 `API`、适用于 `Unix / Linux / Windows` 等系统、跨平台、可移植、使用难度大</span><br><span class="line"></span><br><span class="line">* NSThread</span><br><span class="line"></span><br><span class="line">使用更加面向对象、简单易用，可直接操作线程对象</span><br><span class="line"></span><br><span class="line">* GCD</span><br><span class="line"></span><br><span class="line">旨在替代NSThread等线程技术、充分利用设备的 `多核`、基于 `C` 的底层的 API</span><br><span class="line"></span><br><span class="line">* NSOperation</span><br><span class="line"></span><br><span class="line">`NSOperation` 是基于 `GCD` 之上的更高一层的封装， `NSOpetation` 需要配合 `NSOpetationQueue` 来实现多线程</span><br><span class="line"></span><br><span class="line">## 根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？  **重点**</span><br><span class="line"></span><br><span class="line">dispatch_group_t + dispatch_group_enter + dispatch_group_leave + dispatch_group_notify</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 10个网络请求顺序回调? GCD如何实现？**重点**</span><br><span class="line"></span><br><span class="line">dispatch_group_t + dispatch_semaphore_t：信号量（dispatch_semaphore_wait + dispatch_group_leave）</span><br><span class="line"></span><br><span class="line">## GCD和NSOperation的区别？ **重点**</span><br><span class="line"></span><br><span class="line">* `GCD执行效率更高`，而且由于队列中执行的是由block构成的任务，这是一个轻量级的数据结构，写起来更方便</span><br><span class="line">* GCD只支持FIFO的队列，而 `NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序`</span><br><span class="line">* NSOperationQueue甚至可以跨队列设置依赖关系，但是GCD只能通过设置串行队列，或者在队列内添加barrier(dispatch_barrier_async)任务，才能控制执行顺序,较为复杂</span><br><span class="line">* `NSOperationQueue因为面向对象`，所以 `支持KVO`，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished）、是否取消（isCanceld）</span><br><span class="line"></span><br><span class="line">具体的底层看 [OC底层原理27：GCD之 NSThread &amp; GCD &amp; NSOperation](http://www.bboyzj.cn/2021/03/23/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8627%EF%BC%9AGCD%E4%B9%8B%2520NSThread%2520&amp;%2520GCD%2520&amp;%2520NSOperation/)</span><br><span class="line"></span><br><span class="line">## 什么是Block？ **重点**</span><br><span class="line"></span><br><span class="line">`Block` 是将 `函数及其上下文封装起来的对象`</span><br><span class="line"></span><br><span class="line">## Block的本质 **重点**</span><br><span class="line"> </span><br><span class="line">* block 的 `本质` 是 `对象、函数、结构`体，由于block函数没有名称，也被称为 `匿名函数`</span><br><span class="line"></span><br><span class="line">## Block的分类？ **重点**</span><br><span class="line"></span><br><span class="line">* 分为 `全局Block(_NSConcreteGlobalBlock)、栈Block(_NSConcreteStackBlock)、堆Block(_NSConcreteMallocBlock)` 三种形式。</span><br><span class="line"></span><br><span class="line">* 其中 `栈Block存储在栈(stack)区`，`堆Block存储在堆(heap)区`，`全局Block存储在已初始化数据(.data)区`。</span><br><span class="line"></span><br><span class="line">    * 堆：动态分配内存，需要程序员自己申请，程序员自己管理</span><br><span class="line">    * 栈：自动分配内存，自动销毁，先入后出，栈上的内容存在自动销毁的情况</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">具体看底层原理 [OC底层原理30：Block底层原理](http://www.bboyzj.cn/2021/04/22/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8630%EF%BC%9ABlock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 循环引用的几种情况和解决方式？ **重点**</span><br><span class="line"></span><br><span class="line">* Block</span><br><span class="line"></span><br><span class="line">原因： `self` 强引用了 `block`，而 `block` 内部又调用了 `self`</span><br><span class="line">解决： 使用 `Weak-Strong Dance`</span><br><span class="line"></span><br><span class="line">* Delegate</span><br><span class="line"></span><br><span class="line">原因：委托者和被委托人之间的相互强引用问题 `strong`</span><br><span class="line">解决：用 `weak` 进行弱引用 `或者` 通过中间对象(代理对象)的方式来解决(效率更加高的中间对象NSProxy：不需要进行发送消息和动态解析，直接进行消息转发)</span><br><span class="line"></span><br><span class="line">* NSTimer</span><br><span class="line"></span><br><span class="line">原因：self → timer → self(target) 的循环持有链</span><br><span class="line">解决：在适当的时机销毁 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>[_timer invalidate];<br>_timer &#x3D; nil;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># OC 如何进行内存管理的？ **重点**</span><br><span class="line"></span><br><span class="line">* 手动内存管理 MRC</span><br><span class="line"></span><br><span class="line">* 自动内存管理 ARC</span><br><span class="line">    </span><br><span class="line">    LLVM + Runtime 会为我们代码自动插入 retain 和 release 以及 autorelease等代码,不需要我们手动管理</span><br><span class="line">    </span><br><span class="line">* 自动释放池</span><br><span class="line"></span><br><span class="line"># 自动释放池原理 **重点**</span><br><span class="line"></span><br><span class="line">* 自动释放池的本质是 `__AtAutoreleasePool` 结构体，包含构造函数和析构函数</span><br><span class="line"></span><br><span class="line">* 结构体声明，触发构造函数，调用 `objc_autoreleasePoolPush()` 函数，对象压栈</span><br><span class="line"></span><br><span class="line">* 结构体出作用域，触发析构函数，调用 `objc_autoreleasePoolPop()` 函数，对象出栈</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 内存优化 **重点**</span><br><span class="line"></span><br><span class="line">* cell复用</span><br><span class="line">* 绘制的话：用CAShaperLayer，渲染快，内存使用高效</span><br><span class="line">* 按需加载：懒加载</span><br><span class="line">* 合理利用缓存：比如三方图片压缩缓存</span><br><span class="line">* 尽量使用透明View：控件有背景色增大内存消耗</span><br><span class="line"></span><br><span class="line"># 启动优化 **重点**</span><br><span class="line"></span><br><span class="line">* pre-main 阶段：`二进制重排`</span><br><span class="line"></span><br><span class="line">    * 尽量 `少用外部动态库`，苹果官方建议自定义的动态库最好 `不要超过6个`，如果超过6个，需要 `合并` 动态库</span><br><span class="line"></span><br><span class="line">    * 减少 `OC` 类，因为类越多，越耗时</span><br><span class="line"></span><br><span class="line">    * 将不必须在 `+load` 方法中做的事情延迟到 `+initialize` 中，尽量不要用 `C++` 虚函数</span><br><span class="line"></span><br><span class="line">* main 阶段：mian -&gt; didFinishLaunching</span><br><span class="line"></span><br><span class="line">    * 减少启动初始化的流程，`能懒加载的懒加载，能延迟的延迟，能放后台初始化的放后台`，尽量少占用主线程的启动时间</span><br><span class="line"></span><br><span class="line">    * 优化代码逻辑，去除非必须的代码逻辑，减少每个流程的消耗时间</span><br><span class="line"></span><br><span class="line">    * 启动阶段能 `使用多线程` 来初始化的，就使用多线程</span><br><span class="line"></span><br><span class="line">    * 尽量 `使用纯代码` 来进行UI框架的搭建，尤其是主UI框架，例如 UITabBarController，尽量避免使用Xib或者SB，相比纯代码而言，这种更耗时</span><br><span class="line"></span><br><span class="line">    * 删除废弃类、方法</span><br><span class="line"> </span><br><span class="line">## 卡顿监听 **重点**</span><br><span class="line"></span><br><span class="line">**主要是用displayLink + Runloop进行FPS监测**</span><br><span class="line"></span><br><span class="line">主要从减轻 `CPU` 和 `GPU` 消耗入手，保证写一个 `VSync` 到来时，`CPU` 和 `GPU` 能够写作完成下一帧的渲染并缓存到帧缓冲区</span><br><span class="line"></span><br><span class="line">* 卡顿优化在 `CPU` 层面：</span><br><span class="line"></span><br><span class="line">1）尽量用轻量级的对象，比如 `用不到事件处理` 的地方，可以考虑使用 `CALayer` 取代 `UIView`</span><br><span class="line">2）不要频繁地调用 `UIView` 的相关属性，比如 `frame、bounds、transform` 等属性，尽量减少不必要的修改</span><br><span class="line">3）尽量 `提前计算好布局`，在有需要时一次性调整对应的属性，不要多次修改属性</span><br><span class="line">4）图片的 `size` 最好刚好跟 `UIImageView` 的 `size` 保持一致</span><br><span class="line">5）`控制`一下线程的最大并发数量</span><br><span class="line">6）尽量把 `耗时的操作放到子线程`：如text宽高获取等</span><br><span class="line"></span><br><span class="line">* 卡顿优化在 GPU层面：</span><br><span class="line"></span><br><span class="line">1）GPU能处理的 `最大纹理` 尺寸是 `4096x4096`，一旦超过这个尺寸，就会占用 `CPU` 资源进行处理，所以纹理尽量不要超过这个尺寸</span><br><span class="line">2）尽量 `减少视图数量和层次`</span><br><span class="line">3）`减少透明的视图`（alpha&lt;1），不透明的就设置 `opaque` 为 `YES`</span><br><span class="line">4）尽量 `避免出现离屏渲染`：圆角、阴影、遮罩等</span><br><span class="line"> </span><br><span class="line">## 卡顿优化：tableView优化 **重点**</span><br><span class="line"></span><br><span class="line">* 最常用的就是`cell的复用`， 注册复用标识符</span><br><span class="line"></span><br><span class="line">* `避免cell的重新布局`，初始化时就布局好</span><br><span class="line"></span><br><span class="line">* `提前计算并缓存cell的高度`</span><br><span class="line"></span><br><span class="line">* `减少cell中控件的数量`，少动态添加 view</span><br><span class="line"></span><br><span class="line">* `避免背景透明`</span><br><span class="line"></span><br><span class="line">* 能`使用局部更新` 的就使用 `局部更新`</span><br><span class="line"></span><br><span class="line">* 加载网络数据，`下载图片，使用异步加载`，并缓存</span><br><span class="line"></span><br><span class="line">* `按需加载cell`：cell滚动很快时，只加载范围内的cell</span><br><span class="line"></span><br><span class="line">* `不要实现无用的代理方法`，tableView只遵守两个协议</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"># 网络优化 **重点**</span><br><span class="line"></span><br><span class="line">* DNS优化：即域名解析优化，缓存 ip</span><br><span class="line">* 资源优化：</span><br><span class="line">    * 图片webp，比png/jpg小</span><br><span class="line">    * 数据传输用ProtocolBuffer代替json，数据小，序列化和反序列化也简单</span><br><span class="line">* 请求压缩、请求合并</span><br><span class="line">* 数据缓存</span><br><span class="line">* 网络环境监测</span><br><span class="line">    * 针对性请求重试</span><br><span class="line"></span><br><span class="line">## TCP三次握手，四次挥手过程？**重点**</span><br><span class="line"></span><br><span class="line">1. 为什么是三次握手，而不是二次握手？</span><br><span class="line"></span><br><span class="line">三次握手是为了建立一个可靠的数据传输通道：</span><br><span class="line"></span><br><span class="line">* 刚开始客户端和服务端处于关闭状态，而且服务端B一直处于监听状态，时刻监听是否有建立连接的请求</span><br><span class="line"></span><br><span class="line">* 当客户端需要建立连接的时候就会发送一个 `请求连接` 的报文，此报文是 `同步报文SYN=1`，并且会生成一个 `随机的序号seq=x`，这是第一次握手</span><br><span class="line"></span><br><span class="line">* 当服务端接收到请求连接报文时，会发送一个 `确认连接` 的报文，此报文是 `同步报文SYN=1`，并且 `确认报文ACK=1`，同时服务端也会生成一个 `随机的序号seq=y`，并且将 `确认报文确认号ack=x+1`，回传给客户端，这是第二次握手</span><br><span class="line"></span><br><span class="line">* 当客户端接收到服务端的 `ACK确认报文后`，会回复一个 `ACK确认报文`，用于确认确认报文已经收到，此报文 `ACK=1，seq=x+1，ack=y+1`，这是第三次握手</span><br><span class="line"></span><br><span class="line">2. 四次挥手</span><br><span class="line"></span><br><span class="line">四次挥手则是为了保证数据传输完成接收再关闭连接。</span><br><span class="line"></span><br><span class="line">* 客户端断开连接时会发送一个 `请求断开连接` 的报文，此报文是 `FIN=1`，并且会生成一个 `随机的序号seq=u`，发送给服务端，这是第一次挥手</span><br><span class="line"></span><br><span class="line">* 服务端接收到请求断开连接 `FIN报文` 后，回复一个 `确认断开连接` 报文 `ACK=1,seq=v,ack=u+1`，这是第二次挥手</span><br><span class="line"></span><br><span class="line">* 当服务端数据发送完后，再发送一个FIN报文给客户端，通知客户端，服务端准备关闭连接，此报文 `FIN=1,ACK=1,ack=u+1,seq=w`，这是第三次挥手</span><br><span class="line"></span><br><span class="line">* 当客户端收到 `FIN确认报文`，再发送一个FIN确认报文 `ACK=1,seq=u+1,ack=w+1`，并进入` TIME-WAIT` 等待，等待 `2MSL` 后关闭连接，这是第四次挥手</span><br><span class="line"> </span><br><span class="line"># 事件链 **重点**</span><br><span class="line"></span><br><span class="line">[OC学习01：事件传递链和响应链](https://www.bboyzj.cn/2023/03/01/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/)</span><br><span class="line"></span><br><span class="line">* 传递链：由系统向离用户最近的view传递。</span><br><span class="line">  顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; ViewController -&gt; subViews</span><br><span class="line"></span><br><span class="line">* 响应链：由离用户最近的view向系统传递。</span><br><span class="line">  顺序： superViews –&gt; ViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate</span><br><span class="line"></span><br><span class="line"># 事件传递的两个核心方法？ **重点**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 返回最适合处理事件的视图</p>
</li>
<li><p>(nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;<br>&#x2F;&#x2F; 判断点是否在这个View内部</p>
</li>
<li><p>(BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 第一个方法返回的是一个 `UIView`，是用来寻找最终哪一个视图来响应这个事件</span><br><span class="line">* 第二个方法是用来判断某一个点击的位置是否在视图范围内，如果在就返回YES</span><br><span class="line"></span><br><span class="line"># 实现一个按钮的点击范围扩大效果 **重点**</span><br><span class="line"></span><br><span class="line">自定义一个按钮，继承UIButton，重写 `pointInside:withEvent:` 方法，</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{<br>  &#x2F;&#x2F; 当前btn大小<br>  CGRect btnBounds &#x3D; self.bounds;<br>  &#x2F;&#x2F; 扩大按钮的点击范围，增大内边距<br>  btnBounds &#x3D; CGRectInset(btnBounds, -10, -10);<br>  &#x2F;&#x2F; 若点击的点在新的bounds里，返回YES<br>  return CGRectContainsPoint(btnBounds, point);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 子视图超过父视图部分仍然能响应 **重点**</span><br><span class="line"></span><br><span class="line">重写 `hitTest:withEvent` 方法，让 `子视图` 去相应事件</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{<br>  &#x2F;&#x2F; 判断btn能否接收事件<br>  if (self.btn.userInteractionEnabled &#x3D;&#x3D; NO || self.btn.hidden &#x3D;&#x3D; YES || self.btn.alpha &lt;&#x3D; 0.01) {<br>  return nil;<br>  }<br>  &#x2F;&#x2F; 把当前点转换成btn坐标系上的点<br>  CGPoint btnP &#x3D; [self convertPoint:point toView:self.btn];<br>  &#x2F;&#x2F; 当触摸点在btn上时，才让按钮相应事件<br>  if ([self.btn pointInside:btnP withEvent:event]) {<br>  NSLog(@”%@”,NSStringFromCGPoint(btnP));<br>  return self.btn;<br>  }<br>  NSLog(@”父视图相应”);<br>  return [super hitTest:point withEvent:event];<br>}</p>
</li>
</ul>
<p>&#96;&#96;&#96;</p>
<h1 id="面试官问还有什么想问的？-重点"><a href="#面试官问还有什么想问的？-重点" class="headerlink" title="面试官问还有什么想问的？ 重点"></a>面试官问还有什么想问的？ <strong>重点</strong></h1><p>技术面不问薪资待遇，人事面问薪资待遇</p>
<ul>
<li>问岗位：</li>
</ul>
<ol>
<li>在这个岗位上，会直接 <code>接触到哪些类型的项目？</code></li>
<li>这个岗位的主要职责是什么？主要的KPI是什么？</li>
<li>这个岗位如何评估绩效，试用期需要达到什么指标？</li>
<li>这个岗位的最大挑战是什么？</li>
</ol>
<ul>
<li>问团队：</li>
</ul>
<ol>
<li><code>团队的基本情况？</code></li>
<li>这个团队在公司的角色是什么？</li>
<li>可以跟我介绍一下我的领导吗？</li>
</ol>
<ul>
<li>问公司</li>
</ul>
<ol>
<li><code>公司的文化氛围是什么样的？</code></li>
<li>员工的晋升机制是什么样的？我这个岗位的晋升机会如何？</li>
<li>这个岗位所在的团队如何支持公司目标的实现？</li>
</ol>

    </div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/BboyZJ.github.io/2023/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASwift/" class="pre-post btn btn-default" title='iOS面试题：Swift'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            iOS面试题：Swift</span>
    </a>
    
    
    <a href="/BboyZJ.github.io/2023/03/01/Blog-04%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/" class="next-post btn btn-default" title='Blog-04：主题完善'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            Blog-04：主题完善</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    
    
<div class="utteranc">
  
  <script
    src='https://utteranc.es/client.js'
    repo='shenliyang/snippet-comment'
    issue-term='pathname'
    issue-number=''
    theme='github-light'
    label=''
    crossorigin='anonymous'
    async
  ></script>
</div>



</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            Table of Contents
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OC%E7%AE%97%E6%B3%95"><span class="toc-text">OC算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">1. 冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">2. 选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">3. 直接插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-text">4. 希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-text">5. 斐波那契数列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">6. 二分查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="toc-text">7. 递归算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OC%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">OC常见的面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8E%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-text">什么是野指针？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-text">什么是内存泄漏？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iOS-%E5%85%B3%E9%94%AE%E8%AF%8D%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="toc-text">iOS 关键词有哪些？各有什么作用？ 重点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E9%87%8D%E7%82%B9"><span class="toc-text">浅拷贝和深拷贝 重点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSString-x2F-NSArray-x2F-NSDictionary%E5%92%8CNSMutableString-x2F-NSMutableArray-x2F-NSMutableDictionary-%E8%BF%9B%E8%A1%8Ccopy%E5%92%8CmutableCopy%E5%8C%BA%E5%88%AB%EF%BC%9F%E9%87%8D%E7%82%B9"><span class="toc-text">NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？重点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%9A%84copy%E5%92%8CmutableCopy%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="toc-text">自定义对象的copy和mutableCopy？ 重点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%94%A8copy%E8%BF%98%E6%98%AFstrong%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="toc-text">属性用copy还是strong？ 重点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AAAPP%E6%98%AF%E5%A6%82%E4%BD%95%E5%94%A4%E9%86%92%E5%8F%A6%E4%B8%80%E4%B8%AAAPP%E7%9A%84%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="toc-text">一个APP是如何唤醒另一个APP的？ 重点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E7%9A%84%E5%86%99%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="toc-text">单例的写法和作用？ 重点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E6%83%B3%E9%97%AE%E7%9A%84%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="toc-text">面试官问还有什么想问的？ 重点</span></a></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2017
                    
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>




<script src="/BboyZJ.github.io/js/app.js?rev=@@hash.js"></script>

</body>
</html>