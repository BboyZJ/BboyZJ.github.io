<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="我是小J，关注我">
    <meta name="author" content="张建">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://www.bboyzj.cn/2023/03/01/面试题/oc面试题：总结/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    <meta property="og:type" content="article">
    <meta property="og:title" content="OC面试题：总结">
    <meta property="og:description" content="我是小J，关注我">
    <meta property="og:url" content="https://www.bboyzj.cn2023/03/01/面试题/OC面试题：总结/">
    <meta property="og:image" content="/images/redefine-logo.svg">
    <meta property="og:site_name" content="BboyZJ">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="OC面试题：总结">
    <meta name="twitter:description" content="我是小J，关注我">
    <meta name="twitter:image" content="/images/redefine-logo.svg">
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/BboyZJ.github.io/images/redefine-logo.svg">
    
    <title>
        
            OC面试题：总结 -
        
        BboyZJ
    </title>
    
<link rel="stylesheet" href="/BboyZJ.github.io/css/style.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/assets/fonts.css">

    
    
    
    
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"www.bboyzj.cn","root":"/BboyZJ.github.io/","language":"en","path":"search.xml"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/head_img.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"学无止境 学而不思则罔 思而不学则殆","custom_font":{"enable":false,"font_family":null,"font_url":null}},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_block":{"copy":true,"style":"mac","custom_font":{"enable":false,"font_family":null,"font_url":null}},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"1.1.5","friend_links":{"columns":2},"home_article":{"date_format":"auto","category":{"enable":true,"limit":3},"tag":{"enable":true,"limit":3}},"plugins":{"aplayer":{"enable":false,"audio":[{"name":null,"artist":null,"url":null,"cover":null},{"name":null,"artist":null,"url":null,"cover":null}]}}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/BboyZJ.github.io/atom.xml" title="张建的博客" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="menu-wrapper">
    
    <div class="menu-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                BboyZJ
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        首页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/tags/"  >
                                    
                                        
                                            <i class="fa-regular fa-tags"></i>
                                        
                                        标签
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/categories/"  >
                                    
                                        
                                            <i class="fa-regular fa-categories"></i>
                                        
                                        分类
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="menu-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                首页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/tags/"  >
                             
                                
                                    <i class="fa-regular fa-tags"></i>
                                
                                标签
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/categories/"  >
                             
                                
                                    <i class="fa-regular fa-categories"></i>
                                
                                分类
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">OC面试题：总结</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/BboyZJ.github.io/images/head_img.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">张建</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2023-03-01 16:57:33</span>
        <span class="mobile">2023-03-01 16:57</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="pc">2023-03-10 06:13</span>
            <span class="mobile">2023-03-10 06</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/BboyZJ.github.io/categories/OC/">OC</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/BboyZJ.github.io/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/">OC-面试题</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>👁 <a href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%97%E6%B3%95/">OC面试题：算法</a></p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>👁 <a href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/">OC面试题：多线程</a></p>
<h1 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h1><p>👁 <a href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARunloop/">OC面试题：Runloop</a></p>
<h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><p>👁 <a href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARuntime/">OC面试题：Runtime</a></p>
<h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h1><p>👁 <a href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ABlock/">OC面试题：链表</a></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>👁 <a href="https://www.bboyzj.cn/2020/08/09/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8E%A2%E7%B4%A2/">OC学习：链表</a></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>👁  <a href="https://www.bboyzj.cn/2020/08/26/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%A2%E7%B4%A2/">OC学习：二叉树</a></p>
<h1 id="什么是野指针？"><a href="#什么是野指针？" class="headerlink" title="什么是野指针？"></a>什么是野指针？</h1><p>是一个没有指向 <code>任何内存</code> 的 <code>指针</code>，尝试使用它会导致 <code>应用程序崩溃</code></p>
<h1 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h1><p>一个 <code>对象</code> 没有被释放，会 <code>内存泄漏</code>，内存泄漏会导致应用程序占用的内存会越来越大，直到应用程序无内存可用时，会导致 <code>应用程序崩溃</code></p>
<h2 id="iOS-关键词有哪些？各有什么作用？-重点"><a href="#iOS-关键词有哪些？各有什么作用？-重点" class="headerlink" title="iOS 关键词有哪些？各有什么作用？ 重点"></a>iOS 关键词有哪些？各有什么作用？ <strong>重点</strong></h2><ul>
<li>readwrite</li>
</ul>
<p><code>可读可写</code> 特性，同时生成get方法和set方法的声明和实现</p>
<ul>
<li>readonly</li>
</ul>
<p><code>只读</code> 特性，只会生成get方法的声明和实现，不希望属性在类外改变</p>
<ul>
<li>retain</li>
</ul>
<p><code>持有</code> 特性，retaincount 会 +1,用于 <code>MRC</code></p>
<ul>
<li>nonatomic</li>
</ul>
<p><code>非原子</code> 特性</p>
<ul>
<li>atomic</li>
</ul>
<p><code>原子</code> 特性，默认属性</p>
<p>atomic不是绝对线程安全的，只是对 <code>setter/getter</code> 方法使用了 <code>自旋锁(spinlock_t)</code>，内部使用 <code>互斥锁(os_unfair_lock)</code>，保证了 <code>读/写</code> 安全。</p>
<p>atomic并不能保证 <code>整个对象</code> 是线程安全的，需要对 <code>整个对象</code> 进行 <code>加锁</code> 来保证线程安全：</p>
<pre><code>*  NSLock（互斥锁）
*  dispathch_semaphore（信号量）
*  @synchronized（互斥递归锁）
</code></pre>
<ul>
<li>assign</li>
</ul>
<p>可以修饰 <code>基本数据类型和对象</code>。</p>
<p>通常用于修饰 <code>基本数据类型</code>，如Int、CGFloat、Double等，这是因为 <code>基本数据类型放在栈区</code>，栈由编译器自动分配和释放内存，栈先进后出，基本数据类型出栈后，assign修饰的基本数据类型就不存在了，不会出现 <code>野指针</code></p>
<p>修饰对象，如NSString、实例对象等，引用计数不会增加，但 <code>assign</code> 修饰对象释放后，<code>指针</code> 不会被系统置为nil，会产生 <code>野指针</code> 或 <code>EXC_BAD_ACCESS</code> 错误。</p>
<ul>
<li>strong</li>
</ul>
<p>强引用，<code>只修饰对象</code>，属性默认修饰符</p>
<p><code>指向并持有该对象</code>，其修饰的对象引用计数会 <code>+1</code>，引用计数不为 <code>0</code> 则不会被销毁，需要将其置为 <code>nil</code> 可以销毁。否则会出现 <code>内存泄漏</code>。</p>
<ul>
<li>weak</li>
</ul>
<p>弱引用，<code>只修饰对象</code>。</p>
<p><code>指向但并不拥有该对象</code>，引用计数不增加。该对象自动在内存中销毁。</p>
<ul>
<li>copy</li>
</ul>
<p>用于修饰 <code>不可变的对象</code>。</p>
<p>比如NSString、NSDictionary、NSArray等。</p>
<h2 id="浅拷贝和深拷贝-重点"><a href="#浅拷贝和深拷贝-重点" class="headerlink" title="浅拷贝和深拷贝 重点"></a>浅拷贝和深拷贝 <strong>重点</strong></h2><ul>
<li>浅拷贝</li>
</ul>
<p>浅拷贝，拷贝了一个新的指针，与原对象指针指向同一块内存，<code>引用计数 + 1</code>；(A,CopyA &#x3D; [A copy]，A 变化，CopyA 的值也变化)</p>
<ul>
<li>深拷贝</li>
</ul>
<p>深拷贝，拷贝了一个新的对象，指向新的内存，新对象的 <code>引用计数为 1</code>，源对象引用计数不变；(A,MutableA &#x3D; [A mutbleCopy]，A 变化，MutableA 的值不变)。</p>
<h2 id="NSString-x2F-NSArray-x2F-NSDictionary和NSMutableString-x2F-NSMutableArray-x2F-NSMutableDictionary-进行copy和mutableCopy区别？重点"><a href="#NSString-x2F-NSArray-x2F-NSDictionary和NSMutableString-x2F-NSMutableArray-x2F-NSMutableDictionary-进行copy和mutableCopy区别？重点" class="headerlink" title="NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？重点"></a>NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？<strong>重点</strong></h2><ul>
<li><p>对于不可变NSString&#x2F;NSArray&#x2F;NSDictionary，copy浅拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝)</p>
</li>
<li><p>对于可变NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary，copy深拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝)</p>
</li>
</ul>
<h2 id="自定义对象的copy和mutableCopy？-重点"><a href="#自定义对象的copy和mutableCopy？-重点" class="headerlink" title="自定义对象的copy和mutableCopy？ 重点"></a>自定义对象的copy和mutableCopy？ <strong>重点</strong></h2><ul>
<li>copy和mutableCopy都是深拷贝(属性：浅拷贝）</li>
</ul>
<h1 id="属性用copy还是strong？-重点"><a href="#属性用copy还是strong？-重点" class="headerlink" title="属性用copy还是strong？ 重点"></a>属性用copy还是strong？ <strong>重点</strong></h1><ul>
<li><p>对于不可变属性，推荐用copy，目的是为了 <code>让本属性不受外界影响</code>，无论给我传入可变还是不可变对象，我本身持有的就是一个不可变的副本，被set时，改变的是这个副本。</p>
</li>
<li><p>对于可变属性，推荐用strong，因为copy修饰后，会变成不可变对象，再调用可变对象函数时会 crash</p>
</li>
</ul>
<h2 id="一个APP是如何唤醒另一个APP的？-重点"><a href="#一个APP是如何唤醒另一个APP的？-重点" class="headerlink" title="一个APP是如何唤醒另一个APP的？ 重点"></a>一个APP是如何唤醒另一个APP的？ <strong>重点</strong></h2><p>URL Scheme：iOS有一个特性就是将 <code>自身绑定</code> 到一个自定义的 <code>URL Scheme</code> 上，该 <code>scheme</code> 用于从 <code>浏览器或其他应用中启动本应用</code>。</p>
<h2 id="UIView和CALayer"><a href="#UIView和CALayer" class="headerlink" title="UIView和CALayer"></a>UIView和CALayer</h2><ul>
<li>UIView和CALayer的关系？</li>
</ul>
<p>1）UIView继承UIReponder，CALayer继承NSObject。<br>2）UIView响应事件，CALayer绘制UI。<br>3）UIView是CALayer的代理。</p>
<ul>
<li>UIWindow和UIView的关系？</li>
</ul>
<p>1）UIWindow继承自UIView。<br>2）UIWindow提供一个区域用来显示UIView。</p>
<h2 id="单例的写法和作用？-重点"><a href="#单例的写法和作用？-重点" class="headerlink" title="单例的写法和作用？ 重点"></a>单例的写法和作用？ <strong>重点</strong></h2><p>单例模式的作用：可以保证程序运行过程中，一个类只返回一个实例，供外界访问；static保证类只分配一次内存；dispatch_once方法保证调用一次，并自动加锁，线程安全</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static id _instance = nil; // 定义static全局变量，保证只分配一次内存</span><br><span class="line">+ (id)shareInstance&#123;</span><br><span class="line">    return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">+ (id)copyWithZone:(struct _NSZone *)zone&#123;</span><br><span class="line">    static dispatch_once_t onceToken; // 声明一个静态的GcD单次任务</span><br><span class="line">    // 保证只执行一次</span><br><span class="line">    dispatch_once(&amp;onceToken,^&#123; // </span><br><span class="line">        _instance = [super allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这么写可以保证下面两种方式返回同一个实例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Single * p1 = [Single shareInstance];</span><br><span class="line">Single * p2 = [[Single alloc] init];</span><br><span class="line">NSLog(@&quot;%d&quot;,p1==p2); // 1</span><br></pre></td></tr></table></figure></div>

<h2 id="常用的数据存储方式有哪些？各自的优缺点？"><a href="#常用的数据存储方式有哪些？各自的优缺点？" class="headerlink" title="常用的数据存储方式有哪些？各自的优缺点？"></a>常用的数据存储方式有哪些？各自的优缺点？</h2><ul>
<li><p>plist：plist文件是将某些特定的类，通过 <code>XML文件</code> 的方式保存在目录中。</p>
</li>
<li><p>NSUserdefault：归档</p>
</li>
<li><p>数据库：适合储存数据量较大的数据,一般使用FMDB和CoreData来实现.</p>
</li>
<li><p>Keychain：用于 <code>本地重要数据的存储</code>，将数据加密后存储在本地。如：<code>密码,秘钥,序列号</code> 等,当你 <code>删除APP后Keychain存储的数据不会删除</code>，所以在重装App后，Keychain里的数据还能使用。</p>
</li>
<li><p>沙盒写入：存储非机密数据</p>
<ul>
<li>Application：存放程序源文件，上架前经过数字签名，上架后不可修改。</li>
<li>Documents: <code>保存应⽤运行时生成的需要持久化的数据</code>。<code>iTunes</code> 同步设备时会 <code>备份</code> 该目录。</li>
<li>tmp: <code>保存应⽤运行时所需的临时数据</code>，使⽤完毕后再将相应的文件从该目录删除。<code>iTunes</code> 同步设备时 <code>不会备份</code> 该目录。</li>
<li>Library&#x2F;Caches: <code>保存应用运行时⽣成的需要持久化的数据</code>。 <code>iTunes</code> 同步设备时 <code>不会备份</code> 该目录。</li>
<li>Library&#x2F;Preference: <code>保存应用的所有偏好设置</code>。<code>iTunes</code> 同步设备时会 <code>备份</code> 该目录。</li>
</ul>
</li>
</ul>
<h2 id="加密方式有哪些？各自的加密算法哪些？"><a href="#加密方式有哪些？各自的加密算法哪些？" class="headerlink" title="加密方式有哪些？各自的加密算法哪些？"></a>加密方式有哪些？各自的加密算法哪些？</h2><ul>
<li><p>对称加密：又称公开密钥加密，<code>加密和解密</code> 都会用到 <code>同一个密钥</code>。常见的对称加密算法有 <code>DES、3DES、AES、Blowfish、IDEA、RC5、RC6</code>。</p>
</li>
<li><p>非对称加密：非对称加密又称 <code>共享密钥加密</code>，使用 <code>一对非对称的密钥</code>，一把叫做 <code>私有密钥</code>，另一把叫做 <code>公有密钥</code>；公钥加密只能用私钥来解密，私钥加密只能用公钥来解密。常见的有：<code>RSA</code>、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法。</p>
</li>
</ul>
<h2 id="成员变量和实例变量区别？"><a href="#成员变量和实例变量区别？" class="headerlink" title="成员变量和实例变量区别？"></a>成员变量和实例变量区别？</h2><ul>
<li><p>成员变量：在文件中@interface下{}内的均统称为 <code>成员变量</code></p>
</li>
<li><p>实例变量：实例变量是 <code>类定义</code> 的变量</p>
</li>
<li><p>区别：</p>
<ul>
<li>去除基本数据类型int,float…等，其他类型的变量均叫做 <code>实例变量</code></li>
<li><code>成员变量 = 实例变量 + 基本数据类型</code></li>
</ul>
</li>
</ul>
<h2 id="property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的"><a href="#property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的" class="headerlink" title="@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?"></a>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?</h2><ul>
<li>@property &#x3D; _ivar + getter + setter;</li>
</ul>
<p> property（属性）&#x3D; _ivar（实例变量）+ setter（存方法）+ getter（取方法） </p>
<ul>
<li><p>属性引用self.name与_name的区别？</p>
</li>
<li><p>self.name是对属性的访问，&#x3D; 左侧是调用setter方法，&#x3D; 右侧是调用getter方法，可以在类外使用，_name不能在类外使用。</p>
</li>
<li><p>_name是对 <code>局部变量</code> 的访问，直接调用变量，不通过getter方法</p>
</li>
</ul>
<h2 id="frame-和-bounds-区别？"><a href="#frame-和-bounds-区别？" class="headerlink" title="frame 和 bounds 区别？"></a>frame 和 bounds 区别？</h2><ul>
<li><p>frame：参考系是父视图坐标</p>
</li>
<li><p>bounds：参考系是自身坐标</p>
</li>
</ul>
<h2 id="常见的状态码？"><a href="#常见的状态码？" class="headerlink" title="常见的状态码？"></a>常见的状态码？</h2><ul>
<li><p>2xx <code>成功</code>：200表示请求正常。</p>
</li>
<li><p>3xx <code>重定向</code>：302是请求重定向。解决方法 NSURLConnetion 和 NSURLSession 进行拦截</p>
</li>
<li><p>4xx <code>客户端</code>错误：400客户端请求的语法错误，404Not Found 找不到&#x2F;请求失败</p>
</li>
<li><p>5xx <code>服务器</code>错误：500 Internal Server Error 服务器的内部错误</p>
</li>
</ul>
<h2 id="HTTPS和HTTP的区别？-重点"><a href="#HTTPS和HTTP的区别？-重点" class="headerlink" title="HTTPS和HTTP的区别？ 重点"></a>HTTPS和HTTP的区别？ <strong>重点</strong></h2><ul>
<li><p>HTTP：超文本传输协议，信息明文传输；端口号80；响应速度快（使用TCP三次握手，客户端和服务端需要交换3个包）；</p>
</li>
<li><p>HTTPS：是由 HTTP+SSL&#x2F;TLS 加密传输；端口号443；响应速度慢（除了使用TCP三个包，还要加上SSL握手的9个包）；需要到CA申请证书</p>
</li>
</ul>
<h2 id="TCP-和-UDP-区别-重点"><a href="#TCP-和-UDP-区别-重点" class="headerlink" title="TCP 和 UDP 区别? 重点"></a>TCP 和 UDP 区别? <strong>重点</strong></h2><ul>
<li><p>都是 <code>传输层</code> 协议</p>
</li>
<li><p>TCP协议是 <code>面向连接的可靠的传输层协议</code>。UDP协议是 <code>面向非连接的传输层协议</code></p>
</li>
<li><p>TCP需要 <code>建立连接和断开连接</code>。UDP不需要连接。</p>
</li>
<li><p>TCP传 <code>输数据没有大小限制</code>。UDP <code>传输数据有大小限制</code>。</p>
</li>
<li><p>TCP会 <code>处理数据丢包重发</code>。UDP不会处理。</p>
</li>
</ul>
<h1 id="HTTP和socket区别？-重点"><a href="#HTTP和socket区别？-重点" class="headerlink" title="HTTP和socket区别？ 重点"></a>HTTP和socket区别？ <strong>重点</strong></h1><ul>
<li><code>HTTP</code> 应用层协议；<code>socket</code> 不属于协议范畴，而是一个接口（API），是对TCP&#x2F;IP协议的封装</li>
<li><code>HTTP</code> 是基于 <code>请求-响应</code> 形式 <code>短连接</code>，即客户端发送一次请求，服务端响应后立即 <code>断开连接</code>；socket 是基于TCP协议的 <code>长链接</code>，理论上 客户端和服务端一旦建立连接将不会主动断开</li>
<li>HTTP 传输慢，数据量大，安全差；socket 数据可自定义，数据量小，安全性高，适合信息实时交互（推送、聊天等）</li>
</ul>
<h2 id="staitc-和-const-的区别？-重点"><a href="#staitc-和-const-的区别？-重点" class="headerlink" title="staitc 和 const 的区别？ 重点"></a>staitc 和 const 的区别？ <strong>重点</strong></h2><ul>
<li><p>const：表示 <code>只读</code> 的意思</p>
<ul>
<li><p><code>const</code> 放在 <code>类型</code> 前：可以改变指针的指向，可以改变指针指向的内容</p>
</li>
<li><p><code>const</code> 放在 <code>变量</code> 前：不可以改变指针的指向，不可以改变指针指向的内容</p>
</li>
</ul>
</li>
<li><p>static： <code>静态变量</code>，可修饰 <code>局部变量和全局变量</code>，可修饰方法</p>
<ul>
<li><p><code>static</code> 可修饰 <code>局部/全局变量</code>，称为 <code>局部静态变量和全局静态变量</code>，只初始化一次，只分配一次内存，生命周期被改变，不再是作用域内</p>
</li>
<li><p><code>static</code> 修饰的 <code>方法</code>，可以在不同文件下重名，互不影响运行</p>
</li>
</ul>
</li>
</ul>
<h2 id="通用链接（Universal-Links）重点"><a href="#通用链接（Universal-Links）重点" class="headerlink" title="通用链接（Universal Links）重点"></a>通用链接（Universal Links）<strong>重点</strong></h2><ul>
<li><p>服务端配置 <code>HTTPS</code> 证书 和添加 <code>apple-app-site-association</code> 地址关联文件</p>
</li>
<li><p>移动端在plist添加 <code>Associated Domains</code> 关联域权限</p>
</li>
</ul>
<h2 id="简述GET和POST请求的区别？-重点"><a href="#简述GET和POST请求的区别？-重点" class="headerlink" title="简述GET和POST请求的区别？ 重点"></a>简述GET和POST请求的区别？ <strong>重点</strong></h2><ul>
<li><p>GET 传输数据 <code>有缓存</code>；POST 传输数据 <code>没有缓存</code></p>
</li>
<li><p>GET的 <code>参数</code> 放在 <code>URL</code> 的后面，并且第一个参数用 <code>?</code> 号拼接，后面的从第二个参数开始，直到最后一个，用 <code>&amp;</code> 分割；POST的 <code>参数</code> 放在 <code>请求体</code> 里面，并且第一个参数用 <code>,</code> 号拼接，后面从第二开始，直到最后用 <code>&amp;</code> 分割;</p>
</li>
<li><p>GET一般用于 <code>获取数据</code>；POST一般用于 <code>向服务器提交数据</code></p>
</li>
<li><p><code>GET</code> 的参数是暴漏在 <code>地址栏</code> 的，不安全；<code>POST</code> 的参数隐藏在 <code>请求体</code> 里面，相对安全一点;</p>
</li>
</ul>
<h2 id="iOS中几种常见的设计模式？-重点"><a href="#iOS中几种常见的设计模式？-重点" class="headerlink" title="iOS中几种常见的设计模式？  重点"></a>iOS中几种常见的设计模式？  <strong>重点</strong></h2><ul>
<li><code>代理模式</code></li>
</ul>
<p>一对一的依赖关系，当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。</p>
<ul>
<li><code>观察者模式</code></li>
</ul>
<p>KVO机制 和 Notification通知机制</p>
<ul>
<li><code>单例模式</code></li>
</ul>
<p>保证程序运行过程中，一个类只返回一个实例，供外界访问</p>
<ul>
<li><code>工厂模式</code></li>
</ul>
<p>通过一个类方法，<code>根据已有模板批量生产对象</code>。</p>
<ul>
<li><code>MVC模式</code></li>
</ul>
<p>Model即数据模型</p>
<p>view即视图</p>
<p>controller即控制器</p>
<h2 id="RunLoop是什么？-重点"><a href="#RunLoop是什么？-重点" class="headerlink" title="RunLoop是什么？ 重点"></a>RunLoop是什么？ <strong>重点</strong></h2><ul>
<li>概念</li>
</ul>
<p><code>RunLoop</code> 又叫 <code>运行循环</code>，内部就是一个 <code>do-while循环</code>，在这个循环内部不断 <code>处理各种任务，保证程序持续运行</code>。</p>
<ul>
<li>目的</li>
</ul>
<p>RunLoop存在的目的： 就是当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，<code>提高程序性能，节省CPU资源</code>，该做事的时候做事，该休息的时候休息</p>
<h2 id="RunLoop的作用？-重点"><a href="#RunLoop的作用？-重点" class="headerlink" title="RunLoop的作用？ 重点"></a>RunLoop的作用？ <strong>重点</strong></h2><ul>
<li><p><code>保持程序持续运行</code>。<br> App一启动就会开启主线程，主线程在开启的时候就会开启主线程对应的RunLoop，RunLoop能保证线程不被销毁，主线程不销毁，程序就会持续运行。</p>
</li>
<li><p><code>处理App中各类事件</code>。<br> 事件响应、手势识别、界面刷新、AutoreleasePool自动释放池、NSTimer等事件处理。</p>
</li>
<li><p><code>节省CPU资源，提高程序性能</code>。<br> 如概述所述，当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，提高程序性能，节省资源，该做事的时候做事，该休息的时候休息。</p>
</li>
</ul>
<h2 id="可以用Runloop实现什么功能？-重点"><a href="#可以用Runloop实现什么功能？-重点" class="headerlink" title="可以用Runloop实现什么功能？ 重点"></a>可以用Runloop实现什么功能？ <strong>重点</strong></h2><ul>
<li>tableView 滚动时图片不加载</li>
</ul>
<p>SDWebImage + Runloop，图片延迟加载，滑动不加载图片</p>
<ul>
<li>线程保活</li>
</ul>
<p>往 <code>runloop</code> 中添加 <code>[[NSPort alloc] init]</code> 事件，</p>
<ul>
<li>解决NSTimer在滑动时停止工作的问题</li>
</ul>
<p><code>default</code> 模式改为 <code>common</code> 模式</p>
<ul>
<li>检测卡顿</li>
</ul>
<p><code>displaylink + runloop 进行卡顿检测，将数值和页面绑定上传到服务器</code></p>
<h2 id="RunLoop接收几种输入源，系统默认定义了几种模式？-重点"><a href="#RunLoop接收几种输入源，系统默认定义了几种模式？-重点" class="headerlink" title="RunLoop接收几种输入源，系统默认定义了几种模式？ 重点"></a>RunLoop接收几种输入源，系统默认定义了几种模式？ <strong>重点</strong></h2><ul>
<li><p>输入源有两种<br>基于 <code>端口</code> 的输入源（port）<br><code>自定义</code> 的输入源（custom）</p>
</li>
<li><p>系统定义的RunLoop模式有五种，最常用的有三种，如下所示：<br>NSDefaultRunLoopMode<br>默认模式，主线程中默认是NSDefaultRunLoopMode<br>UITrackingRunLoopMode<br>视图滚动模式，RunLoop会处于该模式下<br>NSRunLoopCommonModes<br>并不是真正意义上的Mode，是一个占位用的“Mode”，默认包含了NSDefaultRunLoopMode和UITrackingRunLoopMode两种模式</p>
</li>
</ul>
<h2 id="RunLoop和线程有什么关系？Runloop的mode-Runloop的作用？-重点"><a href="#RunLoop和线程有什么关系？Runloop的mode-Runloop的作用？-重点" class="headerlink" title="RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？ 重点"></a>RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？ <strong>重点</strong></h2><ul>
<li>每一个线程都有一个runloop，主线程的runloop默认启动。子线程的runloop默认不启动</li>
<li>mode：主要用来指定事件在运行时循环的优先级</li>
<li>作用：保持程序的持续运行、随时处理各种事件、节省cpu资源(没事件休息释放资源)，提高程序的性能。</li>
</ul>
<h2 id="怎么理解Objective-C是动态运行时语言。-重点"><a href="#怎么理解Objective-C是动态运行时语言。-重点" class="headerlink" title="怎么理解Objective-C是动态运行时语言。 重点"></a>怎么理解Objective-C是动态运行时语言。 <strong>重点</strong></h2><p>主要是 <code>将数据类型的确定和函数的调用由编译时推迟到了运行时</code>。这个问题其实浅涉及到两个概念，<code>运行时和多态</code>。</p>
<ul>
<li><p>运行时：简单来说，运行时机制使我们 <code>直到运行时才去确定数据类型和要调用的函数</code>。</p>
</li>
<li><p>多态：<code>不同对象以自己的方式响应相同的消息的能力</code> 叫做多态。</p>
</li>
</ul>
<h2 id="runtime项目中具体应用？-重点"><a href="#runtime项目中具体应用？-重点" class="headerlink" title="runtime项目中具体应用？ 重点"></a>runtime项目中具体应用？ <strong>重点</strong></h2><ul>
<li><code>方法交换</code>。</li>
<li>给 <code>分类添加属性</code>。 </li>
<li>动态添加方法。</li>
<li>字典转模型。</li>
<li>数组越界。</li>
<li>动态获取成员属性、成员变量、实例方法</li>
</ul>
<h2 id="KVC是什么？重点"><a href="#KVC是什么？重点" class="headerlink" title="KVC是什么？重点"></a>KVC是什么？<strong>重点</strong></h2><p><code>KVC</code> 全程 <code>Key Value Coding</code>，中文 <code>键值编码</code>，是由 <code>NSKeyValueCoding</code> 非正式协议启动的一种机制，<code>对象</code> 采用该协议来 <code>间接访问对象的属性</code>。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKey:(NSString *)key;     </span><br><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath; </span><br><span class="line"></span><br><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; </span><br></pre></td></tr></table></figure></div>

<p><a href="http://www.bboyzj.cn/2021/01/17/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8622%EF%BC%9AKVC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">KVC底层原理：</a></p>
<h2 id="KVO是什么？重点"><a href="#KVO是什么？重点" class="headerlink" title="KVO是什么？重点"></a>KVO是什么？<strong>重点</strong></h2><p><code>KVO</code> 全程 <code>Key Value Observing</code>，中文 <code>键值观察</code>，它 <code>用于监听实例对象属性的变化</code>。</p>
<h2 id="KVO的实现原理？-KVO的本质是什么？-重点"><a href="#KVO的实现原理？-KVO的本质是什么？-重点" class="headerlink" title="KVO的实现原理？(KVO的本质是什么？) 重点"></a>KVO的实现原理？(KVO的本质是什么？) <strong>重点</strong></h2><p>当一个 <code>实例对象</code> 的 <code>属性注册了KVO</code>，实例对象 <code>isa指针</code> 的指向在注册KVO观察者之后，由 <code>原有类</code> 改为 <code>中间类(NSKVONotifing_类名)</code>；<code>中间类</code> 重写了 <code>属性setter方法、class、dealloc、_isKVOA</code> 方法；<code>dealloc</code> 方法中，移除 <code>KVO</code> 观察者之后，实例对象isa 指向由 <code>中间类</code> 更改为 <code>原有类</code>;中间类 从创建后就 <code>一直存在内存中</code>，不会被销毁。</p>
<h2 id="KVO实际应用-重点"><a href="#KVO实际应用-重点" class="headerlink" title="KVO实际应用 重点"></a>KVO实际应用 <strong>重点</strong></h2><ul>
<li><p>观察 <code>实例对象</code> 的 <code>属性</code> 变化</p>
</li>
<li><p>观察 <code>实例对象</code> 的 <code>容器</code> 变化</p>
<p> 观察容器用： <code>mutableArrayValueForKey</code></p>
</li>
</ul>
<p><a href="http://www.bboyzj.cn/2021/01/25/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8623%EF%BC%9AKVO%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">KVO底层原理：</a> </p>
<h2 id="category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？重点"><a href="#category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？重点" class="headerlink" title="category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？重点"></a>category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？<strong>重点</strong></h2><ul>
<li><p><code>category</code> 原则上它 <code>只能增加方法</code>，<code>不能增加成员（实例）变量</code>。可以添加属性，但是不会自动生成实例变量_name和setter和getter方法。可以添加方法</p>
</li>
<li><p><code>扩展</code> 主要用来为一个类添加额外的原来没有的 <code>实例变量、方法和属性</code>。extension常用的形式并不是以一个单独的.h文件存在，而是寄生在类的.m文件中。</p>
</li>
</ul>
<p>类扩展中：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface Person ()&#123;</span><br><span class="line">    int age; //实例变量</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic,copy)NSString * name;//属性</span><br><span class="line">- (void)run;//方法</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>


<h1 id="load、initialize的区别，以及它们在category重写的时候的调用的次序？"><a href="#load、initialize的区别，以及它们在category重写的时候的调用的次序？" class="headerlink" title="load、initialize的区别，以及它们在category重写的时候的调用的次序？"></a>load、initialize的区别，以及它们在category重写的时候的调用的次序？</h1><ul>
<li><p>区别在于 <code>调用方式和调用时刻</code></p>
</li>
<li><p>调用方式：<br>  load是根据 <code>函数地址</code> 直接调用，initialize是通过 <code>objc_msgSend</code> 调用</p>
</li>
<li><p>调用时刻：<br>  load 是 <code>runtime加载类、分类的时候调用</code><br>  initialize 是 <code>类第一次接收到消息的时候调用</code></p>
</li>
<li><p>调用顺序：<br>  父类的load &gt; 类load &gt; 分类中load(多个分类：先编译的分类优先调用load方法)。<br>  先调父类initialize -&gt; 再调子类initialize。<br>  如果有分类：父类initialize -&gt; 分类initialize，分类覆盖类的+initialize。</p>
</li>
</ul>
<h1 id="super的本质？"><a href="#super的本质？" class="headerlink" title="super的本质？"></a>super的本质？</h1><ul>
<li>[self class] : 返回实例对象的类</li>
<li>[self superclass] : 返回实例对象的父类</li>
<li>[super class] : 编译指示器(标识符)，底层会被编译成 <code>objc_msgSendSuper()</code> 方法，返回实例对象的类</li>
<li>[super superclass] : 返回父类</li>
</ul>
<h1 id="简述下Objective-C中调用方法的过程？"><a href="#简述下Objective-C中调用方法的过程？" class="headerlink" title="简述下Objective-C中调用方法的过程？"></a>简述下Objective-C中调用方法的过程？</h1><p>Objective-C是动态语言，每个方法在 <code>运行时</code> 会被动态转为 <code>消息发送</code>，即：<code>objc_msgSend(receiver, selector)</code>，整个过程介绍如下：<br>person实例对象发送一条test消息：</p>
<ul>
<li><code>消息发送阶段</code>：</li>
</ul>
<p>负责从 <code>类及父类的缓存列表及方法列表查找方法</code>。每当调用方法的时候，会先去cache中查找是否有缓存的方法，如果没有缓存，在去类对象方法列表中遍历查找，如果方法不在列表里面；就会通过superclass找到父类的类对象，在去父类cache中查找是否有缓存的方法，如果没有缓存，去父类对象方法列表里面遍历查找，以此类推直到找到方法之后，就会将方法直接存储在cache中，下一次在调用这个方法的时候，就会在类对象的cache里面找到这个方法，直接调用了。</p>
<ul>
<li><code>动态方法解析</code></li>
</ul>
<p>如果消息发送阶段没有找到方法，则会进入动态解析阶段，负责动态的添加方法实现。</p>
<p>动态解析对象方法时，会调用：<br><code>+(BOOL)resolveInstanceMethod</code></p>
<p>动态解析类方法时，会调用：<br><code>+(BOOL)resolveClassMethod:(SEL)sel。</code></p>
<ul>
<li><code>快速转发阶段</code></li>
</ul>
<p>如果也没有实现动态解析方法，则会进行消息转发阶段，将消息转发给可以处理消息的接受者来处理。以处理消息的接受者来处理。<br><code>- (id)forwardingTargetForSelector:</code>由上述代码可以看出，当本类没有实现方法，并且没有动态解析方法，就会调用forwardingTargetForSelector函数，<code>进行消息转发</code>，我们可以实现forwardingTargetForSelector函数，在其内部将消息转发给可以实现此方法的对象。</p>
<ul>
<li><code>慢速转发阶段</code></li>
</ul>
<p><code>方法签名</code>：返回值类型、参数类型<br><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code></p>
<p>如果forwardingTargetForSelector函数返回为nil或者没有实现的话，就会调用methodSignatureForSelector方法，用来返回一个方法签名，这也是我们正确跳转方法的最后机会。</p>
<p>NSInvocation 封装了一个方法调用，包括：方法调用者，方法，方法的参数<br><code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code></p>
<p>如果methodSignatureForSelector方法返回正确的方法签名就会调用forwardInvocation方法，forwardInvocation方法内提供一个NSInvocation类型的参数，NSInvocation封装了一个方法的调用，包括方法的调用者，方法名，以及方法的参数。在forwardInvocation函数内修改方法调用对象即可。<br>如果methodSignatureForSelector返回的为nil，就会来到doseNotRecognizeSelector:方法内部，程序crash提示无法识别选择器unrecognized selector sent to instance。</p>
<ul>
<li>如果消息转发也没有实现，就会报方法找不到的错误，无法识别消息，unrecognzied selector sent to instance</li>
</ul>
<h1 id="循环引用的几种情况和解决方式？-重点"><a href="#循环引用的几种情况和解决方式？-重点" class="headerlink" title="循环引用的几种情况和解决方式？ 重点"></a>循环引用的几种情况和解决方式？ <strong>重点</strong></h1><ul>
<li>Block</li>
</ul>
<p>原因： <code>self</code> 强引用了 <code>block</code>，而 <code>block</code> 内部又调用了 <code>self</code><br>解决： 使用 <code>Weak-Strong Dance</code></p>
<ul>
<li>Delegate</li>
</ul>
<p>原因：委托者和被委托人之间的相互强引用问题 <code>strong</code><br>解决：用 <code>weak</code> 进行弱引用 <code>或者</code> 通过中间对象(代理对象)的方式来解决(效率更加高的中间对象NSProxy：不需要进行发送消息和动态解析，直接进行消息转发)</p>
<ul>
<li>NSTimer</li>
</ul>
<p>原因：self → timer → self(target) 的循环持有链<br>解决：在适当的时机销毁 </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[_timer invalidate];</span><br><span class="line">_timer = nil;</span><br></pre></td></tr></table></figure></div>

<h1 id="OC-如何进行内存管理的？-重点"><a href="#OC-如何进行内存管理的？-重点" class="headerlink" title="OC 如何进行内存管理的？ 重点"></a>OC 如何进行内存管理的？ <strong>重点</strong></h1><ul>
<li><p>手动内存管理 MRC</p>
</li>
<li><p>自动内存管理 ARC</p>
<p>  LLVM + Runtime 会为我们代码自动插入 retain 和 release 以及 autorelease等代码,不需要我们手动管理</p>
</li>
<li><p>自动释放池</p>
</li>
</ul>
<h1 id="自动释放池原理-重点"><a href="#自动释放池原理-重点" class="headerlink" title="自动释放池原理 重点"></a>自动释放池原理 <strong>重点</strong></h1><ul>
<li><p>自动释放池的本质是 <code>__AtAutoreleasePool</code> 结构体，包含构造函数和析构函数</p>
</li>
<li><p>结构体声明，触发构造函数，调用 <code>objc_autoreleasePoolPush()</code> 函数，对象压栈</p>
</li>
<li><p>结构体出作用域，触发析构函数，调用 <code>objc_autoreleasePoolPop()</code> 函数，对象出栈</p>
</li>
</ul>
<h1 id="内存优化-重点"><a href="#内存优化-重点" class="headerlink" title="内存优化 重点"></a>内存优化 <strong>重点</strong></h1><ul>
<li>cell复用</li>
<li>绘制的话：用CAShaperLayer，渲染快，内存使用高效</li>
<li>按需加载：懒加载</li>
<li>合理利用缓存：比如三方图片压缩缓存</li>
<li>尽量使用透明View：控件有背景色增大内存消耗</li>
</ul>
<h1 id="启动优化-重点"><a href="#启动优化-重点" class="headerlink" title="启动优化 重点"></a>启动优化 <strong>重点</strong></h1><ul>
<li><p>pre-main 阶段：<code>二进制重排</code></p>
<ul>
<li><p>尽量 <code>少用外部动态库</code>，苹果官方建议自定义的动态库最好 <code>不要超过6个</code>，如果超过6个，需要 <code>合并</code> 动态库</p>
</li>
<li><p>减少 <code>OC</code> 类，因为类越多，越耗时</p>
</li>
<li><p>将不必须在 <code>+load</code> 方法中做的事情延迟到 <code>+initialize</code> 中，尽量不要用 <code>C++</code> 虚函数</p>
</li>
</ul>
</li>
<li><p>main 阶段：mian -&gt; didFinishLaunching</p>
<ul>
<li><p>减少启动初始化的流程，<code>能懒加载的懒加载，能延迟的延迟，能放后台初始化的放后台</code>，尽量少占用主线程的启动时间</p>
</li>
<li><p>优化代码逻辑，去除非必须的代码逻辑，减少每个流程的消耗时间</p>
</li>
<li><p>启动阶段能 <code>使用多线程</code> 来初始化的，就使用多线程</p>
</li>
<li><p>尽量 <code>使用纯代码</code> 来进行UI框架的搭建，尤其是主UI框架，例如 UITabBarController，尽量避免使用Xib或者SB，相比纯代码而言，这种更耗时</p>
</li>
<li><p>删除废弃类、方法</p>
</li>
</ul>
</li>
</ul>
<h2 id="卡顿监听-重点"><a href="#卡顿监听-重点" class="headerlink" title="卡顿监听 重点"></a>卡顿监听 <strong>重点</strong></h2><p><strong>主要是用 displayLink + Runloop 进行FPS监测</strong></p>
<p>主要从减轻 <code>CPU</code> 和 <code>GPU</code> 消耗入手，保证写一个 <code>VSync</code> 到来时，<code>CPU</code> 和 <code>GPU</code> 能够写作完成下一帧的渲染并缓存到帧缓冲区</p>
<ul>
<li>卡顿优化在 <code>CPU</code> 层面：</li>
</ul>
<p>1）尽量用轻量级的对象，比如 <code>用不到事件处理</code> 的地方，可以考虑使用 <code>CALayer</code> 取代 <code>UIView</code><br>2）不要频繁地调用 <code>UIView</code> 的相关属性，比如 <code>frame、bounds、transform</code> 等属性，尽量减少不必要的修改<br>3）尽量 <code>提前计算好布局</code>，在有需要时一次性调整对应的属性，不要多次修改属性<br>4）图片的 <code>size</code> 最好刚好跟 <code>UIImageView</code> 的 <code>size</code> 保持一致<br>5）<code>控制</code>一下线程的最大并发数量<br>6）尽量把 <code>耗时的操作放到子线程</code>：如text宽高获取等</p>
<ul>
<li>卡顿优化在 GPU层面：</li>
</ul>
<p>1）GPU能处理的 <code>最大纹理</code> 尺寸是 <code>4096x4096</code>，一旦超过这个尺寸，就会占用 <code>CPU</code> 资源进行处理，所以纹理尽量不要超过这个尺寸<br>2）尽量 <code>减少视图数量和层次</code><br>3）<code>减少透明的视图</code>（alpha&lt;1），不透明的就设置 <code>opaque</code> 为 <code>YES</code><br>4）尽量 <code>避免出现离屏渲染</code>：圆角、阴影、遮罩等</p>
<h2 id="tableView卡顿优化-重点"><a href="#tableView卡顿优化-重点" class="headerlink" title="tableView卡顿优化 重点"></a>tableView卡顿优化 <strong>重点</strong></h2><ul>
<li><p>最常用的就是<code>cell的复用</code>， 注册复用标识符</p>
</li>
<li><p><code>避免cell的重新布局</code>，初始化时就布局好</p>
</li>
<li><p><code>提前计算并缓存cell的高度</code></p>
</li>
<li><p><code>减少cell中控件的数量</code>，少动态添加 view</p>
</li>
<li><p><code>避免背景透明</code></p>
</li>
<li><p>能<code>使用局部更新</code> 的就使用 <code>局部更新</code></p>
</li>
<li><p>加载网络数据，<code>下载图片，使用异步加载</code>，并缓存</p>
</li>
<li><p><code>按需加载cell</code>：cell滚动很快时，只加载范围内的cell</p>
</li>
<li><p><code>不要实现无用的代理方法</code>，tableView只遵守两个协议</p>
</li>
</ul>
<h1 id="网络优化-重点"><a href="#网络优化-重点" class="headerlink" title="网络优化 重点"></a>网络优化 <strong>重点</strong></h1><ul>
<li>DNS优化：即域名解析优化，缓存 <code>ip</code></li>
<li>资源优化：<ul>
<li>图片webp，比png&#x2F;jpg小</li>
<li>数据传输用ProtocolBuffer代替json，数据小，序列化和反序列化也简单</li>
</ul>
</li>
<li>请求压缩、请求合并</li>
<li>数据缓存</li>
<li>网络环境监测<ul>
<li>针对性请求重试</li>
</ul>
</li>
</ul>
<h2 id="TCP三次握手，四次挥手过程？重点"><a href="#TCP三次握手，四次挥手过程？重点" class="headerlink" title="TCP三次握手，四次挥手过程？重点"></a>TCP三次握手，四次挥手过程？<strong>重点</strong></h2><ol>
<li>为什么是三次握手，而不是二次握手？</li>
</ol>
<p>三次握手是为了建立一个可靠的数据传输通道：</p>
<ul>
<li><p>刚开始客户端和服务端处于关闭状态，而且服务端B一直处于监听状态，时刻监听是否有建立连接的请求</p>
</li>
<li><p>当客户端需要建立连接的时候就会发送一个 <code>请求连接</code> 的报文，此报文是 <code>同步报文SYN=1</code>，并且会生成一个 <code>随机的序号seq=x</code>，这是第一次握手</p>
</li>
<li><p>当服务端接收到请求连接报文时，会发送一个 <code>确认连接</code> 的报文，此报文是 <code>同步报文SYN=1</code>，并且 <code>确认报文ACK=1</code>，同时服务端也会生成一个 <code>随机的序号seq=y</code>，并且将 <code>确认报文确认号ack=x+1</code>，回传给客户端，这是第二次握手</p>
</li>
<li><p>当客户端接收到服务端的 <code>ACK确认报文后</code>，会回复一个 <code>ACK确认报文</code>，用于确认确认报文已经收到，此报文 <code>ACK=1，seq=x+1，ack=y+1</code>，这是第三次握手</p>
</li>
</ul>
<ol start="2">
<li>四次挥手</li>
</ol>
<p>四次挥手则是为了保证数据传输完成接收再关闭连接。</p>
<ul>
<li><p>客户端断开连接时会发送一个 <code>请求断开连接</code> 的报文，此报文是 <code>FIN=1</code>，并且会生成一个 <code>随机的序号seq=u</code>，发送给服务端，这是第一次挥手</p>
</li>
<li><p>服务端接收到请求断开连接 <code>FIN报文</code> 后，回复一个 <code>确认断开连接</code> 报文 <code>ACK=1,seq=v,ack=u+1</code>，这是第二次挥手</p>
</li>
<li><p>当服务端数据发送完后，再发送一个FIN报文给客户端，通知客户端，服务端准备关闭连接，此报文 <code>FIN=1,ACK=1,ack=u+1,seq=w</code>，这是第三次挥手</p>
</li>
<li><p>当客户端收到 <code>FIN确认报文</code>，再发送一个FIN确认报文 <code>ACK=1,seq=u+1,ack=w+1</code>，并进入<code> TIME-WAIT</code> 等待，等待 <code>2MSL</code> 后关闭连接，这是第四次挥手</p>
</li>
</ul>
<h1 id="事件链-重点"><a href="#事件链-重点" class="headerlink" title="事件链 重点"></a>事件链 <strong>重点</strong></h1><p><a href="https://www.bboyzj.cn/2023/03/01/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/">OC学习01：事件传递链和响应链</a></p>
<ul>
<li><p>传递链：由系统向离用户最近的view传递。<br>顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; ViewController -&gt; subViews</p>
</li>
<li><p>响应链：由离用户最近的view向系统传递。<br>顺序： superViews –&gt; ViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate</p>
</li>
</ul>
<h1 id="事件传递的两个核心方法？-重点"><a href="#事件传递的两个核心方法？-重点" class="headerlink" title="事件传递的两个核心方法？ 重点"></a>事件传递的两个核心方法？ <strong>重点</strong></h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 返回最适合处理事件的视图</span><br><span class="line">- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;  </span><br><span class="line">// 判断点是否在这个View内部</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>第一个方法返回的是一个 <code>UIView</code>，是用来寻找最终哪一个视图来响应这个事件</li>
<li>第二个方法是用来判断某一个点击的位置是否在视图范围内，如果在就返回YES</li>
</ul>
<h1 id="实现一个按钮的点击范围扩大效果-重点"><a href="#实现一个按钮的点击范围扩大效果-重点" class="headerlink" title="实现一个按钮的点击范围扩大效果 重点"></a>实现一个按钮的点击范围扩大效果 <strong>重点</strong></h1><p>自定义一个按钮，继承UIButton，重写 <code>pointInside:withEvent:</code> 方法，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 当前btn大小</span><br><span class="line">    CGRect btnBounds = self.bounds;</span><br><span class="line">    // 扩大按钮的点击范围，增大内边距</span><br><span class="line">    btnBounds = CGRectInset(btnBounds, -10, -10);</span><br><span class="line">    // 若点击的点在新的bounds里，返回YES</span><br><span class="line">    return CGRectContainsPoint(btnBounds, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="子视图超过父视图部分仍然能响应-重点"><a href="#子视图超过父视图部分仍然能响应-重点" class="headerlink" title="子视图超过父视图部分仍然能响应 重点"></a>子视图超过父视图部分仍然能响应 <strong>重点</strong></h1><p>重写 <code>hitTest:withEvent</code> 方法，让 <code>子视图</code> 去相应事件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 判断btn能否接收事件</span><br><span class="line">    if (self.btn.userInteractionEnabled == NO || self.btn.hidden == YES || self.btn.alpha &lt;= 0.01) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 把当前点转换成btn坐标系上的点</span><br><span class="line">    CGPoint btnP = [self convertPoint:point toView:self.btn];</span><br><span class="line">    // 当触摸点在btn上时，才让按钮相应事件</span><br><span class="line">    if ([self.btn pointInside:btnP withEvent:event]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,NSStringFromCGPoint(btnP));</span><br><span class="line">        return self.btn;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;父视图相应&quot;);</span><br><span class="line">    return [super hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="SDWebImage流程"><a href="#SDWebImage流程" class="headerlink" title="SDWebImage流程"></a>SDWebImage流程</h1><ol>
<li>入口 <code>setImageWithURL:placeholderImage:options:</code><br>会先把 <code>placeholderImage</code> 显示，然后 <code>SDWebImageManager</code> 根据 <code>URL</code> 开始处理图片。</li>
<li>进入 <code>SDWebImageManagerdownloadWithURL:delegate:options:userInfo:</code>，<br>交给 <code>SDImageCache</code> 从缓存查找图片是否已经下载<br><code>queryDiskCacheForKey:delegate:userInfo:</code></li>
<li>先从内存图片 <code>缓存查找</code> 是否有图片，如果内存中已经有图片缓存，<code>SDImageCacheDelegate</code> 会调用  <code>imageCache:didFindImage:forKey:userInfo:</code> 到 <code>SDWebImageManager</code>。</li>
<li><code>SDWebImageManagerDelegate</code> 会调 <code>webImageManager:didFinishWithImage:</code> 到 <code>UIImageView+WebCache</code> 等前端展示图片。</li>
<li>如果 <code>内存缓存中没有</code>，生成 <code>NSInvocationOperation</code> 添加到队列开始从 <code>硬盘查找</code> 图片是否已经缓存。</li>
<li>根据 <code>URLKey</code> 在硬盘缓存目录下尝试 <code>读取图片文件</code>，这一步是在 <code>NSOperation</code> 进行的操作，所以回主线程进行结果回调 <code>notifyDelegate</code>。</li>
<li>如果上一操作 <code>从硬盘读取到了图片</code>，将 <code>图片添加到内存缓存</code> 中（如果空闲内存过小，会先清空内存缓存）。<code>SDImageCacheDelegate</code> 回调<code>imageCache:didFindImage:forKey:userInfo:</code>，进而回调展示图片。</li>
<li>如果从 <code>硬盘缓存目录读取不到图片</code>，说明所有缓存都不存在该图片，需要 <code>下载图片</code>，<br>回调 <code>imageCache:didNotFindImageForKey:userInfo:</code>。</li>
<li>共享或重新生成一个下载器 <code>SDWebImageDownloader</code> 开始下载图片。</li>
<li>图片下载由 <code>NSURLConnection</code> 来做，实现相关 <code>delegate</code> 来判断图片下载中、下载完成和下载失败。</li>
<li><code>connection:didReceiveData:</code> 中利用 <code>ImageIO</code> 做了按图片下载进度加载效果。</li>
<li><code>connectionDidFinishLoading:</code> 数据下载完成后交给 <code>SDWebImageDecoder</code> 做图片解码处理。</li>
<li>图片解码处理在一个 <code>NSOperationQueue</code> 完成，不会拖慢主线程 <code>UI</code>。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。</li>
<li>在主线程 <code>notifyDelegateOnMainThreadWithInfo:</code> 宣告解码完成，<code>imageDecoder:didFinishDecodingImage:userInfo:</code> 回调给 <code>SDWebImageDownloader</code>。</li>
<li><code>imageDownloader:didFinishWithImage:</code> 回调给 <code>SDWebImageManager</code> 告知图片下载完成。</li>
<li>通知所有的 <code>downloadDelegates</code> 下载完成，回调给需要的地方展示图片。</li>
<li>将图片保存到 <code>SDImageCache</code> 中，<code>内存缓存和硬盘缓存同时保存</code>。写文件到硬盘也在以单独 <code>NSInvocationOperation</code> 完成，避免拖慢主线程。</li>
<li><code>SDImageCache</code> 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。<br>19）SDWebImage 也提供了 <code>UIButton+WebCache</code> 和 <code>MKAnnotationView+WebCache</code>，方便使用。<br>20）<code>SDWebImagePrefetcher</code> 可以预先下载图片，</li>
</ol>
<p><strong>缓存策略：</strong></p>
<ul>
<li><p>它的底层是用 <code>NSCache</code> 在实现的，<code>NSCache</code> 是 <code>Foundation框架</code> 提供的缓存类的实现，它是线程安全的。在内存不足时NSCache会自动释放存储的对象。key是不会重复的。</p>
</li>
<li><p>SDWebImage的缓存策略：缓存有关的一共有四个文件 <code>SDImageCacheConfig和SDImageCache，SDImageCacheConfig配置类</code>，保存一些缓存策略的信息（压缩图片-YES、iCloud备份-关闭、内存做缓存-YES、<code>最长时间默认1周</code>、缓存占用最大的空间-字节），</p>
</li>
<li><p>SDImageCache通过 <code>url作为key</code>，<code>UIImage作为value存到内存</code>。并开启异步串行队列将图片编码存储到磁盘中defalut文件下，key为url做了MD5加密并拼接defalut路径为绝对路径。</p>
</li>
</ul>
<h1 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h1><p>AFNetworking 底层原理分析：<br>AFNetworking主要是对 <code>NSURLSession</code> 的封装,<br>其中主要有以下类: </p>
<ul>
<li><code>AFHTTPSessionManager</code>：内部封装是 <code>NSURLSession</code>, <code>负责发送⽹络请求</code>，使<br>⽤最多的⼀个类。</li>
<li><code>AFNetworkReachabilityManager</code>：实时监测⽹络状态的⼯具类。当前的⽹络环<br>境发⽣改变之后,这个⼯具类就可以检测到。</li>
<li><code>AFSecurityPolicy</code>：⽹络安全的⼯具类, 主要是针对 <code>HTTPS</code> 服务。</li>
<li><code>AFURLRequestSerialization</code>：序列化⼯具类</li>
<li><code>AFURLResponseSerialization</code>：反序列化⼯具类</li>
<li><code>AFJSONResponseSerializer</code>：JSON解析器，默认的解析器.</li>
<li><code>AFHTTPResponseSerializer</code>：万能解析器， JSON和XML之外的数据类型，直接返<br>回⼆进制数据，对服务器返回的数据不做任何处理.</li>
</ul>
<h2 id="MJEetension"><a href="#MJEetension" class="headerlink" title="MJEetension"></a>MJEetension</h2><p>主要作用是将 <code>json -&gt; Model</code>，主要分为三步</p>
<ul>
<li>创建模型</li>
<li>为模型中的属性赋值</li>
<li>返回模型</li>
</ul>
<p>原理： </p>
<ul>
<li>使用 <code>Runtime</code> 动态获取模型的类和其所有父类的所有的 <code>属性名</code>（包括继承链的所有属性，MJExtension对模型的属性做了 <code>缓存</code>，下次转换时自己使用，空间换时间）</li>
<li>将服务器返回的 <code>json数据转为字典</code>，并根据属性名在数据字典中获取对应的 <code>值</code></li>
<li>将取出的值使用 <code>KVC</code>（setValue:forKey）设置给 <code>Model</code> 即可</li>
</ul>
<p>主要是用runtime API是实现的数据解析，将字典转模型</p>
<h2 id="MJRefresh"><a href="#MJRefresh" class="headerlink" title="MJRefresh"></a>MJRefresh</h2><p>下拉刷新的基本原理：<br>大部分的下拉刷新控件，都是用 <code>contentInset</code> 实现的。大部分的下拉刷新控件，都是将自己放在 <code>UIScrollView</code> 的上方，起始y设置成负数，所以平时不会显示出来，只有下拉的时候才会出现，放开又会弹回去。然后在loading的时候，临时把contentInset增大，相当于把UIScrollView往下挤，于是下拉刷新的控件就会显示出来，然后刷新完成之后，再把contentInset改回原来的值，实现回弹的效果</p>
<ul>
<li>通过 <code>UIScrollView+MJRefresh</code> 里的一个category，为UIScrollView增加了属性header和footer。</li>
<li>通过 <code>KVO</code> 监听UIScrollView的contentOffset和contentSize实现状态监听</li>
<li>下拉的时候临时增大contentInset，令header保留在屏幕上。上拉同理。</li>
</ul>
<h1 id="项目面试题"><a href="#项目面试题" class="headerlink" title="项目面试题"></a>项目面试题</h1><h2 id="直播功能怎么实现的？"><a href="#直播功能怎么实现的？" class="headerlink" title="直播功能怎么实现的？"></a>直播功能怎么实现的？</h2><p>直播间是通过集成金山云SDK实现的，分为两端 <code>主播</code> 和 <code>观众</code></p>
<ul>
<li>主播</li>
</ul>
<p>通过 <code>推流</code> 创建直播间，通过 <code>摄像头和麦克风</code> 获取 <code>音视频流</code> ，设置 <code>推流参数</code>，主要是 视频编码器和音频编码率的设置，设置完推流参数之后，将流媒体推送服务器</p>
<ul>
<li>观众</li>
</ul>
<p>进入直播间，初始化播放器，从服务器获取播放拉流的数据 </p>
<h2 id="直播间的聊天IM实现？"><a href="#直播间的聊天IM实现？" class="headerlink" title="直播间的聊天IM实现？"></a>直播间的聊天IM实现？</h2><ul>
<li><p>聊天功能是使用的融云SDK，通过加入聊天室实现的。</p>
</li>
<li><p>融云SDK实现了私聊的功能</p>
</li>
<li><p>自己写的聊天页面，通过 <code>融云接口</code> 传入参数 <code>会话类型：单聊、群组。聊天室等</code>，目标会话ID），消息数量，获取某个会话的内容。发送文本消息、图片消息，监听消息，刷新列表</p>
</li>
</ul>
<h1 id="面试官问还有什么想问的？-重点"><a href="#面试官问还有什么想问的？-重点" class="headerlink" title="面试官问还有什么想问的？ 重点"></a>面试官问还有什么想问的？ <strong>重点</strong></h1><p>技术面不问薪资待遇，人事面问薪资待遇</p>
<ul>
<li>问岗位：</li>
</ul>
<ol>
<li>在这个岗位上，会直接 <code>接触到哪些类型的项目？</code></li>
<li>这个岗位的主要职责是什么？主要的KPI是什么？</li>
<li>这个岗位如何评估绩效，试用期需要达到什么指标？</li>
<li>这个岗位的最大挑战是什么？</li>
</ol>
<ul>
<li>问团队：</li>
</ul>
<ol>
<li><code>团队的基本情况？</code></li>
<li>这个团队在公司的角色是什么？</li>
<li>可以跟我介绍一下我的领导吗？</li>
</ol>
<ul>
<li>问公司</li>
</ul>
<ol>
<li><code>公司的文化氛围是什么样的？</code></li>
<li>员工的晋升机制是什么样的？我这个岗位的晋升机会如何？</li>
<li>这个岗位所在的团队如何支持公司目标的实现？</li>
</ol>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：OC面试题：总结</li>
        <li>Post author：张建</li>
        <li>Create time：2023-03-01 16:57:33</li>
        <li>
            Post link：https://redefine.ohevan.com/2023/03/01/面试题/OC面试题：总结/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/BboyZJ.github.io/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/">#OC-面试题</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/BboyZJ.github.io/2023/03/01/%E9%9D%A2%E8%AF%95%E9%A2%98/Swift%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%80%BB%E7%BB%93/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">iOS面试题：Swift</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-04%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">Blog-04：主题完善</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">OC面试题：总结</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-text">算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Runloop"><span class="nav-text">Runloop</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Runtime"><span class="nav-text">Runtime</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Block"><span class="nav-text">Block</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-text">链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8E%E6%8C%87%E9%92%88%EF%BC%9F"><span class="nav-text">什么是野指针？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="nav-text">什么是内存泄漏？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS-%E5%85%B3%E9%94%AE%E8%AF%8D%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">iOS 关键词有哪些？各有什么作用？ 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E9%87%8D%E7%82%B9"><span class="nav-text">浅拷贝和深拷贝 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSString-x2F-NSArray-x2F-NSDictionary%E5%92%8CNSMutableString-x2F-NSMutableArray-x2F-NSMutableDictionary-%E8%BF%9B%E8%A1%8Ccopy%E5%92%8CmutableCopy%E5%8C%BA%E5%88%AB%EF%BC%9F%E9%87%8D%E7%82%B9"><span class="nav-text">NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%9A%84copy%E5%92%8CmutableCopy%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">自定义对象的copy和mutableCopy？ 重点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%94%A8copy%E8%BF%98%E6%98%AFstrong%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">属性用copy还是strong？ 重点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AAAPP%E6%98%AF%E5%A6%82%E4%BD%95%E5%94%A4%E9%86%92%E5%8F%A6%E4%B8%80%E4%B8%AAAPP%E7%9A%84%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">一个APP是如何唤醒另一个APP的？ 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UIView%E5%92%8CCALayer"><span class="nav-text">UIView和CALayer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E7%9A%84%E5%86%99%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">单例的写法和作用？ 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-text">常用的数据存储方式有哪些？各自的优缺点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%90%84%E8%87%AA%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">加密方式有哪些？各自的加密算法哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">成员变量和实例变量区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#property-%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Fivar%E3%80%81getter%E3%80%81setter-%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E8%BF%99%E4%B8%AA%E7%B1%BB%E4%B8%AD%E7%9A%84"><span class="nav-text">@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#frame-%E5%92%8C-bounds-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">frame 和 bounds 区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F"><span class="nav-text">常见的状态码？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">HTTPS和HTTP的区别？ 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E5%92%8C-UDP-%E5%8C%BA%E5%88%AB-%E9%87%8D%E7%82%B9"><span class="nav-text">TCP 和 UDP 区别? 重点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP%E5%92%8Csocket%E5%8C%BA%E5%88%AB%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">HTTP和socket区别？ 重点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#staitc-%E5%92%8C-const-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">staitc 和 const 的区别？ 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E9%93%BE%E6%8E%A5%EF%BC%88Universal-Links%EF%BC%89%E9%87%8D%E7%82%B9"><span class="nav-text">通用链接（Universal Links）重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0GET%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">简述GET和POST请求的区别？ 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">iOS中几种常见的设计模式？  重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">RunLoop是什么？ 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">RunLoop的作用？ 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E7%94%A8Runloop%E5%AE%9E%E7%8E%B0%E4%BB%80%E4%B9%88%E5%8A%9F%E8%83%BD%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">可以用Runloop实现什么功能？ 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop%E6%8E%A5%E6%94%B6%E5%87%A0%E7%A7%8D%E8%BE%93%E5%85%A5%E6%BA%90%EF%BC%8C%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E5%AE%9A%E4%B9%89%E4%BA%86%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">RunLoop接收几种输入源，系统默认定义了几种模式？ 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9FRunloop%E7%9A%84mode-Runloop%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？ 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3Objective-C%E6%98%AF%E5%8A%A8%E6%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E8%A8%80%E3%80%82-%E9%87%8D%E7%82%B9"><span class="nav-text">怎么理解Objective-C是动态运行时语言。 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runtime%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">runtime项目中具体应用？ 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KVC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E9%87%8D%E7%82%B9"><span class="nav-text">KVC是什么？重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KVO%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E9%87%8D%E7%82%B9"><span class="nav-text">KVO是什么？重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KVO%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F-KVO%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">KVO的实现原理？(KVO的本质是什么？) 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KVO%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8-%E9%87%8D%E7%82%B9"><span class="nav-text">KVO实际应用 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#category%E5%92%8Cextension%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%88%86%E4%B8%A4%E7%B1%BB%E5%92%8C%E6%89%A9%E5%B1%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%88%86%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F%E9%87%8D%E7%82%B9"><span class="nav-text">category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？重点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#load%E3%80%81initialize%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E5%9C%A8category%E9%87%8D%E5%86%99%E7%9A%84%E6%97%B6%E5%80%99%E7%9A%84%E8%B0%83%E7%94%A8%E7%9A%84%E6%AC%A1%E5%BA%8F%EF%BC%9F"><span class="nav-text">load、initialize的区别，以及它们在category重写的时候的调用的次序？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#super%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9F"><span class="nav-text">super的本质？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%8BObjective-C%E4%B8%AD%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-text">简述下Objective-C中调用方法的过程？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">循环引用的几种情况和解决方式？ 重点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#OC-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">OC 如何进行内存管理的？ 重点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E5%8E%9F%E7%90%86-%E9%87%8D%E7%82%B9"><span class="nav-text">自动释放池原理 重点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96-%E9%87%8D%E7%82%B9"><span class="nav-text">内存优化 重点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96-%E9%87%8D%E7%82%B9"><span class="nav-text">启动优化 重点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%A1%E9%A1%BF%E7%9B%91%E5%90%AC-%E9%87%8D%E7%82%B9"><span class="nav-text">卡顿监听 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tableView%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96-%E9%87%8D%E7%82%B9"><span class="nav-text">tableView卡顿优化 重点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96-%E9%87%8D%E7%82%B9"><span class="nav-text">网络优化 重点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B%EF%BC%9F%E9%87%8D%E7%82%B9"><span class="nav-text">TCP三次握手，四次挥手过程？重点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E9%93%BE-%E9%87%8D%E7%82%B9"><span class="nav-text">事件链 重点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">事件传递的两个核心方法？ 重点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE%E7%9A%84%E7%82%B9%E5%87%BB%E8%8C%83%E5%9B%B4%E6%89%A9%E5%A4%A7%E6%95%88%E6%9E%9C-%E9%87%8D%E7%82%B9"><span class="nav-text">实现一个按钮的点击范围扩大效果 重点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%90%E8%A7%86%E5%9B%BE%E8%B6%85%E8%BF%87%E7%88%B6%E8%A7%86%E5%9B%BE%E9%83%A8%E5%88%86%E4%BB%8D%E7%84%B6%E8%83%BD%E5%93%8D%E5%BA%94-%E9%87%8D%E7%82%B9"><span class="nav-text">子视图超过父视图部分仍然能响应 重点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SDWebImage%E6%B5%81%E7%A8%8B"><span class="nav-text">SDWebImage流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AFNetworking"><span class="nav-text">AFNetworking</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MJEetension"><span class="nav-text">MJEetension</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MJRefresh"><span class="nav-text">MJRefresh</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">项目面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%92%AD%E5%8A%9F%E8%83%BD%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-text">直播功能怎么实现的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%92%AD%E9%97%B4%E7%9A%84%E8%81%8A%E5%A4%A9IM%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-text">直播间的聊天IM实现？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E6%83%B3%E9%97%AE%E7%9A%84%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">面试官问还有什么想问的？ 重点</span></a></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2019</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">张建</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        VISITOR COUNT&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        TOTAL PAGE VIEWS&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a></span>
                <br> 
            <span class="theme-version-container">THEME&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v1.1.5</a>
        </div>
        
        
        
            <div id="start_time_div" style="display:none">
                2019/8/17 11:45:14
            </div>
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="unfolded-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="fa-regular fa-arrow-up"></i>
            </li>
        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="folded-tools-list">
        <li class="right-bottom-tools tool-toggle-show flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>




<script src="/BboyZJ.github.io/js/utils.js"></script>

<script src="/BboyZJ.github.io/js/main.js"></script>

<script src="/BboyZJ.github.io/js/layouts/menu-shrink.js"></script>

<script src="/BboyZJ.github.io/js/tools/go-top-bottom.js"></script>

<script src="/BboyZJ.github.io/js/tools/dark-light-toggle.js"></script>



    
<script src="/BboyZJ.github.io/js/tools/local-search.js"></script>




    
<script src="/BboyZJ.github.io/js/tools/code-block.js"></script>






    
<script src="/BboyZJ.github.io/js/tools/runtime.js"></script>

    
<script src="/BboyZJ.github.io/js/layouts/odometer.min.js"></script>

    
<link rel="stylesheet" href="/BboyZJ.github.io/assets/odometer-theme-minimal.css">





<div class="post-scripts pjax">
    
        
<script src="/BboyZJ.github.io/js/tools/toc-toggle.js"></script>

<script src="/BboyZJ.github.io/js/libs/anime.min.js"></script>

<script src="/BboyZJ.github.io/js/layouts/toc.js"></script>

<script src="/BboyZJ.github.io/js/plugins/tabs.js"></script>

    
    
</div>


    
<script src="/BboyZJ.github.io/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>




<script src="/BboyZJ.github.io/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
