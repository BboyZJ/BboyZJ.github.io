<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="我是小J，关注我">
    <meta name="author" content="张建">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://www.bboyzj.cn/2023/03/03/swift课程/swift学习34：闭包/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Swift学习34：闭包">
    <meta property="og:description" content="我是小J，关注我">
    <meta property="og:url" content="https://www.bboyzj.cn2023/03/03/Swift课程/Swift学习34：闭包/">
    <meta property="og:image" content="/images/redefine-logo.svg">
    <meta property="og:site_name" content="BboyZJ">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Swift学习34：闭包">
    <meta name="twitter:description" content="我是小J，关注我">
    <meta name="twitter:image" content="/images/redefine-logo.svg">
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/BboyZJ.github.io/images/redefine-logo.svg">
    
    <title>
        
            Swift学习34：闭包 -
        
        BboyZJ
    </title>
    
<link rel="stylesheet" href="/BboyZJ.github.io/css/style.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/assets/fonts.css">

    
    
    
    
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"www.bboyzj.cn","root":"/BboyZJ.github.io/","language":"en","path":"search.xml"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/head_img.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"学无止境 学而不思则罔 思而不学则殆","custom_font":{"enable":false,"font_family":null,"font_url":null}},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_block":{"copy":true,"style":"mac","custom_font":{"enable":false,"font_family":null,"font_url":null}},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"1.1.5","friend_links":{"columns":2},"home_article":{"date_format":"auto","category":{"enable":true,"limit":3},"tag":{"enable":true,"limit":3}},"plugins":{"aplayer":{"enable":false,"audio":[{"name":null,"artist":null,"url":null,"cover":null},{"name":null,"artist":null,"url":null,"cover":null}]}}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/BboyZJ.github.io/atom.xml" title="张建的博客" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="menu-wrapper">
    
    <div class="menu-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                BboyZJ
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        首页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/tags/"  >
                                    
                                        
                                            <i class="fa-regular fa-tags"></i>
                                        
                                        标签
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/categories/"  >
                                    
                                        
                                            <i class="fa-regular fa-categories"></i>
                                        
                                        分类
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="menu-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                首页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/tags/"  >
                             
                                
                                    <i class="fa-regular fa-tags"></i>
                                
                                标签
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/categories/"  >
                             
                                
                                    <i class="fa-regular fa-categories"></i>
                                
                                分类
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">Swift学习34：闭包</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/BboyZJ.github.io/images/head_img.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">张建</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2023-03-03 22:56:01</span>
        <span class="mobile">2023-03-03 22:56</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="pc">2023-04-12 23:05:51</span>
            <span class="mobile">2023-04-12 23:05</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/BboyZJ.github.io/categories/Swift/">Swift</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/BboyZJ.github.io/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/">Swift-课程篇</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h1><ul>
<li><p>闭包是 <code>可以在你的代码中被传递和引用的功能性独立代码块</code></p>
</li>
<li><p>闭包能够 <code>补获和存储上下文的常量和变量</code>。这就是所谓的闭合并包裹哪些常量和变量，因此称为 <code>闭包</code>，Swift能够为你处理所有关于补获的内存管理操作</p>
</li>
<li><p><code>全局和内嵌函数</code>，实际上是 <code>特殊的闭包</code>。闭包符合以下三种形式的一种</p>
<ul>
<li><p>全局函数：是一个 <code>有名字但不会补获任何值</code> 的 <code>闭包</code></p>
</li>
<li><p>内嵌函数：是一个 <code>有名字且能从其上下层函数补获值</code> 的 <code>闭包</code></p>
</li>
<li><p>闭包表达式：是一个轻量级语法所写的 <code>可以补获其上下文中常量和变量值的没有名字的闭包</code></p>
</li>
</ul>
</li>
</ul>
<h1 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h1><ul>
<li><p>闭包可以作为函数的 <code>参数</code> 也可以作为函数的 <code>返回值</code></p>
</li>
<li><p>闭包可以像 <code>oc</code> 中用于 <code>回调和反向传值</code></p>
</li>
</ul>
<h1 id="设置属性默认值"><a href="#设置属性默认值" class="headerlink" title="设置属性默认值"></a>设置属性默认值</h1><ul>
<li><code>闭包</code> 可以为 <code>存储属性</code> 设置默认值</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 通过闭包设置默认值</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String &#123;</span><br><span class="line">        return &quot;ZJ&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = Person()</span><br><span class="line">print(p.name)</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">ZJ</span><br></pre></td></tr></table></figure></div>

<h1 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h1><ul>
<li>全局函数： 是一种特殊的闭包，定义一个全局函数，只是当前的全局函数并不捕获值。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 有名字但不会补获值的闭包</span><br><span class="line">func test()&#123;</span><br><span class="line">    print(&quot;test&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="内嵌函数："><a href="#内嵌函数：" class="headerlink" title="内嵌函数："></a>内嵌函数：</h1><ul>
<li>全局函数： 是一种特殊的闭包，可以捕获值的闭包。函数中的 <code>incrementer</code> 是一个 <code>内嵌函数</code>，可以从 <code>makeIncrementer</code> 中捕获变量 <code>runningTotal</code>。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func makeIncrementer() -&gt; () -&gt; Int&#123;</span><br><span class="line">    var runningTotal = 10</span><br><span class="line">    // 内嵌函数，有名字会从上下层函数补获值的闭包</span><br><span class="line">    func incrementer() -&gt; Int&#123;</span><br><span class="line">        runningTotal += 1</span><br><span class="line">        return runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    return incrementer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let incre = makeIncrementer()</span><br><span class="line">print(incre())</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h1 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h1><ul>
<li>闭包表达式 &#x2F; 匿名函数：下面是一个 <code>闭包表达式</code>，即一个 <code>匿名函数</code>，而且可以 <code>从上下文中捕获变量和常量</code>。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 闭包表达式：没有名字能从上下文补获值的闭包</span><br><span class="line">&#123; (参数列表) -&gt; 返回值类型 in</span><br><span class="line">    // 主体内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>参数可以有多个，用 , 号隔开</li>
<li>参数的 () 可以省略</li>
<li>返回值类型也可以省略</li>
<li>当没有参数时 in 可以省略</li>
<li>in 可以看做是一个分隔符，将主体内容和前面的参数、返回值分割开</li>
</ul>
<blockquote>
<p>闭包表达式特点：是一个 <code>匿名函数</code>，所有代码都在花括号 <code>&#123;&#125;</code> 内，<code>参数和返回值类型</code> 在 <code>in关键字</code> 之前，<code>in关键字</code> 之后是 <code>主体内容(类似方法体)</code>。</p>
</blockquote>
<p>1、有参数、有返回值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个闭包 赋值 给常量 test</span><br><span class="line">let test: (String,String) -&gt; String = &#123; (str1,str2) -&gt; String in</span><br><span class="line">    return str1 + str2</span><br><span class="line">&#125;</span><br><span class="line">print(test(&quot;Z&quot;,&quot;J&quot;))</span><br><span class="line">// 打印结果 ZJ</span><br></pre></td></tr></table></figure></div>

<p>: 的右边是闭包的类型，&#x3D; 右边就是一个闭包表达式，也可以理解为一个闭包<br>&#x3D; 右边是严格按照了闭包表达式来写的，有参数，有括号，有返回值。<br>下面看一下闭包表达式的简写：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 简写</span><br><span class="line">let test = &#123; str1,str2 -&gt; String in</span><br><span class="line">    return str1 + str2</span><br><span class="line">&#125;</span><br><span class="line">print(test(&quot;Z&quot;,&quot;J&quot;))</span><br></pre></td></tr></table></figure></div>

<p>实际上和上面是等价的，闭包表达式省去了参数的括号。<br>：右边的闭包类型省去了是因为swift编译器能自动根据 &#x3D; 右边去判断类型</p>
<p>2、无参无返回值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 无参无返回值</span><br><span class="line">let test: () -&gt; Void = &#123; () -&gt; Void in</span><br><span class="line">    print(&quot;ZJ&quot;)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line">// 打印结果 ZJ</span><br></pre></td></tr></table></figure></div>

<p>因为无返回值，我们可以直接调用查看打印结果<br>下面看一下闭包表达式简写：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 简写</span><br><span class="line">let test = &#123;</span><br><span class="line">    print(&quot;ZJ&quot;)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure></div>

<p>因为没有参数也没有返回值都可以省略</p>
<h1 id="闭包是引用类型"><a href="#闭包是引用类型" class="headerlink" title="闭包是引用类型"></a>闭包是引用类型</h1><ul>
<li><p>在swift中，<code>函数和闭包都是引用类型</code></p>
</li>
<li><p>无论是什么时候赋值给 <code>函数或闭包</code> 一个 <code>常量或变量</code>，实际上都是将常量和变量设置为对函数和闭包的 <code>引用</code></p>
</li>
<li><p>如果类实例的 <code>属性</code> 是一个 <code>闭包</code>，并且闭包通过引用该实例或者它的成员来捕获实例，你将在闭包和实例间会产生 <code>循环引用</code></p>
</li>
</ul>
<h1 id="闭包作为函数的参数"><a href="#闭包作为函数的参数" class="headerlink" title="闭包作为函数的参数"></a>闭包作为函数的参数</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func exec(fn: (Int,Int) -&gt; Int, v1: Int, v2: Int) &#123;</span><br><span class="line">    /*</span><br><span class="line">     fn: (Int,Int) -&gt; Int = &#123;a,b -&gt; Int in return a + b&#125;</span><br><span class="line">     print(fn(1,2))</span><br><span class="line">     */</span><br><span class="line">    print(fn(v1,v2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数有 <code>3</code> 个参数：第一个参数是个闭包<br>下面是exec函数的调用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func exec(fn: (Int,Int) -&gt; Int, v1: Int, v2: Int) &#123;</span><br><span class="line">    /*</span><br><span class="line">     fn: (Int,Int) -&gt; Int = &#123;a,b -&gt; Int in return a + b&#125;</span><br><span class="line">     print(fn(1,2))</span><br><span class="line">     */</span><br><span class="line">    print(fn(v1,v2)) // 打印结果 2</span><br><span class="line">&#125;</span><br><span class="line">// 调用这个函数</span><br><span class="line">exec(fn: &#123; a, b in</span><br><span class="line">    return a + b</span><br><span class="line">&#125;, v1: 1, v2: 2)</span><br></pre></td></tr></table></figure></div>

<p>exec函数调用时，<code>&#123;&#125;</code> 里就是一个闭包表达式，可以看做是函数第一个参数的实现<br>这样的函数调用形式看起来很不友好，如果闭包表达式有很多行的话，会更加不友好，不利于代码的阅读。swift提供了一个 <code>尾随闭包</code> 的概念</p>
<h1 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h1><ul>
<li>当函数的最后一个参数是函数时，在函数调用时可以把闭包表达式写在 <code>()</code> 外面</li>
<li>尾随闭包是一个书写在函数 <code>()</code> 之后的闭包表达式</li>
<li>如果将一个很长的闭包表达式作为函数的最后一个实参，使用闭包可以增强函数的可读性</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func exec(v1: Int, v2: Int, fn: (Int, Int) -&gt; Int) &#123;</span><br><span class="line">    print(fn(v1,v2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这次把exec函数的第一个参数fn放到了最后，下面可以看下调用方式和上次的有什么不同</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec(v1: 1, v2: 2) &#123; a, b in</span><br><span class="line">    return 1 + 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>根上一次的函数对比，这次是把闭包写在了函数 <code>()</code> 之后，增强了代码的可读性，这就是 <code>尾随闭包</code></p>
<ul>
<li>可以使用 <code>高阶函数</code> 简化参数名，如 $0,$1(从0开始，表示第i个参数…)</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec(v1: 1, v2: 2) &#123;</span><br><span class="line">    return $0 + $1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>还有很多简写方式就不一一举例了，太简写也不利于代码阅读</p>
<ul>
<li>如果闭包表达式是函数的唯一实参，而且使用了尾随闭包的语法，可以将函数名后边的 <code>()</code> 省略</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 只有一个闭包为实参</span><br><span class="line">func exec(fn: (Int,Int) -&gt; Int) &#123;</span><br><span class="line">    print(fn(1,2))</span><br><span class="line">&#125;</span><br><span class="line">exec &#123; a, b in</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<ul>
<li><code>array.sorted</code> 就是一个尾随闭包，且这个函数就 <code>只有一个参数</code>，如下所示：</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// array.sorted就是一个尾随闭包</span><br><span class="line">var arr = [1,2,3]</span><br><span class="line">// 1.完整写法</span><br><span class="line">arr.sorted &#123; (item1: Int,item2: Int) -&gt; Bool in</span><br><span class="line">    return item1 &gt; item2</span><br><span class="line">&#125;</span><br><span class="line">// 2.省略参数类型：通过arr中的参数推断类型</span><br><span class="line">arr.sort &#123; (item1,item2) -&gt; Bool in</span><br><span class="line">    return item1 &gt; item2</span><br><span class="line">&#125;</span><br><span class="line">// 3.省略参数类型 + 返回值类型：通过return推断返回值类型</span><br><span class="line">arr.sorted &#123; (item1,item2) in</span><br><span class="line">    return item1 &gt; item2</span><br><span class="line">&#125;</span><br><span class="line">// 4.省略参数类型 + 返回值类型 + return关键字：单表达式可以隐士表达，即省略return关键字</span><br><span class="line">arr.sorted &#123; (item1, item2) in</span><br><span class="line">    item1 &lt; item2</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">// 5.参数名称简写</span><br><span class="line">arr.sorted &#123; return $0 &lt; $1 &#125;</span><br><span class="line">// 6.参数名称简写 + 省略return关键字</span><br><span class="line">arr.sorted &#123; $0 &lt; $1 &#125;</span><br><span class="line">// 7.最简：直接传比较符号</span><br><span class="line">arr.sorted (by: &lt;)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>闭包的优点：<br>1、利用上下文推断参数和返回类型；<br>2、单表达式可以隐式返回，省略return关键字；<br>3、参数名称可以直接使用简写(如$0,$1,元组的$0.0)；<br>4、尾随闭包可以更简洁的表达。</p>
</blockquote>
<h1 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h1><ul>
<li><p>如果一个闭包作为一个函数的参数，并且在函数执行完之后才被执行，那么这种情况下的闭包就是 <code>逃逸闭包</code></p>
</li>
<li><p>在参数名 <code>:</code> 号后面加 <code>@escaping</code> 修饰符说明 <code>逃逸闭包</code></p>
</li>
</ul>
<p>逃逸闭包的使用场景，①异步线程网络请求，延迟方法，②作为属性存储，在后面进行调用。</p>
<p>1、在 <code>延迟方法</code> 中调用逃逸闭包</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 闭包作为属性</span><br><span class="line">class Animal &#123;</span><br><span class="line">    // 函数参数使用@escaping修饰，表示允许函数返回之后调用</span><br><span class="line">    func getData(amount: Int,handler: @escaping (String) -&gt; Void) &#123;</span><br><span class="line">        // 延迟5s</span><br><span class="line">        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 5) &#123;</span><br><span class="line">            // 假设是请求得到的数据</span><br><span class="line">            var str: String = &quot;my is data&quot;</span><br><span class="line">            // 5s后调用</span><br><span class="line">            handler(&quot;\(str) : \(amount)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        print(&quot;函数执行完了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 返回数据</span><br><span class="line">    func backData(success: @escaping (String) -&gt; Void) &#123;</span><br><span class="line">        // 请求数据</span><br><span class="line">        getData(amount: 10) &#123; data in</span><br><span class="line">            // 拿到数据</span><br><span class="line">            success(&quot;success：\(data)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;Animal deinit&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var t = Animal()</span><br><span class="line">// 拿到数据</span><br><span class="line">t.backData &#123; data in</span><br><span class="line">    print(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">函数执行完了</span><br><span class="line">success：my is data : 10</span><br></pre></td></tr></table></figure></div>

<p>当前方法执行的过程中不会等待闭包执行完成后再执行，而是直接返回，所以 <code>当前闭包的生命周期要比方法长</code>。</p>
<p>2、闭包作为属性：</p>
<blockquote>
<p>当闭包作为存储属性时，主要有以下几点说明：<br>1、定义一个闭包属性；<br>2、在方法中对闭包属性进行赋值；<br>3、在合适的时机调用（与业务逻辑相关）。</p>
</blockquote>
<ul>
<li>逃逸闭包 vs 非逃逸闭包 区别</li>
</ul>
<p>1、非逃逸闭包：一个接受 <code>闭包作为参数</code> 的函数，闭包是在这个 <code>函数结束前</code> 被调用，即可以理解为闭包是在函数作用域结束前被调用。<br>1.1<code>不会产生循环引用</code>，因为闭包的作用域在函数作用域内，在函数执行完成后，就会释放闭包捕获的所有对象；<br>1.2针对非逃逸闭包，编译器会做优化：<code>省略内存管理调用</code>；<br>1.3非逃逸闭包捕获的上下文保存在 <code>栈上</code>，而不是堆上（官方文档说明）。</p>
<p>2.逃逸闭包：一个接受 <code>闭包作为参数</code> 的函数，逃逸闭包可能会在 <code>函数返回之后</code> 才被调用，即闭包逃离了函数的作用域。<br>2.1可能会 <code>产生循环引用</code>，因为逃逸闭包中需要 <code>显式</code> 的引用 <code>self</code>（猜测其原因是为了提醒开发者，这里可能会出现循环引用了），而self可能是持有闭包变量的（与 <code>OC中block</code> 的的循环引用类似）；<br>2.2一般用于异步函数的返回，例如网络请求。</p>
<p>3.使用建议：如果没有特别需要，开发中使用非逃逸闭包是 <code>有利于内存优化的</code>，所以苹果把闭包区分为两种，特殊情况时再使用逃逸闭包。</p>
<p>4.总结：主要区别就是 <code>调用时机和内存管理不同</code>。</p>
<h1 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h1><ul>
<li>在参数名的 <code>:</code> 后面加 <code>@autoclosure</code> 修饰符来说明 <code>自动闭包</code></li>
<li>@autoclosure 只支持 <code>()-&gt; T</code> 格式的参数</li>
<li>@autoclosure 会自动将 <code>10</code> 封装成闭包 <code>&#123;20&#125;</code></li>
<li>@autoclosure 并非只支持最后 <code>1</code> 个参数</li>
<li>有@autoclosure和无@autoclosure构成了函数重载</li>
<li>空合并运算符 <code>??</code> 使用了@autoclosure技术</li>
</ul>
<p>先分析为什么会有自动闭包，自动闭包能实现什么作用<br>先看下面的一个函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func getInt(_ a: Int, _ b: () -&gt; Int) -&gt; Int &#123;</span><br><span class="line">    return a &gt; 0 ? a : b()</span><br><span class="line">&#125;</span><br><span class="line">getInt(1) &#123;</span><br><span class="line">    return 2</span><br><span class="line">&#125;</span><br><span class="line">// 打印结果是 1</span><br></pre></td></tr></table></figure></div>

<p>getInt函数调用时使用了一个尾随闭包，当参数满足 <code>()-&gt; T</code> 这个格式时可以写成 <code>自动闭包</code>，会使代码阅读起来更直观</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func getInt(_ a: Int, _ b: @autoclosure () -&gt; Int) -&gt; Int &#123;</span><br><span class="line">    return a &gt; 0 ? a : b()</span><br><span class="line">&#125;</span><br><span class="line">getInt(1, 2)</span><br><span class="line">// 打印结果是 1</span><br></pre></td></tr></table></figure></div>

<p>需要注意的是 <code>自动闭包</code> 会有 <code>延迟执行</code> 的特点，会在函数内部调用时才会执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func getInt(_ a: Int, _ b: @autoclosure () -&gt; Int) -&gt; Int &#123;</span><br><span class="line">    return a &gt; 0 ? a : b()</span><br><span class="line">&#125;</span><br><span class="line">func exec() -&gt; Int &#123;</span><br><span class="line">    print(&quot;执行了exec&quot;)</span><br><span class="line">    return 20</span><br><span class="line">&#125;</span><br><span class="line">getInt(1, exec())</span><br><span class="line">// 打印结果是 1</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>getInt(1, exec())</code> 函数调用时，很容易误以为 <code>exec()</code> 就已经调用了函数 <code>exec</code>，其实并没有，<code>exec</code> 内部没有执行。这是因为 <code>自动闭包有延迟执行的特点</code>。<br><code>getInt(1, exec())</code> 函数内部因为 <code>a&gt;0 </code>返回的结果是 <code>a</code> 的值，并没有调用到 <code>b()</code>，所以 <code>exec</code> 函数没有执行。<br>只有当 <code>getInt(1, exec())</code> 函数内部调用到了 <code>b()</code>，<code>exec</code> 函数才会被执行</p>
</blockquote>
<h1 id="闭包对变量的捕获"><a href="#闭包对变量的捕获" class="headerlink" title="闭包对变量的捕获"></a>闭包对变量的捕获</h1><ul>
<li>闭包可以对外部函数的 <code>变量/常量</code> 进行捕获</li>
<li>闭包捕获的时机是在函数执行完，return时再去捕获</li>
<li>当函数里有多个闭包时，只会对 <code>变量/常量</code> 捕获一次，多个闭包对捕获的 <code>变量/常量</code> 共享</li>
<li>闭包不会对全局变量进行捕获</li>
</ul>
<p>下面由几份代码来说明这个结论</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 变量捕获</span><br><span class="line">// MARK:局部变量捕获</span><br><span class="line">typealias fn = (Int) -&gt; Void</span><br><span class="line">func exec() -&gt; fn &#123;</span><br><span class="line">    var num = 0</span><br><span class="line">    return &#123; a in</span><br><span class="line">        num += a</span><br><span class="line">        print(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let res = exec()</span><br><span class="line">res(1)</span><br><span class="line">res(2)</span><br><span class="line">res(3)</span><br></pre></td></tr></table></figure></div>

<p>res(1)、res(2)、res(3) 输出的结果分别是 1、3、6<br>这是一个函数中返回的闭包，在闭包里对 <code>num</code> 进行了累加并输出结果</p>
<blockquote>
<p>1、第一次调用res时，num为0，0加上参数1&#x3D;1<br>2、第二次调用res时，闭包里的num的值是第一次res里的累加结果1，1加上参数2&#x3D;3<br>3、第三次调用res时，闭包里num是第二次res里累加的结果3，3加上参数3&#x3D;6<br>从三次调用res来看，闭包里num都是保存了上次调用后num的值，这是因为闭包捕获了外部的num，并重新在<code> 堆</code> 上 <code>分配了内存</code>，实际上是修改 <code>堆区中的value值</code>，当执行let res &#x3D; exec()时，把闭包的内存地址给了res,所以每次调用res都是调用的同一块内存，同一个闭包，闭包里有保存中捕获后的num的内存地址，所以每次调用都是同一个num </p>
</blockquote>
<p>可以把闭包想象成是一个类的实例对象，<code>内存在堆空间</code>，捕获的 <code>局部变量/常量</code> 就是对象的成员(存储属性)，组成闭包的函数就是类内部定义的方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let res1 = exec()</span><br><span class="line">res1(1)</span><br><span class="line">let res2 = exec()</span><br><span class="line">res2(1)</span><br></pre></td></tr></table></figure></div>

<p>将上面的代码稍微改一下，将exec分别赋值给res1和res2，输出的结果为1和1。这个为什么不是跟上面一样累加呢，因为exec分别赋值给了res1和res2，res1和res2指向的是两个不一样的地址，当每调用一次exec()函数，num会初始化为0</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typealias fn = (Int) -&gt; Void</span><br><span class="line">func exec() -&gt; fn &#123;</span><br><span class="line">    var num = 0</span><br><span class="line">    func plus(a: Int) -&gt; Void&#123;</span><br><span class="line">        num += a</span><br><span class="line">        print(num)</span><br><span class="line">    &#125;</span><br><span class="line">    num = 6</span><br><span class="line">    </span><br><span class="line">    return plus</span><br><span class="line">&#125;</span><br><span class="line">let res = exec()</span><br><span class="line">res(1)</span><br></pre></td></tr></table></figure></div>

<p>上面这份代码输出的num又是多少呢？答案是7</p>
<blockquote>
<p>这还是一个局部变量捕获的问题，闭包会在函数执行完，return的时候才会去捕获num，此时num已经由0变为6，所以执行res(1)输出结果为7</p>
</blockquote>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typealias fn = (Int) -&gt; Void</span><br><span class="line">func exec() -&gt; (fn, fn) &#123;</span><br><span class="line">    var num = 0</span><br><span class="line">    func plus(a: Int) &#123;</span><br><span class="line">        num += a</span><br><span class="line">        print(&quot;plus:&quot;, num)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func minus(a: Int) &#123;</span><br><span class="line">        num -= a</span><br><span class="line">        print(&quot;minus:&quot;, num)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (plus, minus)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let (p, m) = exec()</span><br><span class="line">p(5)</span><br><span class="line">m(4)</span><br></pre></td></tr></table></figure></div>

<p>这份代码函数返回了一个元祖，元祖里是两个闭包，两个闭包里面都调用了num，输出的结果为：<br>plus: 5<br>minus: 1</p>
<p>因为当函数里有多个闭包时，只会对变量&#x2F;常量捕获一次，多个闭包对捕获的变量&#x2F;常量共享</p>
<blockquote>
<p>因为当函数里有多个闭包时，只会对变量&#x2F;常量捕获一次，多个闭包对捕获的变量&#x2F;常量共享。在调用m(4)时，前面已经调用过p(5)，此时num已经变为5，所以当调用m(4)，输出结果为1。</p>
</blockquote>
<h1 id="typedef-为闭包类型定义别名"><a href="#typedef-为闭包类型定义别名" class="headerlink" title="typedef 为闭包类型定义别名"></a>typedef 为闭包类型定义别名</h1><p>这里先介绍一下 <code>typealias</code> 的使用 : <code>typealias</code> 是Swift中用来 <code>为已经存在的类型</code> 重新定义名字的关键字（类似于OC语法中的 <code>typedef</code>），重新命名的新名字用来替代之前的类型，并且能够使代码变得更加清晰简单容易理解。<code>typealias</code> 的用法很简单，直接用 <code>=</code> 赋值就可以了：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typealias &lt;type name&gt; = &lt;type expression&gt;</span><br></pre></td></tr></table></figure></div>

<p>这里我们可以用 <code>typealias</code> 来为看似较为复杂的闭包类型定义别名，这样以后我们就可以用别名直接去声明这样类型的闭包了，例子如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 为没有参数也没有返回值的闭包类型起一个别名</span><br><span class="line">typealias Nothing = () -&gt; ()</span><br><span class="line">    </span><br><span class="line">// 如果闭包的没有参数和返回值，那么我们还可以这样写，</span><br><span class="line">typealias Anything = () -&gt; Void</span><br><span class="line">    </span><br><span class="line">// 为接受一个 Int类型的参数 不返回任何值的闭包类型 定义一个别名：PrintNumber</span><br><span class="line">typealias PrintNumber = (Int) -&gt; ()</span><br><span class="line">    </span><br><span class="line">// 为接受两个Int类型的参数并且返回一个Int类型的值的闭包类型 定义一个别名：Add</span><br><span class="line">typealias Add = (Int, Int) -&gt; (Int)</span><br></pre></td></tr></table></figure></div>

<p>闭包是否接受参数、接受几个参数、返回什么类型的值完全取决于你的需求。</p>
<h1 id="闭包的创建、赋值、调用"><a href="#闭包的创建、赋值、调用" class="headerlink" title="闭包的创建、赋值、调用"></a>闭包的创建、赋值、调用</h1><p>闭包表达式语法能够使用常量形式参数、变量形式参数和输入输出形式参数，但不能提供默认值。可变形式参数也能使用，但需要在形式参数列表的最后面使用。元组也可被用来作为形式参数和返回类型。在闭包的中会用到一个关键字in，in 可以看做是一个分割符，他把该闭包的类型和闭包的函数体分开，in前面是该闭包的类型，in后面是具体闭包调用时保存的需要执行的代码。表示该闭包的形式参数类型和返回类型定义已经完成，并且闭包的函数体即将开始执行。这里总结了一下可能用到的几种形式实现闭包的创建、赋值、调用的过程。例子如下:</p>
<p><strong>方式一：利用typealias最完整的创建</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 为(_ num1: Int, _ num2: Int) -&gt; (Int) 类型的闭包定义别名：Add</span><br><span class="line">typealias Add = (_ num1: Int, _ num2: Int) -&gt; (Int)</span><br><span class="line">// 创建一个 Add 类型的闭包常量：addCloser1</span><br><span class="line">let addCloser1: Add</span><br><span class="line">// 为已经创建好的常量 addCloser1 赋值</span><br><span class="line">addCloser1 = &#123; (_ num1: Int, _ num2: Int) -&gt; (Int) in</span><br><span class="line">    return num1 + num2</span><br><span class="line">&#125;</span><br><span class="line">// 调用闭包并接受返回值</span><br><span class="line">let result = addCloser1(20, 10)</span><br></pre></td></tr></table></figure></div>

<p><strong>形式二：闭包类型声明和变量的创建合并在一起</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 (_ num1: Int, _ num2: Int) -&gt; (Int) 类型的闭包常量：addCloser1</span><br><span class="line">let addCloser1: (_ num1: Int, _ num2: Int) -&gt; (Int)</span><br><span class="line">// 为已经创建好的常量 addCloser1 赋值</span><br><span class="line">addCloser1 = &#123; (_ num1: Int, _ num2: Int) -&gt; (Int) in</span><br><span class="line">     return num1 + num2</span><br><span class="line">&#125;</span><br><span class="line">// 调用闭包并接受返回值</span><br><span class="line">let result = addCloser1(20, 10)</span><br></pre></td></tr></table></figure></div>

<p><strong>形式三：省略闭包接收的形参、省略闭包体中返回值</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 (Int, Int) -&gt; (Int) 类型的闭包常量：addCloser1</span><br><span class="line">let addCloser1: (Int, Int) -&gt; (Int)</span><br><span class="line">// 为已经创建好的常量 addCloser1 赋值</span><br><span class="line">addCloser1 = &#123; (num1, num2) in</span><br><span class="line">     return num1 + num2</span><br><span class="line">&#125;</span><br><span class="line">// 调用闭包并接受返回值</span><br><span class="line">let result = addCloser1(20, 10)</span><br></pre></td></tr></table></figure></div>

<p><strong>在形式三的基础上进一步精简</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 (Int, Int) -&gt; (Int) 类型的闭包常量：addCloser1 并赋值</span><br><span class="line">let addCloser1: (Int, Int) -&gt; (Int) = &#123; (num1, num2) in</span><br><span class="line">   return num1 + num2</span><br><span class="line">&#125;    </span><br><span class="line">// 调用闭包并接受返回值</span><br><span class="line">let result = addCloser1(20, 10)</span><br></pre></td></tr></table></figure></div>

<p><strong>形式五：如果闭包没有接收参数省略in</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 () -&gt; (String) 类型的闭包常量：addCloser1 并赋值</span><br><span class="line">let addCloser1: () -&gt; (String) = &#123;</span><br><span class="line">    return &quot;这个闭包没有参数，但是有返回值&quot;</span><br><span class="line">&#125;</span><br><span class="line">// 调用闭包并接受返回值</span><br><span class="line">let result = addCloser1()</span><br></pre></td></tr></table></figure></div>

<p><strong>形式六：简写的实际参数名</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 (String, String) -&gt; (String) 类型的闭包常量：addCloser1 并赋值</span><br><span class="line">let addCloser1: (String, String) -&gt; (String) = &#123;</span><br><span class="line">    return &quot;闭包的返回值是:\($0),\($1)&quot;</span><br><span class="line">&#125;</span><br><span class="line">// 调用闭包并接受返回值</span><br><span class="line">let result = addCloser1(&quot;Hello&quot;, &quot;Swift!&quot;)</span><br></pre></td></tr></table></figure></div>

<p>说明： 得益于Swift的 <code>类型推断机制</code>，我们在使用闭包的时候可以省略很多东西，而且Swift自动对行内闭包提供简写实际参数名，你也可以通过 <code>$0, $1, $2</code> 这样的语法来引用闭包的实际参数值。如果你在闭包表达式中使用这些简写实际参数名，那么你可以在闭包的实际参数列表中忽略对其的定义，并且简写实际参数名的数字和类型将会从期望的函数类型中推断出来。in关键字也能被省略，<code>$0</code> 和 <code>$1</code> 分别是闭包的第一个和第二个 <code>String类型的</code> 实际参数（引自文档翻译）。</p>
<h1 id="闭包常见的几种使用场景"><a href="#闭包常见的几种使用场景" class="headerlink" title="闭包常见的几种使用场景"></a>闭包常见的几种使用场景</h1><p><strong>场景一：利用闭包传值</strong></p>
<p>开发过程中常常会有这样的需求：一个页面的得到的数据需要传递给前一个页面使用。这时候使用闭包可以很简单的实现两个页面之间传值。</p>
<p>场景再现：<br>第一个界面中有一个用来显示文字的UILabel和一个点击进入到第二个界面的UIButton,第二个界面中有一个文本框UITextField和一个点击返回到上一个界面的UIButton,现在的需求是在第二个界面的UITextField中输入完文字后，点击返回按钮返回到第一个界面并且将输入的文字显示在第一个界面（当前页面）的UILabel中。</p>
<p>实现代码:<br>首先在第二个界面的控制器中定义一个 <code>(String) -&gt; ()</code> 可选类型的闭包常量 <code>closer</code> 作为SecondViewController的属性。closer接收一个String类型的参数（就是输入的文字）并且没有返回值。然后在返回按钮的点击事件中传递参数执行闭包。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">class SecondViewController: UIViewController &#123;</span><br><span class="line">    // 输入文本框</span><br><span class="line">    @IBOutlet weak var textField: UITextField!</span><br><span class="line">    // 为创建一个(String) -&gt; () 的可选类型的闭包变量作为控制器的属性</span><br><span class="line">    var closer: ((String) -&gt; ())?</span><br><span class="line">    // 返回按钮的点击事件</span><br><span class="line">    @IBAction func backButtonDidClick(_ sender: AnyObject) &#123;</span><br><span class="line">        // 首先判断closer闭包是否已经被赋值，如果已经有值，直接调用该闭包，并将输入的文字传进去。</span><br><span class="line">        if closer != nil &#123;</span><br><span class="line">            closer!(textField.text!)</span><br><span class="line">        &#125;</span><br><span class="line">        navigationController?.popViewController(animated: true)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里有一个注意点：我们在为 <code>SecondViewController</code> 定义变量闭包属性的时候需要将类型声明为可选类型，闭包可选类型应该是<code> ((String) -&gt; ())?</code> 而不是 <code>(String) -&gt; ()?</code> 的，后者指的是闭包的返回值是可选类型。<br>回到第一个界面的控制器中，我们需要拿到UILabel的控件，然后重写 <code>prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; &#125;</code> 方法，在这个跳转方法中拿到跳转的目标控制器<code>SecondVC</code> 并为他的闭包属性赋值，当然如果你的跳转按钮的点击事件是自己处理的，直接在按钮的点击事件中这样做就OK了。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">class FirstViewController: UIViewController &#123;</span><br><span class="line">    // 显示文字的label</span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">    // 重写这个方法</span><br><span class="line">    override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123;</span><br><span class="line">        // 拿到跳转的目标控制器</span><br><span class="line">        let secondVC = segue.destination as! SecondViewController</span><br><span class="line">        // 为目标控制器的闭包属性赋值</span><br><span class="line">        secondVC.closer = &#123;</span><br><span class="line">            // 将闭包的参数(输入的文本内容)显示在label上</span><br><span class="line">            self.label.text = $0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>经过上面的处理，我们就可以实现两个页面之间的传值了（是不是很简单呢），当然在具体的开发中很可能不是传递文本内容这么简单，当需要传递更复杂的值时，我们可以将传递的值包装成一个模型，直接用闭包传递模型就好了。</p>
<p><strong>场景二：闭包作为函数的参数</strong></p>
<p>在OC语法中block可以作为函数的参数进行传递，在Swift中同样可以用闭包作为函数的参数，还记得上面利用 <code>typealias</code> 关键字定义别名吗，定义完的别名就是一个闭包类型，可以用它申明一个闭包常量或变量当做参数进行传递。一个最简单的闭包作为函数参数例子如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 为接受一个Int类型的参数并且返回一个Int类型的值的闭包类型定义一个别名：Number</span><br><span class="line">typealias Number = (num1: Int) -&gt; (Int)</span><br><span class="line">// 定义一个接收Number类型的参数没有返回值的方法</span><br><span class="line">func Text(num: Number) &#123;</span><br><span class="line">  // code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>闭包在作为函数的参数进行传递的时候根据函数接收参数的情况有很多种不同的写法。这里我们主要介绍一下尾随闭包的概念。<br>首先看一下一般形式的闭包作为函数的参数传递：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 拼接两个字符串和一个整数</span><br><span class="line">func combine(handle:(String, String) -&gt; (Void), num: Int) &#123;</span><br><span class="line">        handle(&quot;hello&quot;, &quot;world \(num)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 方法调用</span><br><span class="line">combine(handle: &#123; (text, text1) -&gt; (Void) in</span><br><span class="line">        print(&quot;\(text) \(text1)&quot;)</span><br><span class="line">&#125;, num: 2016)</span><br></pre></td></tr></table></figure></div>

<p>可以看到上面的combine方法在主动调用的时候依旧是按照 <code>func(形参: 实参)</code> 这样的格式。当我们把闭包作为函数的最后一个参数的时候就引出了尾随闭包的概念。</p>
<p>一，尾随闭包</p>
<p>尾随闭包是指当需要将一个很长的闭包表达式作为函数最后一个实际参数传递给函数时，一个书写在函数形式参数的括号外面（后面）的闭包表达式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func combine1(num:Int, handle:(String, String)-&gt;(Void)) &#123;</span><br><span class="line">  handle(&quot;hello&quot;, &quot;world \(num)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">combine1(num: 2016) &#123; (text, text1) -&gt; (Void) in</span><br><span class="line">  print(&quot;\(text) \(text1)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>进一步：如果闭包表达式被用作函数唯一的实际参数并且你把闭包表达式用作尾随闭包，那么调用这个函数的时候函数名字的（）都可以省略：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func combine2(handle:(String, String)-&gt;(Void)) &#123;</span><br><span class="line">     handle(&quot;hello&quot;, &quot;world&quot;)</span><br><span class="line">&#125;</span><br><span class="line">combine2 &#123; (text, text1) -&gt; (Void) in</span><br><span class="line">     print(&quot;\(text) \(text1)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>二，逃逸闭包<br>如果一个闭包被作为一个参数传递给一个函数，并且在函数return之后才被唤起执行，那么我们称这个闭包的参数是“逃出”这个函数体外，这个闭包就是逃逸闭包。此时可以在形式参数前写 <code>@escaping</code> 来明确闭包是允许逃逸的。<br>闭包可以逃逸的一种方法是被储存在定义于函数外的变量里。比如说，很多函数接收闭包实际参数来作为启动异步任务的回调。函数在启动任务后返回，但是闭包要直到任务完成——闭包需要逃逸，以便于稍后调用。用我们最常用的网络请求举例来说：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func request(methodType:RequestMethodType, urlString: String, parameters: [String : AnyObject], completed: @escaping (AnyObject?, NSError?) -&gt; ()) &#123;</span><br><span class="line">        // 1.封装成功的回调</span><br><span class="line">        let successCallBack = &#123; (task : URLSessionDataTask?, result : Any?) -&gt; Void in</span><br><span class="line">            completed(result as AnyObject?, nil)</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.封装失败的回调</span><br><span class="line">        let failureCallBack = &#123; (task : URLSessionDataTask?, error : Error?) -&gt; Void in</span><br><span class="line">            completed(nil, error as NSError?)</span><br><span class="line">        &#125;</span><br><span class="line">        // 判断是哪种请求方式</span><br><span class="line">        if methodType == .get &#123;</span><br><span class="line">            get(urlString, parameters: parameters, success: successCallBack, failure: failureCallBack)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            post(urlString, parameters: parameters, success: successCallBack, failure: failureCallBack)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="使用闭包可能引起的循环强引用"><a href="#使用闭包可能引起的循环强引用" class="headerlink" title="使用闭包可能引起的循环强引用"></a>使用闭包可能引起的循环强引用</h1><p>Swift中不当的使用闭包可能会引起循环强引用，之所以称之为“强”引用，是因为它会将实例保持住，只要强引用还在，实例是不允许被销毁的。循环强引用会一直阻止类实例的释放，这就在你的应用程序中造成了内存泄漏。<br>举个例子：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">class ThirdViewController: UIViewController &#123;</span><br><span class="line">    var callBack: ((String) -&gt; ())?</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        printString &#123; (text) in</span><br><span class="line">            print(text)</span><br><span class="line">            // 闭包中捕获了self</span><br><span class="line">            self.view.backgroundColor = UIColor.red</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    func printString(callBack:@escaping (String) -&gt; ()) &#123;</span><br><span class="line">        callBack(&quot;这个闭包返回一段文字&quot;)</span><br><span class="line">        // 控制器强引用于着callBack</span><br><span class="line">        self.callBack = callBack</span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;ThirdViewController---释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当你在定义printString这个方法时执行 <code>self.callBack = callBack</code> 代码实际上是self对callBack闭包进行了强引用，到这里其实并没有产生循环引用，但是当你在调用printString方法的闭包里面又访问了self.view.backgroundColor属性，此时强引用就发生了，即self引用了callBack,而callBack内部又引用着self,谁都不愿意松手，我们就说这两者之间产生了循环强引用。</p>
<p>使用闭包何时会出现循环强引用 ：<br>当你把一个闭包分配给类实例属性的时候，并且这个闭包中又捕获了这个实例。捕获可能发生于这个闭包函数体中访问了实例的某个属性，比如 <code>self.someProperty</code> ，或者这个闭包调用了一个实例的方法，例如 <code>self.someMethod()</code> 。这两种情况都导致了闭包捕获了 <code>self</code> ，从而产生了循环强引用。</p>
<p>闭包循环引用的本质是：<br>闭包中循环强引用的产生，是因为闭包和类相似（还有一种两个类实例之间的循环强引用），都是引用类型。当你把闭包赋值给了一个属性，你实际上是把一个引用赋值给了这个闭包。两个强引用让彼此一直有效。</p>
<p>如何解决闭包的循环强引用：</p>
<ul>
<li>方式一：类似于Objective-C中使用 <code>__weak</code> 解决block的循环引用，Swift中支持使用 <code>weak</code> 关键字将类实例声明为弱引用类型（注意，弱引用类型总是 <code>可选类型</code>），打破类实例对闭包的强引用，当对象销毁之后会自动置为 <code>nil</code>，对 <code>nil</code> 进行任何操作不会有反应。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">class ThirdViewController: UIViewController &#123;</span><br><span class="line">    var callBack: ((String) -&gt; ())?</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        // 将self声明明为弱引用类型，打破循环引用</span><br><span class="line">        weak var weakSelf = self</span><br><span class="line">        printString &#123; (text) in</span><br><span class="line">            print(text)</span><br><span class="line">            // 闭包中铺捕获了self</span><br><span class="line">            weakSelf?.view.backgroundColor = UIColor.red</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    func printString(callBack:@escaping (String) -&gt; ()) &#123;</span><br><span class="line">        callBack(&quot;这个闭包返回一段文字&quot;)</span><br><span class="line">        // 控制器强引用于着callBack</span><br><span class="line">        self.callBack = callBack</span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;ThirdViewController---释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>方式二：作为第一种方式的简化操作，我们可以在闭包的第一个大括号后面紧接着插入这段代码 <code>[weak self]</code> ，后面的代码直接使用 <code>self？</code> 也能解决循环引用的问题。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">class ThirdViewController: UIViewController &#123;</span><br><span class="line">    var callBack: ((String) -&gt; ())?</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        printString &#123; [weak self] (text) in</span><br><span class="line">            print(text)</span><br><span class="line">            self?.view.backgroundColor = UIColor.red</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    func printString(callBack: @escaping (String) -&gt; ()) &#123;</span><br><span class="line">        callBack(&quot;这个闭包返回一段文字&quot;)</span><br><span class="line">        // 控制器强引用于着callBack</span><br><span class="line">        self.callBack = callBack</span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;ThirdViewController---释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>方式三：在闭包和捕获的实例总是互相引用并且总是同时释放时，可以将闭包内的捕获定义为 <code>无主引用unowned</code>。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">class ThirdViewController: UIViewController &#123;</span><br><span class="line">    var callBack: ((String) -&gt; ())?</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        printString &#123; [unowned self]  (text) in</span><br><span class="line">            print(text)</span><br><span class="line">            self?.view.backgroundColor = UIColor.red</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    func printString(callBack:@escaping (String) -&gt; ()) &#123;</span><br><span class="line">        callBack(&quot;这个闭包返回一段文字&quot;)</span><br><span class="line">        // 控制器强引用于着callBack</span><br><span class="line">        self.callBack = callBack</span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;ThirdViewController---释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意：<code>unowned</code> 是Swift中另外一种解决循环引用的申明无主引用类型的关键字，类似于Objective-C中的 <code>__unsafe_unretained</code>；大家都知道 <code>__weak</code> 和 <code>__unsafe_unretained</code> 的相同点是可以将该关键字修饰的对象变成弱引用解决可能存在的循环引用。不同点在于前者修饰的对象如果发现被销毁，那么指向该对象的指针会立即指向nil，而<code>__unsafe_unretained</code> 修饰的对象如果发现被销毁，指向该对象的指针依然指向原来的内存地址，如果此时继续访问该对象 <code>很容易产生坏内存访问/野指针/僵尸对象访问</code>。</p>
<p>说明：同样的道理 <code>Swift</code> 中也是一样的。和弱引用类似，无主引用不会牢牢保持住引用的实例。但是不像弱引用，总之，<code>无主引用假定是永远有值的</code>。因此，<code>无主引用总是被定义为非可选类型</code>。你可以在声明属性或者变量时，在前面加上关键字 <code>unowned</code> 表示这是一个无主引用。由于无主引用是非可选类型，你不需要在使用它的时候将它展开。无主引用总是可以直接访问。不过 <code>ARC</code> 无法在实例被释放后将无主引用设为 <code>nil</code> ，因为非可选类型的变量不允许被赋值为 <code>nil</code> 。如果此时继续访问已经被释放实例很容易产生坏内存访问&#x2F;野指针&#x2F;僵尸对象访问。所以Swift建议我们如果被捕获的引用永远不为 <code>nil</code> ，应该用 <code>unowned</code> 而不是 <code>weak</code>，相反，如果你不确定闭包中捕获的引用是不是存在为<code>nil</code> 的可能，你应该使用 <code>weak</code>。</p>
<ul>
<li>总结</li>
</ul>
<blockquote>
<p>解决循环引用的方式：<br>被捕获的引用永远不为nil，用 <code>unowned</code> 即 <code>无主引用</code>。<br>被捕获的引用可能为nil，用 <code>weak</code> 即 <code>弱引用</code>。</p>
</blockquote>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：Swift学习34：闭包</li>
        <li>Post author：张建</li>
        <li>Create time：2023-03-03 22:56:01</li>
        <li>
            Post link：https://redefine.ohevan.com/2023/03/03/Swift课程/Swift学习34：闭包/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/BboyZJ.github.io/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/">#Swift-课程篇</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A036%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">Swift学习36：函数式编程</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A033%EF%BC%9A%E5%87%BD%E6%95%B0/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">Swift学习33：函数</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">Swift学习34：闭包</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">闭包的概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">闭包的作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-text">设置属性默认值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="nav-text">全局函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%B5%8C%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-text">内嵌函数：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">闭包表达式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-text">闭包是引用类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-text">闭包作为函数的参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%BE%E9%9A%8F%E9%97%AD%E5%8C%85"><span class="nav-text">尾随闭包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%83%E9%80%B8%E9%97%AD%E5%8C%85"><span class="nav-text">逃逸闭包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%97%AD%E5%8C%85"><span class="nav-text">自动闭包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E6%8D%95%E8%8E%B7"><span class="nav-text">闭包对变量的捕获</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#typedef-%E4%B8%BA%E9%97%AD%E5%8C%85%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D"><span class="nav-text">typedef 为闭包类型定义别名</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E8%B5%8B%E5%80%BC%E3%80%81%E8%B0%83%E7%94%A8"><span class="nav-text">闭包的创建、赋值、调用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">闭包常见的几种使用场景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="nav-text">使用闭包可能引起的循环强引用</span></a></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2019</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">张建</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        VISITOR COUNT&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        TOTAL PAGE VIEWS&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a></span>
                <br> 
            <span class="theme-version-container">THEME&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v1.1.5</a>
        </div>
        
        
        
            <div id="start_time_div" style="display:none">
                2019/8/17 11:45:14
            </div>
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="unfolded-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="fa-regular fa-arrow-up"></i>
            </li>
        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="folded-tools-list">
        <li class="right-bottom-tools tool-toggle-show flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>




<script src="/BboyZJ.github.io/js/utils.js"></script>

<script src="/BboyZJ.github.io/js/main.js"></script>

<script src="/BboyZJ.github.io/js/layouts/menu-shrink.js"></script>

<script src="/BboyZJ.github.io/js/tools/go-top-bottom.js"></script>

<script src="/BboyZJ.github.io/js/tools/dark-light-toggle.js"></script>



    
<script src="/BboyZJ.github.io/js/tools/local-search.js"></script>




    
<script src="/BboyZJ.github.io/js/tools/code-block.js"></script>




    
<script src="/BboyZJ.github.io/js/layouts/lazyload.js"></script>




    
<script src="/BboyZJ.github.io/js/tools/runtime.js"></script>

    
<script src="/BboyZJ.github.io/js/layouts/odometer.min.js"></script>

    
<link rel="stylesheet" href="/BboyZJ.github.io/assets/odometer-theme-minimal.css">





<div class="post-scripts pjax">
    
        
<script src="/BboyZJ.github.io/js/tools/toc-toggle.js"></script>

<script src="/BboyZJ.github.io/js/libs/anime.min.js"></script>

<script src="/BboyZJ.github.io/js/layouts/toc.js"></script>

<script src="/BboyZJ.github.io/js/plugins/tabs.js"></script>

    
    
</div>


    
<script src="/BboyZJ.github.io/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>




<script src="/BboyZJ.github.io/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
