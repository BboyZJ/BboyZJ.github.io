<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张建的博客</title>
  <icon>https://www.gravatar.com/avatar/134cc2bfaf649e446f661778f4112fca</icon>
  <subtitle>成功的道路上只有荆棘，没有坦途</subtitle>
  <link href="https://www.bboyzj.cn/atom.xml" rel="self"/>
  
  <link href="https://www.bboyzj.cn/"/>
  <updated>2023-03-30T05:45:47.542Z</updated>
  <id>https://www.bboyzj.cn/</id>
  
  <author>
    <name>小J</name>
    <email>13718004742@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>性能优化05：Network 网络</title>
    <link href="https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605%EF%BC%9ANetwork%20%E7%BD%91%E7%BB%9C/"/>
    <id>https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605%EF%BC%9ANetwork%20%E7%BD%91%E7%BB%9C/</id>
    <published>2023-09-10T04:13:29.000Z</published>
    <updated>2023-03-30T05:45:47.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="弱网优化"><a href="#弱网优化" class="headerlink" title="弱网优化"></a>弱网优化</h1><ul><li><p>所谓弱网络，指在网络不好的情况下使用APP，如 <code>2G、3G网络</code>，用户的网络速度基本在 <code>10k/s~60k/s</code>。</p></li><li><p>考虑海外应用的话，就必须考虑弱网优化的方案了。</p></li><li><p>苹果建议，使用苹果内置的 <code>Network Link Conditioner</code> 来模拟网络环境处理 <code>APP</code> 的体验问题，在Xcode和手机都可以开启</p></li></ul><h1 id="Xcode：系统偏好设置"><a href="#Xcode：系统偏好设置" class="headerlink" title="Xcode：系统偏好设置"></a>Xcode：系统偏好设置</h1><h1 id="iPhone：开发者-gt-Network-Link-Conditioner"><a href="#iPhone：开发者-gt-Network-Link-Conditioner" class="headerlink" title="iPhone：开发者 -&gt; Network Link Conditioner"></a>iPhone：开发者 -&gt; Network Link Conditioner</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;弱网优化&quot;&gt;&lt;a href=&quot;#弱网优化&quot; class=&quot;headerlink&quot; title=&quot;弱网优化&quot;&gt;&lt;/a&gt;弱网优化&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;所谓弱网络，指在网络不好的情况下使用APP，如 &lt;code&gt;2G、3G网络&lt;/code&gt;，用户的网络速度基</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>性能优化04：Energy 耗电</title>
    <link href="https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604%EF%BC%9AEnergy%20%E8%80%97%E7%94%B5/"/>
    <id>https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604%EF%BC%9AEnergy%20%E8%80%97%E7%94%B5/</id>
    <published>2023-09-10T04:13:29.000Z</published>
    <updated>2023-03-30T05:53:39.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>所有应用程序在执行网络操作、更新用户界面或在CPU上运行代码时都会消耗能量。随着用户越来越多地依赖电池电量，以及应用程序的激增，能效已成为用户体验中不可或缺的一部分。</p><h1 id="电池寿命"><a href="#电池寿命" class="headerlink" title="电池寿命"></a>电池寿命</h1><p>随着能源效率的下降，<code>电池</code> 的寿命也会下降。同时消耗过多的资源会导致界面滞后，对用户输入的响应会很慢。随着越来越多的应用程序使用越来越多的资源，系统工作起来越来越努力，速度也越来越快，设备的物理温度也在逐渐升高。当这种情况发生时，系统会采取措施将温度降低到更容易接受的水平。</p><h1 id="能量消耗的因素"><a href="#能量消耗的因素" class="headerlink" title="能量消耗的因素"></a>能量消耗的因素</h1><ol><li><p>CPU: CPU是能源的主要消耗者。高CPU使用周期会迅速耗尽用户的电池。 CPU使用率超过20%就会快速耗干电池电量——建议只在必要时通过 <code>批处理、调度和优先级排序</code> 来完成工作。</p></li><li><p>GPU: 图形处理器(显卡的处理器)，乱使用GPU会导致交互差，并且降低电池寿命。</p></li><li><p>Network：大多数iOS应用程序执行网络操作。当联网发生时，蜂窝无线电和Wi-Fi等组件就会启动并消耗能量。通过 <code>批量处理和减少事务、压缩数据和适当处理错误</code>，您的应用程序可以为节能做出重大贡献。</p></li><li><p>Location: 许多应用程序发出位置请求是为了记录用户的物理活动或提供基于环境的警报。能量消耗随着精确度的提高和位置请求的延长而增加。你的应用应该尽可能减少定位活动的准确性和持续时间。当不再需要时停止位置请求。</p></li><li><p>Background: <code>后台</code> 状态App仍会消耗电量，App要按需执行后台操作，并使用延迟APNS来保证系统运算高效执行。另外，在app进入后台状态是，立即减少动作，并且通知系统一次这些动作已经完成</p></li><li><p>Bluetooth: 长时间的 <code>蓝牙</code> 活动会耗尽iOS设备和蓝牙设备的电池。只要可能，批处理和缓冲蓝牙活动，并减少对数据的轮询。</p></li><li><p>Device wakes：iOS设备依靠睡眠来延长电池寿命。无论设备何时唤醒，都会有很高的开销成本，因为必须为屏幕和其他资源提供电源。你的应用程序，尤其是在后台操作时，应该尽可能空闲，除非绝对必要，避免用推送通知或其他活动唤醒设备</p></li></ol><h1 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h1><ol><li><p>Time Profile：时间分析器分析模板。使用此模板对正在运行的进程执行低开销的基于时间的采样。Time Profiler 监视应用程序中正在运行的线程，并定期采样。为每个样本收集完整的回溯，允许您深入查看样本，以准确找到代码中花费大量时间的位置。</p></li><li><p>Animation Hitches：核心动画分析模板。使用此模板可以测量图形性能和CPU使用率。启用模板 Core Animation 的 <code>Flash Updated Regions</code> 设置，以查看应用中发生的每个屏幕更新，并观察不必要或意外的更新。</p></li><li><p>Activity Monitor: 活动监视器分析模板。使用此模板可以监视整体CPU，磁盘I&#x2F;O和网络使用情况。</p></li></ol><h1 id="Energy-log调试和演示"><a href="#Energy-log调试和演示" class="headerlink" title="Energy log调试和演示"></a>Energy log调试和演示</h1><ol><li>检查第一步，是通过xcode开发工具的 <code>energy impact</code> 来整体查看app的耗电情况。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303231852146.png"                                     ></p><p>Overhead：表示开销，包括CPU的唤起，无线电模组(蓝牙&amp;WiFi)，和其他系统资源的调用等。</p><ol start="2"><li>检查第二步：通过instrument工具的 <code>energy log</code> 来检测具体的耗电模块。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303231853126.png"                                     ></p><h1 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h1><ol><li>cpu层面的优化</li></ol><ul><li>尽量降低CPU</li><li>少使用定时器</li><li>优化I&#x2F;O操作<ul><li>写入数据最好一次性写入</li><li>读取数据最好使用GCD异步操作</li><li>数据流比较大，建议使用数据库</li></ul></li><li>适当使用多线程，不宜过多，不要阻塞主线程</li><li>优化算法，减少循环次数</li><li>避免庞大的 <code>xib、storyBoard</code>， 尽量使用纯代码开发</li></ul><ol start="2"><li>GPU 层面的优化</li></ol><ul><li>减少视图刷新，按需刷新；</li><li>尽量少使用圆角和透明度；</li></ul><ol start="3"><li>Network 网络请求层面的优化</li></ol><ul><li>减少、压缩网络数据</li><li>如果多次请求的结果是相同的，尽量使用缓存</li><li>使用断点续传，否则网络不稳定时可能多次传输相同的内容</li><li>网络不可用时，不要尝试执行网络请求</li><li>让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间</li><li>批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载</li></ul><ol start="4"><li>Location 定位层面优化</li></ol><ul><li>如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电</li><li>如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务</li><li>尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest</li><li>需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新</li><li>尽量不要使用startMonitoringSignificantLocationChanges，优先考虑startMonitoringForRegion</li></ul><ol start="5"><li>Bluetooth, Background</li></ol><ul><li>蓝牙按需取用，定位之后要关闭或降低定位频率，进入后台关闭定位，停止定时器运行等</li></ul><ol start="4"><li>硬件检测优化(不常用)</li></ol><ul><li>用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;所有应用程序在执行网络操作、更新用户界面或在CPU上运行代码时都会消耗能量。随着用户越来越多地依赖电池电量，以及应用程序的激增，能效已成为用</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>性能优化06：启动优化</title>
    <link href="https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</id>
    <published>2023-09-10T04:13:29.000Z</published>
    <updated>2023-03-30T06:10:57.318Z</updated>
    
    <content type="html"><![CDATA[<p>启动优化查看以下三篇文章：</p><p><a href="https://www.bboyzj.cn/2021/05/04/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8632%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">OC底层原理32：启动优化（一）基本概念</a></p><p><a href="https://www.bboyzj.cn/2021/05/11/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8633%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/">OC底层原理33：启动优化（二）优化建议</a></p><p><a href="https://www.bboyzj.cn/2021/05/17/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8634%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%87%8D%E6%8E%92/">OC底层原理34：启动优化（三）二进制重排</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;启动优化查看以下三篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bboyzj.cn/2021/05/04/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8632%EF%BC%9A%E5%</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>性能优化06：启动优化</title>
    <link href="https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%202/"/>
    <id>https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%202/</id>
    <published>2023-09-10T04:13:29.000Z</published>
    <updated>2023-03-30T06:10:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>启动优化查看以下三篇文章：</p><p><a href="https://www.bboyzj.cn/2021/05/04/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8632%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">OC底层原理32：启动优化（一）基本概念</a></p><p><a href="https://www.bboyzj.cn/2021/05/11/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8633%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/">OC底层原理33：启动优化（二）优化建议</a></p><p><a href="https://www.bboyzj.cn/2021/05/17/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8634%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%87%8D%E6%8E%92/">OC底层原理34：启动优化（三）二进制重排</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;启动优化查看以下三篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bboyzj.cn/2021/05/04/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8632%EF%BC%9A%E5%</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>OC三方框架07：ReactiveCocoa使用</title>
    <link href="https://www.bboyzj.cn/2023/07/15/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B607%EF%BC%9AReactiveCocoa%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.bboyzj.cn/2023/07/15/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B607%EF%BC%9AReactiveCocoa%E4%BD%BF%E7%94%A8/</id>
    <published>2023-07-15T06:31:51.000Z</published>
    <updated>2023-07-15T06:40:31.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>RAC</code> 全称 <code>ReactiveCocoa</code>，是一个重量级的三方框架，接管了苹果的所有事件机制，RAC主要是 <code>监听事件</code>，并能 <code>立即作为响应</code>，即 <code>响应式编程</code>。</p><h1 id="RAC-大纲"><a href="#RAC-大纲" class="headerlink" title="RAC 大纲"></a>RAC 大纲</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307151439906.png"                                     ></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;RAC&lt;/code&gt; 全称 &lt;code&gt;ReactiveCocoa&lt;/code&gt;，是一个重量级的三方框架，接管了苹果的所有事件机</summary>
      
    
    
    
    <category term="OC-三方框架探索篇" scheme="https://www.bboyzj.cn/categories/OC-%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%B4%A2%E7%AF%87/"/>
    
    
    <category term="iOS-OC" scheme="https://www.bboyzj.cn/tags/iOS-OC/"/>
    
  </entry>
  
  <entry>
    <title>OC网络学习14：AFNetworking如何添加代理</title>
    <link href="https://www.bboyzj.cn/2023/07/15/OC%E7%BD%91%E7%BB%9C/OC%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A014%EF%BC%9AAFNetworking%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%90%86/"/>
    <id>https://www.bboyzj.cn/2023/07/15/OC%E7%BD%91%E7%BB%9C/OC%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A014%EF%BC%9AAFNetworking%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%90%86/</id>
    <published>2023-07-15T05:43:22.000Z</published>
    <updated>2023-07-15T06:16:25.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>我们在iOS开发中无论是三方库 <code>AFNetworking</code> 还是原生的 <code>NSURLSession 或 NSURLSession</code> 来设置代理服务器，均需要配置 <code>URLSessionConfiguration</code>，属性 <code>connectionProxyDictionary</code> 是一个用于配置代理的字典。当你需要使用代理服务器连接到互联网时，你可以使用 <code>connectionProxyDictionary</code> 来指定代理服务器的配置选项。</li></ul><p>该字典包含以下键值对：</p><p>HTTPEnable：BOOL 类型，表示是否开启 HTTP 代理。默认为 NO。<br>HTTPProxy：NSString 类型，表示 HTTP 代理服务器的地址。<br>HTTPPort：NSInteger 类型，表示 HTTP 代理服务器的端口号。<br>HTTPSEnable：BOOL 类型，表示是否开启 HTTPS 代理。默认为 NO。<br>HTTPSProxy：NSString 类型，表示 HTTPS 代理服务器的地址。<br>HTTPSPort：NSInteger 类型，表示 HTTPS 代理服务器的端口号。<br>FTPEnable：BOOL 类型，表示是否开启 FTP 代理。默认为 NO。<br>FTPProxy：NSString 类型，表示 FTP 代理服务器的地址。<br>FTPPort：NSInteger 类型，表示 FTP 代理服务器的端口号。<br>SOCKSEnable：BOOL 类型，表示是否开启 SOCKS 代理。默认为 NO。<br>SOCKSProxy：NSString 类型，表示 SOCKS 代理服务器的地址。<br>SOCKSPort：NSInteger 类型，表示 SOCKS 代理服务器的端口号。<br>ProxyAutoConfigEnable：BOOL 类型，表示是否开启代理自动配置（PAC）。默认为 NO。<br>ProxyAutoConfigURLString：NSString 类型，表示 PAC 配置文件的 URL。</p><h1 id="AFNetworking-具体代码实现"><a href="#AFNetworking-具体代码实现" class="headerlink" title="AFNetworking 具体代码实现"></a>AFNetworking 具体代码实现</h1><p>举例使用 <code>HTTP/HTTPS</code> 代理</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSString * ip = @&quot;127.0.0.1&quot;;</span><br><span class="line">NSNumber * port = @443;</span><br><span class="line">NSURLSessionConfiguration * config = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">config.connectionProxyDictionary = @&#123;</span><br><span class="line">    @&quot;HTTPEnable&quot;:@YES,</span><br><span class="line">    @&quot;HTTPProxy&quot;:ip,</span><br><span class="line">    @&quot;HTTPPort&quot;:port,</span><br><span class="line">    @&quot;HTTPsEnable&quot;:@YES,</span><br><span class="line">    @&quot;HTTPsProxy&quot;:ip,</span><br><span class="line">    @&quot;HTTPsPort&quot;:port,</span><br><span class="line">&#125;;</span><br><span class="line">manager = [[AFHTTPSessionManager alloc] initWithSessionConfiguration:config];</span><br></pre></td></tr></table></figure></div><h1 id="NSURLSession-具体代码实现"><a href="#NSURLSession-具体代码实现" class="headerlink" title="NSURLSession 具体代码实现"></a>NSURLSession 具体代码实现</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NSURL * url = [NSURL URLWithString:@&quot;&quot;];</span><br><span class="line">NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:url];</span><br><span class="line">request.HTTPMethod = @&quot;GET&quot;;</span><br><span class="line">    </span><br><span class="line">NSString * ip = @&quot;127.0.0.1&quot;;</span><br><span class="line">NSNumber * port = @443;</span><br><span class="line">NSURLSessionConfiguration * config = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">config.connectionProxyDictionary = @&#123;</span><br><span class="line">    @&quot;HTTPEnable&quot;:@YES,</span><br><span class="line">    @&quot;HTTPProxy&quot;:ip,</span><br><span class="line">    @&quot;HTTPPort&quot;:port,</span><br><span class="line">    @&quot;HTTPsEnable&quot;:@YES,</span><br><span class="line">    @&quot;HTTPsProxy&quot;:ip,</span><br><span class="line">    @&quot;HTTPsPort&quot;:port,</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">NSURLSession *session = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:[NSOperationQueue mainQueue]];</span><br><span class="line">NSURLSessionTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">&#125;];</span><br><span class="line">[dataTask resume];</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;我们在iOS开发中无论是三方库 &lt;code&gt;AFNetworking&lt;/code&gt; 还是原生的 &lt;code&gt;NSURLSessi</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-网络学习" scheme="https://www.bboyzj.cn/tags/OC-%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习44：网络请求报 Error Domain=NSURLErrorDomain Code=-999 cancelled 处理</title>
    <link href="https://www.bboyzj.cn/2023/07/14/OC/OC%E5%AD%A6%E4%B9%A044%EF%BC%9A%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%8A%A5-Error-Domain-NSURLErrorDomain-Code-999-cancelled-%E5%A4%84%E7%90%86/"/>
    <id>https://www.bboyzj.cn/2023/07/14/OC/OC%E5%AD%A6%E4%B9%A044%EF%BC%9A%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%8A%A5-Error-Domain-NSURLErrorDomain-Code-999-cancelled-%E5%A4%84%E7%90%86/</id>
    <published>2023-07-14T00:38:05.000Z</published>
    <updated>2023-07-14T00:40:08.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>项目中去请求就会报错：Error Domain&#x3D;NSURLErrorDomain Code&#x3D;-999 “cancelled”，调试了很久也不行，查了下资料，才发现当后台服务器配置了 <code>https</code> 证书后，iOS端如果采用 <code>AF</code> 请求网络，必须配置一下证书的支持，代码如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 设置证书</span><br><span class="line">+ (void)setSecurityPolicyWithManager:(AFHTTPSessionManager *)manager&#123;</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [[AFSecurityPolicy alloc] init];</span><br><span class="line">    // 是否信任非法证书</span><br><span class="line">    [securityPolicy setAllowInvalidCertificates:YES];</span><br><span class="line">    // 是否在证书域字段中验证域名</span><br><span class="line">    [securityPolicy setValidatesDomainName:NO];</span><br><span class="line">    [manager setSecurityPolicy:securityPolicy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>只设置是否信任证书而不设置是否验证域名依然是 <code>Error Domain=NSURLErrorDomain Code=-999 &quot;cancelled&quot;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;项目中去请求就会报错：Error Domain&amp;#x3D;NSURLErrorDomain Code&amp;#x3D;-999 “cancelle</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC网络学习04：网关探索</title>
    <link href="https://www.bboyzj.cn/2023/07/13/OC%E7%BD%91%E7%BB%9C/OC%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A004%EF%BC%9A%E7%BD%91%E5%85%B3%E6%8E%A2%E7%B4%A2/"/>
    <id>https://www.bboyzj.cn/2023/07/13/OC%E7%BD%91%E7%BB%9C/OC%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A004%EF%BC%9A%E7%BD%91%E5%85%B3%E6%8E%A2%E7%B4%A2/</id>
    <published>2023-07-13T03:00:58.000Z</published>
    <updated>2023-07-13T03:10:59.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网关(Gateway) 又称 <code>网间连接器、协议转换器</code>。网关在网络层以上实现网络互连，是复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既 <code>可以用于广域网互连，也可以用于局域网互连</code>。</p><blockquote><p>由于历史的原因，许多有关TCP&#x2F;IP的文献曾经把网络层使用的 <code>路由器称为网关</code>，在今天很多局域网采用都是路由来接入网络，因此通常指的 <code>网关就是路由器的IP</code></p></blockquote><h1 id="什么是网关"><a href="#什么是网关" class="headerlink" title="什么是网关"></a>什么是网关</h1><p>大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道 <code>关口</code> ，这道关口就是网关。顾名思义，<code>网关（Gateway）</code> 就是一个网络连接到另一个网络的 <code>关口</code> 。也就是网络关卡。</p><h1 id="网关本质"><a href="#网关本质" class="headerlink" title="网关本质"></a>网关本质</h1><ul><li><p>那么网关到底是什么呢？网关实质上 <code>是一个网络通向其他网络的IP地址</code>。</p></li><li><p>比如有网络A和网络B：网络A的IP地址范围为 <code>192.168.1.1~192. 168.1.254</code> ，子网掩码为255.255.255.0；网络B的IP地址范围为 <code>192.168.2.1~192.168.2.254</code> ，子网掩码为255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行 <code>TCP/IP</code> 通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP&#x2F;IP协议也会根据 子网掩码（255.255.255.0）与主机的IP地址作 <code>与</code> 运算的结果不同判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过 <code>网关</code>。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。这就是网络A向网络B转发数据包的过程。</p></li><li><p>所以说，只有 <code>设置好网关的IP地址</code>，TCP&#x2F;IP协议才能实现不同网络之间的相互通信。那么这个IP地址是哪台机器的IP地址呢？ <code>网关的IP地址是具有路由功能的设备的IP地址</code>，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;网关(Gateway) 又称 &lt;code&gt;网间连接器、协议转换器&lt;/code&gt;。网关在网络层以上实现网络互连，是复杂的网络互连设备，仅用于两</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-网络学习" scheme="https://www.bboyzj.cn/tags/OC-%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC网络学习03：ip地址探索</title>
    <link href="https://www.bboyzj.cn/2023/07/13/OC%E7%BD%91%E7%BB%9C/OC%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A003%EF%BC%9Aip%E5%9C%B0%E5%9D%80%E6%8E%A2%E7%B4%A2/"/>
    <id>https://www.bboyzj.cn/2023/07/13/OC%E7%BD%91%E7%BB%9C/OC%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A003%EF%BC%9Aip%E5%9C%B0%E5%9D%80%E6%8E%A2%E7%B4%A2/</id>
    <published>2023-07-13T01:32:31.000Z</published>
    <updated>2023-07-13T05:05:51.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>IP地址（Internet Protocol Address）是指 <code>互联网协议地址</code>，又译为 <code>网际协议地址</code>。</p></li><li><p><code>IP地址</code> 是 <code>IP协议</code> 提供的一种统一的地址格式，它为互联网上的 <code>每一个网络</code> 和 <code>每一台主机</code> 分配一个逻辑地址，以此来屏蔽物理地址的差异。</p></li></ul><p>在网络中我们经常会 <code>访问域名</code>（例如：百度的 <a class="link"   href="http://www.baidu.com/" >www.baidu.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ），其本质就是 <code>对域名所绑定的IP地址</code> 的访问，那么 IP地址是什么呢？</p><h1 id="什么是IP协议"><a href="#什么是IP协议" class="headerlink" title="什么是IP协议"></a>什么是IP协议</h1><p><code>IP协议</code> 是为计算机网络相互连接进行通信而设计的协议。它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。各个厂家生产的网络系统和设备，如以太网、分组交换网等，它们相互之间不能互通，不能互通的主要原因是因为它们所传送数据的<code>基本单元（技术上称之为“帧”）的格式不同</code>。<code>IP协议</code> 实际上是一套由软件程序组成的协议软件，它把各种不同 <code>帧</code> 统一转换成 <code>IP数据报</code> 格式，使所有各种计算机都能在因特网上实现互通。</p><h1 id="什么是IP地址"><a href="#什么是IP地址" class="headerlink" title="什么是IP地址"></a>什么是IP地址</h1><ul><li><p><code>IP协议</code> 中还有一个非常重要的内容，那就是给因特网上的每台计算机和其它设备都规定了一个唯一的地址，叫做 <code>IP地址</code>。</p></li><li><p>我们知道 <code>网络中的相互访问</code> 其实就是 <code>相互间的数据传递</code>。如送快递一样，快递发出只有知道你的住址信息，才能将快递送到你的手中。而在网络访问时，只有知道你在网络中的地址信息，才能将数据发送到你的设备上。因此，<code>IP地址 其实就是你在网络中的地址信息</code>。与你现实地址不同的是，你的现实地址使用文字表示，而你在网络中的地址（IP地址）是用 <code>二进制数字表示</code> 的。</p></li><li><p><code>IP地址</code> 是一个32位的二进制数，通常被分割为4个 8位二进制数 （也就是4个字节）。IP地址通常用 <code>点分十进制</code> 表示成（a.b.c.d）的形式，其中，a,b,c,d都是0~255之间的十进制整数。例：点分十进IP地址（100.4.5.6），实际上是32位二进制数（01100100.00000100.00000101.00000110）。</p></li></ul><h1 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h1><ul><li><p>首先出现的 <code>IP地址</code> 是 <code>IPV4</code>，它只有4段数字，每一段最大不超过255。实际情况是在2019年11月25日IPv4位地址分配完毕。地址空间的不足必将妨碍互联网的进一步发展。为了扩大地址空间，拟通过IPv6重新定义地址空间。</p></li><li><p><code>IPv6</code> 采用 128位地址长度。在IPv6的设计过程中除了一劳永逸地解决了地址短缺问题以外，还考虑了在IPv4中解决不好的其它问题。</p></li></ul><h1 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h1><p>一般我们会将网络划分为 <code>公网（连Internet的）</code> 与 <code>内网</code>。</p><h1 id="IP地址类型"><a href="#IP地址类型" class="headerlink" title="IP地址类型"></a>IP地址类型</h1><p>根据 网络 我们将IP地址划分为 <code>公有IP地址</code> 和 <code>私有IP地址</code>。</p><h1 id="公有IP地址"><a href="#公有IP地址" class="headerlink" title="公有IP地址"></a>公有IP地址</h1><ul><li><p>一般称公网中的IP地址为公有地址。公有地址由 Inter NIC（因特网信息中心）负责，这些IP地址分配给注册并向Inter NIC提出申请的组织机构。公有地址是全球唯一的，公网中不可能存在两个相同的IP地址。</p></li><li><p>范围：除了私有地址以外的地址，都属于 <code>公有地址</code></p></li></ul><h1 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h1><p>一般称 <code>内网（即局域网）</code> 中的IP地址为 <code>私有地址</code>。私有地址是非注册地址，用于组织机构内部使用。私有地址的范围如下：</p><ul><li>A类IP地址中：10.0.0.0 ~ 10.255.255.255</li><li>B类IP地址中：172.16.0.0 ~ 172.31.255.255</li><li>C类IP地址中：192.168.0.0 ~ 192.168.255.255</li></ul><p>私有地址与公有地址不同，并不是由Internet分配的，是不允许出现在Internet中的，我们在公网中是看不到私有IP地址的，并且公有地址也不会使用上述的三类地址。因此，<code>私有地址是不能直接与Internet连接的</code>。</p><h1 id="IP地址编址方式"><a href="#IP地址编址方式" class="headerlink" title="IP地址编址方式"></a>IP地址编址方式</h1><p>IP地址包括两个标识码（ID），即 <code>网络ID和主机ID</code>。Internet委员会定义了5种IP地址类型以适合不同容量的网络，即 <code>A类~E类</code>。</p><p>其中A、B、C类由InternetNIC在全球范围内统一分配，D、E类为特殊地址。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16892163352329.jpg"                                     ></p><ul><li>A类IP地址</li></ul><p>一个A类IP地址是指， 在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。</p><ul><li>B类IP地址</li></ul><p>一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码。</p><p>B类IP地址的 <code>子网掩码为255.255.0.0</code>，每个网络支持的最大主机数为256的2次方-2&#x3D;65534台。</p><ul><li>C类IP地址</li></ul><p>一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。</p><p>C类IP地址的 <code>子网掩码为255.255.255.0</code>，每个网络支持的最大主机数为256-2&#x3D;254台</p><ul><li>D类IP地址</li></ul><p>D类IP地址在历史上被叫做 多播地址(multicast address)，即 <code>组播地址</code>。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是 1110 ，范围从224.0.0.0到239.255.255.255。</p><ul><li>IP地址特殊的网址</li></ul><p>1）每一个字节都为0的地址（“0.0.0.0”）对应于当前主机；<br>2）IP地址中的每一个字节都为1的IP地址（“255．255．255．255”）是当前子网的广播地址；<br>3）IP地址中凡是以“11110”开头的E类IP地址都保留用于将来和实验使用。<br>4）IP地址中不能以十进制“127”作为开头，该类地址中数字127．0．0．1到127．255．255．255用于回路测试，如：127.0.0.1可以代表本机IP地址，用“<a class="link"   href="http://127.0.0.1”就可以测试本机中配置的web服务器./" >http://127.0.0.1”就可以测试本机中配置的Web服务器。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>5）网络ID的第一个6位组也不能全置为“0”，全“0”表示本地网络。</p><h1 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h1><ul><li><p>引入 <code>子网掩码(NetMask)</code>，从逻辑上把一个大网络划分成一些小网络。子网掩码是由一系列的1和0构成，通过将其同IP地址做 <code>与</code> 运算来 <code>指出一个IP地址的网络号是什么</code>。</p></li><li><p>对于传统IP地址分类来说，A类地址的子网掩码是255.0.0.0；B类地址的子网掩码是255.255.0.0；C类地址的子网掩码是255.255.255.0。例如，如果要将一个B类网络166.111.0.0划分为多个C类子网来用的话，只要将其子网掩码设置为255.255.255.0即可，这样166.111.1.1和166.111.2.1就分属于不同的网络了。像这样，通过较长的子网掩码将一个网络划分为多个网络的方法就叫做划分子网(Subnetting)。</p></li></ul><h1 id="如何-私网与公网-连接"><a href="#如何-私网与公网-连接" class="headerlink" title="如何 私网与公网 连接"></a>如何 私网与公网 连接</h1><ul><li><p>需要将 <code>私有IP地址</code> 转换成 <code>公网IP地址</code>，与外部链接，因此，我们平时使用的 <code>路由器</code> 中会装有一个叫做 <code>NAT（网络地址转换）</code> 的软件，我们的 <code>路由器中会至少会有一个有效的公网IP</code>，NAT会将我们的私有地址转成路由器中的公网IP与外部Internet连接。这样做不仅提供了一定程度的安全，也可以有效的减缓可用的IP地址空间的枯竭问题。（像我们学校或者公司的内网一般都是这么做的）。</p></li><li><p>另外还有一点，在同一个 内网（局域网内） ，IP地址是唯一的；但是在不同的局域网内，IP地址是可以重复出现的。</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">举例: </span><br><span class="line">在局域网A中，有个主机的IP地址是192.168.10.128，那么绝不可能在局域网A中还有其他主机的IP地址为192.168.10.128。</span><br><span class="line"></span><br><span class="line">但是在局域网B中却可以有主机的IP地址也是192.168.10.128。</span><br><span class="line"></span><br><span class="line">如果局域网A中的192.168.10.128主机与局域网B中的192.168.10.128主机通信，不会冲突吗？不会，因为上述说过，它们最终都是使用路由器中的公网IP来连接外网的，而公网IP是全球唯一的。</span><br></pre></td></tr></table></figure></div><h1 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h1><p><code>127.0.0.1</code> 是 <code>本地回环地址</code>，指本地机，一般用来测试用，主要作用有：</p><ul><li><p>一是测试本机的网络配置，能 <code>PING</code> 通 <code>127.0.0.1</code> 说明本机的网卡和IP协议安装都没有问题</p></li><li><p>另一个作用是某些 <code>SERVER/CLIENT</code> 的应用程序在运行时需调用服务器上的资源，一般要指定SERVER的IP地址，但当该程序要在同一台机器上运行而没有别的SERVER时就可以把SERVER的资源装在本机，SERVER的IP地址设为127.0.0.1也同样可以运行。对于大多数习惯用localhost的来说，实质上就是指向127.0.0.1这个本地IP地址。在操作系统中有个配置文件将localhost与127.0.0.1绑定在了一起。</p></li></ul><h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><p>用于标示 <code>不同进程</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;IP地址（Internet Protocol Address）是指 &lt;code&gt;互联网协议地址&lt;/code&gt;，又译为 &lt;c</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-网络学习" scheme="https://www.bboyzj.cn/tags/OC-%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC网络学习12：App Extengsion-探索</title>
    <link href="https://www.bboyzj.cn/2023/07/04/OC%E7%BD%91%E7%BB%9C/OC%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A012%EF%BC%9AApp%20Extengsion-%E6%8E%A2%E7%B4%A2/"/>
    <id>https://www.bboyzj.cn/2023/07/04/OC%E7%BD%91%E7%BB%9C/OC%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A012%EF%BC%9AApp%20Extengsion-%E6%8E%A2%E7%B4%A2/</id>
    <published>2023-07-04T08:59:48.000Z</published>
    <updated>2023-07-15T05:35:40.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><p><code>Extension</code> 是 iOS8 新开发的一种对几个固定系统区域的扩展机制，它可以在一定程度上 <code>弥补</code> iOS 的 <code>沙盒机制对应用间通信的限制</code> 。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>简单的说，<code>App Extension</code> 可以让开发者们 <code>拓展自定义的功能和内容</code> 到应用程序之外，并在用户与其他应用程序或系统交互时提供给用户</p><h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>你可以创建一个 <code>App Extension</code>，通过打开一个特殊的 <code>开关</code>，如下：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307051511243.png"                                     ></p><ul><li><p>Share Extension：让用户从浏览器分享至其他社交软件中</p></li><li><p>Network Extension：给用户提供一个网络的扩展</p></li></ul><h1 id="扩展点（Extension-Point）"><a href="#扩展点（Extension-Point）" class="headerlink" title="扩展点（Extension Point）"></a>扩展点（Extension Point）</h1><ul><li><p><code>Extension Point</code>：启用扩展的区域称为 <code>扩展点</code>，系统中支持 <code>Extension</code> 的区域，<code>Extension</code> 的类别也是据此区分的，iOS上有 <code>Share、Action、Photo Editing、Custom Keyboard、Widget</code> 等。</p></li><li><p>每种 <code>Extension Point</code> 的使用方式和适合干的工作都不同，因此不存在通用的 <code>Extension Point</code></p></li></ul><h1 id="App"><a href="#App" class="headerlink" title="App"></a>App</h1><ul><li>就是我们正常手机里的每个应用程序，即 <code>Xcode</code> 运行后生成的程序。一个 <code>App</code> 可以包含一个或多个target，每个 <code>target</code> 将产生一个 <code>product</code></li></ul><h1 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h1><ul><li>Target : 在项目中新建一个 <code>Target</code> 来创建 <code>App Extension</code> ，任意一个 <code>Target</code> 指定了应用程序中构建 <code>Product</code> 的设置信息和文件。</li></ul><h1 id="扩展（App-Extension）"><a href="#扩展（App-Extension）" class="headerlink" title="扩展（App Extension）"></a>扩展（App Extension）</h1><ul><li><p><code>App Extension</code> 并不是一个独立的 <code>App</code>，它有一个包含在 <code>App Bundle</code> 中独立的 <code>Bundle</code>，其后缀名是 <code>.appex</code>，其 <code>生命周期</code> 和普通 <code>App</code> 不同。</p></li><li><p><code>App Extension</code> 不能单独存在，必须有一个包含它的 <code>Containing App</code>。</p></li><li><p>另外，<code>App Extension</code> 需要用户手动激活，不同的App Extension激活方式不同，比如：<code>Custom Keyboard</code> 需要在设置中进行相关设置；<code>Photo Editing</code> 需要在使用照片时在照片管理其中激活或关闭；<code>Share</code> 和 <code>Action</code> 可以在任何应用里被激活，但前提是开发者需要设置 <code>Activation Rules</code> ，以确定 <code>App Extension</code> 需要在合适出现。</p></li></ul><h1 id="Containing-App"><a href="#Containing-App" class="headerlink" title="Containing App"></a>Containing App</h1><ul><li><p>在 iOS 中 ，<code>App Extension</code> 并不能单独存在，要想提交到 <code>AppStore</code>，必须将 <code>App Extension</code> 包含在一个 <code>App</code> 中提交，并且 <code>App</code> 的实现部分不能为空，这个包含 <code>App Extension</code> 的 <code>App</code> 就叫 <code>Containing App</code>。</p></li><li><p>一个 <code>App</code> 可以包含一个或多个 <code>Extension</code>。</p></li></ul><h1 id="Host-App"><a href="#Host-App" class="headerlink" title="Host App"></a>Host App</h1><ul><li>包含 <code>App Extension</code> 并且能从中打开它(并不一定非要从此 <code>App</code> 内部打开，可以是 <code>App</code> 内部也可以)。我们可以把它理解为 <code>宿主App</code>，能够调起 <code>Extension</code> 的 <code>App</code> 被称为 <code>Host App</code></li></ul><h1 id="App-Extension-生命周期-Life-Cycle"><a href="#App-Extension-生命周期-Life-Cycle" class="headerlink" title="App Extension 生命周期 (Life Cycle)"></a>App Extension 生命周期 (Life Cycle)</h1><p>因为 <code>App Extension</code> 不是一个 <code>App</code>，它的 <code>生命周期</code> 和 <code>App</code> 是不同的，在大多情况下，当用户从 <code>App</code> 的UI上或者其他视图控制器中选择开启 <code>Extension</code> 功能的选项时将会开始执行。</p><ul><li><p>开始：<code>A Host App</code> 定义了上下文提供给 <code>Extension</code>， 当它发送一个请求并且用户正确响应后开启 <code>Extension</code> 的生命周期。</p></li><li><p>结束：通常会在完成 <code>Host App</code> 收到的请求后立即终止。</p></li></ul><h1 id="App-Extension-生命周期"><a href="#App-Extension-生命周期" class="headerlink" title="App Extension 生命周期"></a>App Extension 生命周期</h1><p>Extension 与 普通App 最大的区别就是 生命周期</p><ul><li>开始</li></ul><p>在用户通过 Host App 点击 Extension 时，系统会实例化 Extension 应用，这是生命周期的开始</p><ul><li>执行任务</li></ul><p>在 Extension 启动以后，开始执行它的使命</p><ul><li>终止</li></ul><p>在用户取消任务，或者任务执行结束，或者开启了一个长时间后台任务时，系统会将其杀掉</p><p>由此可见，<code>Extension</code> 就是为了 <code>任务</code> 而生</p><h1 id="App-Extension-和-Host-App-、Containing-App-如何通讯"><a href="#App-Extension-和-Host-App-、Containing-App-如何通讯" class="headerlink" title="App Extension 和 Host App 、Containing App 如何通讯"></a>App Extension 和 Host App 、Containing App 如何通讯</h1><ol><li>App Extension 和 Host App</li></ol><p>可以通过 ExtensionContext 属性直接通信，改属性是新增加的 UIViewController 类别：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">@interface UIViewController(NSExtensionAdditions) &lt;NSExtensionRequestHandling&gt;</span><br><span class="line"></span><br><span class="line">// Returns the extension context. Also acts as a convenience method for a view controller to check if it participating in an extension request.</span><br><span class="line">@property (nonatomic,readonly,retain) NSExtensionContext *extensionContext NS_AVAILABLE_IOS(8_0);</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p>实际上 <code>Extension</code> 和 <code>Host App</code> 之间是通过 <code>IPC（interprocess communication）</code> 实现的，只是苹果把调用接口高度抽象了，我们并不需要关注那么底层的东西。</p><ol start="2"><li>Containing App 和 Host App</li></ol><p>他们之间没有任何直接关系，也 <code>从来不需要通信</code>。</p><ol start="3"><li>App Extension 和 Containing App</li></ol><p>这二者之间的关系最复杂，纠纠缠缠扯不清关系。</p><ul><li>不能直接通信</li></ul><p>首先，尽管 <code>Extension</code> 的 <code>bundle</code> 是放在 <code>Containing App</code> 的 <code>bundle</code> 中，但是他们是两个完全独立的进程，之间 <code>不能直接通信</code>。</p><p>不过 <code>Extension</code> 可以通过 <code>openURL</code> 的方式启动 <code>Containing App</code>（当然也能启动其它app），不过必须通过 <code>extensionContext</code> 借助 <code>Host App</code> 来实现：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 通过openURL的方式启动Containing APP</span><br><span class="line">- (void)openURLContainingAPP&#123;</span><br><span class="line">    [self.extensionContext openURL:[NSURL URLWithString:@&quot;appextension://123&quot;] completionHandler:^(BOOL success) &#123;</span><br><span class="line">         NSLog(@&quot;open url result:%d&quot;,success);</span><br><span class="line">     &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><code>Extension</code> 中是无法直接使用 <code>openURL</code> 的。</p><ul><li>可以共享 <code>Shared Resources</code></li></ul><p><code>Extension</code> 和 <code>Containing App</code> 可以共同读写一个被称为 <code>Shred Resources</code> 的存储区域，这是通过 <code>App Group</code> 实现的。</p><ul><li>Containing App 能够控制 Extension 的出现和隐藏</li></ul><p>通过以下代码，Containing App 可以让 Extension 出现或隐藏（当然 Extension 也可以让自己隐藏）：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 让隐藏的插件重新显示</span><br><span class="line">- (void)showTodayExtension&#123;</span><br><span class="line">    [[NCWidgetController widgetController] setHasContent:YES forWidgetWithBundleIdentifier:@&quot;com.wangzz.app.extension&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 隐藏插件</span><br><span class="line">- (void)hiddeTodayExtension&#123;</span><br><span class="line">    [[NCWidgetController widgetController] setHasContent:NO forWidgetWithBundleIdentifier:@&quot;com.wangzz.app.extension&quot;];</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"># App Groups文件路径</span><br><span class="line"></span><br><span class="line">下面代码用于打印 App Groups路径、应用的可执行文件路径、对应的Documents路径：</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>&#x2F;&#x2F; App Groups路径<br>NSURL * containerURL &#x3D; [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:ApplicationGroupIdentifier];<br>NSLog(@”&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;app group:&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n%@”,containerURL.path);</p><p>&#x2F;&#x2F; 打印可执行文件路径<br>NSLog(@”&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;bundle:&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n%@”,[[NSBundle mainBundle] bundlePath]);</p><p>&#x2F;&#x2F; 打印documents<br>NSArray *paths &#x3D; NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);<br>NSString *path &#x3D; [paths objectAtIndex:0];<br>NSLog(@”&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;documents:&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n%@”,path);</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* Containing App</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>2023-07-05 16:56:31.862847+0800 零信任[20109:1279420] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;app group:&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x2F;private&#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Shared&#x2F;AppGroup&#x2F;2E1178DA-ED5B-49AD-ABCB-B49AD88F1D4D</p><p>2023-07-05 16:56:31.862926+0800 零信任[20109:1279420] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;bundle:&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x2F;private&#x2F;var&#x2F;containers&#x2F;Bundle&#x2F;Application&#x2F;F3FE7759-284D-4D79-A0FC-24D9F71EA9CF&#x2F;零信任.app</p><p>2023-07-05 16:56:38.918528+0800 零信任[20109:1279420] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;documents:&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;4E039FD4-7EB7-4A8B-B436-68BCA93DE2DC&#x2F;Documents</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* Extension 路径</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;app group:&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x2F;private&#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Shared&#x2F;AppGroup&#x2F;2E1178DA-ED5B-49AD-ABCB-B49AD88F1D4D</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;bundle:&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x2F;private&#x2F;var&#x2F;containers&#x2F;Bundle&#x2F;Application&#x2F;F3FE7759-284D-4D79-A0FC-24D9F71EA9CF&#x2F;零信任.app&#x2F;PlugIns&#x2F;tunnel.appex</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;documents:&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Data&#x2F;PluginKitPlugin&#x2F;213025D2-89D3-4938-B513-B2F3CB9D5F8F&#x2F;Documents</p><p>&#96;&#96;&#96;</p><p>由此可见，不管是 <code>Extension</code> 还是 <code>Containing App</code>，它们的可执行文件和保存数据的目录是分开存放的，即所有 <code>App</code> 的可执行文件都放在一个目录下，保存数据的目录保存在另一个目录下，同样，<code>App Groups</code> 放在另一个目录下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Extension&lt;/code&gt; 是 iOS8 新开发的一种对几个固定系统区域的扩展机制，它可以在一定程度上 &lt;code&gt;弥补&lt;</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-网络学习" scheme="https://www.bboyzj.cn/tags/OC-%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习67：键盘上添加工具条</title>
    <link href="https://www.bboyzj.cn/2023/07/04/OC/OC%E5%AD%A6%E4%B9%A067%EF%BC%9A%E9%94%AE%E7%9B%98%E4%B8%8A%E6%B7%BB%E5%8A%A0%E5%B7%A5%E5%85%B7%E6%9D%A1/"/>
    <id>https://www.bboyzj.cn/2023/07/04/OC/OC%E5%AD%A6%E4%B9%A067%EF%BC%9A%E9%94%AE%E7%9B%98%E4%B8%8A%E6%B7%BB%E5%8A%A0%E5%B7%A5%E5%85%B7%E6%9D%A1/</id>
    <published>2023-07-04T05:45:43.000Z</published>
    <updated>2023-07-04T05:51:18.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在实现项目中，我们在使用 <code>UITextField/UITextView</code> 时，往往需要唤起键盘进行文本输入，而在某些时候，我们需要在键盘上方添加一个工具条</p><h1 id="添加工具条的方法"><a href="#添加工具条的方法" class="headerlink" title="添加工具条的方法"></a>添加工具条的方法</h1><ol><li>自定义工具条视图</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface UnlockToolV : UIView</span><br><span class="line">// 忘记密码</span><br><span class="line">@property (nonatomic,strong)UIButton * forgetBtn;</span><br><span class="line">// 面容解锁</span><br><span class="line">@property (nonatomic,strong)UIButton * faceUnlockBtn;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br><span class="line"></span><br><span class="line">=================================================</span><br><span class="line"></span><br><span class="line">#import &quot;UnlockToolV.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation UnlockToolV</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame&#123;</span><br><span class="line">    self = [super initWithFrame:frame];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        [self initUI];</span><br><span class="line">        [self initMasonry];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化UI</span><br><span class="line">- (void)initUI&#123;</span><br><span class="line">    self.backgroundColor = kWhiteColor;</span><br><span class="line">    </span><br><span class="line">    [self addSubview:self.forgetBtn];</span><br><span class="line">    [self addSubview:self.faceUnlockBtn];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化Masonry</span><br><span class="line">- (void)initMasonry&#123;</span><br><span class="line">    [self.forgetBtn mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.left.mas_equalTo(20);</span><br><span class="line">        make.centerY.mas_equalTo(0);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    CGFloat faceUnlockBtn_w = self.faceUnlockBtn.width;</span><br><span class="line">    CGFloat faceUnlockBtn_h = self.faceUnlockBtn.height;</span><br><span class="line">    [self.faceUnlockBtn mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.right.mas_equalTo(-20);</span><br><span class="line">        make.centerY.mas_equalTo(0);</span><br><span class="line">        make.size.mas_equalTo(CGSizeMake(faceUnlockBtn_w, faceUnlockBtn_h));</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -懒加载</span><br><span class="line">- (UIButton *)forgetBtn&#123;</span><br><span class="line">    if (!_forgetBtn) &#123;</span><br><span class="line">        _forgetBtn = [UIButton initBtnWithFrame:CGRectZero bgColor:nil hidden:NO];</span><br><span class="line">        [_forgetBtn setTitle:@&quot;忘记密码&quot; titleColor:kMainThemeColor font:12 isBlod:NO];</span><br><span class="line">    &#125;</span><br><span class="line">    return _forgetBtn;</span><br><span class="line">&#125;</span><br><span class="line">- (UIButton *)faceUnlockBtn&#123;</span><br><span class="line">    if (!_faceUnlockBtn) &#123;</span><br><span class="line">        _faceUnlockBtn = [UIButton initBtnWithFrame:CGRectMake(0, 0, 70, 20) bgColor:nil hidden:NO];</span><br><span class="line">        [_faceUnlockBtn setTitle:@&quot;面容解锁&quot; titleColor:kMainThemeColor font:12 isBlod:NO];</span><br><span class="line">        [_faceUnlockBtn setImg:@&quot;unlock_face&quot; selectedImg:nil isSelect:NO];</span><br><span class="line">        [_faceUnlockBtn setStyle:BtnStyle_ImgLeft space:5];</span><br><span class="line">    &#125;</span><br><span class="line">    return _faceUnlockBtn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ol start="2"><li>在需要设置的控件上设置</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 声明头文件</span><br><span class="line">#import &quot;UnlockToolV.h&quot;</span><br><span class="line"></span><br><span class="line">// 声明属性</span><br><span class="line">@property (nonatomic,strong)UnlockToolV * toolV;</span><br><span class="line"></span><br><span class="line">// 设置</span><br><span class="line">[self.codeV.bottomTF setInputAccessoryView:self.toolV];</span><br><span class="line"></span><br><span class="line">// 懒加载</span><br><span class="line">- (UnlockToolV *)toolV&#123;</span><br><span class="line">    if (!_toolV) &#123;</span><br><span class="line">        _toolV = [[UnlockToolV alloc] initWithFrame:CGRectMake(0, 0, kScreenWidth, 44)];</span><br><span class="line">    &#125;</span><br><span class="line">    return _toolV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在实现项目中，我们在使用 &lt;code&gt;UITextField/UITextView&lt;/code&gt; 时，往往需要唤起键盘进行文本输入，而在某些</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习66：UIDocumentInteractionController 预览或分享文件</title>
    <link href="https://www.bboyzj.cn/2023/06/29/OC/OC%E5%AD%A6%E4%B9%A066%EF%BC%9AUIDocumentInteractionController-%E9%A2%84%E8%A7%88%E6%88%96%E5%88%86%E4%BA%AB%E6%96%87%E4%BB%B6/"/>
    <id>https://www.bboyzj.cn/2023/06/29/OC/OC%E5%AD%A6%E4%B9%A066%EF%BC%9AUIDocumentInteractionController-%E9%A2%84%E8%A7%88%E6%88%96%E5%88%86%E4%BA%AB%E6%96%87%E4%BB%B6/</id>
    <published>2023-06-29T00:28:57.000Z</published>
    <updated>2023-06-29T00:41:50.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p><code>UIDocumentInteractionController</code> 是 <code>OC</code> 语言的一个类，但是他并 <code>不是一个 controller</code>，而是一个继承自 <code>NSObject</code> 类。</p></li><li><p><code>UIDocumentInteractionController</code> 是一个强大的 <code>文档阅读器</code></p></li></ul><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul><li><p>预览文档，包括 <code>word文档、excel文档、pdf文档</code> 等等</p></li><li><p>调用iPhone里第三方的app打开文档</p></li><li><p>将文档用系统级分享到各个应用中（包括QQ、微信、邮箱等）</p></li><li><p>如果有条件配备支持AirPrint的打印机的话，就可以直接打印文档</p></li><li><p>一次只能浏览一个文件</p></li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>声明</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">// 代理</span><br><span class="line">@interface ViewController ()&lt;UIDocumentInteractionControllerDelegate&gt;</span><br><span class="line"></span><br><span class="line">// 属性</span><br><span class="line">@property (nonatomic,strong)UIDocumentInteractionController * document;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>调用</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 预览 文件</span><br><span class="line">- (void)previewFileWithFilePath:(NSString *)filePath&#123;</span><br><span class="line">    NSURL * fileURL = [NSURL fileURLWithPath:filePath];</span><br><span class="line">    self.documentC = [UIDocumentInteractionController interactionControllerWithURL:fileURL];</span><br><span class="line">    // 设置分享代理</span><br><span class="line">    self.documentC.delegate = self;</span><br><span class="line">    // 哪类文件支持第三方打开，这里不证明就代表所有文件！</span><br><span class="line">    //    _document.UTI = @&quot;com.microsoft.word.doc&quot;;</span><br><span class="line">    // 判断手机中有没有应用可以打开该文件并打开分享界面</span><br><span class="line">    // 用户预览文件</span><br><span class="line">    BOOL canOpen = [self.documentC presentPreviewAnimated:YES];</span><br><span class="line">    if (!canOpen) &#123;</span><br><span class="line">        NSLog(@&quot;预览失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>代理回调</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL)documentInteractionController:(UIDocumentInteractionController *)controller canPerformAction:(nullable SEL)action&#123;</span><br><span class="line">    // 响应方法</span><br><span class="line">    NSLog(@&quot;12 %s&quot;, __func__);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">-(BOOL)documentInteractionController:(UIDocumentInteractionController *)controller performAction:(nullable SEL)action&#123;</span><br><span class="line">    //</span><br><span class="line">    NSLog(@&quot;13 %s&quot;, __func__);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">-(void)documentInteractionControllerWillPresentOptionsMenu:(UIDocumentInteractionController *)controller&#123;</span><br><span class="line">    // 页面显示后响应</span><br><span class="line">    NSLog(@&quot;9 %s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">-(void)documentInteractionControllerDidDismissOptionsMenu:(UIDocumentInteractionController *)controller&#123;</span><br><span class="line">    // 取消时响应</span><br><span class="line">    NSLog(@&quot;10 %s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">// 返回预览的控制器</span><br><span class="line">-(UIViewController *)documentInteractionControllerViewControllerForPreview:(UIDocumentInteractionController *)controller&#123;</span><br><span class="line">    NSLog(@&quot;1 %s&quot;, __func__);</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">// 返回预览视图</span><br><span class="line">-(UIView *)documentInteractionControllerViewForPreview:(UIDocumentInteractionController *)controller&#123;</span><br><span class="line">    NSLog(@&quot;2 %s&quot;, __func__);</span><br><span class="line">    return self.view;</span><br><span class="line">&#125;</span><br><span class="line">// 返回预览视图的frame</span><br><span class="line">-(CGRect)documentInteractionControllerRectForPreview:(UIDocumentInteractionController *)controller&#123;</span><br><span class="line">    NSLog(@&quot;3 %s&quot;, __func__);</span><br><span class="line">    return self.view.frame;</span><br><span class="line">&#125;</span><br><span class="line">// 文件分享面板退出时调用</span><br><span class="line">-(void)documentInteractionControllerDidDismissOpenInMenu:(UIDocumentInteractionController *)controller&#123;</span><br><span class="line">    NSLog(@&quot;4 %s&quot;, __func__);</span><br><span class="line">    NSLog(@&quot;dismiss&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 文件分享面板弹出的时候调用</span><br><span class="line">-(void)documentInteractionControllerWillPresentOpenInMenu:(UIDocumentInteractionController *)controller&#123;</span><br><span class="line">    NSLog(@&quot;5 %s&quot;, __func__);</span><br><span class="line">    NSLog(@&quot;WillPresentOpenInMenu&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 当选择一个文件分享App的时候调用</span><br><span class="line">-(void)documentInteractionController:(UIDocumentInteractionController *)controller willBeginSendingToApplication:(nullable NSString *)application&#123;</span><br><span class="line">    NSLog(@&quot;6 %s&quot;, __func__);</span><br><span class="line">    NSLog(@&quot;begin send : %@&quot;, application);</span><br><span class="line">&#125;</span><br><span class="line">// Preview presented/dismissed on document.  Use to set up any HI underneath.</span><br><span class="line">-(void)documentInteractionControllerWillBeginPreview:(UIDocumentInteractionController *)controller&#123;</span><br><span class="line">    NSLog(@&quot;7 %s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">// 完成时响应</span><br><span class="line">-(void)documentInteractionControllerDidEndPreview:(UIDocumentInteractionController *)controller&#123;</span><br><span class="line">    NSLog(@&quot;8 %s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">-(void)documentInteractionController:(UIDocumentInteractionController *)controller didEndSendingToApplication:(nullable NSString *)application&#123;</span><br><span class="line">    NSLog(@&quot;11 %s&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>后续讲 <code>QLPreviewController</code> ，<code>可以一起浏览多个文件</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;UIDocumentInteractionController&lt;/code&gt; 是 &lt;code&gt;OC&lt;/code</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC网络学习13：数据共享App Groups探索</title>
    <link href="https://www.bboyzj.cn/2023/06/27/OC%E7%BD%91%E7%BB%9C/OC%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A013%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%ABApp%20Groups%E6%8E%A2%E7%B4%A2/"/>
    <id>https://www.bboyzj.cn/2023/06/27/OC%E7%BD%91%E7%BB%9C/OC%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A013%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%ABApp%20Groups%E6%8E%A2%E7%B4%A2/</id>
    <published>2023-06-27T05:51:15.000Z</published>
    <updated>2023-07-15T05:37:56.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p><code>App Groups</code> 即 <code>数据共享空间</code>，这是 <code>iOS8</code> 新开放的功能，在 <code>OS X</code> 上早已存在。</p></li><li><p><code>App Groups</code> 主要用于同一 <code>App Groups</code> 下的 <code>不同App</code> 共享同一份 <code>读写空间</code>，以实现数据共享</p></li><li><p><code>App Groups</code> 也可以用于 <code>Containing App</code> 和 <code>Extension</code> 共同读写一份数据，比如：系统的股市应用等</p></li></ul><blockquote><p>注：只能使用于同一个开发者账号，如果不同开发者账号请考虑剪切板 <code>UIPasteboard</code></p></blockquote><h1 id="创建-App-Groups"><a href="#创建-App-Groups" class="headerlink" title="创建 App Groups"></a>创建 App Groups</h1><ol><li>登录开发者账号创建 <code>App Groups</code></li></ol><ul><li><p>打开如下链接：<a class="link"   href="https://developer.apple.com/account/ios/certificate/development" >https://developer.apple.com/account/ios/certificate/development <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 登录开发者账号，开启 <code>App Groups</code></p></li><li><p>添加描述：</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307051630192.png"                                     ></p><ul><li>填写 Identifier</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307051630603.png"                                     ></p><ul><li>最后 确认</li></ul><ol start="2"><li>Xcode 中配置</li></ol><p>请确保你的开发者账号在Xcode上处于登录状态，以便下面的操作，<code>Xcode</code> 中配置 <code>App Group</code>（注意：要用到数据共享的工程都要配置 <code>Extension</code> 和 <code>Containing App</code> 都需要配置）</p><ul><li>在 <code>Extension</code> 中开启</li></ul><p>TARGET -&gt; App Extension Demo -&gt; Capabilities -&gt; App Groups -&gt; 双击添加，添加之后，会根据配置的自动证书去生成 <code>groups</code>，命名规则：<code>group.Bundle Identifier</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307051630926.png"                                     ></p><ul><li>在 Containing App 中开启</li></ul><p>同理：TARGET -&gt; Host App -&gt; App Groups </p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307051630831.png"                                     ></p><ul><li>创建 <code>App Groups</code> 成功后，会生成 <code>Extitlements File</code> 文件，<code>Containing App</code> 和 <code>Extension</code> 相同</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307051631653.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307051631904.png"                                     ></p><h1 id="Containing-App-与-Extension-数据共享"><a href="#Containing-App-与-Extension-数据共享" class="headerlink" title="Containing App 与 Extension 数据共享"></a>Containing App 与 Extension 数据共享</h1><p>配置工作完成，接下来，就是实现数据共享代码</p><ol><li>通过 <code>NSUserDefaults</code> 共享数据</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// NSUserDefaults</span><br><span class="line">self.userDefaultes = [[NSUserDefaults alloc] initWithSuiteName:group];</span><br></pre></td></tr></table></figure></div><ul><li>存数据</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 保存数据到共享空间</span><br><span class="line">- (BOOL)setObject:(nullable id)value forKey:(NSString *_Nullable)key&#123;</span><br><span class="line">    if (!value || !key) return false;</span><br><span class="line">    [self.userDefaultes setObject:value forKey:key];</span><br><span class="line">    [self.userDefaultes synchronize];</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>取数据</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 从共享空间取值</span><br><span class="line">- (nullable id)objectForKey:(NSString *_Nullable)key&#123;</span><br><span class="line">    if (!key) return nil;</span><br><span class="line"></span><br><span class="line">    return [self.userDefaultes objectForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>注：<br>1、保存数据的时候必须指明 group identifier<br>2、而且要注意 NSUserDefaults 能够处理的数据只能是可 plist 化的对象，详情见 Property List Programming Guide 。<br>3、为了防止出现数据同步问题，不要忘记调用 synchronize;</p></blockquote><ol start="2"><li>通过 <code>NSFileManager</code> 共享数据</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过 containerURLForSecurityApplicationGroupIdentifier 方法和 共享域标识符 我们可以获取到该共享域的路径</span><br><span class="line">self.url = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:group];</span><br></pre></td></tr></table></figure></div><p>利用 <code>NSFileManager</code> 我们可以存取各种文件，数据库文件（.db），json文件，framework等等；<br>我们可以复制各种文件到 <code>App Groups</code> 的存取区域，在 <code>另一个App/Extension</code> 中拿出来</p><ul><li>写入文件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 写入 jsonStr dic data array</span><br><span class="line">// 写入 jsonStr</span><br><span class="line">- (BOOL)writeToFile:(NSString *)filename withJsonStr:(NSString *)jsonStr&#123;</span><br><span class="line">    // 拼接文件名</span><br><span class="line">    NSURL * fileURL = [self.url URLByAppendingPathComponent:filename];</span><br><span class="line">    // jsonStr</span><br><span class="line">    return [jsonStr writeToURL:fileURL atomically:YES encoding:NSUTF8StringEncoding error:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>读取文件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 读取 jsonStr dic data array</span><br><span class="line">// 读取jsonStr</span><br><span class="line">- (NSString*)readJsonStrFromFile:(NSString *)filename&#123;</span><br><span class="line">    NSURL * fileURL = [self.url URLByAppendingPathComponent:filename];</span><br><span class="line">    BOOL isExist = [self isExistFile:filename];</span><br><span class="line">    if (isExist) &#123;</span><br><span class="line">        NSString * str = [NSString stringWithContentsOfURL:fileURL encoding:NSUTF8StringEncoding error:nil];</span><br><span class="line">        return str;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;文件不存在&quot;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;App Groups&lt;/code&gt; 即 &lt;code&gt;数据共享空间&lt;/code&gt;，这是 &lt;code&gt;iOS8&lt;/</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-网络学习" scheme="https://www.bboyzj.cn/tags/OC-%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC网络学习11：Network Extension探索</title>
    <link href="https://www.bboyzj.cn/2023/06/25/OC%E7%BD%91%E7%BB%9C/OC%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A011%EF%BC%9ANetwork%20Extension%E6%8E%A2%E7%B4%A2/"/>
    <id>https://www.bboyzj.cn/2023/06/25/OC%E7%BD%91%E7%BB%9C/OC%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A011%EF%BC%9ANetwork%20Extension%E6%8E%A2%E7%B4%A2/</id>
    <published>2023-06-25T03:35:59.000Z</published>
    <updated>2023-07-15T05:35:33.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>苹果提供的 <code>Network Extension</code> 可以帮助我们配置VPN通道，自定义和拓展核心网络功能。</p><h1 id="Network-Extension-功能类型"><a href="#Network-Extension-功能类型" class="headerlink" title="Network Extension 功能类型"></a>Network Extension 功能类型</h1><p><code>Network Extension</code> 一共提供了 <code>App Proxy、Content Filter、Packet Tunnel、DNS Proxy、DNS Settings</code> 五种功能。</p><ul><li>App Proxy：Proxy TCP and UDP network connections</li></ul><p>App 代理：代理TCP和UDP网络连接</p><ul><li>Content Filter：Allow or deny network connections</li></ul><p>内容过滤：允许或拒绝网络连接</p><ul><li>Packet Tunnel：Tunnel IP packets using a tunneling network protocol</li></ul><p>Packet隧道：可以实现本地连接并成功拦截IP数据包packets</p><ul><li>DNS Proxy：Proxy DNS queries</li></ul><p>DNS 代理：代理DNS查询</p><ul><li>DNS Settings：Configure settings for encrypted DNS</li></ul><p>DNS设置：配置加密DNS</p><h1 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h1><ol><li>核心技术</li></ol><ul><li><p>苹果提供了 <code>Network Extension</code> 可以帮助我们配置 <code>VPN</code> 通道。</p></li><li><p>在iOS9中，开发者可以用 <code>NETunnelProvider</code> 扩展核心网络层，从而 <code>实现非标准化的私密VPN</code> 技术，最重要的两个类是 <code>NETunnelProviderManager</code> 和 <code>NEPacketTunnelProvider</code></p></li></ul><ol start="2"><li>创建 Network Extension 步骤</li></ol><ul><li>新建 Target</li></ul><p>在已经创建好的项目中新建 Target：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16886350195240.jpg"                                     ></p><p>创建完成后，<code>TARGET</code> 下会增加一个名为 <code>Tunnel</code> 的扩展，左侧项目中系统会为我们自动生成对应的模板：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16886352509313.jpg"                                     ></p><ol start="2"><li>PacketTunnelProvide 模板中的代码</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 启动VPN时调用</span><br><span class="line">/*</span><br><span class="line"> 当一个新的通道被建立会会调用此函数。我们必须通过重写该类来完成建立连接。</span><br><span class="line"> @param : options - 在主控制调用开启VPN连接时传入的字典，可空。</span><br><span class="line"> @param : completionHandler - 在该方法彻底完成时必须调用这个Block。如果不能建立连接要将错误信息传给该block,如果成功建立连接则只需将nil传给该Block.</span><br><span class="line"> */</span><br><span class="line">- (void)startTunnelWithOptions:(NSDictionary *)options completionHandler:(void (^)(NSError *))completionHandler &#123;</span><br><span class="line">    NSLog(@&quot;=====启动VPN时调用 startTunnelWithOptions=====&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 停止VPN时调用</span><br><span class="line">- (void)stopTunnelWithReason:(NEProviderStopReason)reason completionHandler:(void (^)(void))completionHandler &#123;</span><br><span class="line">    NSLog(@&quot;=====停止VPN时调用 stopTunnelWithReason=====&quot;);</span><br><span class="line">    completionHandler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 处理App消息时调用</span><br><span class="line">- (void)handleAppMessage:(NSData *)messageData completionHandler:(void (^)(NSData *))completionHandler &#123;</span><br><span class="line">    // Add code here to handle the message.</span><br><span class="line">    NSLog(@&quot;=====处理App消息时调用:=====\n%@&quot;,messageData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 准备休眠时调用</span><br><span class="line">- (void)sleepWithCompletionHandler:(void (^)(void))completionHandler &#123;</span><br><span class="line">    // Add code here to get ready to sleep.</span><br><span class="line">    NSLog(@&quot;=====准备休眠时调用:=====&quot;);</span><br><span class="line">    completionHandler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 被唤醒时调用</span><br><span class="line">- (void)wake &#123;</span><br><span class="line">    // Add code here to wake up.</span><br><span class="line">    NSLog(@&quot;=====被唤醒时调用=====&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="3"><li>配置 Network Extension 信息</li></ol><ul><li>配置 Signing</li></ul><p>勾选 <code>Autimatically manage signing</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16886360232265.jpg"                                     ></p><ul><li>开启权限</li></ul><p>主 <code>Target</code> 和 <code>VPN扩展</code> 均需要打开 <code>Person VPN</code> 和  <code>Network Extensions</code> 两个权限，开启后会新增两个 <code>.extitlements</code> 结尾的配置文件</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16886360074059.jpg"                                     ></p><h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><ol><li>实现步骤</li></ol><ul><li>导入必须框架头文件</li></ul><p>在项目中导入 <code>#import &lt;NetworkExtension/NetworkExtension.h&gt; </code></p><ol start="2"><li>初始化并配置 <code>NETunnleProviderManager</code> 对象</li></ol><ul><li>建立 <code>VPN</code> 连接前负责配置基本参数信息保存设置到系统中（一般 <code>VPN App</code> 都会在第一次打开App时授权并保存配置参数信息到系统的VPN设置中）</li></ul><blockquote><p>注：配置好的 <code>NETunnleProviderManager</code> 对象仅在系统中起展示作用（这里的配置并不是真正的生效），真正生效的设置在 <code>Extension Target</code> 中配置</p></blockquote><ul><li><p><code>NETunnleProviderManager</code> 类继承了 NEVPNManager 大多数基本功能：</p><ul><li><code>protocolConfiguration</code> 属性只有 <code>NETunnleProviderManager</code> 类才能设置</li><li><code>connection</code> 这个只读属性只能通过 <code>NETunnleProviderManager</code> 这个类设置</li></ul></li><li><p>每个 <code>NETunnleProviderManager</code> 实例对应一个 VPN 配置，存储在 Network Extension 偏好设置中，可以创建多个 <code>NETunnleProviderManager</code> 实例来管理 <code>多个VPN配置</code>。</p></li><li><p><code>NETunnleProviderManager</code> 创建的 <code>VPN</code> 配置归属 <code>企业VPN</code> 配置，<code>NEVPNManager</code> 创建的 <code>VPN</code> 归属于 <code>个人VPN</code></p></li><li><p>一次只能在系统启用一个 VPN 配置，如果同时在系统中激活 <code>个人VPN</code> 和 <code>企业VPN</code>，优先使用 <code>企业VPN</code></p></li></ul><ol start="3"><li>初始化 <code>NETunnleProviderManager</code> 的代码</li></ol><p>在主Target下实现：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 保存VPN相关数据</span><br><span class="line">- (void)saveVpnData&#123;</span><br><span class="line">    /*</span><br><span class="line">     此函数异步读取调用所有app创建且先前保存在本地的 NETunnelProvider 配置信息，并将它们在回调中以一个存放 NETunnelProvider 对象的数组的形式返回</span><br><span class="line">     */</span><br><span class="line">    [NETunnelProviderManager loadAllFromPreferencesWithCompletionHandler:^(NSArray&lt;NETunnelProviderManager *&gt; * _Nullable managers, NSError * _Nullable error) &#123;</span><br><span class="line">        if (error)&#123;</span><br><span class="line">            NSLog(@&quot;LoadFromPreferences Error: %@&quot;, error.description);</span><br><span class="line">        &#125;</span><br><span class="line">        // manager</span><br><span class="line">        NETunnelProviderManager * manager;</span><br><span class="line">        if (managers.count &gt; 0) &#123;</span><br><span class="line">            manager = managers[0];</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            manager = [[NETunnelProviderManager alloc] init];</span><br><span class="line">            manager.protocolConfiguration = [[NETunnelProviderProtocol alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 配置 manager</span><br><span class="line">        [self configTunnelManagerWithManager:manager];</span><br><span class="line">        </span><br><span class="line">        // 调用此方法用来保存上述配置好的VPN到本机设备的VPN设置中</span><br><span class="line">        [self.tpManager saveToPreferencesWithCompletionHandler:^(NSError * _Nullable error) &#123;</span><br><span class="line">            if (error)&#123;</span><br><span class="line">                NSLog(@&quot;Save  To Preferences Error：%@&quot;,error.description);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                NSLog(@&quot;Save To Preferences Success&quot;);</span><br><span class="line">                // 启动 VPN</span><br><span class="line">                [self startVPN];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">// 配置 VPN 协议</span><br><span class="line">- (void)configTunnelManagerWithManager:(NETunnelProviderManager *)manager&#123;</span><br><span class="line">    /*</span><br><span class="line">     注：以下参数只是在系统设置中 VPN 设置里显示的参数，真正设置网络参数在 VPN Target 项目中重新设置。</span><br><span class="line">     */</span><br><span class="line">    // 协议(配置好协议后，会自动跳转到 iPhone，当你输入好密码后，VPN会自动配置好相关信息并返回到App)</span><br><span class="line">    NETunnelProviderProtocol * proto = [[NETunnelProviderProtocol alloc] init];</span><br><span class="line">    // 子项目的identifier</span><br><span class="line">    proto.providerBundleIdentifier = @&quot;com.jit.cn.MobileCertManagement.sdp.tunnel&quot;;</span><br><span class="line">    </span><br><span class="line">    // 配置</span><br><span class="line">//    NSMutableDictionary * configDic = @&#123;&#125;.mutableCopy;</span><br><span class="line">//    [configDic setObject:@&quot;5055&quot; forKey:@&quot;port&quot;]; // 随机</span><br><span class="line">//    [configDic setObject:@&quot;www.jit.com.cn&quot; forKey:@&quot;server&quot;];</span><br><span class="line">//    [configDic setObject:@&quot;10.10.10.8&quot; forKey:@&quot;ip&quot;];</span><br><span class="line">//    [configDic setObject:@&quot;255.255.255.0&quot; forKey:@&quot;subnet&quot;];</span><br><span class="line">//    [configDic setObject:@&quot;1400&quot; forKey:@&quot;mtu&quot;];</span><br><span class="line">//    [configDic setObject:@&quot;8.8.8.8,8.4.4.4&quot; forKey:@&quot;dns&quot;];</span><br><span class="line">//    proto.providerConfiguration = configDic;</span><br><span class="line">    </span><br><span class="line">    // 手机设置的vpn中显示的vpn地址（服务器）</span><br><span class="line">    proto.serverAddress = @&quot;www.jit.com.cn&quot;;</span><br><span class="line">    // 设备进入睡眠，vpn断开连接</span><br><span class="line">    proto.disconnectOnSleep = NO;</span><br><span class="line">    </span><br><span class="line">    // 协议配置</span><br><span class="line">    manager.protocolConfiguration = proto;</span><br><span class="line">    // 包含vpn描述的字符串(类型)</span><br><span class="line">    manager.localizedDescription = @&quot;零信任&quot;;</span><br><span class="line">    // 是否可以编辑</span><br><span class="line">    manager.enabled = YES;</span><br><span class="line">    </span><br><span class="line">    // 赋值</span><br><span class="line">    self.tpManager = manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ol start="4"><li>启动 VPN</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 启动 VPN</span><br><span class="line">- (void)startVPN&#123;</span><br><span class="line">    // 此函数从调用者的VPN设置中加载当前VPN配置</span><br><span class="line">    [self.tpManager loadFromPreferencesWithCompletionHandler:^(NSError * _Nullable error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            NSLog(@&quot;LoadFromPreferences error:%@&quot;,error.description);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            NSLog(@&quot;LoadFromPreferences success&quot;);</span><br><span class="line">            // 启动VPN</span><br><span class="line">            NSError * connectError;</span><br><span class="line">            // 调用此函数会使用 NEVPNConnection 对当前VPN配置来建立VPN连接。返回YES表示成功。</span><br><span class="line">            [self.tpManager.connection startVPNTunnelAndReturnError:&amp;connectError];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ol start="5"><li>关闭VPN连接</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 断开连接</span><br><span class="line">- (void)disconnectVpn&#123;</span><br><span class="line">    // 此函数从调用者的VPN设置中加载当前VPN配置</span><br><span class="line">    [self.tpManager loadFromPreferencesWithCompletionHandler:^(NSError * _Nullable error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            NSLog(@&quot;loadFromPreferences error:%@&quot;,error.localizedDescription);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            // 调用此函数会关闭当前建立的VPN连接</span><br><span class="line">            [self.tpManager.connection stopVPNTunnel];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ol start="6"><li>监听VPN连接状态</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 添加VPN连接通知</span><br><span class="line">- (void)addVPNNotification&#123;</span><br><span class="line">    // 添加通知 - 连接VPN时会发送通知</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onVpnStateChange:) name:NEVPNStatusDidChangeNotification object:nil];</span><br><span class="line">&#125;</span><br><span class="line">// 通知的方法</span><br><span class="line">- (void)onVpnStateChange:(NSNotification *)Notification &#123;</span><br><span class="line">    // VPN连接的状态</span><br><span class="line">    NEVPNStatus status = self.tpManager.connection.status;</span><br><span class="line">    switch (status) &#123;</span><br><span class="line">        case NEVPNStatusInvalid:&#123;</span><br><span class="line">            NSLog(@&quot;VPN连接无效&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case NEVPNStatusDisconnected:&#123;</span><br><span class="line">            NSLog(@&quot;VPN未连接&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case NEVPNStatusConnecting:&#123;</span><br><span class="line">            NSLog(@&quot;VPN正在连接...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case NEVPNStatusConnected: &#123;</span><br><span class="line">            NSLog(@&quot;VPN已连接&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case NEVPNStatusDisconnecting:&#123;</span><br><span class="line">            NSLog(@&quot;VPN断开连接中...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case NEVPNStatusReasserting:&#123;</span><br><span class="line">            NSLog(@&quot;VPN重新连接...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="7"><li>在 PacketTunnelProvider 回调中完成剩余工作</li></ol><ul><li>当我们在 <code>主Target</code> 中调用开启VPN连接后，会进入 <code>VPN Target</code> 项目的 <code>PacketTunnelProvider</code> 文件下述方法：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 当一个新的通道被建立会会调用此函数。我们必须通过重写该类来完成建立连接。</span><br><span class="line"> @param : options - 在主控制调用开启VPN连接时传入的字典，可空。</span><br><span class="line"> @param : completionHandler - 在该方法彻底完成时必须调用这个Block。如果不能建立连接要将错误信息传给该block,如果成功建立连接则只需将nil传给该Block.</span><br><span class="line"> */</span><br><span class="line">- (void)startTunnelWithOptions:(NSDictionary *)options completionHandler:(void (^)(NSError *))completionHandler &#123;</span><br><span class="line">    NSLog(@&quot;=====启动VPN时调用 startTunnelWithOptions=====&quot;);</span><br><span class="line">    // 建立VPN连接</span><br><span class="line">    [self setupVpnTunnelConnect:completionHandler];</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark - 建立 VPN 连接</span><br><span class="line">// 建立 VPN 连接</span><br><span class="line">- (void)setupVpnTunnelConnect:(void (^)(NSError *))completionHandler&#123;</span><br><span class="line">    </span><br><span class="line">    // 建立 VPN 网络配置</span><br><span class="line">    NEPacketTunnelNetworkSettings * settings = [self setupVpnTunnelNetworkConfig];</span><br><span class="line">    </span><br><span class="line">    //  建立 VPN 连接</span><br><span class="line">    __weak __typeof(&amp;*self)weakSelf = self;</span><br><span class="line">    [self setTunnelNetworkSettings:settings completionHandler:^(NSError * _Nullable error) &#123;</span><br><span class="line">        if (error)&#123;</span><br><span class="line">            NSLog(@&quot;=====建立 VPN 连接 Error:%@=====&quot;,error.description);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            NSLog(@&quot;=====建立 VPN 连接 Success=====&quot;);</span><br><span class="line">            // 启动并运行socks5隧道</span><br><span class="line">            [weakSelf startSockstTunnel];</span><br><span class="line">        &#125;</span><br><span class="line">        completionHandler(error);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>这里是真正设置 <code>VPN tunnel</code> 网络参数的地方，主 <code>target</code> 中设置的仅为系统 <code>VPN</code> 设置中的展示名称</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// VPN网络配置</span><br><span class="line">- (NEPacketTunnelNetworkSettings *)setupVpnTunnelNetworkConfig&#123;</span><br><span class="line">    // 我们要建立连接的远程服务器的地址(如果是域名，则需要解析成ip地址)</span><br><span class="line">    NSString * remoteAddress = @&quot;172.16.21.222&quot;;</span><br><span class="line">    </span><br><span class="line">    // 新建一个 NEPacketTunnelNetworkSettings 对象</span><br><span class="line">    NEPacketTunnelNetworkSettings * settings = [[NEPacketTunnelNetworkSettings alloc] initWithTunnelRemoteAddress:remoteAddress];</span><br><span class="line">    </span><br><span class="line">    // 最大传输单元,即每个packet最大的容量</span><br><span class="line">//    settings.MTU = 1400;</span><br><span class="line">    </span><br><span class="line">    /* ipv4 用于拦截流量/代理 */</span><br><span class="line">    // 虚拟ip</span><br><span class="line">    NSString * ip = @&quot;10.10.10.8&quot;;</span><br><span class="line">    NSString * subNet = @&quot;255.255.255.0&quot;;</span><br><span class="line">    NEIPv4Settings * ipv4Settings = [[NEIPv4Settings alloc] initWithAddresses:@[ip]</span><br><span class="line">                                                                  subnetMasks:@[subNet]];</span><br><span class="line">    /*</span><br><span class="line">     includedRoutes:即VPN tunnel需要拦截包的地址，如果全部拦截则设置[NEIPv4Route defaultRoute]，也可以指定部分需要拦截的地址</span><br><span class="line">     */</span><br><span class="line">    NEIPv4Route * route = [[NEIPv4Route alloc] initWithDestinationAddress:@&quot;172.16.156.243&quot;</span><br><span class="line">                                                              subnetMask:@&quot;255.255.255.255&quot;];</span><br><span class="line">    ipv4Settings.includedRoutes = @[route];</span><br><span class="line">    // 配置ipv4代理</span><br><span class="line">    settings.IPv4Settings = ipv4Settings;</span><br><span class="line">    </span><br><span class="line">    // DNS 解析器（由于 不处理 IP Package）</span><br><span class="line">    NSString * dns = @&quot;8.8.8.8,8.4.4.4&quot;;</span><br><span class="line">    NEDNSSettings * dnsSettings = [[NEDNSSettings alloc] initWithServers:[dns componentsSeparatedByString:@&quot;,&quot;]];</span><br><span class="line">    settings.DNSSettings = dnsSettings;</span><br><span class="line">    </span><br><span class="line">    return settings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>域名转换ip</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"> </span><br><span class="line">// 域名转换IP</span><br><span class="line">- (NSString *)queryIpWithDomain:(NSString *)domain &#123;</span><br><span class="line">    struct hostent *hs;</span><br><span class="line">    struct sockaddr_in server;</span><br><span class="line">    if ((hs = gethostbyname([domain UTF8String])) != NULL) &#123;</span><br><span class="line">        server.sin_addr = *((struct in_addr*)hs-&gt;h_addr_list[0]);</span><br><span class="line">        return [NSString stringWithUTF8String:inet_ntoa(server.sin_addr)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>在 VPN Tunnel 中持续读取 packet 包</li></ul><p>因为我们已经成功建立了 VPN 连接，所以网络数据包我们可以在此回调中截取到，利用 <code>NEPacketTunnelProvider</code> 对象的 <code>packetFlow</code> 完成下面的方法即可。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">从流中读入可用的IP包</span><br><span class="line">- (void)readPakcets &#123;</span><br><span class="line">    __weak PacketTunnelProvider *weakSelf = self;</span><br><span class="line">    [self.packetFlow readPacketsWithCompletionHandler:^(NSArray&lt;NSData *&gt; * _Nonnull packets, NSArray&lt;NSNumber *&gt; * _Nonnull protocols) &#123;</span><br><span class="line">        for (NSData *packet in packets) &#123;</span><br><span class="line">            // log4cplus_debug(&quot;TVUVPNManager&quot;, &quot;Read Packet - %s&quot;,[NSString stringWithFormat:@&quot;%@&quot;,packet].UTF8String);</span><br><span class="line">            __typeof__(self) strongSelf = weakSelf;</span><br><span class="line">            // TODO ...</span><br><span class="line">            </span><br><span class="line">            NSLog(@&quot;XDX : read packet - %@&quot;,packet);</span><br><span class="line">        &#125;</span><br><span class="line">        [weakSelf readPakcets];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></div><ul><li>查看打印结果</li></ul><blockquote><p>注：由于此时是处于另一个 <code>Target</code> 中，在手机中相当于另一条进程，因此我们无法直接在控制台看到任何打印的 <code>log</code> 信息，如果想要看到 <code>log</code> 信息，需要如下配置：<br>1、Debug -&gt; Attach to Process by PID or Name… </p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307070838025.png"                                     ></p><blockquote><p>2、启动台 -&gt; 控制台 -&gt; 设备（张建的 iPhone）-&gt; tunnel(进程) ：查看 <code>NSLog</code> 打印结果</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在 iOS 中：</p><ul><li><p>如果您 <code>启用</code> 此功能，您的所有流量都将 <code>被 VPN 隧道加密</code>，<code>本地流量</code> 将通过您的 <code>VPN</code>。</p></li><li><p>如果它被 <code>禁用</code>，并且您正在浏览互联网，它可以通过本地 WiFi 或 VPN，具体取决于 VPN 提供的路由。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;苹果提供的 &lt;code&gt;Network Extension&lt;/code&gt; 可以帮助我们配置VPN通道，自定义和拓展核心网络功能。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-网络学习" scheme="https://www.bboyzj.cn/tags/OC-%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC网络学习09：VPN探索</title>
    <link href="https://www.bboyzj.cn/2023/06/21/OC%E7%BD%91%E7%BB%9C/OC%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A009%EF%BC%9AVPN%E6%8E%A2%E7%B4%A2/"/>
    <id>https://www.bboyzj.cn/2023/06/21/OC%E7%BD%91%E7%BB%9C/OC%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A009%EF%BC%9AVPN%E6%8E%A2%E7%B4%A2/</id>
    <published>2023-06-21T10:50:21.000Z</published>
    <updated>2023-07-15T05:35:18.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是VPN？"><a href="#什么是VPN？" class="headerlink" title="什么是VPN？"></a>什么是VPN？</h1><p><code>VPN</code>（Virtual Private Network）即 <code>虚拟专用网络</code>，随着互联网的飞速发展，网络安全问题也日益受到广泛关注。在这种情况下，使用 <code>VPN</code> 变得越来越普遍，<code>VPN</code> 可以为用户提供更加安全的上网环境，可以 <code>外网访问内网、隐藏用户的IP地址、加密用户的数据流</code> 等，从而达到保护用户隐私的目的。</p><h1 id="iPhone手机如何设置VPN"><a href="#iPhone手机如何设置VPN" class="headerlink" title="iPhone手机如何设置VPN"></a>iPhone手机如何设置VPN</h1><ol><li><p>打开 <code>设置</code> 菜单，找到 <code>通用</code> 选项。</p></li><li><p>在 <code>通用</code> 菜单下，找到 <code>VPN</code> 选项并点击。</p></li><li><p>点击 <code>添加VPN配置</code> 以创建一个新的VPN连接。</p></li><li><p>在 <code>类型</code> 选项下，选择你的VPN协议类型，例如：<code>IPSec/IKEv2/L2TP</code> 等，这将取决于你的VPN提供商支持的协议类型</p></li><li><p>每种 <code>协议类型</code> 下，需要输入所需的 <code>VPN</code> 信息，例如：<code>IPsec</code> - 包括 <code>描述、服务器、账户、密码、使用证书、群组名称、秘钥</code> 等信息。如果你不知道这些信息，可以联系你的VPN服务提供商获取。</p></li><li><p>点击完成，你已经成功地建立了一个 <code>VPN</code> 连接。</p></li><li><p>点击 <code>VPN</code> 选项，启用你的 <code>VPN</code> 连接。</p></li></ol><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>完成以上步骤后，你就可以开始使用 <code>VPN</code> 了。当你启用 <code>VPN</code> 连接时，你的设备将会连接到远程 <code>VPN</code> 服务器，从而为你提供更加安全的上网环境。同样，在你不需要使用 <code>VPN</code> 时，也可以在 <code>VPN</code> 选项下禁用你的 <code>VPN</code> 连接。</p><p>总的来说，如何在iOS系统上设置 <code>VPN</code> 并不是一件难事。只需按照以上步骤，在你的设备上进行相应操作即可。<code>VPN</code> 可以为你提供更加安全的上网环境，从而保护你的个人隐私。我们建议你使用 <code>VPN</code>，以确保你的网络连接始终得到保护。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是VPN？&quot;&gt;&lt;a href=&quot;#什么是VPN？&quot; class=&quot;headerlink&quot; title=&quot;什么是VPN？&quot;&gt;&lt;/a&gt;什么是VPN？&lt;/h1&gt;&lt;p&gt;&lt;code&gt;VPN&lt;/code&gt;（Virtual Private Network）即 &lt;code&gt;虚</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-网络学习" scheme="https://www.bboyzj.cn/tags/OC-%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习46：App跳转到系统设置各页面</title>
    <link href="https://www.bboyzj.cn/2023/06/21/OC/OC%E5%AD%A6%E4%B9%A046%EF%BC%9AApp%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E5%90%84%E9%A1%B5%E9%9D%A2/"/>
    <id>https://www.bboyzj.cn/2023/06/21/OC/OC%E5%AD%A6%E4%B9%A046%EF%BC%9AApp%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E5%90%84%E9%A1%B5%E9%9D%A2/</id>
    <published>2023-06-21T06:11:03.000Z</published>
    <updated>2023-06-21T06:14:03.404Z</updated>
    
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习20：便捷初始化器convenience</title>
    <link href="https://www.bboyzj.cn/2023/06/21/Swift/Swift%E5%AD%A6%E4%B9%A020%EF%BC%9A%E4%BE%BF%E6%8D%B7%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8convenience/"/>
    <id>https://www.bboyzj.cn/2023/06/21/Swift/Swift%E5%AD%A6%E4%B9%A020%EF%BC%9A%E4%BE%BF%E6%8D%B7%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8convenience/</id>
    <published>2023-06-21T05:45:57.000Z</published>
    <updated>2023-06-21T05:49:39.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="便捷初始化器"><a href="#便捷初始化器" class="headerlink" title="便捷初始化器"></a>便捷初始化器</h1><p>在 <code>swift</code> 中，同一个类中的不同的 <code>init()</code> 方法，是不同直接使用 <code>self.init()</code> 平行调用的，必须使用关键字 <code>convenience</code> 修饰的 <code>init方法</code> 才能调用，这种 init方法叫做 <code>便捷初始化器</code></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person: NSObject &#123;</span><br><span class="line">    var name:String?</span><br><span class="line">    // 自定义初始化器</span><br><span class="line">    init(name: String? = nil) &#123;</span><br><span class="line">        self.name = name;</span><br><span class="line">        print(self.name as Any);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 便利初始化器</span><br><span class="line">    convenience init(age: Int) &#123;</span><br><span class="line">        print(age);</span><br><span class="line">        // 只有便利选择器才能调用同级的初始化器</span><br><span class="line">        self.init(name:&quot;ZJ&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>调用：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let p = Person.init(age: 30);</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;便捷初始化器&quot;&gt;&lt;a href=&quot;#便捷初始化器&quot; class=&quot;headerlink&quot; title=&quot;便捷初始化器&quot;&gt;&lt;/a&gt;便捷初始化器&lt;/h1&gt;&lt;p&gt;在 &lt;code&gt;swift&lt;/code&gt; 中，同一个类中的不同的 &lt;code&gt;init()&lt;/code&gt; 方</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习19：必要初始化器required</title>
    <link href="https://www.bboyzj.cn/2023/06/21/Swift/Swift%E5%AD%A6%E4%B9%A019%EF%BC%9A%E5%BF%85%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8required/"/>
    <id>https://www.bboyzj.cn/2023/06/21/Swift/Swift%E5%AD%A6%E4%B9%A019%EF%BC%9A%E5%BF%85%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8required/</id>
    <published>2023-06-21T01:50:11.000Z</published>
    <updated>2023-06-21T03:02:30.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义的类"><a href="#自定义的类" class="headerlink" title="自定义的类"></a>自定义的类</h1><p>如果 <code>父类初始化方法</code> 指定了 <code>required</code>，那么 <code>子类</code> 必须实现这个 <code>初始化方法</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202306211056779.png"                                     ></p><p><code>子类</code> 必须实现必要初始化器的 初始化方法：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">required init() &#123;</span><br><span class="line">    fatalError(&quot;init() has not been implemented&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="继承自系统的-UIView"><a href="#继承自系统的-UIView" class="headerlink" title="继承自系统的 UIView"></a>继承自系统的 UIView</h1><p>如果是继承自系统的UIView，有了初始化方法（自定义的或重写父类的），则必须实现：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">required init?(coder: NSCoder) &#123;</span><br><span class="line">    fatalError(&quot;init(coder:) has not been implemented&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这是因为 <code>UIView</code> 遵循了 <code>NSCoding</code> 协议，协议中的 <code>init</code> 方法是被 <code>required</code> 修饰的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自定义的类&quot;&gt;&lt;a href=&quot;#自定义的类&quot; class=&quot;headerlink&quot; title=&quot;自定义的类&quot;&gt;&lt;/a&gt;自定义的类&lt;/h1&gt;&lt;p&gt;如果 &lt;code&gt;父类初始化方法&lt;/code&gt; 指定了 &lt;code&gt;required&lt;/code&gt;，那么 &lt;code</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>OC学习62：isKindOfClass和isMemberOfClass和isSubclassOfClass的区别</title>
    <link href="https://www.bboyzj.cn/2023/06/20/OC/OC%E5%AD%A6%E4%B9%A062%EF%BC%9AisKindOfClass%E5%92%8CisMemberOfClass%E5%92%8CisSubclassOfClass%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://www.bboyzj.cn/2023/06/20/OC/OC%E5%AD%A6%E4%B9%A062%EF%BC%9AisKindOfClass%E5%92%8CisMemberOfClass%E5%92%8CisSubclassOfClass%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2023-06-20T03:29:43.000Z</published>
    <updated>2023-06-20T05:06:54.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="isKindOfClass-实例方法"><a href="#isKindOfClass-实例方法" class="headerlink" title="isKindOfClass 实例方法"></a>isKindOfClass 实例方法</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isKindOfClass:(Class)aClass</span><br><span class="line"></span><br><span class="line">Description    </span><br><span class="line">Returns a Boolean value that indicates whether the receiver is an instance of given class or an instance of any class that inherits from that class. (required)</span><br><span class="line"> </span><br><span class="line">// 意思是返回一个BOOL类型的值，该值表示 接收者 是 给定类的实例 还是从 该类继承的任何类 的实例。</span><br></pre></td></tr></table></figure></div><h1 id="isMemberOfClass-实例方法"><a href="#isMemberOfClass-实例方法" class="headerlink" title="isMemberOfClass 实例方法"></a>isMemberOfClass 实例方法</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isMemberOfClass:(Class)aClass</span><br><span class="line"></span><br><span class="line">Description    </span><br><span class="line">Returns a Boolean value that indicates whether the receiver is an instance of a given class. (required)</span><br><span class="line"> </span><br><span class="line">// 意思是返回一个BOOL类型的值，该值表示 接收者 是否为给定类的实例</span><br></pre></td></tr></table></figure></div><h1 id="isSubclassOfClass-类方法"><a href="#isSubclassOfClass-类方法" class="headerlink" title="isSubclassOfClass 类方法"></a>isSubclassOfClass 类方法</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 注意这是一个类方法</span><br><span class="line">+ (BOOL)isSubclassOfClass:(Class)aClass</span><br><span class="line"></span><br><span class="line">Description    </span><br><span class="line">Returns a Boolean value that indicates whether the receiving class is a subclass of, or identical to, a given class.</span><br><span class="line"> </span><br><span class="line">// 意思是返回一个BOOL类型的值，该值表示调用 该方法的类 是不是 参数类的一个子类 或者 是这个类的本身</span><br><span class="line"></span><br><span class="line">// isSubclassOfClass 和 isKindOfClass 的作用基本上是一致的，只不过一个是类方法，一个是实例方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>ZJ类 继承自 Person类</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">#import &quot;ZJ.h&quot;</span><br><span class="line"></span><br><span class="line">ZJ * zj = [ZJ new];</span><br><span class="line">BOOL a = [zj isKindOfClass:[Person class]];</span><br><span class="line">NSLog(@&quot;zj 是否是 Person类或子类的 实例:%d&quot;,a);</span><br><span class="line">BOOL b = [zj isKindOfClass:[ZJ class]];</span><br><span class="line">NSLog(@&quot;zj 是否是 ZJ类或子类的 实例:%d&quot;,b);</span><br><span class="line">BOOL c = [zj isMemberOfClass:[Person class]];</span><br><span class="line">NSLog(@&quot;zj 是否是 Person类的 实例:%d&quot;,c);</span><br><span class="line">BOOL d = [zj isMemberOfClass:[ZJ class]];</span><br><span class="line">NSLog(@&quot;zj 是否是 ZJ类的 实例:%d&quot;,d);</span><br><span class="line"></span><br><span class="line"> BOOL e = [ZJ isSubclassOfClass:[Person class]];</span><br><span class="line">NSLog(@&quot;ZJ类 是否是 Person类或子类：%d&quot;,e);</span><br><span class="line">BOOL f = [ZJ isSubclassOfClass:[ZJ class]];</span><br><span class="line">NSLog(@&quot;ZJ类 是否是 ZJ类或子类：%d&quot;,e);</span><br></pre></td></tr></table></figure></div><p>查看打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2023-06-20 11:44:45.308153+0800 isKindOfClass和isMemberOfClass[49380:3374953] zj 是否是 Person类或子类的 实例:1</span><br><span class="line">2023-06-20 11:44:45.308219+0800 isKindOfClass和isMemberOfClass[49380:3374953] zj 是否是 ZJ类或子类的 实例:1</span><br><span class="line">2023-06-20 11:44:45.308246+0800 isKindOfClass和isMemberOfClass[49380:3374953] zj 是否是 Person类的 实例:0</span><br><span class="line">2023-06-20 11:44:45.308268+0800 isKindOfClass和isMemberOfClass[49380:3374953] zj 是否是 ZJ类的 实例:1</span><br><span class="line"></span><br><span class="line">2023-06-20 13:06:29.706747+0800 isKindOfClass和isMemberOfClass[49888:3410485] ZJ类 是否是 Person类或子类：1</span><br><span class="line">2023-06-20 13:06:29.706766+0800 isKindOfClass和isMemberOfClass[49888:3410485] ZJ类 是否是 ZJ类或子类：1</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;isKindOfClass-实例方法&quot;&gt;&lt;a href=&quot;#isKindOfClass-实例方法&quot; class=&quot;headerlink&quot; title=&quot;isKindOfClass 实例方法&quot;&gt;&lt;/a&gt;isKindOfClass 实例方法&lt;/h1&gt;&lt;div clas</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC三方框架06：SVProgressHUD探索</title>
    <link href="https://www.bboyzj.cn/2023/06/19/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B606%EF%BC%9ASVProgressHUD%E6%8E%A2%E7%B4%A2/"/>
    <id>https://www.bboyzj.cn/2023/06/19/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B606%EF%BC%9ASVProgressHUD%E6%8E%A2%E7%B4%A2/</id>
    <published>2023-06-19T09:48:07.000Z</published>
    <updated>2023-06-19T10:03:09.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SVProgressHUD 是对提示框的一个封装库，里面的方法都是类方法，并且对象是通过单例创建。由于方法都是通过类名调用，简单明了。</p><h1 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+ (void)show;    显示:状态是一个迅速转动的圈</span><br><span class="line">+ (void)showWithMaskType:(SVProgressHUDMaskType)maskType; 显示并且带着一个状态</span><br><span class="line">+ (void)showWithStatus:(NSString*)status; 显示并且带着文字</span><br><span class="line">+ (void)showWithStatus:(NSString*)status maskType:(SVProgressHUDMaskType)maskType;</span><br><span class="line"> </span><br><span class="line">+ (void)showProgress:(float)progress;  //显示进度:状态是一个进度圈</span><br><span class="line">+ (void)showProgress:(float)progress maskType:(SVProgressHUDMaskType)maskType;</span><br><span class="line">+ (void)showProgress:(float)progress status:(NSString*)status;</span><br><span class="line">+ (void)showProgress:(float)progress status:(NSString*)status maskType:(SVProgressHUDMaskType)maskType;</span><br><span class="line"> </span><br><span class="line">+ (void)setStatus:(NSString*)string; // 改变正显示着的HUD的文字</span><br><span class="line"> </span><br><span class="line">// stops the activity indicator, shows a glyph + status, and dismisses HUD a little bit later</span><br><span class="line">+ (void)showInfoWithStatus:(NSString *)string;   //显示消息信息，其实就是中心图片更换了</span><br><span class="line">+ (void)showInfoWithStatus:(NSString *)string maskType:(SVProgressHUDMaskType)maskType;</span><br><span class="line"> </span><br><span class="line">+ (void)showSuccessWithStatus:(NSString*)string; //显示成功消息</span><br><span class="line">+ (void)showSuccessWithStatus:(NSString*)string maskType:(SVProgressHUDMaskType)maskType;</span><br><span class="line"> </span><br><span class="line">+ (void)showErrorWithStatus:(NSString *)string; //显示错误消息</span><br><span class="line">+ (void)showErrorWithStatus:(NSString *)string maskType:(SVProgressHUDMaskType)maskType;</span><br><span class="line"> </span><br><span class="line">// use 28x28 white pngs</span><br><span class="line">+ (void)showImage:(UIImage*)image status:(NSString*)status; //显示自己设置的图片,图片大小事28 * 28 px</span><br><span class="line">+ (void)showImage:(UIImage*)image status:(NSString*)status maskType:(SVProgressHUDMaskType)maskType;</span><br><span class="line"> </span><br><span class="line">+ (void)setOffsetFromCenter:(UIOffset)offset; //距离中心点的偏移量</span><br><span class="line">+ (void)resetOffsetFromCenter; //返回中心点</span><br><span class="line"> </span><br><span class="line">+ (void)popActivity; // 消除一个HUD，根据其实现方法如果前面有执行了好几次show方法，如果给定的progress == 0 或者 pregress &lt; 0那样就会让使一个参数+1，执行这个方法会使那个参数-1，如果参数==0时 执行dismiss方法。</span><br><span class="line">+ (void)dismiss; 消失</span><br><span class="line"> </span><br><span class="line">+ (BOOL)isVisible; 是否正在显示</span><br></pre></td></tr></table></figure></div><h1 id="关于HUD的属性配置"><a href="#关于HUD的属性配置" class="headerlink" title="关于HUD的属性配置"></a>关于HUD的属性配置</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 背景颜色</span><br><span class="line">+ (void)setBackgroundColor:(UIColor*)color; // default is [UIColor whiteColor]</span><br><span class="line"></span><br><span class="line">// progress 和 label颜色</span><br><span class="line">+ (void)setForegroundColor:(UIColor*)color; // default is [UIColor blackColor]</span><br><span class="line"> </span><br><span class="line">// progress 宽度</span><br><span class="line">+ (void)setRingThickness:(CGFloat)width; // default is 4 pt</span><br><span class="line"></span><br><span class="line">// 字体         </span><br><span class="line">+ (void)setFont:(UIFont*)font; // default is [UIFont preferredFontForTextStyle:UIFontTextStyleSubheadline]</span><br><span class="line"></span><br><span class="line">// 消息的图片        </span><br><span class="line">+ (void)setInfoImage:(UIImage*)image; // default is the bundled info image provided by Freepik</span><br><span class="line"></span><br><span class="line">// 成功时的图片</span><br><span class="line">+ (void)setSuccessImage:(UIImage*)image; // default is the bundled success image provided by Freepik</span><br><span class="line"></span><br><span class="line">// 失败时的图片</span><br><span class="line">+ (void)setErrorImage:(UIImage*)image; // default is the bundled error image provided by Freepik</span><br><span class="line"></span><br><span class="line">// 当HUD显示时，用户是否可以点击其他控件</span><br><span class="line">+ (void)setDefaultMaskType:(SVProgressHUDMaskType)maskType; // default is SVProgressHUDMaskTypeNone</span><br><span class="line"> </span><br><span class="line">SVProgressHUDMaskTypeNone = 1,  // 允许用户进行其他用户操作</span><br><span class="line">SVProgressHUDMaskTypeClear,     // 不允许用户进行其他用户操作</span><br><span class="line">SVProgressHUDMaskTypeBlack,     // 不允许用户进行其他用户操作，并且背景是黑色的</span><br><span class="line">SVProgressHUDMaskTypeGradient   // 允许用户进行其他用户操作，并且背景是渐变的黑色</span><br><span class="line"> </span><br><span class="line">// 可以延展一个图片必须设置</span><br><span class="line">+ (void)setViewForExtension:(UIView*)view; </span><br></pre></td></tr></table></figure></div><h1 id="关于HUD的通知"><a href="#关于HUD的通知" class="headerlink" title="关于HUD的通知"></a>关于HUD的通知</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 在HUD外点击</span><br><span class="line">extern NSString * const SVProgressHUDDidReceiveTouchEventNotification; </span><br><span class="line"></span><br><span class="line">// 在HUD中点击</span><br><span class="line">extern NSString * const SVProgressHUDDidTouchDownInsideNotification; </span><br><span class="line"></span><br><span class="line">// 将要显示</span><br><span class="line">extern NSString * const SVProgressHUDWillDisappearNotification;  </span><br><span class="line"></span><br><span class="line">// 已经显示</span><br><span class="line">extern NSString * const SVProgressHUDDidDisappearNotification;   </span><br><span class="line"></span><br><span class="line">// 将要消失</span><br><span class="line">extern NSString * const SVProgressHUDWillAppearNotification;    </span><br><span class="line"></span><br><span class="line">// 已经消失</span><br><span class="line">extern NSString * const SVProgressHUDDidAppearNotification;      </span><br><span class="line"></span><br><span class="line">// HUD的状态</span><br><span class="line">extern NSString * const SVProgressHUDStatusUserInfoKey; </span><br></pre></td></tr></table></figure></div><p>在通知中 <code>userInfo</code> 字典中存储了 <code>HUD</code> 的状态，其 <code>key</code> 为 <code>SVProgressHUDStatusUserInfoKey</code></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol><li>在Podfile中安装</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#x27;SVProgressHUD&#x27;</span><br></pre></td></tr></table></figure></div><ul><li>导入SVProgressHUD</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;SVProgressHUD.h&quot;</span><br></pre></td></tr></table></figure></div><ol start="2"><li>SVProgressHUD弹窗</li></ol><ul><li>SVProgressHUD可以显示一直旋转的进度条：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 显示一直旋转的进度条</span><br><span class="line">+ (void)show;</span><br><span class="line">// 显示一直旋转的进度条和状态</span><br><span class="line">+ (void)showWithStatus:(nullable NSString*)status;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202306191758511.png"                                     ></p><ul><li>SVProgressHUD可以显示具体进度的进度条。</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 显示进度条，progress为 0~1</span><br><span class="line">+ (void)showProgress:(float)progress;</span><br><span class="line">// 显示进度条和状态</span><br><span class="line">+ (void)showProgress:(float)progress status:(nullable NSString*)status;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202306191759347.png"                                     ></p><ul><li>SVProgressHUD可以显示图标和状态。</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 显示消息图标和状态</span><br><span class="line">+ (void)showInfoWithStatus:(nullable NSString*)status;</span><br><span class="line">// 显示成功图标和状态</span><br><span class="line">+ (void)showSuccessWithStatus:(nullable NSString*)status;</span><br><span class="line">// 显示错误图标和状态</span><br><span class="line">+ (void)showErrorWithStatus:(nullable NSString*)status;</span><br><span class="line">// 显示自定义图标和状态</span><br><span class="line">+ (void)showImage:(nonnull UIImage*)image status:(nullable NSString*)status;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202306191759046.png"                                     ></p><ul><li>SVProgressHUD关闭弹窗</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 关闭弹窗</span><br><span class="line">+ (void)dismiss;</span><br><span class="line">// 关闭弹窗，并执行completion</span><br><span class="line">+ (void)dismissWithCompletion:(nullable SVProgressHUDDismissCompletion)completion;</span><br><span class="line">// 延迟关闭弹窗</span><br><span class="line">+ (void)dismissWithDelay:(NSTimeInterval)delay;</span><br><span class="line">// 延迟关闭弹窗，并执行completion</span><br><span class="line">+ (void)dismissWithDelay:(NSTimeInterval)delay completion:(nullable SVProgressHUDDismissCompletion)completion;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ol start="3"><li>主要方法</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 提示框背景和文字，默认是SVProgressHUDStyleLight</span><br><span class="line">+ (void)setDefaultStyle:(SVProgressHUDStyle)style;</span><br><span class="line">// 背景图层，默认SVProgressHUDMaskTypeNone</span><br><span class="line">+ (void)setDefaultMaskType:(SVProgressHUDMaskType)maskType;</span><br><span class="line">// 设置进度条样式，默认SVProgressHUDAnimationTypeFlat</span><br><span class="line">+ (void)setDefaultAnimationType:(SVProgressHUDAnimationType)type;</span><br><span class="line"></span><br><span class="line">// 提示框文字颜色，默认黑色，只在style为SVProgressHUDStyleCustom有效</span><br><span class="line">+ (void)setForegroundColor:(nonnull UIColor*)color;</span><br><span class="line">// 提示框背景颜色，默认白色，只在style为SVProgressHUDStyleCustom有效</span><br><span class="line">+ (void)setBackgroundColor:(nonnull UIColor*)color;</span><br><span class="line">// 背景图层，默认半透明，只在style为SVProgressHUDStyleCustom有效</span><br><span class="line">+ (void)setBackgroundLayerColor:(nonnull UIColor*)color;</span><br><span class="line"></span><br><span class="line">// 状态字体，默认[UIFont preferredFontForTextStyle:UIFontTextStyleSubheadline]</span><br><span class="line">+ (void)setFont:(nonnull UIFont*)font;</span><br><span class="line">// 提示框的边角弯曲半径，默认14pt</span><br><span class="line">+ (void)setCornerRadius:(CGFloat)cornerRadius;</span><br><span class="line">// 转圈宽度，默认2pt</span><br><span class="line">+ (void)setRingThickness:(CGFloat)ringThickness;</span><br><span class="line">// 转圈半径，默认18pt</span><br><span class="line">+ (void)setRingRadius:(CGFloat)radius;</span><br><span class="line">// 没有文字时的转圈半径，默认24pt</span><br><span class="line">+ (void)setRingNoTextRadius:(CGFloat)radius;</span><br><span class="line"></span><br><span class="line">// 设置消息图片</span><br><span class="line">+ (void)setInfoImage:(nonnull UIImage*)image;</span><br><span class="line">// 设置成功图片</span><br><span class="line">+ (void)setSuccessImage:(nonnull UIImage*)image;</span><br><span class="line">// 设置错误图片</span><br><span class="line">+ (void)setErrorImage:(nonnull UIImage*)image;</span><br><span class="line">// 设置图片大小，默认28x28pt</span><br><span class="line">+ (void)setImageViewSize:(CGSize)size;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>SVProgressHUDStyle定义提示框背景和文字</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, SVProgressHUDStyle) &#123;</span><br><span class="line">    SVProgressHUDStyleLight,        // 默认类型，白色半透明背景，黑色字体</span><br><span class="line">    SVProgressHUDStyleDark,         // 黑色背景，白色字体</span><br><span class="line">    SVProgressHUDStyleCustom        // 白色背景，黑色字体</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202306191801823.png"                                     ></p><ul><li>SVProgressHUDMaskType定义背景图层</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, SVProgressHUDMaskType) &#123;</span><br><span class="line">    SVProgressHUDMaskTypeNone = 1,  // 默认类型，允许与后面界面交互</span><br><span class="line">    SVProgressHUDMaskTypeClear,     // 不允许与后面界面交互</span><br><span class="line">    SVProgressHUDMaskTypeBlack,     // 不允许与后面界面交互，背景图层为半透明</span><br><span class="line">    SVProgressHUDMaskTypeGradient,  // 不允许与后面界面交互，背景图层为渐变变化</span><br><span class="line">    SVProgressHUDMaskTypeCustom     // 不允许与后面界面交互，背景图层为自定义</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>SVProgressHUDAnimationType是转圈样式</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, SVProgressHUDAnimationType) &#123;</span><br><span class="line">    SVProgressHUDAnimationTypeFlat,     // 默认转圈样式</span><br><span class="line">    SVProgressHUDAnimationTypeNative    // 菊花型转圈样式</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202306191802901.png"                                     ></p><ol start="4"><li>SVProgressHUD通知</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 提示框即将出现</span><br><span class="line">NSString * const SVProgressHUDWillAppearNotification = @&quot;SVProgressHUDWillAppearNotification&quot;;</span><br><span class="line">// 提示框已经出现</span><br><span class="line">NSString * const SVProgressHUDDidAppearNotification = @&quot;SVProgressHUDDidAppearNotification&quot;;</span><br><span class="line"></span><br><span class="line">// 提示框即将消失</span><br><span class="line">NSString * const SVProgressHUDWillDisappearNotification = @&quot;SVProgressHUDWillDisappearNotification&quot;;</span><br><span class="line">// 提示框已经消失</span><br><span class="line">NSString * const SVProgressHUDDidDisappearNotification = @&quot;SVProgressHUDDidDisappearNotification&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;SVProgressHUD 是对提示框的一个封装库，里面的方法都是类方法，并且对象是通过单例创建。由于方法都是通过类名调用，简单明了。&lt;/p</summary>
      
    
    
    
    <category term="OC-三方框架探索篇" scheme="https://www.bboyzj.cn/categories/OC-%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%B4%A2%E7%AF%87/"/>
    
    
    <category term="iOS-OC" scheme="https://www.bboyzj.cn/tags/iOS-OC/"/>
    
  </entry>
  
</feed>
