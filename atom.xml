<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张建的博客</title>
  <icon>https://www.gravatar.com/avatar/134cc2bfaf649e446f661778f4112fca</icon>
  <subtitle>成功的道路上只有荆棘，没有坦途</subtitle>
  <link href="https://www.bboyzj.cn/atom.xml" rel="self"/>
  
  <link href="https://www.bboyzj.cn/"/>
  <updated>2023-03-30T05:45:47.542Z</updated>
  <id>https://www.bboyzj.cn/</id>
  
  <author>
    <name>小J</name>
    <email>13718004742@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>性能优化05：Network 网络</title>
    <link href="https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605%EF%BC%9ANetwork%20%E7%BD%91%E7%BB%9C/"/>
    <id>https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605%EF%BC%9ANetwork%20%E7%BD%91%E7%BB%9C/</id>
    <published>2023-09-10T04:13:29.000Z</published>
    <updated>2023-03-30T05:45:47.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="弱网优化"><a href="#弱网优化" class="headerlink" title="弱网优化"></a>弱网优化</h1><ul><li><p>所谓弱网络，指在网络不好的情况下使用APP，如 <code>2G、3G网络</code>，用户的网络速度基本在 <code>10k/s~60k/s</code>。</p></li><li><p>考虑海外应用的话，就必须考虑弱网优化的方案了。</p></li><li><p>苹果建议，使用苹果内置的 <code>Network Link Conditioner</code> 来模拟网络环境处理 <code>APP</code> 的体验问题，在Xcode和手机都可以开启</p></li></ul><h1 id="Xcode：系统偏好设置"><a href="#Xcode：系统偏好设置" class="headerlink" title="Xcode：系统偏好设置"></a>Xcode：系统偏好设置</h1><h1 id="iPhone：开发者-gt-Network-Link-Conditioner"><a href="#iPhone：开发者-gt-Network-Link-Conditioner" class="headerlink" title="iPhone：开发者 -&gt; Network Link Conditioner"></a>iPhone：开发者 -&gt; Network Link Conditioner</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;弱网优化&quot;&gt;&lt;a href=&quot;#弱网优化&quot; class=&quot;headerlink&quot; title=&quot;弱网优化&quot;&gt;&lt;/a&gt;弱网优化&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;所谓弱网络，指在网络不好的情况下使用APP，如 &lt;code&gt;2G、3G网络&lt;/code&gt;，用户的网络速度基</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>性能优化04：Energy 耗电</title>
    <link href="https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604%EF%BC%9AEnergy%20%E8%80%97%E7%94%B5/"/>
    <id>https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604%EF%BC%9AEnergy%20%E8%80%97%E7%94%B5/</id>
    <published>2023-09-10T04:13:29.000Z</published>
    <updated>2023-03-30T05:53:39.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>所有应用程序在执行网络操作、更新用户界面或在CPU上运行代码时都会消耗能量。随着用户越来越多地依赖电池电量，以及应用程序的激增，能效已成为用户体验中不可或缺的一部分。</p><h1 id="电池寿命"><a href="#电池寿命" class="headerlink" title="电池寿命"></a>电池寿命</h1><p>随着能源效率的下降，<code>电池</code> 的寿命也会下降。同时消耗过多的资源会导致界面滞后，对用户输入的响应会很慢。随着越来越多的应用程序使用越来越多的资源，系统工作起来越来越努力，速度也越来越快，设备的物理温度也在逐渐升高。当这种情况发生时，系统会采取措施将温度降低到更容易接受的水平。</p><h1 id="能量消耗的因素"><a href="#能量消耗的因素" class="headerlink" title="能量消耗的因素"></a>能量消耗的因素</h1><ol><li><p>CPU: CPU是能源的主要消耗者。高CPU使用周期会迅速耗尽用户的电池。 CPU使用率超过20%就会快速耗干电池电量——建议只在必要时通过 <code>批处理、调度和优先级排序</code> 来完成工作。</p></li><li><p>GPU: 图形处理器(显卡的处理器)，乱使用GPU会导致交互差，并且降低电池寿命。</p></li><li><p>Network：大多数iOS应用程序执行网络操作。当联网发生时，蜂窝无线电和Wi-Fi等组件就会启动并消耗能量。通过 <code>批量处理和减少事务、压缩数据和适当处理错误</code>，您的应用程序可以为节能做出重大贡献。</p></li><li><p>Location: 许多应用程序发出位置请求是为了记录用户的物理活动或提供基于环境的警报。能量消耗随着精确度的提高和位置请求的延长而增加。你的应用应该尽可能减少定位活动的准确性和持续时间。当不再需要时停止位置请求。</p></li><li><p>Background: <code>后台</code> 状态App仍会消耗电量，App要按需执行后台操作，并使用延迟APNS来保证系统运算高效执行。另外，在app进入后台状态是，立即减少动作，并且通知系统一次这些动作已经完成</p></li><li><p>Bluetooth: 长时间的 <code>蓝牙</code> 活动会耗尽iOS设备和蓝牙设备的电池。只要可能，批处理和缓冲蓝牙活动，并减少对数据的轮询。</p></li><li><p>Device wakes：iOS设备依靠睡眠来延长电池寿命。无论设备何时唤醒，都会有很高的开销成本，因为必须为屏幕和其他资源提供电源。你的应用程序，尤其是在后台操作时，应该尽可能空闲，除非绝对必要，避免用推送通知或其他活动唤醒设备</p></li></ol><h1 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h1><ol><li><p>Time Profile：时间分析器分析模板。使用此模板对正在运行的进程执行低开销的基于时间的采样。Time Profiler 监视应用程序中正在运行的线程，并定期采样。为每个样本收集完整的回溯，允许您深入查看样本，以准确找到代码中花费大量时间的位置。</p></li><li><p>Animation Hitches：核心动画分析模板。使用此模板可以测量图形性能和CPU使用率。启用模板 Core Animation 的 <code>Flash Updated Regions</code> 设置，以查看应用中发生的每个屏幕更新，并观察不必要或意外的更新。</p></li><li><p>Activity Monitor: 活动监视器分析模板。使用此模板可以监视整体CPU，磁盘I&#x2F;O和网络使用情况。</p></li></ol><h1 id="Energy-log调试和演示"><a href="#Energy-log调试和演示" class="headerlink" title="Energy log调试和演示"></a>Energy log调试和演示</h1><ol><li>检查第一步，是通过xcode开发工具的 <code>energy impact</code> 来整体查看app的耗电情况。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303231852146.png"                                     ></p><p>Overhead：表示开销，包括CPU的唤起，无线电模组(蓝牙&amp;WiFi)，和其他系统资源的调用等。</p><ol start="2"><li>检查第二步：通过instrument工具的 <code>energy log</code> 来检测具体的耗电模块。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303231853126.png"                                     ></p><h1 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h1><ol><li>cpu层面的优化</li></ol><ul><li>尽量降低CPU</li><li>少使用定时器</li><li>优化I&#x2F;O操作<ul><li>写入数据最好一次性写入</li><li>读取数据最好使用GCD异步操作</li><li>数据流比较大，建议使用数据库</li></ul></li><li>适当使用多线程，不宜过多，不要阻塞主线程</li><li>优化算法，减少循环次数</li><li>避免庞大的 <code>xib、storyBoard</code>， 尽量使用纯代码开发</li></ul><ol start="2"><li>GPU 层面的优化</li></ol><ul><li>减少视图刷新，按需刷新；</li><li>尽量少使用圆角和透明度；</li></ul><ol start="3"><li>Network 网络请求层面的优化</li></ol><ul><li>减少、压缩网络数据</li><li>如果多次请求的结果是相同的，尽量使用缓存</li><li>使用断点续传，否则网络不稳定时可能多次传输相同的内容</li><li>网络不可用时，不要尝试执行网络请求</li><li>让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间</li><li>批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载</li></ul><ol start="4"><li>Location 定位层面优化</li></ol><ul><li>如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电</li><li>如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务</li><li>尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest</li><li>需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新</li><li>尽量不要使用startMonitoringSignificantLocationChanges，优先考虑startMonitoringForRegion</li></ul><ol start="5"><li>Bluetooth, Background</li></ol><ul><li>蓝牙按需取用，定位之后要关闭或降低定位频率，进入后台关闭定位，停止定时器运行等</li></ul><ol start="4"><li>硬件检测优化(不常用)</li></ol><ul><li>用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;所有应用程序在执行网络操作、更新用户界面或在CPU上运行代码时都会消耗能量。随着用户越来越多地依赖电池电量，以及应用程序的激增，能效已成为用</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>性能优化06：启动优化</title>
    <link href="https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</id>
    <published>2023-09-10T04:13:29.000Z</published>
    <updated>2023-03-30T06:10:57.318Z</updated>
    
    <content type="html"><![CDATA[<p>启动优化查看以下三篇文章：</p><p><a href="https://www.bboyzj.cn/2021/05/04/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8632%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">OC底层原理32：启动优化（一）基本概念</a></p><p><a href="https://www.bboyzj.cn/2021/05/11/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8633%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/">OC底层原理33：启动优化（二）优化建议</a></p><p><a href="https://www.bboyzj.cn/2021/05/17/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8634%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%87%8D%E6%8E%92/">OC底层原理34：启动优化（三）二进制重排</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;启动优化查看以下三篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bboyzj.cn/2021/05/04/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8632%EF%BC%9A%E5%</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>OC学习40：sizeToFit和sizeThatFit</title>
    <link href="https://www.bboyzj.cn/2023/04/23/OC/OC%E5%AD%A6%E4%B9%A040%EF%BC%9AsizeToFit%E5%92%8CsizeThatFit/"/>
    <id>https://www.bboyzj.cn/2023/04/23/OC/OC%E5%AD%A6%E4%B9%A040%EF%BC%9AsizeToFit%E5%92%8CsizeThatFit/</id>
    <published>2023-04-23T06:29:21.000Z</published>
    <updated>2023-04-23T06:30:45.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过官方文档查看两个方法的区别：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (CGSize)sizeThatFits:(CGSize)size;   </span><br><span class="line"></span><br><span class="line">return &#x27;best&#x27; size to fit given size. does not actually resize view. Default is return existing view size</span><br><span class="line"></span><br><span class="line">- (void)sizeToFit;     </span><br><span class="line"></span><br><span class="line">calls sizeThatFits: with current view bounds and changes bounds size.</span><br></pre></td></tr></table></figure></div><ul><li><p>sizeThatFits: 会计算出最优的 <code>size</code> 但是 <code>不会改变原来的size</code></p></li><li><p>sizeToFit: 会计算出最优的 <code>size</code> 而且会 <code>改变原来的size</code></p></li></ul><h1 id="不换行情况下"><a href="#不换行情况下" class="headerlink" title="不换行情况下"></a>不换行情况下</h1><p>下面通过代码来验证一下，不换行情况下的区别：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -不换行</span><br><span class="line">- (void)NoWarp&#123;</span><br><span class="line">    UILabel * titleL = [[UILabel alloc] initWithFrame:CGRectMake(10, 100, 100, 18)];</span><br><span class="line">    titleL.text = @&quot;我是谁？我是张建，欢迎来到我的世界！&quot;;</span><br><span class="line">    titleL.textColor = [UIColor redColor];</span><br><span class="line">    titleL.backgroundColor = [UIColor yellowColor];</span><br><span class="line">    [self.view addSubview:titleL];</span><br><span class="line">    </span><br><span class="line">    // sizeThatFits: 会计算出最优的 size 但是不会改变 自己的 size</span><br><span class="line">    CGSize size = [titleL sizeThatFits:CGSizeMake(150, MAXFLOAT)];</span><br><span class="line">    NSLog(@&quot;w:%f h:%f&quot;,size.width,size.height);</span><br><span class="line">    </span><br><span class="line">    // sizeToFit: 会计算出最优的 size 而且会改变自己的 size</span><br><span class="line">    [titleL sizeToFit];</span><br><span class="line">    NSLog(@&quot;w:%f h:%f&quot;,titleL.frame.size.width,titleL.frame.size.height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>查看代码的结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-10-09 16:34:44.011176+0800 sizeToFit和sizeThatFit[506:157387] w:308.000000 h:20.500000</span><br><span class="line">2021-10-09 16:34:44.011280+0800 sizeToFit和sizeThatFit[506:157387] w:308.000000 h:20.500000</span><br></pre></td></tr></table></figure></div><p>显示的效果：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304231430886.png"                                     ></p><h1 id="换行的情况下"><a href="#换行的情况下" class="headerlink" title="换行的情况下"></a>换行的情况下</h1><p>下面用代码来验证一下，换行的情况下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -换行</span><br><span class="line">- (void)warp&#123;</span><br><span class="line">    UILabel * titleL = [[UILabel alloc] initWithFrame:CGRectMake(10, 200, 300, 18)];</span><br><span class="line">    titleL.text = @&quot;我是谁？我是张建，欢迎来到我的世界！,我是谁？我是张建，欢迎来到我的世界！,我是谁？我是张建，欢迎来到我的世界！,我是谁？我是张建，欢迎来到我的世界！,我是谁？我是张建，欢迎来到我的世界！&quot;;</span><br><span class="line">    titleL.textColor = [UIColor redColor];</span><br><span class="line">    titleL.backgroundColor = [UIColor yellowColor];</span><br><span class="line">    titleL.numberOfLines = 0;</span><br><span class="line">    [self.view addSubview:titleL];</span><br><span class="line">    </span><br><span class="line">    // sizeThatFits: 会计算出最优的 size 但是不会改变 自己的 size</span><br><span class="line">    CGSize size = [titleL sizeThatFits:CGSizeMake(300, MAXFLOAT)];</span><br><span class="line">    NSLog(@&quot;w:%f h:%f&quot;,size.width,size.height);</span><br><span class="line">    </span><br><span class="line">    // sizeToFit: 会计算出最优的 size 而且会改变自己的 size</span><br><span class="line">    [titleL sizeToFit];</span><br><span class="line">    NSLog(@&quot;w:%f h:%f&quot;,titleL.frame.size.width,titleL.frame.size.height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>查看代码运行结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-10-09 16:39:54.036423+0800 sizeToFit和sizeThatFit[7271:250369] w:299.333333 h:122.000000</span><br><span class="line">2021-10-09 16:39:54.036707+0800 sizeToFit和sizeThatFit[7271:250369] w:299.333333 h:122.000000</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通过官方文档查看两个方法的区别：&lt;/p&gt;
&lt;div class=&quot;highlight-container&quot; data-rel=&quot;Plaint</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习22.1：Socket实现</title>
    <link href="https://www.bboyzj.cn/2023/04/22/OC/OC%E5%AD%A6%E4%B9%A022-1%EF%BC%9ASocket%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.bboyzj.cn/2023/04/22/OC/OC%E5%AD%A6%E4%B9%A022-1%EF%BC%9ASocket%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-04-22T12:20:45.000Z</published>
    <updated>2023-04-22T14:07:43.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要介绍使用 <code>GCDAsyncSocket</code> 实现iOS端 <code>Socket</code></p><h1 id="什么是Socket？"><a href="#什么是Socket？" class="headerlink" title="什么是Socket？"></a>什么是Socket？</h1><p>Socket 俗称 <code>套接字</code>，是网络通信的基石。它可以通过 <code>IP地址、端口号、TCP/UDP协议</code> 实现客户端和服务端的双向通信。</p><h1 id="长链接-和-短链接"><a href="#长链接-和-短链接" class="headerlink" title="长链接 和 短链接"></a>长链接 和 短链接</h1><ul><li><p>长链接：连上就一直聊，通常用于 <code>及时通讯</code>，效率高。（一对一：）</p></li><li><p>短链接：通讯一次，马上断开，下次再建立连接，效率低。（一对多）</p></li></ul><p>及时通讯：客户端和服务端是 <code>短链接</code>，客户端与客户端是 <code>长链接</code></p><h1 id="Socket如何保持长链接"><a href="#Socket如何保持长链接" class="headerlink" title="Socket如何保持长链接"></a>Socket如何保持长链接</h1><p>一般的Socket正常收发完消息之后，就会断开连接（主动或被动），但是有些实时化场景要求高的地方，需要及时收发消息，比如 <code>直播间、股票期货行情模块</code> 等，要实时收发数据，这样的话就需要Socket保持连接一直在。</p><p>方法：发送 <code>心跳包</code> 来保活</p><ol><li>应用层自己实现 <code>心跳包</code></li></ol><ul><li><p>服务器在 <code>NSTimer</code> 中定时想客户端发送一个小数据包，如果客户端一定时间内没有回应，即认为客户端已掉线。</p></li><li><p>同理：客户端在 <code>NSTimer</code> 中定时向 <code>服务端</code> 发送一个小数据包，在一定时间内没有收到服务器的心跳包，则认为连接不可用。</p></li></ul><ol start="2"><li>TCP 的 KeepAlive 保活机制</li></ol><p>考虑到一个服务器通常会连接多个客户端，因此由用户在应用层自己实现心跳包，<code>代码较多且稍显复杂</code>，而利用 <code>TCP／IP协议层</code> 为内置的 <code>KeepAlive</code> 功能来实现心跳功能则简单得多。 不论是服务端还是客户端，一方开启 <code>KeepAlive</code> 功能后，就会自动在规定时间内向对方发送心跳包， 而另一方在收到心跳包后就会自动回复，以告诉对方我仍然在线。</p><h1 id="iOS端实现-Socket"><a href="#iOS端实现-Socket" class="headerlink" title="iOS端实现 Socket"></a>iOS端实现 Socket</h1><p>用 <code>GCDAsyncSocket</code> 框架</p><ol><li>创建GCDAsyncSocket对象，并且使之成为成员属性</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GCDAsyncSocket *_socket;</span><br></pre></td></tr></table></figure></div><ol start="2"><li>我们在这里传入一个全局队列，让它工作在子线程，防止网络不畅时阻塞主线程。</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_socket = [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)];</span><br></pre></td></tr></table></figure></div><ol start="3"><li>连接服务端</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// IP地址</span><br><span class="line">NSString *host = @&quot;127.0.0.1&quot;;</span><br><span class="line">// 端口号</span><br><span class="line">int port = 12345;</span><br><span class="line">NSError *error = nil;</span><br><span class="line">[_socket connectToHost:host onPort:port error:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="4"><li>实现代理方法来获取数据</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 连接成功的代理</span><br><span class="line">-(void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(uint16_t)port&#123;</span><br><span class="line">    NSLog(@&quot;成功连接到%@:%d&quot;,host,port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 连接结束的代理</span><br><span class="line">- (void)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(NSError *)err&#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>接收数据的代理</li></ul><p>这里的 <code>tag</code> 是用于 <code>区分不同的消息</code> 的，在写一条消息的时候需要指定tag，通过不同的tag判断服务器返回的消息的类型。这里有两类消息，分别是 <code>登录消息和聊天消息</code>，只有后者会被显示，<code>reloadDataWithText</code> 是用于 <code>tableView</code> 显示数据的方法。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 数据成功发送到服务器</span><br><span class="line">- (void)socket:(GCDAsyncSocket *)sock didWriteDataWithTag:(long)tag&#123;</span><br><span class="line">    // 需要自己调用读取方法，socket才会调用代理方法读取数据</span><br><span class="line">    [_socket readDataWithTimeout:-1 tag:tag];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag&#123;</span><br><span class="line"> </span><br><span class="line">    switch (tag) &#123;</span><br><span class="line">        case LoginTag:</span><br><span class="line">            break;</span><br><span class="line">        case MsgTag:&#123;</span><br><span class="line">            NSString *msg = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</span><br><span class="line">            [self reloadDataWithText:msg];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="5"><li>发送一条消息</li></ol><ul><li>使用socket的 <code>writeData</code> 方法，这里不需要指定消息的长度和缓冲区大小，十分方便，tag会被传入，在调用上面提到的代理方法 <code>(void)socket:(GCDAsyncSocket *)sock didWriteDataWithTag:(long)tag</code> 时会被传入，用于判断消息类型。</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 发送 iam:name 表示name登录</span><br><span class="line">NSString *loginStr = @&quot;iam:soulghost&quot;;</span><br><span class="line">// 把string转成NSData</span><br><span class="line">NSData *data = [loginStr dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">[_socket writeData:data withTimeout:-1 tag:LoginTag];</span><br></pre></td></tr></table></figure></div><ul><li>需要注意的是异步socket工作在子线程，如果要更新UI，必然会在socket的代理方法中调用更新UI的方法，这时更新UI的代码运行于子线程，不能立即刷新UI界面，因此应该把更新UI的函数放在主线程中执行：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    // 更新UI的代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文主要介绍使用 &lt;code&gt;GCDAsyncSocket&lt;/code&gt; 实现iOS端 &lt;code&gt;Socket&lt;/code&gt;&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习00：面向过程&amp;面向对象&amp;面向协议&amp;面向函数编程</title>
    <link href="https://www.bboyzj.cn/2023/04/21/Swift/Swift%E5%AD%A6%E4%B9%A000%EF%BC%9A%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE-%E9%9D%A2%E5%90%91%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.bboyzj.cn/2023/04/21/Swift/Swift%E5%AD%A6%E4%B9%A000%EF%BC%9A%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE-%E9%9D%A2%E5%90%91%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/</id>
    <published>2023-04-21T03:53:07.000Z</published>
    <updated>2023-04-21T03:54:15.597Z</updated>
    
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Swift31：AutoLayout</title>
    <link href="https://www.bboyzj.cn/2023/04/19/Swift/Swift%E5%AD%A6%E4%B9%A031%EF%BC%9AAutoLayout/"/>
    <id>https://www.bboyzj.cn/2023/04/19/Swift/Swift%E5%AD%A6%E4%B9%A031%EF%BC%9AAutoLayout/</id>
    <published>2023-04-19T08:12:59.000Z</published>
    <updated>2023-04-19T08:35:02.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Apple提供的API有两套：</p><ul><li><p>一套是iOS9之前用的使用 <code>NSLayoutConstraint</code>，Apple可能是因为发现了使用NSLayoutConstraint代码过长的问题</p></li><li><p>在iOS9推出了 <code>NSLayoutAnchor</code>，不仅让约束声明更加清晰明了，而且还通过静态类型检查以确保约束能够正常工作。</p></li></ul><h1 id="关闭autoresizing布局方式"><a href="#关闭autoresizing布局方式" class="headerlink" title="关闭autoresizing布局方式"></a>关闭autoresizing布局方式</h1><ul><li><p><code>AutoLayout</code> 又名 <code>自动布局</code>。使用 <code>AutoLayout</code> 可以轻易写出目前主流的所有页面布局.</p></li><li><p>在 <code>iOS</code> 中默认使用 <code>autoresizing</code> 布局方式，做了相对父控件大小的伸缩，使用不方便。</p></li><li><p>关闭 <code>aotoresizing</code> 布局，translatesAutoresizingMaskIntoConstraints &#x3D; false，可以开启 <code>自动布局</code></p></li></ul><h1 id="NSLayoutConstraint"><a href="#NSLayoutConstraint" class="headerlink" title="NSLayoutConstraint"></a>NSLayoutConstraint</h1><p>只需要创建一个NSLayoutConstraint，然后激活，添加到对应的view即可。不过，是每一个约束都要创建，所以代码较长。创建一个NSLayoutConstraint只需要一个方法，为了方便，我们对每一个参数进行注释：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSLayoutConstraint.init(item: Any, //要约束的目标(比如 redView)</span><br><span class="line"></span><br><span class="line">attribute: NSLayoutAttribute, //要约束的属性（比如top）</span><br><span class="line"></span><br><span class="line">relatedBy: NSLayoutRelation, //约束类型（比如equal）</span><br><span class="line"></span><br><span class="line">toItem: Any?,//相对于哪个目标（比如superView）</span><br><span class="line"></span><br><span class="line">attribute: NSLayoutAttribute, //相对于这个目标的属性（比如bottom）</span><br><span class="line"></span><br><span class="line">multiplier: CGFloat, //倍数（比如一半为0.5）</span><br><span class="line"></span><br><span class="line">constant: CGFloat)//常数（差值，比如-10）</span><br></pre></td></tr></table></figure></div><p>举例添加一个view到界面上，距上距左各20，宽200，高100.</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个红色的view添加到界面上</span><br><span class="line">let redView = UIView()</span><br><span class="line">redView.backgroundColor = .red</span><br><span class="line">redView.translatesAutoresizingMaskIntoConstraints = false</span><br><span class="line">view.addSubview(redView)</span><br><span class="line">        </span><br><span class="line">// 添加距离顶部20</span><br><span class="line">let topConstraint = NSLayoutConstraint.init(item: redView, attribute: .top, relatedBy: .equal, toItem: view, attribute: .top, multiplier: 1.0, constant: 20)</span><br><span class="line">topConstraint.isActive = true</span><br><span class="line">        </span><br><span class="line">// 添加距离左边20</span><br><span class="line">let leftConstraint = NSLayoutConstraint.init(item: redView, attribute: .left, relatedBy: .equal, toItem: view, attribute: .left, multiplier: 1.0, constant: 20)</span><br><span class="line">leftConstraint.isActive = true</span><br><span class="line">        </span><br><span class="line">// 添加宽为200</span><br><span class="line">let widthConstraint = NSLayoutConstraint.init(item: redView, attribute: .width, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, multiplier: 1.0, constant: 200)</span><br><span class="line">widthConstraint.isActive = true</span><br><span class="line">        </span><br><span class="line">// 添加高为100</span><br><span class="line">let heightConstraint = NSLayoutConstraint.init(item: redView, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, multiplier: 1.0, constant: 100)</span><br><span class="line">heightConstraint.isActive = true</span><br></pre></td></tr></table></figure></div><h1 id="NSLayoutAnchor"><a href="#NSLayoutAnchor" class="headerlink" title="NSLayoutAnchor"></a>NSLayoutAnchor</h1><p>iOS9.0之后，Apple推出了 <code>NSLayoutAnchor</code>。</p><p>使用方式有两种：</p><ol><li>第一种方式</li></ol><ul><li>创建 <code>UIImageView</code> 视图，闭包初始化</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let imgV: UIImageView = &#123;</span><br><span class="line">    let imgV = UIImageView(image: UIImage(named: &quot;logo_icon&quot;))</span><br><span class="line">    imgV.backgroundColor = .blue</span><br><span class="line">    imgV.translatesAutoresizingMaskIntoConstraints = false</span><br><span class="line">    imgV.contentMode = .scaleAspectFill</span><br><span class="line">    return imgV</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></div><ul><li>添加到 ViewController 中</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.addSubview(imgV)</span><br></pre></td></tr></table></figure></div><ul><li>添加一个约束</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 第一种写法：激活，数组</span><br><span class="line">NSLayoutConstraint.activate([</span><br><span class="line">    imgV.topAnchor.constraint(equalTo: view.topAnchor, constant: 200),</span><br><span class="line">    imgV.centerXAnchor.constraint(equalTo: view.centerXAnchor),</span><br><span class="line">    imgV.widthAnchor.constraint(equalToConstant: 100),</span><br><span class="line">    imgV.heightAnchor.constraint(equalToConstant: 100),</span><br><span class="line">])</span><br></pre></td></tr></table></figure></div><ol start="2"><li>第二种方式</li></ol><ul><li>在 <code>imgV</code> 下方创建一个 <code>文本</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let lab: UILabel = &#123;</span><br><span class="line">    let lab = UILabel()</span><br><span class="line">    lab.translatesAutoresizingMaskIntoConstraints = false</span><br><span class="line">    lab.backgroundColor = .red</span><br><span class="line">    lab.text = &quot;加入我们，游戏和乐趣&quot;</span><br><span class="line">    lab.textColor = .green</span><br><span class="line">    lab.font = .systemFont(ofSize: 20, weight: .bold)</span><br><span class="line">    lab.textAlignment = .center</span><br><span class="line">    return lab</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></div><ul><li>添加 lab 到 ViewController 上</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.addSubview(lab)</span><br></pre></td></tr></table></figure></div><ul><li>添加约束</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 另一种写法：需要激活</span><br><span class="line">lab.topAnchor.constraint(equalTo: imgV.bottomAnchor, constant: 50).isActive = true</span><br><span class="line">lab.leftAnchor.constraint(equalTo: view.leftAnchor).isActive = true</span><br><span class="line">lab.rightAnchor.constraint(equalTo: view.rightAnchor).isActive = true</span><br><span class="line">lab.heightAnchor.constraint(equalToConstant: 50).isActive = true</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Apple提供的API有两套：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一套是iOS9之前用的使用 &lt;code&gt;NSLayoutConstraint</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发工作梳理</title>
    <link href="https://www.bboyzj.cn/2023/04/16/iOS%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%A2%B3%E7%90%86/"/>
    <id>https://www.bboyzj.cn/2023/04/16/iOS%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%A2%B3%E7%90%86/</id>
    <published>2023-04-16T03:01:54.000Z</published>
    <updated>2023-04-17T05:57:38.204Z</updated>
    
    <content type="html"><![CDATA[<p>2013年毕业，在葫芦岛市绥四建工下其中一个项目部，从事了2年的工程，前一年跟着师傅学习，后一年自己独立负责项目技术施工；每天6点起床，每天要起早，中午休息一个小时，晚上不一定几点下班，真的是起早贪黑的工作，最关键的是不挣钱；从中学习了很多工程施工方面的经验，也考了二级建造师。最遗憾的是二级建造师的证书没去取。最后由于感情方面的事情，毅然决然的离开了葫芦岛。</p><p>自从2015年中旬来到北京，主要是通过朋友了解了iOS开发这行目前特别火，还挣钱；然后我也去千峰培训了6个月，这6个月是我最难熬的6个月，像是回到了上学期间，每天起早贪黑的学习技术；毕业后的第一份工作是凭借着忽悠进去的，工资翻了好几倍。回头想想值了。</p><p>2016年进入第一家公司，老板姓王，我记忆尤新，是个北大的毕业生创业的公司。然后一直就从事iOS开发到现在。干了7年多了。总结一下自己的工作，从入行到现在，我进步的点是从迷迷糊糊的跨行到能独立搭建框架和开发，是我多年积累的经验。不足是从入行到现在没有明确的目标，没有规划自己的未来房展方向。导致我错过了很多机会。也没有把自己的能力提升上去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2013年毕业，在葫芦岛市绥四建工下其中一个项目部，从事了2年的工程，前一年跟着师傅学习，后一年自己独立负责项目技术施工；每天6点起床，每天要起早，中午休息一个小时，晚上不一定几点下班，真的是起早贪黑的工作，最关键的是不挣钱；从中学习了很多工程施工方面的经验，也考了二级建造</summary>
      
    
    
    
    <category term="工作梳理" scheme="https://www.bboyzj.cn/categories/%E5%B7%A5%E4%BD%9C%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="工作-总结" scheme="https://www.bboyzj.cn/tags/%E5%B7%A5%E4%BD%9C-%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>OC学习36.2：CoreData</title>
    <link href="https://www.bboyzj.cn/2023/04/16/OC/OC%E5%AD%A6%E4%B9%A036.3%EF%BC%9ACoreData/"/>
    <id>https://www.bboyzj.cn/2023/04/16/OC/OC%E5%AD%A6%E4%B9%A036.3%EF%BC%9ACoreData/</id>
    <published>2023-04-15T16:52:43.000Z</published>
    <updated>2023-04-15T16:56:14.887Z</updated>
    
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习36.2：FMDB</title>
    <link href="https://www.bboyzj.cn/2023/04/16/OC/OC%E5%AD%A6%E4%B9%A036.2%EF%BC%9AFMDB/"/>
    <id>https://www.bboyzj.cn/2023/04/16/OC/OC%E5%AD%A6%E4%B9%A036.2%EF%BC%9AFMDB/</id>
    <published>2023-04-15T16:51:39.000Z</published>
    <updated>2023-04-15T16:56:12.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>FMDB</code> 封装了 <code>SQLite</code> 的C语言API，更加面向对象。</p><h1 id="FMDB"><a href="#FMDB" class="headerlink" title="FMDB"></a>FMDB</h1><p>首先需要明确的是FMDB中的三个类：</p><ul><li>FMDatabase：可以理解成一个数据库。</li><li>FMResultSet：查询的结果集合。</li><li>FMDatabaseQueue：运用多线程，可执行多个查询、更新。线程安全。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;FMDB&lt;/code&gt; 封装了 &lt;code&gt;SQLite&lt;/code&gt; 的C语言API，更加面向对象。&lt;/p&gt;
&lt;h1 id=&quot;</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习36.1：SQLite3</title>
    <link href="https://www.bboyzj.cn/2023/04/16/OC/OC%E5%AD%A6%E4%B9%A036.1%EF%BC%9ASQLite3/"/>
    <id>https://www.bboyzj.cn/2023/04/16/OC/OC%E5%AD%A6%E4%B9%A036.1%EF%BC%9ASQLite3/</id>
    <published>2023-04-15T16:51:23.000Z</published>
    <updated>2023-04-15T17:00:06.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQList使用流程："><a href="#SQList使用流程：" class="headerlink" title="SQList使用流程："></a>SQList使用流程：</h1><ol><li>首先需要添加库文件 <code>libsqlite3.0.tbd</code></li><li>导入头文件 <code>#import &lt;sqlite3.h&gt;</code></li><li>打开数据库</li><li>创建表</li><li>对数据表进行增删改查操作</li><li>关闭数据库</li></ol><blockquote><p>注：<br>SQLite 不区分大小写，但也有需要注意的地方，例如GLOB和glob具有不同作用<br>SQLite3 有5种基本数据类型 <code>text、integer、float、boolean、blob</code><br>SQLite3 是无类型的，在创建的时候你可以不声明字段的类型，不过还是建议加上数据类型</p></blockquote><p>例如：</p><blockquote><p>create table t_student(name, age);<br>create table t_student(name text, age integer);</p></blockquote><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><h1 id="SQLite-基本语句"><a href="#SQLite-基本语句" class="headerlink" title="SQLite 基本语句"></a>SQLite 基本语句</h1><ul><li>创建表</li></ul><p>create table if not exists 表名 (字段名1, 字段名2…);</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table if not exists t_student (id integer primary key autoincrement, name text not null, age integer)</span><br></pre></td></tr></table></figure></div><ul><li>增加数据</li></ul><p>insert into 表名 (字段名1, 字段名2, …) values(字段1的值, 字段2的值, …);</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t_student (name,age) values (@&quot;Jack&quot;,@17);</span><br></pre></td></tr></table></figure></div><ul><li>根据条件删除数据</li></ul><p>delete from 表名 where 条件;</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from t_student where name = @&quot;Jack&quot;;</span><br></pre></td></tr></table></figure></div><ul><li>删除表中所有的数据：</li></ul><p>delete from 表名</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from t_student</span><br></pre></td></tr></table></figure></div><ul><li>根据条件更改某个数据</li></ul><p>update 表名 set 字段1 &#x3D; ‘值1’, 字段2 &#x3D; ‘值2’ where 字段1 &#x3D; ‘字段1的当前值’</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update t_student set name = &#x27;lily&#x27;, age = &#x27;16&#x27; where name = &#x27;Jack&#x27;</span><br></pre></td></tr></table></figure></div><ul><li>根据条件查找</li></ul><p>select * from 表名 where 字段1 &#x3D; ‘字段1的值’</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_student where age = &#x27;16&#x27;</span><br></pre></td></tr></table></figure></div><ul><li>查找所有数据</li></ul><p>select * from 表名</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_student</span><br></pre></td></tr></table></figure></div><ul><li>删除表：</li></ul><p>drop table 表名</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table t_student</span><br></pre></td></tr></table></figure></div><ul><li>排序查找：</li></ul><p>select * from 表名 order by 字段</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from t_student order by age asc （升序，默认）</span><br><span class="line">select * from t_student order by age desc （降序）</span><br></pre></td></tr></table></figure></div><ul><li>限制:</li></ul><p>select * from 表名 limit 值1, 值2</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_student limit 5, 10 （跳过5个，一共取10个数据）</span><br></pre></td></tr></table></figure></div><blockquote><p>SQLite3还有事务方面的使用，这里就不做说明了，下面的FMDB中会有事务的使用。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQList使用流程：&quot;&gt;&lt;a href=&quot;#SQList使用流程：&quot; class=&quot;headerlink&quot; title=&quot;SQList使用流程：&quot;&gt;&lt;/a&gt;SQList使用流程：&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;首先需要添加库文件 &lt;code&gt;libsqlite3.0</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习36：常用的数据存储方式</title>
    <link href="https://www.bboyzj.cn/2023/04/15/OC/OC%E5%AD%A6%E4%B9%A036%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/"/>
    <id>https://www.bboyzj.cn/2023/04/15/OC/OC%E5%AD%A6%E4%B9%A036%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2023-04-15T11:15:41.000Z</published>
    <updated>2023-04-17T12:39:55.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <code>iOS</code> 开发过程中，经常需要 <code>保存一些信息到本地</code> ，那么就需要数据存储。</p><h1 id="沙盒（sandbox）"><a href="#沙盒（sandbox）" class="headerlink" title="沙盒（sandbox）"></a>沙盒（sandbox）</h1><p>每个应用程序都有自己的沙盒，且只能访问自己的沙盒</p><ol><li>如何访问沙盒文件呢？</li></ol><p>通过Xcode查看</p><ul><li><p>Window -&gt; Devices And Simulators (快捷键 command + shift + 2)</p></li><li><p>选中自己的设备，也就是iPhone手机，然后 <code>Installed Apps</code> 中选中需要查看的应用</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304160056372.png"                                     ></p><ul><li>滑动鼠标到 <code>Installed Apps</code> 的底部，左键点击设置按钮，选择 <code>Download Container</code>，然后就可以将 <code>沙盒文件</code> 下载到本机上，查看所下载文件的内容即可</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304160057426.png"                                     ></p><blockquote><p>由上图可知 <code>沙盒文件</code> 下结构为：<br>应用程序包<br>1、Documents   持久化的数据<br>2、tmp         临时目录<br>3、Library<br>  3.1、cache 缓存<br>  3.2、Preference 偏好设置</p></blockquote><ol start="2"><li>沙盒文件下每个文件的具体作用？</li></ol><ul><li><p>Documents（保存程序生成的数据）</p><ul><li>保存由应用程序生成的文件或数据。</li><li>iTunes备份和恢复的时候会包括此目录。</li><li>如果保存的网络下载的文件，上架审核的时候，会被拒</li></ul></li><li><p>tmp（暂放数据，随时收回）</p><ul><li><code>保存临时文件，系统会自动回收</code>，如：磁盘空间紧张或重启手机</li><li>iTunes不会备份和恢复此目录，此目录下文件可能会在 <code>应用退出后删除</code></li><li>程序员不需要管tmp文件下的释放</li></ul></li><li><p>Library&#x2F;Caches (保存网络下载的数据)</p><ul><li>缓存，保存从网络下载的文件，后续仍然需要继续使用，如：网络下载的离线数据，图片，视频等</li><li>缓存目录中的文件不会自动删除，可以做离线访问</li><li>程序必须提供一个完善的清除缓存目录的 <code>解决方案</code></li><li>iTunes不会备份此目录，此目录下文件在 <code>应用退出不会删除</code></li></ul></li><li><p>Library&#x2F;Preferences（偏好设置）</p><ul><li>系统偏好，用户偏好</li><li>操作是通过 <code>NSUserDefaults</code> 实现的</li></ul></li></ul><h1 id="沙盒路径的获取方法"><a href="#沙盒路径的获取方法" class="headerlink" title="沙盒路径的获取方法"></a>沙盒路径的获取方法</h1><ol><li>沙盒的路径</li></ol><p>用 <code>NSHomeDirectory()</code> 获取</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取沙盒下的根目录</span><br><span class="line">NSString * sandboxPath = NSHomeDirectory();</span><br><span class="line">NSLog(@&quot;%@&quot;,sandboxPath);</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">/var/mobile/Containers/Data/Application/F8CF4000-F78B-4511-996D-819B96F64389</span><br></pre></td></tr></table></figure></div><ol start="2"><li>Documents 路径</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 获取 Documents 路径</span><br><span class="line">/*</span><br><span class="line"> NSSearchPathForDirectoriesInDomains 返回绝对路径</span><br><span class="line"> NSDocumentDirectory 表示获取沙盒的Documents目录</span><br><span class="line"> NSUserDomainMask 表示是用户主目录</span><br><span class="line"> YES/NO 表示是否获取全路径</span><br><span class="line"> */</span><br><span class="line">NSArray * paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString * documentsPath = [paths lastObject];</span><br><span class="line">NSLog(@&quot;%@&quot;,documentsPath);</span><br><span class="line">    </span><br><span class="line">=======</span><br><span class="line">/var/mobile/Containers/Data/Application/52A513F9-96E3-4DB0-9A40-BE3403E0BD34/Documents</span><br></pre></td></tr></table></figure></div><ol start="3"><li>Caches 路径</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 获取Caches路径</span><br><span class="line">NSArray * paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString * cachesPath = [paths lastObject];</span><br><span class="line">NSLog(@&quot;%@&quot;,cachesPath);</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">/var/mobile/Containers/Data/Application/A0FF5812-EC9C-404F-BF63-4F60FFB1DE01/Library/Caches</span><br></pre></td></tr></table></figure></div><ol start="4"><li>tmp 路径</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取tmp路径</span><br><span class="line">NSString * tmpDir = NSTemporaryDirectory();</span><br><span class="line">NSLog(@&quot;%@&quot;,tmpDir);</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">/private/var/mobile/Containers/Data/Application/206388C3-5180-4631-8120-3CB10EBDA0D8/tmp/</span><br></pre></td></tr></table></figure></div><h1 id="常用的存储方式"><a href="#常用的存储方式" class="headerlink" title="常用的存储方式"></a>常用的存储方式</h1><ul><li>NSUserDefaults </li><li>Plist</li><li>手动存放沙盒</li><li>NSKeyedArchiver归档 &#x2F; NSKeyedUnarchiver解档</li><li>SQLite3</li><li>FMDB</li><li>CoreData</li></ul><h1 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a>NSUserDefaults</h1><p><code>NSUserDefaults</code> 可以存储 <code>OC基本类型（如：字符串、数组、字典等）</code>。但 <code>不能存储自定义对象</code>，如果是 <code>自定义对象，需要进行归档操作</code>。缓存数据到沙盒下 <code>Library-&gt;Preference</code>。<code>iTunes</code> 同步设备时会 <code>备份</code> </p><ul><li>存入数据</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[NSUserDefaults standardUserDefaults] setObject:value forKey:key];</span><br><span class="line">[[NSUserDefaults standardUserDefaults] synchronize];</span><br></pre></td></tr></table></figure></div><ul><li>取出数据</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSUserDefaults standardUserDefaults] objectForKey:key];</span><br></pre></td></tr></table></figure></div><ul><li>移除数据</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[NSUserDefaults standardUserDefaults] removeObjectForKey:key];</span><br><span class="line">[[NSUserDefaults standardUserDefaults] synchronize];</span><br></pre></td></tr></table></figure></div><h1 id="Plist"><a href="#Plist" class="headerlink" title="Plist"></a>Plist</h1><ul><li><p><code>Plist</code> 即 <code>XML属性列表</code> ，是将某些特定的类，通过XML文件的方式保存在 <code>Documents</code> 目录中</p></li><li><p>优点：这种方式 好处是 <code>可视化</code>，可以 <code>很直观</code> 的看到文件的内容，同时 <code>Xcode</code> 提供了直接操作文件的功能。便于我们 <code>增删改查</code>。</p></li><li><p>缺点：<code>plist</code> 文件一般作为固态的数据形式保存，<code>对于经常改动的数据不好操作</code></p></li></ul><ol><li>在项目中直接创建 <code>Plist</code> 文件。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304160057838.png"                                     ></p><blockquote><p>注意：<br>命名的时候不能用Info.plist、INfo.plist、xxxInfo.plist等形式，否则会与系统中存在的Info.plist文件发生冲突。</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304160057390.png"                                     ></p><blockquote><p>点击Root这一行，然后通过点击右键-&gt;Add Row或者点击Root后面的加号来增加一行。<br>这一行中包含三个属性，key、type、value。其中key是字段属性，type是字段类型，value是字段对应的值。<br>Type包含7中类型，对写入的数据结构应属于7仲：<br>(NSString，NSData，NSDate，NSNumber，NSArray，NSDictionary)</p></blockquote><ul><li>获取文件中的数据</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 从plist中直接读取代码</span><br><span class="line">NSString * filePath = [[NSBundle mainBundle] pathForResource:@&quot;InfoPlist&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">NSDictionary * dic = [NSDictionary dictionaryWithContentsOfFile:filePath];</span><br><span class="line">NSLog(@&quot;%@&quot;,dic);</span><br><span class="line">    </span><br><span class="line">=====</span><br><span class="line">2023-04-15 21:31:14.103498+0800 数据存储-plist[48688:9718159] &#123;</span><br><span class="line">    Name = &quot;\U5f20\U5efa&quot;;</span><br><span class="line">    Other =     (</span><br><span class="line">        0,</span><br><span class="line">        1</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="2"><li>代码创建 <code>plist</code> 文件，并 <code>读写</code> 数据，避免了在项目中创建 <code>plist</code> 文件导致不便更改的问题</li></ol><ul><li>ZJDataHelper.h</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJDataHelper : NSObject</span><br><span class="line">// 保存用户信息</span><br><span class="line">+ (BOOL)saveUserInfoInDocument:(NSDictionary *)dic;</span><br><span class="line">// 读取用户信息</span><br><span class="line">+ (NSMutableDictionary *)getUserInfoInDocument;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>ZJDataHelper.m 文件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJDataHelper.h&quot;</span><br><span class="line"></span><br><span class="line">#define DOCMENT_USER_PATH [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES) firstObject] stringByAppendingPathComponent:@&quot;UserData.plist&quot;]</span><br><span class="line"></span><br><span class="line">@implementation ZJDataHelper</span><br><span class="line">// 保存用户信息</span><br><span class="line">+ (BOOL)saveUserInfoInDocument:(NSDictionary *)dic&#123;</span><br><span class="line">    BOOL isSuccess;</span><br><span class="line">    NSString *document_path= DOCMENT_USER_PATH ;</span><br><span class="line">    NSURL *fileUrl = [NSURL fileURLWithPath:document_path];</span><br><span class="line">    isSuccess = [dic writeToURL:fileUrl atomically:YES];</span><br><span class="line">    return isSuccess;</span><br><span class="line">&#125;</span><br><span class="line">// 读取用户信息</span><br><span class="line">+ (NSMutableDictionary *)getUserInfoInDocument&#123;</span><br><span class="line">    NSString *path= DOCMENT_USER_PATH;</span><br><span class="line">    NSMutableDictionary *dic = [[NSMutableDictionary alloc] initWithContentsOfFile:path];</span><br><span class="line">    return dic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><blockquote><p>-(BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomically;<br>writeToURL 的好处是，既可以写入本地url也可以写入远程url，苹果推荐使用此方法写入plist文件</p></blockquote><h1 id="手动存放沙盒"><a href="#手动存放沙盒" class="headerlink" title="手动存放沙盒"></a>手动存放沙盒</h1><p>沙盒和上面两种类似，只能存放 OC 基本数据，自定义对象不能直接存入。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 假设我们需往cache 存入数据，并命名为test的txt格式文件中</span><br><span class="line">NSString *filePath = [cachesPath stringByAppendingPathComponent:@&quot;test.txt&quot;];</span><br><span class="line">NSArray *dic = [[NSArray alloc] initWithObjects:@&quot;name&quot;,@&quot;zj&quot; ,nil];</span><br><span class="line">if([dic writeToFile:filePath atomically:YES])&#123;</span><br><span class="line">    NSLog(@&quot;存入成功&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 取出数据 打印</span><br><span class="line">NSLog(@&quot;%@&quot;,[NSArray arrayWithContentsOfFile:filePath]);</span><br></pre></td></tr></table></figure></div><h1 id="NSKeyedArchiver归档-x2F-NSKeyedUnarchiver解档"><a href="#NSKeyedArchiver归档-x2F-NSKeyedUnarchiver解档" class="headerlink" title="NSKeyedArchiver归档 &#x2F; NSKeyedUnarchiver解档"></a>NSKeyedArchiver归档 &#x2F; NSKeyedUnarchiver解档</h1><p>之前说，不管是 <code>NSUserDefaults</code> 或者是 <code>plist</code> 都不能对 <code>自定义的对象</code> 进行存储， OC提供了 <code>解归档</code> 恰好解决这个问题。 解归档针对的是一个对象，假设我们现在有一个 <code>Person 和 Student</code> 的类，需要进行归档和解档。</p><ul><li>对象的 <code>Person.h</code> 文件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;Student.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject&lt;NSCoding&gt;</span><br><span class="line"></span><br><span class="line">//设置属性</span><br><span class="line">@property (nonatomic,strong)UIImage * avatar;</span><br><span class="line">@property (nonatomic,copy)NSString * name;</span><br><span class="line">@property (nonatomic,assign)NSInteger age;</span><br><span class="line">// 嵌套模型</span><br><span class="line">@property (nonatomic,strong)Student * student;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>对象的 <code>Person.m</code> 文件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">//实现NSCoding协议方法</span><br><span class="line">//解档</span><br><span class="line">- (id)initWithCoder:(NSCoder *)aDecoder&#123;</span><br><span class="line">    </span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        </span><br><span class="line">        self.avatar = [aDecoder decodeObjectForKey:@&quot;avatar&quot;];</span><br><span class="line">        self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];</span><br><span class="line">        self.age = [aDecoder decodeIntegerForKey:@&quot;age&quot;];</span><br><span class="line">        // 嵌套模型</span><br><span class="line">        self.student = [aDecoder decodeObjectForKey:@&quot;student&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">//归档</span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder&#123;</span><br><span class="line">    </span><br><span class="line">    [aCoder encodeObject:self.avatar forKey:@&quot;avatar&quot;];</span><br><span class="line">    [aCoder encodeObject:self.name forKey:@&quot;name&quot;];</span><br><span class="line">    [aCoder encodeInteger:self.age forKey:@&quot;age&quot;];</span><br><span class="line">    // 嵌套模型</span><br><span class="line">    [aCoder encodeObject:self.student forKey:@&quot;student&quot;];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>对象的 <code>Student.h</code> 文件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface Student : NSObject&lt;NSCopying&gt;</span><br><span class="line">@property (nonatomic,copy)NSString * name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>对象的 <code>Student.m</code> 文件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@implementation Student</span><br><span class="line"></span><br><span class="line">//实现NSCoding协议方法</span><br><span class="line">//解档</span><br><span class="line">- (id)initWithCoder:(NSCoder *)aDecoder&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">//归档</span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder&#123;</span><br><span class="line">    [aCoder encodeObject:self.name forKey:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>接下来只要使用 <code>解／归</code> 档辅助类就可以TestModel类进行解归档</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 把对象归档是调用NSKeyedArchiver的工厂方法archiverRootObject:toFile方法</span><br><span class="line">NSString * file  = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;</span><br><span class="line">NSString * path = [file stringByAppendingPathComponent:@&quot;person.data&quot;];</span><br><span class="line">    </span><br><span class="line">Person * person = [[Person alloc] init];</span><br><span class="line">person.avatar = [UIImage imageNamed:@&quot;123&quot;];</span><br><span class="line">person.name = @&quot;张建&quot;;</span><br><span class="line">person.age = 26;</span><br><span class="line">    </span><br><span class="line">// 嵌套模型</span><br><span class="line">Student * student = [[Student alloc] init];</span><br><span class="line">student.name = @&quot;小J&quot;;</span><br><span class="line">person.student = student;</span><br><span class="line">    </span><br><span class="line">[NSKeyedArchiver archiveRootObject:person toFile:path];</span><br><span class="line">    </span><br><span class="line">// 从文件中解档对象就是调用NSKeyedUnarchiver的一个工厂方法unarchiverObjectWithFile：即可</span><br><span class="line">Person * person2 = [NSKeyedUnarchiver unarchiveObjectWithFile:path];</span><br><span class="line">if (person2) &#123;</span><br><span class="line">    UIImage * avatarImg = person2.avatar;</span><br><span class="line">    NSString * name = person2.name;</span><br><span class="line">    NSInteger age = person2.age;</span><br><span class="line">    Student * student2 = person2.student;</span><br><span class="line">    NSString * s_name = student2.name;</span><br><span class="line">    NSLog(@&quot;avatar:%@ name:%@ age:%ld s_name:%@&quot;,avatarImg,name,age,s_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 &lt;code&gt;iOS&lt;/code&gt; 开发过程中，经常需要 &lt;code&gt;保存一些信息到本地&lt;/code&gt; ，那么就需要数据存储。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习35：Runtime在OC中的应用场景</title>
    <link href="https://www.bboyzj.cn/2023/04/11/OC/OC%E5%AD%A6%E4%B9%A035%EF%BC%9ARuntime%E5%9C%A8OC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://www.bboyzj.cn/2023/04/11/OC/OC%E5%AD%A6%E4%B9%A035%EF%BC%9ARuntime%E5%9C%A8OC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2023-04-11T14:45:39.000Z</published>
    <updated>2023-04-11T14:45:39.548Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>销售02：集成电路、IC芯片、电子元器件</title>
    <link href="https://www.bboyzj.cn/2023/04/09/%E9%94%80%E5%94%AE/%E9%94%80%E5%94%AE02%EF%BC%9A%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E3%80%81IC%E8%8A%AF%E7%89%87%E3%80%81%E7%94%B5%E5%AD%90%E5%85%83%E5%99%A8%E4%BB%B6/"/>
    <id>https://www.bboyzj.cn/2023/04/09/%E9%94%80%E5%94%AE/%E9%94%80%E5%94%AE02%EF%BC%9A%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E3%80%81IC%E8%8A%AF%E7%89%87%E3%80%81%E7%94%B5%E5%AD%90%E5%85%83%E5%99%A8%E4%BB%B6/</id>
    <published>2023-04-09T02:59:44.000Z</published>
    <updated>2023-04-09T04:11:34.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导体"><a href="#导体" class="headerlink" title="导体"></a>导体</h1><p>如 <code>金、银、铜、铁等金属</code>，它们导电性能好，叫做 <code>导体</code></p><h1 id="绝缘体"><a href="#绝缘体" class="headerlink" title="绝缘体"></a>绝缘体</h1><p>如 <code>木材、玻璃、陶瓷、云母等</code> 不易导电，叫做 <code>绝缘体</code></p><h1 id="半导体"><a href="#半导体" class="headerlink" title="半导体"></a>半导体</h1><p>导电性能介于 <code>导体和绝缘体之间的物质</code>，叫 <code>半导体</code>，如 <code>硅、锗、砷化镓</code> 等</p><h1 id="晶体管"><a href="#晶体管" class="headerlink" title="晶体管"></a>晶体管</h1><ul><li><p><code>晶体管</code> 就是用 <code>半导体</code> 材料制成的，最常见的就是 <code>硅和锗</code>。</p></li><li><p><code>体积小、放热少</code>。可用于设计 <code>小型、复杂、可靠的电路</code>。</p></li><li><p>被广泛用于 <code>工农业生产、国防建设和日常生活中</code>。</p></li></ul><h1 id="【问题一】元器件为什么用半导体？"><a href="#【问题一】元器件为什么用半导体？" class="headerlink" title="【问题一】元器件为什么用半导体？"></a>【问题一】元器件为什么用半导体？</h1><p>半导体介于导体和绝缘体之间。可以做成两种不同特性的 <code>基片</code>。把这两种 <code>基片</code> 结合到一起，可体现 <code>绝缘和导体</code> 交替的特性。</p><h1 id="为什么用硅而不用锗？"><a href="#为什么用硅而不用锗？" class="headerlink" title="为什么用硅而不用锗？"></a>为什么用硅而不用锗？</h1><ul><li>硅比锗更耐高温</li><li>硅比锗稳定性更好</li></ul><h1 id="集成电路"><a href="#集成电路" class="headerlink" title="集成电路"></a>集成电路</h1><ul><li><p><code>集成电路</code> 是一种 <code>微型电子器件</code>。缩写 <code>IC</code>。<code>硅</code> 集成电路是主流，就是把实现某种功能的电路所需的各种元件都放在一块硅片上，所形成的整体被称作集成电路。</p></li><li><p><code>晶体管、电容、电阻和电感等</code> 是集成电路的重要的 <code>元器件</code>。把其与 <code>布线</code> 互连，封装在一个 <code>管壳</code> 内，形成具有电路功能的 <code>微型结构</code>。</p></li><li><p><code>集成电路</code> 具有 <code>体积小，重量轻，引出线和焊接点少，寿命长，可靠性高，性能好等优点，同时成本低，便于大规模生产。</code></p></li><li><p>它不仅在 <code>工、民用电子设备</code> 如收录机、电视机、计算机等方面得到广泛的应用。同时在 <code>军事、通讯、遥控等</code> 方面也得到广泛的应用。用集成电路来装配电子设备，其装配密度比晶体管可提高几十倍至几千倍，设备的稳定工作时间也可大大提高。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;导体&quot;&gt;&lt;a href=&quot;#导体&quot; class=&quot;headerlink&quot; title=&quot;导体&quot;&gt;&lt;/a&gt;导体&lt;/h1&gt;&lt;p&gt;如 &lt;code&gt;金、银、铜、铁等金属&lt;/code&gt;，它们导电性能好，叫做 &lt;code&gt;导体&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;绝缘体&quot;&gt;</summary>
      
    
    
    
    <category term="销售" scheme="https://www.bboyzj.cn/categories/%E9%94%80%E5%94%AE/"/>
    
    
    <category term="销售" scheme="https://www.bboyzj.cn/tags/%E9%94%80%E5%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>销售01：大客户</title>
    <link href="https://www.bboyzj.cn/2023/04/08/%E9%94%80%E5%94%AE/%E9%94%80%E5%94%AE01%EF%BC%9A%E5%A4%A7%E5%AE%A2%E6%88%B7/"/>
    <id>https://www.bboyzj.cn/2023/04/08/%E9%94%80%E5%94%AE/%E9%94%80%E5%94%AE01%EF%BC%9A%E5%A4%A7%E5%AE%A2%E6%88%B7/</id>
    <published>2023-04-08T08:52:36.000Z</published>
    <updated>2023-04-08T09:48:28.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是大客户？"><a href="#什么是大客户？" class="headerlink" title="什么是大客户？"></a>什么是大客户？</h1><p>1897年，意大利经济学者帕累托发现：社会上20%的人占有80%的社会财富。后来这一法则被发现可以适用到很多领域，包括客户管理，具体解释为 <code>一家企业80%的收益来源于20%的客户</code>，<code>即20%客户创造了企业80%的收益</code>。</p><p>由于20%的客户掌控着企业生存和发展的命脉，企业一般需要投入80%的精力到这20%的客户身上，同时我们称这20%的客户为 <code>“大客户”</code>。</p><h1 id="KA"><a href="#KA" class="headerlink" title="KA"></a>KA</h1><p><code>KA</code>（KeyAccount），直译为 <code>关键客户</code>，中文意为 <code>重点客户，重要性的客户</code></p><h1 id="SaaS"><a href="#SaaS" class="headerlink" title="SaaS"></a>SaaS</h1><p><code>软件运营服务</code> 是 <code>SaaS（Software as a Service）</code> 的中文翻译。是指用户获取软件服务的一种新形式。它不需要用户将软件产品安装在自己的电脑或服务器上。</p><h1 id="ERP"><a href="#ERP" class="headerlink" title="ERP"></a>ERP</h1><p><code>企业资源计划</code> 即 <code>ERP</code> (Enterprise Resource Planning)</p><h1 id="OA"><a href="#OA" class="headerlink" title="OA"></a>OA</h1><p><code>办公自动化</code>（Office Automation，简称OA），是将计算机、通信等现代化技术运用到传统办公方式，进而形成的一种新型办公方式。</p><h1 id="CRM"><a href="#CRM" class="headerlink" title="CRM"></a>CRM</h1><p><code>客户关系管理</code>（Customer Relationship Management，简称CRM），是指企业为提高核心竞争力，利用相应的信息技术以及互联网技术协调企业与顾客间在销售、营销和服务上的交互，从而提升其管理方式，向客户提供创新式的个性化的客户交互和服务的过程。其最终目标是吸引新客户、保留老客户以及将已有客户转为忠实客户，增加市场。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是大客户？&quot;&gt;&lt;a href=&quot;#什么是大客户？&quot; class=&quot;headerlink&quot; title=&quot;什么是大客户？&quot;&gt;&lt;/a&gt;什么是大客户？&lt;/h1&gt;&lt;p&gt;1897年，意大利经济学者帕累托发现：社会上20%的人占有80%的社会财富。后来这一法则被发现可以适</summary>
      
    
    
    
    <category term="销售" scheme="https://www.bboyzj.cn/categories/%E9%94%80%E5%94%AE/"/>
    
    
    <category term="销售" scheme="https://www.bboyzj.cn/tags/%E9%94%80%E5%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习30：DNS原理</title>
    <link href="https://www.bboyzj.cn/2023/04/06/Swift/Swift%E5%AD%A6%E4%B9%A030%EF%BC%9ADNS%E5%8E%9F%E7%90%86/"/>
    <id>https://www.bboyzj.cn/2023/04/06/Swift/Swift%E5%AD%A6%E4%B9%A030%EF%BC%9ADNS%E5%8E%9F%E7%90%86/</id>
    <published>2023-04-06T03:22:53.000Z</published>
    <updated>2023-04-12T16:35:35.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS-是什么？"><a href="#DNS-是什么？" class="headerlink" title="DNS 是什么？"></a>DNS 是什么？</h1><p><code>DNS</code>，就是 <code>Domain Name System</code> 的缩写，翻译过来就是 <code>域名系统</code>。是互联网上作为 <code>域名和IP地址相互映射的一个分布式数据库</code>。<code>DNS</code> 能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 <code>IP</code> 数串。通过域名，最终得到该域名对应的IP地址的过程叫做 <code>域名解析</code>（或主机名解析）。</p><p>举例：如果你要访问域名 <code>www.bboyzj.cn</code> ，首先要通过 <code>DNS</code> 查出它的 <code>IP</code> 地址是  <code>113.31.107.233</code>。</p><h1 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h1><p>虽然只需要返回一个 <code>IP</code> 地址，但是 <code>DNS</code> 查询过程非常复杂，分成多个步骤</p><ol><li>查询 <code>IP</code> 地址</li></ol><p>终端执行：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % dig www.bboyzj.cn</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16807520070188.jpg"                                     ></p><ul><li>第一部分：查询 参数和统计</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; www.bboyzj.cn</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 5433</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 1</span><br></pre></td></tr></table></figure></div><ul><li>第二部分：查询内容</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.bboyzj.cn.INA</span><br></pre></td></tr></table></figure></div><p>查询域名 <code>www.bboyzj.cn</code> 的 <code>A</code> 记录，<code>A</code> 是 <code>address</code> 的缩写</p><ul><li>第三部分：DNS服务器的答复</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.bboyzj.cn.355INCNAMEbboyzj.github.io.</span><br><span class="line">bboyzj.github.io.3355INA185.199.111.153</span><br><span class="line">bboyzj.github.io.3355INA185.199.109.153</span><br><span class="line">bboyzj.github.io.3355INA185.199.108.153</span><br><span class="line">bboyzj.github.io.3355INA185.199.110.153</span><br></pre></td></tr></table></figure></div><blockquote><p>注：<br><code>A</code> ：<code>地址记录（Address），返回域名指向的IP地址</code>。<br><code>CNAME</code>： 记录主要用于 <code>域名内部的跳转</code>。<br><code>NS</code>：<code>域名服务器记录</code>（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。</p></blockquote><p>上面的结果表示：</p><p><code>www.bboyzj.cn</code> 内部跳转指向 <code>bboyzj.github.io</code>，也就是说，用户查询 <code>www.bboyzj.cn</code> 的时候，实际上返回的是 <code>bboyzj.github.io</code> 的 <code>IP</code> 地址。即<code>www.bboyzj.cn</code> 的 <code>CNAME</code> 记录指向 <code>bboyzj.github.io</code> 的 <code>IP</code> 地址。这样的好处是，变更服务器 <code>IP</code> 地址的时候，只需要修改 <code>bboyzj.github.io</code> 这个域名就可以了，用户的 <code>www.bboyzj.cn</code> 域名不用修改</p><p><code>bboyzj.github.io</code> 有四个 <code>A</code> 记录，即四个IP地址，<code>3355</code> 是 <code>TTL</code> 值（Time to live 的缩写），表示 <code>缓存时间</code>，即 <code>3355秒</code> 之内不用重新查询。</p><ul><li>第四部分：DNS服务器的一些传输信息</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;; Query time: 65 msec</span><br><span class="line">;; SERVER: 113.31.107.233#53(113.31.107.233)</span><br><span class="line">;; WHEN: Thu Apr 06 11:34:49 CST 2023</span><br><span class="line">;; MSG SIZE  rcvd: 136</span><br></pre></td></tr></table></figure></div><p>本机的 <code>DNS</code> 服务器是 <code>113.31.107.233</code>，查询端口号是 <code>53</code>（DNS服务器默认端口），以及回应长度是 <code>136</code> 字节。</p><ol start="2"><li>如果不想看到这么多内容，可以是用 <code>+short</code> 参数</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % dig +short www.bboyzj.cn</span><br><span class="line">bboyzj.github.io.</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure></div><p>只返回 <code>www.bboyzj.cn</code> 对应的 <code>四个</code> IP地址(即 <code>A</code> 记录)</p><h1 id="域名的层次"><a href="#域名的层次" class="headerlink" title="域名的层次"></a>域名的层次</h1><p><code>DNS</code> 服务器怎么知道每个域名的 <code>IP</code> 地址的呢？</p><p>答：<code>分级查询</code></p><ul><li>根域名</li></ul><p>举例：<code>bboyzj.github.io</code> 显示为 <code>bboyzj.github.io.</code> ，这不是疏忽，而是所有域名的尾部，实际上都有一个 <code>根域名</code>，实际上的域名是 <code>bboyzj.github.io.root</code>，简写成 <code>bboyzj.github.io.</code>。因为，根域名 <code>.root</code> 对于所有域名都是一样的，可以省略</p><ul><li>顶级域名</li></ul><p>根域名的下一级是 <code>顶级域名（top-level domain，缩写 TLD）</code>，比如 <code>.com/.net/.cn</code></p><ul><li>次级域名</li></ul><p>顶级域名的下一级叫 <code>次级域名（second-level domain，缩写 SLD）</code>，比如 <code>www.bboyzj.cn</code> 中的 <code>.bboyzj</code></p><ul><li>主机</li></ul><p>次级域名的下一级叫 <code>主机（host）</code>，比如： <code>www.bboyzj.cn</code> 中的 <code>www</code>，又称 <code>三级域名</code></p><ul><li>总结</li></ul><p>域名的层级结构：<code>主机名.次级域名.顶级域名.根域名</code></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host.sld.tld.root</span><br></pre></td></tr></table></figure></div><h1 id="分级查询"><a href="#分级查询" class="headerlink" title="分级查询"></a>分级查询</h1><p><code>分级查询</code> 就是从 <code>根域名</code> 依次查询每一级的 <code>NS</code> 记录，知道查到最终的 <code>IP</code> 地址。需要明确的是 <code>NS记录</code> 是 <code>域名服务器记录</code>（Name Server），返回保存下一级域名信息的服务器地址。大致过程如下：</p><ol><li><code>根域名服务器</code> 查到 <code>顶级域名服务器</code> 的 <code>NS记录</code> 和 <code>A记录</code></li><li><code>顶级域名服务器</code> 查到 <code>次级域名服务器</code> 的 <code>NS记录</code> 和 <code>A记录</code></li><li><code>次级域名服务器</code> 查到 <code>主机名</code> 的 <code>IP</code> 地址</li></ol><p>从上面看到没有提及 <code>根域名服务器</code> 的 <code>NS记录</code> 和 <code>A记录</code>，因为 <code>根域名服务器</code> 的 <code>NS记录</code> 和 <code>A记录</code> 地址一般是 <code>不会变化的</code>，<code>内置在DNS服务器中</code></p><p>目前，世界上一共有十三组根域名服务器，<code>从 A.ROOT-SERVERS.NET</code> 到 <code>M.ROOT-SERVERS.NET</code></p><ul><li><code>dig</code> 命令 <code>+trace</code> 参数显示 <code>DNS</code> 的整个分级查询过程</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@MacdeMacBook-Pro ~ % dig +trace www.bboyzj.cn</span><br></pre></td></tr></table></figure></div><p>上面的命令列出了 <code>根域名服务</code> 器的所有 <code>NS记录</code>，即 <code>所有根域名服务器</code></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; +trace www.bboyzj.cn</span><br><span class="line">;; global options: +cmd</span><br><span class="line">.847INNSe.root-servers.net.</span><br><span class="line">.847INNSa.root-servers.net.</span><br><span class="line">.847INNSk.root-servers.net.</span><br><span class="line">.847INNSi.root-servers.net.</span><br><span class="line">.847INNSb.root-servers.net.</span><br><span class="line">.847INNSd.root-servers.net.</span><br><span class="line">.847INNSm.root-servers.net.</span><br><span class="line">.847INNSc.root-servers.net.</span><br><span class="line">.847INNSh.root-servers.net.</span><br><span class="line">.847INNSf.root-servers.net.</span><br><span class="line">.847INNSj.root-servers.net.</span><br><span class="line">.847INNSg.root-servers.net.</span><br><span class="line">.847INNSl.root-servers.net.</span><br><span class="line">;; Received 239 bytes from 114.114.114.114#53(114.114.114.114) in 15 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>然后，服务器跳转到 <code>bboyzj.github.io</code></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.bboyzj.cn.1INCNAMEbboyzj.github.io.</span><br></pre></td></tr></table></figure></div><p>最后，<code>bboyzj.github.io</code> 有4条A记录，即这四个IP地址都可以访问到网站。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">www.bboyzj.cn.1INCNAMEbboyzj.github.io.</span><br><span class="line">bboyzj.github.io.3600INA185.199.111.153</span><br><span class="line">bboyzj.github.io.3600INA185.199.110.153</span><br><span class="line">bboyzj.github.io.3600INA185.199.109.153</span><br><span class="line">bboyzj.github.io.3600INA185.199.108.153</span><br><span class="line">;; Received 136 bytes from 192.5.5.241#53(f.root-servers.net) in 78 ms</span><br></pre></td></tr></table></figure></div><h1 id="其他-DNS-工具"><a href="#其他-DNS-工具" class="headerlink" title="其他 DNS 工具"></a>其他 DNS 工具</h1><p>除了dig，还有一些其他小工具也可以使用。</p><ol><li>host 命令</li></ol><p>host命令可以看作dig命令的简化版本，返回当前请求域名的各种记录。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % host bboyzj.cn</span><br><span class="line">bboyzj.cn has address 185.199.109.153</span><br></pre></td></tr></table></figure></div><ol start="2"><li>nslookup 命令</li></ol><p>nslookup命令用于互动式地查询域名记录。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><ol start="3"><li></li></ol><ol start="4"><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DNS-是什么？&quot;&gt;&lt;a href=&quot;#DNS-是什么？&quot; class=&quot;headerlink&quot; title=&quot;DNS 是什么？&quot;&gt;&lt;/a&gt;DNS 是什么？&lt;/h1&gt;&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt;，就是 &lt;code&gt;Domain Name System&lt;/</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习29：动画</title>
    <link href="https://www.bboyzj.cn/2023/04/03/Swift/Swift%E5%AD%A6%E4%B9%A029%EF%BC%9A%E5%8A%A8%E7%94%BB/"/>
    <id>https://www.bboyzj.cn/2023/04/03/Swift/Swift%E5%AD%A6%E4%B9%A029%EF%BC%9A%E5%8A%A8%E7%94%BB/</id>
    <published>2023-04-03T05:43:21.000Z</published>
    <updated>2023-04-12T13:19:03.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-动画框架"><a href="#iOS-动画框架" class="headerlink" title="iOS 动画框架"></a>iOS 动画框架</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304031444314.png"                                     ></p><ul><li>从图中可以看出，<code>iOS</code> 从上层到底层你会接触到 <code>UIKit、Core Animation、Core Graphics</code>。使用难度依次递增，实现效果的复杂度越来越高</li></ul><h1 id="CALager-绘制的子类"><a href="#CALager-绘制的子类" class="headerlink" title="CALager 绘制的子类"></a>CALager 绘制的子类</h1><ul><li>CAShapeLayer：用于绘制曲线等图形</li><li>CATextLayer：用于绘制文字</li><li>CAGradientLayer：用于绘制渐变</li></ul><h1 id="UIView和CALayer关系"><a href="#UIView和CALayer关系" class="headerlink" title="UIView和CALayer关系"></a>UIView和CALayer关系</h1><ul><li>UIView 可以 <code>响应事件</code>；CALayer 不可以</li><li>UIView 主要是对 <code>显示内容的管理</code>；CALayer 主要侧重 <code>显示内容的绘制</code></li><li>UIView 是 iOS 平台对 <code>CALayer</code> 的 <code>封装</code>；CALayer 是 iOS 和 OSX 跨平台的类</li><li>UIView 的很多属性其实是返回 <code>CALayer</code> 的属性，比如 <code>frame、center</code> 等等</li></ul><h1 id="导入头文件"><a href="#导入头文件" class="headerlink" title="导入头文件"></a>导入头文件</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import ImageIO</span><br></pre></td></tr></table></figure></div><h1 id="UIView的Block动画"><a href="#UIView的Block动画" class="headerlink" title="UIView的Block动画"></a>UIView的Block动画</h1><ol><li><code>UIView</code> 的 <code>Block</code> 动画的适用范围</li></ol><p><code>UIView</code> 的动画可以修改一些 <code>属性</code>，将其以动画的形式展示出来。可修改的属性如下：<code>frame(尺寸)\bound(大小)\center(中心)\ transform(旋转)\alpha(透明度)\ backgroundColor(背景颜色)\ contentStretch(内容拉伸)</code> 等。</p><ol start="2"><li>使用 <code>UIView</code> 实现普通动画</li></ol><ul><li>只可以设置动画内容的动画函数</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> 1、设置动画时间</span><br><span class="line"> 2、设置动画内容</span><br><span class="line"> */</span><br><span class="line">UIView.animate(withDuration:5) &#123;</span><br><span class="line">    // 位置和颜色的变换</span><br><span class="line">    animationView.frame = CGRect.init(x: self.view.frame.width - 200, y: 50, width:100, height: 200)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>可设置动画时间、动画内容、动画结束后的内容的函数</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> /*!</span><br><span class="line"> 1、设置动画时间</span><br><span class="line"> 2、设置动画内容</span><br><span class="line"> 3、设置动画结束后的处理事件</span><br><span class="line"> */</span><br><span class="line">UIView.animate(withDuration: 5, animations: &#123;</span><br><span class="line">    // 位置和颜色的变换</span><br><span class="line">    animationView.frame = CGRect.init(x: 100, y: 50, width: 100, height: 200)</span><br><span class="line">&#125;) &#123; (isFinish) in</span><br><span class="line">    if isFinish &#123;</span><br><span class="line">        // 变色</span><br><span class="line">        self.View1!.backgroundColor = UIColor.magenta</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>设置动画时间、动画延迟时间、动画内容、动画结束内容的动画函数</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> 可设置延时时间的动画</span><br><span class="line"> </span><br><span class="line"> @withDuration : 设置动画时间</span><br><span class="line"> @delay : 设置动画延迟时间</span><br><span class="line"> @options : 设置动画的形式</span><br><span class="line"> */</span><br><span class="line">UIView.animate(withDuration: 5, delay: 2, options: .allowUserInteraction, animations: &#123;</span><br><span class="line">    // code.... 动画的内容</span><br><span class="line">&#125;) &#123; (isFinish) in</span><br><span class="line">    // code.... 动画结束后的处理内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>弹簧动画函数</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> 弹簧式动画</span><br><span class="line"> </span><br><span class="line"> @withDuration : 设置动画时间</span><br><span class="line"> @delay : 设置动画延时时间</span><br><span class="line"> @usingSpringWithDamping : 设置阻尼系数(该数字越大，动画弹动的次数越少)</span><br><span class="line"> @initialSpringVelocity : 设置初始速度(该数字越大，震动的振幅越大)</span><br><span class="line"> @options : 设置动画的出现形式</span><br><span class="line"> */</span><br><span class="line">UIView.animate(withDuration: 5, delay: 2, usingSpringWithDamping: 0.1, initialSpringVelocity: 10, options: .curveEaseIn, animations: &#123;</span><br><span class="line">    // code.... 动画的内容</span><br><span class="line">    animationView.frame = CGRect.init(x: (self.View1?.center.x)!-20, y: 110, width: 40, height: 40)</span><br><span class="line">&#125;) &#123; (isFinish) in</span><br><span class="line">    // code.... 动画结束后的处理内容</span><br><span class="line">    animationView.frame = CGRect.init(x: self.View1!.center.x-40, y: 110, width: 80, height: 80)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>帧动画函数</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> 帧动画</span><br><span class="line"> </span><br><span class="line"> @withDuration : 设置动画时间</span><br><span class="line"> @delay : 设置动画延迟时间</span><br><span class="line"> @options ：设置动画形式</span><br><span class="line"> */</span><br><span class="line">UIView.animateKeyframes(withDuration: 8, delay: 0, options: .calculationModeLinear, animations: &#123;</span><br><span class="line">    // code.... 动画的内容</span><br><span class="line">    UIView.addKeyframe(withRelativeStartTime: 0, relativeDuration: 1.0/4, animations: &#123;</span><br><span class="line">         animationView.backgroundColor = UIColor.red</span><br><span class="line">    &#125;)</span><br><span class="line">    UIView.addKeyframe(withRelativeStartTime: 1.0/4, relativeDuration: 1.0/4, animations: &#123;</span><br><span class="line">        animationView.backgroundColor = UIColor.green</span><br><span class="line">    &#125;)</span><br><span class="line">    UIView.addKeyframe(withRelativeStartTime: 2.0/4, relativeDuration: 1.0/4, animations: &#123;</span><br><span class="line">        animationView.backgroundColor = UIColor.blue</span><br><span class="line">    &#125;)</span><br><span class="line">    UIView.addKeyframe(withRelativeStartTime: 3.0/4, relativeDuration: 1.0/4, animations: &#123;</span><br><span class="line">        animationView.backgroundColor = UIColor.magenta</span><br><span class="line">    &#125;)</span><br><span class="line">    UIView.addKeyframe(withRelativeStartTime: 4.0/4, relativeDuration: 1.0/4, animations: &#123;</span><br><span class="line">        animationView.backgroundColor = UIColor.purple</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;) &#123; (isFinish) in</span><br><span class="line">    // code.... 动画结束后的处理内容</span><br><span class="line">    animationView.backgroundColor = UIColor.cyan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>关键帧动画的单帧动画设置</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> 帧动画</span><br><span class="line"> </span><br><span class="line"> @withRelativeStartTime : 设置动画的开始时间</span><br><span class="line"> @relativeDuration : 动画的持续时间</span><br><span class="line"> */</span><br><span class="line">UIView.addKeyframe(withRelativeStartTime: 0, relativeDuration: 1.0/4, animations: &#123;</span><br><span class="line">    animationView.backgroundColor = UIColor.purple</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><ol start="3"><li>UIView 转场动画</li></ol><ul><li>单个 <code>View</code> 转场动画</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*！</span><br><span class="line"> 单个View的转场动画</span><br><span class="line"> </span><br><span class="line"> @with : 要转场的View</span><br><span class="line"> @duration : 转场时间</span><br><span class="line"> @options : 动画的类型</span><br><span class="line"> */</span><br><span class="line">UIView.transition(with: animationView, duration: 5, options:.transitionCurlUp, animations: &#123;</span><br><span class="line">    self.imageView4?.image = UIImage.init(named: &quot;2.jpg&quot;)</span><br><span class="line">&#125;) &#123; (isFinsish) in</span><br><span class="line">    // code .... 转场结束事件处理</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></div><ul><li>两个 <code>View</code> 的转场动画</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> 转场动画</span><br><span class="line"> </span><br><span class="line"> @from : 起始View</span><br><span class="line"> @to : 结束View</span><br><span class="line"> @duration : 动画时间</span><br><span class="line"> @options : 动画的形式</span><br><span class="line"> */</span><br><span class="line">UIView.transition(from: fromView, to: toView, duration: 5, options: [ .transitionFlipFromLeft,.showHideTransitionViews]) &#123; (isFinish) in</span><br><span class="line">    // code .... 两个View的其他处理内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="4"><li>UIView 基本动画写法</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// TODO: 动画的一般写法</span><br><span class="line">func basicAnimation() -&gt; Void &#123;</span><br><span class="line">    // 开始某个动画</span><br><span class="line">    UIView.beginAnimations(&quot;animation&quot;, context: nil)</span><br><span class="line">    // 设置动画时间</span><br><span class="line">    UIView.setAnimationDuration(5)</span><br><span class="line">    // 设置动画的延时时间</span><br><span class="line">    UIView.setAnimationDelay(0.25)</span><br><span class="line">    // 设置动画的效果</span><br><span class="line">    UIView.setAnimationCurve(.easeInOut)</span><br><span class="line">    // 设置动画是否重复，0为无限重复</span><br><span class="line">    UIView.setAnimationRepeatCount(0)</span><br><span class="line">    // 设置动画的代理</span><br><span class="line">    UIView.setAnimationDelegate(self)</span><br><span class="line">    // 设置动画将要触发的时调用的方法</span><br><span class="line">    UIView.setAnimationWillStart(#selector(willStartMethod))</span><br><span class="line">    // 设置动画结束时触发的方法</span><br><span class="line">    UIView.setAnimationDidStop(#selector(didStopMethod))</span><br><span class="line">    // 设置动画是否可用</span><br><span class="line">    UIView.setAnimationsEnabled(true)</span><br><span class="line">    // 设置动画是否从当前状态开始（例如：一个动画正在播放时，我们要进行下一个动画，如果设置为 true 时，动画将从当前动画状态开始动画。为 false时是等上一个动画停止时，开始下一个动画）</span><br><span class="line">    UIView.setAnimationBeginsFromCurrentState(true)</span><br><span class="line">    // 设置动画开始的时间</span><br><span class="line">    UIView.setAnimationStart(Date.init())</span><br><span class="line">    // 设置动画是否执行动画回路,前提 UIView.setAnimationRepeatCount(0) 为 0</span><br><span class="line">    UIView.setAnimationRepeatAutoreverses(true)</span><br><span class="line">    // 设置单个View的转场动画</span><br><span class="line">    UIView.setAnimationTransition(.flipFromLeft, for: self.view, cache: true)</span><br><span class="line">    // 设置动画的结束</span><br><span class="line">    UIView.commitAnimations()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 动画代理触发事件</span><br><span class="line"></span><br><span class="line">@objc func willStartMethod() &#123;</span><br><span class="line">    // 动画将要开始执行触发的代理事件</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@objc func didStopMethod() &#123;</span><br><span class="line">    // 动画结束后触发的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="Core-Animation-动画"><a href="#Core-Animation-动画" class="headerlink" title="Core Animation 动画"></a>Core Animation 动画</h1><ol><li><code>Core Animation</code> 动画的适用场景？</li></ol><ul><li>当我们无法用 <code>Block</code> 动画解决动画问题时，就是 <code>Core Animation</code> 出场了</li><li>比如：改变 <code>cornerRadius</code>，沿着一条曲线移动 <code>view</code> 等等</li></ul><ol start="2"><li><code>Core Animation</code> 的所有功能都是基于 <code>layer</code> 对吗？</li></ol><ul><li>对，都基于 <code>layer</code></li><li>当你通过 <code>Core Animation</code> 修改了 <code>layer</code> 的属性时，<code>Core Animation</code> 会通过<br><code>GPU</code> 来重新渲染位图，因为是硬件渲染，因此速度非常快。</li></ul><ol start="3"><li>几种常用的 <code>CALayer</code> 子类</li></ol><ul><li><code>CAEmitterLayer</code> 类</li></ul><p><code>CAEmitterLayer</code> 是一个粒子发射器系统，负责粒子的创建和发射源属性的配置。它可以创建出炫酷的粒子效果动画</p><ul><li><code>CAGradientLayer</code> 类</li></ul><p>可以创建色彩渐变的图层效果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建图层对象</span><br><span class="line">let gradientLayer = CAGradientLayer()</span><br><span class="line">// 设置图层尺寸与位置</span><br><span class="line">gradientLayer.bounds = CGRect(x: 0, y: 100, width: 100, height: 100)</span><br><span class="line">gradientLayer.position = CGPoint(x: 100, y: 100)</span><br><span class="line">// 设置要进行色彩渐变的颜色</span><br><span class="line">gradientLayer.colors = [UIColor.red.cgColor,UIColor.green.cgColor,UIColor.blue.cgColor]</span><br><span class="line">// 设置要进行渐变的临界位置 当红色渲染到1/5后开始向绿色进行渐变，绿色渲染到1/2后开始向蓝色进行渐变，当到达7/10距离后完成渐变过程，开始渲染为纯蓝色</span><br><span class="line">gradientLayer.locations = [NSNumber(value: 0.2),NSNumber(value: 0.5),NSNumber(value: 0.7)]</span><br><span class="line">// 设置渐变的起始点与结束点 (0,0)左上角 (1,1)右下角</span><br><span class="line">gradientLayer.startPoint = CGPoint(x: 0, y: 0.5)</span><br><span class="line">gradientLayer.endPoint = CGPoint(x: 1, y: 0.5)</span><br><span class="line">// 添加视图</span><br><span class="line">self.view.layer.addSublayer(gradientLayer)</span><br></pre></td></tr></table></figure></div><ul><li>CAEAGLLayer 类</li></ul><p>可以通过 <code>OpenGL ES</code> 来进行界面的绘制</p><ul><li>CAReplicatorLayer 类</li></ul><p><code>CAReplicatorLayer</code> 是一个图层容器，会对其中的子图层进行复制和属性偏移。可以用来创建类型倒影效果，也可以进行图层的变换复制</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 创建拷贝图层</span><br><span class="line">let replicatorLayer = CAReplicatorLayer()</span><br><span class="line">replicatorLayer.position = CGPoint.zero</span><br><span class="line">// 创建内容图层</span><br><span class="line">let subLayer = CALayer()</span><br><span class="line">subLayer.bounds = CGRect(x: 0, y: 0, width: 20, height: 20)</span><br><span class="line">subLayer.position = CGPoint(x: 30, y: 100)</span><br><span class="line">subLayer.backgroundColor = UIColor.red.cgColor</span><br><span class="line">replicatorLayer.addSublayer(subLayer)</span><br><span class="line">// 设置每次拷贝将副本沿x轴平移30个单位</span><br><span class="line">replicatorLayer.instanceTransform = CATransform3DMakeTranslation(30, 0, 0)</span><br><span class="line">// 设置拷贝副本的个数</span><br><span class="line">replicatorLayer.instanceCount = 10</span><br><span class="line">// 添加视图</span><br><span class="line">self.view.layer.addSublayer(replicatorLayer)</span><br></pre></td></tr></table></figure></div><ul><li>CAScrollLayer类</li></ul><p>可以让其管理的多个子层进行滑动，但是只能通过代码进行管理，不能进行用户点按触发</p><ul><li>CAShapeLayer类</li></ul><p>可以在图层上直接绘制出自定义的形状</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 创建图层</span><br><span class="line">let shapeLayer = CAShapeLayer()</span><br><span class="line">shapeLayer.position = CGPoint.zero</span><br><span class="line">// 创建图形路径</span><br><span class="line">let path = CGMutablePath()</span><br><span class="line">// 设置路径起点</span><br><span class="line">path.move(to: CGPoint(x: 100, y: 100))</span><br><span class="line">// 进行画线</span><br><span class="line">path.addLine(to: CGPoint(x: 300, y: 100))</span><br><span class="line">path.addLine(to: CGPoint(x: 200, y: 200))</span><br><span class="line">path.addLine(to: CGPoint(x: 100, y: 100))</span><br><span class="line">// 设置图层路径</span><br><span class="line">shapeLayer.path = path</span><br><span class="line">// 设置图形边缘线条起点</span><br><span class="line">shapeLayer.strokeStart = 0</span><br><span class="line">// 设置图形边缘线条终点</span><br><span class="line">shapeLayer.strokeEnd = 1</span><br><span class="line">// 设置填充规则</span><br><span class="line">shapeLayer.fillRule = CAShapeLayerFillRule.evenOdd</span><br><span class="line">// 设置填充颜色</span><br><span class="line">shapeLayer.fillColor = UIColor.red.cgColor</span><br><span class="line">// 设置边缘线条颜色</span><br><span class="line">shapeLayer.strokeColor = UIColor.blue.cgColor</span><br><span class="line">// 设置边缘线条宽度</span><br><span class="line">shapeLayer.lineWidth = 1</span><br><span class="line">self.view.layer.addSublayer(shapeLayer)</span><br></pre></td></tr></table></figure></div><ul><li>CATextLayer类</li></ul><p>用于进行文字的绘制</p><ul><li>CATiledLayer类</li></ul><p>瓦片视图，可以分区域绘制，常用于在一张大的图片中分区域绘制</p><ul><li>CATransformLayer类</li></ul><p>用于构建一些图层变化效果，包括3D效果的图层变换</p><ol start="4"><li>CoreAnimation 框架中的属性动画</li></ol><p><code>CAAnimation</code> 类是 <code>CoreAnimation</code> 子类，主要分为：<code>CAPropertyAnimation</code>(<code>CABasicAnimation</code> 属性过渡动画、<code>CAKeyframeAnimation</code> 关键帧属性过渡动画)、<code>CATransition</code>、<code>CAAnimationGroup</code></p><ul><li>CABasicAnimation 属性过渡动画</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 创建动画实例，keyPath为要进行属性动画的属性路径 transform.rotation.z 表示图形属性中以 z 轴为中心轴的旋转属性</span><br><span class="line">let basicAni = CABasicAnimation(keyPath: &quot;transform.rotation.z&quot;)</span><br><span class="line">// 从0度开始旋转</span><br><span class="line">basicAni.fromValue = NSNumber(value: 0)</span><br><span class="line">// 旋转到180度</span><br><span class="line">basicAni.toValue = NSNumber(value: Double.pi)</span><br><span class="line">// 设置动画播放的时长</span><br><span class="line">basicAni.duration = 2</span><br><span class="line">// 将动画作用于当前界面的视图Layer层上</span><br><span class="line">self.view.layer.add(basicAni, forKey: nil)</span><br></pre></td></tr></table></figure></div><ul><li>CAKeyframeAnimation关键帧动画</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建动画实例，keyPath为要进行属性动画的属性路径 transform.rotation.z 表示图形属性中以z轴为中心轴的旋转属性</span><br><span class="line">let keyframeAni = CAKeyframeAnimation(keyPath: &quot;transform.rotation.z&quot;)</span><br><span class="line">// 从0度开始旋转</span><br><span class="line">keyframeAni.values = [NSNumber(value: 0),NSNumber(value: Double.pi/4),NSNumber(value: 0),NSNumber(value: Double.pi)]</span><br><span class="line">// 设置动画播放的时长</span><br><span class="line">keyframeAni.duration = 3</span><br><span class="line">// 将动画作用于当前界面的视图Layer层上</span><br><span class="line">self.view.layer.add(keyframeAni, forKey: &quot;&quot;)</span><br></pre></td></tr></table></figure></div><ul><li>CASpringAnimation类似弹簧的阻尼动画</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 创建动画实例</span><br><span class="line">let springAni = CASpringAnimation(keyPath: &quot;position.y&quot;)</span><br><span class="line">// 模拟重物质量，必须大于0，默认为1，会影响惯性</span><br><span class="line">springAni.mass = 2</span><br><span class="line">// 模拟弹簧劲度系数，必须大于0，这个值越大，则回弹越快</span><br><span class="line">springAni.stiffness = 5</span><br><span class="line">// 设置阻尼系数，必须大于0，这个值越大，回弹的幅度越小</span><br><span class="line">springAni.damping = 2</span><br><span class="line">springAni.toValue = 300</span><br><span class="line">springAni.duration = 3</span><br><span class="line">// 创建演示动画的Layer</span><br><span class="line">let layer = CALayer()</span><br><span class="line">layer.position = CGPoint(x: 100, y: 100)</span><br><span class="line">layer.bounds = CGRect(x: 0, y: 0, width: 100, height: 100)</span><br><span class="line">layer.backgroundColor = UIColor.red.cgColor</span><br><span class="line">self.view.layer.addSublayer(layer)</span><br><span class="line">layer.add(springAni, forKey: &quot;&quot;)</span><br></pre></td></tr></table></figure></div><ul><li>CATransition 实现转场动画</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建转场动画实例</span><br><span class="line">let transAni = CATransition()</span><br><span class="line">// 设置转场动画类型</span><br><span class="line">transAni.type = CATransitionType.reveal</span><br><span class="line">// 设置转场动画方向</span><br><span class="line">transAni.subtype = CATransitionSubtype.fromTop</span><br><span class="line">let layer = CALayer()</span><br><span class="line">layer.position = CGPoint(x: 100, y: 100)</span><br><span class="line">layer.bounds = CGRect(x: 0, y: 0, width: 100, height: 100)</span><br><span class="line">layer.backgroundColor = UIColor.red.cgColor</span><br><span class="line">layer.add(transAni, forKey: &quot;&quot;)</span><br><span class="line">self.view.layer.addSublayer(layer)</span><br></pre></td></tr></table></figure></div><p>type转场动画属性</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 渐入效果</span><br><span class="line">transAni.type = CATransitionType.fade</span><br><span class="line">// 移入效果</span><br><span class="line">transAni.type = CATransitionType.moveIn</span><br><span class="line">// 压入效果</span><br><span class="line">transAni.type = CATransitionType.push</span><br><span class="line">// 溶解效果</span><br><span class="line">transAni.type = CATransitionType.reveal</span><br></pre></td></tr></table></figure></div><p>subtype属性</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 从右侧执行</span><br><span class="line">transAni.subtype = CATransitionSubtype.fromRight</span><br><span class="line">// 从左侧执行</span><br><span class="line">transAni.subtype = CATransitionSubtype.fromLeft</span><br><span class="line">// 从上侧执行</span><br><span class="line">transAni.subtype = CATransitionSubtype.fromTop</span><br><span class="line">// 从下侧执行</span><br><span class="line">transAni.subtype = CATransitionSubtype.fromBottom</span><br></pre></td></tr></table></figure></div><ul><li>CAAnimationGroup组合动画</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 创建背景色过渡动画</span><br><span class="line">let basicAni = CABasicAnimation(keyPath: &quot;backgroundColor&quot;)</span><br><span class="line">basicAni.toValue = UIColor.green.cgColor</span><br><span class="line">// 创建形变动画</span><br><span class="line">let basicAni2 = CABasicAnimation(keyPath: &quot;transform.scale.x&quot;)</span><br><span class="line">basicAni2.toValue = NSNumber(value: 2)</span><br><span class="line">// 进行动画组合</span><br><span class="line">let groupAni = CAAnimationGroup()</span><br><span class="line">groupAni.animations = [basicAni,basicAni2]</span><br><span class="line">groupAni.duration = 3</span><br><span class="line">    </span><br><span class="line">let layer = CALayer()</span><br><span class="line">layer.position = CGPoint(x: 100, y: 100)</span><br><span class="line">layer.bounds = CGRect(x: 0, y: 0, width: 100, height: 100)</span><br><span class="line">layer.backgroundColor = UIColor.red.cgColor</span><br><span class="line">layer.add(groupAni, forKey: &quot;&quot;)</span><br><span class="line">self.view.layer.addSublayer(layer)</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iOS-动画框架&quot;&gt;&lt;a href=&quot;#iOS-动画框架&quot; class=&quot;headerlink&quot; title=&quot;iOS 动画框架&quot;&gt;&lt;/a&gt;iOS 动画框架&lt;/h1&gt;&lt;p&gt;&lt;img  
                     lazyload
         </summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>OC学习34：自动订阅和非自动订阅内购买</title>
    <link href="https://www.bboyzj.cn/2023/03/31/OC/OC%E5%AD%A6%E4%B9%A034%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%AE%A2%E9%98%85%E5%92%8C%E9%9D%9E%E8%87%AA%E5%8A%A8%E8%AE%A2%E9%98%85%E5%86%85%E8%B4%AD%E4%B9%B0/"/>
    <id>https://www.bboyzj.cn/2023/03/31/OC/OC%E5%AD%A6%E4%B9%A034%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%AE%A2%E9%98%85%E5%92%8C%E9%9D%9E%E8%87%AA%E5%8A%A8%E8%AE%A2%E9%98%85%E5%86%85%E8%B4%AD%E4%B9%B0/</id>
    <published>2023-03-31T02:28:32.000Z</published>
    <updated>2023-04-19T06:25:03.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>iOS 内购分为四种商品类型：</p><ol><li><p>消耗品</p></li><li><p>非消耗品</p></li><li><p>自动续期订阅</p></li><li><p>非续期订阅</p></li></ol><h1 id="内购（In-App-Purchase）"><a href="#内购（In-App-Purchase）" class="headerlink" title="内购（In-App Purchase）"></a>内购（In-App Purchase）</h1><p><code>IAP</code> 全称：<code>In-App Purchase</code>，是指苹果 <code>App Store</code> 的应用内购买，是苹果为 <code>App</code> 内购买 <code>虚拟商品或服务</code> 提供的一套交易系统。</p><p>适用范围：在 <code>App</code> 内需要付费使用的产品功能或虚拟商品&#x2F;服务，如游戏道具、电子书、音乐、视频、订阅会员、App的高级功能等需要使用 <code>IAP</code>，而在 <code>App</code> 内购买实体商品（如淘宝购买手机）或者不在 <code>App</code> 内使用的虚拟商品（如充话费）或服务（如滴滴叫车）则不适用于 <code>IAP</code>。</p><p>简而言之，苹果规定：适用范围内的 <code>虚拟商品或服务</code>，必须使用 <code>IAP</code> 进行购买支付，不允许使用支付宝、微信支付等其它第三方支付方式（包括Apple Pay），也不允许以任何方式（包括跳出App、提示文案等）引导用户通过应用外部渠道购买。</p><h1 id="内购前准备"><a href="#内购前准备" class="headerlink" title="内购前准备"></a>内购前准备</h1><p>APP内集成IAP代码之前需要先去开发账号的 <code>ITunes Connect</code> 进行以下三步操作：</p><ol><li><p>后台填写 <code>银行账户、税务</code> 信息；</p></li><li><p>配置商品信息，包括产品ID，产品价格等；</p></li><li><p>配置用于测试IAP支付功能的沙箱账户。</p></li></ol><p>填写银行账户信息一般交由产品管理人员负责，开发者不需要关注，开发者需要关注的是第二步和第三步。</p><h1 id="银行账户、税务信息填写"><a href="#银行账户、税务信息填写" class="headerlink" title="银行账户、税务信息填写"></a>银行账户、税务信息填写</h1><p>关于如何去 Itunes Connect 后台填写账户信息，本文不做讨论</p><h1 id="配置内购商品"><a href="#配置内购商品" class="headerlink" title="配置内购商品"></a>配置内购商品</h1><p><code>IAP</code> 是一套商品交易系统，而非简单的支付系统，每一个购买项目都需要在开发者后台的Itunes Connect后台为 App 创建一个对应的商品，提交给苹果审核通过后，购买项目才会生效。内购商品有四种类型：</p><ul><li><p>消耗型项目：只可使用一次的产品，使用之后即失效，必须再次购买，如：游戏币、一次性虚拟道具等；</p></li><li><p>非消耗型项目：只需购买一次，不会过期或随着使用而减少的产品。如：电子书；</p></li><li><p>自动续期订阅：允许用户在固定时间段内购买动态内容的产品。除非用户选择取消，否则此类订阅会自动续期，如：Apple Music这类按月订阅的商品；</p></li><li><p>非续期订阅：允许用户购买有时限性服务的产品，此 App 内购买项目的内容可以是静态的。此类订阅不会自动续期。</p></li></ul><h1 id="配置商品信息需要注意产品ID和产品价格"><a href="#配置商品信息需要注意产品ID和产品价格" class="headerlink" title="配置商品信息需要注意产品ID和产品价格"></a>配置商品信息需要注意产品ID和产品价格</h1><ul><li><p>产品 ID 具有唯一性，建议使用项目的 Bundle Identidier 作为前缀后面拼接自定义的唯一的商品名或者 ID（字母、数字），这里有个坑：一旦新建一个内购商品，它的产品ID将永远被占用，即使该商品已经被删除，已创建的内购商品除了产品 ID 之外的所有信息都可以修改，如果删除了一个内购商品，将无法再创建一个相同产品 ID 的商品，也意味着该产品 ID 永久失效。</p></li><li><p>在创建IAP项目的时候，需要设定价格，产品价格只能从苹果提供的价格等级去选择，这个价格等级是固定的，同一价格等级会对应各个国家的货币，比如等级1对应1美元、6元人民币，等级2对应2美元、12元人民币……最高等级87对应999.99美元、6498元人民币。另外可能是为了照顾某些货币区的开发者和用户，还有一些特殊的等级，比如备用等级A对应1美元、1元人民币，备用等级B对应1美元、3元人民币这样。除此之外，IAP项目不能定一个9.9元人民币这样不符合任何等级的价格。详细价格等级表可以看苹果的官方价格等级文档。苹果的价格等级表通常是不会调整的，但也不排除在某些货币汇率发生巨大变化的情况下，对该货币的定价进行调整，调整前苹果会发邮件通知开发者。</p></li><li><p>商品分成，App Store上的付费App和App内购，苹果与开发者默认是 <code>3/7</code> 分成。但实际上，在某些地区苹果与开发者分成之前需要先扣除交易税，开发者的实际分成不一定是70%。从2015年10月开始，苹果对中国地区的App Store购买扣除了2%的交易税，对于中国区帐号购买的IAP，开发者的实际分成在68%~69%之间，而且中国以外不同地区的交易税标准也存在差异。</p></li></ul><h1 id="配置沙箱测试账号"><a href="#配置沙箱测试账号" class="headerlink" title="配置沙箱测试账号"></a>配置沙箱测试账号</h1><ul><li><p>新的内购产品上线之前，测试人员一般需要对内购产品进行测试，但是内购涉及到钱，所以苹果为内购测试提供了 <code>沙箱测试账号</code> 的功能，<code>Apple Pay</code> 推出之后 <code>沙箱测试账号</code> 也可以用于 <code>Apple Pay</code> 支付的测试，<code>沙箱测试账号</code> 简单理解就是：只能用于 <code>内购</code> 和 <code>Apple Pay</code> 测试功能的 <code>Apple ID</code>，它并不是真实的 <code>Apple ID</code>。</p></li><li><p>填写沙箱测试账号信息需要注意以下几点：</p><ul><li>电子邮件不能是别人已经注册过 <code>AppleID</code> 的邮箱;</li><li>电子邮箱可以不是真实的邮箱，但是必须符合邮箱格式;</li><li><code>App Store</code> 地区的选择，测试的时候弹出的提示框以及结算的价格会按照沙箱账号选择的地区来，建议测试的时候新建几个不同地区的账号进行测试。</li></ul></li><li><p>沙箱账号测试的使用：</p></li><li><p>首先沙箱测试账号必须在真机环境下进行测试，并且是 adhoc 证书或者 develop 证书签名的安装包，沙盒账号不支持直接从 App Store 下载的安装包;</p></li><li><p>去真机的 <code>App Store</code> 退出真实的 <code>Apple ID</code> 账号，退出之后并不需要在App Store 里面登录沙箱测试账号;</p></li><li><p>然后去 <code>App</code> 里面测试购买商品，会弹出登录框，选择使用现有的 <code>Apple ID</code>，然后登录沙箱测试账号，登录成功之后会弹出购买提示框，点击购买，然后会弹出提示框完成购买。</p></li></ul><h1 id="内购流程"><a href="#内购流程" class="headerlink" title="内购流程"></a>内购流程</h1><ul><li><p>获取内购产品列表（从App内读取或从自己服务器读取），向用户展示内购列表</p></li><li><p>用户选择某个内购产品后，先请求可用的内购产品的本地化信息列表，此次调用Apple的 <code>StoreKit</code> 库的代码</p></li><li><p>得到内购产品的本地化信息后，根据用户选择的内购产品的ID得到内购产品</p></li><li><p>根据内购产品发起IAP购买请求，收到购买完成的回调</p></li><li><p>购买流程结束后, 向服务器发起 <code>验证凭证</code> 以及支付结果的请求</p></li><li><p>服务器接收iOS端发过来的购买凭证，判断凭证是否已经存在或验证过，然后存储该凭证。将该凭证发送到苹果的服务器验证，并将验证结果返回给客户端</p></li><li><p>自己的服务器将支付结果信息返回给前端并发放虚拟产品</p></li></ul><h1 id="自动续期订阅和非续期订阅-IAP"><a href="#自动续期订阅和非续期订阅-IAP" class="headerlink" title="自动续期订阅和非续期订阅 IAP"></a>自动续期订阅和非续期订阅 IAP</h1><ol><li>去开发者网站配置 <code>税务</code> 账号</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304181636528.png"                                     ></p><ol start="2"><li>去开发者网站配置 <code>银行</code> 账号</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304181637684.png"                                     ></p><ol start="3"><li>去开发者网站配置 <code>价格</code> 信息</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304181637798.png"                                     ></p><ol start="4"><li><p>在开发者账号中勾选内购权限</p></li><li><p>项目中封装一个 <code>FJYDIAPTool</code> 类，实现内购买功能</p></li></ol><ul><li>FJYDIAPTool.h 中</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;FJYDMeVIPModel.h&quot;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@protocol FJYDIAPToolDelegate &lt;NSObject&gt;</span><br><span class="line">// 购买并验证成功的回调</span><br><span class="line">- (void)FJYDIAPToolBuyProductSucceedWithInfoReceiptModel:(FJYDBuyReceiptModel *)receiptModel;</span><br><span class="line">// 验证凭证结束上传地理位置的回调</span><br><span class="line">- (void)FJYDIAPToolVerificationEndPostLocationWithRectiptModel:(FJYDBuyReceiptModel *)receiptModel;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface FJYDIAPTool : NSObject</span><br><span class="line">/**</span><br><span class="line"> 代理</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic,weak)id&lt;FJYDIAPToolDelegate&gt;delegate;</span><br><span class="line">//是否在购买中</span><br><span class="line">@property (nonatomic,assign)BOOL isBuying;</span><br><span class="line">/**</span><br><span class="line"> 单例</span><br><span class="line"> @return FJYDIAPTool</span><br><span class="line"> */</span><br><span class="line">+ (FJYDIAPTool *)shareTool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 初始化侦听</span><br><span class="line"> */</span><br><span class="line">- (void)setUp;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 用户决定购买商品</span><br><span class="line"></span><br><span class="line"> @param productID 商品ID</span><br><span class="line"> */</span><br><span class="line">- (void)buyProductWithProductID:(NSString *)productID;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 恢复商品</span><br><span class="line"> */</span><br><span class="line">- (void)restorePurchase;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>FJYDIAPTool.m 中</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FJYDIAPTool.h&quot;</span><br><span class="line">#import &lt;iconv.h&gt;</span><br><span class="line">#import &quot;FJYDVIPHttps.h&quot;</span><br><span class="line">#import &quot;FJYDReceiptData.h&quot;</span><br><span class="line"></span><br><span class="line">@interface FJYDIAPTool ()&lt;SKPaymentTransactionObserver,SKProductsRequestDelegate&gt;</span><br><span class="line">@property(nonatomic, strong)SKProductsRequest * request;</span><br><span class="line">@property(nonatomic,copy)NSString * productID;</span><br><span class="line">@end</span><br><span class="line">@implementation FJYDIAPTool</span><br><span class="line">// 单例</span><br><span class="line">static FJYDIAPTool * shareTool;</span><br><span class="line">+ (FJYDIAPTool *)shareTool&#123;</span><br><span class="line">    if (!shareTool) &#123;</span><br><span class="line">        shareTool = [FJYDIAPTool new];</span><br><span class="line">    &#125;</span><br><span class="line">    return shareTool;</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark -setUp</span><br><span class="line">- (void)setUp&#123;</span><br><span class="line">    // 设置购买队列的监听器</span><br><span class="line">    [[SKPaymentQueue defaultQueue] addTransactionObserver:self];</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark -用户决定购买商品</span><br><span class="line">- (void)buyProductWithProductID:(NSString *)productID&#123;</span><br><span class="line">    if ([SKPaymentQueue canMakePayments]) &#123;</span><br><span class="line">        [self requestProductData:productID];</span><br><span class="line">        self.productID = productID;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        FJYDLog(@&quot;不允许程序内付费&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark -去苹果服务器请求商品</span><br><span class="line">- (void)requestProductData:(NSString *)productID&#123;</span><br><span class="line">    NSArray * product = [[NSArray alloc] initWithObjects:productID,nil];</span><br><span class="line">    NSSet * nsset = [NSSet setWithArray:product];</span><br><span class="line">    _request = [[SKProductsRequest alloc]initWithProductIdentifiers:nsset];</span><br><span class="line">    _request.delegate = self;</span><br><span class="line">    [_request start];</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark -收到产品返回信息</span><br><span class="line">- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;-------------请求对应的产品信息----------------&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [MBProgressHUDExt showProgressLoading:@&quot;&quot; inView:kWindow];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    NSArray *product = response.products;</span><br><span class="line">    //没有商品</span><br><span class="line">    if (product.count == 0) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [MBProgressHUDExt showMessage:@&quot;没有商品&quot; inView:kWindow afterDelayTime:kHUD_Time];</span><br><span class="line">        &#125;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 验证商品ID</span><br><span class="line">    SKProduct *prod = nil;</span><br><span class="line">    for (SKProduct *pro in product) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, [pro description]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [pro localizedTitle]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [pro localizedDescription]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [pro price]);</span><br><span class="line">        NSLog(@&quot;%@&quot;, [pro productIdentifier]);</span><br><span class="line">        if ([pro.productIdentifier isEqualToString:self.productID]) &#123;</span><br><span class="line">            prod = pro;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 发送购买请求</span><br><span class="line">    if (prod != nil) &#123;</span><br><span class="line">        SKPayment *payment = [SKPayment paymentWithProduct:prod];</span><br><span class="line">        [[SKPaymentQueue defaultQueue]addPayment:payment];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 失败回调</span><br><span class="line">- (void)request:(SKRequest *)request didFailWithError:(NSError *)error&#123;</span><br><span class="line">    //隐藏</span><br><span class="line">    [MBProgressHUDExt hidden];</span><br><span class="line">    //购买失败</span><br><span class="line">    [MBProgressHUDExt showMessage:@&quot;购买失败&quot; inView:kWindow afterDelayTime:kHUD_Time];</span><br><span class="line">&#125;</span><br><span class="line">// 支付后的反馈信息</span><br><span class="line">- (void)requestDidFinish:(SKRequest *)request&#123;</span><br><span class="line">    FJYDLog(@&quot;反馈信息结束&quot;);</span><br><span class="line">    //隐藏</span><br><span class="line">    [MBProgressHUDExt hidden];</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark -SKPaymentTransactionObserver(</span><br><span class="line">//监听购买队列的变化,购买队列状态变化，判断购买状态是否成功（只有在重新启动中才能再次执行）</span><br><span class="line">- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray&lt;SKPaymentTransaction *&gt; *)transactions&#123;</span><br><span class="line">    //处理结果</span><br><span class="line">    for (SKPaymentTransaction * transaction in transactions) &#123;</span><br><span class="line">        NSLog(@&quot;队列状态变化 %@&quot;,transaction);</span><br><span class="line">        // 小票状态</span><br><span class="line">        switch (transaction.transactionState) &#123;</span><br><span class="line">            // 购买完成</span><br><span class="line">            case SKPaymentTransactionStatePurchased:</span><br><span class="line">                &#123;</span><br><span class="line">                    // 订阅特殊处理(自动订阅第二次扣费：自动扣费)</span><br><span class="line">                    if(transaction.originalTransaction)&#123;</span><br><span class="line">                        FJYDLog(@&quot;自动订阅第二次扣费：自动扣费成功&quot;);</span><br><span class="line">                        //购买支付成功后，向自己的服务器发送凭证进行验证</span><br><span class="line">                        [self sendReceiptToServerWithTransaction:transaction];</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 普通购买以及第一次购买</span><br><span class="line">                    else&#123;</span><br><span class="line">                        FJYDLog(@&quot;普通购买(非自动订阅，每次购买都执行)以及第一次购买(自动订阅)&quot;);</span><br><span class="line">                        // 购买支付成功后，向自己的服务器发送凭证进行验证</span><br><span class="line">                        [self sendReceiptToServerWithTransaction:transaction];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            //恢复成功</span><br><span class="line">            case SKPaymentTransactionStateRestored:</span><br><span class="line">            &#123;</span><br><span class="line">                NSLog(@&quot;恢复成功 :%@&quot;, transaction.payment.productIdentifier);</span><br><span class="line">                [MBProgressHUDExt showMessage:@&quot;恢复购买成功&quot; inView:kWindow afterDelayTime:kHUD_Time];</span><br><span class="line">                // 将交易从交易队列中删除</span><br><span class="line">                [[SKPaymentQueue defaultQueue] finishTransaction:transaction];</span><br><span class="line">            &#125;</span><br><span class="line">                break;</span><br><span class="line">            // 交易失败</span><br><span class="line">            case SKPaymentTransactionStateFailed:</span><br><span class="line">            &#123;</span><br><span class="line">                if (transaction.error.code != SKErrorPaymentCancelled) &#123;</span><br><span class="line">                    [MBProgressHUDExt showMessage:@&quot;购买失败&quot; inView:kWindow afterDelayTime:kHUD_Time];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    [MBProgressHUDExt showMessage:@&quot;用户取消交易&quot; inView:kWindow afterDelayTime:kHUD_Time];</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">                // 将交易从交易队列中删除</span><br><span class="line">                [[SKPaymentQueue defaultQueue] finishTransaction:transaction];</span><br><span class="line">            &#125;</span><br><span class="line">                break;</span><br><span class="line">            //商品已经添加进列表</span><br><span class="line">            case SKPaymentTransactionStatePurchasing:</span><br><span class="line">            &#123;</span><br><span class="line">                NSLog(@&quot;商品已经添加进列表&quot;);</span><br><span class="line">                [MBProgressHUDExt showProgressLoading:@&quot;&quot; inView:kWindow];</span><br><span class="line">            &#125;</span><br><span class="line">                break;</span><br><span class="line">            case SKPaymentTransactionStateDeferred:</span><br><span class="line">            &#123;</span><br><span class="line">                NSLog(@&quot;等待确认，儿童模式需要询问家长同意&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark -购买成功后，向服务器发送凭证，并验证凭证</span><br><span class="line">- (void)sendReceiptToServerWithTransaction:(SKPaymentTransaction *)transaction&#123;</span><br><span class="line"></span><br><span class="line">        // 验证凭据，获取到苹果返回的交易凭据</span><br><span class="line">        // appStoreReceiptURL iOS7.0增加的，购买交易完成后，会将凭据存放在该地址</span><br><span class="line">        NSURL * receiptURL = [[NSBundle mainBundle] appStoreReceiptURL];</span><br><span class="line">        // 从沙盒中获取到购买凭据</span><br><span class="line">        NSData * receiptData = [NSData dataWithContentsOfURL:receiptURL];</span><br><span class="line">        // 加密成Base64形式的NSString</span><br><span class="line">        NSString * receiptStr = [receiptData base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];</span><br><span class="line">        //    FJYDLog(@&quot;receiptStr:%@&quot;,receiptStr);</span><br><span class="line">        // 存储凭证和token</span><br><span class="line">        [FJYDReceiptData saveOrderReceiptWithReceipt:receiptStr];</span><br><span class="line">    </span><br><span class="line">        // 如果是在支付页面</span><br><span class="line">        if (self.isBuying == YES) &#123;</span><br><span class="line">            //获取用户信息</span><br><span class="line">            NSString * tokenStr = [kUserDefault objectForKey:kUserToken];</span><br><span class="line">            //加载态</span><br><span class="line">            [MBProgressHUDExt showProgressLoading:@&quot;支付确认中...&quot; inView:kWindow];</span><br><span class="line">            //如果用户信息和凭证均有值</span><br><span class="line">            if (tokenStr.length &gt; 0 &amp;&amp; receiptStr.length &gt; 0) &#123;</span><br><span class="line">                //发送凭证</span><br><span class="line">                [self sendRecwiptToServerWithReceipt:receiptStr Token:tokenStr Transaction:transaction];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果不是在支付页面</span><br><span class="line">        else &#123;</span><br><span class="line">            //获取凭证</span><br><span class="line">            NSMutableArray * receiptArr = [FJYDReceiptData getOrderReceipt];</span><br><span class="line">            // 如果有凭证</span><br><span class="line">            if (receiptArr.count &gt; 0) &#123;</span><br><span class="line">                // 向服务器验证凭证</span><br><span class="line">                for (NSInteger i = 0; i &lt; receiptArr.count; i ++) &#123;</span><br><span class="line">                    NSMutableDictionary * dic = [receiptArr objectAtIndex:i];</span><br><span class="line">                    NSString * tokenStr = [dic objectForKey:@&quot;token&quot;];</span><br><span class="line">                    NSString * receiptStr = [dic objectForKey:@&quot;receipt&quot;];</span><br><span class="line">                    //发送凭证</span><br><span class="line">                    [self sendRecwiptToServerWithReceipt:receiptStr Token:tokenStr Transaction:transaction];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//发送凭证</span><br><span class="line">- (void)sendRecwiptToServerWithReceipt:(NSString *)receipt Token:(NSString *)token Transaction:(SKPaymentTransaction *)transaction&#123;</span><br><span class="line">    </span><br><span class="line">    //发送给服务器凭证</span><br><span class="line">    token = [NSString stringWithFormat:@&quot;authorization%@&quot;,token];</span><br><span class="line">    [FJYDVIPHttps sendAndValidationReceipt:receipt Token:token Succeed:^(FJYDBaseModel * _Nonnull model) &#123;</span><br><span class="line">        //隐藏</span><br><span class="line">        [MBProgressHUDExt hidden];</span><br><span class="line">        //解析</span><br><span class="line">        FJYDBuyReceiptModel * receiptModel = [FJYDBuyReceiptModel mj_objectWithKeyValues:model.data];</span><br><span class="line">        </span><br><span class="line">        //如果请求成功，并返回数据</span><br><span class="line">        if (receiptModel != nil) &#123;</span><br><span class="line">            FJYDLog(@&quot;凭证验证成功&quot;);</span><br><span class="line">            // 从列表中移除当前凭证</span><br><span class="line">            [FJYDReceiptData removeOrderReceiptWithReceipt:receipt];</span><br><span class="line">            // 如果将交易从交易队列中删除</span><br><span class="line">            [[SKPaymentQueue defaultQueue] finishTransaction:transaction];</span><br><span class="line">            // 在支付页面需要跳转支付成功页面</span><br><span class="line">            if (self.isBuying == YES) &#123;</span><br><span class="line">                //验证结束上传地理位置的回调</span><br><span class="line">                if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(FJYDIAPToolVerificationEndPostLocationWithRectiptModel:)]) &#123;</span><br><span class="line">                    [self.delegate FJYDIAPToolVerificationEndPostLocationWithRectiptModel:receiptModel];</span><br><span class="line">                &#125;</span><br><span class="line">                // 购买成功并验证凭证成功的回调</span><br><span class="line">                if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(FJYDIAPToolBuyProductSucceedWithInfoReceiptModel:)]) &#123;</span><br><span class="line">                    [self.delegate FJYDIAPToolBuyProductSucceedWithInfoReceiptModel:receiptModel];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果请求成功，但是返回数据失败</span><br><span class="line">        else &#123;</span><br><span class="line">            FJYDLog(@&quot;凭证验证失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; Failure:^(NSError * _Nonnull error) &#123;</span><br><span class="line">        [MBProgressHUDExt hidden];</span><br><span class="line">        FJYDLog(@&quot;凭证验证失败&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">#pragma mark -恢复商品</span><br><span class="line">- (void)restorePurchase&#123;</span><br><span class="line">    // 恢复已经完成的所有交易.（仅限永久有效商品）</span><br><span class="line">    [[SKPaymentQueue defaultQueue] restoreCompletedTransactions];</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark -dealloc</span><br><span class="line">-(void)dealloc&#123;</span><br><span class="line">    // 解除监听</span><br><span class="line">    [[SKPaymentQueue defaultQueue] removeTransactionObserver:self];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="自动续期订阅"><a href="#自动续期订阅" class="headerlink" title="自动续期订阅"></a>自动续期订阅</h1><p>自动续期订阅需要增加一个参数 <code>password</code>，<code>秘钥</code> 在APP内购买项目处创建。服务器提供URL用以接收苹果服务器通知，包含订阅状态变更或App内购买项目退款等。</p><h1 id="丢单及其他问题处理"><a href="#丢单及其他问题处理" class="headerlink" title="丢单及其他问题处理"></a>丢单及其他问题处理</h1><ul><li>IAP的支付流程：</li></ul><p>1、发起支付</p><p>2、扣费成功</p><p>3、得到receipt（支付凭据）</p><p>4、去后台验证凭据获取商品交易状态</p><p>5、返回数据，验证成功前端刷新数据</p><ul><li><p>漏单情况一：2到3环节出问题属于苹果的问题，目前没做处理。</p></li><li><p>漏单情况二：3到4的时候出问题，比如断网。此时 <code>移动端</code> 会把支付凭据 <code>持久化存储</code> 下来，如果期间用户卸载APP此单在前端就真漏了，如果没有协助，下次重新打开app进入购买页会先判断有无未成功的支付，有就提示用户，用户选择找回，重走4，5流程。这一步看产品需求怎么做，可以让用户自主选择是否恢复未成功的支付也可以前端默默恢复就行。</p></li><li><p>漏单情况三：4到5的时候出问题。此时后台其实已经成功，只是 <code>移动端</code> 没获取到数据，当漏单处理，下次进入的时候先刷新数据即可。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;iOS 内购分为四种商品类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;消耗品&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非消耗品&lt;/p&gt;
&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习28：正向传值/反向传值和无相传值</title>
    <link href="https://www.bboyzj.cn/2023/03/31/Swift/Swift%E5%AD%A6%E4%B9%A028%EF%BC%9A%E6%AD%A3%E5%90%91%E4%BC%A0%E5%80%BC:%E5%8F%8D%E5%90%91%E4%BC%A0%E5%80%BC%E5%92%8C%E6%97%A0%E7%9B%B8%E4%BC%A0%E5%80%BC/"/>
    <id>https://www.bboyzj.cn/2023/03/31/Swift/Swift%E5%AD%A6%E4%B9%A028%EF%BC%9A%E6%AD%A3%E5%90%91%E4%BC%A0%E5%80%BC:%E5%8F%8D%E5%90%91%E4%BC%A0%E5%80%BC%E5%92%8C%E6%97%A0%E7%9B%B8%E4%BC%A0%E5%80%BC/</id>
    <published>2023-03-31T00:03:04.000Z</published>
    <updated>2023-04-03T07:03:19.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文章主要介绍如何在 <code>VC</code> 之间进行 <code>正向传值、反向传值</code></p><h1 id="正向传值"><a href="#正向传值" class="headerlink" title="正向传值"></a>正向传值</h1><ul><li>ViewController</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个属性并初始化</span><br><span class="line">let nextVC: NextViewController = NextViewController()</span><br><span class="line"></span><br><span class="line">// 正向传值</span><br><span class="line">nextVC.name = &quot;张建&quot;;</span><br><span class="line">self.present(nextVC, animated: true)</span><br></pre></td></tr></table></figure></div><ul><li>NextViewController</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 正向传值，接收方</span><br><span class="line">var name: String?</span><br></pre></td></tr></table></figure></div><h1 id="反向传值"><a href="#反向传值" class="headerlink" title="反向传值"></a>反向传值</h1><p>反向传值的方式有以下几种：<code>delegate、闭包、KVO</code> 和 <code>NOtification</code> 四种方式</p><ol><li>delegate</li></ol><p><code>delegate</code> 只能 <code>一对一</code>。</p><ul><li>定义一个协议 并 定义一个方法</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 定义协议</span><br><span class="line">protocol NextDelegate &#123;</span><br><span class="line">    // 定义一个方法 返回年龄</span><br><span class="line">    func clickBtn(age: Int) -&gt; Void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>定义代理</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 定义delegate</span><br><span class="line">var delegate: NextDelegate?</span><br></pre></td></tr></table></figure></div><ul><li>添加触发条件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 点击按钮的事件</span><br><span class="line">@objc func clickBtn(sender: UIButton) &#123;</span><br><span class="line">    // 代理回传数据</span><br><span class="line">    delegate?.clickBtn(age: 32)</span><br><span class="line">    </span><br><span class="line">    self.dismiss(animated: true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>遵守协议，并设置代理</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 遵循协议</span><br><span class="line">class ViewController: UIViewController,NextDelegate</span><br><span class="line"></span><br><span class="line">// 设置代理</span><br><span class="line">nextVC.delegate = self</span><br></pre></td></tr></table></figure></div><ul><li>实现协议的方法，打印回传的数据</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 实现代理回调方法</span><br><span class="line">func clickBtn(age: Int) &#123;</span><br><span class="line">    print(age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="2"><li>闭包</li></ol><ul><li>定义一个闭包</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个闭包</span><br><span class="line">var passBlockValue:((_ sex:String) -&gt; Void)?</span><br></pre></td></tr></table></figure></div><ul><li>闭包回传数据</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 闭包回传数据</span><br><span class="line">passBlockValue!(&quot;男&quot;)</span><br></pre></td></tr></table></figure></div><ul><li>接收闭包回传的数据</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 接收block传值</span><br><span class="line">nextVC.passBlockValue = &#123; value in</span><br><span class="line">    print(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="3"><li>KVO</li></ol><p><code>KVO</code> 可以用来监听 <code>自定义类</code> 里面的属性，这个类需要继承 <code>NSObject</code> 并 <code>dynamic</code> 修饰，例如：我们创建一个 <code>Person</code> 类，监听属性 <code>name</code></p><ul><li>创建 <code>Person</code> 类型，并定义一个属性 <code>name</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Person: NSObject &#123;</span><br><span class="line">    // dynamic修饰可支持KVO</span><br><span class="line">    @objc dynamic var name: String = &quot;张三&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>全局 Person</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个全局的person</span><br><span class="line">let p: Person = Person()</span><br></pre></td></tr></table></figure></div><ul><li>添加监听</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 添加监听</span><br><span class="line">p.addObserver(self, forKeyPath: &quot;name&quot;,options: [.old,.new], context: nil)</span><br></pre></td></tr></table></figure></div><ul><li>改变name</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 改变person的属性name</span><br><span class="line">p.name = &quot;李四&quot;</span><br></pre></td></tr></table></figure></div><ul><li>接收监听</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 监听对象属性发送变化，自动调用该函数</span><br><span class="line">override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) &#123;</span><br><span class="line">    let oldName = change![NSKeyValueChangeKey.oldKey]</span><br><span class="line">    if let oldName = oldName &#123;</span><br><span class="line">        print(oldName)</span><br><span class="line">        // 张三</span><br><span class="line">    &#125;</span><br><span class="line">    let newName = change![NSKeyValueChangeKey.newKey]</span><br><span class="line">    if let newName = newName &#123;</span><br><span class="line">        print(newName)</span><br><span class="line">        // 李四</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>移除监听</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 析构函数</span><br><span class="line">deinit &#123;</span><br><span class="line">    // 移除监听：add和remove必须成对出现，否则报错</span><br><span class="line">    p.removeObserver(self, forKeyPath: &quot;name&quot;, context: nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="4"><li>NOtification</li></ol><p><code>通知</code> 是可以 <code>一对多的</code>，通常用于不相邻两个页面之间的 <code>传值</code></p><ul><li>初始化通知Notification</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 发送通知</span><br><span class="line">// 发送简单的数据</span><br><span class="line">// NotificationCenter.default.post(name: NSNotification.Name(rawValue:&quot;SimpleNotification&quot;), object: &quot;hello&quot;)</span><br><span class="line">// 发送复杂的数据</span><br><span class="line">let userInfo = [&quot;name&quot;:&quot;ZJ&quot;,&quot;age&quot;:32] as [String:Any]</span><br><span class="line">NotificationCenter.default.post(name: NSNotification.Name(rawValue:&quot;ComplexNotification&quot;), object: nil,userInfo: userInfo)</span><br></pre></td></tr></table></figure></div><ul><li>接收通知</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 接收通知</span><br><span class="line">NotificationCenter.default.addObserver(self, selector: #selector(handleNotification(noti:)), name: NSNotification.Name(rawValue:&quot;ComplexNotification&quot;), object: nil)</span><br></pre></td></tr></table></figure></div><ul><li>接收到通知执行的操作</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 接收到通知</span><br><span class="line">@objc func handleNotification(noti:NSNotification)  &#123;</span><br><span class="line">    print(noti.userInfo as Any)</span><br><span class="line">    print(noti.userInfo![&quot;name&quot;] as! String)</span><br><span class="line">    print(noti.userInfo![&quot;age&quot;] as! Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">Optional([AnyHashable(&quot;name&quot;): &quot;ZJ&quot;, AnyHashable(&quot;age&quot;): 32])</span><br><span class="line">ZJ</span><br><span class="line">32</span><br></pre></td></tr></table></figure></div><ul><li>移除通知</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line">    NotificationCenter.default.removeObserver(self)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="无相传值"><a href="#无相传值" class="headerlink" title="无相传值"></a>无相传值</h1><p><code>无相传值</code> 就是利用 <code>NSUserFefaults</code> 来存取数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文章主要介绍如何在 &lt;code&gt;VC&lt;/code&gt; 之间进行 &lt;code&gt;正向传值、反向传值&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;正向传</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Flutter学习06：Dart集合类型List、Set、Map及循环语句</title>
    <link href="https://www.bboyzj.cn/2023/03/31/Flutter%E5%AD%A6%E4%B9%A0/Flutter%E5%AD%A6%E4%B9%A006%EF%BC%9ADart%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8BList%E3%80%81Set%E3%80%81Map%E5%8F%8A%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
    <id>https://www.bboyzj.cn/2023/03/31/Flutter%E5%AD%A6%E4%B9%A0/Flutter%E5%AD%A6%E4%B9%A006%EF%BC%9ADart%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8BList%E3%80%81Set%E3%80%81Map%E5%8F%8A%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</id>
    <published>2023-03-30T16:53:20.000Z</published>
    <updated>2023-03-30T18:08:09.625Z</updated>
    
    
    
    
    <category term="Flutter-学习篇" scheme="https://www.bboyzj.cn/categories/Flutter-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
    
    <category term="Flutter" scheme="https://www.bboyzj.cn/tags/Flutter/"/>
    
  </entry>
  
</feed>
