<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张建的博客</title>
  <icon>https://www.gravatar.com/avatar/134cc2bfaf649e446f661778f4112fca</icon>
  <subtitle>成功的道路上只有荆棘，没有坦途</subtitle>
  <link href="https://www.bboyzj.cn/atom.xml" rel="self"/>
  
  <link href="https://www.bboyzj.cn/"/>
  <updated>2023-03-06T10:31:26.073Z</updated>
  <id>https://www.bboyzj.cn/</id>
  
  <author>
    <name>小J</name>
    <email>13718004742@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OC学习04：JSON和XML数据解析</title>
    <link href="https://www.bboyzj.cn/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A004%EF%BC%9AJSON%E5%92%8CXML%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.bboyzj.cn/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A004%EF%BC%9AJSON%E5%92%8CXML%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/</id>
    <published>2023-03-06T06:09:53.000Z</published>
    <updated>2023-03-06T10:31:26.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>在 <code>iOS</code> 开发中，常见的数据传输格式有两种：<code>JSON和XML</code>。</p></li><li><p>服务器返回客户端的数据，一般都是 <code>JSON格式或XML格式（文件下载除外）</code></p></li><li><p><code>JSON</code> 由于体积小、传输快速等优点，逐渐成为了 <code>主流的数据传输格式</code>。</p></li></ul><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>在 iOS 中，常见解析方案有以下几种：</p><ul><li><p>第三方框架：JSONKit、SBJson、TouchJSON（性能从左到右，越来越差）</p></li><li><p>性能最好的是使用苹果原生的框架： <code>NSJSONSerialization</code></p></li><li><p>JSON格式很想OC中的数组和字典，key必须用双引号</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:22&#125;、[&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:22&#125;,&#123;&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:22&#125;]</span><br></pre></td></tr></table></figure><h2 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h2><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061810849.png"></p><h2 id="JSON-转-OC"><a href="#JSON-转-OC" class="headerlink" title="JSON 转 OC"></a>JSON 转 OC</h2><ul><li>第一个参数：要解析的JSON数据，是NSData类型也就是二进制数据</li><li>第二个参数：解析JSON的可选配置参数<ul><li>NSJSONReadingMutableContainers 解析出来的字典和数组是可变的</li><li>NSJSONReadingFragmentsAllowed 解析出来的对象中的字符串是可变的</li><li>NSJSONReadingMutableLeaves 被解析的数据如果既不是字典也不是数组，那么就使用这个</li></ul></li><li>第三个参数：错误信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary * dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&amp;error];</span><br></pre></td></tr></table></figure><h2 id="OC-转-JSON"><a href="#OC-转-JSON" class="headerlink" title="OC 转 JSON"></a>OC 转 JSON</h2><ul><li>第一个参数：要转换成JSON数据的OC对象，这里是一个字典</li><li>第二个参数：NSJSONWritingPrettyPrinted 对转换之后的JSON对象进行排版，无意义</li><li>第三个参数：错误信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSData *data = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;error];</span><br></pre></td></tr></table></figure><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><ul><li>XML 可扩展标记语言，是一种数据交互格式，也叫XML文档</li><li>XML 被设计用来传输和存储数据</li></ul><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>常见的XML文档由三部分组成</p><ul><li>文档声明</li></ul><p>在XML文档最前面，必须编写一个文档声明，用来声明XML文档的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 最简单的声明</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line"></span><br><span class="line">// 用encoding属性说明文档的字符编码</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br></pre></td></tr></table></figure><ul><li><p>元素</p><ul><li>一个元素包括了 <code>开始标签和结束标签</code>，</li><li>有内容的元素 <code>&lt;name&gt;Tom&lt;/name&gt;</code>；没内容的元素 <code>&lt;from&gt;&lt;/from&gt;</code>，可简写成 <code>&lt;from/&gt;</code></li><li>元素可嵌套其他元素，不可出现交叉嵌套</li></ul></li><li><p>属性</p></li></ul><p>一个元素最多可以拥有多个属性，属性值必须用双引号 <code>&quot; &quot;</code> 或 单引号 <code>&#39; &#39;</code> 括住</p><ul><li>示例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line">    &lt;person id=&quot;p1&quot;&gt;</span><br><span class="line">        &lt;name&gt;Tom&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;24&lt;/age&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><h2 id="XML-解析的方法"><a href="#XML-解析的方法" class="headerlink" title="XML 解析的方法"></a>XML 解析的方法</h2><p>要想从XML中提取信息，就得解析XML，目前针对XML的解析有两种方式：</p><ul><li>SAX：从根元素开始，按照顺序一个元素一个元素的往下解析，可用于解析大、小文件</li><li>DOM：一次性将整个XML文档加载到内存中，适合较小的文件</li></ul><p><code>iOS</code> 中解析 <code>XML</code> 有两种：</p><ul><li><p>苹果原生：使用 <code>NSXMLParse</code>，SAX方式解析，使用简答</p></li><li><p>第三方框架：<code>libxml2、GDataXML</code></p><ul><li><code>libxml2</code> 纯 c 语音，默认包含在iOS SDK中，同时支持DOM和SAX方式解析</li><li><code>GDataXMLDOM</code> 解析，由 <code>google</code> 基于 <code>libxml2</code> 开发</li></ul></li></ul><p>解析XML大文件建议用：<code>NSXMLParse、libxml2</code><br>解析XML小文件上述三种都可以</p><h2 id="NSXMLParse-使用"><a href="#NSXMLParse-使用" class="headerlink" title="NSXMLParse 使用"></a>NSXMLParse 使用</h2><ul><li><p>添加NSXMLParserDelegate协议</p></li><li><p>获取XML文件，初始化NSXMLParser，并开启解析</p></li><li><p>实现协议中的方法</p></li></ul><p><strong>XMLElement 文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@interface XMLElement : NSObject</span><br><span class="line">// 元素名称</span><br><span class="line">@property (nonatomic,strong)NSString *name;</span><br><span class="line">//元素节点文本</span><br><span class="line">@property (nonatomic,strong)NSMutableString *text;</span><br><span class="line">@property (nonatomic,strong)NSDictionary *attribute;</span><br><span class="line">@property (nonatomic,strong)XMLElement *parent;</span><br><span class="line">@property (nonatomic,strong)NSMutableArray&lt;XMLElement *&gt; *childElement;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">🔽</span><br><span class="line"></span><br><span class="line">#import &quot;XMLElement.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation XMLElement</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _text=[[NSMutableString alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (NSMutableArray&lt;XMLElement *&gt; *)childElement&#123;</span><br><span class="line">    if (!_childElement) &#123;</span><br><span class="line">        _childElement = [[NSMutableArray alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    return _childElement;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)description&#123;</span><br><span class="line">    NSDictionary *dic = [self convertToDic];</span><br><span class="line">    if ([NSJSONSerialization isValidJSONObject:dic]) &#123;</span><br><span class="line">        NSError *error;</span><br><span class="line">        NSData *jsonData=[NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;error];</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            return @&quot;&#123;&#125;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (jsonData) &#123;</span><br><span class="line">            @try &#123;</span><br><span class="line">                NSString *jsonStr = [[NSString alloc]initWithData:jsonData encoding:NSUTF8StringEncoding];</span><br><span class="line">                return jsonStr;</span><br><span class="line">            &#125; @catch (NSException *exception) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return @&quot;&#123;&#125;&quot;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">- (NSDictionary *)convertToDic&#123;</span><br><span class="line">    NSMutableDictionary *dic = [[NSMutableDictionary alloc] init];</span><br><span class="line">    if (self.name) &#123;</span><br><span class="line">        dic[self.name]=self.text;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.attribute &amp;&amp; self.attribute.count &gt; 0) &#123;</span><br><span class="line">        [dic addEntriesFromDictionary:self.attribute];</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.childElement &amp;&amp; self.childElement.count &gt; 0) &#123;</span><br><span class="line">        NSMutableArray *child=[[NSMutableArray alloc]init];</span><br><span class="line">        for (XMLElement *element in self.childElement) &#123;</span><br><span class="line">            NSDictionary *childDic = [element convertToDic];</span><br><span class="line">            if (element.childElement &amp;&amp; element.childElement.count &gt; 0) &#123;</span><br><span class="line">                [child addObject:childDic];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                [dic addEntriesFromDictionary:childDic];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (child.count &gt; 0) &#123;</span><br><span class="line">            dic[@&quot;child&quot;]=child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dic;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong>XMLParserManager 文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;XMLElement.h&quot;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">typedef void(^ParserXMLCompletion) (BOOL success, XMLElement * _Nullable data,NSError * _Nullable error);</span><br><span class="line">@interface XMLParserManager : NSObject</span><br><span class="line">@property(nonatomic,copy)ParserXMLCompletion completion;</span><br><span class="line">- (void)parserXMLWithUrl:(NSURL *)url completion:(ParserXMLCompletion)completion;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">🔽</span><br><span class="line"></span><br><span class="line">#import &quot;XMLParserManager.h&quot;</span><br><span class="line"></span><br><span class="line">@interface XMLParserManager()&lt;NSXMLParserDelegate&gt;</span><br><span class="line">@property (nonatomic,strong)NSXMLParser *parser;</span><br><span class="line">@property (nonatomic,strong)XMLElement *rootElement;</span><br><span class="line">@property (nonatomic,strong)XMLElement *currentElement;</span><br><span class="line">@end</span><br><span class="line">@implementation XMLParserManager</span><br><span class="line">- (void)parserXMLWithUrl:(NSURL *)url completion:(ParserXMLCompletion)completion&#123;</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        self.completion = completion;</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        NSInputStream *fileInput=[[NSInputStream alloc] initWithURL:url];</span><br><span class="line">        // 创建一个解析器</span><br><span class="line">        _parser = [[NSXMLParser alloc] initWithStream:fileInput];</span><br><span class="line">        // 设置代理</span><br><span class="line">        _parser.delegate = self;</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^&#123;</span><br><span class="line">            __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">            // 开始解析</span><br><span class="line">            [strongSelf.parser parse];</span><br><span class="line">            // 解析错误</span><br><span class="line">            if (weakSelf.parser.parserError) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    if (completion) &#123;</span><br><span class="line">                        completion(NO,nil,strongSelf.parser.parserError);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 文档开始</span><br><span class="line">-(void)parserDidStartDocument:(NSXMLParser *)parser&#123;</span><br><span class="line">    self.rootElement = nil;</span><br><span class="line">    self.currentElement = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 开始解析某个节点</span><br><span class="line"> parser xml对象</span><br><span class="line"> elementName 标签</span><br><span class="line"> namespaceURI 命名控件指向的链接</span><br><span class="line"> qName 命名控件名称</span><br><span class="line"> attributeDict 节点的所有属性</span><br><span class="line"> */</span><br><span class="line">-(void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary&lt;NSString *,NSString *&gt; *)attributeDict&#123;</span><br><span class="line"></span><br><span class="line">    if (!self.rootElement) &#123;</span><br><span class="line">        self.rootElement = [[XMLElement alloc]init];</span><br><span class="line">        self.currentElement = self.rootElement;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        XMLElement *element = [[XMLElement alloc]init];</span><br><span class="line">        // 父节点</span><br><span class="line">        element.parent = self.currentElement;</span><br><span class="line">        // 当前元素的子节点</span><br><span class="line">        [self.currentElement.childElement addObject:element];</span><br><span class="line">        element.name = elementName;</span><br><span class="line">        // 更换当前元素</span><br><span class="line">        self.currentElement = element;</span><br><span class="line">    &#125;</span><br><span class="line">    // 元素名和属性</span><br><span class="line">    self.currentElement.name = elementName;</span><br><span class="line">    self.currentElement.attribute = attributeDict;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当解析器找到开始标记和结束标记之间的字符时，调用这个方法解析当前节点的所有字符</span><br><span class="line">- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string&#123;</span><br><span class="line">    // 获取当前元素的内容</span><br><span class="line">    [self.currentElement.text appendString:string];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结束解析</span><br><span class="line">-(void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName&#123;</span><br><span class="line">    self.currentElement = self.currentElement.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文档结束</span><br><span class="line">-(void)parserDidEndDocument:(NSXMLParser *)parser&#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    if (self &amp;&amp; self.completion) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">            strongSelf.completion(YES, strongSelf.rootElement, nil);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解析失败</span><br><span class="line">- (void)parser:(NSXMLParser *)parser validationErrorOccurred:(NSError *)validationError&#123;</span><br><span class="line">    if (self.completion) &#123;</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">            strongSelf.completion(NO, nil,validationError);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong>VC 调用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;XMLParserManager.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,strong)XMLParserManager *manager;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    [self parserXML];</span><br><span class="line">&#125;</span><br><span class="line">-(void)parserXML&#123;</span><br><span class="line">    NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;xmlText&quot; ofType:@&quot;xml&quot;];</span><br><span class="line">    NSURL *url = [NSURL fileURLWithPath:path];</span><br><span class="line">    _manager=[[XMLParserManager alloc]init];</span><br><span class="line">    [_manager parserXMLWithUrl:url completion:^(BOOL success, XMLElement * _Nullable data, NSError * _Nullable error) &#123;</span><br><span class="line">            if (success) &#123;</span><br><span class="line">                NSLog(@&quot;%@&quot;,data);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                NSLog(@&quot;error = %@&quot;,error);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    NSLog(@&quot;start == &quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="GDataXML-使用"><a href="#GDataXML-使用" class="headerlink" title="GDataXML 使用"></a>GDataXML 使用</h2><ul><li>GDataXMLDocument：xml解析入口</li><li>GdataXMLElement：保存查找的数据</li><li>GdataXMLNode：保存解析的数据</li></ul><p><strong>第一步：集成 GDataXML-HTML</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target &#x27;XML文件解析&#x27; do</span><br><span class="line">  # Comment the next line if you don&#x27;t want to use dynamic frameworks</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  pod &#x27;GDataXML-HTML&#x27;, &#x27;~&gt; 1.4.1&#x27;</span><br><span class="line"></span><br><span class="line">  # Pods for XML文件解析</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>第二步：项目中配置</strong></p><ul><li><p>pod 安装 GDataXML</p></li><li><p>选中target -&gt; Build Settings -&gt; Link Binary With Libraried，搜索添加 <code>libxml2</code></p></li><li><p>Header Search Paths 添加 <code>/usr/include/libxml2</code> </p></li><li><p>Other Linker Flags 添加 <code>-lxml2</code></p></li><li><p>引入头文件使用</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在 &lt;code&gt;iOS&lt;/code&gt; 开发中，常见的数据传输格式有两种：&lt;code&gt;JSON和XML&lt;/code&gt;。&lt;/p</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习40：类&amp;结构体&amp;枚举：下标和下标重载</title>
    <link href="https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A040%EF%BC%9A%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE%EF%BC%9A%E4%B8%8B%E6%A0%87%E5%92%8C%E4%B8%8B%E6%A0%87%E9%87%8D%E8%BD%BD/"/>
    <id>https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A040%EF%BC%9A%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE%EF%BC%9A%E4%B8%8B%E6%A0%87%E5%92%8C%E4%B8%8B%E6%A0%87%E9%87%8D%E8%BD%BD/</id>
    <published>2023-03-05T12:28:10.000Z</published>
    <updated>2023-03-05T13:05:24.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h1><ul><li><p>类、结构体和枚举可以定义 <code>下标</code>，它可以作为访问集合、列表或序列号成员元素的快捷方式。你可以使用下标通过索引值来设置或检索值而不需要为设置和检索分别使用实例方法</p></li><li><p>你可以为一个类型定义多个下标，并且下标会基于传入的索引值的类型选择合适的下标重载使用。下标没有限制单个维度，你可以使用多个输入形参来定义下标以满足自定义类型的需求</p></li></ul><h1 id="下标语法"><a href="#下标语法" class="headerlink" title="下标语法"></a>下标语法</h1><ul><li>下标脚本允许你通过在实例名后面的方括号内写一个或多个值对该类的实例进行查询。它的语法类似于实例方法和计算属性。使用关键字 subscript 来定义下标，并且指定一个或多个输入形式参数和返回类型，与实例方法一样。与实例方法不同的是，下标可以是读写也可以是只读的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;下标&quot;&gt;&lt;a href=&quot;#下标&quot; class=&quot;headerlink&quot; title=&quot;下标&quot;&gt;&lt;/a&gt;下标&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类、结构体和枚举可以定义 &lt;code&gt;下标&lt;/code&gt;，它可以作为访问集合、列表或序列号成员元素的快捷方式。你可以使用下</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习39：为类&amp;结构体&amp;枚举添加属性和方法</title>
    <link href="https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A039%EF%BC%9A%E4%B8%BA%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <id>https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A039%EF%BC%9A%E4%B8%BA%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/</id>
    <published>2023-03-05T10:25:21.000Z</published>
    <updated>2023-03-05T12:58:00.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为类、结构体、枚举添加-属性"><a href="#为类、结构体、枚举添加-属性" class="headerlink" title="为类、结构体、枚举添加 属性"></a>为类、结构体、枚举添加 属性</h1><h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><ul><li><code>存储属性</code> 是一个作为特定类和结构体实例一部分的 <code>常量或变量</code>。存储属性要么是变量存储属性（由 <code>var</code> 关键字引入），要么是常量存储属性（由 <code>let</code> 关键字引入）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 存储属性</span><br><span class="line">class DataManager &#123;</span><br><span class="line">    // 变量存储属性</span><br><span class="line">    var fileName = &quot;tex&quot;</span><br><span class="line">    // 常量存储属性</span><br><span class="line">    let age = 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量结构体实例的存储属性"><a href="#常量结构体实例的存储属性" class="headerlink" title="常量结构体实例的存储属性"></a>常量结构体实例的存储属性</h2><ul><li>如果你创建了一个 <code>结构体的实例</code> 并且把这个 <code>实例赋值给常量</code>，你 <code>不能修改</code> 这个实例的属性，即使是声明为变量的属性</li></ul><h2 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h2><ul><li><p><code>延迟存储属性的初始值在第一次使用时才进行计算</code>。你可以通过在其声明前面标注 <code>lazy 修饰语</code> 来表示一个 <code>延迟存储属性</code></p></li><li><p>如果被标记为 <code>lazy</code> 修饰符的属性同时被多个线程访问并且属性还没有被初始化，则无法保证属性只初始化一次。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 存储属性</span><br><span class="line">class DataManager &#123;</span><br><span class="line">    // 延迟存储属性</span><br><span class="line">    lazy var data = [String]()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><ul><li>除了存储属性，<code>类、结构体、枚举</code> 还能定义 <code>计算属性</code>，而它实际并不是存储值。相反，它提供一个读取器和一个可选的设置器来间接得到和设置其它的属性和值。类似于 <code>OC</code> 的 <code>set/get</code> 方法去设值和取值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 计算属性</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Size &#123;</span><br><span class="line">    var width = 0.0,height = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Rect &#123;</span><br><span class="line">    // 存储属性</span><br><span class="line">    var origin = Point()</span><br><span class="line">    var size = Size()</span><br><span class="line">    // 计算属性：可以通过origin 和 size 计算出来</span><br><span class="line">    var center: Point &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            let centerX = origin.x + size.width/2.0</span><br><span class="line">            let centerY = origin.y + size.height/2.0</span><br><span class="line">            return Point(x:centerX, y:centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        set(newCenter) &#123;</span><br><span class="line">            origin.x = newCenter.x - size.width/2.0</span><br><span class="line">            origin.y = newCenter.y - size.height/2.0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="简写-setter"><a href="#简写-setter" class="headerlink" title="简写 setter"></a>简写 setter</h2><ul><li>如果一个计算属性的设置器没有为将要被设置的值定义一个名字，那么它将被默认命名为 <code>newValue</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set &#123;</span><br><span class="line">    origin.x = newValue.x - size.width/2.0</span><br><span class="line">    origin.y = newValue.y - size.height/2.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简写-getter"><a href="#简写-getter" class="headerlink" title="简写 getter"></a>简写 getter</h2><ul><li>如果整个 <code>getter</code> 的函数体是一个单一的表达式，那么 <code>getter</code> 隐士返回这个表达式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 简写 get</span><br><span class="line">get &#123;</span><br><span class="line">    Point(x: origin.x + size.width/2.0,y: origin.y + size.height/2.0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h2><ul><li><p>一个 <code>有读取器</code> 但是 <code>没有设置器</code> 的 <code>计算属性</code> 就是所谓的 <code>只读计算属性</code>。只读计算属性返回一个值，也可以通过点语法访问，但是不能被修改为另一个值</p></li><li><p>你必须用 <code>var关键字</code> 定义计算属性（包括只读计算属性）为变量属性，因为它的值不是固定的。let关键字 只能用于常量属性，用于明确哪些值一旦作为实例初始化就不能更改</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 只读计算属性</span><br><span class="line">struct Rect &#123;</span><br><span class="line">    // 存储属性</span><br><span class="line">    var origin = Point()</span><br><span class="line">    var size = Size()</span><br><span class="line">    // 计算属性：可以通过origin 和 size 计算出来</span><br><span class="line">    var center: Point &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return Point(x: origin.x + size.width/2.0,y: origin.y + size.height/2.0)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性观察者"><a href="#属性观察者" class="headerlink" title="属性观察者"></a>属性观察者</h2><ul><li><p><code>willSet</code> 会在该值被存储之前被调用</p></li><li><p><code>didSet</code> 会在一个新值被存储之后被调用</p></li><li><p>如果你实现了一个 <code>willSet</code> 观察者，新的属性值会以常量形式参数传递。你可以再你的 <code>willSet</code> 实现中为这个参数定义名字。如果你没有为它命名，那么它会使用默认值的名字 <code>newValue</code></p></li><li><p>如果你实现了一个 <code>didSet</code> 观察者，一个包含旧属性值的常量形式参数将会被传递。你可以为它命名，也可以使用默认值的形式参数名 <code>oldValue</code>。如果你在属性自己的 <code>disSet</code> 观察者里给自己赋值，你赋值的新值就会取代刚刚设置的值。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 属性观察者</span><br><span class="line">class StepCounter &#123;</span><br><span class="line">    var totalSteps: Int = 0 &#123;</span><br><span class="line">        willSet(newValue) &#123;</span><br><span class="line">            print(&quot;totalSteps to \(newValue)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            if totalSteps &gt; oldValue &#123;</span><br><span class="line">                print(&quot;add \(totalSteps - oldValue) steps&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let stepCounter = StepCounter()</span><br><span class="line">stepCounter.totalSteps = 100</span><br><span class="line">stepCounter.totalSteps = 200</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">totalSteps to 100</span><br><span class="line">add 100 steps</span><br><span class="line">totalSteps to 200</span><br><span class="line">add 100 steps</span><br></pre></td></tr></table></figure><h2 id="全局和局部变量"><a href="#全局和局部变量" class="headerlink" title="全局和局部变量"></a>全局和局部变量</h2><ul><li><code>观察属性的能力同样对全局变量和局部变量有效</code>。<code>全局变量</code> 是定义在 <code>任何函数、方法、闭包或者类型环境之外的变量</code>。<code>局部变量</code> 是定义在 <code>函数、方法或闭包环境之中的变量</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 全局变量</span><br><span class="line">var count: Int = 0 &#123;</span><br><span class="line">    willSet &#123;</span><br><span class="line">        print(&quot;will set count to \(newValue)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    didSet &#123;</span><br><span class="line">        print(&quot;did change count from \(oldValue) to \(count)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">count = 10</span><br><span class="line"></span><br><span class="line">==============</span><br><span class="line">will set count to 10</span><br><span class="line">did change count from 0 to 10</span><br></pre></td></tr></table></figure><h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><ul><li>使用 <code>static</code> 关键字来定义 <code>类型属性</code>。对于 <code>类</code> 的 <code>类型属性</code>，你可以使用 <code>class</code> 关键字来 <code>允许子类重写父类的实现</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 类型属性</span><br><span class="line">class SomeClass &#123;</span><br><span class="line">    static var storedProperty = &quot;some value&quot;</span><br><span class="line">    static var computedProperty: Int &#123;</span><br><span class="line">        return 27</span><br><span class="line">    &#125;</span><br><span class="line">    // 重写get方法</span><br><span class="line">    class var overrideComputedProperty: Int &#123;</span><br><span class="line">        return 107</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h1 id="为类、结构体、枚举添加-方法"><a href="#为类、结构体、枚举添加-方法" class="headerlink" title="为类、结构体、枚举添加 方法"></a>为类、结构体、枚举添加 方法</h1><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><ul><li><p><code>实例方法</code> 是属于 <code>特定类实例、结构体实例或枚举实例的函数</code>。他们为这些实例提供功能性，要么通过提供访问和修改实例属性的方法，要么通过提供与实例目的相关的功能</p></li><li><p>每一个类的实例都隐含一个叫做 <code>self</code> 的属性，它完全与实例本身相等。你可以用 self 属性在当前实例中调用自身的方法</p></li><li><p>实际上，你不需要经常在代码中写 <code>self</code>。如果你没有显示地写出 <code>self</code>，<code>swift</code> 会在你方法中使用已知属性或方法的时候假定你调用了当前实例中的属性或者方法</p></li><li><p>例外就是当一个实例方法的形式参数名与实例中某个属性拥有相同的名字的时候。在这种情况下，形式参数名具有优先权，并且调用属性的时候使用更加严谨的方式就很有必要了。你可以使用 <code>self</code> 属性来 <code>区分形式参数名和属性名</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    // 实例方法</span><br><span class="line">    func pringInfo() &#123;</span><br><span class="line">        print(&quot;x is \(x),y is \(y)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p = Point(x: 2,y: 2)</span><br><span class="line">p.pringInfo()</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">x is 2.0,y is 2.0</span><br></pre></td></tr></table></figure><h2 id="实例方法-self"><a href="#实例方法-self" class="headerlink" title="实例方法 self"></a>实例方法 self</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    // 实例方法 self</span><br><span class="line">    func isToTheRightOf(x: Double) -&gt; Bool &#123;</span><br><span class="line">        return self.x &gt; x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let somePoint = Point(x: 2.0,y: 3.0)</span><br><span class="line">if somePoint.isToTheRightOf(x: 1.0) &#123;</span><br><span class="line">    print(&quot;the point is x \(somePoint.x)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">the point is x 2.0</span><br></pre></td></tr></table></figure><h2 id="在实例方法中修改属性"><a href="#在实例方法中修改属性" class="headerlink" title="在实例方法中修改属性"></a>在实例方法中修改属性</h2><ul><li><p><code>结构体和枚举是值类型</code>。默认情况下，<code>值类型属性不能被自身的实例方法修改</code></p></li><li><p>你可以选择在 <code>func</code> 关键字前放一个 <code>mutating(异变方法)</code> 关键字来 <code>指定可以修改属性</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 修改属性</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    // 异变方法</span><br><span class="line">    mutating func moveBy(x deltaX: Double,y deltaY: Double) &#123;</span><br><span class="line">        x += deltaX</span><br><span class="line">        y += deltaY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var somePoint = Point(x: 1.0, y: 3.0)</span><br><span class="line">somePoint.moveBy(x: 2.0,y: 2.0)</span><br><span class="line">print(&quot;\(somePoint.x) \(somePoint.y)&quot;)</span><br><span class="line"></span><br><span class="line">===========</span><br><span class="line">3.0 5.0</span><br></pre></td></tr></table></figure><h2 id="在-mutating-方法中赋值给-self"><a href="#在-mutating-方法中赋值给-self" class="headerlink" title="在 mutating 方法中赋值给 self"></a>在 mutating 方法中赋值给 self</h2><ul><li><code>mutating</code> 方法可以指定整个实例给隐含的 <code>self</code> 属性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// self</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    // 异变方法</span><br><span class="line">    mutating func moveBy(x deltaX: Double,y deltaY: Double) &#123;</span><br><span class="line">        self = Point(x:x+deltaX,y:y+deltaY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var somePoint = Point(x: 2.0, y: 4.0)</span><br><span class="line">somePoint.moveBy(x: 2.0,y: 2.0)</span><br><span class="line">print(&quot;\(somePoint.x) \(somePoint.y)&quot;)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">4.0 6.0</span><br></pre></td></tr></table></figure><h2 id="枚举的-mutating-方法"><a href="#枚举的-mutating-方法" class="headerlink" title="枚举的 mutating 方法"></a>枚举的 mutating 方法</h2><ul><li>枚举的 <code>异变方法</code> 可以设置隐含的 <code>self</code> 属性为相同枚举里的不同成员</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 枚举 mutating 方法</span><br><span class="line">enum StateSwitch &#123;</span><br><span class="line">    case off,low,high</span><br><span class="line">    mutating func next() &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .off:</span><br><span class="line">            self = .low</span><br><span class="line">        case .low:</span><br><span class="line">            self = .high</span><br><span class="line">        case .high:</span><br><span class="line">            self = .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var light = StateSwitch.low</span><br><span class="line">light.next()</span><br><span class="line">light.next()</span><br></pre></td></tr></table></figure><h2 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h2><ul><li>通过在 <code>func</code> 关键字前用 <code>static</code> 关键字来明确一个类型方法。类同样可以使用 <code>class关键字</code> 来允许子类重写父类对类型方法的实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 实例方法 self</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    func pringInfo() &#123;</span><br><span class="line">        print(&quot;x is \(x),y is \(y)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 类方法</span><br><span class="line">    static func printTypeInfo() &#123;</span><br><span class="line">        print(&quot;A Point&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p = Point(x: 2,y: 2)</span><br><span class="line">p.pringInfo()</span><br><span class="line">// 类方法用类型调用</span><br><span class="line">Point.printTypeInfo()</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">x is 2.0,y is 2.0</span><br><span class="line">A Point</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为类、结构体、枚举添加-属性&quot;&gt;&lt;a href=&quot;#为类、结构体、枚举添加-属性&quot; class=&quot;headerlink&quot; title=&quot;为类、结构体、枚举添加 属性&quot;&gt;&lt;/a&gt;为类、结构体、枚举添加 属性&lt;/h1&gt;&lt;h2 id=&quot;存储属性&quot;&gt;&lt;a href=&quot;#存</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习37：扩展</title>
    <link href="https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A042%EF%BC%9A%E6%89%A9%E5%B1%95/"/>
    <id>https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A042%EF%BC%9A%E6%89%A9%E5%B1%95/</id>
    <published>2023-03-05T09:05:03.000Z</published>
    <updated>2023-03-05T09:05:03.104Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Swift学习37：协议</title>
    <link href="https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A041%EF%BC%9A%E5%8D%8F%E8%AE%AE/"/>
    <id>https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A041%EF%BC%9A%E5%8D%8F%E8%AE%AE/</id>
    <published>2023-03-05T09:04:54.000Z</published>
    <updated>2023-03-05T09:04:54.483Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Swift学习37：类</title>
    <link href="https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A040%EF%BC%9A%E7%B1%BB/"/>
    <id>https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A040%EF%BC%9A%E7%B1%BB/</id>
    <published>2023-03-05T09:04:46.000Z</published>
    <updated>2023-03-05T09:04:46.898Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Swift学习37：结构体</title>
    <link href="https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A043%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A043%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2023-03-05T09:04:39.000Z</published>
    <updated>2023-03-05T09:04:39.405Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Swift学习38：枚举</title>
    <link href="https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A038%EF%BC%9A%E6%9E%9A%E4%B8%BE/"/>
    <id>https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A038%EF%BC%9A%E6%9E%9A%E4%B8%BE/</id>
    <published>2023-03-05T09:04:28.000Z</published>
    <updated>2023-03-05T10:21:35.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="增强的枚举"><a href="#增强的枚举" class="headerlink" title="增强的枚举"></a>增强的枚举</h1><h2 id="枚举的语法"><a href="#枚举的语法" class="headerlink" title="枚举的语法"></a>枚举的语法</h2><ul><li><p>用 <code>enum</code> 关键字来定义一个枚举，然后将其所有的定义内容放在一个大括号 <code>&#123;&#125;</code> 中</p></li><li><p>多个成员值可以出现在同一行中，用逗号隔开</p></li><li><p>每个枚举都定义了一个全新的类型。正如swift中其它类型那样，它的名称（例如： ComP）需要首字母大写。给枚举类型起一个单数的而不是复数的名字，从而使得他们能够顾名思义</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum ComP &#123;</span><br><span class="line">    case east</span><br><span class="line">    case south</span><br><span class="line">    case west</span><br><span class="line">    case north</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">enum ComP2 &#123;</span><br><span class="line">    case ease, south, west, north</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-Switch-语句来匹配枚举值"><a href="#使用-Switch-语句来匹配枚举值" class="headerlink" title="使用 Switch 语句来匹配枚举值"></a>使用 Switch 语句来匹配枚举值</h2><ul><li>你可以用 <code>switch</code> 语句来匹配每一个单独的枚举值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let directionToHead = ComP.south</span><br><span class="line">switch directionToHead &#123;</span><br><span class="line">case .east:</span><br><span class="line">    print(&quot;east&quot;)</span><br><span class="line">case .south:</span><br><span class="line">    print(&quot;south&quot;)</span><br><span class="line">case .west:</span><br><span class="line">    print(&quot;west&quot;)</span><br><span class="line">case .north:</span><br><span class="line">    print(&quot;north&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">south</span><br></pre></td></tr></table></figure><h2 id="遍历枚举的-case"><a href="#遍历枚举的-case" class="headerlink" title="遍历枚举的 case"></a>遍历枚举的 case</h2><ul><li>枚举也可以被遍历，需要遵守 <code>CaseIterable</code> 协议来 <code>允许枚举被遍历</code>，写法：在枚举名后面写 <code>:CaseIterable</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 遍历枚举</span><br><span class="line">enum ComP : CaseIterable&#123;</span><br><span class="line">    case east</span><br><span class="line">    case south</span><br><span class="line">    case west</span><br><span class="line">    case north</span><br><span class="line">&#125;</span><br><span class="line">for direction in ComP.allCases &#123;</span><br><span class="line">    print(direction)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">east</span><br><span class="line">south</span><br><span class="line">west</span><br><span class="line">north</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 遍历枚举</span><br><span class="line">enum ComP2 : CaseIterable&#123;</span><br><span class="line">    case east, south, west, north</span><br><span class="line">&#125;</span><br><span class="line">print(ComP2.allCases)</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">[__lldb_expr_75.ComP2.east, __lldb_expr_75.ComP2.south, __lldb_expr_75.ComP2.west, __lldb_expr_75.ComP2.north]</span><br></pre></td></tr></table></figure><h2 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h2><ul><li>可以定义swift枚举来存储任意给定类型的关联值，如果需要的话不同枚举成员关联值的类型可以不同</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 关联值</span><br><span class="line">enum Barcde &#123;</span><br><span class="line">    case upc(Int,Int,Int,Int) // 元组</span><br><span class="line">    case qrCode(String) // 元组</span><br><span class="line">&#125;</span><br><span class="line">var productBarcode = Barcde.upc(5,111,33,245)</span><br><span class="line">print(productBarcode)</span><br><span class="line">productBarcode = .qrCode(&quot;aaaaaddddd&quot;)</span><br><span class="line">print(productBarcode)</span><br><span class="line"></span><br><span class="line">==============</span><br><span class="line">upc(5, 111, 33, 245)</span><br><span class="line">qrCode(&quot;aaaaaddddd&quot;)</span><br></pre></td></tr></table></figure><h2 id="关联值绑定"><a href="#关联值绑定" class="headerlink" title="关联值绑定"></a>关联值绑定</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 关联值绑定</span><br><span class="line">switch productBarcode &#123;</span><br><span class="line">case .upc(let a,let b,let c,let d):</span><br><span class="line">    print(&quot;UPC: \(a) \(b) \(c) \(d)&quot;)</span><br><span class="line">case .qrCode(let codeString):</span><br><span class="line">    print(&quot;QR Code: \(codeString)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">QR Code: aaaaaddddd</span><br></pre></td></tr></table></figure><h2 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h2><ul><li>枚举成员可以用相同类型的默认值预先填充（称为<code>原始值</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 原始值</span><br><span class="line">enum carS: Character &#123;</span><br><span class="line">    case tab = &quot;\t&quot;</span><br><span class="line">    case lineFeed = &quot;\n&quot;</span><br><span class="line">    case carrReturn = &quot;\r&quot;</span><br><span class="line">&#125;</span><br><span class="line">let car = carS.tab</span><br><span class="line">print(car.rawValue)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303051804980.png"></p><h2 id="预设原始值"><a href="#预设原始值" class="headerlink" title="预设原始值"></a>预设原始值</h2><ul><li>当你操作存储整数或字符串原始值枚举的时候，你不必显示地给每一个成员都分配一个原始值。当你没有分配时，swift将自动为你分配值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 预设原始值</span><br><span class="line">enum ComP: Int &#123;</span><br><span class="line">    case ease = 4,south,west,north</span><br><span class="line">&#125;</span><br><span class="line">print(ComP.south.rawValue)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="从原始值初始化"><a href="#从原始值初始化" class="headerlink" title="从原始值初始化"></a>从原始值初始化</h2><ul><li>当你用原始值定义了一个枚举，那么枚举就会自动收到一个可以接受原始值类型的初始化器（叫做 <code>rawValue</code> 的形式参数）然后返回一个枚举成员或者 <code>nil</code>。你可以用这个初始化器来尝试创建一个枚举的 新实例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 初始化器</span><br><span class="line">enum ComP: Int &#123;</span><br><span class="line">    case ease = 4,south,west,north</span><br><span class="line">&#125;</span><br><span class="line">let direction = ComP(rawValue: 6)</span><br><span class="line">print(direction)</span><br><span class="line">let direction2 = ComP(rawValue: 8)</span><br><span class="line">print(direction2)</span><br><span class="line">========</span><br><span class="line">Optional(__lldb_expr_82.ComP.west)</span><br><span class="line">nil</span><br></pre></td></tr></table></figure><h2 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h2><ul><li><p><code>递归枚举是拥有另一个枚举作为枚举成员关联值的枚举</code>。当编译器操作递归枚举时必须插入 简介寻址层。你可以在声明枚举成员之前使用 indrect 关键字来明确它是递归的</p></li><li><p>如果说表达式 (5+4)*2 在乘法右侧有一个数但有其他表达式在乘法的左侧</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 递归枚举</span><br><span class="line">indirect enum ArExp &#123;</span><br><span class="line">    case number(Int)</span><br><span class="line">    case add(ArExp,ArExp)</span><br><span class="line">    case mutiply(ArExp,ArExp)</span><br><span class="line">&#125;</span><br><span class="line">let firstExp = ArExp.number(5)</span><br><span class="line">let secondExp = ArExp.number(4)</span><br><span class="line">let addExp = ArExp.add(firstExp,secondExp)</span><br><span class="line">let thirdExp = ArExp.number(2)</span><br><span class="line">let mutipExp = ArExp.mutiply(addExp,thirdExp)</span><br><span class="line">print(mutipExp)</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">mutiply(__lldb_expr_89.ArExp.add(__lldb_expr_89.ArExp.number(5), __lldb_expr_89.ArExp.number(4)), __lldb_expr_89.ArExp.number(2))</span><br></pre></td></tr></table></figure><p>我们可以写一个函数来执行这个表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func eval(_ exp: ArExp) -&gt; Int &#123;</span><br><span class="line">    switch exp &#123;</span><br><span class="line">    case .number(let value):</span><br><span class="line">        return value</span><br><span class="line">    case .add(let first,let second):</span><br><span class="line">        return eval(first) + eval(second)</span><br><span class="line">    case .mutiply(let first,let second):</span><br><span class="line">        return eval(first) * eval(second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(eval(mutipExp))</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">18</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;增强的枚举&quot;&gt;&lt;a href=&quot;#增强的枚举&quot; class=&quot;headerlink&quot; title=&quot;增强的枚举&quot;&gt;&lt;/a&gt;增强的枚举&lt;/h1&gt;&lt;h2 id=&quot;枚举的语法&quot;&gt;&lt;a href=&quot;#枚举的语法&quot; class=&quot;headerlink&quot; title=&quot;枚举的</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习35：如何使用swift中的高阶函数</title>
    <link href="https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A035%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8swift%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>https://www.bboyzj.cn/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A035%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8swift%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</id>
    <published>2023-03-05T06:57:55.000Z</published>
    <updated>2023-03-05T07:27:45.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><ul><li>对于演示集合里的每一个元素，以一个 <code>变换后的元素替换它</code>，形成一个新的集合</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303051527743.png"></p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// map：尾随闭包的形式输出</span><br><span class="line">let nums = [1,2,3,4,5]</span><br><span class="line">print(nums.map &#123; $0 * 10 &#125;)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">[10, 20, 30, 40, 50]</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303051527639.png"></p><h1 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h1><ul><li>对于原始集合里的每一个元素，通过判定来将其丢弃或者放进新集合</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303051527725.png"></p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// filter：尾随闭包的形式输出</span><br><span class="line">let nums = [1,2,3,4,5]</span><br><span class="line">print(nums.filter &#123; $0 &gt; 3 &#125;)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">[4, 5]</span><br></pre></td></tr></table></figure><h1 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h1><ul><li>对于原始集合里的每一个元素，作用于当前累计的结果上</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303051527779.png"></p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// reduce：尾随闭包的形式输出</span><br><span class="line">let nums = [1,2]</span><br><span class="line">print(nums.reduce(10, &#123; $0 + $1 &#125;))</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">13</span><br></pre></td></tr></table></figure><h1 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h1><ul><li>对于元素是集合的集合，可以得到单级的集合</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let results = [[1,2,3],[4,5,6]];</span><br><span class="line">let allResults = results.flatMap&#123; $0.map &#123; $0 &#125; &#125;</span><br><span class="line">let passMarks = results.flatMap&#123; $0.filter &#123; $0 &gt; 5 &#125; &#125;</span><br><span class="line">print(allResults)</span><br><span class="line">print(passMarks)</span><br><span class="line"></span><br><span class="line">===========</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line">[6]</span><br></pre></td></tr></table></figure><h1 id="compactMap"><a href="#compactMap" class="headerlink" title="compactMap"></a>compactMap</h1><ul><li>过滤空值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// compactMap</span><br><span class="line">let keys: [String?] = [&quot;a&quot;,nil,&quot;b&quot;]</span><br><span class="line">let key = keys.map&#123; $0 &#125;</span><br><span class="line">print(key)</span><br><span class="line">let validNames = keys.compactMap&#123; $0 &#125;</span><br><span class="line">print(validNames)</span><br><span class="line">let counts = keys.compactMap&#123; $0?.count &#125;</span><br><span class="line">print(counts)</span><br><span class="line"></span><br><span class="line">==========</span><br><span class="line">[Optional(&quot;a&quot;), nil, Optional(&quot;b&quot;)]</span><br><span class="line">[&quot;a&quot;, &quot;b&quot;]</span><br><span class="line">[1, 1]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;map&quot;&gt;&lt;a href=&quot;#map&quot; class=&quot;headerlink&quot; title=&quot;map&quot;&gt;&lt;/a&gt;map&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;对于演示集合里的每一个元素，以一个 &lt;code&gt;变换后的元素替换它&lt;/code&gt;，形成一个新的集合&lt;/li&gt;
&lt;/ul&gt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>OC组件化06：Github-Desktop管理工具使用</title>
    <link href="https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9606%EF%BC%9AGithub-Desktop%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9606%EF%BC%9AGithub-Desktop%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</id>
    <published>2023-03-04T15:47:00.000Z</published>
    <updated>2023-03-04T15:55:05.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>GitHub Desktop 简单说就是 <code>图形界面</code> 版的 <code>Git</code>，不需要命令行的操作</p><p>通过 <a href="https://desktop.github.com/">GitHub官网</a> 可以下载、安装使用</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li><p>注册你的 <code>GitHub</code> 账号，已注册 <code>GitHub</code> 账号的，跳过</p></li><li><p>在 <code>GitHub Desktop</code> 登录你的账号</p></li></ul><h1 id="创建仓库：File-gt-new-repository"><a href="#创建仓库：File-gt-new-repository" class="headerlink" title="创建仓库：File -&gt; new repository"></a>创建仓库：File -&gt; new repository</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042347662.png"></p><h1 id="创建分支：branch-gt-new-branch"><a href="#创建分支：branch-gt-new-branch" class="headerlink" title="创建分支：branch -&gt; new branch"></a>创建分支：branch -&gt; new branch</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042347152.png"></p><ul><li>创建一个开发的分支 <code>zj_feature</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042348162.png"></p><h1 id="克隆仓库到-GitHub-Desktop"><a href="#克隆仓库到-GitHub-Desktop" class="headerlink" title="克隆仓库到 GitHub Desktop"></a>克隆仓库到 GitHub Desktop</h1><ul><li>File -&gt; Clone Repository</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042348676.png"></p><ul><li>切换分支</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042348034.png"></p><h1 id="修改工程代码，将-0-2-0-版本代码完成，并提交到新分支-zj-feature"><a href="#修改工程代码，将-0-2-0-版本代码完成，并提交到新分支-zj-feature" class="headerlink" title="修改工程代码，将 0.2.0 版本代码完成，并提交到新分支 zj_feature"></a>修改工程代码，将 0.2.0 版本代码完成，并提交到新分支 zj_feature</h1><ul><li><p>Summary：必填 0.2.0</p></li><li><p>Description：描述 0.2.0 版本的内容</p></li><li><p>Commit to zj_feature</p></li><li><p>push origin</p></li></ul><h1 id="合并分支："><a href="#合并分支：" class="headerlink" title="合并分支："></a>合并分支：</h1><ul><li>先切换到 <code>main</code> 主分支</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042348854.png"></p><ul><li>合并分支：branch菜单 -&gt; merge into current branch</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042348376.png"></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042349579.png"></p><h1 id="提交-main-分支"><a href="#提交-main-分支" class="headerlink" title="提交 main 分支"></a>提交 main 分支</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042349550.png"></p><h1 id="删除分支：菜单branch-gt-delete-删除分支"><a href="#删除分支：菜单branch-gt-delete-删除分支" class="headerlink" title="删除分支：菜单branch -&gt; delete 删除分支"></a>删除分支：菜单branch -&gt; delete 删除分支</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042349616.png"></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042350674.png"></p><h1 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h1><ul><li><p>还未提交代码：文件右键 -&gt; <code>Discard Changes</code> 放弃更改</p></li><li><p>已经提交代码：文件右键选择 -&gt; <code>Revert This Commit</code> 恢复到当前提交</p></li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>打开项目代码：Show in Finder</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042351545.png"></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042351468.png"></p><ul><li>所有 <code>新增代码</code> 可以在工程项目中实时修改，并可以运行查看效果</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042351431.png"></p><ul><li>在 GitHub Desktop 上可以看到实时的修改</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042352356.png"></p><ul><li>修改完记得修改一下版本号</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042353544.png"></p><ul><li>提交代码到 <code>本地mian</code> 分支</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042353044.png"></p><ul><li>提交代码到 <code>远程main</code> 分支</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042354437.png"></p><h1 id="终端搜索-ZJWeakProxy-库"><a href="#终端搜索-ZJWeakProxy-库" class="headerlink" title="终端搜索 ZJWeakProxy 库"></a>终端搜索 ZJWeakProxy 库</h1><p><code>mac@bogon ~ % pod search ZJWeakProxy</code></p><p>【问题：】未搜索到自己创建的组件库</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042353662.png"></p><p>解决方法：更新本地Pod的索引文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % rm ~/Library/Caches/CocoaPods/search_index.json</span><br><span class="line">mac@bogon ~ % pod repo update</span><br></pre></td></tr></table></figure><p>如果还是搜索不到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % sudo gem install -n /usr/local/bin cocoapods --pre </span><br><span class="line">mac@bogon ~ % pod setup</span><br></pre></td></tr></table></figure><ul><li>再次搜索</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;GitHub Desktop 简单说就是 &lt;code&gt;图形界面&lt;/code&gt; 版的 &lt;code&gt;Git&lt;/code&gt;，不需要命令行的操作&lt;/</summary>
      
    
    
    
    <category term="Component" scheme="https://www.bboyzj.cn/categories/Component/"/>
    
    
    <category term="组件化开发" scheme="https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>OC组件化05：【方案二】cocoapods组件化</title>
    <link href="https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9605%EF%BC%9A%E3%80%90%E6%96%B9%E6%A1%88%E4%BA%8C%E3%80%91cocoapods%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    <id>https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9605%EF%BC%9A%E3%80%90%E6%96%B9%E6%A1%88%E4%BA%8C%E3%80%91cocoapods%E7%BB%84%E4%BB%B6%E5%8C%96/</id>
    <published>2023-03-04T15:30:55.000Z</published>
    <updated>2023-03-04T15:45:45.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul><li>随着公司业务的不断发展，应用的代码体积将会越来越大，业务代码耦合也越来越多，代码量也是急剧增加</li><li>如果仅仅完成代码拆分还不足以解决业务之间的代码耦合，而组件化是一种能够解决代码耦合、业务工程能够独立运行的技术</li><li>这篇文章主要介绍远程私有库的创建和管理以及本地索引库的使用</li></ul><p>本文以创建 <code>公有库</code> 为例</p><h1 id="查看本地索引库"><a href="#查看本地索引库" class="headerlink" title="查看本地索引库"></a>查看本地索引库</h1><ul><li>我们用 <code>cocoaPods</code> 的时候，默认使用的是cocoaPods自带的索引库<br>终端中使用命令 <code>$ pod repo</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cocoapods</span><br><span class="line">- Type: git (remotes/origin/master)</span><br><span class="line">- URL:  https://github.com/CocoaPods/Specs.git</span><br><span class="line">- Path: /Users/mac/.cocoapods/repos/cocoapods</span><br><span class="line"></span><br><span class="line">trunk</span><br><span class="line">- Type: CDN</span><br><span class="line">- URL:  https://cdn.cocoapods.org/</span><br><span class="line">- Path: /Users/mac/.cocoapods/repos/trunk</span><br><span class="line"></span><br><span class="line">2 repos</span><br></pre></td></tr></table></figure><h1 id="组件化分类"><a href="#组件化分类" class="headerlink" title="组件化分类"></a>组件化分类</h1><ul><li><p>公有库：所有人都能使用</p></li><li><p>私有库：公司内部拥有特殊权限才能使用</p></li><li><p>framework：公私都有，动态库静态库。只能看到.h文件。</p></li></ul><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li><p><code>GitHub</code> 账号一个：上传组件工程用</p></li><li><p>安装 <code>CocoaPods</code>：创建并验证 <code>pod</code> 用</p></li><li><p>安装 <code>Git</code> 命令行 ：首次上传组件工程用</p></li><li><p>安装 <code>Github Desktop</code> 或者 <code>SourceTree</code>：后续更新组件用的，Git命令使用熟练者忽略此项</p></li></ul><h1 id="创建公有库"><a href="#创建公有库" class="headerlink" title="创建公有库"></a>创建公有库</h1><ul><li>首先在 <code>Github</code> 创建一个新的 <code>Repository</code>，你的 <code>pods</code> 最终要托管在 <code>Github</code> 平台上的，所以在 <code>Github</code> 上创建一个空的 <code>Repository</code></li></ul><p>注意：<code>库名 = 项目前缀 + 组件名称 </code> ，如 ZJWeakProxy &#x3D; 解决循环引用组件库</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042335079.png"></p><ul><li>创建完成后的信息如下：</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042335792.png"></p><h1 id="注册-cocoapods-账户"><a href="#注册-cocoapods-账户" class="headerlink" title="注册 cocoapods 账户"></a>注册 cocoapods 账户</h1><ul><li><p>先安装 <code>cocoapods</code>，这个很简单，可以百度搜索自行安装</p></li><li><p>想要创建一个开源 <code>pod</code> 库，首先我们需要注册 <code>cocoapods账户</code>，基于 <code>cocoapods</code> 已经安装好的前提下，这里直接使用 <code>trunk</code> 去注册 <code>cocopods账户</code>，在终端执行：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod trunk register 邮箱地址 &#x27;用户名&#x27; --verbose</span><br><span class="line">mac@bogon ~ % pod trunk register 13718004742@163.com &#x27;BboyZJ&#x27; --verbose</span><br></pre></td></tr></table></figure><p>邮箱地址：一般会使用 GitHub邮箱<br>用户名：随便</p><ul><li>注册之后，在邮箱会受到确认邮件</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042335229.png"></p><ul><li>注册成功之后可以在终端 <code>验证是否注册成功</code>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 验证是否注册成功</span><br><span class="line">mac@bogon ~ % pod trunk me</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>查看注册信息，以后可以使用该开源pod库发布工具，也可以通过此方式查看已经发布过的pods：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % pod trunk me</span><br><span class="line">  - Name:     BboyZJ</span><br><span class="line">  - Email:    13718004742@163.com</span><br><span class="line">  - Since:    October 20th, 2021 19:20</span><br><span class="line">  - Pods:</span><br><span class="line">    - ZJSDKDemo</span><br><span class="line">    - ZJSDK_iOS</span><br><span class="line">  - Sessions:</span><br><span class="line">    - October 20th, 2021 19:20 - March 31st, 2022 04:01. IP: 114.253.15.66 </span><br><span class="line">    Description: imac</span><br><span class="line">    - February 27th, 02:33     -        July 5th, 02:37. IP:</span><br><span class="line">    114.252.233.188</span><br></pre></td></tr></table></figure><h1 id="在本地创建pod库"><a href="#在本地创建pod库" class="headerlink" title="在本地创建pod库"></a>在本地创建pod库</h1><ul><li>利用pod命令创建名为 <code>ZJWeakProxy</code> 的 <code>pod</code> 库</li></ul><p>注：这个名字要和 <code>GitHub</code> 创建的 <code>Repository</code> 名一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cd 到桌面文件夹(组件文件夹)ZJComponent目录下，这个不强制随意</span><br><span class="line">mac@bogon ~ % cd ZJComponent </span><br><span class="line"># 执行 pod lib create ZJWeakProxy</span><br><span class="line">mac@bogon ~ % pod lib create ZJWeakProxy</span><br></pre></td></tr></table></figure><ul><li>出现 fatal: unable to access ‘<a href="https://github.com/CocoaPods/pod-template.git/">https://github.com/CocoaPods/pod-template.git/</a>‘: HTTP&#x2F;2 stream 1 was not closed cleanly before end of the underlying stream 报错</li></ul><p>原因分析：一般这是因为服务器的 <code>SSL</code> 证书没有经过第三方机构的签署，所以才报错</p><p>解决办法：解除 <code>SSL</code> 验证，再次执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ZJComponent % git config --global http.sslVerify false</span><br></pre></td></tr></table></figure><ul><li>执行完上述命令后，会问你几个问题，按需求填写即可</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 你想使用哪个平台？</span><br><span class="line">1、What platform do you want to use?? [ iOS / macOS ]</span><br><span class="line">iOS</span><br><span class="line"># 库语言选择？</span><br><span class="line">2、What language do you want to use?? [ Swift / ObjC ]</span><br><span class="line">ObjC</span><br><span class="line"># 是否需要一个demo工程，用于调试Pod？</span><br><span class="line">3、Would you like include a demo application with your library? [ Yes / No ]</span><br><span class="line">Yes</span><br><span class="line"># 你要使用哪个测试框架？</span><br><span class="line">4、Which testing frameworks will you use? [ Specta / Kiwi / None ]</span><br><span class="line">None</span><br><span class="line"># 是否要UI测试？</span><br><span class="line">5、Would you like to do view based testing? [ Yes / No ]</span><br><span class="line">NO</span><br><span class="line"># 类名前缀？</span><br><span class="line">6、What is your class prefix?</span><br><span class="line">ZJ</span><br></pre></td></tr></table></figure><ul><li>到这里 <code>pod</code> 库就创建完成了，它会自己打开刚才创建的pod库</li></ul><h1 id="工程目录介绍"><a href="#工程目录介绍" class="headerlink" title="工程目录介绍"></a>工程目录介绍</h1><ul><li>目录结构如下：</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042336465.png"></p><p>【第1部分】：主要是用来编辑pod相关配置元数据区<br>【第2部分】：主要是用来验证pod效果区<br>【第3部分】：主要是用来 提供给别人使用暴露出来的pod，ReplaceMe空的可以删除，是提示我们可以添加自己的类</p><ul><li>配置 <code>podspec</code> 本地索引文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  # 库名称</span><br><span class="line">  s.name             = &#x27;ZJWeakProxy&#x27;</span><br><span class="line">  # 版本号</span><br><span class="line">  s.version          = &#x27;0.1.0&#x27;</span><br><span class="line">  # 库简短介绍</span><br><span class="line">  s.summary          = &#x27;A short description of ZJWeakProxy.&#x27;</span><br><span class="line"></span><br><span class="line"># This description is used to generate tags and improve search results.</span><br><span class="line">#   * Think: What does it do? Why did you write it? What is the focus?</span><br><span class="line">#   * Try to keep it short, snappy and to the point.</span><br><span class="line">#   * Write the description between the DESC delimiters below.</span><br><span class="line">#   * Finally, don&#x27;t worry about the indent, CocoaPods strips it!</span><br><span class="line"></span><br><span class="line">  # 开源库描述</span><br><span class="line">  s.description      = &lt;&lt;-DESC</span><br><span class="line">TODO: Add long description of the pod here.</span><br><span class="line">                       DESC</span><br><span class="line">  # 开源库地址，或者是博客、社交地址等</span><br><span class="line">  s.homepage         = &#x27;https://github.com/BboyZJ/ZJWeakProxy&#x27;</span><br><span class="line">  # s.screenshots     = &#x27;www.example.com/screenshots_1&#x27;, &#x27;www.example.com/screenshots_2&#x27;</span><br><span class="line">  # 开源协议</span><br><span class="line">  s.license          = &#123; :type =&gt; &#x27;MIT&#x27;, :file =&gt; &#x27;LICENSE&#x27; &#125;</span><br><span class="line">  # 开源库作者</span><br><span class="line">  s.author           = &#123; &#x27;BboyZJ&#x27; =&gt; &#x27;13718004742@163.com&#x27; &#125;</span><br><span class="line">  # 开源库资源文件</span><br><span class="line">  s.source           = &#123; :git =&gt; &#x27;https://github.com/BBoyZJ/ZJWeakProxy.git&#x27;, :tag =&gt; s.version.to_s &#125;</span><br><span class="line">  # 社交网址</span><br><span class="line">  # s.social_media_url = &#x27;https://twitter.com/&lt;TWITTER_USERNAME&gt;&#x27;</span><br><span class="line">  # 开源库最低支持</span><br><span class="line">  s.ios.deployment_target = &#x27;10.0&#x27;</span><br><span class="line">  # 开源库源文件</span><br><span class="line">  s.source_files = &#x27;ZJWeakProxy/Classes/**/*&#x27;</span><br><span class="line">  # 添加图片等资源文件</span><br><span class="line">  # s.resource_bundles = &#123;</span><br><span class="line">  #   &#x27;ZJWeakProxy&#x27; =&gt; [&#x27;ZJWeakProxy/Assets/*.png&#x27;]</span><br><span class="line">  # &#125;</span><br><span class="line">  </span><br><span class="line">  # s.public_header_files = &#x27;Pod/Classes/**/*.h&#x27;</span><br><span class="line">  # 依赖系统库 多个用逗号隔开</span><br><span class="line">  # s.frameworks = &#x27;UIKit&#x27;, &#x27;MapKit&#x27;</span><br><span class="line">  # 引入第三方依赖库</span><br><span class="line">  # s.dependency &#x27;AFNetworking&#x27;, &#x27;~&gt; 2.3&#x27;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>【s.dependency】：设置依赖三方库或其他组件，多个库可以分开写多次</p><ul><li>需要注意如图：</li></ul><p><img src="/BboyZJ.github.io/assets/16779442070174.jpg"></p><ul><li><code>Readme</code> 主要是介绍这个组件的用途和使用，可以随时编辑。目前就确认一下自己的名字和邮箱就可以了</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042336844.png"></p><ul><li>协议文件，也是确认一下自己的名字和邮箱就可以了</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042337356.png"></p><h1 id="添加自己的类"><a href="#添加自己的类" class="headerlink" title="添加自己的类"></a>添加自己的类</h1><ul><li>打开pod库目录，删除ReplaceMe</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042337055.png"></p><ul><li>创建 <code>ZJWeakProxy</code> 简单类，声明一个打印函数，方便后续测试</li></ul><p><strong>注：创建类文件一定要放到 Classes 目录下</strong></p><p>.h 文件下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJWeakProxy.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ZJWeakProxy : NSProxy</span><br><span class="line">- (void)printZJWeakProxy;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>.m 文件下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJWeakProxy.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZJWeakProxy</span><br><span class="line">- (void)printZJWeakProxy&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042338285.png"></p><ul><li>此时 <code>cd</code> 到 <code>Example</code> 路径下执行 <code>pod install</code> 命令，看看是否能将刚刚添加的库文件引入到工程中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/ZJComponent/ZJWeakProxy/Example </span><br><span class="line">mac@bogon Example % pod install</span><br></pre></td></tr></table></figure><p>如果成功会在Pods中看到：</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042338860.png"></p><ul><li>可以到项目中导入头文件简单使用一下</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042343398.png"></p><p>证明是可用的</p><p>【注】：<code>CocoaPods</code> 工具的另外一个优点就是，多个组件依赖同一个组件时，它会自动帮你检测安装，而 <code>不会重复导入</code>。</p><h1 id="项目上传与发布"><a href="#项目上传与发布" class="headerlink" title="项目上传与发布"></a>项目上传与发布</h1><ul><li>cd到你的项目路径下，将项目上传到GitHub中（即刚刚创建的ZJWeakProxy公有库中），依次使用下列命令行，不要遗漏</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># cd 到 组件ZJWeakProxy路径下</span><br><span class="line">mac@bogon Example % cd /Users/mac/Desktop/ZJComponent/ZJWeakProxy</span><br><span class="line"># 添加github项目路径</span><br><span class="line">mac@bogon ZJWeakProxy % git remote add origin https://github.com/BboyZ/ZJWeakProxy.git</span><br><span class="line"># 添加文件</span><br><span class="line">mac@bogon ZJWeakProxy % git add .</span><br><span class="line"># 将暂存区里的改动提交到本地的版本库</span><br><span class="line">mac@bogon ZJWeakProxy % git commit -m &quot;first commit&quot;</span><br><span class="line"># 创建分支main</span><br><span class="line">mac@bogon ZJWeakProxy % git branch -M main</span><br><span class="line"># 提交版本号并push到main分支</span><br><span class="line">mac@bogon ZJWeakProxy % git push -u origin main</span><br></pre></td></tr></table></figure><ul><li>在执行 <code>git push -u origin main</code> 时，如果遇到需要输入用户名和密码：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Username for &#x27;https://github.com&#x27;: BboyZJ</span><br><span class="line">Password for &#x27;https://BboyZJ@github.com&#x27;:</span><br></pre></td></tr></table></figure><p><strong>【注意】</strong>：这个 <code>密码</code> 不是你 <code>GitHub</code> 的登录密码，而是需要生成一个 <code>access tokens</code></p><ul><li>生成 <code>access token</code></li></ul><p>需要在 <code>GitHub</code> 个人设置页 -&gt; Settings -&gt; Developer Settings -&gt; Personal access tokens 中创建一个 <code>token</code></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042343972.png"></p><ul><li><p>Generate new token 生成新的 <code>token</code></p><ul><li>设置 <code>token</code> 的有效期 按需设置，访问权限等</li></ul><p>  <img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042344432.png"></p><ul><li><p>选择要授予令牌token的范围或权限</p></li><li><p>要使用token从命令行访问仓库，请选择repo</p></li></ul><p>  <img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042344063.png"></p><ul><li>要使用token从命令行删除仓库，请选择delete_repo</li></ul><p> <img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042344513.png"></p><ul><li>其他根据需要进行勾选</li></ul></li><li><p>点击 <code>Generate token</code> 生成 <code>token</code></p></li></ul><p><code>ghp_VcqgAmF...ZPJ2IGxu0</code></p><p>【注】：记得把这个 <code>token</code> 保存下来，因为下次再刷新这个页面的时候，你会看不到了</p><ul><li>在命令行输入完 <code>token</code> 密码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Username for &#x27;https://github.com&#x27;: BboyZJ</span><br><span class="line">Password for &#x27;https://BboyZJ@github.com&#x27;: </span><br><span class="line">Enumerating objects: 91, done.</span><br><span class="line">Counting objects: 100% (91/91), done.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (83/83), done.</span><br><span class="line">Writing objects: 100% (91/91), 29.35 KiB | 2.45 MiB/s, done.</span><br><span class="line">Total 91 (delta 23), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (23/23), done.</span><br><span class="line">To https://github.com/BboyZJ/ZJWeakProxy.git</span><br><span class="line"> * [new branch]      main -&gt; main</span><br><span class="line">branch &#x27;main&#x27; set up to track &#x27;origin/main&#x27;.</span><br></pre></td></tr></table></figure><p>由上面看代表上传成功了</p><ul><li>打开浏览器 <a href="https://github.com/BboyZJ/ZJWeakProxy">https://github.com/BboyZJ/ZJWeakProxy</a> ，就可以看到你的pod库已经push上去了</li></ul><h1 id="打-tag-并发布到-Cocoapods"><a href="#打-tag-并发布到-Cocoapods" class="headerlink" title="打 tag 并发布到 Cocoapods"></a>打 tag 并发布到 Cocoapods</h1><p>至此，我们已经成功将本地的仓库关联并推送到远程仓库，现在我们需要发布一个可用的组件</p><ul><li>首先我们要给当前项目打一个 tag 版本号，在 podspec 中：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.version           = &#x27;0.1.0&#x27;</span><br></pre></td></tr></table></figure><p>指定的版本号是 0.1.0 ，那么我们就同样打个 0.1.0 的 tag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 打 tag </span><br><span class="line">mac@bogon ZJWeakProxy % git tag 0.1.0</span><br><span class="line">// 推送到远程</span><br><span class="line">mac@bogon ZJWeakProxy % git push --tags</span><br></pre></td></tr></table></figure><p>打 <code>tag</code> 默认在当前分支上，这里只有 <code>master</code> ，所以不用切换分支</p><h1 id="发布到-cocoapods"><a href="#发布到-cocoapods" class="headerlink" title="发布到 cocoapods"></a>发布到 cocoapods</h1><ul><li>我们创建的项目以及标签版本号都是沿用了 <code>podspec</code> 文件中的信息，因此可以直接验证 <code>podspec</code> 文件信息是否可以通过验证，<code>podspec</code> 文件的版本号一定要和 <code>tag</code> 保持一致</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ZJWeakProxy % pod spec link</span><br></pre></td></tr></table></figure><p>如果通过验证，那么你会看到类似下面的提示，绿色的 <code>passed validation</code></p><ul><li>首先要通过 <code>trunk</code> 注册生成一条会话：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// pod trunk register 邮箱 用户名 描述</span><br><span class="line">mac@bogon ZJWeakProxy % pod trunk register 13718004742@163.com BboyZJ --description=ZJWeakProxy组件 </span><br></pre></td></tr></table></figure><p>然后去邮箱进行验证，验证成功会出现下面页面：</p><ul><li>现在，就可以将 podspec 提交给 CocoaPods 了。这个文件将是别人搜索你的组件的索引。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ZJWeakProxy % pod trunk push ZJWeakProxy.podspec --allow-warnings</span><br></pre></td></tr></table></figure><ul><li>pod search 组件名</li></ul><p>上传完成之后，接可以通过 pod search ZJWeakProxy 搜索到自己的组件了，如果搜索不到，删除本地的搜索文件，命令 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ZJWeakProxy % rm ~/Library/Caches/CocoaPods/search_index.json</span><br></pre></td></tr></table></figure><p>重新 <code>search</code> 产生新的搜索文件，发布新版本则需要打新的 <code>tag</code>，重新编辑 <code>podspec</code> 文件，然后再次提交给 <code>CocoaPods</code>。</p><h1 id="集成到宿主工程"><a href="#集成到宿主工程" class="headerlink" title="集成到宿主工程"></a>集成到宿主工程</h1><p>经过上面的操作我们已经完成了组件的创建和发布，也支持了 Cocoapods 的集成。现在我们需要将该组件集成到宿主工程中去，使用方式和集成三方库是一样的。</p><ul><li>新建个带 <code>pod</code> 的项目 <code>Demo</code>，把我们做好的 <code>ZJWeakProxy</code> 加入 <code>podfile</code> 文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Uncomment the next line to define a global platform for your project</span><br><span class="line">platform :ios, &#x27;10.0&#x27;</span><br><span class="line"></span><br><span class="line">target &#x27;ZJWeakProxy-Demo&#x27; do</span><br><span class="line">  # Comment the next line if you don&#x27;t want to use dynamic frameworks</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  # ZJWeakProxy</span><br><span class="line">  pod &#x27;ZJWeakProxy&#x27;,:git =&gt;&quot;https://github.com/BboyZJ/ZJWeakProxy.git&quot;</span><br><span class="line">  </span><br><span class="line">  # Pods for ZJWeakProxy-Demo</span><br><span class="line"></span><br><span class="line">end </span><br></pre></td></tr></table></figure><ul><li>执行 pod install</li></ul><p><code>mac@bogon ZJWeakProxy-Demo % pod install</code></p><p>【问题1】安装报错：[!] Unable to find a specification for <code>ZJWeakProxy</code></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042344858.png"></p><p>解决办法：</p><p><code>mac@bogon ZJWeakProxy-Demo % pod repo update --verbose</code></p><p>【问题2】：HTTP&#x2F;2 stream 1 was not closed cleanly before end of the underlying stream</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042345578.png"></p><p>解决办法：更改默认通信协议</p><p><code>mac@bogon ZJWeakProxy-Demo % git config --global http.version HTTP/1.1</code></p><ul><li>引入头文件并打印结果</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042345740.png"></p><h1 id="版本更新与维护"><a href="#版本更新与维护" class="headerlink" title="版本更新与维护"></a>版本更新与维护</h1><ul><li><p>现在的 <code>ZJWeakProxy</code> 库已经在GitHub上托管了，以后维护这个项目就可以了（开始本地创建的ZJWeakProxy项目就可以删除了），管理GitHub仓库，有两种方案：</p><ul><li><p>可以使用命令行 git clone <a href="https://github.com/BboyZJ/ZJWeakProxy">https://github.com/BboyZJ/ZJWeakProxy</a></p></li><li><p>也可以使用 GitHub Desktop</p><ul><li>下载 <a href="https://desktop.github.com/">GitHub Desktop</a> 登录你的用户名和密码，<code>File -&gt; Responsitory</code></li></ul></li></ul></li><li><p>其实 <code>GitHub Desktop</code> 更加可视化一些，上面History就是刚才git命令行的记录</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>终于写完了，哇哦😮！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;随着公司业务的不断发展，应用的代码体积将会越来越大，业务代码耦合也越来越多，代码量也是急剧增加&lt;/li&gt;
&lt;li&gt;如果仅仅完成代</summary>
      
    
    
    
    <category term="Component" scheme="https://www.bboyzj.cn/categories/Component/"/>
    
    
    <category term="组件化开发" scheme="https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>OC组件化04：【方案一】本地组件化</title>
    <link href="https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9604%EF%BC%9A%E3%80%90%E6%96%B9%E6%A1%88%E4%B8%80%E3%80%91%E6%9C%AC%E5%9C%B0%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    <id>https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9604%EF%BC%9A%E3%80%90%E6%96%B9%E6%A1%88%E4%B8%80%E3%80%91%E6%9C%AC%E5%9C%B0%E7%BB%84%E4%BB%B6%E5%8C%96/</id>
    <published>2023-03-04T15:27:35.000Z</published>
    <updated>2023-03-04T15:31:43.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><code>本地组件化</code>：主要是通过在 <code>工程中创建library</code>，利用 <code>cocoapods</code> 的 <code>workspec</code> 进行本地管理，不需要将项目上传git，而是直接在本项目中以 <code>framework</code> 的方法进行调用</li></ul><h1 id="创建主工程"><a href="#创建主工程" class="headerlink" title="创建主工程"></a>创建主工程</h1><ul><li>首先创建一个名为 <code>Modularization</code> 的工程</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162391343-e72a3235-b07f-41da-9fbf-cca1a55c4e8b.jpg"></p><ul><li>集成 cocoapods，进行本地管理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhangjian@zhangjiandeMBP ~ % cd /Users/zhangjian/Desktop/Modularization </span><br><span class="line">zhangjian@zhangjiandeMBP Modularization % pod init</span><br><span class="line">Ignoring ffi-1.13.1 because its extensions are not built. Try: gem pristine ffi --version 1.13.1</span><br><span class="line">zhangjian@zhangjiandeMBP Modularization % pod install</span><br></pre></td></tr></table></figure><h1 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h1><p>假设有以下几个模块</p><ul><li><p><code>主工程</code>：承载主要的表层业务代码</p></li><li><p><code>Core</code>：独立存在，应用加密、接口请求等敏感代码</p></li><li><p><code>Base</code>：基类封装，拓展，基本的数据处理</p></li><li><p><code>Service</code>：服务层，封装业务工具类，例如网络层服务、持久化服务等</p></li><li><p><code>Pods</code>：三方依赖</p></li></ul><p>其中，各个模块间的关系如下图</p><p><img src="https://user-images.githubusercontent.com/25925248/162391360-04089910-c38d-4859-b4f2-dfc4de229332.jpg"></p><p>下面，我们来进行模块的创建，以 <code>Core</code> 模块为例：</p><ul><li>选择  <code>File -&gt; new -&gt; project -&gt; iOS -&gt; Framework</code>，新建一个 <code>ZJCore</code> 模块</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162391370-c14294a9-e941-4a20-ad6d-edaa12a76afc.jpg"></p><p><img src="https://user-images.githubusercontent.com/25925248/162391384-d4ee6235-4b4c-49fb-b448-2416822359df.jpg"></p><ul><li>选择正确的 <code>Group</code> 和 <code>WorkSpace</code>（这里注意：创建的 <code>library</code> 最好放在 <code>主工程根目录下</code>，否则后续的 <code>podfile</code> 执行 <code>pod install</code> 会报错）</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162391398-93ed8a4d-7f60-48c5-af68-8db35d74d8c0.jpg"></p><p>创建成功后，看到的结果如下：</p><p><img src="https://user-images.githubusercontent.com/25925248/162392357-ddca5e46-b788-4d08-9af5-7e48c475bd1f.jpg"></p><p><img src="https://user-images.githubusercontent.com/25925248/162391438-632eac8a-b78a-4901-995f-f997caeea671.jpg"></p><ul><li>将创建的 <code>library</code> 的 <code>Build Settings -&gt; Mach-O Type</code> 修改为静态库 <code>Static Library</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162391454-6eb6908f-7e29-4e00-afb5-cad186bcc1c0.jpg"></p><h1 id="主工程调用Library"><a href="#主工程调用Library" class="headerlink" title="主工程调用Library"></a>主工程调用Library</h1><ul><li>在 <code>ZJCore</code> 中新建一个文件，并添加如下代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJCoreSetting : NSObject</span><br><span class="line">// 声明属性</span><br><span class="line">@property (nonatomic,copy)NSString * name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ZJCoreSetting</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>在 <code>Build Phases -&gt; Headers -&gt; Public</code> 中将新建的文件拖拽到 <code>Puclic</code> 中，这样主工程才能访问该文件</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162391477-33f10151-72cd-48ae-9b9c-0ef6e22a1e4f.jpg"></p><ul><li>在ZJCore文件中添加引用</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162392415-896bf8dd-d51d-4d63-b548-babfc3101fc8.jpg"></p><ul><li>在主工程中，选择 <code>target -&gt; Frameworks,Libraries,and Embedded Content -&gt; + 号 -&gt; 添加 ZJCore</code>，只需要build主工程，library能够自动联编</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162392476-8813bdd9-e9e9-4508-80e5-40b5bd8101be.jpg"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>首先 <code>#import &lt;ZJCore/ZJCoreSetting.h&gt;</code>，然后使用</p><p><img src="https://user-images.githubusercontent.com/25925248/162392563-05712fc4-c7b3-4fde-ae68-05291475888b.jpg"></p><p>这里需要注意的是，子library之间的互相调用，与主工程调用library类似，主需要添加依赖、暴露header即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;本地组件化&lt;/code&gt;：主要是通过在 &lt;code&gt;工程中创建library&lt;/code&gt;，利用 &lt;code&gt;coc</summary>
      
    
    
    
    <category term="Component" scheme="https://www.bboyzj.cn/categories/Component/"/>
    
    
    <category term="组件化开发" scheme="https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>OC组件化03：面向协议Protocol Class的使用</title>
    <link href="https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AEProtocol-Class%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AEProtocol-Class%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-03-04T08:16:42.000Z</published>
    <updated>2023-03-04T14:56:27.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向协议-Protocol-Class"><a href="#面向协议-Protocol-Class" class="headerlink" title="面向协议 Protocol Class"></a>面向协议 Protocol Class</h1><ul><li><p>在 <code>URL Scheme路由</code> 和 <code>target-action</code> 方案中，都存在 硬编码、参数不明确问题：URL 、Target_ 、 Action_ 的硬编码，参数都是通过字典的形式传递，类型不明确。</p></li><li><p><code>面向接口</code> 的方式能够很好的解决这两个问题。</p></li></ul><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><ul><li><p>中间件先注册 <code>Protocol</code> 和 <code>Class</code> 对应关系，将 <code>protocol</code> 和 <code>对应的类</code> 进行 <code>字典</code> 匹配</p></li><li><p>中间件返回 <code>Protocol</code> 对应的 <code>Class</code>，然后动态创建实例</p></li></ul><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>面向协议编程</li><li>安全性高</li><li>模块解耦</li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>无法多端通用</li><li>需要进行协议的注册</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ul><li>创建 <code>ZJProtocol.h</code> 协议类文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 将各个模块的协议统一放在一个文件中 ，在各个模块中依赖这个文件，实现其协议</span><br><span class="line">@protocol OneMoudleProtocol &lt;NSObject&gt;</span><br><span class="line">@required // 返回模块one</span><br><span class="line">+ (UIViewController *)oneMoudleVC;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol OneDetailMoudleProtocol &lt;NSObject&gt;</span><br><span class="line">@required</span><br><span class="line">+ (UIViewController *)oneDetailMoudleVCWithParas:(NSDictionary *)paras;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>创建 <code>ZJMediator</code> 协议管理类</li></ul><p>ZJMediator.h 文件下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJMediator : NSObject</span><br><span class="line">// 单例</span><br><span class="line">+ (instancetype)shareManager;</span><br><span class="line">// 注册绑定</span><br><span class="line">- (void)registerProtocol:(Protocol *)protocol class:(Class)cls;</span><br><span class="line">// 获取类</span><br><span class="line">- (Class)classFromProtocol:(Protocol *)protocol;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>ZJMediator.m 文件下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJMediator.h&quot;</span><br><span class="line">@interface ZJMediator ()</span><br><span class="line">@property (nonatomic,strong)NSMutableDictionary * protocolCache;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJMediator</span><br><span class="line">+ (instancetype)shareManager&#123;</span><br><span class="line">    static ZJMediator * mediator;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        mediator = [[ZJMediator alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return mediator;</span><br><span class="line">&#125;</span><br><span class="line">// 注册绑定</span><br><span class="line">- (void)registerProtocol:(Protocol *)protocol class:(Class)cls&#123;</span><br><span class="line">    if (protocol &amp;&amp; cls) &#123;</span><br><span class="line">        [self.protocolCache setObject:cls forKey:NSStringFromProtocol(protocol)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 获取类</span><br><span class="line">- (Class)classFromProtocol:(Protocol *)protocol&#123;</span><br><span class="line">    return  [self.protocolCache objectForKey:NSStringFromProtocol(protocol)];</span><br><span class="line">&#125;</span><br><span class="line">// 懒加载</span><br><span class="line">- (NSMutableDictionary *)protocolCache&#123;</span><br><span class="line">    if (!_protocolCache) &#123;</span><br><span class="line">        _protocolCache = @&#123;&#125;.mutableCopy;</span><br><span class="line">    &#125;</span><br><span class="line">    return _protocolCache;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>创建 <code>OneDetailMoudleEntry</code> 模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;OneDetailMoudleEntry.h&quot;</span><br><span class="line">#import &quot;ZJOneDetailViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface OneDetailMoudleEntry ()&lt;OneDetailMoudleProtocol&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation OneDetailMoudleEntry</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    [[ZJMediator shareManager] registerProtocol:@protocol(OneDetailMoudleProtocol) class:[self class]];</span><br><span class="line">&#125;</span><br><span class="line">// 继承</span><br><span class="line">+ (UIViewController *)WithParas:(NSDictionary *)paras&#123;</span><br><span class="line">    ZJOneDetailViewController * detailVC = [[ZJOneDetailViewController alloc] init];</span><br><span class="line">    detailVC.name = paras[@&quot;name&quot;];</span><br><span class="line">    detailVC.age = params[@&quot;age&quot;];</span><br><span class="line">    return detailVC;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>在任何地方调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//下一页的点击事件</span><br><span class="line">- (void)next:(UIButton *)sender&#123;</span><br><span class="line">    </span><br><span class="line">    Class cls = [[ZJMediator shareManager] classFromProtocol:@protocol(OneDetailMoudleProtocol)];</span><br><span class="line">    UIViewController * detailVC = [cls oneDetailMoudleVCWithParas:@&#123;@&quot;name&quot;:@&quot;ZJ&quot;,@&quot;age&quot;:30&#125;];</span><br><span class="line">    [self.navigationController pushViewController:detailVC animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面向协议-Protocol-Class&quot;&gt;&lt;a href=&quot;#面向协议-Protocol-Class&quot; class=&quot;headerlink&quot; title=&quot;面向协议 Protocol Class&quot;&gt;&lt;/a&gt;面向协议 Protocol Class&lt;/h1&gt;&lt;ul&gt;
</summary>
      
    
    
    
    <category term="Component" scheme="https://www.bboyzj.cn/categories/Component/"/>
    
    
    <category term="组件化开发" scheme="https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>OC组件化03：基于RuntTime的target-action的使用</title>
    <link href="https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E5%9F%BA%E4%BA%8ERuntTime%E7%9A%84target-action%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E5%9F%BA%E4%BA%8ERuntTime%E7%9A%84target-action%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-03-04T08:16:13.000Z</published>
    <updated>2023-03-04T15:12:11.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>target action 是利用 <code>Runtime</code> 的 <code>performSelector:withObject:</code> 方法调用，无需注册</p><h1 id="优缺"><a href="#优缺" class="headerlink" title="优缺"></a>优缺</h1><ul><li>优点：<code>无需注册路由</code>，避免了load里注册影响启动速度</li><li>不用维护全局路由表，避免了查找对应路由</li><li>统一了路由入口</li><li>进行了一定的安全处理</li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>缺点：不能多端使用同一套路由H5，Android</li><li>增加了文件，同时在获取target，sel时存在一定的硬编码</li></ul><h1 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;target action 是利用 &lt;code&gt;Runtime&lt;/code&gt; 的 &lt;code&gt;performSelector:withObj</summary>
      
    
    
    
    <category term="Component" scheme="https://www.bboyzj.cn/categories/Component/"/>
    
    
    <category term="组件化开发" scheme="https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>OC组件化02：基于URL Scheme的使用</title>
    <link href="https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9602%EF%BC%9A%E5%9F%BA%E4%BA%8EURL-Scheme%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9602%EF%BC%9A%E5%9F%BA%E4%BA%8EURL-Scheme%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-03-04T08:15:30.000Z</published>
    <updated>2023-03-04T15:02:44.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="URL-Scheme-路由"><a href="#URL-Scheme-路由" class="headerlink" title="URL Scheme 路由"></a>URL Scheme 路由</h1><ul><li>使 <code>URL Scheme</code> 处理本地的跳转</li><li>通过中间层进行注册 <code>&amp;</code> 调用（load方法里面把被调用者注册到中间层）</li></ul><h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//协议://主机名[:端口]/路径/[?参数]#fragment</span><br><span class="line">@&quot;lstest://lsapp:11111/china/ls.com?a=1&amp;b=2&quot;</span><br></pre></td></tr></table></figure><ul><li>lstest：协议名</li><li>lsapp：主机名，为了区分 不同的app</li><li>端口号：可以将端口号作为 模块ID</li><li>china&#x2F;ls.com：路径，可以是跳转到模块的 指定页面</li><li>a&#x3D;1&amp;b&#x3D;2：参数，跳转的参数</li></ul><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042254171.png"></p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><ul><li><p>优点：实现简单</p></li><li><p>缺点：存在硬编码问题，参数都是通过字典的形式传递，类型不明确</p></li></ul><h1 id="URL-Scheme-路由示例"><a href="#URL-Scheme-路由示例" class="headerlink" title="URL Scheme 路由示例"></a>URL Scheme 路由示例</h1><p>思路：B组件使用URL将Block注册给路由，路由以URL为key，将Block存储起来。<br>     A组件通过URL调用路由的方法，找到对应的Block，完成对A的调用</p><ul><li>创建路由</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJRouter.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ZJRouter ()</span><br><span class="line">@property (strong,nonatomic)NSMutableDictionary * blockDic;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJRouter</span><br><span class="line">// 参数 @&#123;@&quot;&quot;:...&#125;</span><br><span class="line">+ (instancetype)shareInstance&#123;</span><br><span class="line">    static ZJRouter * router = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        router = [[self alloc] init];</span><br><span class="line">        router.blockDic = @&#123;&#125;.mutableCopy;</span><br><span class="line">    &#125;);</span><br><span class="line">    return router;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注册</span><br><span class="line">- (void)registerUrl:(NSString *)url block:(ZJRouterBlock)block&#123;</span><br><span class="line">    if (!url || !block) return;</span><br><span class="line">    if (block) &#123;</span><br><span class="line">        self.blockDic[url] = [block copy];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 执行</span><br><span class="line">- (void)excuteBlockWithUrl:(NSString *)key params:(NSDictionary *)params&#123;</span><br><span class="line">    if (!key) return;</span><br><span class="line">    ZJRouterBlock block = self.blockDic[key];</span><br><span class="line">    if (!block) return;</span><br><span class="line">    block(params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>B 组件中注册</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    [[ZJRouter shareInstance] registerUrl:@&quot;A:aTestAction&quot; block:^(NSDictionary * _Nonnull dic) &#123;</span><br><span class="line">        NSLog(@&quot;dic:%@&quot;,dic);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A 组件中调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ZJRouter shareInstance] excuteBlockWithUrl:@&quot;A:aTestAction&quot; params:@&#123;@&quot;text&quot;:@&quot;文字&quot;&#125;];</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;URL-Scheme-路由&quot;&gt;&lt;a href=&quot;#URL-Scheme-路由&quot; class=&quot;headerlink&quot; title=&quot;URL Scheme 路由&quot;&gt;&lt;/a&gt;URL Scheme 路由&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;使 &lt;code&gt;URL Scheme&lt;/</summary>
      
    
    
    
    <category term="Component" scheme="https://www.bboyzj.cn/categories/Component/"/>
    
    
    <category term="组件化开发" scheme="https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>OC组件化01：组件化介绍</title>
    <link href="https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9601%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.bboyzj.cn/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9601%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-03-04T06:05:40.000Z</published>
    <updated>2023-03-04T15:26:25.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么组件化"><a href="#什么组件化" class="headerlink" title="什么组件化"></a>什么组件化</h1><ul><li><p>组件化其实就是 <code>将模块单独抽离、分层</code>，并指定模块间的 <code>通讯</code> 方式，从而实现 <code>解耦</code> 的一种方式，主要运用与团队开发</p></li><li><p>组件化开发就是将一个臃肿的、单一的项目，根据 <code>功能/业务/技术</code> 等进行拆分，形成一个个独立的功能组件，然后借助 <code>Cocoapods</code> 管理工具将其任意组合，集成一个完整的项目。</p></li><li><p>你可以将 <code>AFNetworking、SDWebImage、Bugly、MLeaksFinder</code> 等三方库理解为工程的一部分，属于 <code>基础组件模块</code>，我们要做的就是将项目划分多个独立功能模块，再集成一个完整的项目。</p></li></ul><h1 id="为什么要组件化？"><a href="#为什么要组件化？" class="headerlink" title="为什么要组件化？"></a>为什么要组件化？</h1><p>主要有以下四个原因</p><ul><li><p>模块间解耦</p></li><li><p>模块重用</p></li><li><p>提高团队协作开发效率</p></li><li><p>单元测试</p></li></ul><p>当项目因为各种需求，模块越来越多时，如果此时的各个模块之间是互相调用的，即 <code>你中有我，我中有你</code> 这种情况时，会造成 <code>高耦合</code> 的情况，一旦我们需要对某一模块代码进行 <code>修改</code> 时，就会 <code>牵一发而动全身</code>，导致项目难以维护</p><p><strong>其问题主要体现在以下几个方面：</strong></p><ul><li><p>修改某个功能时，同时需要修改其他模块的代码，因为在其他模块中有该模块的引用，可以理解为 <code>高耦合导致代码修改困难</code></p></li><li><p>模块对外接口不明确，甚至暴露了本不该暴露的私有接口，修改时费时费力。可以理解为 <code>接口不固定导致的接口混乱</code></p></li><li><p>高耦合代码产生的后果就是会影响团队其他成员的开发，产生 <code>代码冲突</code></p></li><li><p>当模块需要重用到其他项目时，<code>难以单独抽离</code></p></li><li><p>模块间耦合的忌口导致接口和依赖关系混乱，<code>无法进行单元测试</code></p></li></ul><p>所以为了解决以上问题，我们需要采用更规范的方式来 <code>降低模块</code> 间的 <code>耦合度</code>，这就是 <code>组件化</code>，也可以理解为 <code>模块化</code></p><p>但是，这里还需要说明一点，因为组件化也是需要一定成本的，需要花费时间设计接口、分离代码等，所以并不是所有的项目都需要组件化。如果你的项目有以下这些特征就 <code>不需要组件化</code>：</p><ul><li><p>项目较小，模块间交互简单，耦合少</p></li><li><p>项目没有被多个外部模块引用，只是一个单独的小模块</p></li><li><p>模块不需要重用，代码也很少被修改</p></li><li><p>团队规模很小</p></li><li><p>不需要编写单元测试</p></li></ul><p>如果你的有以下特性，说明你就必须要 <code>考虑进行组件化</code> 了：</p><ul><li><p>模块逻辑复杂，多个模块之间频繁互相引用</p></li><li><p>项目规模逐渐变大，修改代码变的越来越困难（这里可以理解为：修改一处代码，需要同时修改其他多个地方）</p></li><li><p>团队人数变多，提交代码经常和其他成员冲突</p></li><li><p>项目编译耗时较大</p></li><li><p>模块的单元测试经常由于其他模块的修改而失败</p></li></ul><h1 id="组件化方案"><a href="#组件化方案" class="headerlink" title="组件化方案"></a>组件化方案</h1><p>组件化方案的8条指标：</p><p>一个项目经过组件化后如何来评判，主要有以下几个 <code>标准</code>：</p><ul><li><p>模块之间没有耦合，模块内部的修改不会影响其他模块</p></li><li><p>模块可以单独编译</p></li><li><p>模块间数据传递明确</p></li><li><p>模块对外接口清晰且易维护</p></li><li><p>当模块接口改变时，此模块的外部代码能够被高效重构</p></li><li><p>尽量用最少的修改和代码，让现有项目实现模块化</p></li><li><p>支持OC和Swift，以及混编</p></li></ul><p>前4条主要用于 <code>衡量一个模块是否真正解耦</code>，后4条主要用于衡量在项目中 <code>实践中的易用程序</code></p><p><strong>组件化原则</strong></p><p>一个项目主要分为3层：<code>业务层、通用层</code> 以及 <code>基础层</code>，在进行组件化时，有以下几点说明</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/20230304232513.png"></p><ul><li><p>只能上层对下层依赖，不能下层对上层依赖，因为下层是对上层的抽象</p></li><li><p>项目公共代码资源下沉</p></li><li><p>横向的依赖尽量减少，最好下层至通用模块，或者基础模块</p></li></ul><h1 id="组件化和非组件化区别"><a href="#组件化和非组件化区别" class="headerlink" title="组件化和非组件化区别"></a>组件化和非组件化区别</h1><p>组件化能够帮助我们将大部分项目拆解成数个小组件，开发者只需要关注组件所依赖的其他组件，而无需关心完整项目的其他部分，每个组件可以自己采取所习惯的架构模式：MVC、MVVM等，就行开发一款个人独立的App那样自由</p><p>非组件化：</p><ul><li>代码高耦合度、高依赖</li><li>项目复杂、臃肿、编译时间过长（影响调试）</li><li>难以融合、集成其他产品</li><li>…</li></ul><p>组件化：</p><ul><li>代码复用性提高，可方便集成到其他项目</li><li>项目可配置，方便集成和功能回退</li><li>方便组件并行开发</li><li>可方便单元测试</li><li>…</li></ul><h1 id="组件化分层"><a href="#组件化分层" class="headerlink" title="组件化分层"></a>组件化分层</h1><p>项目组件化，最难的就是 <code>粒度</code> 问题，需要开发者根据自己的经验把控。这里给出个人认为的层次划分：</p><p>【基础组件】：宏定义&#x2F;常量&#x2F;自定义工具类，如常用的自定义分类<br>【功能组件】：项目中常用的功能，如地图&#x2F;消息推送&#x2F;分享&#x2F;登录等<br>【业务组件】：项目中的模块&#x2F;业务，如文章详情&#x2F;个人中心等<br>【中间组件】：负责项目中的路由&#x2F;消息通知&#x2F;传参&#x2F;回调等<br>【宿主工程】：项目容器，用来集成组件，调整各个组件之间的消息传递容器</p><h1 id="中间层几种方案"><a href="#中间层几种方案" class="headerlink" title="中间层几种方案"></a>中间层几种方案</h1><p>在组件化中，中间层是各个组件的通信桥梁，中间层在组件化过程中扮演着非常重要的角色。</p><p>中间层的三种方式：</p><ul><li><p>基于 <code>URL Scheme</code> 的 <code>路由</code></p></li><li><p>基于 <code>Runtime</code> 的 <code>target-action</code></p></li><li><p>面向接口 的 <code>Protocol - Class</code></p></li></ul><h1 id="基于-URL-Scheme-的三方库"><a href="#基于-URL-Scheme-的三方库" class="headerlink" title="基于 URL Scheme 的三方库"></a>基于 URL Scheme 的三方库</h1><p><code>iOS</code> 中支持的 <code>URL Scheme</code> 让我们能够在 <code>应用之间、应用内部传递消息</code>。</p><ul><li><p><a href="https://github.com/joeldev/JLRoutes">JLRoutes</a></p></li><li><p><a href="https://github.com/clayallsopp/routable-ios">routable-ios</a></p></li><li><p><a href="https://github.com/lightory/HHRouter">HHRouter</a></p></li></ul><p>具体怎么使用，可以自行去探索</p><h1 id="基于-Runtime-的-target-action"><a href="#基于-Runtime-的-target-action" class="headerlink" title="基于 Runtime 的 target-action"></a>基于 <code>Runtime</code> 的 <code>target-action</code></h1><p>相比 <code>url scheme</code> 的提前注册、实现服务，<code>CTMediator</code> 借助 <code>OC</code> 运行时的特性，现实组件之间服务的自动发现，无需提前注册即可实现组件间的调用，因此，这种方案的可维护性、可读性、扩展性相对较高。</p><ul><li><a href="https://github.com/casatwy/CTMediator">CTMediator</a></li></ul><h1 id="面向接口-Protocol-Class"><a href="#面向接口-Protocol-Class" class="headerlink" title="面向接口 Protocol - Class"></a>面向接口 <code>Protocol - Class</code></h1><ul><li><code>Protocol - Class</code></li></ul><p>面向接口的方案通常由两部分组成，一个是用来管理接口协议的类（ProtocolManager），一个是具体的接口协议（ComponentProtocol）</p><h1 id="组件化的核心工具"><a href="#组件化的核心工具" class="headerlink" title="组件化的核心工具"></a>组件化的核心工具</h1><ul><li><p>组件化工程，需要一个宿主工程，负责集成所有的组件。每个组件都是一个单独的工程，通过 <code>Git</code> 私有仓库来管理。</p></li><li><p>所有组件都上传到 <code>Git</code> 仓库并支持 <code>cocoapods</code> 集成。主工程通过配置 <code>Podfile</code> 文件，然后一键 <code>pod update</code> 即可。使用 <code>Cocoapods</code> 来管理组件主要因为其本身功能强大，方便的集成整个项目，解放对依赖库的管理。使用组件化的集成方式，可以很好的避免传统项目中的代码冲突问题。</p></li><li><p>组件化的核心工具就是 <code>CocoaPods</code> ，我们要做的就是将组件项目上传到 <code>Gitee码云</code> 或者 <code>Gitlab极狐</code>，编写项目的 <code>podSpec</code> 文件让组件支持 <code>CocoaPods</code> 集成即可。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么组件化&quot;&gt;&lt;a href=&quot;#什么组件化&quot; class=&quot;headerlink&quot; title=&quot;什么组件化&quot;&gt;&lt;/a&gt;什么组件化&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;组件化其实就是 &lt;code&gt;将模块单独抽离、分层&lt;/code&gt;，并指定模块间的 &lt;code&gt;通讯&lt;</summary>
      
    
    
    
    <category term="Component" scheme="https://www.bboyzj.cn/categories/Component/"/>
    
    
    <category term="组件化开发" scheme="https://www.bboyzj.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习37：对象</title>
    <link href="https://www.bboyzj.cn/2023/03/04/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A037%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.bboyzj.cn/2023/03/04/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A037%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</id>
    <published>2023-03-03T16:37:01.000Z</published>
    <updated>2023-03-05T09:05:26.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="swift面向对象概述"><a href="#swift面向对象概述" class="headerlink" title="swift面向对象概述"></a>swift面向对象概述</h1><h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><ul><li><p>继承</p></li><li><p>封装</p></li><li><p>多态</p></li></ul><h2 id="基本单元"><a href="#基本单元" class="headerlink" title="基本单元"></a>基本单元</h2><ul><li><p>枚举</p></li><li><p>结构体</p></li><li><p>类 </p></li><li><p>协议</p></li><li><p>扩展</p></li></ul><h2 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h2><ul><li><p>从整体功能上看 swift 的枚举、结构体、类三者具有完全平等的地位</p></li><li><p>swift 的类、结构体、枚举中都可以定义（属性、方法、下标、构造体、嵌套类型）</p></li><li><p>在swift中，<code>枚举和结构体</code> 是 <code>值类型</code>，<code>类</code> 是 <code>引用类型</code></p></li></ul><h2 id="类和结构体的相似点"><a href="#类和结构体的相似点" class="headerlink" title="类和结构体的相似点"></a>类和结构体的相似点</h2><ul><li><p><code>定义属性用来存储值</code></p></li><li><p><code>定义方法用来提供功能</code></p></li><li><p><code>定义下标脚本用来允许使用下标语法访问值</code></p></li><li><p>定义初始化器用来初始化状态</p></li><li><p>可以被扩展来默认所没有的功能</p></li><li><p>遵循协议来针对特定类型提供标准功能</p></li></ul><h2 id="类和结构体不同点"><a href="#类和结构体不同点" class="headerlink" title="类和结构体不同点"></a>类和结构体不同点</h2><ul><li><p>继承允许一个类继承另一个类的特性</p></li><li><p>类型转换允许你再运行检查和解释一个类实例的类型</p></li><li><p>反初始化器允许一个类实例释放任何其被分配的资源</p></li><li><p>引用计数器允许不止一个类对实例的引用</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;swift面向对象概述&quot;&gt;&lt;a href=&quot;#swift面向对象概述&quot; class=&quot;headerlink&quot; title=&quot;swift面向对象概述&quot;&gt;&lt;/a&gt;swift面向对象概述&lt;/h1&gt;&lt;h2 id=&quot;面向对象的三大特性&quot;&gt;&lt;a href=&quot;#面向对象的三大特</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习36：函数式编程</title>
    <link href="https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A036%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A036%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2023-03-03T14:56:24.000Z</published>
    <updated>2023-03-05T08:49:29.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="范式转换-函数式"><a href="#范式转换-函数式" class="headerlink" title="范式转换-函数式"></a>范式转换-函数式</h1><p>读入一个文本，确定所有单词的使用频率并从高到低排序，打印出所有单词及其频率的排序列表</p><ul><li><code>命令式编程</code> 风格尝尝迫使我们出于性能考虑，把不同的任务交织起来，以便能够用一次循环来完成多个任务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">let words = &quot;&quot;&quot;</span><br><span class="line">This rectangle defines the size and position of the view in its superview’s coordinate system.</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">let NON_WORDS = [&quot;e&quot;,&quot;of&quot;,&quot;end&quot;,&quot;on&quot;]</span><br><span class="line"></span><br><span class="line">func wordFrep(words: String) -&gt; [String:Int] &#123;</span><br><span class="line">    var wordDict: [String:Int] = [:]</span><br><span class="line">    // 分割成一个数组</span><br><span class="line">    let wordList = words.split(separator: &quot; &quot;)</span><br><span class="line">    // 遍历数组</span><br><span class="line">    for word in wordList &#123;</span><br><span class="line">        // 数组每个元素转小写</span><br><span class="line">        let lowercaseWord = word.lowercased()</span><br><span class="line">        // 不包含元素</span><br><span class="line">        if !NON_WORDS.contains(lowercaseWord) &#123;</span><br><span class="line">            // 有count</span><br><span class="line">            if let count = wordDict[lowercaseWord] &#123;</span><br><span class="line">                wordDict[lowercaseWord] = count + 1</span><br><span class="line">            &#125;else &#123; // 无count</span><br><span class="line">                wordDict[lowercaseWord] = 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return wordDict</span><br><span class="line">&#125;</span><br><span class="line">print(wordFrep(words:words))</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">[&quot;and&quot;: 1, &quot;superview’s&quot;: 1, &quot;system.&quot;: 1, &quot;view&quot;: 1, &quot;defines&quot;: 1, &quot;its&quot;: 1, &quot;coordinate&quot;: 1, &quot;in&quot;: 1, &quot;the&quot;: 2, &quot;rectangle&quot;: 1, &quot;this&quot;: 1, &quot;size&quot;: 1, &quot;position&quot;: 1]</span><br></pre></td></tr></table></figure><ul><li>而 <code>函数式编程</code> 用 <code>map()、filter()</code> 这些高级函数把我们解法出来，让我们站在更高的抽象层次上去考虑问题，把问题看的更清楚</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 函数式写法</span><br><span class="line">func wordFrep2(words: String) -&gt; [String:Int] &#123;</span><br><span class="line">    var wordDict: [String:Int] = [:]</span><br><span class="line">    // 分割成一个数组</span><br><span class="line">    let wordList = words.split(separator: &quot; &quot;)</span><br><span class="line">    // map：尾随闭包的方式</span><br><span class="line">    wordList.map &#123; $0.lowercased() &#125;</span><br><span class="line">        .filter &#123; !NON_WORDS.contains( $0 ) &#125;</span><br><span class="line">        .forEach &#123; wordDict[$0] = (wordDict[$0] ?? 0) + 1 &#125;</span><br><span class="line"></span><br><span class="line">    return wordDict</span><br><span class="line">&#125;</span><br><span class="line">print(wordFrep2(words:words))</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line">[&quot;view&quot;: 1, &quot;its&quot;: 1, &quot;and&quot;: 1, &quot;defines&quot;: 1, &quot;in&quot;: 1, &quot;the&quot;: 2, &quot;size&quot;: 1, &quot;this&quot;: 1, &quot;position&quot;: 1, &quot;coordinate&quot;: 1, &quot;superview’s&quot;: 1, &quot;system.&quot;: 1, &quot;rectangle&quot;: 1]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="函数式编程-简洁"><a href="#函数式编程-简洁" class="headerlink" title="函数式编程-简洁"></a>函数式编程-简洁</h1><ul><li><p>函数式编程简洁，<code>面向对象编程</code> 通过 <code>封装不确定因素</code> 来使代码能够被人理解，<code>函数式编程</code> 通过 <code>尽量减少少不确定因素</code> 来使代码能够被人理解</p></li><li><p>在面向对象的命令式编程语言里，重用的单元是类和类之间沟通用的消息</p></li><li><p>函数式编程语言实现重用的思路很不一样。函数式语言提倡在有限的几种关键数据结果（如：list、set、map）上运用针对这些数据结构高度优化过的操作，以此构建成基本的运转机构。开发者再根据具体用途，插入自己的数据结构和高阶函数去调整机构的运转方式</p></li><li><p>比起以为创建新的类结构体系，把封装的元素降低到函数级别，更有利达到细粒度的、基础层面的重用</p></li><li><p>函数式程序员喜欢用少数几个核心数据结构，围绕它们去建立一套充分优化的运转机构。<br>面向对象程序员喜欢不断的创建新的数据结构和附属的操作，因为压倒一切的面向对象编程范式就是建立新的类和类间的消息。<br>把所有的数据结构封装成类，一方面压制了方法层面的重用，另一方面鼓励了大粒度的框架式重用。<br>函数式编程的程序结构方便我们在比较细小的层面上重用代码</p></li></ul><h1 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h1><ul><li>假设我们有一个名字列表，其中一些条目由单个字符组成。现在的任务是，将除去单字符条目之外的列表内容，放在一个逗号分割的字符串里返回，且每个名字的首字母都要大写</li></ul><h1 id="命令式解法"><a href="#命令式解法" class="headerlink" title="命令式解法"></a>命令式解法</h1><ul><li>命令式编程是按照 <code>程序是一系列改变状态的命名</code> 来建模的一种编程风格。传统的 for 循环是命令式风格的句号例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let names = [&quot;neal&quot;,&quot;s&quot;,&quot;stu&quot;,&quot;h&quot;,&quot;rich&quot;]</span><br><span class="line">func cleanNames(names: Array&lt;String&gt;) -&gt; String &#123;</span><br><span class="line">    var cleanedNames = &quot;&quot;</span><br><span class="line">    for name in names &#123;</span><br><span class="line">        if name.count &gt; 1 &#123;</span><br><span class="line">            cleanedNames += name.capitalized + &quot;,&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 去掉最后一个,</span><br><span class="line">    cleanedNames.remove(at: cleanedNames.index(before: cleanedNames.endIndex))</span><br><span class="line">    return cleanedNames</span><br><span class="line">&#125;</span><br><span class="line">print(cleanNames(names: names))</span><br><span class="line"></span><br><span class="line">==========</span><br><span class="line">Neal,Stu,Rich</span><br></pre></td></tr></table></figure><h1 id="函数式解法"><a href="#函数式解法" class="headerlink" title="函数式解法"></a>函数式解法</h1><ul><li>函数式编程将程序描述为 <code>表达式和变换</code>，以数学方程的形式建立模型，并且尽量避免可变的状态。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 函数式解法</span><br><span class="line">let names = [&quot;neal&quot;,&quot;s&quot;,&quot;stu&quot;,&quot;h&quot;,&quot;rich&quot;]</span><br><span class="line">// 过滤</span><br><span class="line">let cleanedNames = names.filter &#123; $0.count &gt; 1 &#125;</span><br><span class="line">print(cleanedNames)</span><br><span class="line">// 首字母大写</span><br><span class="line">let cleanedNames2 = cleanedNames.map &#123; $0.capitalized &#125;</span><br><span class="line">print(cleanedNames2)</span><br><span class="line">// 拼接</span><br><span class="line">let cleanedNames3 = cleanedNames2.joined(separator: &quot;,&quot;)</span><br><span class="line">print(cleanedNames3)</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">[&quot;neal&quot;, &quot;stu&quot;, &quot;rich&quot;]</span><br><span class="line">[&quot;Neal&quot;, &quot;Stu&quot;, &quot;Rich&quot;]</span><br><span class="line">Neal,Stu,Rich</span><br></pre></td></tr></table></figure><p>上面的方式还可以简写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 简写</span><br><span class="line">let cleanedName = names.filter &#123; $0.count &gt; 1 &#125;</span><br><span class="line">    .map &#123; $0.capitalized &#125;</span><br><span class="line">    .joined(separator: &quot;,&quot;)</span><br><span class="line">print(cleanedName)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">Neal,Stu,Rich</span><br></pre></td></tr></table></figure><h1 id="具有普遍意义的基本构造单元"><a href="#具有普遍意义的基本构造单元" class="headerlink" title="具有普遍意义的基本构造单元"></a>具有普遍意义的基本构造单元</h1><ul><li><p>筛选：<code>filter</code></p></li><li><p>映射：<code>map</code> </p></li><li><p>折叠&#x2F;化约：<code>foldLeft/reduce</code> 等</p></li></ul><h1 id="swift-的劣势-并行"><a href="#swift-的劣势-并行" class="headerlink" title="swift 的劣势-并行"></a>swift 的劣势-并行</h1><ul><li>不是线程安全的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 函数式</span><br><span class="line">let names = [&quot;neal&quot;,&quot;s&quot;,&quot;stu&quot;,&quot;h&quot;,&quot;rich&quot;,&quot;ff&quot;,&quot;sag&quot;]</span><br><span class="line">let cleanedName = names.filter &#123; $0.count &gt; 1 &#125;</span><br><span class="line">    .map &#123; $0.capitalized &#125;</span><br><span class="line">    .joined(separator: &quot;,&quot;)</span><br><span class="line">print(cleanedName)</span><br><span class="line"></span><br><span class="line">// 数组的扩展</span><br><span class="line">extension Array where Element : Any &#123;</span><br><span class="line">    // 函数</span><br><span class="line">    public func currentMap&lt;T&gt;(_ transform: (Element) -&gt; T)  -&gt; [T] &#123;</span><br><span class="line">        let n = self.count</span><br><span class="line">        if n == 0 &#123; return [] &#125;</span><br><span class="line">        var result = Array&lt;T&gt;() // 初始化一个数组</span><br><span class="line">        result.reserveCapacity(n)</span><br><span class="line">        DispatchQueue.concurrentPerform(iterations: n) &#123; i in</span><br><span class="line">            result.append(transform(self[i]))</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 并行写法</span><br><span class="line">let cleanedName2 = names.filter &#123; $0.count &gt; 1 &#125;</span><br><span class="line">    .currentMap &#123; $0.capitalized &#125;</span><br><span class="line">    .joined(separator: &quot;,&quot;)</span><br><span class="line">print(cleanedName2)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">Neal,Stu,Rich,Ff,Sag</span><br><span class="line">Stu,Neal,Rich,Ff,Sag</span><br></pre></td></tr></table></figure><p>有结果可知：打印的顺序不同，或者会少，说明线程不安全</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;范式转换-函数式&quot;&gt;&lt;a href=&quot;#范式转换-函数式&quot; class=&quot;headerlink&quot; title=&quot;范式转换-函数式&quot;&gt;&lt;/a&gt;范式转换-函数式&lt;/h1&gt;&lt;p&gt;读入一个文本，确定所有单词的使用频率并从高到低排序，打印出所有单词及其频率的排序列表&lt;/p&gt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习34：闭包</title>
    <link href="https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A034%EF%BC%9A%E9%97%AD%E5%8C%85/"/>
    <id>https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A034%EF%BC%9A%E9%97%AD%E5%8C%85/</id>
    <published>2023-03-03T14:56:01.000Z</published>
    <updated>2023-03-05T06:23:33.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闭包和闭包表达式"><a href="#闭包和闭包表达式" class="headerlink" title="闭包和闭包表达式"></a>闭包和闭包表达式</h1><h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><ul><li><p>闭包是可以在你的代码中被 <code>传递和引用</code> 的功能性独立代码块</p></li><li><p>闭包能够 <code>补获和存储</code> 定义上下文的任何 <code>常量和变量</code>，这就是所谓的闭合并包裹哪些常量和变量，因此成为 <code>闭包</code>，Swift能够为你处理所有关于补获的内存管理操作</p></li><li><p><code>全局和内嵌函数</code>，实际上是 <code>特殊的闭包</code>。闭包符合以下三种形式的一种</p><ul><li><p>全局函数时一个有名字但不会补获任何值的闭包</p></li><li><p>内嵌函数时一个有名字且能从其上下层函数补获值的闭包</p></li><li><p>闭包表达式是一个轻量级语法所写的可 <code>以补获其上下文中常量和变量值</code> 的没有名字的闭包</p></li></ul></li></ul><h2 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h2><ul><li>闭包表达式是一种在简短行内就能写完闭包的语法</li></ul><h2 id="闭包表达式从-sorted-函数说起"><a href="#闭包表达式从-sorted-函数说起" class="headerlink" title="闭包表达式从 sorted 函数说起"></a>闭包表达式从 sorted 函数说起</h2><ul><li>swift标准库提供了一个叫做 <code>sorted(by:)</code> 的方法，会根据你提供的 排序闭包 将已经数组排序，返回一个已排好序的新数组，原数组不会被 <code>sorted(by:)</code> 方法修改</li></ul><p><strong>正序排列</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var newname = name.sorted()</span><br></pre></td></tr></table></figure><p><strong>逆序排列</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]</span><br><span class="line">func backward(_ s1:String,_ s2:String) -&gt; Bool &#123;</span><br><span class="line">    return s1 &gt; s2</span><br><span class="line">&#125;</span><br><span class="line">var newname = name.sorted(by: backward)</span><br><span class="line">print(&quot;\(name) , \(newname)&quot;)</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">[&quot;a&quot;, &quot;bb&quot;, &quot;c&quot;, &quot;ddd&quot;] , [&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure><h2 id="闭包表达式语法"><a href="#闭包表达式语法" class="headerlink" title="闭包表达式语法"></a>闭包表达式语法</h2><ul><li><p>闭包表达式语法能够使用 <code>常量形式参数、变量形式参数和输入输出形式参数</code>，但不能提供默认值。</p></li><li><p>可变形式参数也能使用，需要在形式参数列表的最后面使用</p></li><li><p>元组也可被用来作为形式参数和返回类型</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; (return type) in</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将之前 <code>backward(::)</code> 函数改为闭包表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]</span><br><span class="line">var newname = name.sorted(by: &#123; (s1: String,s2: String) -&gt; Bool in</span><br><span class="line">    return s1 &gt; s2</span><br><span class="line">&#125;)</span><br><span class="line">print(&quot;\(name) , \(newname)&quot;)</span><br><span class="line"></span><br><span class="line">===========</span><br><span class="line">[&quot;a&quot;, &quot;bb&quot;, &quot;c&quot;, &quot;ddd&quot;] , [&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure><h2 id="从语境中推断类型"><a href="#从语境中推断类型" class="headerlink" title="从语境中推断类型"></a>从语境中推断类型</h2><ul><li><p>排序闭包为实际参数来传递给函数，swift能推断它的形式参数类型和返回类型</p></li><li><p>可以省略 形式参数、括号、返回箭头</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]</span><br><span class="line">var newname = name.sorted(by: &#123; s1,s2 in return s1 &gt; s2 &#125;)</span><br><span class="line">print(&quot;\(newname)&quot;)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">[&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure><h2 id="但表达式闭包隐士返回"><a href="#但表达式闭包隐士返回" class="headerlink" title="但表达式闭包隐士返回"></a>但表达式闭包隐士返回</h2><ul><li>但表达式闭包能够通过从它们声明中删掉 <code>return</code> 关键字来隐士返回它们单个表达式的结果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]</span><br><span class="line">var newname = name.sorted(by: &#123; s1,s2 in s1 &gt; s2 &#125;)</span><br><span class="line">print(&quot;\(newname)&quot;)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">[&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure><h2 id="简写实际参数名"><a href="#简写实际参数名" class="headerlink" title="简写实际参数名"></a>简写实际参数名</h2><ul><li><code>swift</code> 自动对行内闭包提供简写实际参数，可以通过 <code>$0,$1,$2</code> 等名字来引用闭包的 <code>实际参数</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]</span><br><span class="line">var newname = name.sorted(by: &#123; $0 &gt; $1 &#125;)</span><br><span class="line">print(&quot;\(newname)&quot;)</span><br><span class="line"></span><br><span class="line">==========</span><br><span class="line">[&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure><h2 id="运算符函数"><a href="#运算符函数" class="headerlink" title="运算符函数"></a>运算符函数</h2><ul><li>swift 的 <code>string</code> 类型定义了关于大于号 <code>&gt;</code> 的特定类型字符串实现，让其作为一个有两个 <code>string</code> 类型形式参数的函数并返回一个 <code>bool</code> 类型的值。正好 <code>soreted(by:)</code> 方法的形式参数需要的函数相匹配。因此你可以简单的传入一个 <code>&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]</span><br><span class="line">var newname = name.sorted(by: &gt;)</span><br><span class="line">print(&quot;\(newname)&quot;)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">[&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure><h2 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h2><ul><li><p>如果你需要一个 <code>很长的闭包表达式</code> 作为 <code>函数最后一个实际参数</code> 传递给函数，使用尾随闭包将增强函数的可读性。</p></li><li><p><code>尾随闭包</code> 是一个被 <code>写在函数形式参数的括号后面</code> 的闭包表达式</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]</span><br><span class="line">var newname = name.sorted&#123; $0 &gt; $1&#125;</span><br><span class="line">print(&quot;\(newname)&quot;)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">[&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure><h1 id="闭包捕获值"><a href="#闭包捕获值" class="headerlink" title="闭包捕获值"></a>闭包捕获值</h1><h2 id="捕获值"><a href="#捕获值" class="headerlink" title="捕获值"></a>捕获值</h2><ul><li>一个闭包能够 <code>从上下文捕获已被定义的常量和变量</code>。即使定义这些常量和变量的原作用域已经不存在，闭包仍能在其函数体内引用和修改这些值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int &#123;</span><br><span class="line">    var runningTotal = 0</span><br><span class="line">    func incrementor() -&gt; Int &#123;</span><br><span class="line">        runningTotal += amount</span><br><span class="line">        return runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    return incrementor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>作为一种优化，如果一个值没有改变或在闭包外面，swift可能会使用这个值的 <code>拷贝</code> 而 <code>不是捕获</code></li></ul><p>如果 <code>runningTotal</code> 没有在闭包里使用或改变，则是 拷贝</p><ul><li>swift也处理了变量的内存管理操作，当变量不再需要时会被释放</li></ul><h2 id="闭包是引用类型"><a href="#闭包是引用类型" class="headerlink" title="闭包是引用类型"></a>闭包是引用类型</h2><ul><li><p>在swift中，<code>函数和闭包都是引用类型</code></p></li><li><p>无论是什么时候赋值给 <code>函数或闭包</code> 一个 <code>常量或变量</code>，实际上都是将常量和变量设置为对函数和闭包的 <code>引用</code></p></li><li><p>如果你分配了一个闭包给类实例的属性，并且闭包通过引用该实例或者它的成员来捕获实例，你将在闭包和实例间会产生 <code>循环引用</code></p></li></ul><h2 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h2><ul><li><p>当闭包作为一个实际参数传递给一个函数时，它会在 <code>函数返回之后调用</code>，我们就说这个 <code>闭包逃逸了</code>。当你声明一个接收闭包作为形式参数的函数时， 你可以在形式参数前加 <code>@escaping</code> 来明确闭包是允许逃逸的</p></li><li><p>闭包可以逃逸的一种方法是 <code>被存储在定义函数外的变量里</code>。比如说，很多函数接收闭包实际参数来作为启动异步任务的回调。函数在启动任务后返回，但是闭包要直到任务完成—闭包需要逃逸，以便稍后调用。一般是网络请求成功或失败使用 <code>逃逸闭包</code></p></li><li><p>让闭包 <code>@escaping</code> 你必须在闭包中显示的使用 <code>self</code></p></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303051414381.png"></p><h2 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h2><ul><li><p>通过 <code>@autoclosure</code> 标志标记它的形式是使用了自动闭包。现在你调用函数就像它接受了一个 <code>String</code> 类型的实际参数而不是闭包。实际参数自动地转换为闭包。</p></li><li><p>可以将一个 <code>表达式 </code>直接传递给 <code>@autoclosure自动闭包</code></p></li><li><p>自动闭包是一种自动创建的用来把作为实际参数传递给函数的表达式的闭包。它不接受任何实际参数，并且当它被调用时，它会返回内部打包的表达式的值。这个语法的好处在于通过写普通表达式代替显示闭包而使你 <code>省略</code> 包围 <code>函数形式参数</code> 的括号<code>()</code></p></li><li><p>自动闭包允许你 <code>延迟执行</code>，因此闭包内部的代码直到你调用时才会运行。对于有副作用或者占用资源的代码来说很有用，因为它可以允许你控制代码何时才进行求值</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 自动闭包</span><br><span class="line">var custom = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;];</span><br><span class="line">print(custom.count)</span><br><span class="line"></span><br><span class="line">let customPro = &#123; custom.remove(at: 0)&#125;</span><br><span class="line">print(custom.count)</span><br><span class="line"></span><br><span class="line">// 调用才求值</span><br><span class="line">print(&quot;new \(customPro())&quot;)</span><br><span class="line">print(custom.count)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">new a</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="自动-逃逸"><a href="#自动-逃逸" class="headerlink" title="自动 + 逃逸"></a>自动 + 逃逸</h2><ul><li>如果你想要自动闭包允许逃逸，就同时使用 <code>@autoclosure</code> 和 <code>@escaping</code> 标志</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 自动+逃逸</span><br><span class="line">var names = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]</span><br><span class="line">var providers:[() -&gt; String] = []</span><br><span class="line">func collectCustomsProviders(provider: @escaping () -&gt; String) &#123;</span><br><span class="line">    providers.append(provider )</span><br><span class="line">&#125;</span><br><span class="line">// 表达式 name.remove(at:0) String</span><br><span class="line">collectCustomsProviders(provider:names.remove(at: 0))</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">报错</span><br></pre></td></tr></table></figure><p>不能直接给 <code>闭包</code> 传递表达式，需要添加 <code>@autoclosure</code></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303051423190.png"></p><p>正确的写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 自动+逃逸</span><br><span class="line">var names = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]</span><br><span class="line">var providers:[() -&gt; String] = []</span><br><span class="line">func collectCustomsProviders(provider: @autoclosure @escaping () -&gt; String) &#123;</span><br><span class="line">    providers.append(provider )</span><br><span class="line">&#125;</span><br><span class="line">// 表达式 name.remove(at:0) String</span><br><span class="line">collectCustomsProviders(provider:names.remove(at: 0))</span><br><span class="line">collectCustomsProviders(provider:names.remove(at: 0))</span><br><span class="line">// 实际上逃逸闭包</span><br><span class="line">print(names.count)</span><br><span class="line"></span><br><span class="line">for provide in providers &#123;</span><br><span class="line">    print(provide())</span><br><span class="line">&#125;</span><br><span class="line">print(names.count)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;闭包和闭包表达式&quot;&gt;&lt;a href=&quot;#闭包和闭包表达式&quot; class=&quot;headerlink&quot; title=&quot;闭包和闭包表达式&quot;&gt;&lt;/a&gt;闭包和闭包表达式&lt;/h1&gt;&lt;h2 id=&quot;闭包的概念&quot;&gt;&lt;a href=&quot;#闭包的概念&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习33：函数</title>
    <link href="https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A033%EF%BC%9A%E5%87%BD%E6%95%B0/"/>
    <id>https://www.bboyzj.cn/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A033%EF%BC%9A%E5%87%BD%E6%95%B0/</id>
    <published>2023-03-03T14:54:55.000Z</published>
    <updated>2023-03-04T16:39:01.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift中如何定义和使用函数"><a href="#Swift中如何定义和使用函数" class="headerlink" title="Swift中如何定义和使用函数"></a>Swift中如何定义和使用函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p><code>函数是一个独立的代码块，用来执行特定的任务</code>。通过给函数一个名字来定义它的功能，并且在需要的时候，通过这个名字来 <code>调用</code> 函数执行它的任务</p></li><li><p><code>Swift统一的函数语法十分灵活</code>。可以从简单的无形式参数到复杂的每个形式参数都带有局部和外部形式参数名。形式参数提供一个默认值来简化函数的调用，可被当做输入输出形式参数被传递，在函数执行完成时修改传递进来的变量。</p></li><li><p><code>Swift中每一个函数都有类型，由函数的形式参数类型和返回类型组成</code> 。可以像swift中其它类型来使用它。可以将函数当一个形式参数传递到另外一个函数中。也可以在一个函数中返回另一个函数。同时也可以写在其他函数内部在内嵌范围封装有用的功能。</p></li><li><p>函数是 <code>引用类型</code> 的，不是值类型的</p></li></ul><h2 id="定义和调用函数"><a href="#定义和调用函数" class="headerlink" title="定义和调用函数"></a>定义和调用函数</h2><ul><li><p>当你定义一个函数时，可以 选择定义一个或多个形式参数类型，也可以定义返回类型</p></li><li><p>每个函数都有函数名，藐视执行的任务。</p></li><li><p>使用函数可通过 <code>函数名</code> 并且 <code>传入</code> 函数的 <code>实际参数</code> （即形式参数类型的输入值 ）来 <code>调用函数</code>。</p></li><li><p>实际参数顺序必须符合形式参数的列表顺序</p></li></ul><h2 id="无形式参数的函数"><a href="#无形式参数的函数" class="headerlink" title="无形式参数的函数"></a>无形式参数的函数</h2><ul><li><p>函数不要求必须传入一个参数，可以没有形式参数</p></li><li><p>函数定义需要在名字的后面加一个圆括号，即使没有形式参数也得加</p></li><li><p>调用函数的时候也要在函数的名字后面加一个圆括号</p></li></ul><h2 id="多形式参数的函数"><a href="#多形式参数的函数" class="headerlink" title="多形式参数的函数"></a>多形式参数的函数</h2><ul><li>函数可以输入多个形式参数，写在圆括号内，用逗号分割</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func manyPara(a:Int,b:Int) &#123;</span><br><span class="line">    pring(&quot;\(a) \(b)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无返回值的函数"><a href="#无返回值的函数" class="headerlink" title="无返回值的函数"></a>无返回值的函数</h2><ul><li><p>函数定义可以没有返回类型，即没有返回箭头 -&gt; 或返回类型</p></li><li><p>严格上，函数还是有一个返回类型的，尽管没有定义返回值，实际上返回一个特殊的类型 <code>void</code>。它是一个空的元组，作用相当于没有元素的元组，写作()</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func manyTuple() -&gt; void &#123;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多返回值的函数"><a href="#多返回值的函数" class="headerlink" title="多返回值的函数"></a>多返回值的函数</h2><ul><li>可以让函数返回多个值作为一个复合的返回值，你可以使用元组类型作为返回类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func manyTuple() -&gt; (a:Int,b:String) &#123;</span><br><span class="line">    return (1,&quot;aaa&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可选元组返回类型"><a href="#可选元组返回类型" class="headerlink" title="可选元组返回类型"></a>可选元组返回类型</h2><ul><li><p>如果在函数返回类型中元组可能 <code>没有值</code>，可以用可选元组说明元组可能是 <code>nil</code></p></li><li><p>写法是可选元组圆括号后面加一个问号 <code>？</code>，例如 (Int,Int)? 或 (String,Int,Bool)?</p></li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 返回元组</span><br><span class="line">func minMax(arr: [Int]) -&gt; (min:Int,max:Int)? &#123;</span><br><span class="line">    if arr.isEmpty &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    var minValue = arr[0]</span><br><span class="line">    var maxValue = arr[0]</span><br><span class="line">    for value in arr &#123;</span><br><span class="line">        if value &lt; minValue &#123;</span><br><span class="line">            minValue = value</span><br><span class="line">        &#125;</span><br><span class="line">        if value &gt; maxValue &#123;</span><br><span class="line">            maxValue = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (minValue,maxValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 绑定</span><br><span class="line">if let minMaxValue = minMax(arr: [1,3,4,2,5]) &#123;</span><br><span class="line">    print(&quot;min is \(minMaxValue.min),max is \(minMaxValue.max)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译运行，查看打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min is 1,max is 5</span><br></pre></td></tr></table></figure><h2 id="隐士返回函数"><a href="#隐士返回函数" class="headerlink" title="隐士返回函数"></a>隐士返回函数</h2><ul><li>如果整个函数体是一个单一的表达式，那么函数隐士返回这个表达式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func greet(person: String) -&gt; String&#123;</span><br><span class="line">    &quot;Hello,&quot; + person + &quot;!&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;\(greet(person: &quot;World&quot;))&quot;)</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello,World!</span><br></pre></td></tr></table></figure><h1 id="Swift形式参数和返回值"><a href="#Swift形式参数和返回值" class="headerlink" title="Swift形式参数和返回值"></a>Swift形式参数和返回值</h1><h2 id="实参标签和形参名"><a href="#实参标签和形参名" class="headerlink" title="实参标签和形参名"></a>实参标签和形参名</h2><ul><li><p>每一个函数的形式参数都包含实际参数标签和形式参数名。</p></li><li><p>形式参数必须有唯一的名字，有助于代码易读</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func someFunc(firstParamName:Int,secondParamName:Int)&#123;</span><br><span class="line">    // 形式参数 firstParamName secondParamName</span><br><span class="line">&#125;</span><br><span class="line">someFunc(firstParamName: 1, secondParamName: 2)</span><br></pre></td></tr></table></figure><h2 id="指定实际参数标签"><a href="#指定实际参数标签" class="headerlink" title="指定实际参数标签"></a>指定实际参数标签</h2><ul><li><p>形式参数名之前写实际参数标签，用 <code>空格</code> 分割</p></li><li><p>如果你为 <code>形式参数</code> 定义了 <code>实际参数标签</code>，那么在调用函数的时候必须使用 <code>实际参数标签</code></p></li><li><p>实际参数标签能够让函数的调用更加明确，更像自然语言，更可读，更清晰表达你的意图</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 实际参数标签 home</span><br><span class="line">func greet(person: String, from home: String) -&gt; String &#123;</span><br><span class="line">    return &quot;Hello \(person)! my home is \(home)&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(greet(person: &quot;ZJ&quot;,from: &quot;BeiJing&quot;))</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello ZJ! my home is BeiJing</span><br></pre></td></tr></table></figure><h2 id="省略实际参数标签"><a href="#省略实际参数标签" class="headerlink" title="省略实际参数标签"></a>省略实际参数标签</h2><ul><li>可以利用下划线 <code>_</code> 替代显示的实际参数标签</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func greet(_ person: String, _ home: String) -&gt; String &#123;</span><br><span class="line">    return &quot;Hello \(person)! my home is \(home)&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(greet(person: &quot;ZJ&quot;,from: &quot;BeiJing&quot;))</span><br></pre></td></tr></table></figure><h2 id="默认形式参数值"><a href="#默认形式参数值" class="headerlink" title="默认形式参数值"></a>默认形式参数值</h2><ul><li><p>可以在形式参数类型后，给类型定义一个默认值</p></li><li><p>如果定义了默认值，你就可以在调用的时候省略这个形式参数</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func someFunc(paramDefault: Int = 10) &#123;</span><br><span class="line">    print(&quot;\(paramDefault)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">someFunc(paramDefault: 6)</span><br><span class="line">someFunc()</span><br><span class="line"></span><br><span class="line">===========</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="可变形式参数"><a href="#可变形式参数" class="headerlink" title="可变形式参数"></a>可变形式参数</h2><ul><li><p>一个可变的形式参数可以接受零或多个特定类型的值。</p></li><li><p>通过在形式参数类型名后插入三个点符号 <code>...</code> 来书写可变形式参数。</p></li><li><p>传入到可变参数中的值在函数的主体中被当做是对应类型的 <code>数组</code>。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func changeFunc(_ numbers: Double...) -&gt; Double &#123;</span><br><span class="line">    var total: Double = 0</span><br><span class="line">    for number in numbers &#123;</span><br><span class="line">        total += number</span><br><span class="line">    &#125;</span><br><span class="line">    return total / Double(numbers.count)</span><br><span class="line">&#125;</span><br><span class="line">changeFunc(1,2,3,4,5)</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="输入输出形式参数"><a href="#输入输出形式参数" class="headerlink" title="输入输出形式参数"></a>输入输出形式参数</h2><ul><li><p>可变形式参数只能在函数的内部做改变。如果你想函数能修改一个形式参数的值，而且这些改变在函数结束之后依然生效，那么就需要将形式参数定义为输入输出形式参数</p></li><li><p>输入输出形式参数：在形式参数前边加 <code>inout</code> 关键字。</p></li><li><p>只能把 <code>变量</code> 作为输入输出形式参数的 <code>实际参数</code>，在将变量作为实际参数传入给输入输出形式参数时，在它前边添加一个符号 <code>&amp;</code> 来明确可以被函数修改</p></li><li><p>输入输出形式参数不能有默认值，可变形式参数不能被标记为 <code>inout</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 输入输出形式参数</span><br><span class="line">func swapTwoInt(_ a: inout Int, _ b: inout Int) &#123;</span><br><span class="line">    let temp = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temp</span><br><span class="line">&#125;</span><br><span class="line">var one = 10</span><br><span class="line">var two = 20</span><br><span class="line">swapTwoInt(&amp;one,&amp;two)</span><br><span class="line">print(&quot;\(one) \(two)&quot;)</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">20 10</span><br></pre></td></tr></table></figure><h1 id="函数类型和内嵌函数"><a href="#函数类型和内嵌函数" class="headerlink" title="函数类型和内嵌函数"></a>函数类型和内嵌函数</h1><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><ul><li>每一个函数都有一个特定的函数类型，它由形式参数类型，返回类型组成</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func addTwo(_ a:Int,_ b:Int) -&gt; Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line">let c = addTwo(1,2)</span><br><span class="line">print(&quot;\(c)&quot;)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>和 (Int,Int) -&gt; Int 相关</p><h2 id="使用函数类型"><a href="#使用函数类型" class="headerlink" title="使用函数类型"></a>使用函数类型</h2><ul><li>你可以像使用Swift中的其他类型一样使用函数类型。例如：你可一个常量或变量定义一个函数类型，并且未变量指定一个相应的函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func addTwo(_ a:inout Int,_ b:inout Int) -&gt; Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line">var mathFunc:(inout Int,inout Int) -&gt; Int = addTwo</span><br><span class="line">print(mathFunc(2,3))</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="函数类型作为形式参数类型"><a href="#函数类型作为形式参数类型" class="headerlink" title="函数类型作为形式参数类型"></a>函数类型作为形式参数类型</h2><ul><li>你可以将 <code>函数</code> 作为 <code>其他函数的形式参数</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func addTwo(_ a:Int,_ b:Int) -&gt; Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line">func printResult(_ mathFunc:(Int,Int) -&gt; Int,_ a:Int,_ b:Int) &#123;</span><br><span class="line">    print(&quot;Result:\(mathFunc(a,b))&quot;)</span><br><span class="line">&#125;</span><br><span class="line">printResult(addTwo,2,3)</span><br><span class="line"></span><br><span class="line">==========</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="函数类型作为返回类型"><a href="#函数类型作为返回类型" class="headerlink" title="函数类型作为返回类型"></a>函数类型作为返回类型</h2><ul><li>可以利用函数的类型作为另一个函数的返回类型。写法在函数的返回箭头后写一个完整的函数类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func backF(_ input:Int) -&gt; Int&#123;</span><br><span class="line">    return input - 1</span><br><span class="line">&#125;</span><br><span class="line">func chooseFunc(back: Bool) -&gt; (Int) -&gt; Int &#123;</span><br><span class="line">    return backF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内嵌函数"><a href="#内嵌函数" class="headerlink" title="内嵌函数"></a>内嵌函数</h1><ul><li><p>可以在函数内定义另外一个函数。这就是内嵌函数</p></li><li><p>内嵌函数默认是被隐藏起来的，但仍然可以通过包裹他们的函数来调用他们。</p></li><li><p>包裹的函数也可以返回它内部的一个内嵌函数来在另外的返回里使用</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func chooseFunc(back: Bool) -&gt; (Int) -&gt; Int &#123;</span><br><span class="line">    func stepForward(step:Int) -&gt; Int &#123; return step + 1&#125;</span><br><span class="line">    func stepBackward(step:Int) -&gt; Int &#123; return step - 1&#125;</span><br><span class="line">    return back ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br><span class="line">var current = -4</span><br><span class="line">let stepFunc = chooseFunc(back: current &gt; 0)</span><br><span class="line">while current != 0 &#123;</span><br><span class="line">    current = stepFunc(current)</span><br><span class="line">&#125;</span><br><span class="line">print(current)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">0</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Swift中如何定义和使用函数&quot;&gt;&lt;a href=&quot;#Swift中如何定义和使用函数&quot; class=&quot;headerlink&quot; title=&quot;Swift中如何定义和使用函数&quot;&gt;&lt;/a&gt;Swift中如何定义和使用函数&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
</feed>
