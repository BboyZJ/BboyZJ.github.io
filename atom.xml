<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张建的博客</title>
  <icon>https://www.gravatar.com/avatar/134cc2bfaf649e446f661778f4112fca</icon>
  <subtitle>成功的道路上只有荆棘，没有坦途</subtitle>
  <link href="https://www.bboyzj.cn/atom.xml" rel="self"/>
  
  <link href="https://www.bboyzj.cn/"/>
  <updated>2023-03-16T14:32:52.240Z</updated>
  <id>https://www.bboyzj.cn/</id>
  
  <author>
    <name>小J</name>
    <email>13718004742@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OC面试题：hybrid</title>
    <link href="https://www.bboyzj.cn/2023/03/16/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Ahybrid/"/>
    <id>https://www.bboyzj.cn/2023/03/16/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Ahybrid/</id>
    <published>2023-03-16T08:34:42.000Z</published>
    <updated>2023-03-16T14:32:52.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <code>iOS</code> 开发中，<code>iOS</code> 和 <code>JS</code> 交互是每个程序猿必须掌握的技能。<code>iOS8</code> 以后，苹果推出了新框架 <code>WebKit</code>，使用 <code>WKWebView</code> 替代 <code>UIWebView</code>。</p><p>说道 <code>iOS</code> 和 <code>JS</code> 交互，就不得不提 <code>Hybrid（Hybrid Mobile App）</code>，即通过 <code>Web</code> 网络技术与 <code>Native</code> 相结合的混合移动应用开发</p><blockquote><p><code>WKWebView</code> 特性<br>稳定性好、占用内存少，速度更快<br>高达60fps的滚动刷新率以及内置手势</p></blockquote><p>本文主要介绍 <code>WKWebView</code> 与 <code>JS</code> 交互</p><h1 id="WKWebView-和-JS-交互的方法"><a href="#WKWebView-和-JS-交互的方法" class="headerlink" title="WKWebView 和 JS 交互的方法"></a>WKWebView 和 JS 交互的方法</h1><ol><li>拦截 <code>URL</code></li><li><code>WKScriptMessageHandler</code></li></ol><p>下面以实际功能为例讲解其使用</p><h1 id="WKUserContentController"><a href="#WKUserContentController" class="headerlink" title="WKUserContentController"></a>WKUserContentController</h1><p><code>WKWebView</code> 和 <code>JS</code> 交互，那就得提到 <code>WKUserContentController</code> ，什么是 <code>WKUserContentController</code> ？ <code>WKUserContentController</code> 的作用？</p><ul><li><code>WKUserContentController</code> 可以理解为 <code>调度器</code>，用来与内容交互，即 <code>OC 监听 JS 的方法</code>，下面我们看一下具体有哪些方法：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface WKUserContentController : NSObject &lt;NSCoding&gt;</span><br><span class="line">// 与内容交互的脚本对象数组</span><br><span class="line">@property (nonatomic, readonly, copy) NSArray&lt;WKUserScript *&gt; *userScripts; </span><br><span class="line">// 添加一个脚本，可以理解为注入一个对象</span><br><span class="line">- (void)addUserScript:(WKUserScript *)userScript;</span><br><span class="line"></span><br><span class="line">// 移除所有脚本</span><br><span class="line">- (void)removeAllUserScripts; </span><br><span class="line"></span><br><span class="line">// 添加 scriptMessageHandler 到所有的 frames 中，html5中需要添加 window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;) 方法，来实现js与oc之间的桥梁，即 OC 监听 JS 的方法</span><br><span class="line">- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;</span><br><span class="line"></span><br><span class="line">// 根据 name 移除所注入的 scriptMessageHandler</span><br><span class="line">- (void)removeScriptMessageHandlerForName:(NSString *)name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>示例：</li></ul><blockquote><p><code>JS</code> 与 <code>OC</code> 约定好方法，用作 <code>JS</code> 调用 <code>OC</code> 时的方法，如 <code>ShowMessageFromWKWebView:</code><br><code>OC</code> 使用 <code>WKUserContentController</code> 的 <code>addScriptMessageHandler:name:</code> 方法监听 <code>name</code> 为 <code>ShowMessageFromWKWebView</code> 的消息<br><code>JS</code> 通过 <code>window.webkit.messageHandlers.scan.postMessage()</code> 的方式对 <code>scan</code> 方法发送消息<br><code>OC</code> 在 <code>WKScriptMessageHandler</code> 的代理协议回调 <code>userContentController:didReceiveScriptMessage:</code> 方法中读取 <code>name</code> 为 <code>ShowMessageFromWKWebView</code> 的消息数据 <code>message.body</code></p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupWKWebView&#123;</span><br><span class="line">    WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];</span><br><span class="line">    configuration.userContentController = [[WKUserContentController alloc] init];</span><br><span class="line">    </span><br><span class="line">    // OC 监听 JS 方法</span><br><span class="line">    [configuration.userContentController addScriptMessageHandler:self name:@&quot;scan&quot;];</span><br><span class="line"></span><br><span class="line">    WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];</span><br><span class="line">    webView.UIDelegate = self;</span><br><span class="line">    [self.view addSubview:self.wkWebV];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>h5中要实现的代码</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function showMessageFromWKWebViewClick() &#123;</span><br><span class="line">    // JS 发送消息到 OC</span><br><span class="line">window.webkit.messageHandlers.ShowMessageFromWKWebView.postMessage(&#123;title:&#x27;WKWebView&#x27;, message:&#x27;测试WKWebView和OC交互&#x27;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>实现 <code>WKScriptMessageHandler</code> 代理方法，当 <code>JS</code> 调用 <code>ShowMessageFromWKWebView</code> 方法时，会回调此代理方法：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - WKScriptMessageHandler</span><br><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123;</span><br><span class="line">// 从协议中我们可以看出这里使用了两个类 WKUserContentController 和 WKScriptMessage。WKUserContentController 可以理解为 调度器，WKScriptMessage 则是携带的数据。</span><br><span class="line">    </span><br><span class="line">    // OC 读取 JS 的消息数据</span><br><span class="line">    NSLog(@&quot;body:%@&quot;,message.body);</span><br><span class="line">    if ([message.name isEqualToString:@&quot;ShowMessageFromWKWebView&quot;]) &#123;</span><br><span class="line">        NSDictionary * dict = message.body;</span><br><span class="line">        NSString * messageStr = [dict objectForKey:@&quot;message&quot;];</span><br><span class="line">        NSString * titleStr = [dict objectForKey:@&quot;title&quot;];</span><br><span class="line">        NSLog(@&quot;messageStr:%@&quot;,messageStr);</span><br><span class="line">        NSLog(@&quot;titleStr:%@&quot;,titleStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="OC-调用-JS"><a href="#OC-调用-JS" class="headerlink" title="OC 调用 JS"></a>OC 调用 JS</h1><ul><li><code>OC</code> 调用 <code>JS</code> 方法用 <code>evaluateJavaScript</code>，可以 <code>传递参数</code>，将拼接字符串传递给 <code>JS</code>，拼接的字符串有格式要求：<code>方法名(&#39;参数&#39;)</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// OC传值JS的代码</span><br><span class="line">NSString * returnJSStr = [NSString stringWithFormat:@&quot;showMessageFromWKWebViewResult(&#x27;%@&#x27;)&quot;, @&quot;message传到OC成功，message传到OC成功，message传到OC成功，message传到OC成功，message传到OC成功，message传到OC成功&quot;];</span><br><span class="line">[self.wkWebV evaluateJavaScript:returnJSStr completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123;</span><br><span class="line">    NSLog(@&quot;%@,%@&quot;,result,error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></div><ul><li>JS 接收 OC 消息</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// JS 接收 OC 消息</span><br><span class="line">function showMessageFromWKWebViewResult(returnStr) &#123;</span><br><span class="line">    if (returnStr != null) &#123;</span><br><span class="line">        alert(&quot;JS已经收到OC的传值&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    document.getElementById(&quot;returnTextrea&quot;).value = returnStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="拦截-URL-实现自定义跳转功能"><a href="#拦截-URL-实现自定义跳转功能" class="headerlink" title="拦截 URL 实现自定义跳转功能"></a>拦截 URL 实现自定义跳转功能</h1><p>通过 <code>WKWebView</code> 代理回调 <code>WKNavigationDelegate</code> 拦截 <code>URL</code> 方式可以实现，点击WebView按钮、cell等事件，去做一些功能</p><ul><li>在发送请求之前，决定是否跳转</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123;</span><br><span class="line">    // 获取当前的url</span><br><span class="line">    NSString * url = navigationAction.request.URL.absoluteString;</span><br><span class="line">    ZJLog(@&quot;url:%@&quot;,url);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>动态控制是否允许跳转和跳转到哪里</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -处理客服中心按钮的点击事件</span><br><span class="line">- (void)handleCallCenterClickActionWithUrl:(NSString *)url decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123;</span><br><span class="line">    ZJLog(@&quot;url:%@&quot;,url);</span><br><span class="line">    if ([url containsString:@&quot;cloudapp://goodsDetail?goodsId=&quot;]) &#123; // 跳转商品详情</span><br><span class="line">        // 去掉前缀</span><br><span class="line">        NSArray * arr = [url componentsSeparatedByString:@&quot;goodsId=&quot;];</span><br><span class="line">        NSString * goodsId = arr.lastObject;</span><br><span class="line">        SFGoodsDetailVC * goodsDetailVc = [SFGoodsDetailVC new];</span><br><span class="line">        goodsDetailVc.goodsId = [goodsId integerValue];</span><br><span class="line">        goodsDetailVc.enterType = GoodsDetailEnterType_Normal;</span><br><span class="line">        goodsDetailVc.souce = CommodityDetailSouce_Banner; // 首页Banner</span><br><span class="line">        [self.navigationController pushViewController:goodsDetailVc animated:YES];</span><br><span class="line">        // 拦截跳转</span><br><span class="line">        decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">    &#125; else &#123; // 其他</span><br><span class="line">        // 不拦截跳转</span><br><span class="line">        decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="KVO-监听"><a href="#KVO-监听" class="headerlink" title="KVO 监听"></a>KVO 监听</h1><ul><li>监听标题 title</li></ul><p>通过 <code>KeyPath路由</code> 监听 <code>title</code> 可以 动态修改 <code>title</code></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 监听标题</span><br><span class="line">[self.wkWebV zj_addObserver:self forKeyPath:@&quot;title&quot;];</span><br></pre></td></tr></table></figure></div><ul><li>监听进度 <code>estimatedProgress</code></li></ul><p>通过监听 <code>estimatedProgress</code> 可以做 <code>进度条</code></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 添加监听</span><br><span class="line">[self.wkWebV zj_addObserver:self forKeyPath:@&quot;estimatedProgress&quot;];</span><br></pre></td></tr></table></figure></div><ul><li>监听 URL</li></ul><p>通过 <code>监听URL</code>，即在跳转过程中 <code>拦截URL</code>，可以去做一些 动态跳转到 <code>OC</code> 页面</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 监听跳转</span><br><span class="line">[self.wkWebV zj_addObserver:self forKeyPath:@&quot;URL&quot;];</span><br></pre></td></tr></table></figure></div><ul><li>监听的方式代码实现</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -进度的监听</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    NSString * url = self.wkWebV.URL.absoluteString;</span><br><span class="line">    ZJLog(@&quot;url:%@&quot;,url);</span><br><span class="line">    if (object == self.wkWebV &amp;&amp; [keyPath isEqualToString:@&quot;title&quot;]) &#123; // 标题</span><br><span class="line">        if (self.wkWebV.title.length &gt; 0) &#123;</span><br><span class="line">            [self.navStatusV.titleL setTitle:self.wkWebV.title titleColor:kMainTextColor font:16 isBlod:YES];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if (object == self.wkWebV &amp;&amp; [keyPath isEqualToString:@&quot;estimatedProgress&quot;]) &#123; // 进度条</span><br><span class="line">        CGFloat newProgress = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue];</span><br><span class="line">//        ZJLog(@&quot;newProgress:%f&quot;,newProgress);</span><br><span class="line">        if (newProgress &lt;= 0.05f) &#123;</span><br><span class="line">            newProgress = 0.05f;</span><br><span class="line">        &#125;</span><br><span class="line">        [self.progressV changeProgressValue:newProgress];</span><br><span class="line">    &#125;else if (object == self.wkWebV &amp;&amp; [keyPath isEqualToString:@&quot;/cloudApp/customer/service&quot;]) &#123;</span><br><span class="line">        // 跳转到客服中心</span><br><span class="line">        ZJLog(@&quot;跳转到客服中心&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 &lt;code&gt;iOS&lt;/code&gt; 开发中，&lt;code&gt;iOS&lt;/code&gt; 和 &lt;code&gt;JS&lt;/code&gt; 交互是每个程序猿必须掌握</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-面试题" scheme="https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习：国际化/多语言适配</title>
    <link href="https://www.bboyzj.cn/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%9B%BD%E9%99%85%E5%8C%96-%E5%A4%9A%E8%AF%AD%E8%A8%80%E9%80%82%E9%85%8D/"/>
    <id>https://www.bboyzj.cn/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%9B%BD%E9%99%85%E5%8C%96-%E5%A4%9A%E8%AF%AD%E8%A8%80%E9%80%82%E9%85%8D/</id>
    <published>2023-03-14T22:27:39.000Z</published>
    <updated>2023-03-15T13:01:04.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>项目开发中不同语言环境需要进行多语言适配，例如：中文、英语、法语、俄语、葡萄牙语等</p><ul><li>纯代码界面开发时，直接添加本地化语言文件，并针对键值对获取即可</li></ul><p>下面我们来介绍如何国际化：</p><h1 id="全局添加需要适配的多语言"><a href="#全局添加需要适配的多语言" class="headerlink" title="全局添加需要适配的多语言"></a>全局添加需要适配的多语言</h1><p>PROHECT -&gt; Info -&gt; Localizetions 下：选择 + 号添加：</p><blockquote><p>Chinese，Simplified：中文简体<br>Chinese，Traditional：中文繁体<br>English - Development Localization：英语<br>French(fr)：法语<br>Russian：俄语<br>Arabic：阿拉伯语<br>…</p></blockquote><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150647485.png"></p><p>添加完成之后的效果：</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303152059213.png"></p><p>细心的朋友会发现如今 <code>English</code> 后面是 <code>1 File Localized</code>，这是因为 <code>英语</code> 是系统默认加入的，并且同一时刻为 <code>Main.storyboard</code> 和 <code>LaunchScreen.storyboard</code> 设置了多语言</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303152100754.png"></p><h1 id="纯代码本地化"><a href="#纯代码本地化" class="headerlink" title="纯代码本地化"></a>纯代码本地化</h1><ol><li>创建本地化文件</li></ol><p>默认文件名为 <code>Localizable</code> ，不要去修改</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303152100712.png"></p><ul><li>点击 Next，Save <code>As：Localizable</code></li></ul><p><img src="/BboyZJ.github.io/assets/16788344378490.jpg"></p><p><code>Localizable.strings</code> 就是你需要的本地化文化</p><ul><li>关联对应的本地化语言</li></ul><p>点击右侧的 <code>Localizable</code>，关联本地化语言</p><p><img src="/BboyZJ.github.io/assets/16788343879290.jpg"></p><ul><li>勾选需要关联的本地化语言，全部勾选</li></ul><p><img src="/BboyZJ.github.io/assets/16788345844259.jpg"></p><ol start="2"><li>在本地化文件中设置 <code>Key-Value</code></li></ol><blockquote><p>注意：不要忘记行末的 <code>;</code> 号</p></blockquote><p>分别在对应的本地化语言文件中，设置不同的 <code>Key-Value</code></p><p><img src="/BboyZJ.github.io/assets/16788354350249.jpg"></p><p><img src="/BboyZJ.github.io/assets/16788358454248.jpg"></p><p><img src="/BboyZJ.github.io/assets/16788358608465.jpg"></p><ol start="3"><li>调用本地化</li></ol><ul><li><p>使用 <code>NSLocalizedString</code> 函数来访问 <code>Localizable.strings</code> 资源文件</p></li><li><p><code>NSLocalizedString</code> 函数第一个参数为对应的 <code>键名</code>，第二个是自定义的说明，给开发或翻译人员看的。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 调用字符串对应的本地化符号</span><br><span class="line">let title = NSLocalizedString(&quot;title&quot;, comment: &quot;title&quot;)</span><br><span class="line">MyLog(message: title)</span><br></pre></td></tr></table></figure><blockquote><p>这种设置完之后仅仅能让应用随系统的语言进行切换，而用户不能手进行切换</p></blockquote><h1 id="图片本地化"><a href="#图片本地化" class="headerlink" title="图片本地化"></a>图片本地化</h1><ol><li>选中需要本地化的图片，同上面一样点击 <code>Localize...</code> ，创建本地化 <code>图片资源文件</code></li></ol><p><img src="/BboyZJ.github.io/assets/16788751048540.jpg"></p><ol start="2"><li>关联你需要本地化的语言</li></ol><p><img src="/BboyZJ.github.io/assets/16788751873198.jpg"></p><p><img src="/BboyZJ.github.io/assets/16788752108974.jpg"></p><ol start="3"><li>图片 <code>Show In Finder</code>，可以看到在 中文和英文资源下都有这个图片，把需要替换的图片换掉即可</li></ol><p><img src="/BboyZJ.github.io/assets/16788753309403.jpg"></p><ol start="4"><li>图片使用和平常一样</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let img = UIImage(named: &quot;loading.png&quot;)</span><br></pre></td></tr></table></figure><h1 id="App-名称的-本地化"><a href="#App-名称的-本地化" class="headerlink" title="App 名称的 本地化"></a>App 名称的 本地化</h1><ol><li>要实现应用名称根据语言环境显示不一样的名称，只需要创建 <code>InfoPlist.strings</code> 文件，创建 <code>InfoPlist.strings</code> 并关联语言</li></ol><p><img src="/BboyZJ.github.io/assets/16788756214245.jpg"></p><ol start="2"><li>获取info.plist中的key</li></ol><p>点击 <code>Infoplist</code> 右键选择 <code>Open As -&gt; Source Code</code>，查看我们所要获取权限的原始key。</p><p><img src="/BboyZJ.github.io/assets/16788378592924.jpg"></p><p>新版Xcode获取不出来数据不用急，去代码中将info打印出来，拿到key效果一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let infoPlist = Bundle.main.infoDictionary</span><br><span class="line">MyLog(message: infoPlist)</span><br></pre></td></tr></table></figure><ol start="3"><li>本地化文件中，对key-value进行配置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Chinese,Simplified</span><br><span class="line">&quot;CFBundleDisplayName&quot; = &quot;中图云书房&quot;</span><br><span class="line"></span><br><span class="line">// Englist</span><br><span class="line">&quot;CFBundleDisplayName&quot; = &quot;SRSF&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>运行App，然后切换手机语言为英文，会发现软件名称变成了英文</li></ol><h1 id="Xcode中切换语言"><a href="#Xcode中切换语言" class="headerlink" title="Xcode中切换语言"></a>Xcode中切换语言</h1><p>为了调试国际化，我们除了可以进入 <code>模拟器或真机</code> 切换系统语言，也可以在 <code>Xcode</code> 中配置相关项，使 <code>Debug</code> 环境下运行时预览不同语言和地区 App的界面效果</p><ol><li>选择 Product -&gt; Scheme -&gt; Edit Scheme</li></ol><p><img src="/BboyZJ.github.io/assets/16788759582575.jpg"></p><ol start="2"><li>切换语言后，运行工程</li></ol><h1 id="应用内切换语言"><a href="#应用内切换语言" class="headerlink" title="应用内切换语言"></a>应用内切换语言</h1><p>纯代码本地化只能跟随系统进行切换，并不能手动进行切换，下面先介绍一下相关宏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 尾随系统切换, 多语言文件名称必须是Localizable</span><br><span class="line">NSLocalizedString(&quot;title&quot;, nil);</span><br><span class="line"></span><br><span class="line">// 以下三个都能够手动设置多语言</span><br><span class="line">// 第一个參数:是多语言中的key</span><br><span class="line">// 第二个參数:是多语言文件的名字</span><br><span class="line">// 第三个參数:是对key的自定义的说明,一般传nil</span><br><span class="line">NSLocalizedStringFromTable(@&quot;title&quot;, @&quot;Localizable&quot;, nil);</span><br><span class="line">// 指定多语言文件名称和bundle</span><br><span class="line">NSLocalizedStringFromTableInBundle(@&quot;title&quot;, @&quot;Localizable&quot;, bundle, nil);</span><br><span class="line">// 在上面的基础上添加一个默认值的參数</span><br><span class="line">NSLocalizedStringWithDefaultValue(@&quot;title&quot;, @&quot;Localizable&quot;, bundle, @&quot;label&quot;, nil);</span><br></pre></td></tr></table></figure><ol><li>Resources -&gt; Show In Finder后，发现每一种语言都有对应的文件目录，后缀是 <code>.lproj</code></li></ol><p><img src="/BboyZJ.github.io/assets/16788765439649.jpg"></p><blockquote><p>总结：<br>因此 <code>ar.lproj、en.lproj、fr.lproj、ru.lproj、zh-Hans.lproj、zh-Hant.lproj</code> 为我们可以从本地获取到的 <code>语言资源文件</code><br>在 <code>App</code> 内切换语言的时候，实际上就是获取 <code>语言资源文件</code> 的 <code>Localizable.strings</code> 文件</p></blockquote><ol start="2"><li>将所有的 <code>语言文件</code> 设置成 <code>字符串类型的枚举</code> 并且有初始值 <code>rawValue</code>， 获取 <code>Localizable.strings</code></li></ol><ul><li>获取 <code>某语言</code> 文件的 <code>value值</code>，相应的想要切换语言的话，直接切换 <code>pathForResource</code> 面的 <code>参数</code> 就可以</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 本地化语言类型</span><br><span class="line">enum LocalizedType: String &#123;</span><br><span class="line">    // 字符串需要对应本地的国际化文件名 .lproj</span><br><span class="line">    case English = &quot;en&quot; // 英语</span><br><span class="line">    case ChineseHans = &quot;zh-Hans&quot; // 简体中文</span><br><span class="line">    case ChineseHant = &quot;zh-Hant&quot; // 繁体中文</span><br><span class="line">    case Russian = &quot;ru&quot; // 俄语</span><br><span class="line">    case Frcench = &quot;fr&quot; // 法语</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取语言文件路径(可以为：en/zh-Hans/zh-Hant/fr/ru 任意一个)</span><br><span class="line">let languageBundlePath = Bundle.main.path(forResource: LocalizedType.English, ofType: &quot;lproj&quot;)</span><br><span class="line">// 获取语言文件路径下对应 key 的 value</span><br><span class="line">let value = Bundle(path: languageBundlePath ?? &quot;&quot;)?.localizedString(forKey: &quot;title&quot;, value: nil, table: &quot;ZJLocalizable&quot;)</span><br><span class="line">MyLog(message: value) </span><br></pre></td></tr></table></figure><ol start="3"><li>根据上面的思路，我们可以用 <code>NSUserDefaults</code> 缓存当前的 <code>语言</code>，以便 <code>第一次启动程序</code> 或 <code>程序退出去后</code>，下次进入继续使用上次关闭程序的语言。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 本地化语言类型</span><br><span class="line">enum LocalizedType: String &#123;</span><br><span class="line">    // 字符串需要对应本地的国际化文件名 .lproj</span><br><span class="line">    case English = &quot;en&quot; // 英语</span><br><span class="line">    case ChineseHans = &quot;zh-Hans&quot; // 简体中文</span><br><span class="line">    case ChineseHant = &quot;zh-Hant&quot; // 繁体中文</span><br><span class="line">    case Russian = &quot;ru&quot; // 俄语</span><br><span class="line">    case Frcench = &quot;fr&quot; // 法语</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化启动时语言</span><br><span class="line">func initLaunchLanguage() &#123;</span><br><span class="line">    // 获取上一次设置的语言</span><br><span class="line">    var languageType = kUserDefault.getInfo(key: &quot;appLanguage&quot;)</span><br><span class="line">    // 如果是第一次启动</span><br><span class="line">    if languageType == nil &#123;</span><br><span class="line">        // 获取系统第一个首选语言</span><br><span class="line">        let systemLanguage = Locale.preferredLanguages.first!</span><br><span class="line">        MyLog(message: systemLanguage)</span><br><span class="line">        if systemLanguage.hasPrefix(LocalizedType.English.rawValue) &#123;</span><br><span class="line">            // 英文</span><br><span class="line">            languageType = LocalizedType.English.rawValue</span><br><span class="line">        &#125;else if systemLanguage.hasPrefix(LocalizedType.ChineseHans.rawValue) &#123;</span><br><span class="line">            // 简体中文</span><br><span class="line">            languageType = LocalizedType.ChineseHans.rawValue</span><br><span class="line">        &#125;else if systemLanguage.hasPrefix(LocalizedType.ChineseHant.rawValue) &#123;</span><br><span class="line">            // 繁体中文</span><br><span class="line">            languageType = LocalizedType.ChineseHant.rawValue</span><br><span class="line">        &#125;else if systemLanguage.hasPrefix(LocalizedType.Frcench.rawValue) &#123;</span><br><span class="line">            // 法文</span><br><span class="line">            languageType = LocalizedType.Frcench.rawValue</span><br><span class="line">        &#125;else if systemLanguage.hasPrefix(LocalizedType.Russian.rawValue) &#123;</span><br><span class="line">            // 俄文</span><br><span class="line">            languageType = LocalizedType.Russian.rawValue</span><br><span class="line">        &#125;</span><br><span class="line">        // 赋值给上一次设置的语言类型</span><br><span class="line">        languageType = systemLanguage</span><br><span class="line">    &#125;</span><br><span class="line">    // 缓存语言</span><br><span class="line">    kUserDefault.saveInfo(value: languageType!, key: &quot;appLanguage&quot;)</span><br><span class="line">    // 设置bundle</span><br><span class="line">    setCurrentBundle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：<br>每次设置完语言，我们跟要更新一下 <code>bundle</code>，以便随时获取 <code>key-value</code></p></blockquote><ol start="3"><li>接下来，我们要根据缓存的语言来获取本地语言资源文件，赋值给一个全局的 bundle，以便随时可以通过 bundle 来拿到具体语言文件下的 keu-value</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 设置bundle</span><br><span class="line">func setCurrentBundle() &#123;</span><br><span class="line">    // 拿到当前语言</span><br><span class="line">    let currentLanguageType = kUserDefault.getInfo(key: &quot;appLanguage&quot;) as! String</span><br><span class="line">    // 获取本地语言资源路径</span><br><span class="line">    let languageBundlePath = Bundle.main.path(forResource: currentLanguageType, ofType: &quot;lproj&quot;)</span><br><span class="line">//        MyLog(message: languageBundlePath)</span><br><span class="line">    guard languageBundlePath != nil else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取 bundle</span><br><span class="line">    let languageBundle = Bundle(path: languageBundlePath!)</span><br><span class="line">    guard languageBundle != nil else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // 赋值给全局的 bundle</span><br><span class="line">    currentBundle = languageBundle</span><br><span class="line">//        MyLog(message: currentBundle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>根据 key 获取 value</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取要显示的文本</span><br><span class="line">func getLanguageValueWithKey(key: String) -&gt; String &#123;</span><br><span class="line">    let bundle = LocalizableManager.sharedManager.currentBundle</span><br><span class="line">    let value = bundle?.localizedString(forKey: key, value: nil, table: nil)</span><br><span class="line">    return value ?? &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>至此，我们的 <code>App内+系统</code> 切换国际化语言，大功告成！！！</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;项目开发中不同语言环境需要进行多语言适配，例如：中文、英语、法语、俄语、葡萄牙语等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;纯代码界面开发时，直接添加本地</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Blog-06：阿里云图床</title>
    <link href="https://www.bboyzj.cn/2023/03/15/Blog%E6%90%AD%E5%BB%BA/Blog-06%EF%BC%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9B%BE%E5%BA%8A/"/>
    <id>https://www.bboyzj.cn/2023/03/15/Blog%E6%90%AD%E5%BB%BA/Blog-06%EF%BC%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9B%BE%E5%BA%8A/</id>
    <published>2023-03-14T21:11:50.000Z</published>
    <updated>2023-03-14T22:11:14.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近Gitee突然加了防盗链，导致基于Gitee的图床直接GG了！好家伙还带这样玩的，数据要是没有备份真的心惊胆跳的，不白嫖了，直接付费转战阿里云OSS去。</p><p>​分享一下搭建过程:<br>​</p><h1 id="阿里云OSS开通及配置"><a href="#阿里云OSS开通及配置" class="headerlink" title="阿里云OSS开通及配置"></a>阿里云OSS开通及配置</h1><p>​<br>​1、开通及购买服务包<br>​<br>​登录 <a href="https://www.aliyun.com/?utm_content=se_1013083955">阿里云官网</a>，开通对象存储OSS，开通对象存储OSS不用扣费，只有使用OSS才需要扣费。<br>​​<br>​​<br>​​<img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150611729.png"></p><p>2、OSS有两种扣费方式（产品计费详细介绍）：</p><ul><li><p><a href="https://help.aliyun.com/document_detail/450471.html">按量付费</a></p></li><li><p><a href="https://help.aliyun.com/document_detail/48291.html">资源包</a></p></li></ul><p>根据需要按需购买对应的 <code>资源包</code> 即可，作为一个只是搭建个人向图床的我，只需要购买一个 <code>40GB</code> 的《标准(LRS)存储包》即可，半年只要4.98，四舍五入相当于白嫖……</p><p>我每个月也用不了多少流量，《下行流量包》先暂时不购买，要是后续那天顶不住后再考虑购买即可。</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610052.png"></p><ul><li>根据需求选择 <code>购买时长</code>，最后支付</li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610166.png"></p><blockquote><p>注意事项：<br>记得给阿里云账户充值！！！别到时候欠费停用了</p></blockquote><p>3、基础配置</p><ul><li>创建 Bucket</li></ul><p>打开 <a href="https://oss.console.aliyun.com/bucket">OSS管理控制台Bucket页面</a>，按需创建一个Bucket。</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610062.png"></p><blockquote><p>Bucket 名称：bboy-blog（自定义）<br>地域：华北2（选择最近）<br>存储类型：标准存储<br>读写权限：公共读<br>其他：默认不改动</p></blockquote><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610598.png"></p><p>创建完成你的 <code>Bucket</code> 就在列表显示了</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610981.png"></p><ul><li>找到你的地域节点</li></ul><p>点击你的 <code>bucket</code>，然后点击 <code>bucket</code> 下的 <code>概览</code>，在 <code>访问域名</code> 一栏找你的 <code>地域节点</code>，后面会用到</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150609099.png"></p><ul><li>找到你的 key</li></ul><p>右上角找到头像，在弹出框里选择 <code>AccessKey</code> 管理，在弹出框选择 <code>继续使用</code></p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150609401.png"></p><p>进入后，创建一个新的 <code>AccessKey</code>，在弹出框里，复制你的 <code>AccessKeyId和AccessKeySecret</code>，保存好，以便后续使用</p><h1 id="配置-picgo"><a href="#配置-picgo" class="headerlink" title="配置 picgo"></a>配置 picgo</h1><p>1、打开picgo，在图床设置里选择 <code>阿里云OSS</code>，一招以下步骤填写信息</p><blockquote><p>设定Keyld：必填，填写刚刚获得的AccessKeyID<br>设定KeySecret：必填，填写AccessKeyIDSecret<br>设定Bucket：必填 bboy-blog，填写bucket名称（这里填写的是bucket名称，不是浏览器里的域名）<br>确认存储区域：必填 oss-cn-beijing，填写你的地域节点，注意复制的格式<br>设定存储路径：选填，其实就是自定义一个文件夹的名字，以&#x2F;结尾，它会自动在你的bucket里面创建一个文件夹，并把图片上传进去<br>指定自定义域名：选填</p></blockquote><p>2、配置完成之后，<code>确定</code>，并点击 <code>设置为默认图床</code></p><p>3、PicGo设置</p><p>打开 <code>时间戳重命名</code> 和 <code>上传后自动赋值URL</code> 选项</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150608665.png"></p><p>4、至此，你已经配置成功了，可以随意用 <code>PicGo</code> 上传图片了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近Gitee突然加了防盗链，导致基于Gitee的图床直接GG了！好家伙还带这样玩的，数据要是没有备份真的心惊胆跳的，不白嫖了，直接付费转战</summary>
      
    
    
    
    <category term="Blog" scheme="https://www.bboyzj.cn/categories/Blog/"/>
    
    
    <category term="博客搭建" scheme="https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习：自定义Log</title>
    <link href="https://www.bboyzj.cn/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89Log/"/>
    <id>https://www.bboyzj.cn/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89Log/</id>
    <published>2023-03-14T20:26:24.000Z</published>
    <updated>2023-03-14T20:50:42.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打印文件名、方法、行数"><a href="#打印文件名、方法、行数" class="headerlink" title="打印文件名、方法、行数"></a>打印文件名、方法、行数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1.获取打印所在的文件</span><br><span class="line">let file = (#file as NSString).lastPathComponent;</span><br><span class="line">print(file);</span><br><span class="line"></span><br><span class="line">// 2.获取打印所在的方法</span><br><span class="line">let function = #function</span><br><span class="line">print(function);</span><br><span class="line"></span><br><span class="line">// 3.获取打印所在的行号</span><br><span class="line">let line = #line;</span><br><span class="line">print(line)</span><br></pre></td></tr></table></figure><h1 id="全局化"><a href="#全局化" class="headerlink" title="全局化"></a>全局化</h1><p><code>swift</code> 中的 全局函数：写在单独的一个 <code>.swift</code> 文件下即可，比如：Common.swift</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func ZNLog&lt;T&gt;(message:T, file:String = #file, funcName:String = #function, lineNum:Int = #line) &#123;</span><br><span class="line"></span><br><span class="line">     let fileName = (file as NSString).lastPathComponent;</span><br><span class="line"></span><br><span class="line">     print(&quot;[文件名:\(fileName)]:[函数名:\(funcName)]:[行数:\(lineNum)]-打印内容:\n\(message)&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置DeBug下打印，Release-下不打印"><a href="#配置DeBug下打印，Release-下不打印" class="headerlink" title="配置DeBug下打印，Release 下不打印"></a>配置DeBug下打印，Release 下不打印</h1><p>swift 没有宏定义，只能通过添加配置字段</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303150447405.png"></p><h1 id="最终写法"><a href="#最终写法" class="headerlink" title="最终写法"></a>最终写法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 自定义Log</span><br><span class="line">func MyLog&lt;T&gt;(message: T,file: String = #file, funcName: String = #function, lineNum: Int = #line) &#123;</span><br><span class="line">#if DEBUG</span><br><span class="line">    let fileName = (file as NSString).lastPathComponent</span><br><span class="line">    print(&quot;[文件名:\(fileName)]:[函数名:\(funcName)]:[行数:\(lineNum)]-打印内容:\n\(message)&quot;);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;打印文件名、方法、行数&quot;&gt;&lt;a href=&quot;#打印文件名、方法、行数&quot; class=&quot;headerlink&quot; title=&quot;打印文件名、方法、行数&quot;&gt;&lt;/a&gt;打印文件名、方法、行数&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习49：Any</title>
    <link href="https://www.bboyzj.cn/2023/03/14/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A049%EF%BC%9AAny/"/>
    <id>https://www.bboyzj.cn/2023/03/14/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A049%EF%BC%9AAny/</id>
    <published>2023-03-13T22:34:03.000Z</published>
    <updated>2023-03-13T22:49:03.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Swift中，Objective-C中的 <code>id</code> 类型现在映射成了Swift中的 <code>Any</code> 类型，它可以代表任何类型的值，无论是类、枚举、结构体还是任何其他Swift类型。这种变化使得Swift中的Objective-C API更加灵活，因为Swift定义的值类型可以传递给Objective-C API并作为Swift中的类型获取，从而无需手动“框选”类型（本人理解为转换、解包）。</p><h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><p>对于Swift中哈希类的集合，例如Dictionary和Set，有一个新类型 <code>AnyHashable</code>，可以保存任何遵守Swift中 <code>Hashable</code> 协议的类型的值。。<code>Array</code> 对应 <code>Any</code> </p><h1 id="非集合类型"><a href="#非集合类型" class="headerlink" title="非集合类型"></a>非集合类型</h1><ul><li><p>属性列表，JSON和用户信息字典在Cocoa框架中很常见，Cocoa框架将这些表示为非类型化集合。</p></li><li><p>Swift可以导入 <code>Cocoa API</code> 接受 <code>Any或AnyHashable</code> 类型的集合，所以我们可以用[AnyHashable：Any]</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Swift 3</span><br><span class="line">struct State &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var abbreviation: String</span><br><span class="line">    var population: Int</span><br><span class="line"></span><br><span class="line">    // Change the dictionary type to [AnyHashable: Any] here...</span><br><span class="line">    var asPropertyList: [AnyHashable: Any] &#123;</span><br><span class="line">        var result: [AnyHashable: Any] = [:]</span><br><span class="line">        // No implicit conversions necessary, since String and Int are subtypes</span><br><span class="line">        // of Any and AnyHashable</span><br><span class="line">        result[&quot;name&quot;] = self.name</span><br><span class="line">        result[&quot;abbreviation&quot;] = self.abbreviation</span><br><span class="line">        result[&quot;population&quot;] = self.population</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let california = State(name: &quot;California&quot;,</span><br><span class="line">                       abbreviation: &quot;CA&quot;,</span><br><span class="line">                       population: 39_000_000)</span><br><span class="line">// ...and you can still use it with Cocoa API here</span><br><span class="line">Notification(name: &quot;foo&quot;, object: nil,</span><br><span class="line">             userInfo: california.asPropertyList)</span><br></pre></td></tr></table></figure><h1 id="未链接上下文的显式转换"><a href="#未链接上下文的显式转换" class="headerlink" title="未链接上下文的显式转换"></a>未链接上下文的显式转换</h1><p>在某些确定的情况下，Swift不能自动桥接C和Objective-C。 例如，一些C和Cocoa API使用id *指针作为“out”或“in-out”参数，并且由于Swift不能静态地确定指针的使用方式，因此它不能对内存中的值自动执行桥接转换 。 在这种情况下，指针仍将显示为UnsafePointer <AnyObject>。 如果您需要使用到这些不能自动桥接转换的API，您可以使用显式桥接转换，在代码中使用 <code>as Type</code> 或 <code>as AnyObject</code> 显式转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ObjC</span><br><span class="line">@interface Foo</span><br><span class="line">- (void)updateString:(NSString **)string;</span><br><span class="line">- (void)updateObject:(id *)obj;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Swift</span><br><span class="line">func interactWith(foo: Foo) -&gt; (String, Any) &#123;</span><br><span class="line">    var string = &quot;string&quot; as NSString // explicit conversion</span><br><span class="line">    foo.updateString(&amp;string) // parameter imports as UnsafeMutablePointer&lt;NSString&gt;</span><br><span class="line">    let finishedString = string as String</span><br><span class="line"></span><br><span class="line">    var object = &quot;string&quot; as AnyObject</span><br><span class="line">    foo.updateObject(&amp;object) // parameter imports as UnsafeMutablePointer&lt;AnyObject&gt;</span><br><span class="line">    let finishedObject = object as Any</span><br><span class="line"></span><br><span class="line">    return (finishedString, finishedObject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，Objective-C中的协议在Swift中仍然是类约束（及只有类才可以遵守协议），所以你不能让Swift中的结构体或枚举直接遵守Objective-C中的协议或者是使用轻量级的泛型类。 当您需要使用到这些协议和API时应该像这样 <code>String as NSString</code>、<code>Array as NSArray</code> 进行显式转换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在Swift中，Objective-C中的 &lt;code&gt;id&lt;/code&gt; 类型现在映射成了Swift中的 &lt;code&gt;Any&lt;/code&gt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习48：ARC</title>
    <link href="https://www.bboyzj.cn/2023/03/13/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A048%EF%BC%9AARC/"/>
    <id>https://www.bboyzj.cn/2023/03/13/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A048%EF%BC%9AARC/</id>
    <published>2023-03-13T09:44:18.000Z</published>
    <updated>2023-03-13T22:34:49.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h1><ul><li><p>swift 使用 <code>自动引用计数（ARC）</code> 来跟踪并管理应用使用的 <code>内存</code>。</p></li><li><p><code>引用计数</code> 只应用在 <code>类</code> 的实例。</p></li><li><p><code>结构体和枚举</code> 都是 <code>值类型</code>，并非引用类型，不是以引用的方式来 <code>存储和传递</code> 的</p></li></ul><h1 id="ARC-如何工作"><a href="#ARC-如何工作" class="headerlink" title="ARC 如何工作"></a>ARC 如何工作</h1><ul><li><p>每次创建一个类的实例，<code>ARC</code> 就会分配一个内存块，用来存储这个实例的相关信息。这个内存块保存着实例的类型，以及这个实例相关的属性的值</p></li><li><p>当实例不再被使用时，ARC 是否这个实例使用的内存，使这块内存可做它用。保证了实例不再被使用时，不会占用内存空间</p></li><li><p>但是，如果 <code>ARC</code> 释放了仍在使用的实例，那么你就不能再访问这个实例的苏醒或者调用它的方法。如果你仍然视图访问这个实例，应用极有可能会崩溃</p></li><li><p>为了保证不会发生上述的情况， <code>ARC</code> 跟踪类实例的相关属性、常量及变量的数量。只要有一个有效的引用，<code>ARC</code> 都不会释放这个实例</p></li><li><p>为了让这个变成现实，只要你将一个类的实例赋值给一个属性或常量或变量，这个属性、常量、变量就是这个实例的 <code>强引用（strong reference）</code>。之所以称之为 <code>强引用</code>，是因为它持有这实例，并且只要这个强引用还存在，就不能销毁实例</p></li></ul><h1 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h1><ul><li><p>在两个类实例彼此保持对方的强应用，使得每个实例都使对方保持有效时会发生这种情况。我们称之为强引用环</p></li><li><p>通过用 <code>弱引用或者无主引用</code> 来 <code>取代强引用</code>，我们可以 <code>解决强引用环问题</code></p></li></ul><h1 id="解决循环引用"><a href="#解决循环引用" class="headerlink" title="解决循环引用"></a>解决循环引用</h1><ul><li><p><code>弱引用和无主引用</code> 允许引用环中的一个实例引用另外一个实例，但 <code>不是强引用</code>。因此实例可以互相引用但是不会产生强引用</p><ul><li><p><code>弱引用不会增加实例的引用计数</code>，因此不会阻止ARC销毁被引用的实例。这种特性使得引用不会编程强引用环。声明属性或者变量的时候，关键字 <code>weak</code> 表明引用为弱引用。</p></li><li><p><code>弱引用只能声明为变量类型</code>，因为运行时它的值可能会变。弱引用绝对不能声明为常量</p></li><li><p>因为弱引用可以没有值，所以声明弱引用的时候 <code>必须是可选类型</code> 的。在swift语言中，推荐使用可选类型作为可能没有值的引用类型</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person: Person?</span><br><span class="line"></span><br><span class="line">weak var student: Student?    </span><br></pre></td></tr></table></figure><ul><li><p>对于生命周期中引用会变nil的实例，使用弱引用；对于初始化时赋值之后引用再也不会赋值为nil的实例，使用无主引用</p><ul><li><p>和弱引用相似，<code>无主引用</code> 也不强持有实例。但是和弱引用不同的是，<code>无主引用默认始终有值</code>。因此，无主引用只能定义为非可选类型。在属性、变量前添加 <code>unowned</code> 关键字，可以声明一个无主引用</p></li><li><p>因为是 <code>可选类型</code>，因此当使用无主引用时，不需要展开，可直接访问。不过非可选类型变量不能赋值为 <code>nil</code>，因此当实例被销毁的时候，ARC无法将引用赋值为 <code>nil</code></p></li><li><p>当实例被销毁后，试图访问该实例的无主引用会触发运行时错误。使用无主引用时请确保引用始终指向一个未销毁的实例</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class City &#123;</span><br><span class="line">    // 无主引用</span><br><span class="line">    unowned let country: Country</span><br><span class="line">    init(country: Country) &#123;</span><br><span class="line">        self.country = country</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Country &#123;</span><br><span class="line">    var capitaCity: City!</span><br><span class="line">    init(capitaCity: City) &#123;</span><br><span class="line">        self.capitaCity = capitaCity</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="闭包引用循环"><a href="#闭包引用循环" class="headerlink" title="闭包引用循环"></a>闭包引用循环</h1><p>将一个闭包赋值给类实例的某个属性，并且这个闭包使用了实例，这样也会产生强引用环。这个闭包可能反问了实例的某个属性，如果 <code>self.someProperty</code>，或者调用了实例的某个方法 <code>self.someMethod</code>。这两种情况都导致了闭包使用 <code>self</code>，从而产生了循环引用</p><p>解决：</p><ul><li><p>定义占有列表-占有列表中的每个元素都是由 <code>weak</code> 或者 <code>unowend</code> 关键字和实例的引用（如 <code>self</code> 或 <code>someInstance</code>）组成。每一对都在括号中，通过逗号分开</p></li><li><p>当闭包和占有的实例总是互相引用时并且总是同时销毁时，将闭包内的占有定义为无主引用</p></li><li><p>相反的，当占有引用有时可能会是 <code>nil</code> 时，将闭包内的占有定义为 弱引用</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lazy var someClosure = &#123;</span><br><span class="line">    [unowned self, weak delete = self.delete]</span><br><span class="line">    (index: Int,stringToProcess: String) -&gt; String in</span><br><span class="line">    </span><br><span class="line">    // closure body goes here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ARC&quot;&gt;&lt;a href=&quot;#ARC&quot; class=&quot;headerlink&quot; title=&quot;ARC&quot;&gt;&lt;/a&gt;ARC&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;swift 使用 &lt;code&gt;自动引用计数（ARC）&lt;/code&gt; 来跟踪并管理应用使用的 &lt;code&gt;内存&lt;/c</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习47:多线程</title>
    <link href="https://www.bboyzj.cn/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A047%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://www.bboyzj.cn/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A047%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-03-12T14:52:33.000Z</published>
    <updated>2023-03-13T09:40:14.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为什么几乎所有的GUI框架都是单线程的？：处理问题代价大于收益</p><h1 id="多线程可以做什么"><a href="#多线程可以做什么" class="headerlink" title="多线程可以做什么"></a>多线程可以做什么</h1><ul><li>网络请求</li><li>IO：读写文件</li><li>计算</li><li>数据模型转换</li><li>….</li></ul><h1 id="多线程编程的方式"><a href="#多线程编程的方式" class="headerlink" title="多线程编程的方式"></a>多线程编程的方式</h1><ul><li>Thread</li><li>Operation 和 OperationQueue</li><li>GCD</li></ul><h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><ul><li>三种中最轻量级的，自己管理线程的生命周期和线程同步</li><li>线程同步对数据加锁有一定的系统开销</li></ul><p>1、快捷方式创建</p><ul><li>detachNewThread(_ block: @escaping @Sendable () -&gt; Void)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">// 不希望程代码在主线完成后退出，因为很多线程需要异步操作</span><br><span class="line">PlaygroundPage.current.needsIndefiniteExecution = true</span><br><span class="line"></span><br><span class="line">for i in 0...10 &#123;</span><br><span class="line">    Thread.detachNewThread &#123;</span><br><span class="line">        print(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>detachNewThreadSelector(_ selector: Selector, toTarget target: Any, with argument: Any?)</li></ul><p>2、初始化器</p><ul><li>Thread(target:  selector: , object: )</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">// 不希望程代码在主线完成后退出，因为很多线程需要异步操作</span><br><span class="line">PlaygroundPage.current.needsIndefiniteExecution = true</span><br><span class="line"></span><br><span class="line">class ObjectThread &#123;</span><br><span class="line">    func threadTest() &#123;</span><br><span class="line">        let thread = Thread(target: self, selector: #selector(threadMethod), object: nil)</span><br><span class="line">        // 手动开启</span><br><span class="line">        thread.start()</span><br><span class="line">    &#125;</span><br><span class="line">    @objc func threadMethod() &#123;</span><br><span class="line">        print(&quot;threadMethod&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 实例</span><br><span class="line">let obj = ObjectThread()</span><br><span class="line">obj.threadTest()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Operation-和-OperationQueue-概述"><a href="#Operation-和-OperationQueue-概述" class="headerlink" title="Operation 和 OperationQueue 概述"></a>Operation 和 OperationQueue 概述</h1><ul><li>面向对象</li><li>Operation + OperationQueue</li><li>取消、依赖、任务优先级、复杂逻辑、保存业务状态、子类化</li></ul><h1 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h1><ul><li>Operation：抽象类，任务</li><li>BlockOperation</li></ul><p>1、状态：</p><ul><li>isReady：准备好了，可以执行了</li><li>isExecuting：执行中</li><li>isFinished：执行完成</li><li>isCancelled：取消执行</li></ul><p>2、同步、异步</p><ul><li>sync</li><li>async</li></ul><p>3、添加依赖</p><h1 id="OperationQueue"><a href="#OperationQueue" class="headerlink" title="OperationQueue"></a>OperationQueue</h1><ul><li><code>OperationQueue</code> 队列，可以加入很多 <code>Operation</code>，</li><li>底层使用 <code>GCD</code></li><li><code>maxConcurrentOperationCount</code>：可以设置最大并发数</li><li><code>defaultMaxConcurrentOperationCount</code>：根据当前系统条件动态确定的最大并发数，建议使用这个</li><li>可以取消所有的 <code>Operation</code>，但是当前正在执行的不会取消</li><li>所有 <code>Operation</code> 执行完毕后退出销毁</li></ul><h1 id="BlockOperation"><a href="#BlockOperation" class="headerlink" title="BlockOperation"></a>BlockOperation</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ObjectOperation &#123;</span><br><span class="line">    func test() &#123;</span><br><span class="line">        let operation = BlockOperation&#123; [weak self] in</span><br><span class="line">            self?.threadMethod()</span><br><span class="line">        &#125;</span><br><span class="line">        let queue = OperationQueue()</span><br><span class="line">        queue.addOperation(operation)</span><br><span class="line">    &#125;</span><br><span class="line">    @objc func threadMethod() &#123;</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;threadMethod&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let op = ObjectOperation()</span><br><span class="line">op.test()</span><br><span class="line">print(&quot;after invoke test&quot;)</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">after invoke test</span><br><span class="line">threadMethod</span><br></pre></td></tr></table></figure><p>由打印结果可知，异步执行了</p><h1 id="继承-Operation"><a href="#继承-Operation" class="headerlink" title="继承 Operation"></a>继承 Operation</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class ObjectOperation &#123;</span><br><span class="line">    func test() &#123;</span><br><span class="line">        let operation = MyOpetation()</span><br><span class="line">        let queue = OperationQueue()</span><br><span class="line">        queue.addOperation(operation)</span><br><span class="line">    &#125;</span><br><span class="line">    @objc func threadMethod() &#123;</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;threadMethod&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyOpetation: Operation &#123;</span><br><span class="line">    override func main() &#123;</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;myOperation main&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let op = ObjectOperation()</span><br><span class="line">op.test()</span><br><span class="line">print(&quot;after invoke test&quot;)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">after invoke test</span><br><span class="line">myOperation main</span><br></pre></td></tr></table></figure><h1 id="Operation-完成的回调"><a href="#Operation-完成的回调" class="headerlink" title="Operation 完成的回调"></a>Operation 完成的回调</h1><ul><li>completionBlock</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">operation.completionBlock = &#123; () -&gt; Void in</span><br><span class="line">    print(&quot;completionBlock&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">after invoke test</span><br><span class="line">myOperation main</span><br><span class="line">completionBlock</span><br></pre></td></tr></table></figure><h1 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h1><ul><li>任务 + 队列</li><li>易用</li><li>效率</li><li>性能</li></ul><h1 id="GCD功能"><a href="#GCD功能" class="headerlink" title="GCD功能"></a>GCD功能</h1><ul><li>创建管理Queue</li><li>提交Job</li><li>Dispatch Group</li><li>管理Dispatch Object</li><li>信号量Semaphore</li><li>队里屏障Barrier</li><li>Dispatch Source</li><li>Queue Context数据</li><li>Dispatch I&#x2F;O Channel</li><li>Dispatch Data 对象</li></ul><h1 id="GCD队列"><a href="#GCD队列" class="headerlink" title="GCD队列"></a>GCD队列</h1><ul><li>主队列：任务在主线程执行</li><li>并行队列：任务会以先进先出的顺序入列和出列，但是因为多个任务可以并行执行，所以顺序是不一定的</li><li>串行队列：任务会以先进先出的顺序入列和出列，但是同一时刻只会执行一个任务</li></ul><h1 id="GCD-队列API"><a href="#GCD-队列API" class="headerlink" title="GCD-队列API"></a>GCD-队列API</h1><ul><li>Dispatch.main</li><li>Dispatch.global</li><li>DispatchQueue</li><li>queue.label</li><li>setTarget</li></ul><h1 id="GCD-基本操作"><a href="#GCD-基本操作" class="headerlink" title="GCD 基本操作"></a>GCD 基本操作</h1><ul><li>sync</li></ul><p>提交任务到当前队列里，并且直接任务执行完成，当前队列才会返回</p><ul><li>async</li></ul><p>调用一个任务去立即执行，但是不用等任务执行完当前队列就会返回</p><ul><li>asyncAfter</li></ul><p>调度一个任务多久之后去执行，但是不用等任务执行完当前队列就会返回</p><h1 id="GCD-串行-amp-并行"><a href="#GCD-串行-amp-并行" class="headerlink" title="GCD 串行 &amp; 并行"></a>GCD 串行 &amp; 并行</h1><ul><li>串行和并行描述的是任务之间如何运行</li><li>串行任务每一个仅执行一个</li><li>并行任务可以多个同时执行</li></ul><h1 id="GCD-同步-amp-异步"><a href="#GCD-同步-amp-异步" class="headerlink" title="GCD 同步 &amp; 异步"></a>GCD 同步 &amp; 异步</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303131515216.png"> </p><h1 id="GCD-使用"><a href="#GCD-使用" class="headerlink" title="GCD 使用"></a>GCD 使用</h1><ul><li>同步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let queue = DispatchQueue(label: &quot;myQueue&quot;,qos: DispatchQoS.default,attributes: DispatchQueue.Attributes.concurrent,autoreleaseFrequency: DispatchQueue.AutoreleaseFrequency.inherit,target: nil)</span><br><span class="line">queue.sync &#123; // 同步</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;in queue sync&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;after invoke queue method&quot;)</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">in queue sync</span><br><span class="line">after invoke queue method</span><br></pre></td></tr></table></figure><ul><li>异步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">queue.async &#123; // 异步</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;in queue async&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;after invoke queue method&quot;)</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">after invoke queue method</span><br><span class="line">in queue async</span><br></pre></td></tr></table></figure><ul><li>asyncAfter</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">queue.asyncAfter(deadline: .now() + 1) &#123;</span><br><span class="line">    print(&quot;in asyncAfter&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;after invoke queue method&quot;)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">after invoke queue method</span><br><span class="line">in asyncAfter</span><br></pre></td></tr></table></figure><h1 id="GCD-源码剖析"><a href="#GCD-源码剖析" class="headerlink" title="GCD 源码剖析"></a>GCD 源码剖析</h1><ul><li><p>dispatch_sync</p><ul><li><p>线程A在串行队里dq中执行task1的过程中，如果再向dq中投递串行任务task2，同时还要求必须阻塞当前线程，等待task2结束(sync投递task2)，那么这时候会发生死锁</p></li><li><p>因为这时候task1还没有结束，串行队列不会去执行task2，而我们又要在当前线程等待task2的结束才肯继续执行task1，即task1在等待task2，而task2也在等待task1，循环等待，形成死锁</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 串行队列</span><br><span class="line">let queue = DispatchQueue(label: &quot;label&quot;)</span><br><span class="line">queue.async &#123; // 异步</span><br><span class="line">    print(&quot;in queue async&quot;) // 串行队列执行task1</span><br><span class="line">    queue.sync &#123;</span><br><span class="line">        print(&quot;in queue sync&quot;) // 串行队列加入task2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 死锁</span><br></pre></td></tr></table></figure><h1 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h1><p>一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码</p><h1 id="竟态条件"><a href="#竟态条件" class="headerlink" title="竟态条件"></a>竟态条件</h1><ul><li>两个或多个线程读写某些数据，而最后的结果取决于线程运行的精确时序</li></ul><h1 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303131739456.png"></p><h1 id="SpinLock"><a href="#SpinLock" class="headerlink" title="SpinLock"></a>SpinLock</h1><ul><li><p>线程通过busy-wait-loop方式来获取锁，任何时刻只有一个线程能够获取锁，其他线程忙等待知道获取锁</p></li><li><p>临界区尽量简短，控制在100行代码以内，不要有限时或隐士的系统调用，调用的函数也尽量简短</p></li><li><p>保证访问锁的线程全部都处于同一优先级</p></li></ul><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func synchronized(_ obj: Any, closure: ()-&gt;()) &#123;</span><br><span class="line">    objc_sync_enter(obj)</span><br><span class="line">    closure()</span><br><span class="line">    objc_sync_exit(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只有传同样的对象给synchronized，才能起到加锁的作用</li><li>如果传nil，无法起到加锁的作用</li><li>可以重入</li><li>synchronized不会持有传给它的对象</li></ul><h1 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h1><ul><li><p>一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面</p></li><li><p>实现一个多线程安全的Array的读和写</p></li><li><p>编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度</p></li><li><p>需要在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件</p></li></ul><h1 id="【场景一】：一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面"><a href="#【场景一】：一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面" class="headerlink" title="【场景一】：一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面"></a>【场景一】：一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面</h1><h1 id="【场景二】：实现一个多线程安全的Array的读和写"><a href="#【场景二】：实现一个多线程安全的Array的读和写" class="headerlink" title="【场景二】：实现一个多线程安全的Array的读和写"></a>【场景二】：实现一个多线程安全的Array的读和写</h1><p>一个队列加方法方法</p><ul><li>1、首先是 <code>并行队列</code>，我们需要保持多线程并行操作</li><li>2、 <code>sync</code> 方法，<code>封装读操作</code>，读操作在调用读方法时能直接拿到返回值，而不是异步获取</li><li>3、<code>async</code> 方法使用 <code>barrier flag</code>，<code>封装写操作</code>，起到一个栅栏的作用，等待所有的 <code>barrier flag</code> 函数前操作执行完成后， <code>barrier flag</code> 函数之后的所有操作才执行</li></ul><h1 id="【场景三】：编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度"><a href="#【场景三】：编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度" class="headerlink" title="【场景三】：编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度"></a>【场景三】：编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度</h1><h1 id="【场景四】：需要-在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件"><a href="#【场景四】：需要-在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件" class="headerlink" title="【场景四】：需要 在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件"></a>【场景四】：需要 在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件</h1><h1 id="Promise-多线程编程模式"><a href="#Promise-多线程编程模式" class="headerlink" title="Promise 多线程编程模式"></a>Promise 多线程编程模式</h1><ul><li><p>所谓的 <code>Promise</code>，就是一个对象，<code>用来传递异步操作的消息</code>。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 <code>API</code>，可供进一步处理</p></li><li><p>对象的状态不受外界影响。<code>Promise</code> 对象代表一个异步操作，有三种状态：<code>Pending</code>（进行中）、<code>Resolved</code>（已完成）、<code>Rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 <code>Promise</code> 这个名字的由来，它的英文意思就是 <code>承诺</code>，表示其他手段无法改变</p></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code> 对象的状态改变，只有两种可能：从 <code>Pending</code> 变为 <code>Resolved</code> 变为 <code>Rejected</code>，只要这两种情况发送，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发送了，你再对 <code>Resolved</code> 对象添加回调函数，也会立即得到这个结果。这与事件 Event 完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的</p></li></ul><h1 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h1><ul><li><p>将一个任务分解为若干个阶段（State），前阶段的输出作为下阶段的输入，各个阶段由不同的工作者线程负责执行</p></li><li><p>各个任务的各个阶段是并行（Parallel）处理的</p></li><li><p>具体任务的处理是串行的，即完成一个任务要一次执行各个阶段，但从整体任务上看，不同任务的各个阶段的执行时并行的</p></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303131740513.png"></p><h1 id="Master-x2F-Slave"><a href="#Master-x2F-Slave" class="headerlink" title="Master&#x2F;Slave"></a>Master&#x2F;Slave</h1><p>将一个任务分解为若干个语义等同的子任务，并由专门的工作者线程来并行执行这些子任务，既提高计算效率，又实现了信息隐藏</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为什么几乎所有的GUI框架都是单线程的？：处理问题代价大于收益&lt;/p&gt;
&lt;h1 id=&quot;多线程可以做什么&quot;&gt;&lt;a href=&quot;#多线程可以做</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习50：多态和类型转换</title>
    <link href="https://www.bboyzj.cn/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A050%EF%BC%9A%E5%A4%9A%E6%80%81%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://www.bboyzj.cn/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A050%EF%BC%9A%E5%A4%9A%E6%80%81%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2023-03-12T14:36:21.000Z</published>
    <updated>2023-03-14T18:40:44.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向下类型转换"><a href="#向下类型转换" class="headerlink" title="向下类型转换"></a>向下类型转换</h1><ul><li><p>类型的常量或变量实际上是子类的实例，你可以用 <code>as?</code> 或 <code>as!</code> 向下类型转换至子类类型</p></li><li><p>向下类型转换可能失败，<code>as？</code> 返回的值是 <code>可选类型</code>，<code>as！</code> 返回的是 <code>强制类型</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 基类</span><br><span class="line">class MediaItem &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子类</span><br><span class="line">class Movie: MediaItem &#123;</span><br><span class="line">    var director: String</span><br><span class="line">    init(name: String, director: String) &#123;</span><br><span class="line">        // 安全检查</span><br><span class="line">        self.director = director</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子类</span><br><span class="line">class Song: MediaItem &#123;</span><br><span class="line">    var artist: String</span><br><span class="line">    init(name: String,artist: String) &#123;</span><br><span class="line">        self.artist = artist</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [Movie(name: &quot;1&quot;, director: &quot;2&quot;),</span><br><span class="line">           Song(name: &quot;3&quot;, artist: &quot;4&quot;),</span><br><span class="line">           Movie(name: &quot;5&quot;, director: &quot;6&quot;)]</span><br><span class="line">print(type(of: arr))</span><br><span class="line">for item in arr &#123;</span><br><span class="line">    // 向下类型转换</span><br><span class="line">    if let realItem = item as? Movie &#123;</span><br><span class="line">        print(realItem.director)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Any-和-AnyObject"><a href="#Any-和-AnyObject" class="headerlink" title="Any 和 AnyObject"></a>Any 和 AnyObject</h1><p>swift 为不确定的类型提供了两种特殊的类型别名：</p><ul><li><p>AnyObject：表示任何类类型</p></li><li><p>Any：表示任何类型，包括函数类型</p></li></ul><h1 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h1><ul><li><p>swift 中 <code>类、结构体、枚举</code> 可以进行嵌套</p></li><li><p>嵌套类型能够访问它外部的成员</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;向下类型转换&quot;&gt;&lt;a href=&quot;#向下类型转换&quot; class=&quot;headerlink&quot; title=&quot;向下类型转换&quot;&gt;&lt;/a&gt;向下类型转换&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类型的常量或变量实际上是子类的实例，你可以用 &lt;code&gt;as?&lt;/code&gt; 或 &lt;co</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习42：初始化器</title>
    <link href="https://www.bboyzj.cn/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A042%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8/"/>
    <id>https://www.bboyzj.cn/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A042%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8/</id>
    <published>2023-03-12T09:43:58.000Z</published>
    <updated>2023-03-14T19:28:40.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p><code>类、枚举、结构体</code> 可以引入 <code>初始化器</code>。初始化器使用 <code>关键字init来声明</code></p></li><li><p><code>结构体、枚举、类</code> 可以有任意数量的初始化器，但是 <code>类</code> 的初始化器不同 <code>于结构体和枚举</code>，<code>类有两种初始化器，即指定初始化器和便捷初始化器。</code></p></li></ul><h1 id="存储属性的初始赋值"><a href="#存储属性的初始赋值" class="headerlink" title="存储属性的初始赋值"></a>存储属性的初始赋值</h1><ul><li><p><code>类</code> 的 <code>存储属性需要有默认值</code>，而 <code>结构体、枚举不需要</code></p></li><li><p>类设置默认值方式也有两种：一种是 <code>定义存储属性时设置默认值（Optional）</code>，另一种是通过 <code>初始化器为存储属性设置默认值</code> </p></li><li><p>类的初始化器有两种，一种 <code>指定初始化器</code>，另一种 <code>便捷初始化器</code></p></li><li><p>指定初始化器又分为两种：一种 <code>初始化器</code> 不带参数，另一种 <code>自定义初始化器</code> 带参数</p></li></ul><h1 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h1><blockquote><p><code>可选类型</code> 的存储属性，不需要设置默认值，因为它本身 <code>可能有值</code> 或 <code>可能没有值</code>，编译器会自动设置默认的初始化器</p></blockquote><ul><li>直接设置默认值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    // 1、声明一个 Optional 默认值</span><br><span class="line">    var name: String?</span><br><span class="line">    // 2、直接设置默认值</span><br><span class="line">    var name: String = &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以通过 <code>闭包</code> 设置默认值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var name: String &#123;</span><br><span class="line">        // 在这个闭包中给 name 创建一个默认值</span><br><span class="line">        return &quot;ZJ&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指定初始化器为存储属性设置默认值"><a href="#指定初始化器为存储属性设置默认值" class="headerlink" title="指定初始化器为存储属性设置默认值"></a>指定初始化器为存储属性设置默认值</h1><blockquote><p> 初始化器创建实例时被调用，最简答的形式是不带任何参数的实例方法，已关键字 <code>init</code> 命名，即 <code>指定初始化器</code></p></blockquote><ul><li>可选类型的存储属性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clas Person &#123;</span><br><span class="line">    var name: String？</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义初始化器设置默认值，带参数</li></ul><p>可以通过 <code>输入参数</code> 来自定义初始化器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    // 0.不带参数</span><br><span class="line">    init() &#123;</span><br><span class="line">        self.name = &quot;ZJ&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    // 1.实际参数和形式参数相同</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.实际参数 和 形式参数 不同</span><br><span class="line">    init(to name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.通配符实际参数</span><br><span class="line">    init(_ name: String) &#123;</span><br><span class="line">        self.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = Person(name: &quot;ZJ&quot;)</span><br><span class="line">let p1 = Person(to: &quot;ZJ&quot;)</span><br><span class="line">let p2 = Person(&quot;ZJ&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>注：指定初始化器分为两种：一种是不带参数，一种是带参数<br>初始化器可以有任意数量</p></blockquote><h1 id="类的继承和构造"><a href="#类的继承和构造" class="headerlink" title="类的继承和构造"></a>类的继承和构造</h1><p>类中的所有存储属性-&gt;包括继承父类的所有存储属性：都必须在构造过程中 <code>设置默认值</code></p><p>1、<code>swift</code> 中为类提供了两种初始化器：<code>指定初始化器</code> 和 <code>便捷初始化器</code></p><ul><li>指定初始化器</li></ul><p>类中主要的初始化器，设置类中所有属性默认值，并往上调用父类的初始化器设置所有属性的默认值</p><ul><li>便捷初始化器</li></ul><p>类中次要的、辅助型的初始化器，可以调用类中的指定初始化器，并提供默认值</p><p>2、指定初始化器和便捷初始化器语法</p><ul><li>指定初始化器和简单初始化器一样</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>便捷初始化器，需要在 <code>init</code> 前放置 <code>convenience</code> 关键字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    // 未设置默认值的存储属性</span><br><span class="line">    var name: String</span><br><span class="line">    // 指定初始化器 用来给存储属性设置默认值</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    // 便捷初始化器</span><br><span class="line">    convenience init() &#123;</span><br><span class="line">        // 横向代理：必须调用一个指定的初始化器</span><br><span class="line">        self.init(name: &quot;ZJ&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = Person()</span><br><span class="line">print(p.name)</span><br></pre></td></tr></table></figure><blockquote><p>类的初始化器代理规则<br>1、指定初始化器必须调用其直接父类的指定初始化器<br>2、便捷初始化器必须调从同类调用一个指定初始化器<br>3、便捷初始化器最终必须调用一个指定初始化器</p><p>更方便的记忆方法<br>1、指定初始化器必须总是向上代理<br>2、便捷初始化器必须是横向代理</p></blockquote><p>3、初始化器继承和重写</p><ul><li>子类默认是 <code>不继承</code> 父类的初始化器，实际上是通过 <code>重写</code> 父类的初始化器，切需要带上 <code>override</code> 关键字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 继承和重写</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name:String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student: Person &#123;</span><br><span class="line">    // 重写父类的初始化器</span><br><span class="line">    override init(name: String) &#123;</span><br><span class="line">        var newName = &quot;my name is \(name)&quot;</span><br><span class="line">        super .init(name: newName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let s = Student(name: &quot;ZJ&quot;)</span><br><span class="line">print(s.name)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">my name is ZJ</span><br></pre></td></tr></table></figure><ul><li>初始化器的自动继承</li></ul><blockquote><p>1、如果子类没有定义任何初始化器，它将自动继承父类的所有指定初始化器<br>2、如果子类实现了继承自父类的指定初始化器，那么它将自动继承父类的便捷初始化器</p></blockquote><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name:String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    convenience init() &#123;</span><br><span class="line">        self.init(name: &quot;ZJ&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = Person()</span><br><span class="line">print(p.name)</span><br><span class="line">// 打印结果 ZJ</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">class Student: Person &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">    // 本类的指定初始化器</span><br><span class="line">    init(name: String,age: Int) &#123;</span><br><span class="line">        self.age = age</span><br><span class="line">        // 实现父类的指定初始化器</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    convenience override init(name: String) &#123;</span><br><span class="line">        self.init(name: name, age: 32)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let s = Student()</span><br><span class="line">let s1 = Student(name: &quot;ZJ&quot;)</span><br><span class="line">let s2 = Student(name: &quot;ZJ&quot;, age: 32)</span><br><span class="line">print(s.age)</span><br><span class="line">// 打印结果 32</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="安全检查"><a href="#安全检查" class="headerlink" title="安全检查"></a>安全检查</h1><ul><li>子类指定初始化器向上委托父类初始化器前，子类的所有属性都要完成初始化</li><li>之类指定初始化器必须先向上委托父类初始化器，才能修改父类的所有属性</li><li>便捷初始化器必须先委托同类初始化器，才能为任意属性赋值</li><li>方法的调用在所有指定初始化器之后。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 安全检查</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">    // 指定初始化器</span><br><span class="line">    init(name: String, age: Int) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    convenience init()&#123;</span><br><span class="line">        self.init(name: &quot;[Unnamed]&quot;, age: 0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Teacher: Person &#123;</span><br><span class="line">    // 工资</span><br><span class="line">    var salary: Int</span><br><span class="line">    // 自己的指定初始化器</span><br><span class="line">    init(name: String, age: Int, salary: Int) &#123;</span><br><span class="line">        // 1.先赋值自己的所有属性</span><br><span class="line">        self.salary = salary</span><br><span class="line">        // 2.调用父类的指定初始化器</span><br><span class="line">        super.init(name: name, age: age)</span><br><span class="line">        // 3.修改父类的所有属性</span><br><span class="line">        self.name = name + &quot;老师&quot;</span><br><span class="line">        // 6.调用方法</span><br><span class="line">        test()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func test() &#123;</span><br><span class="line">        print(&quot;test&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    convenience init(salary: Int) &#123;</span><br><span class="line">        // 4.必须调用本类的指定初始化器</span><br><span class="line">        self.init(name: &quot;ZJ&quot;, age: 32, salary: salary)</span><br><span class="line">        // 5.调用本类的指定初始化器后，才能赋值本类的所有属性</span><br><span class="line">        self.salary = self.salary + 1000</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="失败初始化器"><a href="#失败初始化器" class="headerlink" title="失败初始化器"></a>失败初始化器</h1><p>如果在构造过程有可能失败，则需要定义一个可失败的初始化器，在 <code>init</code> 关键字 <code>后面</code> 添加 <code>?</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">    init?(age: Int) &#123;</span><br><span class="line">        if age &gt; 200 &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = Person(age: 300)</span><br><span class="line">print(p)</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">nil</span><br></pre></td></tr></table></figure><h1 id="反初始化器"><a href="#反初始化器" class="headerlink" title="反初始化器"></a>反初始化器</h1><ul><li><p>类实例 <code>被释放时</code>，反初始化器立即被调用。用 <code>deinit</code> 关键字写反初始化器。</p></li><li><p>反初始化器在 <code>实例释放前自动被调用</code>。不能自己调用。可以被子类继承。先子类 -&gt; 父类</p></li><li><p>每个类只能有一个</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line">    // perform the deinitialization</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="必要初始化器"><a href="#必要初始化器" class="headerlink" title="必要初始化器"></a>必要初始化器</h1><ul><li>在类的初始化器前加 <code>required</code> 修饰符表明所有该子类必须实现该初始化器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 必要初始化器</span><br><span class="line">class SomeClass &#123;</span><br><span class="line">    required init()&#123;</span><br><span class="line">        // 初始化器的实现代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子类重写父类的必要初始化器时，子类的初始化器前也添加 <code>required</code> 关键字，表明可继承</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 必要初始化器</span><br><span class="line">class SomeSubClass: SomeClass &#123;</span><br><span class="line">    required init()&#123;</span><br><span class="line">        // 初始化器的实现代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;类、枚举、结构体&lt;/code&gt; 可以引入 &lt;code&gt;初始化器&lt;/code&gt;。初始化器使用 &lt;code&gt;关键字</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习41：泛型</title>
    <link href="https://www.bboyzj.cn/2023/03/11/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A041%EF%BC%9A%E6%B3%9B%E5%9E%8B/"/>
    <id>https://www.bboyzj.cn/2023/03/11/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A041%EF%BC%9A%E6%B3%9B%E5%9E%8B/</id>
    <published>2023-03-10T20:40:24.000Z</published>
    <updated>2023-03-11T20:49:13.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul><li><p>泛型代码能根据所定义的要求写出可以用于任何类型的灵活的、可复用的函数。可以编写出可复用、意图表达清晰、抽象的代码。</p></li><li><p><code>泛型 </code>是Swift最强大的特性之一，<code>很多Swift标准库</code> 是基于 <code>泛型</code> 代码构建的。如，Swift 的 <code>Array和Dictionary类型都是泛型集合</code>；你也可以创建一个容纳 <code>Int</code> 值的数组，或者容纳 <code>String</code> 值的数组，甚至容纳任何 <code>Swift</code> 可以创建的其他类型的数组。同样，可以创建一个存储任何指定类型值的字典，而且类型没有限制。</p></li><li><p>泛型所解决的问题：<code>代码的复用性和抽象能力</code>。比如，交换两个值，这里的值可以是Int、Double、String。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//经典例子swap，使用泛型，可以满足不同类型参数的调用</span><br><span class="line">func swap&lt;T&gt;(_ a: inout T, _ b: inout T)&#123;</span><br><span class="line">    let tmp = a</span><br><span class="line">    a = b</span><br><span class="line">    b = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><p>主要讲3点：<code>类型约束、关联类型、Where语句</code></p><ul><li>类型约束</li></ul><p>在一个 <code>类型参数后面放置协议或者是类</code>，例如下面的例子，要求类型参数T遵循 <code>Equatable</code> 协议。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func test&lt;T:Equatable&gt;(_ a: T, _ b: T) -&gt; Bool &#123;</span><br><span class="line">    return a == b</span><br><span class="line">&#125;</span><br><span class="line">test(1, 2)</span><br><span class="line">// 打印结果 false</span><br><span class="line">test(&quot;A&quot;, &quot;a&quot;)</span><br><span class="line">// 打印结果 false</span><br></pre></td></tr></table></figure><blockquote><p>Equatable协议：可以比较值相等的协议，即可以使用 <code>==</code> 比较</p></blockquote><ul><li>关联类型</li></ul><blockquote><p>在定义协议时，使用 <code>关联类型</code> 给 <code>协议</code> 中用到的 <code>类型</code> 起一个 <code>占位符名称</code>。关联类型 <code>只能用于协议</code>，并且是通过关键字 <code>associatedtype</code> 指定。</p></blockquote><p>下面这个示例，仿写的一个栈的结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Stack &#123;</span><br><span class="line">    var items = [Int]()</span><br><span class="line">    // 入栈</span><br><span class="line">    mutating func push(_ item: Int) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    // 出栈</span><br><span class="line">    mutating func pop() -&gt; Int?&#123;</span><br><span class="line">        if items.isEmpty &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该结构体中有个成员 <code>item</code>，是个只能存储 <code>Int</code> 类型的数组，如果想使用其他类型呢？ 可以通过协议来实现 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protocol StackProtocol &#123;</span><br><span class="line">    // 协议中使用类型的占位符</span><br><span class="line">    associatedtype Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Stack: StackProtocol&#123;</span><br><span class="line">    // 在使用时，需要指定具体的类型</span><br><span class="line">    typealias Item = Int</span><br><span class="line">    </span><br><span class="line">    var items = [Item]()</span><br><span class="line">    // 入栈</span><br><span class="line">    mutating func push(_ item: Int) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    // 出栈</span><br><span class="line">    mutating func pop() -&gt; Int?&#123;</span><br><span class="line">        if items.isEmpty &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在尝试用 <code>泛型</code> 实现上面的功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 泛型实现</span><br><span class="line">struct Stack&lt;T&gt; &#123;</span><br><span class="line">    var items = [T]()</span><br><span class="line">    // 入栈</span><br><span class="line">    mutating func push(_ item: T) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    // 出栈</span><br><span class="line">    mutating func pop() -&gt; T?&#123;</span><br><span class="line">        if items.isEmpty &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型的优势和强大，暴露无疑</p><ul><li>where</li></ul><p><code>where语句</code> 主要用于 <code>表明泛型需要满足的条件</code>，即 <code>限制形式参数的要求</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// where</span><br><span class="line">protocol StackProtocol &#123;</span><br><span class="line">    // 协议中使用类型的占位符</span><br><span class="line">    associatedtype Item</span><br><span class="line">    // 实例属性</span><br><span class="line">    var itemCount: Int &#123; get &#125;</span><br><span class="line">    // 出栈</span><br><span class="line">    mutating func pop() -&gt; Item?</span><br><span class="line">    // 下标获取</span><br><span class="line">    func index(of index: Int) -&gt; Item</span><br><span class="line">&#125;</span><br><span class="line">struct Stack: StackProtocol &#123;</span><br><span class="line">    // 在使用时，需要指定具体的类型</span><br><span class="line">    typealias Item = Int</span><br><span class="line">    // 存储属性</span><br><span class="line">    var items = [Item]()</span><br><span class="line">    // 计算属性</span><br><span class="line">    var itemCount: Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return items.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 入栈</span><br><span class="line">    mutating func push(_ item: Item)&#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    // 出栈</span><br><span class="line">    mutating func pop() -&gt; Item?&#123;</span><br><span class="line">        if items.isEmpty &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    // 下标获取</span><br><span class="line">    func index(of index: Int) -&gt; Item&#123;</span><br><span class="line">        return items[index]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> whrer语句</span><br><span class="line"> T1.Item == T2.Item 表示 T1和T2中的类型必须相等</span><br><span class="line"> T1.Item: Equatable 表示 T1的类型必须遵循Equatable协议，意味着T2也要尊徐Equatable协议</span><br><span class="line"> */</span><br><span class="line">func compare&lt;T1: StackProtocol, T2: StackProtocol&gt;(_ stack1: T1,_ stack2: T2) -&gt; Bool where T1.Item == T2.Item, T1.Item: Equatable &#123;</span><br><span class="line">    // 如果数量相等，则遍历</span><br><span class="line">    guard stack1.itemCount == stack2.itemCount else &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    // 遍历</span><br><span class="line">    for i in 0..&lt;stack1.itemCount &#123;</span><br><span class="line">        if stack1.index(of: i) != stack2.index(of: i) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 扩展协议中的 Iem 遵循 Equatable</span><br><span class="line">extension StackProtocol where Item: Equatable &#123;&#125;</span><br></pre></td></tr></table></figure><p>当希望 <code>泛型指定类型</code> 拥有特定功能，可以这么写，在上述写法的基础上 <code>增加extension：</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 扩展协议中 Item 指定具体类型</span><br><span class="line">extension StackProtocol where Item == Int &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 简单的泛型函数</span><br><span class="line">func testGen&lt;T&gt;(_ value: T) -&gt; T &#123;</span><br><span class="line">    let tmp = value</span><br><span class="line">    return tmp</span><br><span class="line">&#125;</span><br><span class="line">class Teacher &#123;</span><br><span class="line">    var age: Int = 18</span><br><span class="line">    var name: String = &quot;ZJ&quot;</span><br><span class="line">&#125;</span><br><span class="line">// 传入Int类型</span><br><span class="line">testGen(10)</span><br><span class="line">// 传入元组</span><br><span class="line">testGen((1,2))</span><br><span class="line">// 传入实例对象</span><br><span class="line">testGen(Teacher())</span><br></pre></td></tr></table></figure><p>从以上代码可以看出，泛型函数 <code>可以接受任何类型</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>泛型主要用于解决代码的 <code>抽象能力</code>，以及提升代码的 <code>复用性</code></li><li>如果一个泛型 <code>遵循了某个协议</code>，则在使用时，要求具体的类型也是必须遵循某个协议的；</li><li>在定义协议时，可以使用 <code>关联类型</code> 给协议中用到的 <code>类型</code> 起一个 <code>占位符名称</code>；</li><li><code>where语句</code> 主要用于表明泛型需要满足的条件，即 <code>限制形式参数的要求</code>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;泛型代码能根据所定义的要求写出可以用于任何类型的灵活的、可复用的函数。可以编写出可复用、意图表达清晰、抽象的代码。&lt;/p&gt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>OC学习20：UIViewController生命周期</title>
    <link href="https://www.bboyzj.cn/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A020%EF%BC%9AUIViewController%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://www.bboyzj.cn/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A020%EF%BC%9AUIViewController%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2023-03-09T21:15:32.000Z</published>
    <updated>2023-03-09T21:47:29.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UIViewController生命周期相关方法"><a href="#UIViewController生命周期相关方法" class="headerlink" title="UIViewController生命周期相关方法"></a>UIViewController生命周期相关方法</h1><ul><li><ul><li>(instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil;</li></ul></li></ul><p>非storyBoard(xib或非xib)都走这个方法</p><ul><li><ul><li>(instancetype)initWithCoder:(NSCoder *)aDecoder;</li></ul></li></ul><p>如果连接了串联图storyBoard 走这个方法</p><ul><li><ul><li>(void)awakeFromNib;</li></ul></li></ul><p>xib 加载 完成</p><ul><li>+(void)load</li></ul><p>load 在代码加载的时候，对象还没有被初始化的时候就已经调⽤了，可以⽤<br>来做⼀些全局的swizzle,只调⽤⼀次</p><ul><li>+(void)initialize</li></ul><p>类的初始化方法</p><ul><li>-(instancetype)init</li></ul><p>对象初始化方法</p><ul><li>-(void)loadView</li></ul><p>加载视图:当访问UIViewController的view属性时，view如果此时是nil，那么VC会自动调用loadView方法来初始化一个UIView并赋值给view属性。此方法用在初始化关键view，需要注意的是，在view初始化之前，不能先调用view的getter方法，否则将导致死循环（除非先调用了[super loadView];）如果没有重载loadView方法，则UIViewController会从nib或StoryBoard中查找默认的loadView，默认的loadView会返回一个空白的UIView对象。</p><ul><li>-(void)viewDidLoad</li></ul><p>视图加载完成</p><ul><li>-(void)viewWillAppear:(BOOL)animated</li></ul><p>将要展示:在view即将添加到视图层级中（显示给用户）且任意显示动画切换之前调用,此时self.view.superview为nil.这个方法中完成任何与试图显示相关的任务，例如改变视图方向、状态栏方向、视图显示样式等。</p><ul><li>-(void)viewWillLayoutSubviews</li></ul><p>将要布局子视图,self.view.superview为_UIParallaxDimmingView</p><ul><li>-(void)viewDidLayoutSubviews</li></ul><p>已经布局子视图</p><ul><li>-(void)viewDidAppear:(BOOL)animated</li></ul><p>已经展示:在view被添加到视图层级中，显示动画切换之后调用（这时view已经添加到supperView中）。在这个方法中执行视图显示相关附件任务，如果重载了这个方法，必须在方法中调用[supper viewDidAppear];,此时self.view.superview为UIViewControllerWrapperView。</p><ul><li>-(void)viewWillDisappear:(BOOL)animated</li></ul><p>将要消失:view即将从supperView中移除，移除动画切换之后调用，此时已调用removeFromSuperview。此时self.view.superview还是superview为UIViewControllerWrapperView.</p><ul><li>-(void)viewDidDisappear:(BOOL)animated</li></ul><p>已经消失:view从superView中移除，移除动画切换之后调用，此时已调用removeFromSuperview。此时self.view.superview还是superview为nil.</p><ul><li>-(void)dideMemoryWarning</li></ul><p>内存警告</p><ul><li>-(void)dealloc</li></ul><p>销毁释放</p><h1 id="声明周期"><a href="#声明周期" class="headerlink" title="声明周期"></a>声明周期</h1><blockquote><p>-[ViewController initWithCoder:]<br>-[ViewController awakeFromNib]<br>-[ViewController loadView]<br>-[ViewController viewDidLoad]<br>-[ViewController viewWillAppear:]<br>-[ViewController viewWillLayoutSubviews]<br>-[ViewController viewDidLayoutSubviews]<br>-[ViewController viewDidAppear:]<br>-[ViewController viewWillDisappear:]<br>-[ViewController viewDidDisappear:]<br>-[ViewController dealloc]<br>-[ViewController didReceiveMemoryWarning]</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UIViewController生命周期相关方法&quot;&gt;&lt;a href=&quot;#UIViewController生命周期相关方法&quot; class=&quot;headerlink&quot; title=&quot;UIViewController生命周期相关方法&quot;&gt;&lt;/a&gt;UIViewControll</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习19：UIView的生命周期</title>
    <link href="https://www.bboyzj.cn/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A019%EF%BC%9AUIView%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://www.bboyzj.cn/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A019%EF%BC%9AUIView%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2023-03-09T21:03:36.000Z</published>
    <updated>2023-03-09T21:38:16.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UIView生命周期相关函数"><a href="#UIView生命周期相关函数" class="headerlink" title="UIView生命周期相关函数"></a>UIView生命周期相关函数</h1><ul><li><ul><li>(instancetype)initWithFrame:(CGRect)frame;</li></ul></li></ul><p>构造方法,初始化时调用,不会调用init方法</p><ul><li>-(instancetype)init</li></ul><p>构造方法,内部会调用initWithFrame方法</p><ul><li><ul><li>(instancetype)initWithCoder:(NSCoder *)aDecoder;</li></ul></li></ul><p>xib归档初始化视图后调用,如果xib中添加了子控件会在didAddSubview方法调用后调用</p><ul><li><ul><li>(void)awakeFromNib;</li></ul></li></ul><p>唤醒xib,可以布局子控件</p><ul><li>-(void)willMoveToSuperview:(UIView *)newSuperview</li></ul><p>父视图将要更改为指定的父视图,当前视图被添加到父视图时调用</p><ul><li>-(void)didMoveToSuperview</li></ul><p>父视图已更改时调用</p><ul><li>-(void)willMoveToWindow:(UIWindow *)newWindow</li></ul><p>其窗口对象将要更改时调用</p><ul><li>-(void)didMoveToWindow</li></ul><p>窗口对象已经更改时调用</p><ul><li>-(void)layoutSubviews</li></ul><p>布局子控件</p><ul><li>-(void)drawRect:(CGRect)rect</li></ul><p>绘制视图</p><ul><li>-(void)dealloc</li></ul><p>销毁</p><ul><li><ul><li>(void)didAddSubview:(UIView *)subview;</li></ul></li></ul><p>添加子控件时调用</p><ul><li><ul><li>(void)willRemoveSubview:(UIView *)subview;</li></ul></li></ul><p>将要移除子控件</p><h1 id="init方式创建视图-并添加到父视图中展示-不添加子控件-其生命周期调用顺序为"><a href="#init方式创建视图-并添加到父视图中展示-不添加子控件-其生命周期调用顺序为" class="headerlink" title="init方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为:"></a>init方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为:</h1><blockquote><p>[NoXibView initWithFrame:]<br>[NoXibView init]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView layoutSubviews]</p></blockquote><h1 id="initWithFrame方式创建视图-并添加到父视图中展示-不添加子控件-其生命周期调用顺序为"><a href="#initWithFrame方式创建视图-并添加到父视图中展示-不添加子控件-其生命周期调用顺序为" class="headerlink" title="initWithFrame方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为:"></a>initWithFrame方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为:</h1><blockquote><p>[NoXibView initWithFrame:]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView layoutSubviews]<br>[NoXibView drawRect:]</p></blockquote><h1 id="移除销毁是调用顺序"><a href="#移除销毁是调用顺序" class="headerlink" title="移除销毁是调用顺序:"></a>移除销毁是调用顺序:</h1><blockquote><p>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView removeFromSuperview]<br>[NoXibView dealloc]</p></blockquote><h1 id="添加子控件展示时调用顺序"><a href="#添加子控件展示时调用顺序" class="headerlink" title="添加子控件展示时调用顺序:"></a>添加子控件展示时调用顺序:</h1><blockquote><p>[NoXibView initWithFrame:]<br>[NoXibView didAddSubview:]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView layoutSubviews]<br>[NoXibView drawRect:]</p></blockquote><h1 id="添加子控件移除销毁时调用顺序"><a href="#添加子控件移除销毁时调用顺序" class="headerlink" title="添加子控件移除销毁时调用顺序:"></a>添加子控件移除销毁时调用顺序:</h1><blockquote><p>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView removeFromSuperview]<br>[NoXibView dealloc]<br>[NoXibView willRemoveSubview:]</p></blockquote><h1 id="xib创建初始化视图-xib中不添加子控件时调用顺序"><a href="#xib创建初始化视图-xib中不添加子控件时调用顺序" class="headerlink" title="xib创建初始化视图, xib中不添加子控件时调用顺序:"></a>xib创建初始化视图, xib中不添加子控件时调用顺序:</h1><blockquote><p>[XibView initWithCoder:]<br>[XibView awakeFromNib]<br>[XibView willMoveToSuperview:]<br>[XibView didMoveToSuperview]<br>[XibView willMoveToWindow:]<br>[XibView didMoveToWindow]<br>[XibView layoutSubviews]<br>[XibView layoutSubviews]<br>[XibView drawRect:]</p></blockquote><h1 id="xib创建初始化视图-xib中添加子控件时调用顺序"><a href="#xib创建初始化视图-xib中添加子控件时调用顺序" class="headerlink" title="xib创建初始化视图, xib中添加子控件时调用顺序:"></a>xib创建初始化视图, xib中添加子控件时调用顺序:</h1><blockquote><p>[XibView didAddSubview:]<br>[XibView initWithCoder:]<br>[XibView awakeFromNib]<br>[XibView willMoveToSuperview:]<br>[XibView didMoveToSuperview]<br>[XibView willMoveToWindow:]<br>[XibView didMoveToWindow]<br>[XibView layoutSubviews]<br>[XibView layoutSubviews]<br>[XibView drawRect:]</p></blockquote><h1 id="移除销毁时调用顺序-有子控件"><a href="#移除销毁时调用顺序-有子控件" class="headerlink" title="移除销毁时调用顺序,有子控件:"></a>移除销毁时调用顺序,有子控件:</h1><blockquote><p>[XibView willMoveToWindow:]<br>[XibView didMoveToWindow]<br>[XibView willMoveToSuperview:]<br>[XibView didMoveToSuperview]<br>[XibView removeFromSuperview]<br>[NoXibView dealloc]<br>[NoXibView willRemoveSubview:]</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UIView生命周期相关函数&quot;&gt;&lt;a href=&quot;#UIView生命周期相关函数&quot; class=&quot;headerlink&quot; title=&quot;UIView生命周期相关函数&quot;&gt;&lt;/a&gt;UIView生命周期相关函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;(instan</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC面试题：Block</title>
    <link href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ABlock/"/>
    <id>https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ABlock/</id>
    <published>2023-03-09T18:31:11.000Z</published>
    <updated>2023-03-09T21:52:35.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Block的本质"><a href="#Block的本质" class="headerlink" title="Block的本质"></a>Block的本质</h1><ul><li>block 的 <code>本质</code> 是 <code>对象、函数、结构</code>体，由于block函数没有名称，也被称为 <code>匿名函数</code></li></ul><h1 id="Block的分类？"><a href="#Block的分类？" class="headerlink" title="Block的分类？"></a>Block的分类？</h1><ul><li><p>分为 <code>全局Block(_NSConcreteGlobalBlock)、栈Block(_NSConcreteStackBlock)、堆Block(_NSConcreteMallocBlock)</code> 三种形式。</p></li><li><p>其中 <code>栈Block存储在栈(stack)区</code>，<code>堆Block存储在堆(heap)区</code>，<code>全局Block存储在已初始化数据(.data)区</code>。</p><ul><li>堆：动态分配内存，需要程序员自己申请，程序员自己管理</li><li>栈：自动分配内存，自动销毁，先入后出，栈上的内容存在自动销毁的情况</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Block的本质&quot;&gt;&lt;a href=&quot;#Block的本质&quot; class=&quot;headerlink&quot; title=&quot;Block的本质&quot;&gt;&lt;/a&gt;Block的本质&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;block 的 &lt;code&gt;本质&lt;/code&gt; 是 &lt;code&gt;对象、函数、结构</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-面试题" scheme="https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>OC面试题：Runtime</title>
    <link href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARuntime/"/>
    <id>https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARuntime/</id>
    <published>2023-03-09T18:30:47.000Z</published>
    <updated>2023-03-09T19:50:38.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="runtime如何通过selector找到对应的IMP地址？"><a href="#runtime如何通过selector找到对应的IMP地址？" class="headerlink" title="runtime如何通过selector找到对应的IMP地址？"></a>runtime如何通过selector找到对应的IMP地址？</h1><ul><li><p>class_getMethodImplementation(Class cls, SEL name);</p></li><li><p>method_getImplementation(Method m)</p></li></ul><h1 id="Runtime-如何实现-weak-属性"><a href="#Runtime-如何实现-weak-属性" class="headerlink" title="Runtime 如何实现 weak 属性?"></a>Runtime 如何实现 weak 属性?</h1><p><code>Runtime</code> 对 <code>注册的类</code>，会进行 <code>布局</code>，会将 <code>weak</code> 对象放入一个 <code>hash</code> 表中。 用 <code>weak</code> 指向的 <code>对象内存地址</code> 作为 <code>key</code>，当此对象的引用计数为0的时候会调用对象的 <code>dealloc</code> 方法， 假设 <code>weak</code> 指向的对象内存地址是a，那么就会以a为key，在这个 <code>weak</code> hash表中搜索，找到所有以a为key的 <code>weak</code> 对象，从而设置为 <code>nil</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;runtime如何通过selector找到对应的IMP地址？&quot;&gt;&lt;a href=&quot;#runtime如何通过selector找到对应的IMP地址？&quot; class=&quot;headerlink&quot; title=&quot;runtime如何通过selector找到对应的IMP地址？&quot;&gt;</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-面试题" scheme="https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>OC面试题：Runloop</title>
    <link href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARunloop/"/>
    <id>https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARunloop/</id>
    <published>2023-03-09T18:30:37.000Z</published>
    <updated>2023-03-09T19:51:04.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PerformSelector和runloop的关系？"><a href="#PerformSelector和runloop的关系？" class="headerlink" title="PerformSelector和runloop的关系？"></a>PerformSelector和runloop的关系？</h1><ul><li>基础用法：默认在主线程的runloop，会执行，因为此方法是发送消息，objc_msgSend</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelector:@selector(name:) withObject:@“张建&quot;];</span><br></pre></td></tr></table></figure><ul><li>performSelector 在子线程默认不执行，需要加入到 runloop 中并开启</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PerformSelector和runloop的关系？&quot;&gt;&lt;a href=&quot;#PerformSelector和runloop的关系？&quot; class=&quot;headerlink&quot; title=&quot;PerformSelector和runloop的关系？&quot;&gt;&lt;/a&gt;Perfo</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-面试题" scheme="https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>OC面试题：算法</title>
    <link href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%97%E6%B3%95/"/>
    <id>https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%97%E6%B3%95/</id>
    <published>2023-03-09T18:22:53.000Z</published>
    <updated>2023-03-09T18:26:38.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>1）依次比较相邻两个元素，顺序错误则交换位置；需要两层循环，外层循环控制趟数，内层循环控制比较次数</p><p>2）例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;5&quot;,@&quot;4&quot;]];</span><br><span class="line">    // 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">    for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序</span><br><span class="line">        for (int j = 0; j &lt; arr.count - i - 1; j++) &#123;</span><br><span class="line">            // 相邻元素比较，若逆序则交换</span><br><span class="line">            if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123;</span><br><span class="line">                [arr exchangeObjectAtIndex:j withObjectAtIndex:j + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>1）从第一个元素与其他元素比较找到最小值，重复操作，直到最后一位结束；需要两层循环，外层循环趟数，里层循环比较次数</p><p>2）例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithObjects:@&quot;2&quot;,@&quot;1&quot;,@&quot;5&quot;,@&quot;3&quot;, nil];</span><br><span class="line">// 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">    // 里循环获比较换位</span><br><span class="line">    for (int j = i + 1; j &lt; arr.count; j ++) &#123;</span><br><span class="line">        if ([arr[i] intValue] &gt; [arr[j] intValue]) &#123;</span><br><span class="line">            [arr exchangeObjectAtIndex:i withObjectAtIndex:j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;arr:%@&quot;,arr);</span><br></pre></td></tr></table></figure><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p>1） 始终定义第一个元素为 <code>已排序</code> 的，将剩余元素定义为 <code>未排序</code> 逐个插入到 <code>已排序</code> 的排列中；不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去</p><p>2）例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = @[@2,@1,@3,@5,@4].mutableCopy;</span><br><span class="line">// 插入排序的原理：始终定义第一个元素为有序的，将元素逐个插入到有序的排列中</span><br><span class="line">// 其特点是：不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去</span><br><span class="line">for(int i = 0;i &lt; arr.count;i++)&#123;</span><br><span class="line">    // 待排序值</span><br><span class="line">    NSNumber * temp = arr[i];</span><br><span class="line">    // 已排序下标</span><br><span class="line">    int j = i - 1;</span><br><span class="line">    // 待排序与已排序比较，从后向前比较</span><br><span class="line">    while (j &gt;= 0 &amp;&amp; [arr[j] integerValue] &gt; [temp integerValue]) &#123;</span><br><span class="line">        // 如果已排序的 &gt; 待排序的 往后移动一个位置</span><br><span class="line">        [arr replaceObjectAtIndex:(j + 1) withObject:arr[j]];</span><br><span class="line">        j --;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 空出来的位置插入新元素</span><br><span class="line">    [arr replaceObjectAtIndex:(j + 1) withObject:temp];</span><br><span class="line">    NSLog(@&quot;arr:%@&quot;,arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:26:19.242271+0800 插入排序[4184:77845] arr:(</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>1）希尔排序相当于 <code>直接插入排序加强版</code>，引入了 <code>增量</code> 的概念；直到增量为 <code>1</code> 时，再进行直接插入排序</p><p>2）例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = @[@7,@3,@8,@5,@2,@6,@1,@4].mutableCopy;</span><br><span class="line">// 其实间隔值设值为总数的一半</span><br><span class="line">int gap = arr.count/2;</span><br><span class="line">// 直到间隔小于1时结束</span><br><span class="line">while (gap &gt;= 1) &#123;</span><br><span class="line">    // i 待排元素，以 步距 gap 从后向前扫描</span><br><span class="line">    for(int i = 0;i &lt; arr.count;i++)&#123;</span><br><span class="line">        // 待排元素</span><br><span class="line">        NSNumber * temp = arr[i];</span><br><span class="line">        // 当前位置</span><br><span class="line">        int j = i;</span><br><span class="line">        // 跳跃式比较</span><br><span class="line">        while (j &gt;= gap &amp;&amp; [arr[j - gap] integerValue] &gt; [temp integerValue] ) &#123;</span><br><span class="line">            [arr replaceObjectAtIndex:j withObject:arr[j - gap]];</span><br><span class="line">            j -= gap;</span><br><span class="line">        &#125;</span><br><span class="line">        // 空出来位置，插入待排序</span><br><span class="line">        [arr replaceObjectAtIndex:j withObject:temp];</span><br><span class="line">    &#125;</span><br><span class="line">    // 改变步长</span><br><span class="line">    gap = gap/2;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;arr:%@&quot;,arr);</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:22:41.910840+0800 插入排序[4124:74568] arr:(</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5,</span><br><span class="line">    6,</span><br><span class="line">    7,</span><br><span class="line">    8</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>1）也就是 <code>兔子数列</code>，当前数是前两个数列之和</p><p>2）例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    NSInteger num = 10;</span><br><span class="line">    NSInteger total = [self getTotalNum:num];</span><br><span class="line">    NSLog(@&quot;total:%ld&quot;,total);</span><br><span class="line">&#125;</span><br><span class="line">- (NSInteger)getTotalNum:(NSInteger)num&#123;</span><br><span class="line">    if(num == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(num == 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return [self getTotalNum:num-2] + [self getTotalNum:num-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:28:32.672554+0800 斐波那契数列[4285:80606] total:89</span><br></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>1）<code>有序的数组</code>，将数组分割成两份，利用查找的值跟中间值进行比较，如果查找的值大于中间值，就在数组的右边进行查找；如果查找的值小于中间值，就在数组的左边进行查找。如此循环的执行下去，最终找到符合的值。</p><p>2）例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NSArray * arr = @[@(1),@(3),@(5),@(6),@(8),@(10)];</span><br><span class="line">int key = [@(5) intValue];</span><br><span class="line">int min = 0;</span><br><span class="line">int max = arr.count - 1;</span><br><span class="line">int mid;</span><br><span class="line">while (min &lt;= max) &#123;</span><br><span class="line">    // 计算中间下标</span><br><span class="line">    mid = (min + max) / 2;</span><br><span class="line">    // 如果目标值 &gt; 中间下标的中间值</span><br><span class="line">    if (key &gt; [arr[mid] intValue]) &#123;</span><br><span class="line">        //最小变为中间下标+1</span><br><span class="line">        min = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果目标值 &lt; 中间下标的中间值</span><br><span class="line">    else if (key &lt; [arr[mid] intValue])&#123;</span><br><span class="line">        //最大变为中间下标-1</span><br><span class="line">        max = max - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 否则，正好</span><br><span class="line">    else &#123;</span><br><span class="line">        NSLog(@&quot;key:%d&quot;,mid);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:33:18.661324+0800 二分查找[4607:86953] key:2</span><br></pre></td></tr></table></figure><h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><p>递归求和1+2+..+n?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    int sum = [self sum:4];</span><br><span class="line">    NSLog(@&quot;sum:%d&quot;,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)sum:(int)n&#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return [self sum:n-1] + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;p&gt;1）依次比较相邻两个元素，顺序错误则交换位置；需要两层循环，外层循环控制趟数，内层循环控制比较次数&lt;/p&gt;
&lt;p&gt;2）例子：</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-面试题" scheme="https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>OC面试题：多线程</title>
    <link href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-03-09T18:22:02.000Z</published>
    <updated>2023-03-09T21:52:44.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你了解线程么？谈谈你对进程和线程的理解？"><a href="#你了解线程么？谈谈你对进程和线程的理解？" class="headerlink" title="你了解线程么？谈谈你对进程和线程的理解？"></a>你了解线程么？谈谈你对进程和线程的理解？</h1><ul><li><p>进程是 <code>系统进行资源分配和调度的基本单位</code>，是操作系统结构的基础，进程是程序的实体。</p></li><li><p>线程是 <code>独立调度和分派的基本单位</code>，一条线程是进程中一个单一顺序的控制流。</p></li><li><p>同一进程中多条线程共享进程中的全部系统资源，一个进程有很多线程，一个进程可以并发多个线程。</p></li></ul><h1 id="iOS中，有哪些实现多线程的方式？"><a href="#iOS中，有哪些实现多线程的方式？" class="headerlink" title="iOS中，有哪些实现多线程的方式？"></a>iOS中，有哪些实现多线程的方式？</h1><blockquote><p>Pthread<br>   特点：C语言。跨平台，可移植，使用难度大。生命周期：自己管理。<br>NSThread<br>  特点：OC语言。面向对象，简单易用，可直接操作线程。生命周期：自己管理。<br>GCD<br>  特点：替代NSThread，充分利用多核的技术。生命周期：系统管理。<br>NSOperaton<br>  特点：基于GCD的封装。比GCD多了一些简单实用的功能。生命周期：系统管理。</p></blockquote><h1 id="请说一下多线程中-GCD-和-NSOperation-的区别？"><a href="#请说一下多线程中-GCD-和-NSOperation-的区别？" class="headerlink" title="请说一下多线程中 GCD 和 NSOperation 的区别？"></a>请说一下多线程中 GCD 和 NSOperation 的区别？</h1><p><strong>GCD：</strong></p><ul><li><p><code>提供了一次性执行的代码 dispatch_once</code> ，也就是说保证了一段代码在程序执行的过程中只被执行一次，并且是线程安全的！，实现的单例。</p></li><li><p>提供了 <code>延迟执行</code> 的简便方法 <code>dispatch_after</code>。</p></li><li><p>提供了 <code>调度组</code> 的使用，监听一些列异步方法之行结束之后，我们得到统一的通知</p><ul><li>dispatch_group</li><li>dispatch_group_async</li><li>dispatch_group_notify</li><li>dispatch_group_enter&#x2F;dispatch_group_leave</li></ul></li><li><p>提供了 <code>快速迭代的方式dispatch_apply</code>。按照指定的次序将制定的任务追加到指定的队列中，并等待全部队列执行结束！</p></li><li><p>提供了信号量 <code>dispatch_semaphore_t</code>，使用信号量可以实现安全的多线程！（加锁的一种方式）</p><ul><li>dispatch_semaphore_wait：信号量减1，阻塞当前线程</li><li>dispatch_semaphore_signal：信号量加1，释放当前线程</li></ul></li><li><p>提供了栅栏函数 <code>dispatch_barrier_async</code>，使用栅栏函数 <code>可以实现线程的多读单写</code>！</p></li></ul><p><strong>​​​​​​NSOpearion：</strong></p><ul><li><p>NSOperatoin是对GCD更高层次的封装</p></li><li><p>NSOperation可以设置两个操作之间的依赖关系。</p></li><li><p>NSOperation是个抽象类，开发中使用它的两个子类，NSBlockOperation&#x2F;NSInvocationOperation。</p></li><li><p>使用KVO，观察NSOperation的各种状态（isExecuted是否正在执行，isFinished是否结束，isCancled是否取消）。无法判断GCD的状态。</p></li><li><p>NSOperation可以设置操作的优先级。</p></li><li><p>NSoperation可以方便的取消一个操作的执行</p></li><li><p>可以重写NSOperation的main和start函数。</p></li></ul><h1 id="dispatch-once-是怎么保证线程安全的？"><a href="#dispatch-once-是怎么保证线程安全的？" class="headerlink" title="dispatch_once 是怎么保证线程安全的？"></a>dispatch_once 是怎么保证线程安全的？</h1><p>定义一个dispatch_once_t的静态变量，标识下面的diapatch_once的block是否执行过了，static修饰会默认将 <code>onceToken其初始化为0</code>，当值为0时才会 <code>执行block代码块</code> 里面的内容，此时onceToken不为0，当block执行完成，<code>底层会将oneceToken设置为-1</code>，以后再调用的话不会再走block代码块。</p><h1 id="dispatch-after延迟执行，执行时间是准确的吗？"><a href="#dispatch-after延迟执行，执行时间是准确的吗？" class="headerlink" title="dispatch_after延迟执行，执行时间是准确的吗？"></a>dispatch_after延迟执行，执行时间是准确的吗？</h1><p>dispatch_after的延迟执行时间不是准确的，因为dispatch_after是在指定时间之后将任务添加到主队列，并不是在指定时间之后开始执行处理！</p><h1 id="说说你对-dispatch-apply-的理解？"><a href="#说说你对-dispatch-apply-的理解？" class="headerlink" title="说说你对 dispatch_apply 的理解？"></a>说说你对 dispatch_apply 的理解？</h1><ul><li><p><code>dispatch_apply</code> 是GCD提供的一种 <code>快速迭代的函数</code>，按照指定的次数将指定的任务追加到指定的队列中，并等待全部任务结束。</p></li><li><p>如果用在串行队列，就和for循环一样，按顺序同步执行。</p></li><li><p>如果用在并发队列，追加到队列的任务会异步执行，并且等待全部任务结束！</p></li></ul><h1 id="说说你对dispatch-group的理解？"><a href="#说说你对dispatch-group的理解？" class="headerlink" title="说说你对dispatch_group的理解？"></a>说说你对dispatch_group的理解？</h1><ul><li><p>GCD提供的队列组，有两种使用方式 <code>dispatch_group_async</code> 和 <code>dispatch_group_enter/dispatch_group_leave</code>，使用过程中要根据任务类型选择使用哪种方式。</p></li><li><p>如果任务类型是同步任务：使用 <code>dispatch_group_async</code> 和 <code>dispatch_group_enter/dispatch_group_leave</code> 是同样的，可以实现相同的功能。</p></li><li><p>如果任务类型是异步任务：比如（AF）网络请求，使用dispatch_group_async不能等到所有异步任务执行完成，就会去执行dispatch_group_notify中的代码，使用dispatch_group_enter&#x2F;dispatch_group_leave可以实现执行完添加的异步任务，最后执行dispatch_group_notify中的代码</p></li><li><p>如果你要实现这样一个功能，请求网络A和B,然后根据A&#x2F;B返回的内容去刷新页面，如果使用dispatch_group，那么只能使用 <code>dispatch_grouo_enter/dispatch_grouo_leave</code>！！！使用dispatch_group_async是不能实现这个功能的！</p></li></ul><h1 id="说说你项目中的哪些功能使用了dispatch-semaphore-t，解决了什么问题？"><a href="#说说你项目中的哪些功能使用了dispatch-semaphore-t，解决了什么问题？" class="headerlink" title="说说你项目中的哪些功能使用了dispatch_semaphore_t，解决了什么问题？"></a>说说你项目中的哪些功能使用了dispatch_semaphore_t，解决了什么问题？</h1><p>使用信号量 <code>dispatch_semaphore_t</code> 可以实现 <code>异步任务的顺序执行</code>（也就是 <code>将异步任务转换为同步任务执行</code>）不要阻塞主线程！。也是多线程加锁的一种实现方式，保证线程安全。</p><ul><li><p>dispatch_semaphore_create(intptr_t value) 创建一个队列组，传入得值&gt;&#x3D;0，传入的值控制控制并发线程的数量！！！，如果我们传入2，那么就表示当前最多有两个线程同时执行。</p></li><li><p>dispatch_semaphore_signal(dispatch_semaphore_t dsema) 增加信号量，使信号量的值加1！</p></li><li><p>dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout) 等待当前线程，直到某个时间释放！！！</p></li></ul><h1 id="说说你对NSOperation-x2F-NSOperationQueue的使用和理解？"><a href="#说说你对NSOperation-x2F-NSOperationQueue的使用和理解？" class="headerlink" title="说说你对NSOperation&#x2F;NSOperationQueue的使用和理解？"></a>说说你对NSOperation&#x2F;NSOperationQueue的使用和理解？</h1><ol><li><p>NSOperation&#x2F;NSOperationQueue 是系统提供的一套多线程实现方案。实际上NSOperation&#x2F;NSOperationQueue是基于GCD更高层次的封装，完全面向对象，比GCD简单易用，代码可读性更高。</p></li><li><p>使用步骤：</p></li></ol><ul><li><p>创建操作，将操作封装到NSOperation对象中,执行的顺序取决于操作之间的相对优先级，操作执行结束的顺序，取决于操作本身！</p></li><li><p>创建队列 NSOperationQueue，将操作添加到队列中，一个队列中同时能并发执行的最大操作数由maxConcurrentOperationCount 决定，也就是一个操作队列中的操作是串行还是并发执行，由maxConcurrentOperationCount它决定！</p><ul><li>maxConcurrentOperationCount &#x3D; -1，默认，并发执行</li><li>maxConcurrentOperationCount &#x3D; 1，串行执行</li><li>maxConcurrentOperationCount &#x3D; 3，并发执行</li></ul></li><li><p>系统会将队列中的操作取出，在新线程中执行操作。</p></li><li><p>操作有几种状态</p><ul><li>op1.isReady; 是否准备就绪</li><li>op1.isExecuting; 是否正在执行</li><li>op1.isCancelled; 是否已经取消</li><li>op1.isFinished; 是否执行完成</li></ul></li><li><p>取消操作和队列</p><ul><li>[op1 cancel]; 取消操作，实际上是标记isCancelled状态</li><li>[queue cancelAllOperations]; 取消队列</li></ul></li></ul><h1 id="你是否在定义过NSOperation"><a href="#你是否在定义过NSOperation" class="headerlink" title="你是否在定义过NSOperation?"></a>你是否在定义过NSOperation?</h1><p>自定义NSOperation可以通过重写main或者start方法。重写main方法，不需要管理操作的状态属性isExecuting和isFinished。重写start方法需要管理操作的状态属性。</p><h1 id="【面试题】：如果在工作中有这样一个需求，使用AFNetworking请求A接口拿到A接口返回的id-a，用id-a作为参数去请求B接口，拿到B网络返回的name-b去查数据库，然后刷新页面。该怎么实现呢？"><a href="#【面试题】：如果在工作中有这样一个需求，使用AFNetworking请求A接口拿到A接口返回的id-a，用id-a作为参数去请求B接口，拿到B网络返回的name-b去查数据库，然后刷新页面。该怎么实现呢？" class="headerlink" title="【面试题】：如果在工作中有这样一个需求，使用AFNetworking请求A接口拿到A接口返回的id_a，用id_a作为参数去请求B接口，拿到B网络返回的name_b去查数据库，然后刷新页面。该怎么实现呢？"></a>【面试题】：如果在工作中有这样一个需求，使用AFNetworking请求A接口拿到A接口返回的id_a，用id_a作为参数去请求B接口，拿到B网络返回的name_b去查数据库，然后刷新页面。该怎么实现呢？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) dispatch_semaphore_t semaphore;</span><br><span class="line">@property (nonatomic, assign) dispatch_queue_t queue;</span><br><span class="line"> </span><br><span class="line">- (void)viewDidLoad&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //：测试</span><br><span class="line">    [self semaphoreSync];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)semaphoreSync&#123;</span><br><span class="line">    // 创建信号量，传入参数0</span><br><span class="line">    self.semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    // 创建队列，这里串行和并发并无区别</span><br><span class="line">    self.queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    // 开启一个新线程，</span><br><span class="line">    // 这里之所以要创建一个新线程，而不是在当前（主线程）执行，是因为，AF的网络请求返回默认是在主线程中执行，如果我们在当前线程执行一下操作，会发生线程死锁的现象，</span><br><span class="line">    dispatch_async(self.queue, ^&#123;</span><br><span class="line">        // 任务A</span><br><span class="line">        int ida = [self requestA];</span><br><span class="line">        // 任务B</span><br><span class="line">        NSString *name = [self requestB:ida];</span><br><span class="line">        // 任务C</span><br><span class="line">        NSDictionary *res = [self queryDB:name];</span><br><span class="line">        NSLog(@&quot;%@&quot;, res);</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            // 刷新页面</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (int)requestA&#123;</span><br><span class="line">    __block int ida = 0;</span><br><span class="line">    // AF</span><br><span class="line">    NSArray *paths = @[@(self.currentPage), @(pageNum), @(100)];</span><br><span class="line">    [[ZJNetWorkManager shareManager] GetWithUrlString:TC_API(GetCourseList) paths:paths successedBlock:^(BOOL successed, id  _Nonnull jsonObject) &#123;</span><br><span class="line">        ida = 1;</span><br><span class="line">        // 释放信号量，信号量加1，释放当前线程，然后执行return操作</span><br><span class="line">        dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">    &#125; failedBlock:^(NSError * _Nonnull error) &#123;</span><br><span class="line">        dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line">    // 信号量减1，阻塞当前线程</span><br><span class="line">    dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"> </span><br><span class="line">    return ida;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (NSString *)requestB:(int)ida&#123;</span><br><span class="line">    __block NSString *name;</span><br><span class="line">    NSArray *paths = @[@(self.currentPage), @(pageNum), @(100), @(ida)];</span><br><span class="line">    [[ZJNetWorkManager shareManager] GetWithUrlString:TC_API(GetCourseList) paths:paths successedBlock:^(BOOL successed, id  _Nonnull jsonObject) &#123;</span><br><span class="line">        name = @&quot;你好👋&quot;;</span><br><span class="line">        dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">    &#125; failedBlock:^(NSError * _Nonnull error) &#123;</span><br><span class="line">        dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line">        </span><br><span class="line">    dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"> </span><br><span class="line">    return name;</span><br><span class="line">&#125; </span><br><span class="line">- (NSDictionary *)queryDB:(NSString *)name&#123;</span><br><span class="line">    //查询数据库，返回结果</span><br><span class="line">    return @&#123;@&quot;name&quot;:@&quot;name&quot;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="【面试题】根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？"><a href="#【面试题】根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？" class="headerlink" title="【面试题】根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？"></a>【面试题】根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？</h1><p>dispatch_group_t + dispatch_group_enter + dispatch_group_leave + dispatch_group_notify</p><h1 id="【面试题】请实现一个多读单写的功能？"><a href="#【面试题】请实现一个多读单写的功能？" class="headerlink" title="【面试题】请实现一个多读单写的功能？"></a>【面试题】请实现一个多读单写的功能？</h1><p>我们可以用 <code>dispatch_barrier_async</code> 实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@interface TKReadWhiteSafeDic() &#123;</span><br><span class="line">    // 定义一个并发队列</span><br><span class="line">    dispatch_queue_t concurrent_queue;</span><br><span class="line">    </span><br><span class="line">    // 用户数据中心, 可能多个线程需要数据访问</span><br><span class="line">    NSMutableDictionary *userCenterDic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 多读单写模型</span><br><span class="line">@implementation TKReadWhiteSafeDic</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        // 通过宏定义 DISPATCH_QUEUE_CONCURRENT 创建一个并发队列</span><br><span class="line">        concurrent_queue = dispatch_queue_create(&quot;read_write_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">        // 创建数据容器</span><br><span class="line">        userCenterDic = [NSMutableDictionary dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)objectForKey:(NSString *)key &#123;</span><br><span class="line">    __block id obj;</span><br><span class="line">    // 同步读取指定数据</span><br><span class="line">    dispatch_sync(concurrent_queue, ^&#123;</span><br><span class="line">        obj = [userCenterDic objectForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setObject:(id)obj forKey:(NSString *)key &#123;</span><br><span class="line">    // 异步栅栏调用设置数据</span><br><span class="line">    dispatch_barrier_async(concurrent_queue, ^&#123;</span><br><span class="line">        [userCenterDic setObject:obj forKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>读操作为啥同步dispatch_sync</li></ul><blockquote><p>读的话通常都是直接想要结果，需要同步返回结果，如果是异步获取的话就根网络请求一样了。</p></blockquote><ul><li>写操作为啥异步dispatch_barrier_async</li></ul><blockquote><p>写操作是因为不需要等待写操作完成，所以用异步。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;你了解线程么？谈谈你对进程和线程的理解？&quot;&gt;&lt;a href=&quot;#你了解线程么？谈谈你对进程和线程的理解？&quot; class=&quot;headerlink&quot; title=&quot;你了解线程么？谈谈你对进程和线程的理解？&quot;&gt;&lt;/a&gt;你了解线程么？谈谈你对进程和线程的理解？&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-面试题" scheme="https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习43：继承</title>
    <link href="https://www.bboyzj.cn/2023/03/09/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A043%EF%BC%9A%E7%BB%A7%E6%89%BF/"/>
    <id>https://www.bboyzj.cn/2023/03/09/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A043%EF%BC%9A%E7%BB%A7%E6%89%BF/</id>
    <published>2023-03-09T12:33:59.000Z</published>
    <updated>2023-03-14T19:12:59.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>swift中，<code>只有类支持继承</code></li><li>swift中 <code>类没有统一的基类</code>。</li><li>没有继承任何父类的类是基类，但其实它是有一个父类的，叫 <code>_SwiftObject</code></li><li>被 <code>final</code> 修饰的 <code>属性、方法、下标</code> 禁止被 <code>重写</code>，禁止被 <code>继承</code></li></ul><h1 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h1><ul><li><p>不继承任何类的类是 <code>基类</code></p></li><li><p>没有指定特定的父类的类都以基类的形式创建</p></li></ul><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 基类</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String = &quot;ZJ&quot;</span><br><span class="line">    func test() &#123;</span><br><span class="line">        print(&quot;hello&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h1><ul><li><p><code>子类</code> 是基于 <code>父类</code> 创建的新类</p></li><li><p>子类写在父类前面，用 <code>:</code> 分割</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Teacher: Person &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h1><ul><li>子类可以定义自己的 <code>属性、方法、下标</code> 及其他的特征，可一级从 <code>父类继承</code>，就是所谓的 <code>重写</code></li><li>子类可以 <code>继承</code> 父类的 <code>属性、方法、下标</code>，前面加 <code>override</code> 关键字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 基类</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String = &quot;ZJ&quot;</span><br><span class="line">    var desc: String&#123;</span><br><span class="line">        return name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子类</span><br><span class="line">class Student: Person &#123;</span><br><span class="line">    // 重写</span><br><span class="line">    override var desc: String&#123;</span><br><span class="line">        return super.desc + &quot;hello&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let s = Student()</span><br><span class="line">print(s.desc)</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">ZJ hello</span><br></pre></td></tr></table></figure><h1 id="访问父类的-属性、方法、下标"><a href="#访问父类的-属性、方法、下标" class="headerlink" title="访问父类的 属性、方法、下标"></a>访问父类的 属性、方法、下标</h1><ul><li>通过使用 <code>super</code> 前缀访问父类的、<code>属性、方法、下标脚本</code></li></ul><blockquote><p>super.someMethod() 重写父类的方法<br>super.someProperty 重写父类的属性<br>super[someIndex] 重写父类的下标脚本</p></blockquote><h1 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">class Person &#123;</span><br><span class="line">    // 实例方法</span><br><span class="line">    func test() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子类 Teacher 继承 Person 父类</span><br><span class="line">class Teacher: Person &#123;</span><br><span class="line">    // 子类重写父类的 test() 方法，用 override 关键字</span><br><span class="line">    override func test() &#123;</span><br><span class="line">        print(&quot;呜呼！&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let t = Teacher()</span><br><span class="line">t.test()</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">呜呼！</span><br></pre></td></tr></table></figure><h1 id="重写属性的getter和setter方法"><a href="#重写属性的getter和setter方法" class="headerlink" title="重写属性的getter和setter方法"></a>重写属性的getter和setter方法</h1><p>可以自定义一个gett或setter来重写父类继承的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var desc: String = &quot;ZJ&quot;</span><br><span class="line">&#125;</span><br><span class="line">class Teacher: Person &#123;</span><br><span class="line">    var age: Int = 0</span><br><span class="line">    override var desc: String &#123;</span><br><span class="line">        return super.desc + &quot;is \(age)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let t = Teacher()</span><br><span class="line">age = 32</span><br><span class="line">print(t.desc)</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">ZJ is 32</span><br></pre></td></tr></table></figure><h1 id="重写属性观察器"><a href="#重写属性观察器" class="headerlink" title="重写属性观察器"></a>重写属性观察器</h1><ul><li><p>可以为继承的属性添加属性观察器</p></li><li><p>不可以为继承的 <code>常量存储属性</code> 或 <code>只读的计算属性</code> 添加属性观察器</p></li><li><p>不能为同一个属性同时提供重写 <code>setter和属性观察器</code></p></li></ul><h1 id="禁止重写"><a href="#禁止重写" class="headerlink" title="禁止重写"></a>禁止重写</h1><ul><li>可以用 <code>final</code> 关键字禁止被 <code>继承</code></li><li>禁止继承属性： final var（变量属性）、final let（常量属性）</li><li>禁止继承方法：final func（实例方法）、final class（类方法）、</li><li>禁止继承下标：final subscribe（下标）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;swift中，&lt;code&gt;只有类支持继承&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;swift中 &lt;code&gt;类没有统一的基类&lt;/code</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习：swift中方法的调用</title>
    <link href="https://www.bboyzj.cn/2023/03/09/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/"/>
    <id>https://www.bboyzj.cn/2023/03/09/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</id>
    <published>2023-03-09T08:29:57.000Z</published>
    <updated>2023-03-09T08:29:57.676Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>性能优化03：Crash检测和优化方案</title>
    <link href="https://www.bboyzj.cn/2023/03/09/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603%EF%BC%9ACrash%E6%A3%80%E6%B5%8B%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <id>https://www.bboyzj.cn/2023/03/09/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603%EF%BC%9ACrash%E6%A3%80%E6%B5%8B%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</id>
    <published>2023-03-08T21:32:04.000Z</published>
    <updated>2023-03-09T19:15:28.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="Crash原因"><a href="#Crash原因" class="headerlink" title="Crash原因"></a>Crash原因</h1><h1 id="Crash原因和解决"><a href="#Crash原因和解决" class="headerlink" title="Crash原因和解决"></a>Crash原因和解决</h1><ol><li>找不到方法的实现 unrecognized selector sent to instance</li></ol><ul><li><p>原因：找不到方法iOS系统抛出异常崩溃</p></li><li><p>解决方案：给NSObject添加一个分类，实现消息转发的几个方法</p></li></ul><ol start="2"><li>KVC造成的crash</li></ol><ul><li><p>原因：给不存在的key（包括key为nil）设置value</p></li><li><p>解决方法：</p></li><li><p>如果属性存在，利用iOS的反射机制来规避，NSStringFromSelector(@selector())将SEL反射为字符串作为key。这样在@selector()中传入方法名的过程中，编译器会有合法性检查，如果方法不存在或未实现会报黄色警告。</p></li><li><p>重写类的setValue:forUndefinedKey:和valueForUndefinedKey:</p></li></ul><ol start="3"><li>KVO引起的崩溃</li></ol><ul><li><p>原因：添加了观察者，没有在正确的时机移除</p></li><li><p>解决方案：addObserver和removeObserver一定要成对出现</p></li></ul><ol start="4"><li>集合类相关崩溃</li></ol><ul><li><p>原因：越界、添加nil、越界、添加nil</p></li><li><p>解决方案：</p></li></ul><p>给集合类添加category重写原来的方法，在内部做判段<br>使用Runtime把原来的方法替换成自定义的安全方法</p><ol start="5"><li>多线程中的崩溃</li></ol><p>原因:子线程中更新UI</p><p>解决方案：主线程更新UI</p><h1 id="Crash收集"><a href="#Crash收集" class="headerlink" title="Crash收集"></a>Crash收集</h1><h1 id="检测方式"><a href="#检测方式" class="headerlink" title="检测方式"></a>检测方式</h1><ol><li><p>第三方框架：Bugly</p></li><li><p>iTunes Store收集：上传App Store的app，苹果有帮我们收集，Xcode-&gt;Windows-&gt;Organizer</p></li><li><p>NSSetUncaughtExceptionHandler：iOS SDK 中提供了一个现成的函数</p></li></ol><h1 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h1 id=&quot;Crash原因&quot;&gt;&lt;a href=&quot;#Crash原因&quot; class=&quot;headerlink&quot; title=&quot;Crash原因&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
