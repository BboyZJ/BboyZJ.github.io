<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张建的博客</title>
  <icon>https://www.gravatar.com/avatar/134cc2bfaf649e446f661778f4112fca</icon>
  <subtitle>成功的道路上只有荆棘，没有坦途</subtitle>
  <link href="https://www.bboyzj.cn/atom.xml" rel="self"/>
  
  <link href="https://www.bboyzj.cn/"/>
  <updated>2023-03-30T05:45:47.542Z</updated>
  <id>https://www.bboyzj.cn/</id>
  
  <author>
    <name>小J</name>
    <email>13718004742@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>性能优化05：Network 网络</title>
    <link href="https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605%EF%BC%9ANetwork%20%E7%BD%91%E7%BB%9C/"/>
    <id>https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605%EF%BC%9ANetwork%20%E7%BD%91%E7%BB%9C/</id>
    <published>2023-09-10T04:13:29.000Z</published>
    <updated>2023-03-30T05:45:47.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="弱网优化"><a href="#弱网优化" class="headerlink" title="弱网优化"></a>弱网优化</h1><ul><li><p>所谓弱网络，指在网络不好的情况下使用APP，如 <code>2G、3G网络</code>，用户的网络速度基本在 <code>10k/s~60k/s</code>。</p></li><li><p>考虑海外应用的话，就必须考虑弱网优化的方案了。</p></li><li><p>苹果建议，使用苹果内置的 <code>Network Link Conditioner</code> 来模拟网络环境处理 <code>APP</code> 的体验问题，在Xcode和手机都可以开启</p></li></ul><h1 id="Xcode：系统偏好设置"><a href="#Xcode：系统偏好设置" class="headerlink" title="Xcode：系统偏好设置"></a>Xcode：系统偏好设置</h1><h1 id="iPhone：开发者-gt-Network-Link-Conditioner"><a href="#iPhone：开发者-gt-Network-Link-Conditioner" class="headerlink" title="iPhone：开发者 -&gt; Network Link Conditioner"></a>iPhone：开发者 -&gt; Network Link Conditioner</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;弱网优化&quot;&gt;&lt;a href=&quot;#弱网优化&quot; class=&quot;headerlink&quot; title=&quot;弱网优化&quot;&gt;&lt;/a&gt;弱网优化&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;所谓弱网络，指在网络不好的情况下使用APP，如 &lt;code&gt;2G、3G网络&lt;/code&gt;，用户的网络速度基</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>性能优化04：Energy 耗电</title>
    <link href="https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604%EF%BC%9AEnergy%20%E8%80%97%E7%94%B5/"/>
    <id>https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604%EF%BC%9AEnergy%20%E8%80%97%E7%94%B5/</id>
    <published>2023-09-10T04:13:29.000Z</published>
    <updated>2023-03-30T05:53:39.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>所有应用程序在执行网络操作、更新用户界面或在CPU上运行代码时都会消耗能量。随着用户越来越多地依赖电池电量，以及应用程序的激增，能效已成为用户体验中不可或缺的一部分。</p><h1 id="电池寿命"><a href="#电池寿命" class="headerlink" title="电池寿命"></a>电池寿命</h1><p>随着能源效率的下降，<code>电池</code> 的寿命也会下降。同时消耗过多的资源会导致界面滞后，对用户输入的响应会很慢。随着越来越多的应用程序使用越来越多的资源，系统工作起来越来越努力，速度也越来越快，设备的物理温度也在逐渐升高。当这种情况发生时，系统会采取措施将温度降低到更容易接受的水平。</p><h1 id="能量消耗的因素"><a href="#能量消耗的因素" class="headerlink" title="能量消耗的因素"></a>能量消耗的因素</h1><ol><li><p>CPU: CPU是能源的主要消耗者。高CPU使用周期会迅速耗尽用户的电池。 CPU使用率超过20%就会快速耗干电池电量——建议只在必要时通过 <code>批处理、调度和优先级排序</code> 来完成工作。</p></li><li><p>GPU: 图形处理器(显卡的处理器)，乱使用GPU会导致交互差，并且降低电池寿命。</p></li><li><p>Network：大多数iOS应用程序执行网络操作。当联网发生时，蜂窝无线电和Wi-Fi等组件就会启动并消耗能量。通过 <code>批量处理和减少事务、压缩数据和适当处理错误</code>，您的应用程序可以为节能做出重大贡献。</p></li><li><p>Location: 许多应用程序发出位置请求是为了记录用户的物理活动或提供基于环境的警报。能量消耗随着精确度的提高和位置请求的延长而增加。你的应用应该尽可能减少定位活动的准确性和持续时间。当不再需要时停止位置请求。</p></li><li><p>Background: <code>后台</code> 状态App仍会消耗电量，App要按需执行后台操作，并使用延迟APNS来保证系统运算高效执行。另外，在app进入后台状态是，立即减少动作，并且通知系统一次这些动作已经完成</p></li><li><p>Bluetooth: 长时间的 <code>蓝牙</code> 活动会耗尽iOS设备和蓝牙设备的电池。只要可能，批处理和缓冲蓝牙活动，并减少对数据的轮询。</p></li><li><p>Device wakes：iOS设备依靠睡眠来延长电池寿命。无论设备何时唤醒，都会有很高的开销成本，因为必须为屏幕和其他资源提供电源。你的应用程序，尤其是在后台操作时，应该尽可能空闲，除非绝对必要，避免用推送通知或其他活动唤醒设备</p></li></ol><h1 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h1><ol><li><p>Time Profile：时间分析器分析模板。使用此模板对正在运行的进程执行低开销的基于时间的采样。Time Profiler 监视应用程序中正在运行的线程，并定期采样。为每个样本收集完整的回溯，允许您深入查看样本，以准确找到代码中花费大量时间的位置。</p></li><li><p>Animation Hitches：核心动画分析模板。使用此模板可以测量图形性能和CPU使用率。启用模板 Core Animation 的 <code>Flash Updated Regions</code> 设置，以查看应用中发生的每个屏幕更新，并观察不必要或意外的更新。</p></li><li><p>Activity Monitor: 活动监视器分析模板。使用此模板可以监视整体CPU，磁盘I&#x2F;O和网络使用情况。</p></li></ol><h1 id="Energy-log调试和演示"><a href="#Energy-log调试和演示" class="headerlink" title="Energy log调试和演示"></a>Energy log调试和演示</h1><ol><li>检查第一步，是通过xcode开发工具的 <code>energy impact</code> 来整体查看app的耗电情况。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303231852146.png"                                     ></p><p>Overhead：表示开销，包括CPU的唤起，无线电模组(蓝牙&amp;WiFi)，和其他系统资源的调用等。</p><ol start="2"><li>检查第二步：通过instrument工具的 <code>energy log</code> 来检测具体的耗电模块。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303231853126.png"                                     ></p><h1 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h1><ol><li>cpu层面的优化</li></ol><ul><li>尽量降低CPU</li><li>少使用定时器</li><li>优化I&#x2F;O操作<ul><li>写入数据最好一次性写入</li><li>读取数据最好使用GCD异步操作</li><li>数据流比较大，建议使用数据库</li></ul></li><li>适当使用多线程，不宜过多，不要阻塞主线程</li><li>优化算法，减少循环次数</li><li>避免庞大的 <code>xib、storyBoard</code>， 尽量使用纯代码开发</li></ul><ol start="2"><li>GPU 层面的优化</li></ol><ul><li>减少视图刷新，按需刷新；</li><li>尽量少使用圆角和透明度；</li></ul><ol start="3"><li>Network 网络请求层面的优化</li></ol><ul><li>减少、压缩网络数据</li><li>如果多次请求的结果是相同的，尽量使用缓存</li><li>使用断点续传，否则网络不稳定时可能多次传输相同的内容</li><li>网络不可用时，不要尝试执行网络请求</li><li>让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间</li><li>批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载</li></ul><ol start="4"><li>Location 定位层面优化</li></ol><ul><li>如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电</li><li>如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务</li><li>尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest</li><li>需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新</li><li>尽量不要使用startMonitoringSignificantLocationChanges，优先考虑startMonitoringForRegion</li></ul><ol start="5"><li>Bluetooth, Background</li></ol><ul><li>蓝牙按需取用，定位之后要关闭或降低定位频率，进入后台关闭定位，停止定时器运行等</li></ul><ol start="4"><li>硬件检测优化(不常用)</li></ol><ul><li>用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;所有应用程序在执行网络操作、更新用户界面或在CPU上运行代码时都会消耗能量。随着用户越来越多地依赖电池电量，以及应用程序的激增，能效已成为用</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>性能优化06：启动优化</title>
    <link href="https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</id>
    <published>2023-09-10T04:13:29.000Z</published>
    <updated>2023-03-30T06:10:57.318Z</updated>
    
    <content type="html"><![CDATA[<p>启动优化查看以下三篇文章：</p><p><a href="https://www.bboyzj.cn/2021/05/04/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8632%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">OC底层原理32：启动优化（一）基本概念</a></p><p><a href="https://www.bboyzj.cn/2021/05/11/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8633%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/">OC底层原理33：启动优化（二）优化建议</a></p><p><a href="https://www.bboyzj.cn/2021/05/17/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8634%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%87%8D%E6%8E%92/">OC底层原理34：启动优化（三）二进制重排</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;启动优化查看以下三篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bboyzj.cn/2021/05/04/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8632%EF%BC%9A%E5%</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>OC学习22.2：RTMP协议</title>
    <link href="https://www.bboyzj.cn/2023/05/06/OC/OC%E5%AD%A6%E4%B9%A022.2%EF%BC%9ARTMP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://www.bboyzj.cn/2023/05/06/OC/OC%E5%AD%A6%E4%B9%A022.2%EF%BC%9ARTMP%E5%8D%8F%E8%AE%AE/</id>
    <published>2023-05-06T11:35:34.000Z</published>
    <updated>2023-05-06T11:45:13.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是RTMP协议？"><a href="#什么是RTMP协议？" class="headerlink" title="什么是RTMP协议？"></a>什么是RTMP协议？</h1><p><code>RTMP协议</code> 是一个专门为 <code>高效传输视频，音频和数据</code> 而设计的协议。它通过建立一个 <code>二进制TCP连接</code> 或者 <code>连接HTTP隧道</code> 实现 <code>实时的视频和声音传输</code>。</p><h1 id="RTMP作用？"><a href="#RTMP作用？" class="headerlink" title="RTMP作用？"></a>RTMP作用？</h1><ul><li><p>RTMP比传统媒介服务器流出的媒介协议支持更多。它支持可能包含 <code>声音、影像和脚本数据</code> 从服务器到客户和从客户到服务器多条线路的动态传输。<code>RTMP对声音、影像和脚本数据分别处理</code>。</p></li><li><p>声音和视频数据被分开地缓冲在服务器中。如果声音数据在声音缓冲器中达到某一极限，所有在缓冲器中的数据将被丢掉，并且最近到达的数据被允许开始收集在缓冲中并被送到各个客户。视频数据被以相似的方式处理，不同是当新的关键帧到达时，缓冲器中数据才被清除。在丢掉旧的帧数据时，如果发现客户端的数据有误，则将新旧两个不同的帧进行拟合。</p></li><li><p>RTMP对数据给予不同的优先级别。在实时交谈中，声音是最重要的，影像给予低优先级，而脚本数据被给予的优先权介于声音和影像中间。</p></li><li><p>RTMP协议可以创建多个数据流，但是每个数据流只能有一个方向。使用RTMP可以构建这样的一个系统，客户端可以同时与RTMP服务器和应用服务器进行交互，使得服务端的负荷得以分散，虽然在这种改进的系统结构中，RTMP服务器的性能要求比较高。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是RTMP协议？&quot;&gt;&lt;a href=&quot;#什么是RTMP协议？&quot; class=&quot;headerlink&quot; title=&quot;什么是RTMP协议？&quot;&gt;&lt;/a&gt;什么是RTMP协议？&lt;/h1&gt;&lt;p&gt;&lt;code&gt;RTMP协议&lt;/code&gt; 是一个专门为 &lt;code&gt;高效传输视</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习43：iOS多个UIImageView加载高清大图</title>
    <link href="https://www.bboyzj.cn/2023/05/06/OC/OC%E5%AD%A6%E4%B9%A043%EF%BC%9AiOS%E5%A4%9A%E4%B8%AAUIImageView%E5%8A%A0%E8%BD%BD%E9%AB%98%E6%B8%85%E5%A4%A7%E5%9B%BE/"/>
    <id>https://www.bboyzj.cn/2023/05/06/OC/OC%E5%AD%A6%E4%B9%A043%EF%BC%9AiOS%E5%A4%9A%E4%B8%AAUIImageView%E5%8A%A0%E8%BD%BD%E9%AB%98%E6%B8%85%E5%A4%A7%E5%9B%BE/</id>
    <published>2023-05-06T08:33:15.000Z</published>
    <updated>2023-05-08T06:57:25.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在项目中遇到了加载高清大图的场景，处理不好占用大量的内存，造成性能问题，影响用户体验。</p><p>如何去解决加载高清大图这个难点呢？先看看iOS中图片的加载流程</p><h1 id="iOS中图片的加载流程"><a href="#iOS中图片的加载流程" class="headerlink" title="iOS中图片的加载流程"></a>iOS中图片的加载流程</h1><ol><li><p>加载图片数据（尚未解码）</p></li><li><p>解码图片数据</p></li><li><p>缓存图片数据</p></li><li><p>渲染图片数据</p></li></ol><p>性能问题一般是发生在 <code>解码图片</code> 这个步骤上，<code>SDWebImage</code> 解码图片解码的代码是在 <code>SDWebImageCoderHelper</code> 中的 <code>decodedImageWithImage</code> 函数中，并 <code>缓存起来</code>，以保证 <code>tableViews/collectionViews</code> 交互更加流畅，如果是 <code>加载高分辨率图片</code> 的话，会适得其反，有可能造成 <code>内存占用过高</code> 和 <code>内存峰值过高</code> 的问题</p><h1 id="优化的思路"><a href="#优化的思路" class="headerlink" title="优化的思路"></a>优化的思路</h1><ul><li><p><code>SDWebImage</code> 加载高清图的性能问题，主要是其直接加载高清图原来尺寸导致的，而 <code>加载一张图片的内存占用 = 图片Width * 图片Height * 4</code>。</p></li><li><p>对于高分辨率的图片，应该在 <code>图片解压</code> 后，<code>禁止缓存解码后的数据</code>：</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[SDImageCache sharedImageCache] setShouldDecompressImages:NO];</span><br><span class="line">[[SDWebImageDownloader sharedDownloader] setShouldDecompressImages:NO];</span><br></pre></td></tr></table></figure></div><p>当然，你也可以设置 <code>SDWebImage</code> 的其他参数，比如是 <code>否缓存到内存以及内存缓存最高限制</code> 等，来保证内存安全：</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ol><li>APPDelegate中设置相关参数。</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)imageLoadingSettings &#123;</span><br><span class="line">    // 最大缓存周期 一周</span><br><span class="line">    [SDImageCache sharedImageCache].config.maxCacheAge = 3600 * 24 * 7;</span><br><span class="line">    // 最大内存限制 20M</span><br><span class="line">    [SDImageCache sharedImageCache].maxMemoryCost = 1024 * 1024 * 20;</span><br><span class="line">    // 不缓存到内存</span><br><span class="line">    [SDImageCache sharedImageCache].config.shouldCacheImagesInMemory = NO;</span><br><span class="line">    // 不解压图片</span><br><span class="line">    [SDImageCache sharedImageCache].config.shouldDecompressImages = NO;</span><br><span class="line">    // 不解压图片</span><br><span class="line">    [SDWebImageDownloader sharedDownloader].shouldDecompressImages = NO;</span><br><span class="line">    // iOS就不会把整个文件全部读取的内存了，而是将文件映射到进程的 地址空间 中，这么做并不会占用实际内存。这样就可以解决内存占用过高的问题。</span><br><span class="line">    [SDImageCache sharedImageCache].config.diskCacheReadingOptions = NSDataReadingMappedIfSafe;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="2"><li>ViewController中实现</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// Decompress 解码</span><br><span class="line">static BOOL SDImageCacheOldShouldDecompressImages = YES;</span><br><span class="line">static BOOL SDImagedownloderOldShouldDecompressImages = YES;</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">   </span><br><span class="line">    // 设置图片缓存方式 防止图片过大崩溃的情况</span><br><span class="line">    SDImageCache *canche = [SDImageCache sharedImageCache];</span><br><span class="line">    SDImageCacheOldShouldDecompressImages = canche.config.shouldDecompressImages;</span><br><span class="line">    canche.config.shouldDecompressImages = NO;</span><br><span class="line">    SDWebImageDownloader *downloder = [SDWebImageDownloader sharedDownloader];</span><br><span class="line">    SDImagedownloderOldShouldDecompressImages = downloder.shouldDecompressImages;</span><br><span class="line">    downloder.shouldDecompressImages = NO;</span><br><span class="line">&#125;</span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">    </span><br><span class="line">    // Dispose of any resources that can be recreated.</span><br><span class="line">    [[SDWebImageManager sharedManager].imageCache clearMemory];</span><br><span class="line">    [[SDWebImageManager sharedManager].imageCache clearDiskOnCompletion:nil];</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc &#123;    </span><br><span class="line">    [[SDImageCache sharedImageCache] clearMemory];</span><br><span class="line">    SDImageCache *canche = [SDImageCache sharedImageCache];</span><br><span class="line">    canche.config.shouldDecompressImages = SDImageCacheOldShouldDecompressImages;</span><br><span class="line">    SDWebImageDownloader *downloder = [SDWebImageDownloader sharedDownloader];</span><br><span class="line">    downloder.shouldDecompressImages = SDImagedownloderOldShouldDecompressImages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="加载大图的解决方案"><a href="#加载大图的解决方案" class="headerlink" title="加载大图的解决方案"></a>加载大图的解决方案</h1><ol><li>显示大图时，传统加载方法会造成内存暴涨，造成主线程阻塞，甚至造成程序crash。可以使用 <code>CATiledLayer</code> 显示，<code>CATiledLayer</code> 类似瓦片视图，他将需要绘制的内容分割成许多小块，然后异步绘制相应的小块，这样就节约了处理时间和内存。</li></ol><ul><li><p>它不需要你自己计算分块显示的区域，它自己直接提供，你只需要根据这个区域计算图片相应区域，然后画图就可以了。</p></li><li><p>它是在其他线程画图，不会因为阻塞主线程而导致卡顿。</p></li><li><p>它自己实现了只在屏幕区域显示图片，屏幕区域外不会显示，而且当移动图片时，它会自动绘制之前未绘制的区域，当你缩放时它也会自动重绘。</p></li></ul><ol start="2"><li><code>CATiledLayer</code> 是为载入大图造成的性能问题提供的一个解决方案，具体如何划分小块和缩放时的加载策略，与CATiledLayer三个重要属性有关:</li></ol><ul><li><p>levelsOfDetail：levelsOfDetail 指的是该图层缓存的缩小 LOD 数目，默认值为1，每进一级会对前一级分辨率的一半进行缓存，图层的 <code>levelsOfDetail</code> 最大值，对应至少一个像素点。</p></li><li><p>levelsOfDetailBias：levelsOfDetailBias 指的是该图层缓存的放大LODB数目，它是layer的放大级别重绘设置，默认为0，即不会额外缓存放大层次，每进一级会对前一级两倍分辨率进行缓存。</p></li><li><p>tileSIze:（默认是256x256）tiledSize是layer划分视图区域最大尺寸，主要是影响layer的切片数量。</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&lt;CALayerDelegate&gt;</span><br><span class="line">// 构建一个容器来展示大图，保证其contenSize与图片尺寸大小一致</span><br><span class="line">@property (nonatomic, weak) IBOutlet UIScrollView *scrollView;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    // 创建图层，并设置属性信息</span><br><span class="line">    CATiledLayer *tileLayer = [CATiledLayer layer];</span><br><span class="line">    </span><br><span class="line">    CGFloat scale = UIScreen.mainScreen.scale;  // 确保scale比例一致</span><br><span class="line">    tileLayer.frame = CGRectMake(0, 0, 3972/scale,15718/scale);// 图片像素</span><br><span class="line">    tileLayer.delegate = self;</span><br><span class="line">    tileLayer.tileSize = CGSizeMake(256/scale, 256/scale);  // 每个瓷砖块的大小</span><br><span class="line">    [self.scrollView.layer addSublayer:tileLayer];</span><br><span class="line">    </span><br><span class="line">    self.scrollView.contentSize = tileLayer.frame.size;</span><br><span class="line">    </span><br><span class="line">    // 刷新当前屏幕Rect</span><br><span class="line">    [tileLayer setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当滑动到不同区域时会调用此方法</span><br><span class="line">- (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx</span><br><span class="line">&#123;</span><br><span class="line">    // 确定坐标信息</span><br><span class="line">    CGRect bounds = CGContextGetClipBoundingBox(ctx);</span><br><span class="line">    NSInteger x = floor(bounds.origin.x / layer.tileSize.width);</span><br><span class="line">    NSInteger y = floor(bounds.origin.y / layer.tileSize.height);</span><br><span class="line">    </span><br><span class="line">    // 加载小图</span><br><span class="line">    NSString *imageName = [NSString stringWithFormat: @&quot;zz_%02i_%02i&quot;, x, y];</span><br><span class="line">    NSString *imagePath = [[NSBundle mainBundle] pathForResource:imageName ofType:@&quot;jpg&quot;];</span><br><span class="line">    UIImage *tileImage = [UIImage imageWithContentsOfFile:imagePath];</span><br><span class="line">    </span><br><span class="line">    // 在TiledLayer上绘制图片</span><br><span class="line">    UIGraphicsPushContext(ctx);</span><br><span class="line">    [tileImage drawInRect:bounds];</span><br><span class="line">    UIGraphicsPopContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在项目中遇到了加载高清大图的场景，处理不好占用大量的内存，造成性能问题，影响用户体验。&lt;/p&gt;
&lt;p&gt;如何去解决加载高清大图这个难点呢？先看</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-面试题" scheme="https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Xcode学习04：Shell自动化脚本打IPA包</title>
    <link href="https://www.bboyzj.cn/2023/05/01/Xcode/Xcode%E5%AD%A6%E4%B9%A004%EF%BC%9AShell%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E6%89%93IPA%E5%8C%85/"/>
    <id>https://www.bboyzj.cn/2023/05/01/Xcode/Xcode%E5%AD%A6%E4%B9%A004%EF%BC%9AShell%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E6%89%93IPA%E5%8C%85/</id>
    <published>2023-05-01T13:46:19.000Z</published>
    <updated>2023-05-03T04:08:42.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>iOS 项目打包通常都是通过 <code>Xcode -&gt; Product -&gt; Archive</code> 去给项目打包，这是常用的方式，还有一种方式就是 <code>shell脚本自动化打包</code>，可以用一行代码解决打包问题，</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ol><li>项目下创建 <code>ZJ_Shell.sh</code> 脚本文件，可以将该文件放在一个文件夹 <code>Shell</code> 下，也可以放在项目根目录下，具体看你设计实现方式</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305031157028.png"                                     ></p><ol start="2"><li>在 <code>ZJ_Shell.sh</code> 文件中编写脚本</li></ol><ul><li>使用方法 开始</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">#--------使用方法 开始--------</span><br><span class="line"># 1、将该脚本放在工程的根目录下（xcworkspace 或 xcodeproj 文件同级目录）或新建一个Shell文件夹下</span><br><span class="line"># 2、请根据自己项目的情况选择使用 xcworkspace 还是 xcodeproj 形式，目前默认为 xcworkspace 形式</span><br><span class="line"># 3、打开终端、执行脚本（输入 sh，将脚本文件拉倒终端，会生成文件路径，然后enter就可）</span><br><span class="line"># 这个脚本主要介绍放在Shell文件夹下</span><br><span class="line">#--------使用方法 结束--------</span><br></pre></td></tr></table></figure></div><ul><li>项目自定义配置</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;************************************&quot;</span><br><span class="line">echo &quot;==========项目自定义配置 开始==========&quot;</span><br><span class="line">## 自定义好下列参数后再执行该脚本</span><br><span class="line"></span><br><span class="line"># 工程Project名称</span><br><span class="line">PROJECT_NAME=&quot;UBR&quot;</span><br><span class="line"># Scheme名</span><br><span class="line">SCHEME_NAME=&quot;UBR&quot;</span><br><span class="line"># 打包编译的方式 Debug/Release，一般用Release</span><br><span class="line">BUILD_CONFIGURATION=&quot;Debug&quot;</span><br><span class="line"># 打包的方式method：development/ad-hoc/app-store/nterprise</span><br><span class="line">METHOD=&quot;ad-hoc&quot;</span><br><span class="line"># compileBitcode选项配置，默认YES，要设置成NO</span><br><span class="line">COMPILEBITCODE=&quot;NO&quot;</span><br><span class="line"># SDK</span><br><span class="line">SDK_NAME=iphoneos</span><br><span class="line"># # 和method对应的mobileprovision文件名，手动管理时必填</span><br><span class="line"># MOBILEPROVISION_NAME=&quot;&quot;</span><br><span class="line"># # 项目的bundleID，手动管理时必填</span><br><span class="line"># BUNDLE_IDENTIFIER=&quot;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;项目自定义配置 打印：&quot;</span><br><span class="line">echo &quot;PROJECT_NAME=$&#123;PROJECT_NAME&#125;&quot;</span><br><span class="line">echo &quot;SCHEME_NAME=$&#123;SCHEME_NAME&#125;&quot;</span><br><span class="line">echo &quot;BUILD_CONFIGURATION=$&#123;BUILD_CONFIGURATION&#125;&quot;</span><br><span class="line">echo &quot;METHOD=$&#123;METHOD&#125;&quot;</span><br><span class="line">echo &quot;COMPILEBITCODE=$&#123;COMPILEBITCODE&#125;&quot;</span><br><span class="line">echo &quot;SDK_NAME=$&#123;SDK_NAME&#125;&quot;</span><br><span class="line"># echo &quot;MOBILEPROVISION_NAME=$&#123;MOBILEPROVISION_NAME&#125;&quot;</span><br><span class="line"># echo &quot;BUNDLE_IDENTIFIER=$&#123;BUNDLE_IDENTIFIER&#125;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;==========项目自定义配置  结束==========&quot;</span><br><span class="line"></span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br></pre></td></tr></table></figure></div><ul><li>项目固定参数配置</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;==========项目固定参数配置 开始==========&quot;</span><br><span class="line">##无特殊情况不用修改</span><br><span class="line"></span><br><span class="line"># 获取当前脚本所在的目录 $(cd `dirname $0`; pwd) ，脚本上一层目录 $(cd ..; pwd)</span><br><span class="line">PROJECT_ROOT_PATH=$(cd ..; pwd)</span><br><span class="line"></span><br><span class="line"># ExportOptions.plist 文件的存放路径，该文件描述了导出ipa文件所需要的配置</span><br><span class="line"># 如果不知道如何配置该plist，可直接使用xcode打包ipa结果文件夹的 ExportOptions.plist 文件</span><br><span class="line"># ExportOptions.plist 文件路径</span><br><span class="line">EXPORTOPTIONS_PLIST_PATH=$&#123;PROJECT_ROOT_PATH&#125;/ExportOptionsPlist/AdhocExportOptions.plist</span><br><span class="line"></span><br><span class="line"># xcodeproject路径</span><br><span class="line">PROJECT_PATH=$&#123;PROJECT_ROOT_PATH&#125;/$&#123;PROJECT_NAME&#125;.xcodeproj</span><br><span class="line"></span><br><span class="line"># xcworkspace路径</span><br><span class="line">WORKSPACE_PATH=$&#123;PROJECT_ROOT_PATH&#125;/$&#123;PROJECT_NAME&#125;.xcworkspace</span><br><span class="line"></span><br><span class="line">echo &quot;项目固定参数配置 打印：&quot;</span><br><span class="line">echo &quot;PROJECT_ROOT_PATH=$&#123;PROJECT_ROOT_PATH&#125;&quot;</span><br><span class="line">echo &quot;EXPORTOPTIONSP_LIST_PATH=$&#123;EXPORTOPTIONS_PLIST_PATH&#125;&quot;</span><br><span class="line">echo &quot;PROJECT_PATH=$&#123;PROJECT_PATH&#125;&quot;</span><br><span class="line">echo &quot;WORKSPACE_PATH=$&#123;WORKSPACE_PATH&#125;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;==========项目固定参数配置 结束==========&quot;</span><br><span class="line"></span><br><span class="line"># echo &#x27;//////////////////////////////////////////&#x27;</span><br><span class="line"># echo &#x27;//////////////////////////////////////////&#x27;</span><br></pre></td></tr></table></figure></div><ul><li>项目版本号配置</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;==========项目版本号配置  开始==========&quot;</span><br><span class="line"># # 获取当前版本号</span><br><span class="line"># GET_BUILD_VERSION=`xcodebuild -showBuildSettings -target $&#123;PROJECT_NAME&#125; | grep CURRENT_PROJECT_VERSION | tr -d &#x27;CURRENT_PROJECT_VERSION = &#x27;`</span><br><span class="line"># # 当前版本号</span><br><span class="line"># CURRENT_BUILD_VERSION=$&#123;GET_BUILD_VERSION&#125;</span><br><span class="line"></span><br><span class="line"># # 版本号增加 根据需求配置</span><br><span class="line"># # agvtool new-version $(($&#123;OLD_BUILD_VERSION&#125;+1))</span><br><span class="line"></span><br><span class="line"># echo &quot;项目版本号配置 打印：&quot;</span><br><span class="line"># echo &quot;CURRENT_BUILD_VERSION=$&#123;CURRENT_BUILD_VERSION&#125;&quot;</span><br><span class="line"></span><br><span class="line"># echo &quot;==========项目版本号配置  结束==========&quot;</span><br><span class="line"></span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br></pre></td></tr></table></figure></div><ul><li>IPA包路径配置</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;==========IPA包路径配置 开始==========&quot;</span><br><span class="line">## IPA包</span><br><span class="line"># 时间</span><br><span class="line">DATE=`date &#x27;+%Y%m%d_%H%M%S&#x27;`</span><br><span class="line"># IPA名称</span><br><span class="line">EXPORT_IPA_NAME=iOS_$&#123;SCHEME_NAME&#125;_$&#123;DATE&#125;_$&#123;BUILD_CONFIGURATION&#125;</span><br><span class="line"># IPA文件夹路径</span><br><span class="line">EXPORT_IPA_PATH=$&#123;PROJECT_ROOT_PATH&#125;/IPA/$&#123;EXPORT_IPA_NAME&#125;</span><br><span class="line"></span><br><span class="line"># IPA归档文件路径</span><br><span class="line">EXPORT_ARCHIVE_PATH=$&#123;EXPORT_IPA_PATH&#125;/$&#123;SCHEME_NAME&#125;.xcarchive</span><br><span class="line"></span><br><span class="line">echo &quot;IPA包路径配置 打印：&quot;</span><br><span class="line">echo &quot;DATE=$&#123;DATE&#125;&quot;</span><br><span class="line">echo &quot;EXPORT_IPA_NAME=$&#123;EXPORT_IPA_NAME&#125;&quot;</span><br><span class="line">echo &quot;EXPORT_IPA_PATH=$&#123;EXPORT_IPA_PATH&#125;&quot;</span><br><span class="line">echo &quot;EXPORT_ARCHIVE_PATH=$&#123;EXPORT_ARCHIVE_PATH&#125;&quot;</span><br><span class="line"></span><br><span class="line"># $&#123;PROJECT_ROOT_PATH&#125;：获取当前脚本目录，这个配置主要看脚本放在哪里</span><br><span class="line"># 进入项目工程目录</span><br><span class="line">cd ..</span><br><span class="line"># IPA文件目录存在</span><br><span class="line">if [ -d &quot;$&#123;EXPORT_IPA_PATH&#125;&quot; ] ; then</span><br><span class="line">    echo &quot;IPA文件路径已存在&quot;</span><br><span class="line">else # IPA文件目录不存在，则创建</span><br><span class="line">    mkdir -p $&#123;EXPORT_IPA_PATH&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;==========IPA包路径配置 结束==========&quot;</span><br><span class="line"></span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br></pre></td></tr></table></figure></div><ul><li>编译前清理工程</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;==========Build Clean Begin==========&quot;</span><br><span class="line">## 编译前清理工程</span><br><span class="line"></span><br><span class="line"># project形式</span><br><span class="line"># xcodebuild clean -project $&#123;PROJECT_ROOT_PATH&#125;/$&#123;PROJECT_NAME&#125;.xcworkspace \</span><br><span class="line">#  -scheme $&#123;SCHEME_NAME&#125; \</span><br><span class="line">#  -configuration $&#123;BUILD_CONFIGURATION&#125; \</span><br><span class="line"># -quiet || exit</span><br><span class="line"></span><br><span class="line"># workspace</span><br><span class="line">xcodebuild clean -workspace $&#123;PROJECT_ROOT_PATH&#125;/$&#123;PROJECT_NAME&#125;.xcworkspace \</span><br><span class="line"> -scheme $&#123;SCHEME_NAME&#125; \</span><br><span class="line"> -configuration $&#123;BUILD_CONFIGURATION&#125; \</span><br><span class="line"> -quiet || exit</span><br><span class="line"></span><br><span class="line">echo &quot;==========Build Clean End==========&quot;</span><br><span class="line"></span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>开始编译Archive工程</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;==========Build Archive Begin==========&quot;</span><br><span class="line">## 开始编译Archive工程</span><br><span class="line"></span><br><span class="line"># 解锁钥匙串 -p 后面跟电脑密码 根据需要设置 XXX</span><br><span class="line">security unlock-keychain -p &quot;1127&quot;</span><br><span class="line"></span><br><span class="line"># project</span><br><span class="line"># xcodebuild archive -project $&#123;PROJECT_ROOT_PATH&#125;/$&#123;PROJECT_NAME&#125;.xcodeproj \</span><br><span class="line">#    -scheme $&#123;SCHEME_NAME&#125; \</span><br><span class="line">#    -configuration $&#123;BUILD_CONFIGURATION&#125; \</span><br><span class="line">#    -sdk $&#123;SDK_NAME&#125; \</span><br><span class="line">#    -archivePath $&#123;EXPORT_ARCHIVE_PATH&#125; \</span><br><span class="line">#    -quiet || exit</span><br><span class="line"></span><br><span class="line"># workspace</span><br><span class="line">xcodebuild archive -workspace $&#123;PROJECT_ROOT_PATH&#125;/$&#123;PROJECT_NAME&#125;.xcworkspace \</span><br><span class="line">   -scheme $&#123;SCHEME_NAME&#125; \</span><br><span class="line">   -configuration $&#123;BUILD_CONFIGURATION&#125; \</span><br><span class="line">   -sdk $&#123;SDK_NAME&#125; \</span><br><span class="line">   -archivePath $&#123;EXPORT_ARCHIVE_PATH&#125; \</span><br><span class="line">   -quiet || exit</span><br><span class="line"></span><br><span class="line">echo &quot;==========Build Archive Success==========&quot;</span><br><span class="line"></span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br></pre></td></tr></table></figure></div><ul><li>删除 ExportOptions 文件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;==========Delete ExportOptions Begin==========&quot;</span><br><span class="line">## 先删除ExportOptions文件</span><br><span class="line"># if [ -f &quot;$&#123;EXPORTOPTIONS_PLIST_PATH&#125;&quot; ] ; then</span><br><span class="line">#     rm -f $&#123;EXPORTOPTIONS_PLIST_PATH&#125;</span><br><span class="line"># fi</span><br><span class="line"># # 根据参数生成ExportOptions文件</span><br><span class="line"># /usr/libexec/PlistBuddy -c  &quot;Add :compileBitcode bool $&#123;COMPILEBITCODE&#125;&quot;  $&#123;EXPORTOPTIONS_PLIST_PATH&#125;</span><br><span class="line"># /usr/libexec/PlistBuddy -c  &quot;Add :method string $&#123;METHOD&#125;&quot;  $&#123;EXPORTOPTIONS_PLIST_PATH&#125;</span><br><span class="line"># /usr/libexec/PlistBuddy -c  &quot;Add :provisioningProfiles:&quot;  $&#123;EXPORTOPTIONS_PLIST_PATH&#125;</span><br><span class="line"># /usr/libexec/PlistBuddy -c  &quot;Add :provisioningProfiles:$&#123;BUNDLE_IDENTIFIER&#125; string $&#123;MOBILEPROVISION_NAME&#125;&quot;  $&#123;EXPORTOPTIONS_PLIST_PATH&#125;</span><br><span class="line"></span><br><span class="line"># echo &quot;==========Delete ExportOptions End==========&quot;</span><br><span class="line"></span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br></pre></td></tr></table></figure></div><ul><li>导出ipa包</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;==========Export IPA Begin==========&quot;</span><br><span class="line"># 导出ipa包</span><br><span class="line">xcodebuild -exportArchive \</span><br><span class="line">   -archivePath $&#123;EXPORT_ARCHIVE_PATH&#125; \</span><br><span class="line">   -exportPath $&#123;EXPORT_IPA_PATH&#125; \</span><br><span class="line">   -exportOptionsPlist $&#123;EXPORTOPTIONS_PLIST_PATH&#125; \</span><br><span class="line">   -quiet || exit</span><br><span class="line"></span><br><span class="line"># 检查ipa包是否存在</span><br><span class="line">if [ -e $&#123;EXPORT_IPA_PATH&#125;/$&#123;SCHEME_NAME&#125;.ipa ]; then</span><br><span class="line">echo &quot;导出ipa包成功 😃 😃 😃&quot;</span><br><span class="line"># 打开IPA包的目录</span><br><span class="line">open $&#123;EXPORT_IPA_PATH&#125;</span><br><span class="line">else</span><br><span class="line">    echo &quot;导出ipa包失败 😢 😢 😢&quot;</span><br><span class="line">fi</span><br><span class="line">echo &quot;==========Export IPA End==========&quot;</span><br><span class="line"></span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br><span class="line"></span><br><span class="line">echo &quot;==========Delete Archive Start==========&quot;</span><br><span class="line"># 删除编译的.xcarchive文件，可根据各自情况选择是否保留</span><br><span class="line">if [ -d &quot;$&#123;EXPORT_ARCHIVE_PATH&#125;&quot; ]; then</span><br><span class="line">rm -rf $&#123;EXPORT_ARCHIVE_PATH&#125;</span><br><span class="line">echo &quot;删除xcarchive文件夹成功 😃 😃 😃&quot;</span><br><span class="line">fi</span><br><span class="line">echo &quot;==========Delete Archive End==========&quot;</span><br><span class="line"></span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>上传IPA到蒲公英</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;============Upload Pgyer Begin============&quot;</span><br><span class="line"># ## 上传蒲公英 https://www.pgyer.com/doc/view/upload_one_command</span><br><span class="line"></span><br><span class="line"># # &#123;$filePath&#125;是应用安装包文件的路径</span><br><span class="line"># # &#123;$uKey&#125;是开发者的用户 Key，在应用管理-API中查看</span><br><span class="line"># # &#123;$apiKey&#125;是开发者的 API Key，在应用管理-API中查看</span><br><span class="line"></span><br><span class="line"># # U_KEY</span><br><span class="line"># U_KEY=&quot;eb7e409601493709e587b1b30206e27b&quot;</span><br><span class="line"># # API_KEY</span><br><span class="line"># API_KEY=&quot;26f45bbd98549c89a14753329e234372&quot;</span><br><span class="line"># # 上传到蒲公英</span><br><span class="line"># if [ -e &quot;$&#123;EXPORT_IPA_PATH&#125;/$&#123;SCHEME_NAME&#125;.ipa&quot; ]; then</span><br><span class="line">#    echo &quot;开始上传ipa到蒲公英&quot;</span><br><span class="line">#    curl -F &quot;file=@$&#123;EXPORT_IPA_PATH&#125;/$&#123;SCHEME_NAME&#125;.ipa&quot; \</span><br><span class="line">#    -F &quot;uKey=4a5bc52e6763795e18b69bd82dd23a9e&quot; \</span><br><span class="line">#    -F &quot;_api_key=$&#123;API_KEY&#125;&quot; \</span><br><span class="line">#    &quot;https://www.pgyer.com/apiv1/app/upload&quot;</span><br><span class="line">#    echo &quot;上传ipa到蒲公英成功&quot;</span><br><span class="line"># else</span><br><span class="line">#    echo &quot;上传ipa到蒲公英失败&quot;</span><br><span class="line"># fi</span><br><span class="line"></span><br><span class="line"># echo &quot;============Upload Pgyer End============&quot;</span><br><span class="line"></span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br><span class="line">echo &#x27;//////////////////////////////////////////&#x27;</span><br></pre></td></tr></table></figure></div><ul><li>上传到App Store</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;============Uploading App Store Begin============&quot;</span><br><span class="line"># 上传App Store</span><br><span class="line"># ALTOOL_PATH=&quot;/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool&quot;</span><br><span class="line"></span><br><span class="line"># 将-u 后面的XXX替换成自己的AppID账号，-p后面的XXX替换成自己的密码</span><br><span class="line"># &quot;$ALTOOL_PATH&quot; --validate-app -f $&#123;EXPORT_IPA_PATH&#125;/$&#123;SCHEME_NAME&#125;.ipa -u 13718004742@163.com -p ZJzj5425541 -t ios --output-format xml</span><br><span class="line"># &quot;$ALTOOL_PATH&quot; --upload-app -f $&#123;EXPORT_IPA_PATH&#125;/$&#123;SCHEME_NAME&#125;.ipa -u  13718004742@163.com -p ZJzj5425541 -t ios --output-format xml</span><br><span class="line"></span><br><span class="line"># echo &quot;============Uploading App Store End============&quot;</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></div><blockquote><p>注：<br>上面的一些配置可用可不用，具体根据项目和需求去添加</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;iOS 项目打包通常都是通过 &lt;code&gt;Xcode -&amp;gt; Product -&amp;gt; Archive&lt;/code&gt; 去给项目打包，这</summary>
      
    
    
    
    <category term="Xcode" scheme="https://www.bboyzj.cn/categories/Xcode/"/>
    
    
    <category term="Xcode-常用" scheme="https://www.bboyzj.cn/tags/Xcode-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Xcode学习03：Xode报xxxiPhone(Developer Mode Disabled)</title>
    <link href="https://www.bboyzj.cn/2023/04/30/Xcode/Xcode%E5%AD%A6%E4%B9%A003%EF%BC%9AXode%E6%8A%A5xxxiPhone-Developer-Mode-DIsabled/"/>
    <id>https://www.bboyzj.cn/2023/04/30/Xcode/Xcode%E5%AD%A6%E4%B9%A003%EF%BC%9AXode%E6%8A%A5xxxiPhone-Developer-Mode-DIsabled/</id>
    <published>2023-04-30T06:53:14.000Z</published>
    <updated>2023-04-30T07:01:28.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h1><ul><li>如果你的iPhone手机连接上你的Mac，Xcode在真机运行的时候出现如下问题：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxiPhone(Developer Mode Disabled)</span><br></pre></td></tr></table></figure></div><ul><li>这是由于你的iPhone手机设备开发者模式是关闭状态</li></ul><p>隐私与安全性 -&gt; 开发者模式 -&gt; 开启</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304301500738.PNG"                                     ></p><p>打开后，设备会重启</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304301500052.PNG"                                     ></p><ul><li>此时你就可以正常运行项目到真机开发测试了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题一&quot;&gt;&lt;a href=&quot;#问题一&quot; class=&quot;headerlink&quot; title=&quot;问题一&quot;&gt;&lt;/a&gt;问题一&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;如果你的iPhone手机连接上你的Mac，Xcode在真机运行的时候出现如下问题：&lt;/li&gt;
&lt;/ul&gt;
&lt;div cl</summary>
      
    
    
    
    <category term="Xcode" scheme="https://www.bboyzj.cn/categories/Xcode/"/>
    
    
    <category term="Xcode-常用" scheme="https://www.bboyzj.cn/tags/Xcode-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Xcode学习02：git命令行工具找不到</title>
    <link href="https://www.bboyzj.cn/2023/04/30/Xcode/Xcode%E5%AD%A6%E4%B9%A002%EF%BC%9Agit%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E6%89%BE%E4%B8%8D%E5%88%B0/"/>
    <id>https://www.bboyzj.cn/2023/04/30/Xcode/Xcode%E5%AD%A6%E4%B9%A002%EF%BC%9Agit%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E6%89%BE%E4%B8%8D%E5%88%B0/</id>
    <published>2023-04-30T06:29:21.000Z</published>
    <updated>2023-04-30T06:48:41.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>当你 <code>cd</code> 项目根目录，在终端输入 <code>git</code> 命令时，如果出现如下提示：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to extract git version fromgit --version(&quot;xcrun: error: active developer path (\&quot;/Users/mac/Desktop/Xcode.app/Contents/Developer\&quot;) does not exist\nUsesudo xcode-select --switch path/to/Xcode.appto specify the Xcode that you wish to use for command line developer tools, or usexcode-select --installto install the standalone command line developer tools.</span><br></pre></td></tr></table></figure></div><p>上面的描述，表示Xcode找不到git，为什么找不到？</p><ul><li>1、可能没有安装git</li><li>2、可能关联路径不对</li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol><li>查看是否安装了git，没有安装则安装</li></ol><ul><li>查看是否安装了git</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % git --version           </span><br><span class="line">git version 2.37.1 (Apple Git-137.1)</span><br></pre></td></tr></table></figure></div><p>终端显示的结果是已经安装</p><ul><li>没有安装则安装</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % xcode-select --install</span><br></pre></td></tr></table></figure></div><ol start="2"><li>关联路径不对</li></ol><p>终端执行命令：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Desktop % mac@bogon Blog % sudo xcode-select --switch /Users/mac/Desktop/Xcode.app </span><br></pre></td></tr></table></figure></div><p>如果你不知道Xcode的安装目录，或者不想用命令，可以查找 Xcode -&gt; Preferences -&gt; Locations 并选择 Command Line Tools，查看是否选择了当前Xcode版本</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304301443412.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;当你 &lt;code&gt;cd&lt;/code&gt; 项目根目录，在终端输入 &lt;code&gt;git&lt;/code&gt; 命令时，如果出现如下提示：&lt;</summary>
      
    
    
    
    <category term="Xcode" scheme="https://www.bboyzj.cn/categories/Xcode/"/>
    
    
    <category term="Xcode-常用" scheme="https://www.bboyzj.cn/tags/Xcode-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Xcode学习01：查看Xcode支持iPhone手机系统版本</title>
    <link href="https://www.bboyzj.cn/2023/04/30/Xcode/Xcode%E5%AD%A6%E4%B9%A001%EF%BC%9A%E6%9F%A5%E7%9C%8BXcode%E6%94%AF%E6%8C%81iPhone%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC/"/>
    <id>https://www.bboyzj.cn/2023/04/30/Xcode/Xcode%E5%AD%A6%E4%B9%A001%EF%BC%9A%E6%9F%A5%E7%9C%8BXcode%E6%94%AF%E6%8C%81iPhone%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC/</id>
    <published>2023-04-30T04:24:39.000Z</published>
    <updated>2023-04-30T06:22:02.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍了在 <code>Xcode</code> 不支持 <code>iOS系统版本</code> 时如何通过增加 <code>Xcode系统支持</code> 来解决问题。当出现报错 <code>Failed to prepare the device for development. This operation can fail if the version of the OS on the device is incompatible with the installed version of Xcode. You may also need to restart your Mac and device in order to correctly detect compatibility.</code>  时，首先 <code>尝试重启iOS设备</code>，之后查看Xcode版本是否支持当前手机系统。如果不支持，可以通过进入 <code>iOSDeviceSupport</code> 项目（Gitee或Github）下载需要支持的系统文件，新建一个文件夹，然后将解压好的内容全部粘贴进去，最后再真机运行即可。</p><h1 id="Xcode-版本信息"><a href="#Xcode-版本信息" class="headerlink" title="Xcode 版本信息"></a>Xcode 版本信息</h1><ol><li>由于 <code>Xcode14.2</code> 不支持 <code>iOS16.4</code>，在 <code>Appstore</code> 上可以查看到，如下：</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304301319340.png"                                     ></p><p><strong>结论：上图表示 <code>Xcode14.3</code> 支持 <code>iOS16.4及以下</code>，<code>Xcode14.2</code> 支持到 <code>iOS16.2及以下</code></strong></p><h1 id="查看MacOS系统版本"><a href="#查看MacOS系统版本" class="headerlink" title="查看MacOS系统版本"></a>查看MacOS系统版本</h1><ul><li>点击  图标 -&gt; 关于本机，如下：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304301327813.png"                                     ></p><p>由上图可知，当前我电脑的版本是 macOS Monterey 12.6.5</p><ul><li>由于 <code>Xcode14.3</code> 要求 <code>macOS 13.0或更高版本</code>，如下图</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304301334890.png"                                     ></p><h1 id="如何查看Xcode版本"><a href="#如何查看Xcode版本" class="headerlink" title="如何查看Xcode版本"></a>如何查看Xcode版本</h1><ol><li>第一种方式是直接使用Xcode工具查询</li></ol><p>点击桌面Xcode引用程序：Xcode -&gt; About Xcode</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304301255288.png"                                     ></p><ol start="2"><li>第二种方式通过命令查看</li></ol><p>在终端输入如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % xcodebuild -version </span><br><span class="line">Xcode 14.2</span><br><span class="line">Build version 14C18</span><br></pre></td></tr></table></figure></div><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><strong>重点：本人手欠，早上起来把手机iOS系统升级到了 iOS16.4.1，而我的电脑系统已经升级到最新的了，没办法安装 Xcode14.3</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304301410643.png"                                     ></p><p>当你遇到报错：Failed to prepare the device for development. This operation can fail if the version of the OS on the device is incompatible with the installed version of Xcode. You may also need to restart your Mac and device in order to correctly detect compatibility.</p><ol><li>首先你应该做的是尝试重启你的iOS设备</li><li>重启连不上之后可以查看一下你的Xcode版本是否支持你现在的iPhone手机系统</li></ol><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>在 <code>GitHub</code> 上有一个项目在维护 <code>Xcode支持系统的Device support</code>，我们可以通过 <code>增加Xcode系统支持</code> 解决上面的问题</p><h1 id="增加Xcode系统支持"><a href="#增加Xcode系统支持" class="headerlink" title="增加Xcode系统支持"></a>增加Xcode系统支持</h1><ol><li>进入 <a class="link"   href="https://gitee.com/Han0/iOSDeviceSupport/tree/master/iOSDeviceSupport" >iOSDeviceSupport <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 项目（或者 <a class="link"   href="https://github.com/JinjunHan/iOSDeviceSupport" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 项目），下载你需要支持的系统文件</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304301341010.png"                                     ></p><ol start="2"><li>查看 Xcode 支持设备</li></ol><ul><li>第一种方式：这种方式适用于 <a class="link"   href="https://developer.apple.com/download/more" >Xcode历史版本下载 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul><p>Xcode -&gt; 显示包内容 -&gt; Contents -&gt; Developer -&gt; Platforms -&gt; iPhoneOS.platform -&gt; DeviceSupport </p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304301346085.png"                                     ></p><ul><li>第二种方式：终端输入（这种方式适用于从 <code>App Store下载的Xcode</code>）</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport</span><br></pre></td></tr></table></figure></div><ol start="3"><li>将解压好的内容全部复制到 <code>DeviceSupport</code> 文件下下</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304301421169.png"                                     ></p><ol start="4"><li>关闭Xcode，重新真机运行就 <code>OK</code> 了</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文介绍了在 &lt;code&gt;Xcode&lt;/code&gt; 不支持 &lt;code&gt;iOS系统版本&lt;/code&gt; 时如何通过增加 &lt;code&gt;Xcode</summary>
      
    
    
    
    <category term="Xcode" scheme="https://www.bboyzj.cn/categories/Xcode/"/>
    
    
    <category term="Xcode-常用" scheme="https://www.bboyzj.cn/tags/Xcode-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习20.1：RwSwift介绍</title>
    <link href="https://www.bboyzj.cn/2023/04/26/Swift%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/Swift%E5%AD%A6%E4%B9%A020.1%EF%BC%9ARwSwift%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.bboyzj.cn/2023/04/26/Swift%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/Swift%E5%AD%A6%E4%B9%A020.1%EF%BC%9ARwSwift%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-04-26T05:48:35.000Z</published>
    <updated>2023-04-26T06:00:32.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数式响应式编程-FRP"><a href="#函数式响应式编程-FRP" class="headerlink" title="函数式响应式编程(FRP)"></a>函数式响应式编程(FRP)</h1><ol><li>函数式编程(FP)</li></ol><p>函数式编程是一种抽象的编程，它将 <code>计算机运算</code> 看做是 <code>数学中函数的计算</code>，而纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要是输入确定，输出就是确定的，这种 <code>纯函数</code> 我们称之为 <code>没有副作用</code></p><p>简单来说：<code>将函数作为一个单元来处理逻辑，给定一个输入值，就会有对应的一个输出值</code>。函数还可以作为参数和返回值。这就是 <code>函数式编程</code>。</p><blockquote><p>函数表达式：<br>由 y &#x3D; f(x) ，x &#x3D; f(x)<br>即 y &#x3D; f(f(x))</p></blockquote><p>函数式编程的特性：</p><ul><li>闭包：一种特殊的函数，绑定了函数内部引用的所有变量，把它引用的东西都放在一个上下文中 包 起来</li><li>匿名函数：在传入函数时，有些时候，不需要显示地定义函数，可以直接传入nim</li></ul><ol start="2"><li><p>响应式编程(RP)</p></li><li><p>函数响应式编程(FRP)</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数式响应式编程-FRP&quot;&gt;&lt;a href=&quot;#函数式响应式编程-FRP&quot; class=&quot;headerlink&quot; title=&quot;函数式响应式编程(FRP)&quot;&gt;&lt;/a&gt;函数式响应式编程(FRP)&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;函数式编程(FP)&lt;/li&gt;
&lt;/ol&gt;
&lt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>C语言学习20：算法的复杂度</title>
    <link href="https://www.bboyzj.cn/2023/04/25/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E7%AE%97%E6%B3%9500%EF%BC%9A%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://www.bboyzj.cn/2023/04/25/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E7%AE%97%E6%B3%9500%EF%BC%9A%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2023-04-25T07:44:20.000Z</published>
    <updated>2023-05-08T04:44:34.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法的复杂度"><a href="#算法的复杂度" class="headerlink" title="算法的复杂度"></a>算法的复杂度</h1><p>算法在编译成可执行程序后，运行时需要耗费 <code>时间资源(执行次数)</code> 和 <code>空间资源(内容)</code> 。因此衡量一个算法的好坏，一般是从 <code>时间和空间两个维度来衡量的</code>，即 <code>时间复杂度和空间复杂度</code></p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><ol><li>定义</li></ol><ul><li><p>时间复杂度的定义：在计算机科学中，<code>算法的时间复杂度是一个函数</code>，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例</p></li><li><p><code>算法中的基本操作的执行次数，为算法的时间复杂度。</code> </p></li><li><p>即：找到某条基本语句与问题规模 <code>N</code> 之间的数学表达式，就是算出了该算法的时间复杂度</p></li></ul><ol start="2"><li>举例</li></ol><p>计算一下 <code>func1</code> 中 <code>++count</code> 语句执行了多少次</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void func1(int n)&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    </span><br><span class="line">    // 两层循环</span><br><span class="line">    for (int i = 0;i &lt; n; i ++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j ++) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 单层循环</span><br><span class="line">    for (int k = 0; k &lt; 2 * n; k ++) &#123;</span><br><span class="line">        ++ count;</span><br><span class="line">    &#125;</span><br><span class="line">    // 循环</span><br><span class="line">    int m = 10;</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>结果：<br>func1 的时间复杂度：func1(n) &#x3D; n * n + 2 * n + 10<br>n &#x3D; 10：func1(10) &#x3D; 10 * 10 + 2 * 10 + 10 &#x3D; 130</p></blockquote><p>实际我们计算时间复杂度时，起始并不一定要计算精准的执行次数，只需要计算 <code>大概执行次数</code>，那么这里我们使用大 <code>O</code> 的渐进表示法</p><h1 id="大-O-的渐进表示法"><a href="#大-O-的渐进表示法" class="headerlink" title="大 O 的渐进表示法"></a>大 O 的渐进表示法</h1><ol><li>定义</li></ol><p>大O符号（Big O notation）：是用于 <code>描述函数渐进行为的数学符号</code>。</p><ol start="2"><li>推导大O阶方法：</li></ol><ul><li>用常数1取代运行时间中的所有加法常数</li><li>在修改后的运行次数函数中，只保留最高阶项</li><li>如果最高阶项存在且不是1，则去掉与这个项目相乘的常数。得到的结果就是大O阶</li></ul><ol start="3"><li>另外有些算法的时间复杂度存在最好、平均和最坏情况：</li></ol><ul><li>最坏情况：任意输入规模的最大运行次数(上界)</li><li>平均情况：任意输入规模的期望运行次数</li><li>最好情况：任意输入规模的最小运行次数(下界)</li></ul><p><strong>例如：</strong></p><p>在一个长度为 N 数组中搜索一个数据 x</p><ul><li>最好情况：1 次找到</li><li>最坏情况：N 次找到</li><li>平均情况：N&#x2F;2 次找到</li></ul><p>在实际中一般情况关注的是算法的 <code>最坏</code> 运行情况，所以数组中搜索数据时间复杂度为 <code>O(N)</code>。</p><blockquote><p>注：时间复杂度是不固定的，时间复杂度表示的是 <code>最坏</code> 的情况。</p></blockquote><ol start="4"><li>实例</li></ol><p><strong>Q：计算下面代码的时间复杂度</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void func2(int n, int m) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (int k = 0; k &lt; m; k ++) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int k = 0; k&lt; n; k ++) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,count);</span><br><span class="line">&#125;</span><br><span class="line">=====</span><br><span class="line">20</span><br></pre></td></tr></table></figure></div><blockquote><p>结果：<br>时间复杂度：O(m+n)<br>这里除非说明 m&gt;&gt;n 或 n&gt;&gt;m，远小于的那个字母就可以不表示了</p></blockquote><p><strong>Q：计算下面代码的时间复杂度</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void func3(int n) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (int k = 0; k &lt; 100; k ++) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">====</span><br><span class="line">100</span><br></pre></td></tr></table></figure></div><blockquote><p>结果：<br>时间复杂度：O(1)<br>分析：这里的 <code>1</code> 不是一次，是代表常数次，常数次用 <code>O(1)</code> 表示，写成1亿也是常数</p></blockquote><h1 id="常见时间复杂度计算举例"><a href="#常见时间复杂度计算举例" class="headerlink" title="常见时间复杂度计算举例"></a>常见时间复杂度计算举例</h1><ol><li>冒泡排序</li></ol><ul><li>冒泡排序的思想：相邻两个元素比较，取到最大值放在最后，共进行 <code>n-1</code> 趟</li></ul><p>第一趟：n-1 次<br>第二趟：n-2 次<br>…<br>最后一趟：1 次</p><ul><li>我们发现上面是一个 <code>等差数列</code>，等差数为1，利用等差数列公式求和 <code>(首项 + 末项) * 项数 / 2</code></li></ul><blockquote><p>注：等差数列 即 每一项与它的前一项的差等于同一个常数，这个数列就叫做 等差数列<br>求和公式：&#96;(首项 + 末项) * 项数 &#x2F; 2</p></blockquote><p>利用公式计算：1 + 2 + 3 + … + n-1 &#x3D; (1 + n-1) * (n-1) &#x2F; 2</p><p>最坏的结果（执行次数）： n^2</p><blockquote><p>因此：<code>冒泡排序</code> 的时间复杂度 <code>O(n^2)</code></p></blockquote><ul><li>具体实现</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void swap(int *a, int *b) &#123;</span><br><span class="line">    int tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bubbleSort(int *arr, int n) &#123;</span><br><span class="line">    for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n - i - 1; j ++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                swap(&amp;arr[j], &amp;arr[j + 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 打印</span><br><span class="line">    for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int arr[5] = &#123;5,4,3,2,1&#125;;</span><br><span class="line">    int len = sizeof(arr)/sizeof(arr[0]);</span><br><span class="line">    bubbleSort(arr, len);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ol start="2"><li>阶乘递归</li></ol><ul><li>代码实现</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 求 n! 传入一个无符号整型</span><br><span class="line">int factorial(int n)&#123;</span><br><span class="line">    if (n&lt;=1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return n * factorial(n-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int n = 5;</span><br><span class="line">    printf(&quot;%d 的阶乘是：%d\n&quot;,n,factorial(n));</span><br><span class="line">    //5 的阶乘是：120</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这是一个递归调用，递归了 <code>n</code> 次</p><blockquote><p>结论：因此时间复杂度是 O(n)</p></blockquote><ol start="3"><li>二分查找</li></ol><ul><li>代码实现</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int *arr, int n, int x) &#123;</span><br><span class="line">    int begin = 0;</span><br><span class="line">    int end = n - 1;</span><br><span class="line">    while (begin &lt;= end) &#123;</span><br><span class="line">        int mid = (end - begin) / 2;</span><br><span class="line">        if (arr[mid] &lt; x) &#123;</span><br><span class="line">            begin = mid + 1;</span><br><span class="line">        &#125;else if (arr[mid] &gt; x) &#123;</span><br><span class="line">            end = mid - 1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int arr[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">    int len = sizeof(arr)/sizeof(arr[0]);</span><br><span class="line">    int index = binarySearch(arr, len, 3);</span><br><span class="line">    printf(&quot;%d\n&quot;,index);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">====</span><br><span class="line">2</span><br></pre></td></tr></table></figure></div><blockquote><p>注：<br>logN 的意思是以 <code>2</code> 为底 <code>多少次幂</code> 等于 <code>N</code></p></blockquote><p>分析：二分查找是对数组区间不断的缩小 <code>1/2</code> 找数字</p><pre><code>第1次：N/2第2次：N/2^2...第x次：N/2^x</code></pre><p>假设二分了X次，有 1 * 2 * 2…. * 2 &#x3D; N，2^X&#x3D;N, X&#x3D;(log2) N</p><ul><li>因此，二分查找的时间复杂度 O(logN)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法的复杂度&quot;&gt;&lt;a href=&quot;#算法的复杂度&quot; class=&quot;headerlink&quot; title=&quot;算法的复杂度&quot;&gt;&lt;/a&gt;算法的复杂度&lt;/h1&gt;&lt;p&gt;算法在编译成可执行程序后，运行时需要耗费 &lt;code&gt;时间资源(执行次数)&lt;/code&gt; 和 &lt;code&gt;空</summary>
      
    
    
    
    <category term="算法" scheme="https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结和算法" scheme="https://www.bboyzj.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-进阶01：Swift源码编译</title>
    <link href="https://www.bboyzj.cn/2023/04/24/Swift%E8%BF%9B%E9%98%B6/Swift-%E8%BF%9B%E9%98%B601%EF%BC%9ASwift%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
    <id>https://www.bboyzj.cn/2023/04/24/Swift%E8%BF%9B%E9%98%B6/Swift-%E8%BF%9B%E9%98%B601%EF%BC%9ASwift%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</id>
    <published>2023-04-24T10:37:10.000Z</published>
    <updated>2023-05-05T04:23:36.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h1><ul><li>MacOS Big Sur 11.0.1</li><li>Xcode 12.2 </li><li>Python 2.x</li><li>brew install cmake ninja</li></ul><h1 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h1><ol><li>准备阶段</li></ol><ul><li><p>新建一个文件夹，命名为 <code>swift-source</code></p></li><li><p>由于拉取资源过程中，需要访问外网，所以需要梯子（各位童鞋自行解决）</p></li></ul><ol start="2"><li>第一步：clone swift源码</li></ol><p>这里编译的是 <code>swift-5.3.1-Release</code>。可以自行在官网找到对应的 <a class="link"   href="https://github.com/apple/swift/tags" >分支 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，需要注意的是：swift源码版本需要与Xcode版本匹配（官方编译文档有说明）</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --branch swift-5.3.1-RELEASE https://github.com/apple/swift.git</span><br></pre></td></tr></table></figure></div><ol start="3"><li>第二步：update-checkout</li></ol><p>这步主要是 <code>clone</code> 编译 <code>swift相关的库</code>，否则在编译时一定会失败，这步很关键！（编译过程会很长，建议休息时间编译）</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./swift/utils/build-script -r --debug-swift-stdlib --lldb</span><br></pre></td></tr></table></figure></div><ol start="4"><li>第三步：采用ninja编译</li></ol><p>编译过程可以使用ninja，也可以使用Xcode，但是Xcode编译之后的支持性不是太好，所以这里采用ninja编译</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./swift/utils/build-script -r --debug-swift-stdlib --lldb</span><br></pre></td></tr></table></figure></div><ol start="5"><li>使用VSCode调试Swift</li></ol><ul><li>首先，在VSCode中安装插件</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304241855657.png"                                     ></p><ul><li>添加配置文件 <code>launch.json</code>，并修改</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305051222851.png"                                     ></p><p>需要注意的是 <code>program</code> 的路径需要与你编译的文件路径一致</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">    </span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;lldb&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Debug&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/Ninja-RelWithDebInfoAssert+stdlib-DebugAssert/swift-macosx-x86_64/bin/swift&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>点击Debug运行，断住</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304241856149.png"                                     ></p><p>然后过掉断点</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304241857577.png"                                     ></p><p>看到以下结果就是运行成功了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304241857894.png"                                     ></p><ul><li>然后切换至终端，我们可以开始源码调试啦。</li></ul><p>在终端中输入以下代码（也可以从swift文件拷贝）</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304241858483.png"                                     ></p><p>源码中搜索 <code>swift_allocObject</code>（这个在后面文章会讲解，仅作为调试的例子），加上断点</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304241858639.png"                                     ></p><ul><li>继续在终端输入 <code>var t = CJLTeacher()</code>,回车</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304241900898.png"                                     ></p><p>这样，我们就可以愉快的调试的Swift源码啦，✿✿ヽ(°▽°)ノ✿</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编译环境&quot;&gt;&lt;a href=&quot;#编译环境&quot; class=&quot;headerlink&quot; title=&quot;编译环境&quot;&gt;&lt;/a&gt;编译环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;MacOS Big Sur 11.0.1&lt;/li&gt;
&lt;li&gt;Xcode 12.2 &lt;/li&gt;
&lt;li&gt;Pytho</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-进阶" scheme="https://www.bboyzj.cn/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>OC学习42：layoutSubviews</title>
    <link href="https://www.bboyzj.cn/2023/04/24/OC/OC%E5%AD%A6%E4%B9%A042%EF%BC%9AlayoutSubviews/"/>
    <id>https://www.bboyzj.cn/2023/04/24/OC/OC%E5%AD%A6%E4%B9%A042%EF%BC%9AlayoutSubviews/</id>
    <published>2023-04-24T03:55:48.000Z</published>
    <updated>2023-04-24T04:08:15.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="layoutSubviews-使用"><a href="#layoutSubviews-使用" class="headerlink" title="layoutSubviews 使用"></a>layoutSubviews 使用</h1><ul><li>使用 <code>layoutSubviews</code> ，必须调用它的父类方法：[super layoutSubviews];</li><li><code>layoutSubviews</code> 是 UIView 中的方法，即只要继承与 UIView，就可以使用这个方法</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(void)layoutSubviews&#123;</span><br><span class="line">  [super layoutSubviews];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="layoutSubviews-作用？"><a href="#layoutSubviews-作用？" class="headerlink" title="layoutSubviews 作用？"></a>layoutSubviews 作用？</h1><p><code>layoutSubviews</code> 是对 <code>subviews</code> 的重新布局</p><h1 id="layoutSubviews-什么时候调用？"><a href="#layoutSubviews-什么时候调用？" class="headerlink" title="layoutSubviews 什么时候调用？"></a>layoutSubviews 什么时候调用？</h1><ol><li><p><code>addSubView</code> 添加到某个父 <code>view</code> 上时</p></li><li><p>init初始化不会执行，但是用 <code>initWithFrame</code> 初始化成一个 <code>frame</code> 不为<code>CGRectZero</code> 且 <code>addSubView</code> 时，会 <code>触发两次</code>，不addSubView一次也不会执行</p></li><li><p>设置 <code>frame</code> 会触发 layoutSubviews，前提是 frame的值设置前后有变化</p></li><li><p>view的父试图是 <code>scrollView/tableView</code>，滚动时候会调用 <code>layoutSubviews</code></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;layoutSubviews-使用&quot;&gt;&lt;a href=&quot;#layoutSubviews-使用&quot; class=&quot;headerlink&quot; title=&quot;layoutSubviews 使用&quot;&gt;&lt;/a&gt;layoutSubviews 使用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;使用 &lt;</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习41：UITableView</title>
    <link href="https://www.bboyzj.cn/2023/04/24/OC/OC%E5%AD%A6%E4%B9%A041%EF%BC%9AUITableView/"/>
    <id>https://www.bboyzj.cn/2023/04/24/OC/OC%E5%AD%A6%E4%B9%A041%EF%BC%9AUITableView/</id>
    <published>2023-04-24T03:23:21.000Z</published>
    <updated>2023-04-24T03:52:09.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h1><p>如果在调用 <code>reloadData</code> 方法后，需要立即获取 <code>tableView 的cell、高度、需要滚动tableView</code>，那么，直接在 <code>reloadData</code> 后获取是可能有问题的</p><p><strong>原因分析：</strong></p><ul><li><p><code>reloadData</code> 并不会等待 <code>tableView</code> 更新结束后才返回，而是 <code>立即返回</code>，之后再计算高度、获取cell（主线程）</p></li><li><p>如果表中的数据非常大，在一个 <code>runloop</code> 周期没有执行完，这时，获取 <code>tableView</code> 的数据就会出现问题</p></li><li><p><code>Apple</code> 并没有直接提供 <code>reloadData</code> 的 <code>API</code>，想要程序延迟到 <code>tableView</code> 更新结束，可以用下面的方法</p></li></ul><p><strong>解决方法：</strong></p><ul><li>方法一</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self.tableView reloadData];</span><br><span class="line">[self.tableView layoutIfNeeded];</span><br><span class="line">// 刷新完成</span><br></pre></td></tr></table></figure></div><blockquote><p><code>layoutIfNeeded</code> 会强制绘制并等待完成</p></blockquote><ul><li>方法二</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[self.tableView reloadData];</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;  </span><br><span class="line">    // 刷新完成  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure></div><blockquote><p><code>reloadData</code> 会在主队列执行，而 <code>dispatch_get_main_queue</code> 会等待机会，直到主队列空闲才执行</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题1&quot;&gt;&lt;a href=&quot;#问题1&quot; class=&quot;headerlink&quot; title=&quot;问题1&quot;&gt;&lt;/a&gt;问题1&lt;/h1&gt;&lt;p&gt;如果在调用 &lt;code&gt;reloadData&lt;/code&gt; 方法后，需要立即获取 &lt;code&gt;tableView 的cell、高度、</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习40：sizeToFit和sizeThatFit</title>
    <link href="https://www.bboyzj.cn/2023/04/23/OC/OC%E5%AD%A6%E4%B9%A040%EF%BC%9AsizeToFit%E5%92%8CsizeThatFit/"/>
    <id>https://www.bboyzj.cn/2023/04/23/OC/OC%E5%AD%A6%E4%B9%A040%EF%BC%9AsizeToFit%E5%92%8CsizeThatFit/</id>
    <published>2023-04-23T06:29:21.000Z</published>
    <updated>2023-04-23T06:30:45.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过官方文档查看两个方法的区别：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (CGSize)sizeThatFits:(CGSize)size;   </span><br><span class="line"></span><br><span class="line">return &#x27;best&#x27; size to fit given size. does not actually resize view. Default is return existing view size</span><br><span class="line"></span><br><span class="line">- (void)sizeToFit;     </span><br><span class="line"></span><br><span class="line">calls sizeThatFits: with current view bounds and changes bounds size.</span><br></pre></td></tr></table></figure></div><ul><li><p>sizeThatFits: 会计算出最优的 <code>size</code> 但是 <code>不会改变原来的size</code></p></li><li><p>sizeToFit: 会计算出最优的 <code>size</code> 而且会 <code>改变原来的size</code></p></li></ul><h1 id="不换行情况下"><a href="#不换行情况下" class="headerlink" title="不换行情况下"></a>不换行情况下</h1><p>下面通过代码来验证一下，不换行情况下的区别：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -不换行</span><br><span class="line">- (void)NoWarp&#123;</span><br><span class="line">    UILabel * titleL = [[UILabel alloc] initWithFrame:CGRectMake(10, 100, 100, 18)];</span><br><span class="line">    titleL.text = @&quot;我是谁？我是张建，欢迎来到我的世界！&quot;;</span><br><span class="line">    titleL.textColor = [UIColor redColor];</span><br><span class="line">    titleL.backgroundColor = [UIColor yellowColor];</span><br><span class="line">    [self.view addSubview:titleL];</span><br><span class="line">    </span><br><span class="line">    // sizeThatFits: 会计算出最优的 size 但是不会改变 自己的 size</span><br><span class="line">    CGSize size = [titleL sizeThatFits:CGSizeMake(150, MAXFLOAT)];</span><br><span class="line">    NSLog(@&quot;w:%f h:%f&quot;,size.width,size.height);</span><br><span class="line">    </span><br><span class="line">    // sizeToFit: 会计算出最优的 size 而且会改变自己的 size</span><br><span class="line">    [titleL sizeToFit];</span><br><span class="line">    NSLog(@&quot;w:%f h:%f&quot;,titleL.frame.size.width,titleL.frame.size.height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>查看代码的结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-10-09 16:34:44.011176+0800 sizeToFit和sizeThatFit[506:157387] w:308.000000 h:20.500000</span><br><span class="line">2021-10-09 16:34:44.011280+0800 sizeToFit和sizeThatFit[506:157387] w:308.000000 h:20.500000</span><br></pre></td></tr></table></figure></div><p>显示的效果：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304231430886.png"                                     ></p><h1 id="换行的情况下"><a href="#换行的情况下" class="headerlink" title="换行的情况下"></a>换行的情况下</h1><p>下面用代码来验证一下，换行的情况下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -换行</span><br><span class="line">- (void)warp&#123;</span><br><span class="line">    UILabel * titleL = [[UILabel alloc] initWithFrame:CGRectMake(10, 200, 300, 18)];</span><br><span class="line">    titleL.text = @&quot;我是谁？我是张建，欢迎来到我的世界！,我是谁？我是张建，欢迎来到我的世界！,我是谁？我是张建，欢迎来到我的世界！,我是谁？我是张建，欢迎来到我的世界！,我是谁？我是张建，欢迎来到我的世界！&quot;;</span><br><span class="line">    titleL.textColor = [UIColor redColor];</span><br><span class="line">    titleL.backgroundColor = [UIColor yellowColor];</span><br><span class="line">    titleL.numberOfLines = 0;</span><br><span class="line">    [self.view addSubview:titleL];</span><br><span class="line">    </span><br><span class="line">    // sizeThatFits: 会计算出最优的 size 但是不会改变 自己的 size</span><br><span class="line">    CGSize size = [titleL sizeThatFits:CGSizeMake(300, MAXFLOAT)];</span><br><span class="line">    NSLog(@&quot;w:%f h:%f&quot;,size.width,size.height);</span><br><span class="line">    </span><br><span class="line">    // sizeToFit: 会计算出最优的 size 而且会改变自己的 size</span><br><span class="line">    [titleL sizeToFit];</span><br><span class="line">    NSLog(@&quot;w:%f h:%f&quot;,titleL.frame.size.width,titleL.frame.size.height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>查看代码运行结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-10-09 16:39:54.036423+0800 sizeToFit和sizeThatFit[7271:250369] w:299.333333 h:122.000000</span><br><span class="line">2021-10-09 16:39:54.036707+0800 sizeToFit和sizeThatFit[7271:250369] w:299.333333 h:122.000000</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通过官方文档查看两个方法的区别：&lt;/p&gt;
&lt;div class=&quot;highlight-container&quot; data-rel=&quot;Plaint</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习22.1：Socket实现</title>
    <link href="https://www.bboyzj.cn/2023/04/22/OC/OC%E5%AD%A6%E4%B9%A022.1%EF%BC%9ASocket%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.bboyzj.cn/2023/04/22/OC/OC%E5%AD%A6%E4%B9%A022.1%EF%BC%9ASocket%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-04-22T12:20:45.000Z</published>
    <updated>2023-04-22T14:07:43.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要介绍使用 <code>GCDAsyncSocket</code> 实现iOS端 <code>Socket</code></p><h1 id="什么是Socket？"><a href="#什么是Socket？" class="headerlink" title="什么是Socket？"></a>什么是Socket？</h1><p>Socket 俗称 <code>套接字</code>，是网络通信的基石。它可以通过 <code>IP地址、端口号、TCP/UDP协议</code> 实现客户端和服务端的双向通信。</p><h1 id="长链接-和-短链接"><a href="#长链接-和-短链接" class="headerlink" title="长链接 和 短链接"></a>长链接 和 短链接</h1><ul><li><p>长链接：连上就一直聊，通常用于 <code>及时通讯</code>，效率高。（一对一：）</p></li><li><p>短链接：通讯一次，马上断开，下次再建立连接，效率低。（一对多）</p></li></ul><p>及时通讯：客户端和服务端是 <code>短链接</code>，客户端与客户端是 <code>长链接</code></p><h1 id="Socket如何保持长链接"><a href="#Socket如何保持长链接" class="headerlink" title="Socket如何保持长链接"></a>Socket如何保持长链接</h1><p>一般的Socket正常收发完消息之后，就会断开连接（主动或被动），但是有些实时化场景要求高的地方，需要及时收发消息，比如 <code>直播间、股票期货行情模块</code> 等，要实时收发数据，这样的话就需要Socket保持连接一直在。</p><p>方法：发送 <code>心跳包</code> 来保活</p><ol><li>应用层自己实现 <code>心跳包</code></li></ol><ul><li><p>服务器在 <code>NSTimer</code> 中定时想客户端发送一个小数据包，如果客户端一定时间内没有回应，即认为客户端已掉线。</p></li><li><p>同理：客户端在 <code>NSTimer</code> 中定时向 <code>服务端</code> 发送一个小数据包，在一定时间内没有收到服务器的心跳包，则认为连接不可用。</p></li></ul><ol start="2"><li>TCP 的 KeepAlive 保活机制</li></ol><p>考虑到一个服务器通常会连接多个客户端，因此由用户在应用层自己实现心跳包，<code>代码较多且稍显复杂</code>，而利用 <code>TCP／IP协议层</code> 为内置的 <code>KeepAlive</code> 功能来实现心跳功能则简单得多。 不论是服务端还是客户端，一方开启 <code>KeepAlive</code> 功能后，就会自动在规定时间内向对方发送心跳包， 而另一方在收到心跳包后就会自动回复，以告诉对方我仍然在线。</p><h1 id="iOS端实现-Socket"><a href="#iOS端实现-Socket" class="headerlink" title="iOS端实现 Socket"></a>iOS端实现 Socket</h1><p>用 <code>GCDAsyncSocket</code> 框架</p><ol><li>创建GCDAsyncSocket对象，并且使之成为成员属性</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GCDAsyncSocket *_socket;</span><br></pre></td></tr></table></figure></div><ol start="2"><li>我们在这里传入一个全局队列，让它工作在子线程，防止网络不畅时阻塞主线程。</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_socket = [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)];</span><br></pre></td></tr></table></figure></div><ol start="3"><li>连接服务端</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// IP地址</span><br><span class="line">NSString *host = @&quot;127.0.0.1&quot;;</span><br><span class="line">// 端口号</span><br><span class="line">int port = 12345;</span><br><span class="line">NSError *error = nil;</span><br><span class="line">[_socket connectToHost:host onPort:port error:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="4"><li>实现代理方法来获取数据</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 连接成功的代理</span><br><span class="line">-(void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(uint16_t)port&#123;</span><br><span class="line">    NSLog(@&quot;成功连接到%@:%d&quot;,host,port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 连接结束的代理</span><br><span class="line">- (void)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(NSError *)err&#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>接收数据的代理</li></ul><p>这里的 <code>tag</code> 是用于 <code>区分不同的消息</code> 的，在写一条消息的时候需要指定tag，通过不同的tag判断服务器返回的消息的类型。这里有两类消息，分别是 <code>登录消息和聊天消息</code>，只有后者会被显示，<code>reloadDataWithText</code> 是用于 <code>tableView</code> 显示数据的方法。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 数据成功发送到服务器</span><br><span class="line">- (void)socket:(GCDAsyncSocket *)sock didWriteDataWithTag:(long)tag&#123;</span><br><span class="line">    // 需要自己调用读取方法，socket才会调用代理方法读取数据</span><br><span class="line">    [_socket readDataWithTimeout:-1 tag:tag];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag&#123;</span><br><span class="line"> </span><br><span class="line">    switch (tag) &#123;</span><br><span class="line">        case LoginTag:</span><br><span class="line">            break;</span><br><span class="line">        case MsgTag:&#123;</span><br><span class="line">            NSString *msg = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</span><br><span class="line">            [self reloadDataWithText:msg];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="5"><li>发送一条消息</li></ol><ul><li>使用socket的 <code>writeData</code> 方法，这里不需要指定消息的长度和缓冲区大小，十分方便，tag会被传入，在调用上面提到的代理方法 <code>(void)socket:(GCDAsyncSocket *)sock didWriteDataWithTag:(long)tag</code> 时会被传入，用于判断消息类型。</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 发送 iam:name 表示name登录</span><br><span class="line">NSString *loginStr = @&quot;iam:soulghost&quot;;</span><br><span class="line">// 把string转成NSData</span><br><span class="line">NSData *data = [loginStr dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">[_socket writeData:data withTimeout:-1 tag:LoginTag];</span><br></pre></td></tr></table></figure></div><ul><li>需要注意的是异步socket工作在子线程，如果要更新UI，必然会在socket的代理方法中调用更新UI的方法，这时更新UI的代码运行于子线程，不能立即刷新UI界面，因此应该把更新UI的函数放在主线程中执行：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    // 更新UI的代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文主要介绍使用 &lt;code&gt;GCDAsyncSocket&lt;/code&gt; 实现iOS端 &lt;code&gt;Socket&lt;/code&gt;&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习00：面向过程&amp;面向对象&amp;面向协议&amp;面向函数编程</title>
    <link href="https://www.bboyzj.cn/2023/04/21/Swift/Swift%E5%AD%A6%E4%B9%A000%EF%BC%9A%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE-%E9%9D%A2%E5%90%91%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.bboyzj.cn/2023/04/21/Swift/Swift%E5%AD%A6%E4%B9%A000%EF%BC%9A%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE-%E9%9D%A2%E5%90%91%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/</id>
    <published>2023-04-21T03:53:07.000Z</published>
    <updated>2023-04-21T03:54:15.597Z</updated>
    
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Swift31：AutoLayout</title>
    <link href="https://www.bboyzj.cn/2023/04/19/Swift/Swift%E5%AD%A6%E4%B9%A031%EF%BC%9AAutoLayout/"/>
    <id>https://www.bboyzj.cn/2023/04/19/Swift/Swift%E5%AD%A6%E4%B9%A031%EF%BC%9AAutoLayout/</id>
    <published>2023-04-19T08:12:59.000Z</published>
    <updated>2023-04-19T08:35:02.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Apple提供的API有两套：</p><ul><li><p>一套是iOS9之前用的使用 <code>NSLayoutConstraint</code>，Apple可能是因为发现了使用NSLayoutConstraint代码过长的问题</p></li><li><p>在iOS9推出了 <code>NSLayoutAnchor</code>，不仅让约束声明更加清晰明了，而且还通过静态类型检查以确保约束能够正常工作。</p></li></ul><h1 id="关闭autoresizing布局方式"><a href="#关闭autoresizing布局方式" class="headerlink" title="关闭autoresizing布局方式"></a>关闭autoresizing布局方式</h1><ul><li><p><code>AutoLayout</code> 又名 <code>自动布局</code>。使用 <code>AutoLayout</code> 可以轻易写出目前主流的所有页面布局.</p></li><li><p>在 <code>iOS</code> 中默认使用 <code>autoresizing</code> 布局方式，做了相对父控件大小的伸缩，使用不方便。</p></li><li><p>关闭 <code>aotoresizing</code> 布局，translatesAutoresizingMaskIntoConstraints &#x3D; false，可以开启 <code>自动布局</code></p></li></ul><h1 id="NSLayoutConstraint"><a href="#NSLayoutConstraint" class="headerlink" title="NSLayoutConstraint"></a>NSLayoutConstraint</h1><p>只需要创建一个NSLayoutConstraint，然后激活，添加到对应的view即可。不过，是每一个约束都要创建，所以代码较长。创建一个NSLayoutConstraint只需要一个方法，为了方便，我们对每一个参数进行注释：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSLayoutConstraint.init(item: Any, //要约束的目标(比如 redView)</span><br><span class="line"></span><br><span class="line">attribute: NSLayoutAttribute, //要约束的属性（比如top）</span><br><span class="line"></span><br><span class="line">relatedBy: NSLayoutRelation, //约束类型（比如equal）</span><br><span class="line"></span><br><span class="line">toItem: Any?,//相对于哪个目标（比如superView）</span><br><span class="line"></span><br><span class="line">attribute: NSLayoutAttribute, //相对于这个目标的属性（比如bottom）</span><br><span class="line"></span><br><span class="line">multiplier: CGFloat, //倍数（比如一半为0.5）</span><br><span class="line"></span><br><span class="line">constant: CGFloat)//常数（差值，比如-10）</span><br></pre></td></tr></table></figure></div><p>举例添加一个view到界面上，距上距左各20，宽200，高100.</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个红色的view添加到界面上</span><br><span class="line">let redView = UIView()</span><br><span class="line">redView.backgroundColor = .red</span><br><span class="line">redView.translatesAutoresizingMaskIntoConstraints = false</span><br><span class="line">view.addSubview(redView)</span><br><span class="line">        </span><br><span class="line">// 添加距离顶部20</span><br><span class="line">let topConstraint = NSLayoutConstraint.init(item: redView, attribute: .top, relatedBy: .equal, toItem: view, attribute: .top, multiplier: 1.0, constant: 20)</span><br><span class="line">topConstraint.isActive = true</span><br><span class="line">        </span><br><span class="line">// 添加距离左边20</span><br><span class="line">let leftConstraint = NSLayoutConstraint.init(item: redView, attribute: .left, relatedBy: .equal, toItem: view, attribute: .left, multiplier: 1.0, constant: 20)</span><br><span class="line">leftConstraint.isActive = true</span><br><span class="line">        </span><br><span class="line">// 添加宽为200</span><br><span class="line">let widthConstraint = NSLayoutConstraint.init(item: redView, attribute: .width, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, multiplier: 1.0, constant: 200)</span><br><span class="line">widthConstraint.isActive = true</span><br><span class="line">        </span><br><span class="line">// 添加高为100</span><br><span class="line">let heightConstraint = NSLayoutConstraint.init(item: redView, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, multiplier: 1.0, constant: 100)</span><br><span class="line">heightConstraint.isActive = true</span><br></pre></td></tr></table></figure></div><h1 id="NSLayoutAnchor"><a href="#NSLayoutAnchor" class="headerlink" title="NSLayoutAnchor"></a>NSLayoutAnchor</h1><p>iOS9.0之后，Apple推出了 <code>NSLayoutAnchor</code>。</p><p>使用方式有两种：</p><ol><li>第一种方式</li></ol><ul><li>创建 <code>UIImageView</code> 视图，闭包初始化</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let imgV: UIImageView = &#123;</span><br><span class="line">    let imgV = UIImageView(image: UIImage(named: &quot;logo_icon&quot;))</span><br><span class="line">    imgV.backgroundColor = .blue</span><br><span class="line">    imgV.translatesAutoresizingMaskIntoConstraints = false</span><br><span class="line">    imgV.contentMode = .scaleAspectFill</span><br><span class="line">    return imgV</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></div><ul><li>添加到 ViewController 中</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.addSubview(imgV)</span><br></pre></td></tr></table></figure></div><ul><li>添加一个约束</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 第一种写法：激活，数组</span><br><span class="line">NSLayoutConstraint.activate([</span><br><span class="line">    imgV.topAnchor.constraint(equalTo: view.topAnchor, constant: 200),</span><br><span class="line">    imgV.centerXAnchor.constraint(equalTo: view.centerXAnchor),</span><br><span class="line">    imgV.widthAnchor.constraint(equalToConstant: 100),</span><br><span class="line">    imgV.heightAnchor.constraint(equalToConstant: 100),</span><br><span class="line">])</span><br></pre></td></tr></table></figure></div><ol start="2"><li>第二种方式</li></ol><ul><li>在 <code>imgV</code> 下方创建一个 <code>文本</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let lab: UILabel = &#123;</span><br><span class="line">    let lab = UILabel()</span><br><span class="line">    lab.translatesAutoresizingMaskIntoConstraints = false</span><br><span class="line">    lab.backgroundColor = .red</span><br><span class="line">    lab.text = &quot;加入我们，游戏和乐趣&quot;</span><br><span class="line">    lab.textColor = .green</span><br><span class="line">    lab.font = .systemFont(ofSize: 20, weight: .bold)</span><br><span class="line">    lab.textAlignment = .center</span><br><span class="line">    return lab</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></div><ul><li>添加 lab 到 ViewController 上</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.addSubview(lab)</span><br></pre></td></tr></table></figure></div><ul><li>添加约束</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 另一种写法：需要激活</span><br><span class="line">lab.topAnchor.constraint(equalTo: imgV.bottomAnchor, constant: 50).isActive = true</span><br><span class="line">lab.leftAnchor.constraint(equalTo: view.leftAnchor).isActive = true</span><br><span class="line">lab.rightAnchor.constraint(equalTo: view.rightAnchor).isActive = true</span><br><span class="line">lab.heightAnchor.constraint(equalToConstant: 50).isActive = true</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Apple提供的API有两套：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一套是iOS9之前用的使用 &lt;code&gt;NSLayoutConstraint</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发工作梳理</title>
    <link href="https://www.bboyzj.cn/2023/04/16/iOS%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%A2%B3%E7%90%86/"/>
    <id>https://www.bboyzj.cn/2023/04/16/iOS%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%A2%B3%E7%90%86/</id>
    <published>2023-04-16T03:01:54.000Z</published>
    <updated>2023-04-17T05:57:38.204Z</updated>
    
    <content type="html"><![CDATA[<p>2013年毕业，在葫芦岛市绥四建工下其中一个项目部，从事了2年的工程，前一年跟着师傅学习，后一年自己独立负责项目技术施工；每天6点起床，每天要起早，中午休息一个小时，晚上不一定几点下班，真的是起早贪黑的工作，最关键的是不挣钱；从中学习了很多工程施工方面的经验，也考了二级建造师。最遗憾的是二级建造师的证书没去取。最后由于感情方面的事情，毅然决然的离开了葫芦岛。</p><p>自从2015年中旬来到北京，主要是通过朋友了解了iOS开发这行目前特别火，还挣钱；然后我也去千峰培训了6个月，这6个月是我最难熬的6个月，像是回到了上学期间，每天起早贪黑的学习技术；毕业后的第一份工作是凭借着忽悠进去的，工资翻了好几倍。回头想想值了。</p><p>2016年进入第一家公司，老板姓王，我记忆尤新，是个北大的毕业生创业的公司。然后一直就从事iOS开发到现在。干了7年多了。总结一下自己的工作，从入行到现在，我进步的点是从迷迷糊糊的跨行到能独立搭建框架和开发，是我多年积累的经验。不足是从入行到现在没有明确的目标，没有规划自己的未来房展方向。导致我错过了很多机会。也没有把自己的能力提升上去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2013年毕业，在葫芦岛市绥四建工下其中一个项目部，从事了2年的工程，前一年跟着师傅学习，后一年自己独立负责项目技术施工；每天6点起床，每天要起早，中午休息一个小时，晚上不一定几点下班，真的是起早贪黑的工作，最关键的是不挣钱；从中学习了很多工程施工方面的经验，也考了二级建造</summary>
      
    
    
    
    <category term="工作梳理" scheme="https://www.bboyzj.cn/categories/%E5%B7%A5%E4%BD%9C%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="工作-总结" scheme="https://www.bboyzj.cn/tags/%E5%B7%A5%E4%BD%9C-%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>OC学习36.2：CoreData</title>
    <link href="https://www.bboyzj.cn/2023/04/16/OC/OC%E5%AD%A6%E4%B9%A036.3%EF%BC%9ACoreData/"/>
    <id>https://www.bboyzj.cn/2023/04/16/OC/OC%E5%AD%A6%E4%B9%A036.3%EF%BC%9ACoreData/</id>
    <published>2023-04-15T16:52:43.000Z</published>
    <updated>2023-04-15T16:56:14.887Z</updated>
    
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
