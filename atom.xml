<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张建的博客</title>
  <icon>https://www.gravatar.com/avatar/134cc2bfaf649e446f661778f4112fca</icon>
  <subtitle>成功的道路上只有荆棘，没有坦途</subtitle>
  <link href="https://www.bboyzj.cn/atom.xml" rel="self"/>
  
  <link href="https://www.bboyzj.cn/"/>
  <updated>2023-03-28T12:24:59.588Z</updated>
  <id>https://www.bboyzj.cn/</id>
  
  <author>
    <name>小J</name>
    <email>13718004742@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift学习27：MZRefresh</title>
    <link href="https://www.bboyzj.cn/2023/03/28/Swift/Swift%E5%AD%A6%E4%B9%A027%EF%BC%9AMZRefresh/"/>
    <id>https://www.bboyzj.cn/2023/03/28/Swift/Swift%E5%AD%A6%E4%B9%A027%EF%BC%9AMZRefresh/</id>
    <published>2023-03-28T05:38:45.000Z</published>
    <updated>2023-03-28T12:24:59.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Swift</code> 下拉刷新、上拉加载组件，简单易用，适用于 <code>UIScrollView、UITableView、UICollectionView</code> 等继承自 <code>UIScrollView</code> 的组件</p><h1 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h1><p>使用 Cocoapods 引入</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#x27;MZRefresh&#x27;</span><br></pre></td></tr></table></figure></div><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>这里以 UITableView 为例</p><ul><li>添加刷新组件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 添加下拉刷新组件</span><br><span class="line">self.tableV.setRefreshHeader(MZRefreshNormalHeader(beginRefresh: &#123;</span><br><span class="line">    // 请求数据，请求到数据后记得停止刷新动画</span><br><span class="line">    self.loadData()</span><br><span class="line">&#125;))</span><br><span class="line">    </span><br><span class="line">// 添加上拉加载组件</span><br><span class="line">self.tableV.setRefreshFooter(MZRefreshNormalFooter(beginRefresh: &#123;</span><br><span class="line">    // 请求数据，请求到数据后记得停止刷新动画</span><br><span class="line">    self.loadMore()</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">// 加载数据</span><br><span class="line">func loadData() &#123;</span><br><span class="line">    print(&quot;下拉刷新&quot;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">func loadMore() &#123;</span><br><span class="line">    print(&quot;上拉加载&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>手动下拉刷新或加载更多</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 手动触发下拉刷新</span><br><span class="line">self.tableV.startHeaderRefreshing(animated: true)</span><br><span class="line">// 手动触发上拉加载</span><br><span class="line">self.tableV.startFooterRefreshing(animated: true)</span><br></pre></td></tr></table></figure></div><ul><li>停止下拉刷新或加载更多</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 停止下拉刷新动画</span><br><span class="line">self.tableV.stopHeaderRefreshing()</span><br><span class="line">// 停止上拉加载动画</span><br><span class="line">self.tableV.stopFooterRefreshing()</span><br></pre></td></tr></table></figure></div><h1 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h1><ul><li>通过 <code>MZRefreshConfig</code> 类管理部分组件属性</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 管理部分组件属性</span><br><span class="line">// 刷新状态文字颜色</span><br><span class="line">MZRefreshConfig.shareInstance.setRefreshStatusColor(.blue)</span><br><span class="line">// 刷新状态文字大小</span><br><span class="line">MZRefreshConfig.shareInstance.setRefreshStatusFont(.systemFont(ofSize: 18))</span><br><span class="line">// 刷新时间文字颜色</span><br><span class="line">MZRefreshConfig.shareInstance.setRefreshTimeColor(.green)</span><br><span class="line">// 刷新时间文字大小</span><br><span class="line">MZRefreshConfig.shareInstance.setRefreshTimeFont(.systemFont(ofSize: 12))</span><br></pre></td></tr></table></figure></div><h1 id="MZRefreshNormalHeader-amp-MZRefreshNormalFooter"><a href="#MZRefreshNormalHeader-amp-MZRefreshNormalFooter" class="headerlink" title="MZRefreshNormalHeader &amp; MZRefreshNormalFooter"></a>MZRefreshNormalHeader &amp; MZRefreshNormalFooter</h1><ul><li>下拉刷新组件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> type 刷新动画类型</span><br><span class="line"> color 刷新动画颜色</span><br><span class="line"> showTime 是否显示上次刷新时间</span><br><span class="line"> beginRefresh 刷新回调</span><br><span class="line"> */</span><br><span class="line">MZRefreshNormalHeader(type: .lineSpinFadeLoader, color: .brown, showTime: true) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>上拉加载组件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> type 刷新动画类型</span><br><span class="line"> color 刷新动画颜色</span><br><span class="line"> beginRefresh 刷新回调</span><br><span class="line"> */</span><br><span class="line">MZRefreshNormalFooter(type: .lineScalePulseOut, color: .brown, beginRefresh: &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>刷新动画类型</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303282007690.png"                                     ></p><h1 id="MZRefreshGifHeader-amp-MZRefreshGifFooter"><a href="#MZRefreshGifHeader-amp-MZRefreshGifFooter" class="headerlink" title="MZRefreshGifHeader &amp; MZRefreshGifFooter"></a>MZRefreshGifHeader &amp; MZRefreshGifFooter</h1><ul><li>下拉刷新组件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 下拉刷新组件</span><br><span class="line"> images               gif分解图片数组</span><br><span class="line"> size                 gif图片显示大小</span><br><span class="line"> animationDuration    是否显示上次下拉刷新时间</span><br><span class="line"> showTime             gif动画时间</span><br><span class="line"> beginRefresh         刷新回调</span><br><span class="line"> */</span><br><span class="line">MZRefreshGifHeader(images: animationImages, size: 60, animationDuration: 1.0, showTime: true, beginRefresh: &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">images               gif图片Data</span><br><span class="line">size                 gif图片显示大小</span><br><span class="line">animationDuration    是否显示上次下拉刷新时间</span><br><span class="line">showTime             gif动画时间</span><br><span class="line">beginRefresh         刷新回调</span><br><span class="line">*/</span><br><span class="line">MZRefreshGifHeader(gifImage: data, size: 40, animationDuration: 1.0, showTime: true, beginRefresh: &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><ul><li>上拉加载组件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 上拉加载组件</span><br><span class="line"> images               gif分解图片数组</span><br><span class="line"> size                 gif图片显示大小</span><br><span class="line"> animationDuration    是否显示上次下拉刷新时间</span><br><span class="line"> beginRefresh         刷新回调</span><br><span class="line"> */</span><br><span class="line">MZRefreshGifFooter(images: animationImages, size: 60, animationDuration: 1.0, beginRefresh: &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 上拉加载组件</span><br><span class="line"> gifImage             gif图片Data</span><br><span class="line"> size                 gif图片显示大小</span><br><span class="line"> animationDuration    是否显示上次下拉刷新时间</span><br><span class="line"> beginRefresh         刷新回调</span><br><span class="line"> */</span><br><span class="line">MZRefreshGifFooter(gifImage: data, size: 40, animationDuration: 0.0, beginRefresh: &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><ul><li>gif图片Data获取方式</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let path = Bundle.main.path(forResource: &quot;1&quot;, ofType: &quot;gif&quot;)!</span><br><span class="line">let data = try! Data(contentsOf: URL(fileURLWithPath: path))</span><br></pre></td></tr></table></figure></div><h1 id="MZRefreshOnlyGifHeader"><a href="#MZRefreshOnlyGifHeader" class="headerlink" title="MZRefreshOnlyGifHeader"></a>MZRefreshOnlyGifHeader</h1><ul><li>下拉刷新组件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 下拉刷新组件</span><br><span class="line"> images               gif分解图片数组</span><br><span class="line"> size                 gif图片显示大小</span><br><span class="line"> refreshOffSet        开始刷新所需的偏移量</span><br><span class="line"> animationDuration    gif动画时间</span><br><span class="line"> readyImage           释放刷新图片</span><br><span class="line"> beginRefresh         刷新回调</span><br><span class="line"> */</span><br><span class="line">MZRefreshOnlyGifHeader(images: animationImages, size: 80, refreshOffSet: 80, animationDuration: 1.0, readyImage: nil, beginRefresh: &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 下拉刷新组件</span><br><span class="line"> gifImage             gif图片Data</span><br><span class="line"> size                 gif图片显示大小</span><br><span class="line"> refreshOffSet        开始刷新所需的偏移量</span><br><span class="line"> animationDuration    gif动画时间</span><br><span class="line"> readyImage           释放刷新图片</span><br><span class="line"> beginRefresh         刷新回调</span><br><span class="line"> */</span><br><span class="line">MZRefreshOnlyGifHeader(gifImage: data, size: 80, refreshOffSet: 80, animationDuration: 1.0, readyImage: nil, beginRefresh: &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><h1 id="stopRefreshingWithNoMoreData"><a href="#stopRefreshingWithNoMoreData" class="headerlink" title="stopRefreshingWithNoMoreData"></a>stopRefreshingWithNoMoreData</h1><ul><li>设置 <code>NoMoreData</code> 组件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let footer = UILabel(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: 40))</span><br><span class="line">footer.font = .systemFont(ofSize: 14)</span><br><span class="line">footer.textAlignment = .center</span><br><span class="line">footer.textColor = .black</span><br><span class="line">footer.text = &quot;—— 生活的强者，往往都能坚持到底 ——&quot;</span><br><span class="line">footer.textColor = .brown</span><br><span class="line">self.tableV.setRefreshNoMoreDataView(footer)</span><br></pre></td></tr></table></figure></div><ul><li>没有更多数据加载，取消上拉加载功能</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 停止下拉刷新动画，并显示没有更多数据</span><br><span class="line">self.tableV.stopHeaderRefreshingWithNoMoreData()</span><br><span class="line"></span><br><span class="line">// 停止上拉加载动画，并显示没有更多数据</span><br><span class="line">self.tableV.stopFooterRefreshingWithNoMoreData()</span><br></pre></td></tr></table></figure></div><h1 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h1><ul><li>下拉刷新</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过 MZRefreshHeaderComponent 协议实现下拉刷新组件自定义，可参考MZRefreshNormalHeader、MZRefreshOnlyGifHeader等组件实现</span><br></pre></td></tr></table></figure></div><ul><li>上拉加载</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过 MZRefreshFooterComponent 协议实现下拉刷新组件自定义，可参考MZRefreshNormalFooter、MZRefreshGifFooter等组件实现</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Swift&lt;/code&gt; 下拉刷新、上拉加载组件，简单易用，适用于 &lt;code&gt;UIScrollView、UITableView</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习26：UITableView</title>
    <link href="https://www.bboyzj.cn/2023/03/28/Swift/Swift%E5%AD%A6%E4%B9%A026%EF%BC%9AUITableView/"/>
    <id>https://www.bboyzj.cn/2023/03/28/Swift/Swift%E5%AD%A6%E4%B9%A026%EF%BC%9AUITableView/</id>
    <published>2023-03-28T00:34:36.000Z</published>
    <updated>2023-03-28T05:30:36.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p><code>UITableView</code> 是我们开发中最常见的列表，<code>UITableView</code> 继承自 </p></li><li><p><code>UIScrollView``UIScrollView</code> 可以在任意方向滑动，<code>UITableView</code> 只能在垂直方向滑动</p></li><li><p><code>UITableView</code> 的内容由 <code>UITableViewCell</code> 来显示的</p></li><li><p><code>UITableViewCell</code> 可以使用系统自带样式，也可以自定义</p></li></ul><h1 id="创建-UITableView"><a href="#创建-UITableView" class="headerlink" title="创建 UITableView"></a>创建 <code>UITableView</code></h1><ul><li>我们在实际开发中通常是用 <code>延迟加载</code> 的方式来创建，如下：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 懒加载：延迟加载 - 第一次使用的时候才加载</span><br><span class="line">lazy var tableV: UITableView = &#123;</span><br><span class="line">    let tableV = UITableView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: UIScreen.main.bounds.size.height), style: .plain)</span><br><span class="line">    tableV.backgroundColor = UIColor.red</span><br><span class="line">    return tableV</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></div><blockquote><p>注：<br>style 有两种样式：<code>plain</code> 和 <code>group</code><br>区别：<br>plain：<br>1、plain类型有多个header时，header停留（自带效果）<br>2、plain类型section之间没有间距<br>group：<br>1、类型有多个header时，header不停留<br>2、plain类型section之间有间距</p></blockquote><ul><li>将其添加到指定页面上：例如 <code>VC</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 添加tableV到vc的view上</span><br><span class="line">self.view.addSubview(self.tableV)</span><br></pre></td></tr></table></figure></div><h1 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h1><ul><li>可以设置代理</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 懒加载：延迟加载 - 第一次使用的时候才加载</span><br><span class="line">lazy var tableV: UITableView = &#123;</span><br><span class="line">    let tableV = UITableView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width, height: UIScreen.main.bounds.size.height), style: .plain)</span><br><span class="line">    tableV.backgroundColor = UIColor.red</span><br><span class="line">    // 设置代理</span><br><span class="line">    tableV.delegate = self</span><br><span class="line">    tableV.dataSource = self</span><br><span class="line">    return tableV</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></div><ul><li>遵守代理</li></ul><p>可以通过 <code>extension</code> 去遵守代理</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extension ViewController: UITableViewDataSource,UITableViewDelegate &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>实现代理回调方法，丰富页面</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">extension ViewController: UITableViewDataSource,UITableViewDelegate &#123;</span><br><span class="line">    // 组的个数</span><br><span class="line">    func numberOfSections(in tableView: UITableView) -&gt; Int &#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line">    // 每组的row数</span><br><span class="line">    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">        return 10</span><br><span class="line">    &#125;</span><br><span class="line">    // 每个row的cell</span><br><span class="line">    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line">        // 系统的cell</span><br><span class="line">        let cellId = &quot;testCellId&quot;</span><br><span class="line">        var cell = tableV.dequeueReusableCell(withIdentifier: cellId)</span><br><span class="line">        if cell == nil &#123;</span><br><span class="line">            cell = UITableViewCell(style: .default, reuseIdentifier: cellId)</span><br><span class="line">        &#125;</span><br><span class="line">        cell?.textLabel?.text = &quot;标题&quot;</span><br><span class="line">        cell?.detailTextLabel?.text = &quot;内容&quot;</span><br><span class="line">        cell?.imageView?.image = UIImage(named: &quot;test&quot;)</span><br><span class="line">        </span><br><span class="line">        return cell!</span><br><span class="line">    &#125;</span><br><span class="line">    // cell的高度</span><br><span class="line">    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;</span><br><span class="line">        return 70</span><br><span class="line">    &#125;</span><br><span class="line">    // 选中cell执行的方法</span><br><span class="line">    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123;</span><br><span class="line">        print(indexPath.row)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><blockquote><p>注：系统样式的cell有三种样式：default,value1,value2,subtitle</p></blockquote><ul><li>default</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16799658025019.jpg"                                     ></p><ul><li>value1</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16799657416469.jpg"                                     ></p><ul><li>value2</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16799656595223.jpg"                                     ></p><ul><li>subtitle</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16799659584081.jpg"                                     ></p><h1 id="自定义cell"><a href="#自定义cell" class="headerlink" title="自定义cell"></a>自定义cell</h1><ul><li>创建一个 BaseTableViewCell 基类</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class BaseTableViewCell: UITableViewCell &#123;</span><br><span class="line">    // 基础</span><br><span class="line">    class func BaseTableViewCell(tableView:UITableView,indexPath:NSIndexPath) -&gt; UITableViewCell&#123;</span><br><span class="line">        let ID = NSStringFromClass(self);</span><br><span class="line">        let cls = NSClassFromString(ID) as! UITableViewCell.Type;</span><br><span class="line">        let cell = tableView.dequeueReusableCell(withIdentifier: ID) ?? cls.init(style: .default, reuseIdentifier: ID)</span><br><span class="line">        return cell</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">     子类默认不继承父类的初始化器，实际上是通过 重写 父类的初始化器实现的，用 override 关键字</span><br><span class="line">     子类调用父类的初始化区，用 super</span><br><span class="line">     */</span><br><span class="line">    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) &#123;</span><br><span class="line">        super.init(style: style, reuseIdentifier: reuseIdentifier)</span><br><span class="line">        self.prepareUI()</span><br><span class="line">    &#125;</span><br><span class="line">    // UI</span><br><span class="line">    func prepareUI() &#123;</span><br><span class="line">        self.contentView.backgroundColor = kColorRandom();</span><br><span class="line">    &#125;</span><br><span class="line">    // 必要初始化器：可失败</span><br><span class="line">    required init?(coder: NSCoder) &#123;</span><br><span class="line">        fatalError(&quot;init(coder:) has not been implemented&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 反初始化器</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;deinit&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>创建自定义cell</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class CustomTableViewCell: BaseTableViewCell &#123;</span><br><span class="line">    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) &#123;</span><br><span class="line">        super.init(style: style, reuseIdentifier: reuseIdentifier)</span><br><span class="line">        self.prepareUI()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    override func prepareUI() &#123;</span><br><span class="line">        super.prepareUI();</span><br><span class="line">        self.contentView.backgroundColor = .white;</span><br><span class="line">        </span><br><span class="line">        initUI();</span><br><span class="line">        initConstraint();</span><br><span class="line">    &#125;</span><br><span class="line">    func initUI() &#123;</span><br><span class="line">        self.contentView.addSubview(bgV);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    func initConstraint() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    required init?(coder: NSCoder) &#123;</span><br><span class="line">        fatalError(&quot;init(coder:) has not been implemented&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>修改代理回调方法给cell赋值</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let cell = CustomTableViewCell.BaseTableViewCell(tableView: tableView, indexPath: indexPath as NSIndexPath)</span><br><span class="line">        </span><br><span class="line">return cell</span><br></pre></td></tr></table></figure></div><h1 id="cell-的插入和删除"><a href="#cell-的插入和删除" class="headerlink" title="cell 的插入和删除"></a>cell 的插入和删除</h1><ul><li>插入和删除涉及到三个代理方法 和 编辑模式的方法</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// editing: 是否开启编辑状态 animated: 是否有动画效果</span><br><span class="line">setEditing(_ editing:, animated:)</span><br></pre></td></tr></table></figure></div><ul><li>删除的实现</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 编辑模式：insert 添加操作、delete删除操作、none 没有任何操作</span><br><span class="line">func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -&gt; UITableViewCell.EditingStyle &#123;</span><br><span class="line">    return .delete</span><br><span class="line">&#125;</span><br><span class="line">// 执行编辑操作：调用此方法</span><br><span class="line">func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) &#123;</span><br><span class="line">    if editingStyle == .insert &#123;</span><br><span class="line">        // 添加</span><br><span class="line">        dataArr.insert(&quot;\(indexPath.row)&quot;, at: indexPath.row)</span><br><span class="line">        // 添加操作</span><br><span class="line">        tableView.insertRows(at: [indexPath], with: .right)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        // 删除</span><br><span class="line">        dataArr.remove(at: indexPath.row)</span><br><span class="line">        // 删除</span><br><span class="line">        print(dataArr)</span><br><span class="line">        tableView.deleteRows(at: [indexPath], with: .left)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 修改删除的文字</span><br><span class="line">func tableView(_ tableView: UITableView, titleForDeleteConfirmationButtonForRowAt indexPath: IndexPath) -&gt; String? &#123;</span><br><span class="line">    return &quot;删除&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="cell位置移动"><a href="#cell位置移动" class="headerlink" title="cell位置移动"></a>cell位置移动</h1><ul><li>移动功能同样需要开启编辑模式</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// editing: 是否开启编辑状态 animated: 是否有动画效果</span><br><span class="line">setEditing(_ editing:, animated:)</span><br></pre></td></tr></table></figure></div><ul><li>简单实现</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 设置cell是否可移动</span><br><span class="line">func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -&gt; Bool &#123;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line">// 移动结束后调用此方法</span><br><span class="line">func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) &#123;</span><br><span class="line">    let data = dataArr[sourceIndexPath.row]</span><br><span class="line">    dataArr.remove(at: sourceIndexPath.row)</span><br><span class="line">    dataArr.insert(data, at: destinationIndexPath.row)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;UITableView&lt;/code&gt; 是我们开发中最常见的列表，&lt;code&gt;UITableView&lt;/code</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习25：通知Notification</title>
    <link href="https://www.bboyzj.cn/2023/03/27/Swift/Swift%E5%AD%A6%E4%B9%A025%EF%BC%9A%E9%80%9A%E7%9F%A5Notification/"/>
    <id>https://www.bboyzj.cn/2023/03/27/Swift/Swift%E5%AD%A6%E4%B9%A025%EF%BC%9A%E9%80%9A%E7%9F%A5Notification/</id>
    <published>2023-03-27T03:43:29.000Z</published>
    <updated>2023-03-27T04:03:42.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>通知</code> 通常用于不相邻两个页面之间的 <code>传值</code></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol><li>初始化通知Notification</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 发送通知</span><br><span class="line">// 发送简单的数据</span><br><span class="line">// NotificationCenter.default.post(name: NSNotification.Name(rawValue:&quot;SimpleNotification&quot;), object: &quot;hello&quot;)</span><br><span class="line">// 发送复杂的数据</span><br><span class="line">let userInfo = [&quot;name&quot;:&quot;ZJ&quot;,&quot;age&quot;:32] as [String:Any]</span><br><span class="line">NotificationCenter.default.post(name: NSNotification.Name(rawValue:&quot;ComplexNotification&quot;), object: nil,userInfo: userInfo)</span><br></pre></td></tr></table></figure></div><ol start="2"><li>接收通知</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 接收通知</span><br><span class="line">NotificationCenter.default.addObserver(self, selector: #selector(handleNotification(noti:)), name: NSNotification.Name(rawValue:&quot;ComplexNotification&quot;), object: nil)</span><br></pre></td></tr></table></figure></div><ol start="3"><li>接收到通知执行的操作</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 接收到通知</span><br><span class="line">@objc func handleNotification(noti:NSNotification)  &#123;</span><br><span class="line">    print(noti.userInfo as Any)</span><br><span class="line">    print(noti.userInfo![&quot;name&quot;] as! String)</span><br><span class="line">    print(noti.userInfo![&quot;age&quot;] as! Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">Optional([AnyHashable(&quot;name&quot;): &quot;ZJ&quot;, AnyHashable(&quot;age&quot;): 32])</span><br><span class="line">ZJ</span><br><span class="line">32</span><br></pre></td></tr></table></figure></div><ol start="4"><li>移除通知</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line">    NotificationCenter.default.removeObserver(self)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;通知&lt;/code&gt; 通常用于不相邻两个页面之间的 &lt;code&gt;传值&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;使用&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习24：反初始化器deinit</title>
    <link href="https://www.bboyzj.cn/2023/03/26/Swift/Swift%E5%AD%A6%E4%B9%A024%EF%BC%9A%E5%8F%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8deinit/"/>
    <id>https://www.bboyzj.cn/2023/03/26/Swift/Swift%E5%AD%A6%E4%B9%A024%EF%BC%9A%E5%8F%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8deinit/</id>
    <published>2023-03-26T10:42:37.000Z</published>
    <updated>2023-03-26T11:30:56.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>Swift 的析构过程，在类的实例被释放前，析构函数被立即调用，析构函数只使用于类的类型。</p></li><li><p><code>析构器</code> 用 <code>deinit</code> 关键字来表示，也叫反初始化器，不带任何参数</p></li><li><p><code>构造器</code> 用 <code>init</code> 关键字来表示，也叫 <code>初始化器</code>，可以带参数</p></li></ul><h1 id="deinit-析构过程"><a href="#deinit-析构过程" class="headerlink" title="deinit 析构过程"></a>deinit 析构过程</h1><ul><li><p><code>Swift</code> 是通过 <code>自动引用计数(ARC)</code> 处理实例的内存管理，自动释放不再需要的实例以释放资源</p></li><li><p><code>析构器在实例释放发生前自动调用，你不能主动调用析构器</code></p></li><li><p>通常当实例被释放时不需要手动去清理。但是，当使用自己的资源时，可能需要进行一些额外的清理</p></li></ul><p>例如：自定义的类打开一个文件并写入一些数据，可能需要在类实例被释放之前关闭该文件</p><h1 id="deinit-语法"><a href="#deinit-语法" class="headerlink" title="deinit 语法"></a>deinit 语法</h1><p>在类的定义中，<code>每个类最多只能有一个析构函数，析构函数不带有任何参数</code>，在语法上不带圆括号</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line">    // 执行析构过程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>描述了一个简单的游戏，这里定义了两种新类型，分别是 <code>Bank</code> 和 <code>Player</code>。</p><p><code>Bank</code> 类管理一种虚拟硬币，确保流通的硬币数量永远不可能超过 <code>10,000</code>。在游戏中有且只能有一个 <code>Bank</code> 存在，因此 <code>Bank</code> 用类来实现，并使用类型属性和类型方法来存储和管理其当前状态。(比单例的设计要好，单例的内存不会被释放)</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Bank &#123;</span><br><span class="line">    // 类型属性：硬币数量</span><br><span class="line">    static var coinsInBank = 10_000;</span><br><span class="line">    </span><br><span class="line">    // 类型方法：分发硬币之前检查是否有足够的硬币</span><br><span class="line">    static func distribute(coins numberOfCoinsRequest: Int) -&gt; Int &#123;</span><br><span class="line">        // 可分发的硬币数量</span><br><span class="line">        let numberOfCoinToVend = min(numberOfCoinsRequest, coinsInBank);</span><br><span class="line">        // 银行剩余硬币数量</span><br><span class="line">        coinsInBank -= numberOfCoinToVend;</span><br><span class="line">        // 返回银行可分发的硬币数量</span><br><span class="line">        return numberOfCoinToVend;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 类型属性：将 Bank 实例接收到的硬币数目加回硬币存储中</span><br><span class="line">    static func receive(coins: Int) &#123;</span><br><span class="line">        coinsInBank += coins;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><code>Player</code> 类描述了游戏中的一个玩家。每一个玩家在任意时间都有一定数量的硬币存储在他们的钱包中。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Player &#123;</span><br><span class="line">    // 玩家的钱包</span><br><span class="line">    var coinsInPurse: Int</span><br><span class="line">    </span><br><span class="line">    // 初始化从 Bank 对象获取指定数量的硬币</span><br><span class="line">    init(coins: Int) &#123;</span><br><span class="line">        coinsInPurse = Bank.distribute(coins: coins)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 从 Bank 对象 赢取 一定数量的硬币，把它们添加到玩家的钱包</span><br><span class="line">    func win(coins: Int) &#123;</span><br><span class="line">        coinsInPurse += Bank.distribute(coins: coins)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 析构器被自动调用</span><br><span class="line">    deinit &#123;</span><br><span class="line">        // 查询 Player 的硬币</span><br><span class="line">        print(&quot;Bank回收之前，Player的硬币数量：\(coinsInPurse)&quot;)</span><br><span class="line">        // 查询 Bank 的硬币</span><br><span class="line">        print(&quot;Bank回收之前，Bank的硬币数量：\(Bank.coinsInBank)&quot;)</span><br><span class="line">        </span><br><span class="line">        // 玩家钱包中的硬币返回给银行</span><br><span class="line">        Bank.receive(coins: coinsInPurse)</span><br><span class="line">        coinsInPurse = 0;</span><br><span class="line">        </span><br><span class="line">        // 查询 Player 的硬币</span><br><span class="line">        print(&quot;Bank回收之后，Player的硬币数量：\(coinsInPurse)&quot;)</span><br><span class="line">        // 查询 Bank 的硬币</span><br><span class="line">        print(&quot;Bank回收之后，Bank的硬币数量：\(Bank.coinsInBank)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>假设玩家从银行初次获取 3000 硬币，后又赢取 1000 硬币</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        // 实例化 Player 从 Bank 获取 3000 硬币</span><br><span class="line">        let player = Player(coins: 3000)</span><br><span class="line">        // Player 从 Bank 赢取 100 硬币</span><br><span class="line">        player.win(coins: 1000)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当玩家的硬币由于某些原因被回收后，查看打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bank回收之前，Player的硬币数量：4000</span><br><span class="line">Bank回收之前，Bank的硬币数量：6000</span><br><span class="line">Bank回收之后，Player的硬币数量：0</span><br><span class="line">Bank回收之后，Bank的硬币数量：10000</span><br></pre></td></tr></table></figure></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>析构过程调用的方法是 <code>deinit &#123;&#125;</code>。类似 <code>OC</code> 的 <code>dealloc</code></p></li><li><p><code>deinit</code> 通过 <code>ARC</code> 自动处理，不需要手动操作，也会自动调用父类的 <code>deinit</code></p></li><li><p><code>deinit</code> 里处理对象将要被释放时的一些操作</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Swift 的析构过程，在类的实例被释放前，析构函数被立即调用，析构函数只使用于类的类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>性能优化02.3：Ping主线程</title>
    <link href="https://www.bboyzj.cn/2023/03/23/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602.3%EF%BC%9APing%E4%B8%BB%E7%BA%BF%E7%A8%8B/"/>
    <id>https://www.bboyzj.cn/2023/03/23/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602.3%EF%BC%9APing%E4%B8%BB%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-03-23T02:07:43.000Z</published>
    <updated>2023-03-23T02:08:58.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>Ping主线程的核心思想是向主线程发送一个信号，一定时间内收到了主线程的回复，即表示当前主线程流畅运行。没有收到主线程的回复，即表示当前主线程在做耗时运算，发生了卡顿。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>目前昆虫线上使用的就是这套方案。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">self.semaphore = dispatch_semaphore_create(0);</span><br><span class="line">- (void)main &#123; </span><br><span class="line">   //判断是否需要上报  </span><br><span class="line">  __weak typeof(self) weakSelf = self; </span><br><span class="line">   void (^ verifyReport)(void) = ^() &#123;   </span><br><span class="line">     __strong typeof(weakSelf) strongSelf = weakSelf;    </span><br><span class="line">    if (strongSelf.reportInfo.length &gt; 0) &#123;     </span><br><span class="line">       if (strongSelf.handler) &#123;     </span><br><span class="line">           double responseTimeValue = floor([[NSDate date] timeIntervalSince1970] * 1000); </span><br><span class="line">               double duration = responseTimeValue - strongSelf.startTimeValue;     </span><br><span class="line">           if (DEBUG) &#123;      </span><br><span class="line">              NSLog(@&quot;卡了%f,堆栈为--%@&quot;, duration, strongSelf.reportInfo);    </span><br><span class="line">            &#125;          </span><br><span class="line">      strongSelf.handler(@&#123;    </span><br><span class="line">                @&quot;title&quot;: [InsectUtil dateFormatNow].length &gt; 0 ? [InsectUtil dateFormatNow] : @&quot;&quot;,                    @&quot;duration&quot;: [NSString stringWithFormat:@&quot;%.2f&quot;,duration],                    @&quot;content&quot;: strongSelf.reportInfo       </span><br><span class="line">                            &#125;);   </span><br><span class="line">         &#125;          </span><br><span class="line">  strongSelf.reportInfo = @&quot;&quot;;     </span><br><span class="line">   &#125;   </span><br><span class="line"> &#125;;        while (!self.cancelled) &#123;    </span><br><span class="line">    if (_isApplicationInActive) &#123;       </span><br><span class="line">     self.mainThreadBlock = YES;       </span><br><span class="line">     self.reportInfo = @&quot;&quot;;        </span><br><span class="line">    self.startTimeValue = floor([[NSDate date] timeIntervalSince1970] * 1000);    </span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;          </span><br><span class="line">      self.mainThreadBlock = NO;      </span><br><span class="line">          dispatch_semaphore_signal(self.semaphore);    </span><br><span class="line">        &#125;);        </span><br><span class="line">    [NSThread sleepForTimeInterval:(self.threshold/1000)];    </span><br><span class="line">        if (self.isMainThreadBlock) &#123;         </span><br><span class="line">       self.reportInfo = [InsectBacktraceLogger insect_backtraceOfMainThread];     </span><br><span class="line">       &#125;         </span><br><span class="line">   dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);     </span><br><span class="line">       //卡顿超时情况;          </span><br><span class="line">  verifyReport();   </span><br><span class="line">     &#125; else &#123;    </span><br><span class="line">        [NSThread sleepForTimeInterval:(self.threshold/1000)];     </span><br><span class="line">   &#125;  </span><br><span class="line">  &#125;&#125; </span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;Ping主线程的核心思想是向主线程发送一个信号，一定时间内收到了主线程的回复，即表示当前主线程流畅运行。没有收到主线程的回复，即表示当前主线</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>性能优化02.2：Runloop监测</title>
    <link href="https://www.bboyzj.cn/2023/03/23/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602.2%EF%BC%9ARunloop%E7%9B%91%E6%B5%8B/"/>
    <id>https://www.bboyzj.cn/2023/03/23/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602.2%EF%BC%9ARunloop%E7%9B%91%E6%B5%8B/</id>
    <published>2023-03-23T00:07:53.000Z</published>
    <updated>2023-03-25T19:04:26.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RunLoop-原理"><a href="#RunLoop-原理" class="headerlink" title="RunLoop 原理"></a>RunLoop 原理</h1><ol><li><code>RunLoop</code> 在 <code>iOS</code> 里由 <code>CFRunLoop</code> 实现。简单来说，<code>RunLoop</code> 是用来监听输入源，进行调度处理的。</li></ol><ul><li><p>这里的输入源可以是输入设备、网络、周期性或者延迟时间、异步回调。</p></li><li><p><code>RunLoop</code> 会接收两种类型的输入源：一种是来自另一个线程或者来自不同应用的异步消息；另一种是来自预订时间或者重复间隔的同步事件。</p></li><li><p><code>RunLoop</code> 的目的是，当有事件要去处理时保持线程忙，当没有事件要处理时让线程进入休眠。所以，<code>RunLoop</code> 不光能够运用到监控卡顿上，还可以提高用户的交互体验。通过将那些繁重而不紧急会大量占用 <code>CPU</code> 的任务（比如图片加载），放到空闲的 <code>RunLoop</code> 模式里执行，就可以避开在 <code>UITrackingRunLoopMode</code> 这个 <code>RunLoop</code> 模式时执行</p></li></ul><ol start="2"><li>RunLoop 执行流程</li></ol><ul><li>在RunLoop运行的整个过程中，<code>loop</code> 的状态包括 <code>6</code> 个:</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry , // 进入 loop</span><br><span class="line">    kCFRunLoopBeforeTimers , // 触发 Timer 回调</span><br><span class="line">    kCFRunLoopBeforeSources , // 触发 Source0 回调</span><br><span class="line">    kCFRunLoopBeforeWaiting , // 等待 mach_port 消息</span><br><span class="line">    kCFRunLoopAfterWaiting ), // 接收 mach_port 消息</span><br><span class="line">    kCFRunLoopExit , // 退出 loop</span><br><span class="line">    kCFRunLoopAllActivities  // loop 所有状态改变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Runloop 流程图：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303230822991.png"                                     ></p><blockquote><p>注：<br>1、<code>Source0</code> 被添加到 <code>RunLoop</code> 上时并不会主动唤醒线程，需要手动去唤醒。<code>Source0</code> 负责对触摸事件的处理以及 <code>performSeletor:onThread:</code>。<br>2、<code>Source1</code> 具备唤醒线程的能力，使用的是基于 <code>Port</code> 的 <code>线程间通信</code>。<code>Source1</code> 负责捕获系统事件，并将事件交由 <code>Source0</code> 处理。</p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RunLoop 顺序：</span><br><span class="line">     1、进入</span><br><span class="line">     </span><br><span class="line">     2、通知Timer</span><br><span class="line">     3、通知Source</span><br><span class="line">     4、处理Block</span><br><span class="line">     5、处理Source0</span><br><span class="line">     6、如果有 Source1 调转到 11</span><br><span class="line">     7、通知 BeforWaiting</span><br><span class="line">     8、休眠 wait：等待线程被唤醒</span><br><span class="line">     9、通知 afterWaiting</span><br><span class="line">     10、处理唤醒线程消息： timer、GCD相关、处理Source1</span><br><span class="line">     11、处理 dispatch 到 main_queue 的 block</span><br><span class="line">     12、根据情况，决定如何操作：回到 2、退出Runloop</span><br><span class="line">     </span><br><span class="line">     13、退出 Runloop</span><br></pre></td></tr></table></figure></div><ul><li><p>理清楚Runloop的运行机制，就很容易明白处理事件主要有两个时间段 <code>kCFRunLoopBeforeSources</code> 发送之后和 <code>kCFRunLoopAfterWaiting</code> 发送之后。</p></li><li><p><code>dispatch_semaphore_t</code> 是一个信号量机制，信号量到达、或者超时会继续向下进行，否则等待，如果超时则返回的结果必定不为0，信号量到达结果为0。</p></li><li><p>利用这个特性我们判断卡顿出现的条件为 <code>在信号量发送</code> <code>kCFRunLoopBeforeSources</code> 和<code>kCFRunLoopAfterWaiting</code> 后进行了大量的操作，在一段时间内没有再发送信号量，导致超时。也就是说主线程通知状态长时间的停留在这两个状态上了。转换为代码就是判断有没有超时，超时了，判断当前停留的状态是不是这两个状态，如果是，就判定为 <code>卡顿</code>。</p></li></ul><ol start="3"><li><p>这样就能解释通为什么要用这两个信号量判断卡顿。这么一个简单的问题，思路转不过来就绕进去了，现在回看感觉这个很简单，也是耗了一天时间。</p></li><li><p>要利用 <code>RunLoop</code> 原理来监控卡顿的话，要关注两个阶段。分别是 <code>kCFRunLoopBeforeSources</code> 和 <code>kCFRunLoopAfterWaiting</code> ，就是要触发 <code>Source0</code> 回调和接收 <code>mach_port</code> 消息两个状态。</p></li></ol><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><ol><li>创建一个 ZJRunloopMonitor 类</li></ol><p>.h 文件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface ZJRunloopMonitor : NSObject</span><br><span class="line">// 单例</span><br><span class="line">+ (instancetype)shareInstance;</span><br><span class="line">// 开始监测</span><br><span class="line">- (void)startMonitor;</span><br><span class="line">// 停止监测</span><br><span class="line">- (void)stopMonitor;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p>.m 文件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJRunloopMonitor.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ZJRunloopMonitor ()&#123;</span><br><span class="line">    // 信号量</span><br><span class="line">    dispatch_semaphore_t dispatchSemaphore;</span><br><span class="line">    CFRunLoopObserverRef runLoopObserver;</span><br><span class="line">    CFRunLoopActivity runLoopActivity;</span><br><span class="line">    NSInteger timeoutCount;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJRunloopMonitor</span><br><span class="line">// 单例</span><br><span class="line">+ (instancetype)shareInstance&#123;</span><br><span class="line">    static ZJRunloopMonitor * instance = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        instance = [[ZJRunloopMonitor alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -开始监测</span><br><span class="line">- (void)startMonitor&#123;</span><br><span class="line">    // 如果有监测，则返回</span><br><span class="line">    if (runLoopObserver) &#123;return;&#125;</span><br><span class="line">    </span><br><span class="line">    // 创建 CFRunLoopObserverContext 观察者</span><br><span class="line">    /**</span><br><span class="line">         typedef struct &#123;</span><br><span class="line">         CFIndex    version;</span><br><span class="line">         void * info;</span><br><span class="line">         const void *(*retain)(const void *info);</span><br><span class="line">         void   (*release)(const void *info);</span><br><span class="line">         CFStringRef    (*copyDescription)(const void *info);</span><br><span class="line">         &#125; CFRunLoopObserverContext;</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL,NULL&#125;;</span><br><span class="line">    /**</span><br><span class="line">        CFRunLoopObserverRef CFRunLoopObserverCreate(</span><br><span class="line">        CFAllocatorRef allocator,</span><br><span class="line">        CFOptionFlags activities,</span><br><span class="line">        Boolean repeats,</span><br><span class="line">        CFIndex order,</span><br><span class="line">        CFRunLoopObserverCallBack callout,</span><br><span class="line">        CFRunLoopObserverContext *context</span><br><span class="line">        );</span><br><span class="line">        */</span><br><span class="line">    runLoopObserver = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">                                              kCFRunLoopAllActivities,</span><br><span class="line">                                              YES,</span><br><span class="line">                                              0,</span><br><span class="line">                                              &amp;runLoopObserverCallBack,</span><br><span class="line">                                              &amp;context);</span><br><span class="line">    // 添加观察者</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">    // 向主线程添加 观察者</span><br><span class="line">    CFRunLoopRef mainLoop = CFRunLoopGetMain();</span><br><span class="line">    CFRunLoopAddObserver(mainLoop, runLoopObserver, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">    // 创建子线程开始监控</span><br><span class="line">    dispatch_queue_t monitorQueue = dispatch_queue_create(&quot;com.zj.monitorQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">        </span><br><span class="line">    // 创建同步信号量</span><br><span class="line">    dispatchSemaphore = dispatch_semaphore_create(0);</span><br><span class="line">    </span><br><span class="line">    //创建子线程开始监控</span><br><span class="line">    dispatch_async(monitorQueue, ^&#123;</span><br><span class="line">        // 子线程开启一个持续的loop用来进行监控</span><br><span class="line">        while (YES) &#123;</span><br><span class="line">            // 超时时间设置 2s</span><br><span class="line">            dispatch_time_t outTimer = dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC);</span><br><span class="line">            </span><br><span class="line">            // 信号量到达、或者 超时会继续向下进行，否则等待</span><br><span class="line">            long result = dispatch_semaphore_wait(self-&gt;dispatchSemaphore, outTimer);</span><br><span class="line">            </span><br><span class="line">            if (result != 0) &#123;</span><br><span class="line">                // 超时，判断最后停留的信号量是哪一个，是否处理为卡顿现象。</span><br><span class="line">                if (!self-&gt;runLoopObserver) &#123;</span><br><span class="line">                    NSLog(@&quot;--NO runLoopObserver---&quot;);</span><br><span class="line">                    self-&gt;timeoutCount = 0;</span><br><span class="line">                    self-&gt;dispatchSemaphore = 0;</span><br><span class="line">                    self-&gt;runLoopActivity = 0;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                //判断当前 监听到的 信号(也就是说上一个信号量超过2秒没有更新，故卡顿)</span><br><span class="line">                if (self-&gt;runLoopActivity == kCFRunLoopBeforeSources ||</span><br><span class="line">                    self-&gt;runLoopActivity == kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                    // 出现卡顿、进一步处理</span><br><span class="line">                    NSLog(@&quot;--卡顿啦----From 卡顿监控线程&quot;);</span><br><span class="line">                    // log current stack info</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            NSLog(@&quot;--系统运行良好--From 卡顿监控线程&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 停止监测</span><br><span class="line">- (void)stopMonitor&#123;</span><br><span class="line">    if (!runLoopObserver) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    CFRunLoopRemoveObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes);</span><br><span class="line">    CFRelease(runLoopObserver);</span><br><span class="line">    runLoopObserver = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -监控是否处于 运行状态</span><br><span class="line">// 观察者回调函数</span><br><span class="line">void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123;</span><br><span class="line">    // 每一次监测到Runloop发送通知的时候，都会调用此函数</span><br><span class="line">    // 在此过程修改当前的 RunloopActivity 状态，发送同步信号。</span><br><span class="line">    ZJRunloopMonitor * monitor = (__bridge ZJRunloopMonitor *)info;</span><br><span class="line">    monitor-&gt;runLoopActivity = activity;</span><br><span class="line">    dispatch_semaphore_t semaphore = monitor-&gt;dispatchSemaphore;</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ol start="2"><li>观察RunLoop 的 <code>common</code> 模式</li></ol><ul><li><p>将创建好的观察者 <code>runLoopObserver</code> 添加到主线程 <code>RunLoop</code> 的 <code>common</code> 模式下观察。<br>然后，创建一个持续的子线程专门用来监控主线程的 <code>RunLoop</code> 状态。</p></li><li><p>一旦发现进入睡眠前的 <code>kCFRunLoopBeforeSources</code> 状态，或者唤醒后的状态 <code>kCFRunLoopAfterWaiting</code>，在设置的时间阈值内一直没有变化，即可判定为 <code>卡顿</code>。</p></li><li><p>代码中触发卡顿的时间阈值 ,设置成了 <code>2</code> 秒。这个 <code>2</code> 秒的阈值合理？我们可以根据 <code>WatchDog</code> 机制来设置。<code>WatchDog</code> 在不同状态下设置的不同时间，如下所示：</p></li></ul><blockquote><p>启动（Launch）：20s；<br>恢复（Resume）：10s；<br>挂起（Suspend）：10s；<br>退出（Quit）：6s；<br>后台（Background）：3min（在 iOS 7 之前，每次申请 10min； 之后改为每次申请 3min，可连续申请，最多申请到 10min）。</p></blockquote><ul><li>接下来，我们就可以 <code>log</code> 出堆栈的信息，从而进一步分析出具体是哪个方法的执行时间过长。</li></ul><h1 id="如何获取卡顿的方法堆栈信息"><a href="#如何获取卡顿的方法堆栈信息" class="headerlink" title="如何获取卡顿的方法堆栈信息"></a>如何获取卡顿的方法堆栈信息</h1><ul><li><p>子线程监控发现卡顿后，还需要记录当前出现卡顿的方法堆栈信息，并适时推送到服务端供开发者分析，从而解决卡顿问题。</p></li><li><p>直接调用系统函数获取堆栈</p></li><li><p>这种方法的优点在于，性能消耗小。但是，它只能够获取简单的信息，也没有办法配合 <code>dSYM</code> 来获取具体是哪行代码出了问题，而且能够获取的信息类型也有限。</p></li><li><p>但因为性能比较好，所以适用于观察大盘统计卡顿情况，而不是想要找到卡顿原因的场景。</p></li></ul><ol><li>直接获取堆栈信息</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;libkern/OSAtomic.h&gt;</span><br><span class="line">#include &lt;execinfo.h&gt;</span><br><span class="line"></span><br><span class="line">//获取函数堆栈信息</span><br><span class="line">+ (NSArray *)backtrace &#123;</span><br><span class="line">    void* callstack[128];</span><br><span class="line">    int frames = backtrace(callstack, 128);//用于获取当前线程的函数调用堆栈，返回实际获取的指针个数</span><br><span class="line">    char **strs = backtrace_symbols(callstack, frames);//从backtrace函数获取的信息转化为一个字符串数组</span><br><span class="line">    int i;</span><br><span class="line">    NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames];</span><br><span class="line">    for (i = 0;</span><br><span class="line">     i &lt; backtrace.count;</span><br><span class="line">     i++)  &#123;</span><br><span class="line">        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    free(strs);</span><br><span class="line">    return backtrace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="2"><li>三方库</li></ol><p>直接用 <a href="">PLCrashReporter</a> 这个开源的第三方库来获取堆栈信息。这种方法的特点是，能够定位到问题代码的具体位置，而且性能消耗也不大。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取数据</span><br><span class="line">NSData *lagData = [[[PLCrashReporter alloc] initWithConfiguration:[[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll]] generateLiveReport];</span><br><span class="line">// 转换成 PLCrashReport 对象</span><br><span class="line">PLCrashReport *lagReport = [[PLCrashReport alloc] initWithData:lagData error:NULL];</span><br><span class="line">// 进行字符串格式化处理</span><br><span class="line">NSString *lagReportString = [PLCrashReportTextFormatter stringValueForCrashReport:lagReport withTextFormat:PLCrashReportTextFormatiOS];</span><br><span class="line">//将字符串上传服务器</span><br><span class="line">NSLog(@&quot;lag happen, detail below: \n %@&quot;,lagReportString);</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RunLoop-原理&quot;&gt;&lt;a href=&quot;#RunLoop-原理&quot; class=&quot;headerlink&quot; title=&quot;RunLoop 原理&quot;&gt;&lt;/a&gt;RunLoop 原理&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;RunLoop&lt;/code&gt; 在 &lt;code&gt;iOS</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>性能优化02.1：FPS监测</title>
    <link href="https://www.bboyzj.cn/2023/03/23/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602.1%EF%BC%9AFPS%E7%9B%91%E6%B5%8B/"/>
    <id>https://www.bboyzj.cn/2023/03/23/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602.1%EF%BC%9AFPS%E7%9B%91%E6%B5%8B/</id>
    <published>2023-03-22T22:53:11.000Z</published>
    <updated>2023-03-22T22:58:22.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监控-FPS"><a href="#监控-FPS" class="headerlink" title="监控 FPS"></a>监控 FPS</h1><ul><li><p>一般来说，我们约定60FPS即为流畅，那么反过来，如果App在运行期间出现了掉帧，即可认为出现了卡顿。</p></li><li><p>监控FPS方案一般是基于 <code>CADisplayLink</code> 实现的。<code>CADisplayLink</code> 是一个和屏幕刷新率保持一致的定时器，一旦 <code>CADisplayLink</code> 以特定的模式注册到 <code>runloop</code> 后，没当屏幕需要刷新时，<code>runloop</code> 就会调用 <code>CADisplayLink</code> 绑定的 <code>target</code> 上的 <code>selector</code>。</p></li><li><p>通过向 <code>runloop</code> 中添加 <code>CADisplayLink</code>，根据回调来计算出当前画面的 <code>帧数</code>。</p></li><li><p><code>FPS</code> 的 <code>好处</code> 就是直观，根据FPS是否下降说明页面某处是否有性能问题。</p></li><li><p><code>FPS</code> 的 <code>坏处</code> 就是只知道页面的某处，不能准确定位到具体的 <code>堆栈</code>。</p></li></ul><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><ul><li>创建一个 <code>ZJFPSMonitor</code> 工具类，实现如下代码：</li></ul><p>.h 文件下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface ZJFPSMonitor : NSObject</span><br><span class="line">// 返回屏幕刷新率FPS</span><br><span class="line">@property (nonatomic,copy)void(^FPSMonitorBlock)(NSInteger fps);</span><br><span class="line">// 单例</span><br><span class="line">+ (instancetype)shareInstance;</span><br><span class="line">// 开始监测</span><br><span class="line">- (void)startMonitor;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure></div><p>.m 文件下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJFPSMonitor.h&quot;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &lt;ZJWeakProxy/ZJWeakProxy.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ZJFPSMonitor ()</span><br><span class="line">@property (nonatomic,strong)CADisplayLink * displayLink;</span><br><span class="line">@property (nonatomic,assign)NSTimeInterval lastUpdateTime; // 上一次更新时间</span><br><span class="line">@property (nonatomic,assign)NSInteger count; // 刷新次数</span><br><span class="line">@property (nonatomic,assign)NSInteger fps; // FPS</span><br><span class="line">@end</span><br><span class="line">@implementation ZJFPSMonitor</span><br><span class="line">// 单例</span><br><span class="line">+ (instancetype)shareInstance&#123;</span><br><span class="line">    static ZJFPSMonitor * instance = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        instance = [[ZJFPSMonitor alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -开始监测</span><br><span class="line">- (void)startMonitor&#123;</span><br><span class="line">    if (_displayLink != nil) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 线程保活</span><br><span class="line">    [self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -计算FPS</span><br><span class="line">- (void)fpsInfoAction:(CADisplayLink *)displayLink&#123;</span><br><span class="line">    if (self.lastUpdateTime == 0) &#123;</span><br><span class="line">        self.lastUpdateTime = displayLink.timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    // 刷新次数</span><br><span class="line">    self.count ++;</span><br><span class="line">    // 时间间隔</span><br><span class="line">    NSTimeInterval interval = displayLink.timestamp - self.lastUpdateTime;</span><br><span class="line">    // 如果满足更新FPS时间间隔</span><br><span class="line">    if (interval &gt;= 1) &#123;</span><br><span class="line">        // 赋值fps</span><br><span class="line">        self.fps = self.count / interval;</span><br><span class="line">        // 赋值上次更新时间</span><br><span class="line">        self.lastUpdateTime = displayLink.timestamp;</span><br><span class="line">        // 重置数量</span><br><span class="line">        self.count = 0;</span><br><span class="line">        // 返回FPS</span><br><span class="line">        if (self.FPSMonitorBlock) &#123;</span><br><span class="line">            self.FPSMonitorBlock(self.fps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -lazy</span><br><span class="line">- (CADisplayLink *)displayLink&#123;</span><br><span class="line">    if (!_displayLink) &#123;</span><br><span class="line">        _displayLink = [CADisplayLink displayLinkWithTarget:[ZJWeakProxy proxyWithTarget:self] selector:@selector(fpsInfoAction:)];</span><br><span class="line">        // 屏幕刷新率</span><br><span class="line">        _displayLink.preferredFramesPerSecond = 60;</span><br><span class="line">    &#125;</span><br><span class="line">    return _displayLink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>VC 中调用</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;ZJFPSMonitor.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // 开始监测FPS</span><br><span class="line">    [ZJFPSMonitor.shareInstance startMonitor];</span><br><span class="line">    ZJFPSMonitor.shareInstance.FPSMonitorBlock = ^(NSInteger fps) &#123;</span><br><span class="line">        NSLog(@&quot;%ld&quot;,fps);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p>查看打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2023-03-23 06:58:00.945820+0800 FPS[27330:1519462] 60</span><br><span class="line">2023-03-23 06:58:01.962348+0800 FPS[27330:1519462] 60</span><br><span class="line">2023-03-23 06:58:02.979022+0800 FPS[27330:1519462] 60</span><br><span class="line">2023-03-23 06:58:03.995646+0800 FPS[27330:1519462] 60</span><br><span class="line">2023-03-23 06:58:05.012252+0800 FPS[27330:1519462] 60</span><br><span class="line">2023-03-23 06:58:06.028901+0800 FPS[27330:1519462] 60</span><br><span class="line">2023-03-23 06:58:07.045433+0800 FPS[27330:1519462] 60</span><br><span class="line">2023-03-23 06:58:08.062067+0800 FPS[27330:1519462] 60</span><br><span class="line">2023-03-23 06:58:09.078645+0800 FPS[27330:1519462] 60</span><br><span class="line">2023-03-23 06:58:10.095264+0800 FPS[27330:1519462] 60</span><br><span class="line">2023-03-23 06:58:11.111855+0800 FPS[27330:1519462] 60</span><br><span class="line">2023-03-23 06:58:12.128443+0800 FPS[27330:1519462] 60</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;监控-FPS&quot;&gt;&lt;a href=&quot;#监控-FPS&quot; class=&quot;headerlink&quot; title=&quot;监控 FPS&quot;&gt;&lt;/a&gt;监控 FPS&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一般来说，我们约定60FPS即为流畅，那么反过来，如果App在运行期间出现了掉帧，即可认为</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>OC学习24：多环境配置</title>
    <link href="https://www.bboyzj.cn/2023/03/21/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A024%EF%BC%9A%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.bboyzj.cn/2023/03/21/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A024%EF%BC%9A%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2023-03-21T00:31:38.000Z</published>
    <updated>2023-03-29T05:07:53.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h1><ul><li>Project : 包含了项目所有的代码、资源文件和所有信息。</li><li>Target : 对指定代码和资源文件的具体构建方式。</li><li>Scheme : 对指定的Target的环境配置</li></ul><p>在实际开发中，我们必须要进行网络请求（<code>内网和外网</code>），而网络请求则就要针对不同的环境（<code>开发</code>、<code>测试</code>、<code>生产</code>）有不同的的<code>主机名称（URL_HOST）</code>，那么我们如何获取某个环境下的<code>URL_HOST</code>，那么在这个过程中，我们需要进行配置，而 <code>多环境配置</code> 的方式有三种：</p><ol><li>Target 配置</li><li>Scheme 配置</li><li>xcconfig 配置</li></ol><h1 id="Target-配置"><a href="#Target-配置" class="headerlink" title="Target 配置"></a>Target 配置</h1><ol><li>新建Dev的Target</li></ol><ul><li><p>选中 <code>Target</code> 下 <code>LoginApp</code> -&gt; 右键选中 <code>Duplicate</code> 复制 -&gt; 生成新的 <code>LoginApp copy</code> -&gt; 将其改名为 <code>LoginApp-Dev</code> </p></li><li><p>修改 <code>Bundle Identifier</code> 名为 <code>com.srsf.LoginApp-Dev</code></p></li><li><p>修改新生成的 <code>LoginApp copy-info</code> 名为 <code>LoginApp-Dev-info</code>，plist名称改变同时需要在 <code>Build Settings</code> -&gt; <code>Packaging</code> -&gt; <code>info.list File</code> 下 -&gt; 将 <code>LoginApp copy-info</code> 改成  <code>LoginApp-Dev-info</code>。</p></li></ul><p>如下图：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210829441.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210837715.png"                                     ></p><p>注：到目前为止，你运行 <code>LoginApp</code> 和 <code>LoginApp-Dev</code> 会生成两个 <code>App</code>。</p><ol start="2"><li>添加自定义宏 <code>macros</code></li></ol><ul><li>选中 <code>LoginApp-Dev</code> -&gt; <code>Builds Settings</code> -&gt; <code>all</code> -&gt; 搜索 <code>macros</code> -&gt; <code>Apple Clang - Preprocessing</code> -&gt; 选中 <code>Debug</code> 右键空白双击 -&gt; 弹出添加 <code>DEV=1</code>；同理，<code>Release</code> 设置 <code>DEV=0</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210859670.png"                                     ></p><ul><li>此时，自定义的宏已经生效了，此时可以在任意地方调用下面的方式进行判断使用</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if DEV</span><br><span class="line">    #define URL_HOST @&quot;http://192.168.0.1&quot;</span><br><span class="line">#else</span><br><span class="line">    #define URL_HOST @&quot;http://192.168.0.2&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></div><ol start="3"><li>当你切换不同的 <code>Scheme</code> 时，打印不同的 <code>URL_HOST</code></li></ol><p>如果你觉得 <code>Scheme</code> 下名字看的不爽，也可以将 <code>Scheme</code> 下的名字也修改：<code>LoginApp copy</code> 改成 <code>LoginApp-Dev</code></p><ol start="4"><li>总结</li></ol><p><code>Target</code> 配置这种方式，每创建一个 <code>target</code> 都会产生新的 <code>info.plist</code>，每一个都需要去配置 <code>macros</code>，配置比较乱，<code>不推荐</code> 使用。</p><h1 id="Scheme-配置"><a href="#Scheme-配置" class="headerlink" title="Scheme 配置"></a>Scheme 配置</h1><ol><li>首先我们要了解到 <code>Scheme</code> 默认是有两种环境变量 <code>Debug</code> 和 <code>Release</code>，可以在 <code>Edit Scheme</code> -&gt; <code>Run</code> -&gt; <code>info</code> -&gt; <code>Build Configuration</code> 下查看。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210909448.png"                                     ></p><ol start="2"><li>其次，与之对应的环境配置在 <code>Project</code> -&gt; <code>LoginApp</code> -&gt; <code>Configurations</code> 下也可以看到</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210916856.png"                                     ></p><ol start="3"><li>在 <code>Project</code> -&gt; <code>Info</code> -&gt; <code>Configurations</code> 下，我们可以创建一个自己的配置环境 <code>Beta</code>,现在我们有了 <code>三</code> 种配置方式，对应的在 <code>Edit Scheme</code> -&gt; <code>Run</code> -&gt; <code>info</code> -&gt; <code>Build Configuration</code> 下也有三种，同时在 <code>Target</code> -&gt; <code>Build Settings</code> -&gt; <code>Build Active Architecture Only</code> 下也有对应的三种配置方式，说明这是一个 <code>全局</code> 的配置，如下图：</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210923815.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210924650.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210925812.png"                                     ></p><ol start="3"><li>新建 Scheme</li></ol><ul><li>点击 <code>LoginApp</code> -&gt; manager Schemes -&gt; 点击 + 号 -&gt; 添加 <code>Debug</code> 和 <code>Beta</code> 两种，加上 <code>LoginApp</code> 本身 <code>Release</code> 就是三种，对应上面 <code>三种</code> 配置</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210927495.png"                                     ></p><ul><li>点击 <code>Edit Scheme</code> 切换 <code>Scheme</code>，并指定 <code>Configurations</code>，如下图</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210927160.png"                                     ></p><ol start="4"><li>自定义主机名URL_HOST</li></ol><ul><li><code>Target</code> -&gt; <code>Build Settings</code> -&gt; 点击 <code>+</code> 号 -&gt; <code>Add User-Defined Settings</code> -&gt; <code>URL_HOST</code>，此时我们发现其对应的配置也是三个，分别设值如下：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210930226.png"                                     ></p><ol start="5"><li>将 <code>URL_HOST</code> 添加到 <code>info.plist</code> 文件中，<code>Build Settings</code> 中的 配置可以通过 <code>info.plist</code> 暴露出来，可以直接读出来</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210933404.png"                                     ></p><ol start="6"><li>在项目中使用</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString * path = [NSBundle.mainBundle pathForResource:@&quot;Info&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">NSDictionary * infoDic = [[NSDictionary alloc] initWithContentsOfFile:path];</span><br><span class="line">NSLog(@&quot;%@&quot;,infoDic[@&quot;HOST_URL&quot;]);</span><br></pre></td></tr></table></figure></div><p>切换 <code>Scheme</code> ，打印如下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Debug：http://137.0.0.2</span><br><span class="line">Beta：http://137.0.0.1</span><br><span class="line">LoginApp：http://www.zjboy.com</span><br></pre></td></tr></table></figure></div><ol start="7"><li>同理配置图标的也一样</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210936202.png"                                     ></p><h1 id="xcconfig-配置"><a href="#xcconfig-配置" class="headerlink" title="xcconfig 配置"></a>xcconfig 配置</h1><ol><li>在实际项目中，我们可能会有多个主机名称 <code>HOST_URL</code>，因此，我们还是需要去配置多个<code>Configurations</code>，下面还是以三个为准</li></ol><ul><li>在 <code>Project</code> -&gt; <code>LoginApp</code> -&gt; <code>Configurations</code> 下，我们可以创建一个自己的配置环境 <code>Beta</code>,现在我们有 了 <code>三</code> 种配置方式，对应的在 <code>Edit Scheme</code> -&gt; <code>Run</code> -&gt; <code>info</code> -&gt; <code>Build Configuration</code> 下也有三种，同时在 <code>Target</code> -&gt; <code>Build Settings</code> -&gt; <code>Build Active Architecture Only</code> 下也有对应的三种配置方式，说明这是一个 <code>全局</code> 的配置，如下图：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211008376.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210936989.png"                                     ></p><ol start="2"><li>在主项目下，创建 <code>Congifg</code> 文件，并在下面创建三个对应环境的 <code>.xxconfig</code> 文件</li></ol><ul><li>在Config文件夹下 -&gt; command + N -&gt; 搜索config</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210936598.png"                                     ></p><ul><li>输入对应的名称 -&gt; 点击create</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/148355970-ade68d43-9816-4697-92d6-b451aa09e20d.jpg"                                     ></p><ul><li>创建成功之后，如下图</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211025332.png"                                     ></p><ol start="2"><li>选择对应Target的进行配置</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211025894.png"                                     ></p><ol start="3"><li>在 <code>xxconfig</code> 文件中写入 <code>HOST_URL</code></li></ol><ul><li><code>Debug</code> 下</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = /</span><br><span class="line">HOST_URL = http:$&#123;A&#125;/127.0.0.1</span><br></pre></td></tr></table></figure></div><ul><li>Beta</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = /</span><br><span class="line">HOST_URL = http:$&#123;A&#125;/127.0.0.2</span><br></pre></td></tr></table></figure></div><ul><li>Release ：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = /</span><br><span class="line">HOST_URL = http:$&#123;A&#125;/www.bboyzj.cn</span><br></pre></td></tr></table></figure></div><ol start="4"><li>同样，我们需要在 <code>info.plist</code> 文件中暴露，在项目中取出</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210935125.png"                                     ></p><ol start="5"><li>项目中代码取出</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString * path = [NSBundle.mainBundle pathForResource:@&quot;Info&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">    NSDictionary * infoDic = [[NSDictionary alloc] initWithContentsOfFile:path];</span><br><span class="line">    NSLog(@&quot;%@&quot;,infoDic[@&quot;HOST_URL&quot;]);</span><br></pre></td></tr></table></figure></div><p>切换不同的 scheme 的打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Debug：http://127.0.0.1</span><br><span class="line"></span><br><span class="line">Beta： http://127.0.0.2</span><br><span class="line"></span><br><span class="line">Release：https://www.bboyzj.cn</span><br></pre></td></tr></table></figure></div><h1 id="Pch"><a href="#Pch" class="headerlink" title="Pch"></a>Pch</h1><ul><li>到 Target -&gt; Build Settings -&gt; 设值不同的DEBUG值</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211034254.png"                                     ></p><ul><li>具体是现代吗</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#if (DEBUG == 1)</span><br><span class="line">    #define kBaseUrl @&quot;http://127.0.0.1&quot;</span><br><span class="line">#elif (DEBUG == 2)</span><br><span class="line">    #define kBaseUrl @&quot;http://127.0.0.2&quot;</span><br><span class="line">#else</span><br><span class="line">    #define kBaseUrl @&quot;https://www.bboyzj.cn&quot;</span><br><span class="line">#endif</span><br><span class="line">    NSLog(@&quot;url:%@&quot;,kBaseUrl);</span><br></pre></td></tr></table></figure></div><h1 id="xconfig-其他功能"><a href="#xconfig-其他功能" class="headerlink" title="xconfig 其他功能"></a>xconfig 其他功能</h1><ul><li><code>xconfig</code> 全名是 <code>xcodeConfig</code>，它不仅仅是一个文件，它的本质是控制 <code>Build Settings</code> 里面的选项(比如配置动态库、静态库等)</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ld 配置到链接器上</span><br><span class="line">// OTHER_LDFLAGS 即 Other Linker Flags 的缩写</span><br><span class="line">OTHER_LDFLAGS = -framework &quot;AFNetworking&quot;</span><br></pre></td></tr></table></figure></div><ul><li>在Debug配置下运行，报错 <code>ld: framework not found AFNetworking</code> ，然后我们找到 <code>Other Linker Flags</code>，可以看到如下</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211035155.png"                                     ></p><ul><li><p>他的原理与 <code>cocoapods</code> 的原理相同</p></li><li><p>想查找 <code>Build Settings</code> 中选项的缩写，这里有一个网站可以去查看 <a class="link"   href="https://xcodebuildsettings.com/" >Build Settings 缩写网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p>比如搜索一个 <code>header search path</code>，找到其缩写 <code>HEADER_SEARCH_PATHS</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEADER_SEARCH_PATHS = \user\zjbboy</span><br></pre></td></tr></table></figure></div><ul><li>你会在 <code>build settings</code> 找到</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211037905.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多环境配置&quot;&gt;&lt;a href=&quot;#多环境配置&quot; class=&quot;headerlink&quot; title=&quot;多环境配置&quot;&gt;&lt;/a&gt;多环境配置&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Project : 包含了项目所有的代码、资源文件和所有信息。&lt;/li&gt;
&lt;li&gt;Target : 对指</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习18：多环境切换</title>
    <link href="https://www.bboyzj.cn/2023/03/21/Swift/Swift%E5%AD%A6%E4%B9%A018%EF%BC%9A%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/"/>
    <id>https://www.bboyzj.cn/2023/03/21/Swift/Swift%E5%AD%A6%E4%B9%A018%EF%BC%9A%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/</id>
    <published>2023-03-20T23:33:09.000Z</published>
    <updated>2023-03-21T02:43:57.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>swift</code> 多环境配置和 <code>oc</code> 类似，本文主要介绍 <code>Scheme</code> 和 <code>xcconfig</code> 多环境配置</p><h1 id="第一种方式：Scheme"><a href="#第一种方式：Scheme" class="headerlink" title="第一种方式：Scheme"></a>第一种方式：Scheme</h1><ol><li>首先我们要了解到 <code>Scheme</code> 默认是有两种环境变量 <code>Debug</code> 和 <code>Release</code>，可以在 <code>Edit Scheme</code> -&gt; <code>Run</code> -&gt; <code>info</code> -&gt; <code>Build Configuration</code> 下查看。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211039679.png"                                     ></p><ol start="2"><li>其次，与之对应的环境配置在 <code>Project</code> -&gt; <code>Scheme</code> -&gt; <code>Configurations</code> 下也可以看到：</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211039310.png"                                     ></p><ol start="3"><li>在 <code>Project</code> -&gt; <code>Info</code> -&gt; <code>Configurations</code> 下，我们可以创建一个自己的配置环境 <code>Beta</code>,现在我们有了 <code>三</code> 种配置方式，如下图：</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211039788.png"                                     ></p><ul><li>对应的在 <code>Edit Scheme</code> -&gt; <code>Run</code> -&gt; <code>info</code> -&gt; <code>Build Configuration</code> 下也有三种，如下图：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211040573.png"                                     ></p><ul><li>同时在 <code>Target</code> -&gt; <code>Build Settings</code> -&gt; <code>Build Active Architecture Only</code> 下也有对应的三种配置方式，说明这是一个 <code>全局</code> 的配置，如下图：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211040984.png"                                     ></p><ol start="4"><li>新建 Scheme</li></ol><ul><li>点击 <code>Scheme -&gt; manager Schemes</code> -&gt; 点击 <code>+</code> 号 -&gt; 添加 <code>Debug</code> 和 <code>Beta</code> 两种，加上 <code>Scheme</code> 本身 <code>Release</code> 就是三种，对应上面 <code>三种</code> 配置</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211040044.png"                                     ></p><ul><li>点击 <code>Edit Scheme</code> 切换 <code>Scheme</code>，并指定 <code>Configurations</code>，如下图:</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211041361.png"                                     ></p><ol start="5"><li>自定义主机名 <code>URL_HOST</code></li></ol><ul><li><code>Target</code> -&gt; <code>Build Settings</code> -&gt; 点击 <code>+</code> 号 -&gt; <code>Add User-Defined Settings</code> -&gt; <code>URL_HOST</code>，此时我们发现其对应的配置也是三个，分别设值如下：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211041980.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211041457.png"                                     ></p><ol start="6"><li>将 <code>URL_HOST</code> 添加到 <code>info.plist</code> 文件中，<code>Build Settings</code> 中的 配置可以通过 <code>info.plist</code> 暴露出来，可以直接读出来</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211042468.png"                                     ></p><ol start="7"><li>在项目中使用</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let path = Bundle.main.path(forResource: &quot;Info&quot;, ofType: &quot;plist&quot;);</span><br><span class="line">let dic = NSMutableDictionary(contentsOfFile: path!);</span><br><span class="line">print(dic![&quot;URL_HOST&quot;]!);</span><br></pre></td></tr></table></figure></div><p>切换 scheme ，查看不同的打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://Debug</span><br><span class="line">http://Release</span><br><span class="line">http://Beta</span><br></pre></td></tr></table></figure></div><h1 id="第二种方式：xcconfig-配置"><a href="#第二种方式：xcconfig-配置" class="headerlink" title="第二种方式：xcconfig 配置"></a>第二种方式：xcconfig 配置</h1><ol><li>同样的，我们需要先配置 <code>三种 Connfigurations</code> ，配置方式同上</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211042205.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211042608.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211042489.png"                                     ></p><ol start="2"><li>在主项目下，创建 <code>Config</code> 文件，并在下面创建三个对应环境的 <code>.xcconfig</code> 文件</li></ol><ul><li>在Config文件夹下 -&gt; <code>command + N</code> -&gt; 搜索config</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211042170.png"                                     ></p><ul><li>输入对应的名称 -&gt; 点击create</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211043434.png"                                     ></p><ul><li>创建成功之后，如下图:</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211043637.png"                                     ></p><ol start="3"><li>选择对应Target的进行配置</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211043410.png"                                     ></p><ol start="4"><li>在 <code>xconfig</code> 文件中写入 <code>URL_HOST</code></li></ol><ul><li><code>Debug</code> 下</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = /</span><br><span class="line">URL_HOST = http:$&#123;A&#125;/Debug</span><br></pre></td></tr></table></figure></div><ul><li>Beta</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = /</span><br><span class="line">URL_HOST = http:$&#123;A&#125;/Beta</span><br></pre></td></tr></table></figure></div><ul><li>Release ：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = /</span><br><span class="line">URL_HOST = http:$&#123;A&#125;/Release</span><br></pre></td></tr></table></figure></div><ol start="5"><li>同样，我们需要在 <code>info.plist</code> 文件中暴露，在项目中取出</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211043893.png"                                     ></p><ol start="6"><li>项目中代码取出</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let path = Bundle.main.path(forResource: &quot;Info&quot;, ofType: &quot;plist&quot;);</span><br><span class="line">let dic = NSMutableDictionary(contentsOfFile: path!);</span><br><span class="line">print(dic![&quot;URL_HOST&quot;]!);</span><br></pre></td></tr></table></figure></div><p>切换 scheme ，查看不同的打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://Debug</span><br><span class="line">http://Release</span><br><span class="line">http://Beta</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;swift&lt;/code&gt; 多环境配置和 &lt;code&gt;oc&lt;/code&gt; 类似，本文主要介绍 &lt;code&gt;Scheme&lt;/code</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Flutter学习03：Dart数据类型</title>
    <link href="https://www.bboyzj.cn/2023/03/21/Flutter%E5%AD%A6%E4%B9%A0/Flutter%E5%AD%A6%E4%B9%A003%EF%BC%9ADart%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://www.bboyzj.cn/2023/03/21/Flutter%E5%AD%A6%E4%B9%A0/Flutter%E5%AD%A6%E4%B9%A003%EF%BC%9ADart%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2023-03-20T21:41:36.000Z</published>
    <updated>2023-03-20T21:46:04.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h1><ul><li><p>Numbers（数值）：</p><ul><li>int</li><li>double</li></ul></li><li><p>Strings（字符串）：</p><ul><li>String</li></ul></li><li><p>Booleans（布尔）：</p><ul><li>bool</li></ul></li><li><p>List（数组）：</p><ul><li>在dart中，数组是列表对象，所以大多数人只是称它们为列表</li></ul></li><li><p>Maps（字典）：<br>  通常来说，Map 是一个键值对相关的对象。键和值可以是任何类型的对象。每个键</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用数据类型&quot;&gt;&lt;a href=&quot;#常用数据类型&quot; class=&quot;headerlink&quot; title=&quot;常用数据类型&quot;&gt;&lt;/a&gt;常用数据类型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Numbers（数值）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int&lt;/li&gt;
&lt;li&gt;double</summary>
      
    
    
    
    <category term="Flutter-学习篇" scheme="https://www.bboyzj.cn/categories/Flutter-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
    
    <category term="Flutter" scheme="https://www.bboyzj.cn/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter学习02：Dart入口、打印、注释、常量、变量、命名规则</title>
    <link href="https://www.bboyzj.cn/2023/03/20/Flutter%E5%AD%A6%E4%B9%A0/Flutter%E5%AD%A6%E4%B9%A002%EF%BC%9ADart%E5%85%A5%E5%8F%A3%E3%80%81%E6%89%93%E5%8D%B0%E3%80%81%E6%B3%A8%E9%87%8A%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"/>
    <id>https://www.bboyzj.cn/2023/03/20/Flutter%E5%AD%A6%E4%B9%A0/Flutter%E5%AD%A6%E4%B9%A002%EF%BC%9ADart%E5%85%A5%E5%8F%A3%E3%80%81%E6%89%93%E5%8D%B0%E3%80%81%E6%B3%A8%E9%87%8A%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/</id>
    <published>2023-03-20T09:07:03.000Z</published>
    <updated>2023-03-20T21:40:25.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="入口方法"><a href="#入口方法" class="headerlink" title="入口方法"></a>入口方法</h1><p>入口方法有两种方式：</p><ul><li>第一种</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">    print(&#x27;hello dart&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>第二种</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 表示main方法没有返回值</span><br><span class="line">void main() &#123;</span><br><span class="line">    print(&#x27;hello dart&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>注：<br>如果无法输入请按 i：切换为输入<br>如果运行结果不全：请先保存 command + s</p></blockquote><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><ul><li>command + &#x2F;</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// main() &#123;</span><br><span class="line">//   print(&quot;hello dart&quot;);</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure></div><ul><li>&#x2F;&#x2F;&#x2F;</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/// 这也是一个注释</span><br></pre></td></tr></table></figure></div><ul><li>&#x2F;* 内容 *&#x2F;</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  // 表示main方法没有返回值</span><br><span class="line">  void main() &#123;</span><br><span class="line">    print(&#x27;hello dart&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></div><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul><li><p>dart 变量是一个强大的脚本类语言，可以不先预定义变量类型，自动会类型推断</p></li><li><p>dart 定义变量可以通过 <code>var</code> 关键字来申明变量</p></li></ul><p>如：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  // dart里面有类型校验</span><br><span class="line">    </span><br><span class="line">  // 定义变量-字符串类型</span><br><span class="line">  var str = &quot;this is var&quot;;</span><br><span class="line">  print(str);</span><br><span class="line">  // 也可以用另一种方式</span><br><span class="line">  String str1 = &#x27;this is str&#x27;;</span><br><span class="line">  print(str1);</span><br><span class="line"></span><br><span class="line">  // 定义变量-数字类型</span><br><span class="line">  var myNum = 1234;</span><br><span class="line">  print(myNum);</span><br><span class="line">  // 另一张方式</span><br><span class="line">  int myNum1 = 12345;</span><br><span class="line">  print(myNum1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>注：<code>var</code> 后不要写类型，写了类型 不要写 <code>var</code>，两者都写 <code>var int a = 5;</code> 报错</p></blockquote><h1 id="Dart-的命名规则"><a href="#Dart-的命名规则" class="headerlink" title="Dart 的命名规则"></a>Dart 的命名规则</h1><ul><li>变量名称必须由数字、字母、下划线和美元符$组成</li><li>注意：标识符开头不能是数字</li><li>标识符不能是保留字和关键字</li><li>变量的名字是区分大小写的，如：age和Age是不同的变量</li><li>变量名称建议用名词，方法名建议用动词</li></ul><p>示例：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;this is var string&#x27;;</span><br><span class="line"></span><br><span class="line">// 错误的写法</span><br><span class="line">// 数字开头</span><br><span class="line">// var 2str = &#x27;error var&#x27;;</span><br><span class="line">// 关键字</span><br><span class="line">// var if = &#x27;12&#x27;;</span><br><span class="line"></span><br><span class="line">// 变量区分大小写</span><br><span class="line">var age = 30;</span><br><span class="line">print(age);</span><br><span class="line"></span><br><span class="line">var Age = 31;</span><br><span class="line">print(Age);</span><br></pre></td></tr></table></figure></div><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><ul><li><p><code>const</code> 值不变 一开始就得赋值</p></li><li><p><code>final</code> 可以开始不赋值 只能赋一次，而final不仅有const的编译时常量特性，最重要的它是运行时</p></li><li><p>永远不改变的量，请使用 <code>const</code> 或 <code>final</code> 修饰，而不是使用var或其他变量类型</p></li><li><p>final 和 const 区别：final可以开始不赋值，只能赋一次。而final不仅有const编译时常量的特性，最重要的是它是运行时的常量，并且final是惰性初始化，即在运行时第一次使用前才初始化</p></li></ul><p>示例：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// const修饰常量</span><br><span class="line">  // const PI = 3.1415926;</span><br><span class="line">  // PI = 123.123; // 错误的写法 常量不可以修改</span><br><span class="line"></span><br><span class="line">// final修饰常量</span><br><span class="line">  final PI = 3.1415926;</span><br><span class="line">  // PI = 123.123; // 错误的写法 常量不可以修改</span><br><span class="line"></span><br><span class="line">  final a = new DateTime.now();</span><br><span class="line">  print(a);</span><br><span class="line"></span><br><span class="line">  const a1 = new DateTime.now(); // 错误</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;入口方法&quot;&gt;&lt;a href=&quot;#入口方法&quot; class=&quot;headerlink&quot; title=&quot;入口方法&quot;&gt;&lt;/a&gt;入口方法&lt;/h1&gt;&lt;p&gt;入口方法有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight-c</summary>
      
    
    
    
    <category term="Flutter-学习篇" scheme="https://www.bboyzj.cn/categories/Flutter-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
    
    <category term="Flutter" scheme="https://www.bboyzj.cn/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习17：Model使用结构体还是类</title>
    <link href="https://www.bboyzj.cn/2023/03/19/Swift/Swift%E5%AD%A6%E4%B9%A017%EF%BC%9AModel%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E8%BF%98%E6%98%AF%E7%B1%BB/"/>
    <id>https://www.bboyzj.cn/2023/03/19/Swift/Swift%E5%AD%A6%E4%B9%A017%EF%BC%9AModel%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E8%BF%98%E6%98%AF%E7%B1%BB/</id>
    <published>2023-03-19T14:42:36.000Z</published>
    <updated>2023-03-19T14:43:07.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习16：Git使用</title>
    <link href="https://www.bboyzj.cn/2023/03/19/Swift/Swift%E5%AD%A6%E4%B9%A016%EF%BC%9AGit%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.bboyzj.cn/2023/03/19/Swift/Swift%E5%AD%A6%E4%B9%A016%EF%BC%9AGit%E4%BD%BF%E7%94%A8/</id>
    <published>2023-03-19T00:21:04.000Z</published>
    <updated>2023-03-20T23:37:26.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p><code>Git</code> 是一款免费、开源的 <code>分布式版本控制系统</code></p></li><li><p><code>GitHub/Gitee/Gitlab</code> 用 <code>Git</code> 做版本控制的项目托管平台</p></li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a class="link"   href="https://git-scm.com/downloads" >Git官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 选择自己对应的系统安装，安装完成后在终端执行 <code>git version</code>，输出 <code>git</code> 版本则安装成功，<code>Mac</code> 本身自带 <code>git</code>，可以不用安装</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % git version</span><br><span class="line">git version 2.37.1 (Apple Git-137.1)</span><br></pre></td></tr></table></figure></div><h1 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h1><ul><li>使用 <code>git config</code> 命令来配置用户信息</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % git config --global user.name &quot;BboyZJ&quot;</span><br><span class="line">mac@bogon ~ % git config --global user.email 13718004742@163.com</span><br></pre></td></tr></table></figure></div><blockquote><p>注：<br>–global：表示你的配置文件在你用户主目录下，以后默认使用这里配置的用户信息。<br>如果要在某个特定的仙姑中使用其他名字或电子邮件，只要去掉 –global 重新配置即可，新设定保存在当前项目的 <code>.git/config</code> 文件中</p></blockquote><ul><li>检查是否成功</li></ul><p>使用 git config user.name 和 git config user.email 或者使用 git config –list</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % git config user.name</span><br><span class="line">BboyZJ</span><br><span class="line">mac@bogon ~ % git config user.email</span><br><span class="line">13718004742@163.com</span><br></pre></td></tr></table></figure></div><h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><ul><li>初始化</li></ul><blockquote><p>git init</p></blockquote><ul><li>提交</li></ul><blockquote><p>&#x2F;&#x2F; 将当前目录下所有文件提交到暂存区<br>git add .<br>&#x2F;&#x2F; 添加单个文件到暂缓区<br>git add file…</p></blockquote><ul><li>查看</li></ul><blockquote><p>&#x2F;&#x2F; 查看当前仓库的状态<br>git status<br>&#x2F;&#x2F; 查看提交记录<br>git log</p></blockquote><ul><li>版本回退</li></ul><blockquote><p>&#x2F;&#x2F; 切换到指定版本<br>git reset –hard 版本id<br>&#x2F;&#x2F; 查看以前的提交日志<br>git reflog</p></blockquote><ul><li>克隆&#x2F;更新</li></ul><blockquote><p>&#x2F;&#x2F; 克隆<br>git clone 仓库地址<br>&#x2F;&#x2F; 更新<br>git pull </p></blockquote><ul><li>关联&#x2F;推送</li></ul><blockquote><p>&#x2F;&#x2F; 添加远程仓库关联<br>git remote add origin 仓库地址<br>&#x2F;&#x2F; 查看所有远程仓库关联<br>git remote -v<br>&#x2F;&#x2F; 删除远程仓库关联<br>git remote remove origin 仓库地址</p><p>&#x2F;&#x2F; 推送到远程第一次加 -u<br>git push -u origin master<br>&#x2F;&#x2F; 不是第一次推送<br>git push origin zj_feature</p></blockquote><ul><li>分支操作</li></ul><blockquote><p>&#x2F;&#x2F; 查看分支<br>git branch<br>&#x2F;&#x2F; 删除分支<br>git branch -d<br>&#x2F;&#x2F; 新建分支<br>git branch zj_feature<br>&#x2F;&#x2F; 新建并切换分支<br>git checkout -b zj_feature<br>&#x2F;&#x2F; 切换分支<br>git checkout zj_feature</p></blockquote><ul><li>提交</li></ul><blockquote><p>&#x2F;&#x2F; 提交所有代码到暂存区<br>git add .<br>&#x2F;&#x2F; 提交到本地仓库<br>git commit -m “注释说明”<br>&#x2F;&#x2F; 提交到 远程仓库<br>git push origin zj_feature</p></blockquote><h1 id="拉取代码"><a href="#拉取代码" class="headerlink" title="拉取代码"></a>拉取代码</h1><blockquote><p>&#x2F;&#x2F; 克隆<br>git clone <a class="link"   href="mailto:&#x67;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;" >&#x67;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#109; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>:BboyZJ&#x2F;ZJWeakProxy.git</p></blockquote><h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><ul><li>在分支下的操作</li></ul><blockquote><p>&#x2F;&#x2F; 切换到 zj_feature<br>git checkout zj_feature<br>&#x2F;&#x2F; 添加到暂缓区<br>git add files….<br>&#x2F;&#x2F; 提交到本地仓库<br>git commit -m “commit msg”<br>&#x2F;&#x2F; 提交到远程 zj_feature 分支<br>git push origin zj_feature</p></blockquote><ul><li>更新到主分支</li></ul><blockquote><p>&#x2F;&#x2F; 切换到主分支<br>git checkout master<br>&#x2F;&#x2F; 拉取主分支内容<br>git pull origin master<br>git add files….<br>&#x2F;&#x2F; 提交到本地仓库<br>git commit -m “commit msg”<br>&#x2F;&#x2F; 提交到远程 master 分支<br>git push origin master</p></blockquote><ul><li>合并分支</li></ul><blockquote><p>&#x2F;&#x2F; 切换到 zj_feature<br>git checkout zj_feature<br>&#x2F;&#x2F; 合并主分支到当前分支<br>git merge master<br>&#x2F;&#x2F; 提交到远程分支 zj_feature<br>git push origin zj_feature</p></blockquote><h1 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h1><blockquote><p>&#x2F;&#x2F; 切换到想打tag的分支<br>git checkout master<br>&#x2F;&#x2F; 创建带有信息的tag<br>git tag -a release_v1.0 -m “release_v1.0”<br>&#x2F;&#x2F; 创建不带有信息的tag<br>git tag release_v1.0<br>&#x2F;&#x2F; 查看tag<br>git tag<br>&#x2F;&#x2F; 推送全部tag<br>git push –tags<br>&#x2F;&#x2F; 推送单个tag<br>git push origin release_v1.0</p></blockquote><h1 id="【面试题】"><a href="#【面试题】" class="headerlink" title="【面试题】"></a>【面试题】</h1><ul><li>提交 <code>单个/多个</code> 文件夹&#x2F;文件</li></ul><p><code>git add</code> 可以提交 <code>单个/多个</code> 文件夹&#x2F;文件，后面加上 <code>文件夹/文件路径</code> 即可</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon SRSF % git branch zj_feature</span><br><span class="line">mac@bogon SRSF % git add /Users/mac/Desktop/SRSF/SRSF/Classes/UI\(用户界面\)/Me\(我的\)/Collect\(收藏\)</span><br><span class="line">mac@bogon SRSF % git commit -m &quot;提交收藏文件夹&quot;</span><br><span class="line">mac@bogon SRSF % git push origin zj_feature</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Git&lt;/code&gt; 是一款免费、开源的 &lt;code&gt;分布式版本控制系统&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>OC学习21：hybrid</title>
    <link href="https://www.bboyzj.cn/2023/03/16/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A021%EF%BC%9Ahybrid/"/>
    <id>https://www.bboyzj.cn/2023/03/16/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A021%EF%BC%9Ahybrid/</id>
    <published>2023-03-16T08:34:42.000Z</published>
    <updated>2023-03-17T12:40:51.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <code>iOS</code> 开发中，<code>iOS</code> 和 <code>JS</code> 交互是每个程序猿必须掌握的技能。<code>iOS8</code> 以后，苹果推出了新框架 <code>WebKit</code>，使用 <code>WKWebView</code> 替代 <code>UIWebView</code>。</p><p>说道 <code>iOS</code> 和 <code>JS</code> 交互，就不得不提 <code>Hybrid（Hybrid Mobile App）</code>，即通过 <code>Web</code> 网络技术与 <code>Native</code> 相结合的混合移动应用开发</p><blockquote><p><code>WKWebView</code> 特性<br>1、稳定性好、占用内存少，速度更快<br>2、高达60fps的滚动刷新率以及内置手势</p></blockquote><p>本文主要介绍 <code>WKWebView</code> 与 <code>JS</code> 交互</p><h1 id="WKWebView-和-JS-交互的方法"><a href="#WKWebView-和-JS-交互的方法" class="headerlink" title="WKWebView 和 JS 交互的方法"></a>WKWebView 和 JS 交互的方法</h1><ol><li><code>WKScriptMessageHandler</code> 代理</li><li>拦截 <code>URL</code></li></ol><p>下面以实际功能为例讲解其使用</p><h1 id="WKScriptMessageHandler-代理"><a href="#WKScriptMessageHandler-代理" class="headerlink" title="WKScriptMessageHandler 代理"></a>WKScriptMessageHandler 代理</h1><ul><li><code>WKScriptMessageHandler</code> 是一个 <code>代理</code> ，代理有一个方法：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 当接收到 JS 消息 时调用，是 UserContentController 委托的代理方法</span><br><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message;</span><br></pre></td></tr></table></figure></div><blockquote><p>上面的代理回调方法是 <code>WKScriptMessageHandler</code> 的代理回到方法，当接收到 <code>JS</code> 消息时调用，是 <code>UserContentController（调度器）</code> 委托的代理方法。</p></blockquote><h1 id="WKUserContentController"><a href="#WKUserContentController" class="headerlink" title="WKUserContentController"></a>WKUserContentController</h1><blockquote><p><code>WKWebView</code> 和 <code>JS</code> 交互，那就得提到 <code>WKUserContentController</code> ，什么是 <code>WKUserContentController</code> ？ <code>WKUserContentController</code> 的作用？</p></blockquote><ul><li><code>WKUserContentController</code> 可以理解为 <code>调度器</code>，用于 <code>JS 和 OC 内容交互</code>，下面我们看一下具体有哪些方法：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface WKUserContentController : NSObject &lt;NSCoding&gt;</span><br><span class="line">// 与内容交互的脚本对象数组</span><br><span class="line">@property (nonatomic, readonly, copy) NSArray&lt;WKUserScript *&gt; *userScripts; </span><br><span class="line">// 添加一个脚本，可以理解为注入一个对象</span><br><span class="line">- (void)addUserScript:(WKUserScript *)userScript;</span><br><span class="line"></span><br><span class="line">// 移除所有脚本</span><br><span class="line">- (void)removeAllUserScripts; </span><br><span class="line"></span><br><span class="line">// 添加 JS 消息处理并设置代理</span><br><span class="line">// JS 中要添加 window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;) 方法,是 JS 与OC 之间的桥梁</span><br><span class="line">- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;</span><br><span class="line"></span><br><span class="line">// 根据 name 移除所注入的 scriptMessageHandler</span><br><span class="line">- (void)removeScriptMessageHandlerForName:(NSString *)name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><blockquote><p>这里有一个重要的方法：<code>addScriptMessageHandler</code>，添加 <code>JS</code> 消息处理并设置代理</p></blockquote><ul><li>示例：</li></ul><blockquote><p>1、<code>JS</code> 与 <code>OC</code> 约定好方法，如 <code>ShowMessageFromWKWebView:</code><br>2、<code>OC</code> 使用 <code>WKUserContentController</code> 的 <code>addScriptMessageHandler:name:</code> 方法设置代理并接收名为 <code>name</code> 的 <code>ShowMessageFromWKWebView</code> 的消息<br>3、<code>JS</code> 通过 <code>window.webkit.messageHandlers.scan.postMessage()</code> 的方式将方法 <code>scan</code> 发送消息到 <code>OC</code><br>4、<code>OC</code> 通过 <code>WKScriptMessageHandler</code> 的代理回调方法 <code>userContentController:didReceiveScriptMessage:</code> 中读取 <code>name</code> 为 <code>ShowMessageFromWKWebView</code> 的消息，消息数据在 <code>message.body</code> 中</p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupWKWebView&#123;</span><br><span class="line">    WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];</span><br><span class="line">    configuration.userContentController = [[WKUserContentController alloc] init];</span><br><span class="line">    </span><br><span class="line">    // 添加 JS 消息处理并设置代理</span><br><span class="line">    [configuration.userContentController addScriptMessageHandler:self name:@&quot;scan&quot;];</span><br><span class="line"></span><br><span class="line">    WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];</span><br><span class="line">    webView.UIDelegate = self;</span><br><span class="line">    [self.view addSubview:self.wkWebV];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>h5中要实现的代码</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function showMessageFromWKWebViewClick() &#123;</span><br><span class="line">    // JS 发送消息到 OC</span><br><span class="line">window.webkit.messageHandlers.ShowMessageFromWKWebView.postMessage(&#123;title:&#x27;WKWebView&#x27;, message:&#x27;测试WKWebView和OC交互&#x27;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>实现 <code>WKScriptMessageHandler</code> 代理方法，当接收到 <code>JS</code> 消息 <code>name</code> 为 <code>ShowMessageFromWKWebView</code> 时调用，会回调此代理方法：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - WKScriptMessageHandler</span><br><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123;</span><br><span class="line">// 从协议中我们可以看出这里使用了两个类 WKUserContentController 和 WKScriptMessage。WKUserContentController 可以理解为 调度器，WKScriptMessage 则是携带的数据。</span><br><span class="line">    </span><br><span class="line">    // OC 读取 JS 的消息数据</span><br><span class="line">    NSLog(@&quot;body:%@&quot;,message.body);</span><br><span class="line">    if ([message.name isEqualToString:@&quot;ShowMessageFromWKWebView&quot;]) &#123;</span><br><span class="line">        NSDictionary * dict = message.body;</span><br><span class="line">        NSString * messageStr = [dict objectForKey:@&quot;message&quot;];</span><br><span class="line">        NSString * titleStr = [dict objectForKey:@&quot;title&quot;];</span><br><span class="line">        NSLog(@&quot;messageStr:%@&quot;,messageStr);</span><br><span class="line">        NSLog(@&quot;titleStr:%@&quot;,titleStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="OC-调用-JS"><a href="#OC-调用-JS" class="headerlink" title="OC 调用 JS"></a>OC 调用 JS</h1><ul><li><code>OC</code> 调用 <code>JS</code> 方法用 <code>evaluateJavaScript</code>，可以 <code>传递参数</code>，将拼接字符串传递给 <code>JS</code>，拼接的字符串有格式要求：<code>方法名(&#39;参数&#39;)</code>，是 <code>WKWebView</code> 下的一个方法</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// OC传值JS的代码</span><br><span class="line">NSString * returnJSStr = [NSString stringWithFormat:@&quot;showMessageFromWKWebViewResult(&#x27;%@&#x27;)&quot;, @&quot;message传到OC成功，message传到OC成功，message传到OC成功，message传到OC成功，message传到OC成功，message传到OC成功&quot;];</span><br><span class="line">[self.wkWebV evaluateJavaScript:returnJSStr completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123;</span><br><span class="line">    NSLog(@&quot;%@,%@&quot;,result,error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></div><ul><li>JS 接收 OC 消息</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// JS 接收 OC 消息</span><br><span class="line">function showMessageFromWKWebViewResult(returnStr) &#123;</span><br><span class="line">    if (returnStr != null) &#123;</span><br><span class="line">        alert(&quot;JS已经收到OC的传值&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    document.getElementById(&quot;returnTextrea&quot;).value = returnStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="拦截-URL-实现自定义跳转功能"><a href="#拦截-URL-实现自定义跳转功能" class="headerlink" title="拦截 URL 实现自定义跳转功能"></a>拦截 URL 实现自定义跳转功能</h1><p>拦截 <code>URL</code> 是通过 <code>WKWebView</code> 的 <code>WKNavigationDelegate</code> 代理回调 <code>decidePolicyForNavigationAction</code> 方式实现的，例如：点击WebView按钮、cell等事件，去做一些功能</p><ul><li>在发送请求之前，决定是否跳转</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123;</span><br><span class="line">    // 获取当前的url</span><br><span class="line">    NSString * url = navigationAction.request.URL.absoluteString;</span><br><span class="line">    ZJLog(@&quot;url:%@&quot;,url);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>动态控制是否允许跳转和跳转到哪里</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -处理客服中心按钮的点击事件</span><br><span class="line">- (void)handleCallCenterClickActionWithUrl:(NSString *)url decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123;</span><br><span class="line">    ZJLog(@&quot;url:%@&quot;,url);</span><br><span class="line">    if ([url containsString:@&quot;cloudapp://goodsDetail?goodsId=&quot;]) &#123; // 跳转商品详情</span><br><span class="line">        // 去掉前缀</span><br><span class="line">        NSArray * arr = [url componentsSeparatedByString:@&quot;goodsId=&quot;];</span><br><span class="line">        NSString * goodsId = arr.lastObject;</span><br><span class="line">        SFGoodsDetailVC * goodsDetailVc = [SFGoodsDetailVC new];</span><br><span class="line">        goodsDetailVc.goodsId = [goodsId integerValue];</span><br><span class="line">        goodsDetailVc.enterType = GoodsDetailEnterType_Normal;</span><br><span class="line">        goodsDetailVc.souce = CommodityDetailSouce_Banner; // 首页Banner</span><br><span class="line">        [self.navigationController pushViewController:goodsDetailVc animated:YES];</span><br><span class="line">        // 拦截跳转</span><br><span class="line">        decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">    &#125; else &#123; // 其他</span><br><span class="line">        // 不拦截跳转</span><br><span class="line">        decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="KVO-监听"><a href="#KVO-监听" class="headerlink" title="KVO 监听"></a>KVO 监听</h1><ul><li>监听标题 title</li></ul><p>通过 <code>KeyPath路由</code> 监听 <code>title</code> 可以 动态修改 <code>title</code></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 监听标题</span><br><span class="line">[self.wkWebV zj_addObserver:self forKeyPath:@&quot;title&quot;];</span><br></pre></td></tr></table></figure></div><ul><li>监听进度 <code>estimatedProgress</code></li></ul><p>通过 <code>KeyPath路由</code> 监听  <code>estimatedProgress</code> 可以做 <code>进度条</code></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 添加监听</span><br><span class="line">[self.wkWebV zj_addObserver:self forKeyPath:@&quot;estimatedProgress&quot;];</span><br></pre></td></tr></table></figure></div><ul><li>监听 URL</li></ul><p>通过 <code>KeyPath路由</code> 监听 <code>URL</code>，即在跳转过程中 <code>拦截URL</code>，可以去做一些 动态跳转到 <code>OC</code> 页面</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 监听跳转</span><br><span class="line">[self.wkWebV zj_addObserver:self forKeyPath:@&quot;URL&quot;];</span><br></pre></td></tr></table></figure></div><ul><li>监听的方式代码实现</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -进度的监听</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    NSString * url = self.wkWebV.URL.absoluteString;</span><br><span class="line">    ZJLog(@&quot;url:%@&quot;,url);</span><br><span class="line">    if (object == self.wkWebV &amp;&amp; [keyPath isEqualToString:@&quot;title&quot;]) &#123; // 标题</span><br><span class="line">        if (self.wkWebV.title.length &gt; 0) &#123;</span><br><span class="line">            [self.navStatusV.titleL setTitle:self.wkWebV.title titleColor:kMainTextColor font:16 isBlod:YES];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if (object == self.wkWebV &amp;&amp; [keyPath isEqualToString:@&quot;estimatedProgress&quot;]) &#123; // 进度条</span><br><span class="line">        CGFloat newProgress = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue];</span><br><span class="line">//        ZJLog(@&quot;newProgress:%f&quot;,newProgress);</span><br><span class="line">        if (newProgress &lt;= 0.05f) &#123;</span><br><span class="line">            newProgress = 0.05f;</span><br><span class="line">        &#125;</span><br><span class="line">        [self.progressV changeProgressValue:newProgress];</span><br><span class="line">    &#125;else if (object == self.wkWebV &amp;&amp; [keyPath isEqualToString:@&quot;/cloudApp/customer/service&quot;]) &#123;</span><br><span class="line">        // 跳转到客服中心</span><br><span class="line">        ZJLog(@&quot;跳转到客服中心&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 &lt;code&gt;iOS&lt;/code&gt; 开发中，&lt;code&gt;iOS&lt;/code&gt; 和 &lt;code&gt;JS&lt;/code&gt; 交互是每个程序猿必须掌握</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习15：国际化/多语言适配</title>
    <link href="https://www.bboyzj.cn/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A015%EF%BC%9A%E5%9B%BD%E9%99%85%E5%8C%96-%E5%A4%9A%E8%AF%AD%E8%A8%80%E9%80%82%E9%85%8D/"/>
    <id>https://www.bboyzj.cn/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A015%EF%BC%9A%E5%9B%BD%E9%99%85%E5%8C%96-%E5%A4%9A%E8%AF%AD%E8%A8%80%E9%80%82%E9%85%8D/</id>
    <published>2023-03-14T22:27:39.000Z</published>
    <updated>2023-03-19T00:20:25.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>项目开发中不同语言环境需要进行多语言适配，例如：中文、英语、法语、俄语、葡萄牙语等</p><ul><li>纯代码界面开发时，直接添加本地化语言文件，并针对键值对获取即可</li></ul><p>下面我们来介绍如何国际化：</p><h1 id="全局添加需要适配的多语言"><a href="#全局添加需要适配的多语言" class="headerlink" title="全局添加需要适配的多语言"></a>全局添加需要适配的多语言</h1><p>PROHECT -&gt; Info -&gt; Localizetions 下：选择 + 号添加：</p><blockquote><p>Chinese，Simplified：中文简体<br>Chinese，Traditional：中文繁体<br>English - Development Localization：英语<br>French(fr)：法语<br>Russian：俄语<br>Arabic：阿拉伯语<br>…</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150647485.png"                                     ></p><p>添加完成之后的效果：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172026085.png"                                     ></p><p>细心的朋友会发现如今 <code>English</code> 后面是 <code>1 File Localized</code>，这是因为 <code>英语</code> 是系统默认加入的，并且同一时刻为 <code>Main.storyboard</code> 和 <code>LaunchScreen.storyboard</code> 设置了多语言</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172026300.png"                                     ></p><h1 id="纯代码本地化"><a href="#纯代码本地化" class="headerlink" title="纯代码本地化"></a>纯代码本地化</h1><ol><li>创建本地化文件</li></ol><p>默认文件名为 <code>Localizable</code> ，不要去修改</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172026376.png"                                     ></p><ul><li>点击 Next，Save <code>As：Localizable</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172026092.png"                                     ></p><p><code>Localizable.strings</code> 就是你需要的本地化文化</p><ul><li>关联对应的本地化语言</li></ul><p>点击右侧的 <code>Localizable</code>，关联本地化语言</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172027552.png"                                     ></p><ul><li>勾选需要关联的本地化语言，全部勾选</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172027404.png"                                     ></p><ol start="2"><li>在本地化文件中设置 <code>Key-Value</code></li></ol><blockquote><p>注意：不要忘记行末的 <code>;</code> 号</p></blockquote><p>分别在对应的本地化语言文件中，设置不同的 <code>Key-Value</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172027768.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172027106.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172027605.png"                                     ></p><ol start="3"><li>调用本地化</li></ol><ul><li><p>使用 <code>NSLocalizedString</code> 函数来访问 <code>Localizable.strings</code> 资源文件</p></li><li><p><code>NSLocalizedString</code> 函数第一个参数为对应的 <code>键名</code>，第二个是自定义的说明，给开发或翻译人员看的。</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 调用字符串对应的本地化符号</span><br><span class="line">let title = NSLocalizedString(&quot;title&quot;, comment: &quot;title&quot;)</span><br><span class="line">MyLog(message: title)</span><br></pre></td></tr></table></figure></div><blockquote><p>这种设置完之后仅仅能让应用随系统的语言进行切换，而用户不能手进行切换</p></blockquote><h1 id="图片本地化"><a href="#图片本地化" class="headerlink" title="图片本地化"></a>图片本地化</h1><ol><li>选中需要本地化的图片，同上面一样点击 <code>Localize...</code> ，创建本地化 <code>图片资源文件</code></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172028648.png"                                     ></p><ol start="2"><li>关联你需要本地化的语言</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172028577.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172029322.png"                                     ></p><ol start="3"><li>图片 <code>Show In Finder</code>，可以看到在 中文和英文资源下都有这个图片，把需要替换的图片换掉即可</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172029513.png"                                     ></p><ol start="4"><li>图片使用和平常一样</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let img = UIImage(named: &quot;loading.png&quot;)</span><br></pre></td></tr></table></figure></div><h1 id="App-名称的-本地化"><a href="#App-名称的-本地化" class="headerlink" title="App 名称的 本地化"></a>App 名称的 本地化</h1><ol><li>要实现应用名称根据语言环境显示不一样的名称，只需要创建 <code>InfoPlist.strings</code> 文件，创建 <code>InfoPlist.strings</code> 并关联语言</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172029520.png"                                     ></p><ol start="2"><li>获取info.plist中的key</li></ol><p>点击 <code>Infoplist</code> 右键选择 <code>Open As -&gt; Source Code</code>，查看我们所要获取权限的原始key。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172029052.png"                                     ></p><p>新版Xcode获取不出来数据不用急，去代码中将info打印出来，拿到key效果一样。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let infoPlist = Bundle.main.infoDictionary</span><br><span class="line">MyLog(message: infoPlist)</span><br></pre></td></tr></table></figure></div><ol start="3"><li>本地化文件中，对key-value进行配置</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Chinese,Simplified</span><br><span class="line">&quot;CFBundleDisplayName&quot; = &quot;中图云书房&quot;</span><br><span class="line"></span><br><span class="line">// Englist</span><br><span class="line">&quot;CFBundleDisplayName&quot; = &quot;SRSF&quot;</span><br></pre></td></tr></table></figure></div><ol start="4"><li>运行App，然后切换手机语言为英文，会发现软件名称变成了英文</li></ol><h1 id="Xcode中切换语言"><a href="#Xcode中切换语言" class="headerlink" title="Xcode中切换语言"></a>Xcode中切换语言</h1><p>为了调试国际化，我们除了可以进入 <code>模拟器或真机</code> 切换系统语言，也可以在 <code>Xcode</code> 中配置相关项，使 <code>Debug</code> 环境下运行时预览不同语言和地区 <code>App的界面效果</code></p><ol><li>选择 Product -&gt; Scheme -&gt; Edit Scheme</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172030056.png"                                     ></p><ol start="2"><li>切换语言后，运行工程</li></ol><h1 id="应用内切换语言"><a href="#应用内切换语言" class="headerlink" title="应用内切换语言"></a>应用内切换语言</h1><p>纯代码本地化只能跟随系统进行切换，并不能手动进行切换，下面先介绍一下相关宏</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 尾随系统切换, 多语言文件名称必须是Localizable</span><br><span class="line">NSLocalizedString(&quot;title&quot;, nil);</span><br><span class="line"></span><br><span class="line">// 以下三个都能够手动设置多语言</span><br><span class="line">// 第一个參数:是多语言中的key</span><br><span class="line">// 第二个參数:是多语言文件的名字</span><br><span class="line">// 第三个參数:是对key的自定义的说明,一般传nil</span><br><span class="line">NSLocalizedStringFromTable(@&quot;title&quot;, @&quot;Localizable&quot;, nil);</span><br><span class="line">// 指定多语言文件名称和bundle</span><br><span class="line">NSLocalizedStringFromTableInBundle(@&quot;title&quot;, @&quot;Localizable&quot;, bundle, nil);</span><br><span class="line">// 在上面的基础上添加一个默认值的參数</span><br><span class="line">NSLocalizedStringWithDefaultValue(@&quot;title&quot;, @&quot;Localizable&quot;, bundle, @&quot;label&quot;, nil);</span><br></pre></td></tr></table></figure></div><ol><li>Resources -&gt; Show In Finder后，发现每一种语言都有对应的文件目录，后缀是 <code>.lproj</code></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172031421.png"                                     ></p><blockquote><p>总结：<br>1、因此 <code>ar.lproj、en.lproj、fr.lproj、ru.lproj、zh-Hans.lproj、zh-Hant.lproj</code> 为我们可以从本地获取到的 <code>语言资源文件</code><br>2、在 <code>App</code> 内切换语言的时候，实际上就是获取 <code>语言资源文件</code> 的 <code>Localizable.strings</code> 文件</p></blockquote><ol start="2"><li>将所有的 <code>语言文件</code> 设置成 <code>字符串类型的枚举</code> 并且有初始值 <code>rawValue</code>， 获取 <code>Localizable.strings</code></li></ol><ul><li>获取 <code>某语言</code> 文件的 <code>value值</code>，相应的想要切换语言的话，直接切换 <code>pathForResource</code> 面的 <code>参数</code> 就可以</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 本地化语言类型</span><br><span class="line">enum LocalizedType: String &#123;</span><br><span class="line">    // 字符串需要对应本地的国际化文件名 .lproj</span><br><span class="line">    case English = &quot;en&quot; // 英语</span><br><span class="line">    case ChineseHans = &quot;zh-Hans&quot; // 简体中文</span><br><span class="line">    case ChineseHant = &quot;zh-Hant&quot; // 繁体中文</span><br><span class="line">    case Russian = &quot;ru&quot; // 俄语</span><br><span class="line">    case Frcench = &quot;fr&quot; // 法语</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取语言文件路径(可以为：en/zh-Hans/zh-Hant/fr/ru 任意一个)</span><br><span class="line">let languageBundlePath = Bundle.main.path(forResource: LocalizedType.English, ofType: &quot;lproj&quot;)</span><br><span class="line">// 获取语言文件路径下对应 key 的 value</span><br><span class="line">let value = Bundle(path: languageBundlePath ?? &quot;&quot;)?.localizedString(forKey: &quot;title&quot;, value: nil, table: &quot;ZJLocalizable&quot;)</span><br><span class="line">MyLog(message: value) </span><br></pre></td></tr></table></figure></div><ol start="3"><li>根据上面的思路，我们可以用 <code>NSUserDefaults</code> 缓存当前的 <code>语言</code>，以便 <code>第一次启动程序</code> 或 <code>程序退出去后</code>，下次进入继续使用上次关闭程序的语言。</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 本地化语言类型</span><br><span class="line">enum LocalizedType: String &#123;</span><br><span class="line">    // 字符串需要对应本地的国际化文件名 .lproj</span><br><span class="line">    case English = &quot;en&quot; // 英语</span><br><span class="line">    case ChineseHans = &quot;zh-Hans&quot; // 简体中文</span><br><span class="line">    case ChineseHant = &quot;zh-Hant&quot; // 繁体中文</span><br><span class="line">    case Russian = &quot;ru&quot; // 俄语</span><br><span class="line">    case Frcench = &quot;fr&quot; // 法语</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化启动时语言</span><br><span class="line">func initLaunchLanguage() &#123;</span><br><span class="line">    // 获取上一次设置的语言</span><br><span class="line">    var languageType = kUserDefault.getInfo(key: &quot;appLanguage&quot;)</span><br><span class="line">    // 如果是第一次启动</span><br><span class="line">    if languageType == nil &#123;</span><br><span class="line">        // 获取系统第一个首选语言</span><br><span class="line">        let systemLanguage = Locale.preferredLanguages.first!</span><br><span class="line">        MyLog(message: systemLanguage)</span><br><span class="line">        if systemLanguage.hasPrefix(LocalizedType.English.rawValue) &#123;</span><br><span class="line">            // 英文</span><br><span class="line">            languageType = LocalizedType.English.rawValue</span><br><span class="line">        &#125;else if systemLanguage.hasPrefix(LocalizedType.ChineseHans.rawValue) &#123;</span><br><span class="line">            // 简体中文</span><br><span class="line">            languageType = LocalizedType.ChineseHans.rawValue</span><br><span class="line">        &#125;else if systemLanguage.hasPrefix(LocalizedType.ChineseHant.rawValue) &#123;</span><br><span class="line">            // 繁体中文</span><br><span class="line">            languageType = LocalizedType.ChineseHant.rawValue</span><br><span class="line">        &#125;else if systemLanguage.hasPrefix(LocalizedType.Frcench.rawValue) &#123;</span><br><span class="line">            // 法文</span><br><span class="line">            languageType = LocalizedType.Frcench.rawValue</span><br><span class="line">        &#125;else if systemLanguage.hasPrefix(LocalizedType.Russian.rawValue) &#123;</span><br><span class="line">            // 俄文</span><br><span class="line">            languageType = LocalizedType.Russian.rawValue</span><br><span class="line">        &#125;</span><br><span class="line">        // 赋值给上一次设置的语言类型</span><br><span class="line">        languageType = systemLanguage</span><br><span class="line">    &#125;</span><br><span class="line">    // 缓存语言</span><br><span class="line">    kUserDefault.saveInfo(value: languageType!, key: &quot;appLanguage&quot;)</span><br><span class="line">    // 设置bundle</span><br><span class="line">    setCurrentBundle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>注：<br>每次设置完语言，我们跟要更新一下 <code>bundle</code>，以便随时获取 <code>key-value</code></p></blockquote><ol start="3"><li>接下来，我们要根据缓存的语言来获取本地语言资源文件，赋值给一个全局的 <code>bundle</code>，以便随时可以通过 <code>bundle</code> 来拿到具体语言文件下的 <code>key-value</code></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 设置bundle</span><br><span class="line">func setCurrentBundle() &#123;</span><br><span class="line">    // 拿到当前语言</span><br><span class="line">    let currentLanguageType = kUserDefault.getInfo(key: &quot;appLanguage&quot;) as! String</span><br><span class="line">    // 获取本地语言资源路径</span><br><span class="line">    let languageBundlePath = Bundle.main.path(forResource: currentLanguageType, ofType: &quot;lproj&quot;)</span><br><span class="line">//        MyLog(message: languageBundlePath)</span><br><span class="line">    guard languageBundlePath != nil else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取 bundle</span><br><span class="line">    let languageBundle = Bundle(path: languageBundlePath!)</span><br><span class="line">    guard languageBundle != nil else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // 赋值给全局的 bundle</span><br><span class="line">    currentBundle = languageBundle</span><br><span class="line">//        MyLog(message: currentBundle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="4"><li>根据 <code>key</code> 获取 <code>value</code></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取要显示的文本</span><br><span class="line">func getLanguageValueWithKey(key: String) -&gt; String &#123;</span><br><span class="line">    let bundle = LocalizableManager.sharedManager.currentBundle</span><br><span class="line">    let value = bundle?.localizedString(forKey: key, value: nil, table: nil)</span><br><span class="line">    return value ?? &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="5"><li>至此，我们的 <code>App内+系统</code> 切换国际化语言，大功告成！！！</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;项目开发中不同语言环境需要进行多语言适配，例如：中文、英语、法语、俄语、葡萄牙语等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;纯代码界面开发时，直接添加本地</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Blog-06：阿里云图床</title>
    <link href="https://www.bboyzj.cn/2023/03/15/Blog%E6%90%AD%E5%BB%BA/Blog-06%EF%BC%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9B%BE%E5%BA%8A/"/>
    <id>https://www.bboyzj.cn/2023/03/15/Blog%E6%90%AD%E5%BB%BA/Blog-06%EF%BC%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9B%BE%E5%BA%8A/</id>
    <published>2023-03-14T21:11:50.000Z</published>
    <updated>2023-03-14T22:11:14.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近Gitee突然加了防盗链，导致基于Gitee的图床直接GG了！好家伙还带这样玩的，数据要是没有备份真的心惊胆跳的，不白嫖了，直接付费转战阿里云OSS去。</p><p>​分享一下搭建过程:<br>​</p><h1 id="阿里云OSS开通及配置"><a href="#阿里云OSS开通及配置" class="headerlink" title="阿里云OSS开通及配置"></a>阿里云OSS开通及配置</h1><p>​<br>​1、开通及购买服务包<br>​<br>​登录 <a class="link"   href="https://www.aliyun.com/?utm_content=se_1013083955" >阿里云官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，开通对象存储OSS，开通对象存储OSS不用扣费，只有使用OSS才需要扣费。<br>​​<br>​​<br>​​<img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150611729.png"                                     ></p><p>2、OSS有两种扣费方式（产品计费详细介绍）：</p><ul><li><p><a class="link"   href="https://help.aliyun.com/document_detail/450471.html" >按量付费 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p><a class="link"   href="https://help.aliyun.com/document_detail/48291.html" >资源包 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li></ul><p>根据需要按需购买对应的 <code>资源包</code> 即可，作为一个只是搭建个人向图床的我，只需要购买一个 <code>40GB</code> 的《标准(LRS)存储包》即可，半年只要4.98，四舍五入相当于白嫖……</p><p>我每个月也用不了多少流量，《下行流量包》先暂时不购买，要是后续那天顶不住后再考虑购买即可。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610052.png"                                     ></p><ul><li>根据需求选择 <code>购买时长</code>，最后支付</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610166.png"                                     ></p><blockquote><p>注意事项：<br>记得给阿里云账户充值！！！别到时候欠费停用了</p></blockquote><p>3、基础配置</p><ul><li>创建 Bucket</li></ul><p>打开 <a class="link"   href="https://oss.console.aliyun.com/bucket" >OSS管理控制台Bucket页面 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，按需创建一个Bucket。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610062.png"                                     ></p><blockquote><p>Bucket 名称：bboy-blog（自定义）<br>地域：华北2（选择最近）<br>存储类型：标准存储<br>读写权限：公共读<br>其他：默认不改动</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610598.png"                                     ></p><p>创建完成你的 <code>Bucket</code> 就在列表显示了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610981.png"                                     ></p><ul><li>找到你的地域节点</li></ul><p>点击你的 <code>bucket</code>，然后点击 <code>bucket</code> 下的 <code>概览</code>，在 <code>访问域名</code> 一栏找你的 <code>地域节点</code>，后面会用到</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150609099.png"                                     ></p><ul><li>找到你的 key</li></ul><p>右上角找到头像，在弹出框里选择 <code>AccessKey</code> 管理，在弹出框选择 <code>继续使用</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150609401.png"                                     ></p><p>进入后，创建一个新的 <code>AccessKey</code>，在弹出框里，复制你的 <code>AccessKeyId和AccessKeySecret</code>，保存好，以便后续使用</p><h1 id="配置-picgo"><a href="#配置-picgo" class="headerlink" title="配置 picgo"></a>配置 picgo</h1><p>1、打开picgo，在图床设置里选择 <code>阿里云OSS</code>，一招以下步骤填写信息</p><blockquote><p>设定Keyld：必填，填写刚刚获得的AccessKeyID<br>设定KeySecret：必填，填写AccessKeyIDSecret<br>设定Bucket：必填 bboy-blog，填写bucket名称（这里填写的是bucket名称，不是浏览器里的域名）<br>确认存储区域：必填 oss-cn-beijing，填写你的地域节点，注意复制的格式<br>设定存储路径：选填，其实就是自定义一个文件夹的名字，以&#x2F;结尾，它会自动在你的bucket里面创建一个文件夹，并把图片上传进去<br>指定自定义域名：选填</p></blockquote><p>2、配置完成之后，<code>确定</code>，并点击 <code>设置为默认图床</code></p><p>3、PicGo设置</p><p>打开 <code>时间戳重命名</code> 和 <code>上传后自动赋值URL</code> 选项</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150608665.png"                                     ></p><p>4、至此，你已经配置成功了，可以随意用 <code>PicGo</code> 上传图片了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近Gitee突然加了防盗链，导致基于Gitee的图床直接GG了！好家伙还带这样玩的，数据要是没有备份真的心惊胆跳的，不白嫖了，直接付费转战</summary>
      
    
    
    
    <category term="Blog" scheme="https://www.bboyzj.cn/categories/Blog/"/>
    
    
    <category term="博客搭建" scheme="https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习01：自定义Log</title>
    <link href="https://www.bboyzj.cn/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A001%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89Log/"/>
    <id>https://www.bboyzj.cn/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A001%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89Log/</id>
    <published>2023-03-14T20:26:24.000Z</published>
    <updated>2023-03-18T23:58:36.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打印文件名、方法、行数"><a href="#打印文件名、方法、行数" class="headerlink" title="打印文件名、方法、行数"></a>打印文件名、方法、行数</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1.获取打印所在的文件</span><br><span class="line">let file = (#file as NSString).lastPathComponent;</span><br><span class="line">print(file);</span><br><span class="line"></span><br><span class="line">// 2.获取打印所在的方法</span><br><span class="line">let function = #function</span><br><span class="line">print(function);</span><br><span class="line"></span><br><span class="line">// 3.获取打印所在的行号</span><br><span class="line">let line = #line;</span><br><span class="line">print(line)</span><br></pre></td></tr></table></figure></div><h1 id="全局化"><a href="#全局化" class="headerlink" title="全局化"></a>全局化</h1><p><code>swift</code> 中的 全局函数：写在单独的一个 <code>.swift</code> 文件下即可，比如：Common.swift</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func ZNLog&lt;T&gt;(message:T, file:String = #file, funcName:String = #function, lineNum:Int = #line) &#123;</span><br><span class="line"></span><br><span class="line">     let fileName = (file as NSString).lastPathComponent;</span><br><span class="line"></span><br><span class="line">     print(&quot;[文件名:\(fileName)]:[函数名:\(funcName)]:[行数:\(lineNum)]-打印内容:\n\(message)&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="配置DeBug下打印，Release-下不打印"><a href="#配置DeBug下打印，Release-下不打印" class="headerlink" title="配置DeBug下打印，Release 下不打印"></a>配置DeBug下打印，Release 下不打印</h1><ul><li><code>Swift</code> 没有宏定义，只能通过添加配置字段，<code>Build Settings -&gt; Other Swift Flags</code> 下添加 <code>-D DEBUG</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303190758719.png"                                     ></p><h1 id="最终写法"><a href="#最终写法" class="headerlink" title="最终写法"></a>最终写法</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 自定义Log</span><br><span class="line">func MyLog&lt;T&gt;(message: T,file: String = #file, funcName: String = #function, lineNum: Int = #line) &#123;</span><br><span class="line">#if DEBUG</span><br><span class="line">    let fileName = (file as NSString).lastPathComponent</span><br><span class="line">    print(&quot;[文件名:\(fileName)]:[函数名:\(funcName)]:[行数:\(lineNum)]-打印内容:\n\(message)&quot;);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;打印文件名、方法、行数&quot;&gt;&lt;a href=&quot;#打印文件名、方法、行数&quot; class=&quot;headerlink&quot; title=&quot;打印文件名、方法、行数&quot;&gt;&lt;/a&gt;打印文件名、方法、行数&lt;/h1&gt;&lt;div class=&quot;highlight-container&quot; data</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习49：Any</title>
    <link href="https://www.bboyzj.cn/2023/03/14/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A049%EF%BC%9AAny/"/>
    <id>https://www.bboyzj.cn/2023/03/14/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A049%EF%BC%9AAny/</id>
    <published>2023-03-13T22:34:03.000Z</published>
    <updated>2023-03-13T22:49:03.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Swift中，Objective-C中的 <code>id</code> 类型现在映射成了Swift中的 <code>Any</code> 类型，它可以代表任何类型的值，无论是类、枚举、结构体还是任何其他Swift类型。这种变化使得Swift中的Objective-C API更加灵活，因为Swift定义的值类型可以传递给Objective-C API并作为Swift中的类型获取，从而无需手动“框选”类型（本人理解为转换、解包）。</p><h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><p>对于Swift中哈希类的集合，例如Dictionary和Set，有一个新类型 <code>AnyHashable</code>，可以保存任何遵守Swift中 <code>Hashable</code> 协议的类型的值。。<code>Array</code> 对应 <code>Any</code> </p><h1 id="非集合类型"><a href="#非集合类型" class="headerlink" title="非集合类型"></a>非集合类型</h1><ul><li><p>属性列表，JSON和用户信息字典在Cocoa框架中很常见，Cocoa框架将这些表示为非类型化集合。</p></li><li><p>Swift可以导入 <code>Cocoa API</code> 接受 <code>Any或AnyHashable</code> 类型的集合，所以我们可以用[AnyHashable：Any]</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Swift 3</span><br><span class="line">struct State &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var abbreviation: String</span><br><span class="line">    var population: Int</span><br><span class="line"></span><br><span class="line">    // Change the dictionary type to [AnyHashable: Any] here...</span><br><span class="line">    var asPropertyList: [AnyHashable: Any] &#123;</span><br><span class="line">        var result: [AnyHashable: Any] = [:]</span><br><span class="line">        // No implicit conversions necessary, since String and Int are subtypes</span><br><span class="line">        // of Any and AnyHashable</span><br><span class="line">        result[&quot;name&quot;] = self.name</span><br><span class="line">        result[&quot;abbreviation&quot;] = self.abbreviation</span><br><span class="line">        result[&quot;population&quot;] = self.population</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let california = State(name: &quot;California&quot;,</span><br><span class="line">                       abbreviation: &quot;CA&quot;,</span><br><span class="line">                       population: 39_000_000)</span><br><span class="line">// ...and you can still use it with Cocoa API here</span><br><span class="line">Notification(name: &quot;foo&quot;, object: nil,</span><br><span class="line">             userInfo: california.asPropertyList)</span><br></pre></td></tr></table></figure></div><h1 id="未链接上下文的显式转换"><a href="#未链接上下文的显式转换" class="headerlink" title="未链接上下文的显式转换"></a>未链接上下文的显式转换</h1><p>在某些确定的情况下，Swift不能自动桥接C和Objective-C。 例如，一些C和Cocoa API使用id *指针作为“out”或“in-out”参数，并且由于Swift不能静态地确定指针的使用方式，因此它不能对内存中的值自动执行桥接转换 。 在这种情况下，指针仍将显示为UnsafePointer <AnyObject>。 如果您需要使用到这些不能自动桥接转换的API，您可以使用显式桥接转换，在代码中使用 <code>as Type</code> 或 <code>as AnyObject</code> 显式转换。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ObjC</span><br><span class="line">@interface Foo</span><br><span class="line">- (void)updateString:(NSString **)string;</span><br><span class="line">- (void)updateObject:(id *)obj;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Swift</span><br><span class="line">func interactWith(foo: Foo) -&gt; (String, Any) &#123;</span><br><span class="line">    var string = &quot;string&quot; as NSString // explicit conversion</span><br><span class="line">    foo.updateString(&amp;string) // parameter imports as UnsafeMutablePointer&lt;NSString&gt;</span><br><span class="line">    let finishedString = string as String</span><br><span class="line"></span><br><span class="line">    var object = &quot;string&quot; as AnyObject</span><br><span class="line">    foo.updateObject(&amp;object) // parameter imports as UnsafeMutablePointer&lt;AnyObject&gt;</span><br><span class="line">    let finishedObject = object as Any</span><br><span class="line"></span><br><span class="line">    return (finishedString, finishedObject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>另外，Objective-C中的协议在Swift中仍然是类约束（及只有类才可以遵守协议），所以你不能让Swift中的结构体或枚举直接遵守Objective-C中的协议或者是使用轻量级的泛型类。 当您需要使用到这些协议和API时应该像这样 <code>String as NSString</code>、<code>Array as NSArray</code> 进行显式转换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在Swift中，Objective-C中的 &lt;code&gt;id&lt;/code&gt; 类型现在映射成了Swift中的 &lt;code&gt;Any&lt;/code&gt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习48：ARC</title>
    <link href="https://www.bboyzj.cn/2023/03/13/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A048%EF%BC%9AARC/"/>
    <id>https://www.bboyzj.cn/2023/03/13/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A048%EF%BC%9AARC/</id>
    <published>2023-03-13T09:44:18.000Z</published>
    <updated>2023-03-13T22:34:49.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h1><ul><li><p>swift 使用 <code>自动引用计数（ARC）</code> 来跟踪并管理应用使用的 <code>内存</code>。</p></li><li><p><code>引用计数</code> 只应用在 <code>类</code> 的实例。</p></li><li><p><code>结构体和枚举</code> 都是 <code>值类型</code>，并非引用类型，不是以引用的方式来 <code>存储和传递</code> 的</p></li></ul><h1 id="ARC-如何工作"><a href="#ARC-如何工作" class="headerlink" title="ARC 如何工作"></a>ARC 如何工作</h1><ul><li><p>每次创建一个类的实例，<code>ARC</code> 就会分配一个内存块，用来存储这个实例的相关信息。这个内存块保存着实例的类型，以及这个实例相关的属性的值</p></li><li><p>当实例不再被使用时，ARC 是否这个实例使用的内存，使这块内存可做它用。保证了实例不再被使用时，不会占用内存空间</p></li><li><p>但是，如果 <code>ARC</code> 释放了仍在使用的实例，那么你就不能再访问这个实例的苏醒或者调用它的方法。如果你仍然视图访问这个实例，应用极有可能会崩溃</p></li><li><p>为了保证不会发生上述的情况， <code>ARC</code> 跟踪类实例的相关属性、常量及变量的数量。只要有一个有效的引用，<code>ARC</code> 都不会释放这个实例</p></li><li><p>为了让这个变成现实，只要你将一个类的实例赋值给一个属性或常量或变量，这个属性、常量、变量就是这个实例的 <code>强引用（strong reference）</code>。之所以称之为 <code>强引用</code>，是因为它持有这实例，并且只要这个强引用还存在，就不能销毁实例</p></li></ul><h1 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h1><ul><li><p>在两个类实例彼此保持对方的强应用，使得每个实例都使对方保持有效时会发生这种情况。我们称之为强引用环</p></li><li><p>通过用 <code>弱引用或者无主引用</code> 来 <code>取代强引用</code>，我们可以 <code>解决强引用环问题</code></p></li></ul><h1 id="解决循环引用"><a href="#解决循环引用" class="headerlink" title="解决循环引用"></a>解决循环引用</h1><ul><li><p><code>弱引用和无主引用</code> 允许引用环中的一个实例引用另外一个实例，但 <code>不是强引用</code>。因此实例可以互相引用但是不会产生强引用</p><ul><li><p><code>弱引用不会增加实例的引用计数</code>，因此不会阻止ARC销毁被引用的实例。这种特性使得引用不会编程强引用环。声明属性或者变量的时候，关键字 <code>weak</code> 表明引用为弱引用。</p></li><li><p><code>弱引用只能声明为变量类型</code>，因为运行时它的值可能会变。弱引用绝对不能声明为常量</p></li><li><p>因为弱引用可以没有值，所以声明弱引用的时候 <code>必须是可选类型</code> 的。在swift语言中，推荐使用可选类型作为可能没有值的引用类型</p></li></ul></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person: Person?</span><br><span class="line"></span><br><span class="line">weak var student: Student?    </span><br></pre></td></tr></table></figure></div><ul><li><p>对于生命周期中引用会变nil的实例，使用弱引用；对于初始化时赋值之后引用再也不会赋值为nil的实例，使用无主引用</p><ul><li><p>和弱引用相似，<code>无主引用</code> 也不强持有实例。但是和弱引用不同的是，<code>无主引用默认始终有值</code>。因此，无主引用只能定义为非可选类型。在属性、变量前添加 <code>unowned</code> 关键字，可以声明一个无主引用</p></li><li><p>因为是 <code>可选类型</code>，因此当使用无主引用时，不需要展开，可直接访问。不过非可选类型变量不能赋值为 <code>nil</code>，因此当实例被销毁的时候，ARC无法将引用赋值为 <code>nil</code></p></li><li><p>当实例被销毁后，试图访问该实例的无主引用会触发运行时错误。使用无主引用时请确保引用始终指向一个未销毁的实例</p></li></ul></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class City &#123;</span><br><span class="line">    // 无主引用</span><br><span class="line">    unowned let country: Country</span><br><span class="line">    init(country: Country) &#123;</span><br><span class="line">        self.country = country</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Country &#123;</span><br><span class="line">    var capitaCity: City!</span><br><span class="line">    init(capitaCity: City) &#123;</span><br><span class="line">        self.capitaCity = capitaCity</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="闭包引用循环"><a href="#闭包引用循环" class="headerlink" title="闭包引用循环"></a>闭包引用循环</h1><p>将一个闭包赋值给类实例的某个属性，并且这个闭包使用了实例，这样也会产生强引用环。这个闭包可能反问了实例的某个属性，如果 <code>self.someProperty</code>，或者调用了实例的某个方法 <code>self.someMethod</code>。这两种情况都导致了闭包使用 <code>self</code>，从而产生了循环引用</p><p>解决：</p><ul><li><p>定义占有列表-占有列表中的每个元素都是由 <code>weak</code> 或者 <code>unowend</code> 关键字和实例的引用（如 <code>self</code> 或 <code>someInstance</code>）组成。每一对都在括号中，通过逗号分开</p></li><li><p>当闭包和占有的实例总是互相引用时并且总是同时销毁时，将闭包内的占有定义为无主引用</p></li><li><p>相反的，当占有引用有时可能会是 <code>nil</code> 时，将闭包内的占有定义为 弱引用</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lazy var someClosure = &#123;</span><br><span class="line">    [unowned self, weak delete = self.delete]</span><br><span class="line">    (index: Int,stringToProcess: String) -&gt; String in</span><br><span class="line">    </span><br><span class="line">    // closure body goes here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ARC&quot;&gt;&lt;a href=&quot;#ARC&quot; class=&quot;headerlink&quot; title=&quot;ARC&quot;&gt;&lt;/a&gt;ARC&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;swift 使用 &lt;code&gt;自动引用计数（ARC）&lt;/code&gt; 来跟踪并管理应用使用的 &lt;code&gt;内存&lt;/c</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习47:多线程</title>
    <link href="https://www.bboyzj.cn/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A047%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://www.bboyzj.cn/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A047%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-03-12T14:52:33.000Z</published>
    <updated>2023-03-13T09:40:14.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为什么几乎所有的GUI框架都是单线程的？：处理问题代价大于收益</p><h1 id="多线程可以做什么"><a href="#多线程可以做什么" class="headerlink" title="多线程可以做什么"></a>多线程可以做什么</h1><ul><li>网络请求</li><li>IO：读写文件</li><li>计算</li><li>数据模型转换</li><li>….</li></ul><h1 id="多线程编程的方式"><a href="#多线程编程的方式" class="headerlink" title="多线程编程的方式"></a>多线程编程的方式</h1><ul><li>Thread</li><li>Operation 和 OperationQueue</li><li>GCD</li></ul><h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><ul><li>三种中最轻量级的，自己管理线程的生命周期和线程同步</li><li>线程同步对数据加锁有一定的系统开销</li></ul><p>1、快捷方式创建</p><ul><li>detachNewThread(_ block: @escaping @Sendable () -&gt; Void)</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">// 不希望程代码在主线完成后退出，因为很多线程需要异步操作</span><br><span class="line">PlaygroundPage.current.needsIndefiniteExecution = true</span><br><span class="line"></span><br><span class="line">for i in 0...10 &#123;</span><br><span class="line">    Thread.detachNewThread &#123;</span><br><span class="line">        print(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>detachNewThreadSelector(_ selector: Selector, toTarget target: Any, with argument: Any?)</li></ul><p>2、初始化器</p><ul><li>Thread(target:  selector: , object: )</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">// 不希望程代码在主线完成后退出，因为很多线程需要异步操作</span><br><span class="line">PlaygroundPage.current.needsIndefiniteExecution = true</span><br><span class="line"></span><br><span class="line">class ObjectThread &#123;</span><br><span class="line">    func threadTest() &#123;</span><br><span class="line">        let thread = Thread(target: self, selector: #selector(threadMethod), object: nil)</span><br><span class="line">        // 手动开启</span><br><span class="line">        thread.start()</span><br><span class="line">    &#125;</span><br><span class="line">    @objc func threadMethod() &#123;</span><br><span class="line">        print(&quot;threadMethod&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 实例</span><br><span class="line">let obj = ObjectThread()</span><br><span class="line">obj.threadTest()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="Operation-和-OperationQueue-概述"><a href="#Operation-和-OperationQueue-概述" class="headerlink" title="Operation 和 OperationQueue 概述"></a>Operation 和 OperationQueue 概述</h1><ul><li>面向对象</li><li>Operation + OperationQueue</li><li>取消、依赖、任务优先级、复杂逻辑、保存业务状态、子类化</li></ul><h1 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h1><ul><li>Operation：抽象类，任务</li><li>BlockOperation</li></ul><p>1、状态：</p><ul><li>isReady：准备好了，可以执行了</li><li>isExecuting：执行中</li><li>isFinished：执行完成</li><li>isCancelled：取消执行</li></ul><p>2、同步、异步</p><ul><li>sync</li><li>async</li></ul><p>3、添加依赖</p><h1 id="OperationQueue"><a href="#OperationQueue" class="headerlink" title="OperationQueue"></a>OperationQueue</h1><ul><li><code>OperationQueue</code> 队列，可以加入很多 <code>Operation</code>，</li><li>底层使用 <code>GCD</code></li><li><code>maxConcurrentOperationCount</code>：可以设置最大并发数</li><li><code>defaultMaxConcurrentOperationCount</code>：根据当前系统条件动态确定的最大并发数，建议使用这个</li><li>可以取消所有的 <code>Operation</code>，但是当前正在执行的不会取消</li><li>所有 <code>Operation</code> 执行完毕后退出销毁</li></ul><h1 id="BlockOperation"><a href="#BlockOperation" class="headerlink" title="BlockOperation"></a>BlockOperation</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ObjectOperation &#123;</span><br><span class="line">    func test() &#123;</span><br><span class="line">        let operation = BlockOperation&#123; [weak self] in</span><br><span class="line">            self?.threadMethod()</span><br><span class="line">        &#125;</span><br><span class="line">        let queue = OperationQueue()</span><br><span class="line">        queue.addOperation(operation)</span><br><span class="line">    &#125;</span><br><span class="line">    @objc func threadMethod() &#123;</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;threadMethod&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let op = ObjectOperation()</span><br><span class="line">op.test()</span><br><span class="line">print(&quot;after invoke test&quot;)</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">after invoke test</span><br><span class="line">threadMethod</span><br></pre></td></tr></table></figure></div><p>由打印结果可知，异步执行了</p><h1 id="继承-Operation"><a href="#继承-Operation" class="headerlink" title="继承 Operation"></a>继承 Operation</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class ObjectOperation &#123;</span><br><span class="line">    func test() &#123;</span><br><span class="line">        let operation = MyOpetation()</span><br><span class="line">        let queue = OperationQueue()</span><br><span class="line">        queue.addOperation(operation)</span><br><span class="line">    &#125;</span><br><span class="line">    @objc func threadMethod() &#123;</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;threadMethod&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyOpetation: Operation &#123;</span><br><span class="line">    override func main() &#123;</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;myOperation main&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let op = ObjectOperation()</span><br><span class="line">op.test()</span><br><span class="line">print(&quot;after invoke test&quot;)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">after invoke test</span><br><span class="line">myOperation main</span><br></pre></td></tr></table></figure></div><h1 id="Operation-完成的回调"><a href="#Operation-完成的回调" class="headerlink" title="Operation 完成的回调"></a>Operation 完成的回调</h1><ul><li>completionBlock</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">operation.completionBlock = &#123; () -&gt; Void in</span><br><span class="line">    print(&quot;completionBlock&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">after invoke test</span><br><span class="line">myOperation main</span><br><span class="line">completionBlock</span><br></pre></td></tr></table></figure></div><h1 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h1><ul><li>任务 + 队列</li><li>易用</li><li>效率</li><li>性能</li></ul><h1 id="GCD功能"><a href="#GCD功能" class="headerlink" title="GCD功能"></a>GCD功能</h1><ul><li>创建管理Queue</li><li>提交Job</li><li>Dispatch Group</li><li>管理Dispatch Object</li><li>信号量Semaphore</li><li>队里屏障Barrier</li><li>Dispatch Source</li><li>Queue Context数据</li><li>Dispatch I&#x2F;O Channel</li><li>Dispatch Data 对象</li></ul><h1 id="GCD队列"><a href="#GCD队列" class="headerlink" title="GCD队列"></a>GCD队列</h1><ul><li>主队列：任务在主线程执行</li><li>并行队列：任务会以先进先出的顺序入列和出列，但是因为多个任务可以并行执行，所以顺序是不一定的</li><li>串行队列：任务会以先进先出的顺序入列和出列，但是同一时刻只会执行一个任务</li></ul><h1 id="GCD-队列API"><a href="#GCD-队列API" class="headerlink" title="GCD-队列API"></a>GCD-队列API</h1><ul><li>Dispatch.main</li><li>Dispatch.global</li><li>DispatchQueue</li><li>queue.label</li><li>setTarget</li></ul><h1 id="GCD-基本操作"><a href="#GCD-基本操作" class="headerlink" title="GCD 基本操作"></a>GCD 基本操作</h1><ul><li>sync</li></ul><p>提交任务到当前队列里，并且直接任务执行完成，当前队列才会返回</p><ul><li>async</li></ul><p>调用一个任务去立即执行，但是不用等任务执行完当前队列就会返回</p><ul><li>asyncAfter</li></ul><p>调度一个任务多久之后去执行，但是不用等任务执行完当前队列就会返回</p><h1 id="GCD-串行-amp-并行"><a href="#GCD-串行-amp-并行" class="headerlink" title="GCD 串行 &amp; 并行"></a>GCD 串行 &amp; 并行</h1><ul><li>串行和并行描述的是任务之间如何运行</li><li>串行任务每一个仅执行一个</li><li>并行任务可以多个同时执行</li></ul><h1 id="GCD-同步-amp-异步"><a href="#GCD-同步-amp-异步" class="headerlink" title="GCD 同步 &amp; 异步"></a>GCD 同步 &amp; 异步</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303131515216.png"                                     > </p><h1 id="GCD-使用"><a href="#GCD-使用" class="headerlink" title="GCD 使用"></a>GCD 使用</h1><ul><li>同步</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let queue = DispatchQueue(label: &quot;myQueue&quot;,qos: DispatchQoS.default,attributes: DispatchQueue.Attributes.concurrent,autoreleaseFrequency: DispatchQueue.AutoreleaseFrequency.inherit,target: nil)</span><br><span class="line">queue.sync &#123; // 同步</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;in queue sync&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;after invoke queue method&quot;)</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">in queue sync</span><br><span class="line">after invoke queue method</span><br></pre></td></tr></table></figure></div><ul><li>异步</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">queue.async &#123; // 异步</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;in queue async&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;after invoke queue method&quot;)</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">after invoke queue method</span><br><span class="line">in queue async</span><br></pre></td></tr></table></figure></div><ul><li>asyncAfter</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">queue.asyncAfter(deadline: .now() + 1) &#123;</span><br><span class="line">    print(&quot;in asyncAfter&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;after invoke queue method&quot;)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">after invoke queue method</span><br><span class="line">in asyncAfter</span><br></pre></td></tr></table></figure></div><h1 id="GCD-源码剖析"><a href="#GCD-源码剖析" class="headerlink" title="GCD 源码剖析"></a>GCD 源码剖析</h1><ul><li><p>dispatch_sync</p><ul><li><p>线程A在串行队里dq中执行task1的过程中，如果再向dq中投递串行任务task2，同时还要求必须阻塞当前线程，等待task2结束(sync投递task2)，那么这时候会发生死锁</p></li><li><p>因为这时候task1还没有结束，串行队列不会去执行task2，而我们又要在当前线程等待task2的结束才肯继续执行task1，即task1在等待task2，而task2也在等待task1，循环等待，形成死锁</p></li></ul></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 串行队列</span><br><span class="line">let queue = DispatchQueue(label: &quot;label&quot;)</span><br><span class="line">queue.async &#123; // 异步</span><br><span class="line">    print(&quot;in queue async&quot;) // 串行队列执行task1</span><br><span class="line">    queue.sync &#123;</span><br><span class="line">        print(&quot;in queue sync&quot;) // 串行队列加入task2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 死锁</span><br></pre></td></tr></table></figure></div><h1 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h1><p>一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码</p><h1 id="竟态条件"><a href="#竟态条件" class="headerlink" title="竟态条件"></a>竟态条件</h1><ul><li>两个或多个线程读写某些数据，而最后的结果取决于线程运行的精确时序</li></ul><h1 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303131739456.png"                                     ></p><h1 id="SpinLock"><a href="#SpinLock" class="headerlink" title="SpinLock"></a>SpinLock</h1><ul><li><p>线程通过busy-wait-loop方式来获取锁，任何时刻只有一个线程能够获取锁，其他线程忙等待知道获取锁</p></li><li><p>临界区尽量简短，控制在100行代码以内，不要有限时或隐士的系统调用，调用的函数也尽量简短</p></li><li><p>保证访问锁的线程全部都处于同一优先级</p></li></ul><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func synchronized(_ obj: Any, closure: ()-&gt;()) &#123;</span><br><span class="line">    objc_sync_enter(obj)</span><br><span class="line">    closure()</span><br><span class="line">    objc_sync_exit(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>只有传同样的对象给synchronized，才能起到加锁的作用</li><li>如果传nil，无法起到加锁的作用</li><li>可以重入</li><li>synchronized不会持有传给它的对象</li></ul><h1 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h1><ul><li><p>一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面</p></li><li><p>实现一个多线程安全的Array的读和写</p></li><li><p>编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度</p></li><li><p>需要在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件</p></li></ul><h1 id="【场景一】：一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面"><a href="#【场景一】：一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面" class="headerlink" title="【场景一】：一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面"></a>【场景一】：一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面</h1><h1 id="【场景二】：实现一个多线程安全的Array的读和写"><a href="#【场景二】：实现一个多线程安全的Array的读和写" class="headerlink" title="【场景二】：实现一个多线程安全的Array的读和写"></a>【场景二】：实现一个多线程安全的Array的读和写</h1><p>一个队列加方法方法</p><ul><li>1、首先是 <code>并行队列</code>，我们需要保持多线程并行操作</li><li>2、 <code>sync</code> 方法，<code>封装读操作</code>，读操作在调用读方法时能直接拿到返回值，而不是异步获取</li><li>3、<code>async</code> 方法使用 <code>barrier flag</code>，<code>封装写操作</code>，起到一个栅栏的作用，等待所有的 <code>barrier flag</code> 函数前操作执行完成后， <code>barrier flag</code> 函数之后的所有操作才执行</li></ul><h1 id="【场景三】：编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度"><a href="#【场景三】：编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度" class="headerlink" title="【场景三】：编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度"></a>【场景三】：编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度</h1><h1 id="【场景四】：需要-在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件"><a href="#【场景四】：需要-在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件" class="headerlink" title="【场景四】：需要 在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件"></a>【场景四】：需要 在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件</h1><h1 id="Promise-多线程编程模式"><a href="#Promise-多线程编程模式" class="headerlink" title="Promise 多线程编程模式"></a>Promise 多线程编程模式</h1><ul><li><p>所谓的 <code>Promise</code>，就是一个对象，<code>用来传递异步操作的消息</code>。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 <code>API</code>，可供进一步处理</p></li><li><p>对象的状态不受外界影响。<code>Promise</code> 对象代表一个异步操作，有三种状态：<code>Pending</code>（进行中）、<code>Resolved</code>（已完成）、<code>Rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 <code>Promise</code> 这个名字的由来，它的英文意思就是 <code>承诺</code>，表示其他手段无法改变</p></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code> 对象的状态改变，只有两种可能：从 <code>Pending</code> 变为 <code>Resolved</code> 变为 <code>Rejected</code>，只要这两种情况发送，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发送了，你再对 <code>Resolved</code> 对象添加回调函数，也会立即得到这个结果。这与事件 Event 完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的</p></li></ul><h1 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h1><ul><li><p>将一个任务分解为若干个阶段（State），前阶段的输出作为下阶段的输入，各个阶段由不同的工作者线程负责执行</p></li><li><p>各个任务的各个阶段是并行（Parallel）处理的</p></li><li><p>具体任务的处理是串行的，即完成一个任务要一次执行各个阶段，但从整体任务上看，不同任务的各个阶段的执行时并行的</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303131740513.png"                                     ></p><h1 id="Master-x2F-Slave"><a href="#Master-x2F-Slave" class="headerlink" title="Master&#x2F;Slave"></a>Master&#x2F;Slave</h1><p>将一个任务分解为若干个语义等同的子任务，并由专门的工作者线程来并行执行这些子任务，既提高计算效率，又实现了信息隐藏</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为什么几乎所有的GUI框架都是单线程的？：处理问题代价大于收益&lt;/p&gt;
&lt;h1 id=&quot;多线程可以做什么&quot;&gt;&lt;a href=&quot;#多线程可以做</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
</feed>
