<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张建的博客</title>
  <icon>https://www.gravatar.com/avatar/134cc2bfaf649e446f661778f4112fca</icon>
  <subtitle>成功的道路上只有荆棘，没有坦途</subtitle>
  <link href="https://www.bboyzj.cn/atom.xml" rel="self"/>
  
  <link href="https://www.bboyzj.cn/"/>
  <updated>2023-03-21T02:38:39.414Z</updated>
  <id>https://www.bboyzj.cn/</id>
  
  <author>
    <name>小J</name>
    <email>13718004742@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OC学习24：多环境配置</title>
    <link href="https://www.bboyzj.cn/2023/03/21/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A024%EF%BC%9A%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.bboyzj.cn/2023/03/21/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A024%EF%BC%9A%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2023-03-21T00:31:38.000Z</published>
    <updated>2023-03-21T02:38:39.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h1><ul><li>Project : 包含了项目所有的代码、资源文件和所有信息。</li><li>Target : 对指定代码和资源文件的具体构建方式。</li><li>Scheme : 对指定的Target的环境配置</li></ul><p>在实际开发中，我们必须要进行网络请求（<code>内网和外网</code>），而网络请求则就要针对不同的环境（<code>开发</code>、<code>测试</code>、<code>生产</code>）有不同的的<code>主机名称（URL_HOST）</code>，那么我们如何获取某个环境下的<code>URL_HOST</code>，那么在这个过程中，我们需要进行配置，而配置的方式有三种：</p><ul><li>Target 配置</li><li>Scheme 配置</li><li>xcconfig 配置</li></ul><h1 id="Target-配置"><a href="#Target-配置" class="headerlink" title="Target 配置"></a>Target 配置</h1><ol><li>新建Dev的Target</li></ol><ul><li><p>选中 <code>Target</code> 下 <code>LoginApp</code> -&gt; 右键选中 <code>Duplicate</code> 复制 -&gt; 生成新的 <code>LoginApp copy</code> -&gt; 将其改名为 <code>LoginApp-Dev</code> </p></li><li><p>修改 <code>Bundle Identifier</code> 名为 <code>com.srsf.LoginApp-Dev</code></p></li><li><p>修改新生成的 <code>LoginApp copy-info</code> 名为 <code>LoginApp-Dev-info</code>，plist名称改变同时需要在 <code>Build Settings</code> -&gt; <code>Packaging</code> -&gt; <code>info.list File</code> 下 -&gt; 将 <code>LoginApp copy-info</code> 改成  <code>LoginApp-Dev-info</code>。</p></li></ul><p>如下图：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210829441.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210837715.png"                                     ></p><p>注：到目前为止，你运行 <code>LoginApp</code> 和 <code>LoginApp-Dev</code> 会生成两个 <code>App</code>。</p><ol start="2"><li>添加自定义宏 <code>macros</code></li></ol><ul><li>选中 <code>LoginApp-Dev</code> -&gt; <code>Builds Settings</code> -&gt; <code>all</code> -&gt; 搜索 <code>macros</code> -&gt; <code>Apple Clang - Preprocessing</code> -&gt; 选中 <code>Debug</code> 右键空白双击 -&gt; 弹出添加 <code>DEV=1</code>；同理，<code>Release</code> 设置 <code>DEV=0</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210859670.png"                                     ></p><ul><li>此时，自定义的宏已经生效了，此时可以在任意地方调用下面的方式进行判断使用</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if DEV</span><br><span class="line">    #define URL_HOST @&quot;http://192.168.0.1&quot;</span><br><span class="line">#else</span><br><span class="line">    #define URL_HOST @&quot;http://192.168.0.2&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></div><ol start="3"><li>当你切换不同的 <code>Scheme</code> 时，打印不同的 <code>URL_HOST</code></li></ol><p>如果你觉得 <code>Scheme</code> 下名字看的不爽，也可以将 <code>Scheme</code> 下的名字也修改：<code>LoginApp copy</code> 改成 <code>LoginApp-Dev</code></p><ol start="4"><li>总结</li></ol><p><code>Target</code> 配置这种方式，每创建一个 <code>target</code> 都会产生新的 <code>info.plist</code>，每一个都需要去配置 <code>macros</code>，配置比较乱，<code>不推荐</code> 使用。</p><h1 id="Scheme-配置"><a href="#Scheme-配置" class="headerlink" title="Scheme 配置"></a>Scheme 配置</h1><ol><li>首先我们要了解到 <code>Scheme</code> 默认是有两种环境变量 <code>Debug</code> 和 <code>Release</code>，可以在 <code>Edit Scheme</code> -&gt; <code>Run</code> -&gt; <code>info</code> -&gt; <code>Build Configuration</code> 下查看。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210909448.png"                                     ></p><ol start="2"><li>其次，与之对应的环境配置在 <code>Project</code> -&gt; <code>LoginApp</code> -&gt; <code>Configurations</code> 下也可以看到</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210916856.png"                                     ></p><ol start="3"><li>在 <code>Project</code> -&gt; <code>Info</code> -&gt; <code>Configurations</code> 下，我们可以创建一个自己的配置环境 <code>Beta</code>,现在我们有了 <code>三</code> 种配置方式，对应的在 <code>Edit Scheme</code> -&gt; <code>Run</code> -&gt; <code>info</code> -&gt; <code>Build Configuration</code> 下也有三种，同时在 <code>Target</code> -&gt; <code>Build Settings</code> -&gt; <code>Build Active Architecture Only</code> 下也有对应的三种配置方式，说明这是一个 <code>全局</code> 的配置，如下图：</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210923815.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210924650.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210925812.png"                                     ></p><ol start="3"><li>新建 Scheme</li></ol><ul><li>点击 <code>LoginApp</code> -&gt; manager Schemes -&gt; 点击 + 号 -&gt; 添加 <code>Debug</code> 和 <code>Beta</code> 两种，加上 <code>LoginApp</code> 本身 <code>Release</code> 就是三种，对应上面 <code>三种</code> 配置</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210927495.png"                                     ></p><ul><li>点击 <code>Edit Scheme</code> 切换 <code>Scheme</code>，并指定 <code>Configurations</code>，如下图</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210927160.png"                                     ></p><ol start="4"><li>自定义主机名URL_HOST</li></ol><ul><li><code>Target</code> -&gt; <code>Build Settings</code> -&gt; 点击 <code>+</code> 号 -&gt; <code>Add User-Defined Settings</code> -&gt; <code>URL_HOST</code>，此时我们发现其对应的配置也是三个，分别设值如下：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210930226.png"                                     ></p><ol start="5"><li>将 <code>URL_HOST</code> 添加到 <code>info.plist</code> 文件中，<code>Build Settings</code> 中的 配置可以通过 <code>info.plist</code> 暴露出来，可以直接读出来</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210933404.png"                                     ></p><ol start="6"><li>在项目中使用</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString * path = [NSBundle.mainBundle pathForResource:@&quot;Info&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">NSDictionary * infoDic = [[NSDictionary alloc] initWithContentsOfFile:path];</span><br><span class="line">NSLog(@&quot;%@&quot;,infoDic[@&quot;HOST_URL&quot;]);</span><br></pre></td></tr></table></figure></div><p>切换 <code>Scheme</code> ，打印如下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Debug：http://137.0.0.2</span><br><span class="line">Beta：http://137.0.0.1</span><br><span class="line">LoginApp：http://www.zjboy.com</span><br></pre></td></tr></table></figure></div><ol start="7"><li>同理配置图标的也一样</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210936202.png"                                     ></p><h1 id="xcconfig-配置"><a href="#xcconfig-配置" class="headerlink" title="xcconfig 配置"></a>xcconfig 配置</h1><ol><li>在实际项目中，我们可能会有多个主机名称 <code>HOST_URL</code>，因此，我们还是需要去配置多个<code>Configurations</code>，下面还是以三个为准</li></ol><ul><li>在 <code>Project</code> -&gt; <code>LoginApp</code> -&gt; <code>Configurations</code> 下，我们可以创建一个自己的配置环境 <code>Beta</code>,现在我们有 了 <code>三</code> 种配置方式，对应的在 <code>Edit Scheme</code> -&gt; <code>Run</code> -&gt; <code>info</code> -&gt; <code>Build Configuration</code> 下也有三种，同时在 <code>Target</code> -&gt; <code>Build Settings</code> -&gt; <code>Build Active Architecture Only</code> 下也有对应的三种配置方式，说明这是一个 <code>全局</code> 的配置，如下图：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211008376.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210936989.png"                                     ></p><ol start="2"><li>在主项目下，创建 <code>Congifg</code> 文件，并在下面创建三个对应环境的 <code>.xxconfig</code> 文件</li></ol><ul><li>在Config文件夹下 -&gt; command + N -&gt; 搜索config</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210936598.png"                                     ></p><ul><li>输入对应的名称 -&gt; 点击create</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/148355970-ade68d43-9816-4697-92d6-b451aa09e20d.jpg"                                     ></p><ul><li>创建成功之后，如下图</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211025332.png"                                     ></p><ol start="2"><li>选择对应Target的进行配置</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211025894.png"                                     ></p><ol start="3"><li>在 <code>xxconfig</code> 文件中写入 <code>HOST_URL</code></li></ol><ul><li><code>Debug</code> 下</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = /</span><br><span class="line">HOST_URL = http:$&#123;A&#125;/127.0.0.1</span><br></pre></td></tr></table></figure></div><ul><li>Beta</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = /</span><br><span class="line">HOST_URL = http:$&#123;A&#125;/127.0.0.2</span><br></pre></td></tr></table></figure></div><ul><li>Release ：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = /</span><br><span class="line">HOST_URL = http:$&#123;A&#125;/www.bboyzj.cn</span><br></pre></td></tr></table></figure></div><ol start="4"><li>同样，我们需要在 <code>info.plist</code> 文件中暴露，在项目中取出</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303210935125.png"                                     ></p><ol start="5"><li>项目中代码取出</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString * path = [NSBundle.mainBundle pathForResource:@&quot;Info&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">    NSDictionary * infoDic = [[NSDictionary alloc] initWithContentsOfFile:path];</span><br><span class="line">    NSLog(@&quot;%@&quot;,infoDic[@&quot;HOST_URL&quot;]);</span><br></pre></td></tr></table></figure></div><p>切换不同的 scheme 的打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Debug：http://127.0.0.1</span><br><span class="line"></span><br><span class="line">Beta： http://127.0.0.2</span><br><span class="line"></span><br><span class="line">Release：https://www.bboyzj.cn</span><br></pre></td></tr></table></figure></div><h1 id="Pch"><a href="#Pch" class="headerlink" title="Pch"></a>Pch</h1><ul><li>到 Target -&gt; Build Settings -&gt; 设值不同的DEBUG值</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211034254.png"                                     ></p><ul><li>具体是现代吗</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#if (DEBUG == 1)</span><br><span class="line">    #define kBaseUrl @&quot;http://127.0.0.1&quot;</span><br><span class="line">#elif (DEBUG == 2)</span><br><span class="line">    #define kBaseUrl @&quot;http://127.0.0.2&quot;</span><br><span class="line">#else</span><br><span class="line">    #define kBaseUrl @&quot;https://www.bboyzj.cn&quot;</span><br><span class="line">#endif</span><br><span class="line">    NSLog(@&quot;url:%@&quot;,kBaseUrl);</span><br></pre></td></tr></table></figure></div><h1 id="xconfig-其他功能"><a href="#xconfig-其他功能" class="headerlink" title="xconfig 其他功能"></a>xconfig 其他功能</h1><ul><li><code>xconfig</code> 全名是 <code>xcodeConfig</code>，它不仅仅是一个文件，它的本质是控制 <code>Build Settings</code> 里面的选项(比如配置动态库、静态库等)</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ld 配置到链接器上</span><br><span class="line">// OTHER_LDFLAGS 即 Other Linker Flags 的缩写</span><br><span class="line">OTHER_LDFLAGS = -framework &quot;AFNetworking&quot;</span><br></pre></td></tr></table></figure></div><ul><li>在Debug配置下运行，报错 <code>ld: framework not found AFNetworking</code> ，然后我们找到 <code>Other Linker Flags</code>，可以看到如下</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211035155.png"                                     ></p><ul><li><p>他的原理与 <code>cocoapods</code> 的原理相同</p></li><li><p>想查找 <code>Build Settings</code> 中选项的缩写，这里有一个网站可以去查看 <a class="link"   href="https://xcodebuildsettings.com/" >Build Settings 缩写网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p>比如搜索一个 <code>header search path</code>，找到其缩写 <code>HEADER_SEARCH_PATHS</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEADER_SEARCH_PATHS = \user\zjbboy</span><br></pre></td></tr></table></figure></div><ul><li>你会在 <code>build settings</code> 找到</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211037905.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多环境配置&quot;&gt;&lt;a href=&quot;#多环境配置&quot; class=&quot;headerlink&quot; title=&quot;多环境配置&quot;&gt;&lt;/a&gt;多环境配置&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Project : 包含了项目所有的代码、资源文件和所有信息。&lt;/li&gt;
&lt;li&gt;Target : 对指</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习18：多环境切换</title>
    <link href="https://www.bboyzj.cn/2023/03/21/Swift/Swift%E5%AD%A6%E4%B9%A018%EF%BC%9A%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/"/>
    <id>https://www.bboyzj.cn/2023/03/21/Swift/Swift%E5%AD%A6%E4%B9%A018%EF%BC%9A%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/</id>
    <published>2023-03-20T23:33:09.000Z</published>
    <updated>2023-03-21T02:43:57.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>swift</code> 多环境配置和 <code>oc</code> 类似，本文主要介绍 <code>Scheme</code> 和 <code>xcconfig</code> 多环境配置</p><h1 id="第一种方式：Scheme"><a href="#第一种方式：Scheme" class="headerlink" title="第一种方式：Scheme"></a>第一种方式：Scheme</h1><ol><li>首先我们要了解到 <code>Scheme</code> 默认是有两种环境变量 <code>Debug</code> 和 <code>Release</code>，可以在 <code>Edit Scheme</code> -&gt; <code>Run</code> -&gt; <code>info</code> -&gt; <code>Build Configuration</code> 下查看。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211039679.png"                                     ></p><ol start="2"><li>其次，与之对应的环境配置在 <code>Project</code> -&gt; <code>Scheme</code> -&gt; <code>Configurations</code> 下也可以看到：</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211039310.png"                                     ></p><ol start="3"><li>在 <code>Project</code> -&gt; <code>Info</code> -&gt; <code>Configurations</code> 下，我们可以创建一个自己的配置环境 <code>Beta</code>,现在我们有了 <code>三</code> 种配置方式，如下图：</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211039788.png"                                     ></p><ul><li>对应的在 <code>Edit Scheme</code> -&gt; <code>Run</code> -&gt; <code>info</code> -&gt; <code>Build Configuration</code> 下也有三种，如下图：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211040573.png"                                     ></p><ul><li>同时在 <code>Target</code> -&gt; <code>Build Settings</code> -&gt; <code>Build Active Architecture Only</code> 下也有对应的三种配置方式，说明这是一个 <code>全局</code> 的配置，如下图：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211040984.png"                                     ></p><ol start="4"><li>新建 Scheme</li></ol><ul><li>点击 <code>Scheme -&gt; manager Schemes</code> -&gt; 点击 <code>+</code> 号 -&gt; 添加 <code>Debug</code> 和 <code>Beta</code> 两种，加上 <code>Scheme</code> 本身 <code>Release</code> 就是三种，对应上面 <code>三种</code> 配置</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211040044.png"                                     ></p><ul><li>点击 <code>Edit Scheme</code> 切换 <code>Scheme</code>，并指定 <code>Configurations</code>，如下图:</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211041361.png"                                     ></p><ol start="5"><li>自定义主机名 <code>URL_HOST</code></li></ol><ul><li><code>Target</code> -&gt; <code>Build Settings</code> -&gt; 点击 <code>+</code> 号 -&gt; <code>Add User-Defined Settings</code> -&gt; <code>URL_HOST</code>，此时我们发现其对应的配置也是三个，分别设值如下：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211041980.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211041457.png"                                     ></p><ol start="6"><li>将 <code>URL_HOST</code> 添加到 <code>info.plist</code> 文件中，<code>Build Settings</code> 中的 配置可以通过 <code>info.plist</code> 暴露出来，可以直接读出来</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211042468.png"                                     ></p><ol start="7"><li>在项目中使用</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let path = Bundle.main.path(forResource: &quot;Info&quot;, ofType: &quot;plist&quot;);</span><br><span class="line">let dic = NSMutableDictionary(contentsOfFile: path!);</span><br><span class="line">print(dic![&quot;URL_HOST&quot;]!);</span><br></pre></td></tr></table></figure></div><p>切换 scheme ，查看不同的打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://Debug</span><br><span class="line">http://Release</span><br><span class="line">http://Beta</span><br></pre></td></tr></table></figure></div><h1 id="第二种方式：xcconfig-配置"><a href="#第二种方式：xcconfig-配置" class="headerlink" title="第二种方式：xcconfig 配置"></a>第二种方式：xcconfig 配置</h1><ol><li>同样的，我们需要先配置 <code>三种 Connfigurations</code> ，配置方式同上</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211042205.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211042608.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211042489.png"                                     ></p><ol start="2"><li>在主项目下，创建 <code>Config</code> 文件，并在下面创建三个对应环境的 <code>.xcconfig</code> 文件</li></ol><ul><li>在Config文件夹下 -&gt; <code>command + N</code> -&gt; 搜索config</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211042170.png"                                     ></p><ul><li>输入对应的名称 -&gt; 点击create</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211043434.png"                                     ></p><ul><li>创建成功之后，如下图:</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211043637.png"                                     ></p><ol start="3"><li>选择对应Target的进行配置</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211043410.png"                                     ></p><ol start="4"><li>在 <code>xconfig</code> 文件中写入 <code>URL_HOST</code></li></ol><ul><li><code>Debug</code> 下</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = /</span><br><span class="line">URL_HOST = http:$&#123;A&#125;/Debug</span><br></pre></td></tr></table></figure></div><ul><li>Beta</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = /</span><br><span class="line">URL_HOST = http:$&#123;A&#125;/Beta</span><br></pre></td></tr></table></figure></div><ul><li>Release ：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = /</span><br><span class="line">URL_HOST = http:$&#123;A&#125;/Release</span><br></pre></td></tr></table></figure></div><ol start="5"><li>同样，我们需要在 <code>info.plist</code> 文件中暴露，在项目中取出</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303211043893.png"                                     ></p><ol start="6"><li>项目中代码取出</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let path = Bundle.main.path(forResource: &quot;Info&quot;, ofType: &quot;plist&quot;);</span><br><span class="line">let dic = NSMutableDictionary(contentsOfFile: path!);</span><br><span class="line">print(dic![&quot;URL_HOST&quot;]!);</span><br></pre></td></tr></table></figure></div><p>切换 scheme ，查看不同的打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://Debug</span><br><span class="line">http://Release</span><br><span class="line">http://Beta</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;swift&lt;/code&gt; 多环境配置和 &lt;code&gt;oc&lt;/code&gt; 类似，本文主要介绍 &lt;code&gt;Scheme&lt;/code</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Flutter学习03：Dart数据类型</title>
    <link href="https://www.bboyzj.cn/2023/03/21/Flutter%E5%AD%A6%E4%B9%A0/Flutter%E5%AD%A6%E4%B9%A003%EF%BC%9ADart%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://www.bboyzj.cn/2023/03/21/Flutter%E5%AD%A6%E4%B9%A0/Flutter%E5%AD%A6%E4%B9%A003%EF%BC%9ADart%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2023-03-20T21:41:36.000Z</published>
    <updated>2023-03-20T21:46:04.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h1><ul><li><p>Numbers（数值）：</p><ul><li>int</li><li>double</li></ul></li><li><p>Strings（字符串）：</p><ul><li>String</li></ul></li><li><p>Booleans（布尔）：</p><ul><li>bool</li></ul></li><li><p>List（数组）：</p><ul><li>在dart中，数组是列表对象，所以大多数人只是称它们为列表</li></ul></li><li><p>Maps（字典）：<br>  通常来说，Map 是一个键值对相关的对象。键和值可以是任何类型的对象。每个键</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用数据类型&quot;&gt;&lt;a href=&quot;#常用数据类型&quot; class=&quot;headerlink&quot; title=&quot;常用数据类型&quot;&gt;&lt;/a&gt;常用数据类型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Numbers（数值）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int&lt;/li&gt;
&lt;li&gt;double</summary>
      
    
    
    
    <category term="Flutter-学习篇" scheme="https://www.bboyzj.cn/categories/Flutter-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
    
    <category term="Flutter" scheme="https://www.bboyzj.cn/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter学习02：Dart入口、打印、注释、常量、变量、命名规则</title>
    <link href="https://www.bboyzj.cn/2023/03/20/Flutter%E5%AD%A6%E4%B9%A0/Flutter%E5%AD%A6%E4%B9%A002%EF%BC%9ADart%E5%85%A5%E5%8F%A3%E3%80%81%E6%89%93%E5%8D%B0%E3%80%81%E6%B3%A8%E9%87%8A%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"/>
    <id>https://www.bboyzj.cn/2023/03/20/Flutter%E5%AD%A6%E4%B9%A0/Flutter%E5%AD%A6%E4%B9%A002%EF%BC%9ADart%E5%85%A5%E5%8F%A3%E3%80%81%E6%89%93%E5%8D%B0%E3%80%81%E6%B3%A8%E9%87%8A%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/</id>
    <published>2023-03-20T09:07:03.000Z</published>
    <updated>2023-03-20T21:40:25.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="入口方法"><a href="#入口方法" class="headerlink" title="入口方法"></a>入口方法</h1><p>入口方法有两种方式：</p><ul><li>第一种</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">    print(&#x27;hello dart&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>第二种</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 表示main方法没有返回值</span><br><span class="line">void main() &#123;</span><br><span class="line">    print(&#x27;hello dart&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>注：<br>如果无法输入请按 i：切换为输入<br>如果运行结果不全：请先保存 command + s</p></blockquote><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><ul><li>command + &#x2F;</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// main() &#123;</span><br><span class="line">//   print(&quot;hello dart&quot;);</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure></div><ul><li>&#x2F;&#x2F;&#x2F;</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/// 这也是一个注释</span><br></pre></td></tr></table></figure></div><ul><li>&#x2F;* 内容 *&#x2F;</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  // 表示main方法没有返回值</span><br><span class="line">  void main() &#123;</span><br><span class="line">    print(&#x27;hello dart&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></div><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul><li><p>dart 变量是一个强大的脚本类语言，可以不先预定义变量类型，自动会类型推断</p></li><li><p>dart 定义变量可以通过 <code>var</code> 关键字来申明变量</p></li></ul><p>如：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  // dart里面有类型校验</span><br><span class="line">    </span><br><span class="line">  // 定义变量-字符串类型</span><br><span class="line">  var str = &quot;this is var&quot;;</span><br><span class="line">  print(str);</span><br><span class="line">  // 也可以用另一种方式</span><br><span class="line">  String str1 = &#x27;this is str&#x27;;</span><br><span class="line">  print(str1);</span><br><span class="line"></span><br><span class="line">  // 定义变量-数字类型</span><br><span class="line">  var myNum = 1234;</span><br><span class="line">  print(myNum);</span><br><span class="line">  // 另一张方式</span><br><span class="line">  int myNum1 = 12345;</span><br><span class="line">  print(myNum1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>注：<code>var</code> 后不要写类型，写了类型 不要写 <code>var</code>，两者都写 <code>var int a = 5;</code> 报错</p></blockquote><h1 id="Dart-的命名规则"><a href="#Dart-的命名规则" class="headerlink" title="Dart 的命名规则"></a>Dart 的命名规则</h1><ul><li>变量名称必须由数字、字母、下划线和美元符$组成</li><li>注意：标识符开头不能是数字</li><li>标识符不能是保留字和关键字</li><li>变量的名字是区分大小写的，如：age和Age是不同的变量</li><li>变量名称建议用名词，方法名建议用动词</li></ul><p>示例：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;this is var string&#x27;;</span><br><span class="line"></span><br><span class="line">// 错误的写法</span><br><span class="line">// 数字开头</span><br><span class="line">// var 2str = &#x27;error var&#x27;;</span><br><span class="line">// 关键字</span><br><span class="line">// var if = &#x27;12&#x27;;</span><br><span class="line"></span><br><span class="line">// 变量区分大小写</span><br><span class="line">var age = 30;</span><br><span class="line">print(age);</span><br><span class="line"></span><br><span class="line">var Age = 31;</span><br><span class="line">print(Age);</span><br></pre></td></tr></table></figure></div><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><ul><li><p><code>const</code> 值不变 一开始就得赋值</p></li><li><p><code>final</code> 可以开始不赋值 只能赋一次，而final不仅有const的编译时常量特性，最重要的它是运行时</p></li><li><p>永远不改变的量，请使用 <code>const</code> 或 <code>final</code> 修饰，而不是使用var或其他变量类型</p></li><li><p>final 和 const 区别：final可以开始不赋值，只能赋一次。而final不仅有const编译时常量的特性，最重要的是它是运行时的常量，并且final是惰性初始化，即在运行时第一次使用前才初始化</p></li></ul><p>示例：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// const修饰常量</span><br><span class="line">  // const PI = 3.1415926;</span><br><span class="line">  // PI = 123.123; // 错误的写法 常量不可以修改</span><br><span class="line"></span><br><span class="line">// final修饰常量</span><br><span class="line">  final PI = 3.1415926;</span><br><span class="line">  // PI = 123.123; // 错误的写法 常量不可以修改</span><br><span class="line"></span><br><span class="line">  final a = new DateTime.now();</span><br><span class="line">  print(a);</span><br><span class="line"></span><br><span class="line">  const a1 = new DateTime.now(); // 错误</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;入口方法&quot;&gt;&lt;a href=&quot;#入口方法&quot; class=&quot;headerlink&quot; title=&quot;入口方法&quot;&gt;&lt;/a&gt;入口方法&lt;/h1&gt;&lt;p&gt;入口方法有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight-c</summary>
      
    
    
    
    <category term="Flutter-学习篇" scheme="https://www.bboyzj.cn/categories/Flutter-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
    
    <category term="Flutter" scheme="https://www.bboyzj.cn/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习17：Model使用结构体还是类</title>
    <link href="https://www.bboyzj.cn/2023/03/19/Swift/Swift%E5%AD%A6%E4%B9%A017%EF%BC%9AModel%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E8%BF%98%E6%98%AF%E7%B1%BB/"/>
    <id>https://www.bboyzj.cn/2023/03/19/Swift/Swift%E5%AD%A6%E4%B9%A017%EF%BC%9AModel%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E8%BF%98%E6%98%AF%E7%B1%BB/</id>
    <published>2023-03-19T14:42:36.000Z</published>
    <updated>2023-03-19T14:43:07.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习16：Git使用</title>
    <link href="https://www.bboyzj.cn/2023/03/19/Swift/Swift%E5%AD%A6%E4%B9%A016%EF%BC%9AGit%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.bboyzj.cn/2023/03/19/Swift/Swift%E5%AD%A6%E4%B9%A016%EF%BC%9AGit%E4%BD%BF%E7%94%A8/</id>
    <published>2023-03-19T00:21:04.000Z</published>
    <updated>2023-03-20T23:37:26.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p><code>Git</code> 是一款免费、开源的 <code>分布式版本控制系统</code></p></li><li><p><code>GitHub/Gitee/Gitlab</code> 用 <code>Git</code> 做版本控制的项目托管平台</p></li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a class="link"   href="https://git-scm.com/downloads" >Git官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 选择自己对应的系统安装，安装完成后在终端执行 <code>git version</code>，输出 <code>git</code> 版本则安装成功，<code>Mac</code> 本身自带 <code>git</code>，可以不用安装</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % git version</span><br><span class="line">git version 2.37.1 (Apple Git-137.1)</span><br></pre></td></tr></table></figure></div><h1 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h1><ul><li>使用 <code>git config</code> 命令来配置用户信息</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % git config --global user.name &quot;BboyZJ&quot;</span><br><span class="line">mac@bogon ~ % git config --global user.email 13718004742@163.com</span><br></pre></td></tr></table></figure></div><blockquote><p>注：<br>–global：表示你的配置文件在你用户主目录下，以后默认使用这里配置的用户信息。<br>如果要在某个特定的仙姑中使用其他名字或电子邮件，只要去掉 –global 重新配置即可，新设定保存在当前项目的 <code>.git/config</code> 文件中</p></blockquote><ul><li>检查是否成功</li></ul><p>使用 git config user.name 和 git config user.email 或者使用 git config –list</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % git config user.name</span><br><span class="line">BboyZJ</span><br><span class="line">mac@bogon ~ % git config user.email</span><br><span class="line">13718004742@163.com</span><br></pre></td></tr></table></figure></div><h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><ul><li>初始化</li></ul><blockquote><p>git init</p></blockquote><ul><li>提交</li></ul><blockquote><p>&#x2F;&#x2F; 将当前目录下所有文件提交到暂存区<br>git add .<br>&#x2F;&#x2F; 添加单个文件到暂缓区<br>git add file…</p></blockquote><ul><li>查看</li></ul><blockquote><p>&#x2F;&#x2F; 查看当前仓库的状态<br>git status<br>&#x2F;&#x2F; 查看提交记录<br>git log</p></blockquote><ul><li>版本回退</li></ul><blockquote><p>&#x2F;&#x2F; 切换到指定版本<br>git reset –hard 版本id<br>&#x2F;&#x2F; 查看以前的提交日志<br>git reflog</p></blockquote><ul><li>克隆&#x2F;更新</li></ul><blockquote><p>&#x2F;&#x2F; 克隆<br>git clone 仓库地址<br>&#x2F;&#x2F; 更新<br>git pull </p></blockquote><ul><li>关联&#x2F;推送</li></ul><blockquote><p>&#x2F;&#x2F; 添加远程仓库关联<br>git remote add origin 仓库地址<br>&#x2F;&#x2F; 查看所有远程仓库关联<br>git remote -v<br>&#x2F;&#x2F; 删除远程仓库关联<br>git remote remove origin 仓库地址</p><p>&#x2F;&#x2F; 推送到远程第一次加 -u<br>git push -u origin master<br>&#x2F;&#x2F; 不是第一次推送<br>git push origin zj_feature</p></blockquote><ul><li>分支操作</li></ul><blockquote><p>&#x2F;&#x2F; 查看分支<br>git branch<br>&#x2F;&#x2F; 删除分支<br>git branch -d<br>&#x2F;&#x2F; 新建分支<br>git branch zj_feature<br>&#x2F;&#x2F; 新建并切换分支<br>git checkout -b zj_feature<br>&#x2F;&#x2F; 切换分支<br>git checkout zj_feature</p></blockquote><ul><li>提交</li></ul><blockquote><p>&#x2F;&#x2F; 提交所有代码到暂存区<br>git add .<br>&#x2F;&#x2F; 提交到本地仓库<br>git commit -m “注释说明”<br>&#x2F;&#x2F; 提交到 远程仓库<br>git push origin zj_feature</p></blockquote><h1 id="拉取代码"><a href="#拉取代码" class="headerlink" title="拉取代码"></a>拉取代码</h1><blockquote><p>&#x2F;&#x2F; 克隆<br>git clone <a class="link"   href="mailto:&#103;&#105;&#x74;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#111;&#109;" >&#103;&#105;&#x74;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#111;&#109; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>:BboyZJ&#x2F;ZJWeakProxy.git</p></blockquote><h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><ul><li>在分支下的操作</li></ul><blockquote><p>&#x2F;&#x2F; 切换到 zj_feature<br>git checkout zj_feature<br>&#x2F;&#x2F; 添加到暂缓区<br>git add files….<br>&#x2F;&#x2F; 提交到本地仓库<br>git commit -m “commit msg”<br>&#x2F;&#x2F; 提交到远程 zj_feature 分支<br>git push origin zj_feature</p></blockquote><ul><li>更新到主分支</li></ul><blockquote><p>&#x2F;&#x2F; 切换到主分支<br>git checkout master<br>&#x2F;&#x2F; 拉取主分支内容<br>git pull origin master<br>git add files….<br>&#x2F;&#x2F; 提交到本地仓库<br>git commit -m “commit msg”<br>&#x2F;&#x2F; 提交到远程 master 分支<br>git push origin master</p></blockquote><ul><li>合并分支</li></ul><blockquote><p>&#x2F;&#x2F; 切换到 zj_feature<br>git checkout zj_feature<br>&#x2F;&#x2F; 合并主分支到当前分支<br>git merge master<br>&#x2F;&#x2F; 提交到远程分支 zj_feature<br>git push origin zj_feature</p></blockquote><h1 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h1><blockquote><p>&#x2F;&#x2F; 切换到想打tag的分支<br>git checkout master<br>&#x2F;&#x2F; 创建带有信息的tag<br>git tag -a release_v1.0 -m “release_v1.0”<br>&#x2F;&#x2F; 创建不带有信息的tag<br>git tag release_v1.0<br>&#x2F;&#x2F; 查看tag<br>git tag<br>&#x2F;&#x2F; 推送全部tag<br>git push –tags<br>&#x2F;&#x2F; 推送单个tag<br>git push origin release_v1.0</p></blockquote><h1 id="【面试题】"><a href="#【面试题】" class="headerlink" title="【面试题】"></a>【面试题】</h1><ul><li>提交 <code>单个/多个</code> 文件夹&#x2F;文件</li></ul><p><code>git add</code> 可以提交 <code>单个/多个</code> 文件夹&#x2F;文件，后面加上 <code>文件夹/文件路径</code> 即可</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon SRSF % git branch zj_feature</span><br><span class="line">mac@bogon SRSF % git add /Users/mac/Desktop/SRSF/SRSF/Classes/UI\(用户界面\)/Me\(我的\)/Collect\(收藏\)</span><br><span class="line">mac@bogon SRSF % git commit -m &quot;提交收藏文件夹&quot;</span><br><span class="line">mac@bogon SRSF % git push origin zj_feature</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Git&lt;/code&gt; 是一款免费、开源的 &lt;code&gt;分布式版本控制系统&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>OC学习23：FPS卡顿检测和上报</title>
    <link href="https://www.bboyzj.cn/2023/03/18/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A023%EF%BC%9AFPS%E5%8D%A1%E9%A1%BF%E6%A3%80%E6%B5%8B%E5%92%8C%E4%B8%8A%E6%8A%A5/"/>
    <id>https://www.bboyzj.cn/2023/03/18/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A023%EF%BC%9AFPS%E5%8D%A1%E9%A1%BF%E6%A3%80%E6%B5%8B%E5%92%8C%E4%B8%8A%E6%8A%A5/</id>
    <published>2023-03-17T23:50:38.000Z</published>
    <updated>2023-03-21T00:32:02.426Z</updated>
    
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习22：Crash崩溃和捕获</title>
    <link href="https://www.bboyzj.cn/2023/03/18/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A022%EF%BC%9ACrash%E5%B4%A9%E6%BA%83%E5%92%8C%E6%8D%95%E8%8E%B7/"/>
    <id>https://www.bboyzj.cn/2023/03/18/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A022%EF%BC%9ACrash%E5%B4%A9%E6%BA%83%E5%92%8C%E6%8D%95%E8%8E%B7/</id>
    <published>2023-03-17T22:22:12.000Z</published>
    <updated>2023-03-18T23:40:40.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OC-层面的crash"><a href="#OC-层面的crash" class="headerlink" title="OC 层面的crash"></a>OC 层面的crash</h1><ol><li>NSInvalidArgumentException：非法参数</li></ol><ul><li><p>原因：</p><ul><li>字典 ：<code>key</code> 和 <code>value</code> 为 <code>nil</code></li><li>数组：添加了 <code>nil</code> 元素</li></ul></li><li><p>解决方案：hook 相关方法，增加保护机制</p></li></ul><ol start="2"><li>NSRangeException：下标越界</li></ol><ul><li><p>原因：最常见的 <code>数组</code> 下标越界</p></li><li><p>解决方案：hook 相关方法，增加保护机制</p></li></ul><ol start="3"><li>unrecognized selector sent to instance</li></ol><ul><li><p>原因：<code>实例对象</code> 或 <code>类对象</code> 找不到 <code>方法</code></p></li><li><p>方法调用的过程：</p><ul><li><p>动态方法决议：resolveInstanceMethod&#x2F;resolveClassMethod</p><p>  动态的添加方法：<code>class_addMethod</code></p></li><li><p>快速查找：forwardingTargetForSelector</p><p>  寻找别的对象接收消息</p></li><li><p>慢速查找：</p><p>  methodSignatureForSelector（函数符号制造器）+ forwardInvocation（函数执行器），灵活的将目标函数以其他形式执行。</p></li><li><p>抛出异常：doesNotRecognizeSelector</p></li></ul></li><li><p>解决方案：</p><ul><li>方案一：<code>hook</code> 慢速查找两个方法，添加 <code>try-catch</code> </li><li>方案二：<code>hook</code> 抛出异常 <code>doesNotRecognizeSelector</code>，添加 <code>try-catch</code></li></ul></li></ul><ol start="4"><li>KVO</li></ol><ul><li><p>原因：移除未注册的观察者、重复移除、添加观察者没有实现、添加移除keypath&#x2F;observer为nil</p></li><li><p>解决方案：<code>添加</code> 和 <code>移除</code> 成对出现</p></li></ul><h1 id="Signal-层面的crash"><a href="#Signal-层面的crash" class="headerlink" title="Signal 层面的crash"></a>Signal 层面的crash</h1><p>除了 <code>OC</code> 层面的 <code>crash</code> 之外，还有 内存错误、访问不存在的内存地址等产生的 <code>crash</code>，则需要利用 <code>unix</code> 标准的 <code>signal</code> 机制，注册 <code>SIGABRT、SIGBUS、SIGSEGV</code> 等信号发生时的处理函数。</p><ul><li>SIGKILL：用来立即结束程序的运行的信号。</li><li>SIGSEGV：试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据。</li><li>SIGABRT：调用abort函数生成的信号。</li><li>SIGTRAP：由断点指令或其它trap指令产生。</li><li>SIGBUS：非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)。</li></ul><h1 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h1><p>程序闪退，用户体验不好</p><h1 id="Crash-捕获"><a href="#Crash-捕获" class="headerlink" title="Crash 捕获"></a>Crash 捕获</h1><ol><li><code>OC</code> 层面 <code>crash</code> 捕获</li></ol><ul><li>NSSetUncaughExceptionHander 捕获 OC 层面面的 crash</li></ul><ol start="2"><li><code>Signal</code> 层面 <code>crash</code> 捕获</li></ol><p><code>Appdelegate</code> 中注册 <code>SIGABRT, SIGBUS, SIGSEGV</code> 等信号发生时的处理函数，处理Signal层面的crash。</p><ol start="3"><li>unrecognized selector sent to instance 捕获 crash</li></ol><p><code>hook</code> 慢速查找，<code>try - catch</code> 捕获并上报</p><ol start="4"><li><code>KVO</code> 活不 <code>crash</code></li></ol><p>数组维护，添加和删除的时候做判断，同时 <code>hook dealloc</code> 函数</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>具体代码看下一篇</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OC-层面的crash&quot;&gt;&lt;a href=&quot;#OC-层面的crash&quot; class=&quot;headerlink&quot; title=&quot;OC 层面的crash&quot;&gt;&lt;/a&gt;OC 层面的crash&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;NSInvalidArgumentException：非</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习21：hybrid</title>
    <link href="https://www.bboyzj.cn/2023/03/16/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A021%EF%BC%9Ahybrid/"/>
    <id>https://www.bboyzj.cn/2023/03/16/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A021%EF%BC%9Ahybrid/</id>
    <published>2023-03-16T08:34:42.000Z</published>
    <updated>2023-03-17T12:40:51.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <code>iOS</code> 开发中，<code>iOS</code> 和 <code>JS</code> 交互是每个程序猿必须掌握的技能。<code>iOS8</code> 以后，苹果推出了新框架 <code>WebKit</code>，使用 <code>WKWebView</code> 替代 <code>UIWebView</code>。</p><p>说道 <code>iOS</code> 和 <code>JS</code> 交互，就不得不提 <code>Hybrid（Hybrid Mobile App）</code>，即通过 <code>Web</code> 网络技术与 <code>Native</code> 相结合的混合移动应用开发</p><blockquote><p><code>WKWebView</code> 特性<br>1、稳定性好、占用内存少，速度更快<br>2、高达60fps的滚动刷新率以及内置手势</p></blockquote><p>本文主要介绍 <code>WKWebView</code> 与 <code>JS</code> 交互</p><h1 id="WKWebView-和-JS-交互的方法"><a href="#WKWebView-和-JS-交互的方法" class="headerlink" title="WKWebView 和 JS 交互的方法"></a>WKWebView 和 JS 交互的方法</h1><ol><li><code>WKScriptMessageHandler</code> 代理</li><li>拦截 <code>URL</code></li></ol><p>下面以实际功能为例讲解其使用</p><h1 id="WKScriptMessageHandler-代理"><a href="#WKScriptMessageHandler-代理" class="headerlink" title="WKScriptMessageHandler 代理"></a>WKScriptMessageHandler 代理</h1><ul><li><code>WKScriptMessageHandler</code> 是一个 <code>代理</code> ，代理有一个方法：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 当接收到 JS 消息 时调用，是 UserContentController 委托的代理方法</span><br><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message;</span><br></pre></td></tr></table></figure></div><blockquote><p>上面的代理回调方法是 <code>WKScriptMessageHandler</code> 的代理回到方法，当接收到 <code>JS</code> 消息时调用，是 <code>UserContentController（调度器）</code> 委托的代理方法。</p></blockquote><h1 id="WKUserContentController"><a href="#WKUserContentController" class="headerlink" title="WKUserContentController"></a>WKUserContentController</h1><blockquote><p><code>WKWebView</code> 和 <code>JS</code> 交互，那就得提到 <code>WKUserContentController</code> ，什么是 <code>WKUserContentController</code> ？ <code>WKUserContentController</code> 的作用？</p></blockquote><ul><li><code>WKUserContentController</code> 可以理解为 <code>调度器</code>，用于 <code>JS 和 OC 内容交互</code>，下面我们看一下具体有哪些方法：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface WKUserContentController : NSObject &lt;NSCoding&gt;</span><br><span class="line">// 与内容交互的脚本对象数组</span><br><span class="line">@property (nonatomic, readonly, copy) NSArray&lt;WKUserScript *&gt; *userScripts; </span><br><span class="line">// 添加一个脚本，可以理解为注入一个对象</span><br><span class="line">- (void)addUserScript:(WKUserScript *)userScript;</span><br><span class="line"></span><br><span class="line">// 移除所有脚本</span><br><span class="line">- (void)removeAllUserScripts; </span><br><span class="line"></span><br><span class="line">// 添加 JS 消息处理并设置代理</span><br><span class="line">// JS 中要添加 window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;) 方法,是 JS 与OC 之间的桥梁</span><br><span class="line">- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;</span><br><span class="line"></span><br><span class="line">// 根据 name 移除所注入的 scriptMessageHandler</span><br><span class="line">- (void)removeScriptMessageHandlerForName:(NSString *)name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><blockquote><p>这里有一个重要的方法：<code>addScriptMessageHandler</code>，添加 <code>JS</code> 消息处理并设置代理</p></blockquote><ul><li>示例：</li></ul><blockquote><p>1、<code>JS</code> 与 <code>OC</code> 约定好方法，如 <code>ShowMessageFromWKWebView:</code><br>2、<code>OC</code> 使用 <code>WKUserContentController</code> 的 <code>addScriptMessageHandler:name:</code> 方法设置代理并接收名为 <code>name</code> 的 <code>ShowMessageFromWKWebView</code> 的消息<br>3、<code>JS</code> 通过 <code>window.webkit.messageHandlers.scan.postMessage()</code> 的方式将方法 <code>scan</code> 发送消息到 <code>OC</code><br>4、<code>OC</code> 通过 <code>WKScriptMessageHandler</code> 的代理回调方法 <code>userContentController:didReceiveScriptMessage:</code> 中读取 <code>name</code> 为 <code>ShowMessageFromWKWebView</code> 的消息，消息数据在 <code>message.body</code> 中</p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupWKWebView&#123;</span><br><span class="line">    WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];</span><br><span class="line">    configuration.userContentController = [[WKUserContentController alloc] init];</span><br><span class="line">    </span><br><span class="line">    // 添加 JS 消息处理并设置代理</span><br><span class="line">    [configuration.userContentController addScriptMessageHandler:self name:@&quot;scan&quot;];</span><br><span class="line"></span><br><span class="line">    WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];</span><br><span class="line">    webView.UIDelegate = self;</span><br><span class="line">    [self.view addSubview:self.wkWebV];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>h5中要实现的代码</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function showMessageFromWKWebViewClick() &#123;</span><br><span class="line">    // JS 发送消息到 OC</span><br><span class="line">window.webkit.messageHandlers.ShowMessageFromWKWebView.postMessage(&#123;title:&#x27;WKWebView&#x27;, message:&#x27;测试WKWebView和OC交互&#x27;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>实现 <code>WKScriptMessageHandler</code> 代理方法，当接收到 <code>JS</code> 消息 <code>name</code> 为 <code>ShowMessageFromWKWebView</code> 时调用，会回调此代理方法：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - WKScriptMessageHandler</span><br><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123;</span><br><span class="line">// 从协议中我们可以看出这里使用了两个类 WKUserContentController 和 WKScriptMessage。WKUserContentController 可以理解为 调度器，WKScriptMessage 则是携带的数据。</span><br><span class="line">    </span><br><span class="line">    // OC 读取 JS 的消息数据</span><br><span class="line">    NSLog(@&quot;body:%@&quot;,message.body);</span><br><span class="line">    if ([message.name isEqualToString:@&quot;ShowMessageFromWKWebView&quot;]) &#123;</span><br><span class="line">        NSDictionary * dict = message.body;</span><br><span class="line">        NSString * messageStr = [dict objectForKey:@&quot;message&quot;];</span><br><span class="line">        NSString * titleStr = [dict objectForKey:@&quot;title&quot;];</span><br><span class="line">        NSLog(@&quot;messageStr:%@&quot;,messageStr);</span><br><span class="line">        NSLog(@&quot;titleStr:%@&quot;,titleStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="OC-调用-JS"><a href="#OC-调用-JS" class="headerlink" title="OC 调用 JS"></a>OC 调用 JS</h1><ul><li><code>OC</code> 调用 <code>JS</code> 方法用 <code>evaluateJavaScript</code>，可以 <code>传递参数</code>，将拼接字符串传递给 <code>JS</code>，拼接的字符串有格式要求：<code>方法名(&#39;参数&#39;)</code>，是 <code>WKWebView</code> 下的一个方法</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// OC传值JS的代码</span><br><span class="line">NSString * returnJSStr = [NSString stringWithFormat:@&quot;showMessageFromWKWebViewResult(&#x27;%@&#x27;)&quot;, @&quot;message传到OC成功，message传到OC成功，message传到OC成功，message传到OC成功，message传到OC成功，message传到OC成功&quot;];</span><br><span class="line">[self.wkWebV evaluateJavaScript:returnJSStr completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123;</span><br><span class="line">    NSLog(@&quot;%@,%@&quot;,result,error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></div><ul><li>JS 接收 OC 消息</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// JS 接收 OC 消息</span><br><span class="line">function showMessageFromWKWebViewResult(returnStr) &#123;</span><br><span class="line">    if (returnStr != null) &#123;</span><br><span class="line">        alert(&quot;JS已经收到OC的传值&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    document.getElementById(&quot;returnTextrea&quot;).value = returnStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="拦截-URL-实现自定义跳转功能"><a href="#拦截-URL-实现自定义跳转功能" class="headerlink" title="拦截 URL 实现自定义跳转功能"></a>拦截 URL 实现自定义跳转功能</h1><p>拦截 <code>URL</code> 是通过 <code>WKWebView</code> 的 <code>WKNavigationDelegate</code> 代理回调 <code>decidePolicyForNavigationAction</code> 方式实现的，例如：点击WebView按钮、cell等事件，去做一些功能</p><ul><li>在发送请求之前，决定是否跳转</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123;</span><br><span class="line">    // 获取当前的url</span><br><span class="line">    NSString * url = navigationAction.request.URL.absoluteString;</span><br><span class="line">    ZJLog(@&quot;url:%@&quot;,url);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>动态控制是否允许跳转和跳转到哪里</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -处理客服中心按钮的点击事件</span><br><span class="line">- (void)handleCallCenterClickActionWithUrl:(NSString *)url decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123;</span><br><span class="line">    ZJLog(@&quot;url:%@&quot;,url);</span><br><span class="line">    if ([url containsString:@&quot;cloudapp://goodsDetail?goodsId=&quot;]) &#123; // 跳转商品详情</span><br><span class="line">        // 去掉前缀</span><br><span class="line">        NSArray * arr = [url componentsSeparatedByString:@&quot;goodsId=&quot;];</span><br><span class="line">        NSString * goodsId = arr.lastObject;</span><br><span class="line">        SFGoodsDetailVC * goodsDetailVc = [SFGoodsDetailVC new];</span><br><span class="line">        goodsDetailVc.goodsId = [goodsId integerValue];</span><br><span class="line">        goodsDetailVc.enterType = GoodsDetailEnterType_Normal;</span><br><span class="line">        goodsDetailVc.souce = CommodityDetailSouce_Banner; // 首页Banner</span><br><span class="line">        [self.navigationController pushViewController:goodsDetailVc animated:YES];</span><br><span class="line">        // 拦截跳转</span><br><span class="line">        decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">    &#125; else &#123; // 其他</span><br><span class="line">        // 不拦截跳转</span><br><span class="line">        decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="KVO-监听"><a href="#KVO-监听" class="headerlink" title="KVO 监听"></a>KVO 监听</h1><ul><li>监听标题 title</li></ul><p>通过 <code>KeyPath路由</code> 监听 <code>title</code> 可以 动态修改 <code>title</code></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 监听标题</span><br><span class="line">[self.wkWebV zj_addObserver:self forKeyPath:@&quot;title&quot;];</span><br></pre></td></tr></table></figure></div><ul><li>监听进度 <code>estimatedProgress</code></li></ul><p>通过 <code>KeyPath路由</code> 监听  <code>estimatedProgress</code> 可以做 <code>进度条</code></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 添加监听</span><br><span class="line">[self.wkWebV zj_addObserver:self forKeyPath:@&quot;estimatedProgress&quot;];</span><br></pre></td></tr></table></figure></div><ul><li>监听 URL</li></ul><p>通过 <code>KeyPath路由</code> 监听 <code>URL</code>，即在跳转过程中 <code>拦截URL</code>，可以去做一些 动态跳转到 <code>OC</code> 页面</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 监听跳转</span><br><span class="line">[self.wkWebV zj_addObserver:self forKeyPath:@&quot;URL&quot;];</span><br></pre></td></tr></table></figure></div><ul><li>监听的方式代码实现</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -进度的监听</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    NSString * url = self.wkWebV.URL.absoluteString;</span><br><span class="line">    ZJLog(@&quot;url:%@&quot;,url);</span><br><span class="line">    if (object == self.wkWebV &amp;&amp; [keyPath isEqualToString:@&quot;title&quot;]) &#123; // 标题</span><br><span class="line">        if (self.wkWebV.title.length &gt; 0) &#123;</span><br><span class="line">            [self.navStatusV.titleL setTitle:self.wkWebV.title titleColor:kMainTextColor font:16 isBlod:YES];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if (object == self.wkWebV &amp;&amp; [keyPath isEqualToString:@&quot;estimatedProgress&quot;]) &#123; // 进度条</span><br><span class="line">        CGFloat newProgress = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue];</span><br><span class="line">//        ZJLog(@&quot;newProgress:%f&quot;,newProgress);</span><br><span class="line">        if (newProgress &lt;= 0.05f) &#123;</span><br><span class="line">            newProgress = 0.05f;</span><br><span class="line">        &#125;</span><br><span class="line">        [self.progressV changeProgressValue:newProgress];</span><br><span class="line">    &#125;else if (object == self.wkWebV &amp;&amp; [keyPath isEqualToString:@&quot;/cloudApp/customer/service&quot;]) &#123;</span><br><span class="line">        // 跳转到客服中心</span><br><span class="line">        ZJLog(@&quot;跳转到客服中心&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 &lt;code&gt;iOS&lt;/code&gt; 开发中，&lt;code&gt;iOS&lt;/code&gt; 和 &lt;code&gt;JS&lt;/code&gt; 交互是每个程序猿必须掌握</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习15：国际化/多语言适配</title>
    <link href="https://www.bboyzj.cn/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A015%EF%BC%9A%E5%9B%BD%E9%99%85%E5%8C%96-%E5%A4%9A%E8%AF%AD%E8%A8%80%E9%80%82%E9%85%8D/"/>
    <id>https://www.bboyzj.cn/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A015%EF%BC%9A%E5%9B%BD%E9%99%85%E5%8C%96-%E5%A4%9A%E8%AF%AD%E8%A8%80%E9%80%82%E9%85%8D/</id>
    <published>2023-03-14T22:27:39.000Z</published>
    <updated>2023-03-19T00:20:25.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>项目开发中不同语言环境需要进行多语言适配，例如：中文、英语、法语、俄语、葡萄牙语等</p><ul><li>纯代码界面开发时，直接添加本地化语言文件，并针对键值对获取即可</li></ul><p>下面我们来介绍如何国际化：</p><h1 id="全局添加需要适配的多语言"><a href="#全局添加需要适配的多语言" class="headerlink" title="全局添加需要适配的多语言"></a>全局添加需要适配的多语言</h1><p>PROHECT -&gt; Info -&gt; Localizetions 下：选择 + 号添加：</p><blockquote><p>Chinese，Simplified：中文简体<br>Chinese，Traditional：中文繁体<br>English - Development Localization：英语<br>French(fr)：法语<br>Russian：俄语<br>Arabic：阿拉伯语<br>…</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150647485.png"                                     ></p><p>添加完成之后的效果：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172026085.png"                                     ></p><p>细心的朋友会发现如今 <code>English</code> 后面是 <code>1 File Localized</code>，这是因为 <code>英语</code> 是系统默认加入的，并且同一时刻为 <code>Main.storyboard</code> 和 <code>LaunchScreen.storyboard</code> 设置了多语言</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172026300.png"                                     ></p><h1 id="纯代码本地化"><a href="#纯代码本地化" class="headerlink" title="纯代码本地化"></a>纯代码本地化</h1><ol><li>创建本地化文件</li></ol><p>默认文件名为 <code>Localizable</code> ，不要去修改</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172026376.png"                                     ></p><ul><li>点击 Next，Save <code>As：Localizable</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172026092.png"                                     ></p><p><code>Localizable.strings</code> 就是你需要的本地化文化</p><ul><li>关联对应的本地化语言</li></ul><p>点击右侧的 <code>Localizable</code>，关联本地化语言</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172027552.png"                                     ></p><ul><li>勾选需要关联的本地化语言，全部勾选</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172027404.png"                                     ></p><ol start="2"><li>在本地化文件中设置 <code>Key-Value</code></li></ol><blockquote><p>注意：不要忘记行末的 <code>;</code> 号</p></blockquote><p>分别在对应的本地化语言文件中，设置不同的 <code>Key-Value</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172027768.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172027106.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172027605.png"                                     ></p><ol start="3"><li>调用本地化</li></ol><ul><li><p>使用 <code>NSLocalizedString</code> 函数来访问 <code>Localizable.strings</code> 资源文件</p></li><li><p><code>NSLocalizedString</code> 函数第一个参数为对应的 <code>键名</code>，第二个是自定义的说明，给开发或翻译人员看的。</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 调用字符串对应的本地化符号</span><br><span class="line">let title = NSLocalizedString(&quot;title&quot;, comment: &quot;title&quot;)</span><br><span class="line">MyLog(message: title)</span><br></pre></td></tr></table></figure></div><blockquote><p>这种设置完之后仅仅能让应用随系统的语言进行切换，而用户不能手进行切换</p></blockquote><h1 id="图片本地化"><a href="#图片本地化" class="headerlink" title="图片本地化"></a>图片本地化</h1><ol><li>选中需要本地化的图片，同上面一样点击 <code>Localize...</code> ，创建本地化 <code>图片资源文件</code></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172028648.png"                                     ></p><ol start="2"><li>关联你需要本地化的语言</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172028577.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172029322.png"                                     ></p><ol start="3"><li>图片 <code>Show In Finder</code>，可以看到在 中文和英文资源下都有这个图片，把需要替换的图片换掉即可</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172029513.png"                                     ></p><ol start="4"><li>图片使用和平常一样</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let img = UIImage(named: &quot;loading.png&quot;)</span><br></pre></td></tr></table></figure></div><h1 id="App-名称的-本地化"><a href="#App-名称的-本地化" class="headerlink" title="App 名称的 本地化"></a>App 名称的 本地化</h1><ol><li>要实现应用名称根据语言环境显示不一样的名称，只需要创建 <code>InfoPlist.strings</code> 文件，创建 <code>InfoPlist.strings</code> 并关联语言</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172029520.png"                                     ></p><ol start="2"><li>获取info.plist中的key</li></ol><p>点击 <code>Infoplist</code> 右键选择 <code>Open As -&gt; Source Code</code>，查看我们所要获取权限的原始key。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172029052.png"                                     ></p><p>新版Xcode获取不出来数据不用急，去代码中将info打印出来，拿到key效果一样。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let infoPlist = Bundle.main.infoDictionary</span><br><span class="line">MyLog(message: infoPlist)</span><br></pre></td></tr></table></figure></div><ol start="3"><li>本地化文件中，对key-value进行配置</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Chinese,Simplified</span><br><span class="line">&quot;CFBundleDisplayName&quot; = &quot;中图云书房&quot;</span><br><span class="line"></span><br><span class="line">// Englist</span><br><span class="line">&quot;CFBundleDisplayName&quot; = &quot;SRSF&quot;</span><br></pre></td></tr></table></figure></div><ol start="4"><li>运行App，然后切换手机语言为英文，会发现软件名称变成了英文</li></ol><h1 id="Xcode中切换语言"><a href="#Xcode中切换语言" class="headerlink" title="Xcode中切换语言"></a>Xcode中切换语言</h1><p>为了调试国际化，我们除了可以进入 <code>模拟器或真机</code> 切换系统语言，也可以在 <code>Xcode</code> 中配置相关项，使 <code>Debug</code> 环境下运行时预览不同语言和地区 <code>App的界面效果</code></p><ol><li>选择 Product -&gt; Scheme -&gt; Edit Scheme</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172030056.png"                                     ></p><ol start="2"><li>切换语言后，运行工程</li></ol><h1 id="应用内切换语言"><a href="#应用内切换语言" class="headerlink" title="应用内切换语言"></a>应用内切换语言</h1><p>纯代码本地化只能跟随系统进行切换，并不能手动进行切换，下面先介绍一下相关宏</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 尾随系统切换, 多语言文件名称必须是Localizable</span><br><span class="line">NSLocalizedString(&quot;title&quot;, nil);</span><br><span class="line"></span><br><span class="line">// 以下三个都能够手动设置多语言</span><br><span class="line">// 第一个參数:是多语言中的key</span><br><span class="line">// 第二个參数:是多语言文件的名字</span><br><span class="line">// 第三个參数:是对key的自定义的说明,一般传nil</span><br><span class="line">NSLocalizedStringFromTable(@&quot;title&quot;, @&quot;Localizable&quot;, nil);</span><br><span class="line">// 指定多语言文件名称和bundle</span><br><span class="line">NSLocalizedStringFromTableInBundle(@&quot;title&quot;, @&quot;Localizable&quot;, bundle, nil);</span><br><span class="line">// 在上面的基础上添加一个默认值的參数</span><br><span class="line">NSLocalizedStringWithDefaultValue(@&quot;title&quot;, @&quot;Localizable&quot;, bundle, @&quot;label&quot;, nil);</span><br></pre></td></tr></table></figure></div><ol><li>Resources -&gt; Show In Finder后，发现每一种语言都有对应的文件目录，后缀是 <code>.lproj</code></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172031421.png"                                     ></p><blockquote><p>总结：<br>1、因此 <code>ar.lproj、en.lproj、fr.lproj、ru.lproj、zh-Hans.lproj、zh-Hant.lproj</code> 为我们可以从本地获取到的 <code>语言资源文件</code><br>2、在 <code>App</code> 内切换语言的时候，实际上就是获取 <code>语言资源文件</code> 的 <code>Localizable.strings</code> 文件</p></blockquote><ol start="2"><li>将所有的 <code>语言文件</code> 设置成 <code>字符串类型的枚举</code> 并且有初始值 <code>rawValue</code>， 获取 <code>Localizable.strings</code></li></ol><ul><li>获取 <code>某语言</code> 文件的 <code>value值</code>，相应的想要切换语言的话，直接切换 <code>pathForResource</code> 面的 <code>参数</code> 就可以</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 本地化语言类型</span><br><span class="line">enum LocalizedType: String &#123;</span><br><span class="line">    // 字符串需要对应本地的国际化文件名 .lproj</span><br><span class="line">    case English = &quot;en&quot; // 英语</span><br><span class="line">    case ChineseHans = &quot;zh-Hans&quot; // 简体中文</span><br><span class="line">    case ChineseHant = &quot;zh-Hant&quot; // 繁体中文</span><br><span class="line">    case Russian = &quot;ru&quot; // 俄语</span><br><span class="line">    case Frcench = &quot;fr&quot; // 法语</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取语言文件路径(可以为：en/zh-Hans/zh-Hant/fr/ru 任意一个)</span><br><span class="line">let languageBundlePath = Bundle.main.path(forResource: LocalizedType.English, ofType: &quot;lproj&quot;)</span><br><span class="line">// 获取语言文件路径下对应 key 的 value</span><br><span class="line">let value = Bundle(path: languageBundlePath ?? &quot;&quot;)?.localizedString(forKey: &quot;title&quot;, value: nil, table: &quot;ZJLocalizable&quot;)</span><br><span class="line">MyLog(message: value) </span><br></pre></td></tr></table></figure></div><ol start="3"><li>根据上面的思路，我们可以用 <code>NSUserDefaults</code> 缓存当前的 <code>语言</code>，以便 <code>第一次启动程序</code> 或 <code>程序退出去后</code>，下次进入继续使用上次关闭程序的语言。</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 本地化语言类型</span><br><span class="line">enum LocalizedType: String &#123;</span><br><span class="line">    // 字符串需要对应本地的国际化文件名 .lproj</span><br><span class="line">    case English = &quot;en&quot; // 英语</span><br><span class="line">    case ChineseHans = &quot;zh-Hans&quot; // 简体中文</span><br><span class="line">    case ChineseHant = &quot;zh-Hant&quot; // 繁体中文</span><br><span class="line">    case Russian = &quot;ru&quot; // 俄语</span><br><span class="line">    case Frcench = &quot;fr&quot; // 法语</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化启动时语言</span><br><span class="line">func initLaunchLanguage() &#123;</span><br><span class="line">    // 获取上一次设置的语言</span><br><span class="line">    var languageType = kUserDefault.getInfo(key: &quot;appLanguage&quot;)</span><br><span class="line">    // 如果是第一次启动</span><br><span class="line">    if languageType == nil &#123;</span><br><span class="line">        // 获取系统第一个首选语言</span><br><span class="line">        let systemLanguage = Locale.preferredLanguages.first!</span><br><span class="line">        MyLog(message: systemLanguage)</span><br><span class="line">        if systemLanguage.hasPrefix(LocalizedType.English.rawValue) &#123;</span><br><span class="line">            // 英文</span><br><span class="line">            languageType = LocalizedType.English.rawValue</span><br><span class="line">        &#125;else if systemLanguage.hasPrefix(LocalizedType.ChineseHans.rawValue) &#123;</span><br><span class="line">            // 简体中文</span><br><span class="line">            languageType = LocalizedType.ChineseHans.rawValue</span><br><span class="line">        &#125;else if systemLanguage.hasPrefix(LocalizedType.ChineseHant.rawValue) &#123;</span><br><span class="line">            // 繁体中文</span><br><span class="line">            languageType = LocalizedType.ChineseHant.rawValue</span><br><span class="line">        &#125;else if systemLanguage.hasPrefix(LocalizedType.Frcench.rawValue) &#123;</span><br><span class="line">            // 法文</span><br><span class="line">            languageType = LocalizedType.Frcench.rawValue</span><br><span class="line">        &#125;else if systemLanguage.hasPrefix(LocalizedType.Russian.rawValue) &#123;</span><br><span class="line">            // 俄文</span><br><span class="line">            languageType = LocalizedType.Russian.rawValue</span><br><span class="line">        &#125;</span><br><span class="line">        // 赋值给上一次设置的语言类型</span><br><span class="line">        languageType = systemLanguage</span><br><span class="line">    &#125;</span><br><span class="line">    // 缓存语言</span><br><span class="line">    kUserDefault.saveInfo(value: languageType!, key: &quot;appLanguage&quot;)</span><br><span class="line">    // 设置bundle</span><br><span class="line">    setCurrentBundle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>注：<br>每次设置完语言，我们跟要更新一下 <code>bundle</code>，以便随时获取 <code>key-value</code></p></blockquote><ol start="3"><li>接下来，我们要根据缓存的语言来获取本地语言资源文件，赋值给一个全局的 <code>bundle</code>，以便随时可以通过 <code>bundle</code> 来拿到具体语言文件下的 <code>key-value</code></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 设置bundle</span><br><span class="line">func setCurrentBundle() &#123;</span><br><span class="line">    // 拿到当前语言</span><br><span class="line">    let currentLanguageType = kUserDefault.getInfo(key: &quot;appLanguage&quot;) as! String</span><br><span class="line">    // 获取本地语言资源路径</span><br><span class="line">    let languageBundlePath = Bundle.main.path(forResource: currentLanguageType, ofType: &quot;lproj&quot;)</span><br><span class="line">//        MyLog(message: languageBundlePath)</span><br><span class="line">    guard languageBundlePath != nil else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取 bundle</span><br><span class="line">    let languageBundle = Bundle(path: languageBundlePath!)</span><br><span class="line">    guard languageBundle != nil else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // 赋值给全局的 bundle</span><br><span class="line">    currentBundle = languageBundle</span><br><span class="line">//        MyLog(message: currentBundle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="4"><li>根据 <code>key</code> 获取 <code>value</code></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取要显示的文本</span><br><span class="line">func getLanguageValueWithKey(key: String) -&gt; String &#123;</span><br><span class="line">    let bundle = LocalizableManager.sharedManager.currentBundle</span><br><span class="line">    let value = bundle?.localizedString(forKey: key, value: nil, table: nil)</span><br><span class="line">    return value ?? &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="5"><li>至此，我们的 <code>App内+系统</code> 切换国际化语言，大功告成！！！</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;项目开发中不同语言环境需要进行多语言适配，例如：中文、英语、法语、俄语、葡萄牙语等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;纯代码界面开发时，直接添加本地</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Blog-06：阿里云图床</title>
    <link href="https://www.bboyzj.cn/2023/03/15/Blog%E6%90%AD%E5%BB%BA/Blog-06%EF%BC%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9B%BE%E5%BA%8A/"/>
    <id>https://www.bboyzj.cn/2023/03/15/Blog%E6%90%AD%E5%BB%BA/Blog-06%EF%BC%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9B%BE%E5%BA%8A/</id>
    <published>2023-03-14T21:11:50.000Z</published>
    <updated>2023-03-14T22:11:14.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近Gitee突然加了防盗链，导致基于Gitee的图床直接GG了！好家伙还带这样玩的，数据要是没有备份真的心惊胆跳的，不白嫖了，直接付费转战阿里云OSS去。</p><p>​分享一下搭建过程:<br>​</p><h1 id="阿里云OSS开通及配置"><a href="#阿里云OSS开通及配置" class="headerlink" title="阿里云OSS开通及配置"></a>阿里云OSS开通及配置</h1><p>​<br>​1、开通及购买服务包<br>​<br>​登录 <a href="https://www.aliyun.com/?utm_content=se_1013083955">阿里云官网</a>，开通对象存储OSS，开通对象存储OSS不用扣费，只有使用OSS才需要扣费。<br>​​<br>​​<br>​​<img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150611729.png"></p><p>2、OSS有两种扣费方式（产品计费详细介绍）：</p><ul><li><p><a href="https://help.aliyun.com/document_detail/450471.html">按量付费</a></p></li><li><p><a href="https://help.aliyun.com/document_detail/48291.html">资源包</a></p></li></ul><p>根据需要按需购买对应的 <code>资源包</code> 即可，作为一个只是搭建个人向图床的我，只需要购买一个 <code>40GB</code> 的《标准(LRS)存储包》即可，半年只要4.98，四舍五入相当于白嫖……</p><p>我每个月也用不了多少流量，《下行流量包》先暂时不购买，要是后续那天顶不住后再考虑购买即可。</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610052.png"></p><ul><li>根据需求选择 <code>购买时长</code>，最后支付</li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610166.png"></p><blockquote><p>注意事项：<br>记得给阿里云账户充值！！！别到时候欠费停用了</p></blockquote><p>3、基础配置</p><ul><li>创建 Bucket</li></ul><p>打开 <a href="https://oss.console.aliyun.com/bucket">OSS管理控制台Bucket页面</a>，按需创建一个Bucket。</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610062.png"></p><blockquote><p>Bucket 名称：bboy-blog（自定义）<br>地域：华北2（选择最近）<br>存储类型：标准存储<br>读写权限：公共读<br>其他：默认不改动</p></blockquote><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610598.png"></p><p>创建完成你的 <code>Bucket</code> 就在列表显示了</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610981.png"></p><ul><li>找到你的地域节点</li></ul><p>点击你的 <code>bucket</code>，然后点击 <code>bucket</code> 下的 <code>概览</code>，在 <code>访问域名</code> 一栏找你的 <code>地域节点</code>，后面会用到</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150609099.png"></p><ul><li>找到你的 key</li></ul><p>右上角找到头像，在弹出框里选择 <code>AccessKey</code> 管理，在弹出框选择 <code>继续使用</code></p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150609401.png"></p><p>进入后，创建一个新的 <code>AccessKey</code>，在弹出框里，复制你的 <code>AccessKeyId和AccessKeySecret</code>，保存好，以便后续使用</p><h1 id="配置-picgo"><a href="#配置-picgo" class="headerlink" title="配置 picgo"></a>配置 picgo</h1><p>1、打开picgo，在图床设置里选择 <code>阿里云OSS</code>，一招以下步骤填写信息</p><blockquote><p>设定Keyld：必填，填写刚刚获得的AccessKeyID<br>设定KeySecret：必填，填写AccessKeyIDSecret<br>设定Bucket：必填 bboy-blog，填写bucket名称（这里填写的是bucket名称，不是浏览器里的域名）<br>确认存储区域：必填 oss-cn-beijing，填写你的地域节点，注意复制的格式<br>设定存储路径：选填，其实就是自定义一个文件夹的名字，以&#x2F;结尾，它会自动在你的bucket里面创建一个文件夹，并把图片上传进去<br>指定自定义域名：选填</p></blockquote><p>2、配置完成之后，<code>确定</code>，并点击 <code>设置为默认图床</code></p><p>3、PicGo设置</p><p>打开 <code>时间戳重命名</code> 和 <code>上传后自动赋值URL</code> 选项</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150608665.png"></p><p>4、至此，你已经配置成功了，可以随意用 <code>PicGo</code> 上传图片了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近Gitee突然加了防盗链，导致基于Gitee的图床直接GG了！好家伙还带这样玩的，数据要是没有备份真的心惊胆跳的，不白嫖了，直接付费转战</summary>
      
    
    
    
    <category term="Blog" scheme="https://www.bboyzj.cn/categories/Blog/"/>
    
    
    <category term="博客搭建" scheme="https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习01：自定义Log</title>
    <link href="https://www.bboyzj.cn/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A001%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89Log/"/>
    <id>https://www.bboyzj.cn/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A001%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89Log/</id>
    <published>2023-03-14T20:26:24.000Z</published>
    <updated>2023-03-18T23:58:36.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打印文件名、方法、行数"><a href="#打印文件名、方法、行数" class="headerlink" title="打印文件名、方法、行数"></a>打印文件名、方法、行数</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1.获取打印所在的文件</span><br><span class="line">let file = (#file as NSString).lastPathComponent;</span><br><span class="line">print(file);</span><br><span class="line"></span><br><span class="line">// 2.获取打印所在的方法</span><br><span class="line">let function = #function</span><br><span class="line">print(function);</span><br><span class="line"></span><br><span class="line">// 3.获取打印所在的行号</span><br><span class="line">let line = #line;</span><br><span class="line">print(line)</span><br></pre></td></tr></table></figure></div><h1 id="全局化"><a href="#全局化" class="headerlink" title="全局化"></a>全局化</h1><p><code>swift</code> 中的 全局函数：写在单独的一个 <code>.swift</code> 文件下即可，比如：Common.swift</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func ZNLog&lt;T&gt;(message:T, file:String = #file, funcName:String = #function, lineNum:Int = #line) &#123;</span><br><span class="line"></span><br><span class="line">     let fileName = (file as NSString).lastPathComponent;</span><br><span class="line"></span><br><span class="line">     print(&quot;[文件名:\(fileName)]:[函数名:\(funcName)]:[行数:\(lineNum)]-打印内容:\n\(message)&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="配置DeBug下打印，Release-下不打印"><a href="#配置DeBug下打印，Release-下不打印" class="headerlink" title="配置DeBug下打印，Release 下不打印"></a>配置DeBug下打印，Release 下不打印</h1><ul><li><code>Swift</code> 没有宏定义，只能通过添加配置字段，<code>Build Settings -&gt; Other Swift Flags</code> 下添加 <code>-D DEBUG</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303190758719.png"                                     ></p><h1 id="最终写法"><a href="#最终写法" class="headerlink" title="最终写法"></a>最终写法</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 自定义Log</span><br><span class="line">func MyLog&lt;T&gt;(message: T,file: String = #file, funcName: String = #function, lineNum: Int = #line) &#123;</span><br><span class="line">#if DEBUG</span><br><span class="line">    let fileName = (file as NSString).lastPathComponent</span><br><span class="line">    print(&quot;[文件名:\(fileName)]:[函数名:\(funcName)]:[行数:\(lineNum)]-打印内容:\n\(message)&quot;);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;打印文件名、方法、行数&quot;&gt;&lt;a href=&quot;#打印文件名、方法、行数&quot; class=&quot;headerlink&quot; title=&quot;打印文件名、方法、行数&quot;&gt;&lt;/a&gt;打印文件名、方法、行数&lt;/h1&gt;&lt;div class=&quot;highlight-container&quot; data</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习49：Any</title>
    <link href="https://www.bboyzj.cn/2023/03/14/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A049%EF%BC%9AAny/"/>
    <id>https://www.bboyzj.cn/2023/03/14/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A049%EF%BC%9AAny/</id>
    <published>2023-03-13T22:34:03.000Z</published>
    <updated>2023-03-13T22:49:03.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Swift中，Objective-C中的 <code>id</code> 类型现在映射成了Swift中的 <code>Any</code> 类型，它可以代表任何类型的值，无论是类、枚举、结构体还是任何其他Swift类型。这种变化使得Swift中的Objective-C API更加灵活，因为Swift定义的值类型可以传递给Objective-C API并作为Swift中的类型获取，从而无需手动“框选”类型（本人理解为转换、解包）。</p><h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><p>对于Swift中哈希类的集合，例如Dictionary和Set，有一个新类型 <code>AnyHashable</code>，可以保存任何遵守Swift中 <code>Hashable</code> 协议的类型的值。。<code>Array</code> 对应 <code>Any</code> </p><h1 id="非集合类型"><a href="#非集合类型" class="headerlink" title="非集合类型"></a>非集合类型</h1><ul><li><p>属性列表，JSON和用户信息字典在Cocoa框架中很常见，Cocoa框架将这些表示为非类型化集合。</p></li><li><p>Swift可以导入 <code>Cocoa API</code> 接受 <code>Any或AnyHashable</code> 类型的集合，所以我们可以用[AnyHashable：Any]</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Swift 3</span><br><span class="line">struct State &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var abbreviation: String</span><br><span class="line">    var population: Int</span><br><span class="line"></span><br><span class="line">    // Change the dictionary type to [AnyHashable: Any] here...</span><br><span class="line">    var asPropertyList: [AnyHashable: Any] &#123;</span><br><span class="line">        var result: [AnyHashable: Any] = [:]</span><br><span class="line">        // No implicit conversions necessary, since String and Int are subtypes</span><br><span class="line">        // of Any and AnyHashable</span><br><span class="line">        result[&quot;name&quot;] = self.name</span><br><span class="line">        result[&quot;abbreviation&quot;] = self.abbreviation</span><br><span class="line">        result[&quot;population&quot;] = self.population</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let california = State(name: &quot;California&quot;,</span><br><span class="line">                       abbreviation: &quot;CA&quot;,</span><br><span class="line">                       population: 39_000_000)</span><br><span class="line">// ...and you can still use it with Cocoa API here</span><br><span class="line">Notification(name: &quot;foo&quot;, object: nil,</span><br><span class="line">             userInfo: california.asPropertyList)</span><br></pre></td></tr></table></figure><h1 id="未链接上下文的显式转换"><a href="#未链接上下文的显式转换" class="headerlink" title="未链接上下文的显式转换"></a>未链接上下文的显式转换</h1><p>在某些确定的情况下，Swift不能自动桥接C和Objective-C。 例如，一些C和Cocoa API使用id *指针作为“out”或“in-out”参数，并且由于Swift不能静态地确定指针的使用方式，因此它不能对内存中的值自动执行桥接转换 。 在这种情况下，指针仍将显示为UnsafePointer <AnyObject>。 如果您需要使用到这些不能自动桥接转换的API，您可以使用显式桥接转换，在代码中使用 <code>as Type</code> 或 <code>as AnyObject</code> 显式转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ObjC</span><br><span class="line">@interface Foo</span><br><span class="line">- (void)updateString:(NSString **)string;</span><br><span class="line">- (void)updateObject:(id *)obj;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Swift</span><br><span class="line">func interactWith(foo: Foo) -&gt; (String, Any) &#123;</span><br><span class="line">    var string = &quot;string&quot; as NSString // explicit conversion</span><br><span class="line">    foo.updateString(&amp;string) // parameter imports as UnsafeMutablePointer&lt;NSString&gt;</span><br><span class="line">    let finishedString = string as String</span><br><span class="line"></span><br><span class="line">    var object = &quot;string&quot; as AnyObject</span><br><span class="line">    foo.updateObject(&amp;object) // parameter imports as UnsafeMutablePointer&lt;AnyObject&gt;</span><br><span class="line">    let finishedObject = object as Any</span><br><span class="line"></span><br><span class="line">    return (finishedString, finishedObject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，Objective-C中的协议在Swift中仍然是类约束（及只有类才可以遵守协议），所以你不能让Swift中的结构体或枚举直接遵守Objective-C中的协议或者是使用轻量级的泛型类。 当您需要使用到这些协议和API时应该像这样 <code>String as NSString</code>、<code>Array as NSArray</code> 进行显式转换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在Swift中，Objective-C中的 &lt;code&gt;id&lt;/code&gt; 类型现在映射成了Swift中的 &lt;code&gt;Any&lt;/code&gt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习48：ARC</title>
    <link href="https://www.bboyzj.cn/2023/03/13/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A048%EF%BC%9AARC/"/>
    <id>https://www.bboyzj.cn/2023/03/13/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A048%EF%BC%9AARC/</id>
    <published>2023-03-13T09:44:18.000Z</published>
    <updated>2023-03-13T22:34:49.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h1><ul><li><p>swift 使用 <code>自动引用计数（ARC）</code> 来跟踪并管理应用使用的 <code>内存</code>。</p></li><li><p><code>引用计数</code> 只应用在 <code>类</code> 的实例。</p></li><li><p><code>结构体和枚举</code> 都是 <code>值类型</code>，并非引用类型，不是以引用的方式来 <code>存储和传递</code> 的</p></li></ul><h1 id="ARC-如何工作"><a href="#ARC-如何工作" class="headerlink" title="ARC 如何工作"></a>ARC 如何工作</h1><ul><li><p>每次创建一个类的实例，<code>ARC</code> 就会分配一个内存块，用来存储这个实例的相关信息。这个内存块保存着实例的类型，以及这个实例相关的属性的值</p></li><li><p>当实例不再被使用时，ARC 是否这个实例使用的内存，使这块内存可做它用。保证了实例不再被使用时，不会占用内存空间</p></li><li><p>但是，如果 <code>ARC</code> 释放了仍在使用的实例，那么你就不能再访问这个实例的苏醒或者调用它的方法。如果你仍然视图访问这个实例，应用极有可能会崩溃</p></li><li><p>为了保证不会发生上述的情况， <code>ARC</code> 跟踪类实例的相关属性、常量及变量的数量。只要有一个有效的引用，<code>ARC</code> 都不会释放这个实例</p></li><li><p>为了让这个变成现实，只要你将一个类的实例赋值给一个属性或常量或变量，这个属性、常量、变量就是这个实例的 <code>强引用（strong reference）</code>。之所以称之为 <code>强引用</code>，是因为它持有这实例，并且只要这个强引用还存在，就不能销毁实例</p></li></ul><h1 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h1><ul><li><p>在两个类实例彼此保持对方的强应用，使得每个实例都使对方保持有效时会发生这种情况。我们称之为强引用环</p></li><li><p>通过用 <code>弱引用或者无主引用</code> 来 <code>取代强引用</code>，我们可以 <code>解决强引用环问题</code></p></li></ul><h1 id="解决循环引用"><a href="#解决循环引用" class="headerlink" title="解决循环引用"></a>解决循环引用</h1><ul><li><p><code>弱引用和无主引用</code> 允许引用环中的一个实例引用另外一个实例，但 <code>不是强引用</code>。因此实例可以互相引用但是不会产生强引用</p><ul><li><p><code>弱引用不会增加实例的引用计数</code>，因此不会阻止ARC销毁被引用的实例。这种特性使得引用不会编程强引用环。声明属性或者变量的时候，关键字 <code>weak</code> 表明引用为弱引用。</p></li><li><p><code>弱引用只能声明为变量类型</code>，因为运行时它的值可能会变。弱引用绝对不能声明为常量</p></li><li><p>因为弱引用可以没有值，所以声明弱引用的时候 <code>必须是可选类型</code> 的。在swift语言中，推荐使用可选类型作为可能没有值的引用类型</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person: Person?</span><br><span class="line"></span><br><span class="line">weak var student: Student?    </span><br></pre></td></tr></table></figure><ul><li><p>对于生命周期中引用会变nil的实例，使用弱引用；对于初始化时赋值之后引用再也不会赋值为nil的实例，使用无主引用</p><ul><li><p>和弱引用相似，<code>无主引用</code> 也不强持有实例。但是和弱引用不同的是，<code>无主引用默认始终有值</code>。因此，无主引用只能定义为非可选类型。在属性、变量前添加 <code>unowned</code> 关键字，可以声明一个无主引用</p></li><li><p>因为是 <code>可选类型</code>，因此当使用无主引用时，不需要展开，可直接访问。不过非可选类型变量不能赋值为 <code>nil</code>，因此当实例被销毁的时候，ARC无法将引用赋值为 <code>nil</code></p></li><li><p>当实例被销毁后，试图访问该实例的无主引用会触发运行时错误。使用无主引用时请确保引用始终指向一个未销毁的实例</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class City &#123;</span><br><span class="line">    // 无主引用</span><br><span class="line">    unowned let country: Country</span><br><span class="line">    init(country: Country) &#123;</span><br><span class="line">        self.country = country</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Country &#123;</span><br><span class="line">    var capitaCity: City!</span><br><span class="line">    init(capitaCity: City) &#123;</span><br><span class="line">        self.capitaCity = capitaCity</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="闭包引用循环"><a href="#闭包引用循环" class="headerlink" title="闭包引用循环"></a>闭包引用循环</h1><p>将一个闭包赋值给类实例的某个属性，并且这个闭包使用了实例，这样也会产生强引用环。这个闭包可能反问了实例的某个属性，如果 <code>self.someProperty</code>，或者调用了实例的某个方法 <code>self.someMethod</code>。这两种情况都导致了闭包使用 <code>self</code>，从而产生了循环引用</p><p>解决：</p><ul><li><p>定义占有列表-占有列表中的每个元素都是由 <code>weak</code> 或者 <code>unowend</code> 关键字和实例的引用（如 <code>self</code> 或 <code>someInstance</code>）组成。每一对都在括号中，通过逗号分开</p></li><li><p>当闭包和占有的实例总是互相引用时并且总是同时销毁时，将闭包内的占有定义为无主引用</p></li><li><p>相反的，当占有引用有时可能会是 <code>nil</code> 时，将闭包内的占有定义为 弱引用</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lazy var someClosure = &#123;</span><br><span class="line">    [unowned self, weak delete = self.delete]</span><br><span class="line">    (index: Int,stringToProcess: String) -&gt; String in</span><br><span class="line">    </span><br><span class="line">    // closure body goes here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ARC&quot;&gt;&lt;a href=&quot;#ARC&quot; class=&quot;headerlink&quot; title=&quot;ARC&quot;&gt;&lt;/a&gt;ARC&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;swift 使用 &lt;code&gt;自动引用计数（ARC）&lt;/code&gt; 来跟踪并管理应用使用的 &lt;code&gt;内存&lt;/c</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习47:多线程</title>
    <link href="https://www.bboyzj.cn/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A047%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://www.bboyzj.cn/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A047%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-03-12T14:52:33.000Z</published>
    <updated>2023-03-13T09:40:14.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为什么几乎所有的GUI框架都是单线程的？：处理问题代价大于收益</p><h1 id="多线程可以做什么"><a href="#多线程可以做什么" class="headerlink" title="多线程可以做什么"></a>多线程可以做什么</h1><ul><li>网络请求</li><li>IO：读写文件</li><li>计算</li><li>数据模型转换</li><li>….</li></ul><h1 id="多线程编程的方式"><a href="#多线程编程的方式" class="headerlink" title="多线程编程的方式"></a>多线程编程的方式</h1><ul><li>Thread</li><li>Operation 和 OperationQueue</li><li>GCD</li></ul><h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><ul><li>三种中最轻量级的，自己管理线程的生命周期和线程同步</li><li>线程同步对数据加锁有一定的系统开销</li></ul><p>1、快捷方式创建</p><ul><li>detachNewThread(_ block: @escaping @Sendable () -&gt; Void)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">// 不希望程代码在主线完成后退出，因为很多线程需要异步操作</span><br><span class="line">PlaygroundPage.current.needsIndefiniteExecution = true</span><br><span class="line"></span><br><span class="line">for i in 0...10 &#123;</span><br><span class="line">    Thread.detachNewThread &#123;</span><br><span class="line">        print(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>detachNewThreadSelector(_ selector: Selector, toTarget target: Any, with argument: Any?)</li></ul><p>2、初始化器</p><ul><li>Thread(target:  selector: , object: )</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">// 不希望程代码在主线完成后退出，因为很多线程需要异步操作</span><br><span class="line">PlaygroundPage.current.needsIndefiniteExecution = true</span><br><span class="line"></span><br><span class="line">class ObjectThread &#123;</span><br><span class="line">    func threadTest() &#123;</span><br><span class="line">        let thread = Thread(target: self, selector: #selector(threadMethod), object: nil)</span><br><span class="line">        // 手动开启</span><br><span class="line">        thread.start()</span><br><span class="line">    &#125;</span><br><span class="line">    @objc func threadMethod() &#123;</span><br><span class="line">        print(&quot;threadMethod&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 实例</span><br><span class="line">let obj = ObjectThread()</span><br><span class="line">obj.threadTest()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Operation-和-OperationQueue-概述"><a href="#Operation-和-OperationQueue-概述" class="headerlink" title="Operation 和 OperationQueue 概述"></a>Operation 和 OperationQueue 概述</h1><ul><li>面向对象</li><li>Operation + OperationQueue</li><li>取消、依赖、任务优先级、复杂逻辑、保存业务状态、子类化</li></ul><h1 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h1><ul><li>Operation：抽象类，任务</li><li>BlockOperation</li></ul><p>1、状态：</p><ul><li>isReady：准备好了，可以执行了</li><li>isExecuting：执行中</li><li>isFinished：执行完成</li><li>isCancelled：取消执行</li></ul><p>2、同步、异步</p><ul><li>sync</li><li>async</li></ul><p>3、添加依赖</p><h1 id="OperationQueue"><a href="#OperationQueue" class="headerlink" title="OperationQueue"></a>OperationQueue</h1><ul><li><code>OperationQueue</code> 队列，可以加入很多 <code>Operation</code>，</li><li>底层使用 <code>GCD</code></li><li><code>maxConcurrentOperationCount</code>：可以设置最大并发数</li><li><code>defaultMaxConcurrentOperationCount</code>：根据当前系统条件动态确定的最大并发数，建议使用这个</li><li>可以取消所有的 <code>Operation</code>，但是当前正在执行的不会取消</li><li>所有 <code>Operation</code> 执行完毕后退出销毁</li></ul><h1 id="BlockOperation"><a href="#BlockOperation" class="headerlink" title="BlockOperation"></a>BlockOperation</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ObjectOperation &#123;</span><br><span class="line">    func test() &#123;</span><br><span class="line">        let operation = BlockOperation&#123; [weak self] in</span><br><span class="line">            self?.threadMethod()</span><br><span class="line">        &#125;</span><br><span class="line">        let queue = OperationQueue()</span><br><span class="line">        queue.addOperation(operation)</span><br><span class="line">    &#125;</span><br><span class="line">    @objc func threadMethod() &#123;</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;threadMethod&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let op = ObjectOperation()</span><br><span class="line">op.test()</span><br><span class="line">print(&quot;after invoke test&quot;)</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">after invoke test</span><br><span class="line">threadMethod</span><br></pre></td></tr></table></figure><p>由打印结果可知，异步执行了</p><h1 id="继承-Operation"><a href="#继承-Operation" class="headerlink" title="继承 Operation"></a>继承 Operation</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class ObjectOperation &#123;</span><br><span class="line">    func test() &#123;</span><br><span class="line">        let operation = MyOpetation()</span><br><span class="line">        let queue = OperationQueue()</span><br><span class="line">        queue.addOperation(operation)</span><br><span class="line">    &#125;</span><br><span class="line">    @objc func threadMethod() &#123;</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;threadMethod&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyOpetation: Operation &#123;</span><br><span class="line">    override func main() &#123;</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;myOperation main&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let op = ObjectOperation()</span><br><span class="line">op.test()</span><br><span class="line">print(&quot;after invoke test&quot;)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">after invoke test</span><br><span class="line">myOperation main</span><br></pre></td></tr></table></figure><h1 id="Operation-完成的回调"><a href="#Operation-完成的回调" class="headerlink" title="Operation 完成的回调"></a>Operation 完成的回调</h1><ul><li>completionBlock</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">operation.completionBlock = &#123; () -&gt; Void in</span><br><span class="line">    print(&quot;completionBlock&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">after invoke test</span><br><span class="line">myOperation main</span><br><span class="line">completionBlock</span><br></pre></td></tr></table></figure><h1 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h1><ul><li>任务 + 队列</li><li>易用</li><li>效率</li><li>性能</li></ul><h1 id="GCD功能"><a href="#GCD功能" class="headerlink" title="GCD功能"></a>GCD功能</h1><ul><li>创建管理Queue</li><li>提交Job</li><li>Dispatch Group</li><li>管理Dispatch Object</li><li>信号量Semaphore</li><li>队里屏障Barrier</li><li>Dispatch Source</li><li>Queue Context数据</li><li>Dispatch I&#x2F;O Channel</li><li>Dispatch Data 对象</li></ul><h1 id="GCD队列"><a href="#GCD队列" class="headerlink" title="GCD队列"></a>GCD队列</h1><ul><li>主队列：任务在主线程执行</li><li>并行队列：任务会以先进先出的顺序入列和出列，但是因为多个任务可以并行执行，所以顺序是不一定的</li><li>串行队列：任务会以先进先出的顺序入列和出列，但是同一时刻只会执行一个任务</li></ul><h1 id="GCD-队列API"><a href="#GCD-队列API" class="headerlink" title="GCD-队列API"></a>GCD-队列API</h1><ul><li>Dispatch.main</li><li>Dispatch.global</li><li>DispatchQueue</li><li>queue.label</li><li>setTarget</li></ul><h1 id="GCD-基本操作"><a href="#GCD-基本操作" class="headerlink" title="GCD 基本操作"></a>GCD 基本操作</h1><ul><li>sync</li></ul><p>提交任务到当前队列里，并且直接任务执行完成，当前队列才会返回</p><ul><li>async</li></ul><p>调用一个任务去立即执行，但是不用等任务执行完当前队列就会返回</p><ul><li>asyncAfter</li></ul><p>调度一个任务多久之后去执行，但是不用等任务执行完当前队列就会返回</p><h1 id="GCD-串行-amp-并行"><a href="#GCD-串行-amp-并行" class="headerlink" title="GCD 串行 &amp; 并行"></a>GCD 串行 &amp; 并行</h1><ul><li>串行和并行描述的是任务之间如何运行</li><li>串行任务每一个仅执行一个</li><li>并行任务可以多个同时执行</li></ul><h1 id="GCD-同步-amp-异步"><a href="#GCD-同步-amp-异步" class="headerlink" title="GCD 同步 &amp; 异步"></a>GCD 同步 &amp; 异步</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303131515216.png"> </p><h1 id="GCD-使用"><a href="#GCD-使用" class="headerlink" title="GCD 使用"></a>GCD 使用</h1><ul><li>同步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let queue = DispatchQueue(label: &quot;myQueue&quot;,qos: DispatchQoS.default,attributes: DispatchQueue.Attributes.concurrent,autoreleaseFrequency: DispatchQueue.AutoreleaseFrequency.inherit,target: nil)</span><br><span class="line">queue.sync &#123; // 同步</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;in queue sync&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;after invoke queue method&quot;)</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">in queue sync</span><br><span class="line">after invoke queue method</span><br></pre></td></tr></table></figure><ul><li>异步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">queue.async &#123; // 异步</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;in queue async&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;after invoke queue method&quot;)</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">after invoke queue method</span><br><span class="line">in queue async</span><br></pre></td></tr></table></figure><ul><li>asyncAfter</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">queue.asyncAfter(deadline: .now() + 1) &#123;</span><br><span class="line">    print(&quot;in asyncAfter&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;after invoke queue method&quot;)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">after invoke queue method</span><br><span class="line">in asyncAfter</span><br></pre></td></tr></table></figure><h1 id="GCD-源码剖析"><a href="#GCD-源码剖析" class="headerlink" title="GCD 源码剖析"></a>GCD 源码剖析</h1><ul><li><p>dispatch_sync</p><ul><li><p>线程A在串行队里dq中执行task1的过程中，如果再向dq中投递串行任务task2，同时还要求必须阻塞当前线程，等待task2结束(sync投递task2)，那么这时候会发生死锁</p></li><li><p>因为这时候task1还没有结束，串行队列不会去执行task2，而我们又要在当前线程等待task2的结束才肯继续执行task1，即task1在等待task2，而task2也在等待task1，循环等待，形成死锁</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 串行队列</span><br><span class="line">let queue = DispatchQueue(label: &quot;label&quot;)</span><br><span class="line">queue.async &#123; // 异步</span><br><span class="line">    print(&quot;in queue async&quot;) // 串行队列执行task1</span><br><span class="line">    queue.sync &#123;</span><br><span class="line">        print(&quot;in queue sync&quot;) // 串行队列加入task2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 死锁</span><br></pre></td></tr></table></figure><h1 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h1><p>一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码</p><h1 id="竟态条件"><a href="#竟态条件" class="headerlink" title="竟态条件"></a>竟态条件</h1><ul><li>两个或多个线程读写某些数据，而最后的结果取决于线程运行的精确时序</li></ul><h1 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303131739456.png"></p><h1 id="SpinLock"><a href="#SpinLock" class="headerlink" title="SpinLock"></a>SpinLock</h1><ul><li><p>线程通过busy-wait-loop方式来获取锁，任何时刻只有一个线程能够获取锁，其他线程忙等待知道获取锁</p></li><li><p>临界区尽量简短，控制在100行代码以内，不要有限时或隐士的系统调用，调用的函数也尽量简短</p></li><li><p>保证访问锁的线程全部都处于同一优先级</p></li></ul><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func synchronized(_ obj: Any, closure: ()-&gt;()) &#123;</span><br><span class="line">    objc_sync_enter(obj)</span><br><span class="line">    closure()</span><br><span class="line">    objc_sync_exit(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只有传同样的对象给synchronized，才能起到加锁的作用</li><li>如果传nil，无法起到加锁的作用</li><li>可以重入</li><li>synchronized不会持有传给它的对象</li></ul><h1 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h1><ul><li><p>一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面</p></li><li><p>实现一个多线程安全的Array的读和写</p></li><li><p>编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度</p></li><li><p>需要在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件</p></li></ul><h1 id="【场景一】：一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面"><a href="#【场景一】：一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面" class="headerlink" title="【场景一】：一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面"></a>【场景一】：一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面</h1><h1 id="【场景二】：实现一个多线程安全的Array的读和写"><a href="#【场景二】：实现一个多线程安全的Array的读和写" class="headerlink" title="【场景二】：实现一个多线程安全的Array的读和写"></a>【场景二】：实现一个多线程安全的Array的读和写</h1><p>一个队列加方法方法</p><ul><li>1、首先是 <code>并行队列</code>，我们需要保持多线程并行操作</li><li>2、 <code>sync</code> 方法，<code>封装读操作</code>，读操作在调用读方法时能直接拿到返回值，而不是异步获取</li><li>3、<code>async</code> 方法使用 <code>barrier flag</code>，<code>封装写操作</code>，起到一个栅栏的作用，等待所有的 <code>barrier flag</code> 函数前操作执行完成后， <code>barrier flag</code> 函数之后的所有操作才执行</li></ul><h1 id="【场景三】：编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度"><a href="#【场景三】：编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度" class="headerlink" title="【场景三】：编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度"></a>【场景三】：编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度</h1><h1 id="【场景四】：需要-在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件"><a href="#【场景四】：需要-在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件" class="headerlink" title="【场景四】：需要 在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件"></a>【场景四】：需要 在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件</h1><h1 id="Promise-多线程编程模式"><a href="#Promise-多线程编程模式" class="headerlink" title="Promise 多线程编程模式"></a>Promise 多线程编程模式</h1><ul><li><p>所谓的 <code>Promise</code>，就是一个对象，<code>用来传递异步操作的消息</code>。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 <code>API</code>，可供进一步处理</p></li><li><p>对象的状态不受外界影响。<code>Promise</code> 对象代表一个异步操作，有三种状态：<code>Pending</code>（进行中）、<code>Resolved</code>（已完成）、<code>Rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 <code>Promise</code> 这个名字的由来，它的英文意思就是 <code>承诺</code>，表示其他手段无法改变</p></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code> 对象的状态改变，只有两种可能：从 <code>Pending</code> 变为 <code>Resolved</code> 变为 <code>Rejected</code>，只要这两种情况发送，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发送了，你再对 <code>Resolved</code> 对象添加回调函数，也会立即得到这个结果。这与事件 Event 完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的</p></li></ul><h1 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h1><ul><li><p>将一个任务分解为若干个阶段（State），前阶段的输出作为下阶段的输入，各个阶段由不同的工作者线程负责执行</p></li><li><p>各个任务的各个阶段是并行（Parallel）处理的</p></li><li><p>具体任务的处理是串行的，即完成一个任务要一次执行各个阶段，但从整体任务上看，不同任务的各个阶段的执行时并行的</p></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303131740513.png"></p><h1 id="Master-x2F-Slave"><a href="#Master-x2F-Slave" class="headerlink" title="Master&#x2F;Slave"></a>Master&#x2F;Slave</h1><p>将一个任务分解为若干个语义等同的子任务，并由专门的工作者线程来并行执行这些子任务，既提高计算效率，又实现了信息隐藏</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为什么几乎所有的GUI框架都是单线程的？：处理问题代价大于收益&lt;/p&gt;
&lt;h1 id=&quot;多线程可以做什么&quot;&gt;&lt;a href=&quot;#多线程可以做</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习50：多态和类型转换</title>
    <link href="https://www.bboyzj.cn/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A050%EF%BC%9A%E5%A4%9A%E6%80%81%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://www.bboyzj.cn/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A050%EF%BC%9A%E5%A4%9A%E6%80%81%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2023-03-12T14:36:21.000Z</published>
    <updated>2023-03-14T18:40:44.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向下类型转换"><a href="#向下类型转换" class="headerlink" title="向下类型转换"></a>向下类型转换</h1><ul><li><p>类型的常量或变量实际上是子类的实例，你可以用 <code>as?</code> 或 <code>as!</code> 向下类型转换至子类类型</p></li><li><p>向下类型转换可能失败，<code>as？</code> 返回的值是 <code>可选类型</code>，<code>as！</code> 返回的是 <code>强制类型</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 基类</span><br><span class="line">class MediaItem &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子类</span><br><span class="line">class Movie: MediaItem &#123;</span><br><span class="line">    var director: String</span><br><span class="line">    init(name: String, director: String) &#123;</span><br><span class="line">        // 安全检查</span><br><span class="line">        self.director = director</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子类</span><br><span class="line">class Song: MediaItem &#123;</span><br><span class="line">    var artist: String</span><br><span class="line">    init(name: String,artist: String) &#123;</span><br><span class="line">        self.artist = artist</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [Movie(name: &quot;1&quot;, director: &quot;2&quot;),</span><br><span class="line">           Song(name: &quot;3&quot;, artist: &quot;4&quot;),</span><br><span class="line">           Movie(name: &quot;5&quot;, director: &quot;6&quot;)]</span><br><span class="line">print(type(of: arr))</span><br><span class="line">for item in arr &#123;</span><br><span class="line">    // 向下类型转换</span><br><span class="line">    if let realItem = item as? Movie &#123;</span><br><span class="line">        print(realItem.director)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Any-和-AnyObject"><a href="#Any-和-AnyObject" class="headerlink" title="Any 和 AnyObject"></a>Any 和 AnyObject</h1><p>swift 为不确定的类型提供了两种特殊的类型别名：</p><ul><li><p>AnyObject：表示任何类类型</p></li><li><p>Any：表示任何类型，包括函数类型</p></li></ul><h1 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h1><ul><li><p>swift 中 <code>类、结构体、枚举</code> 可以进行嵌套</p></li><li><p>嵌套类型能够访问它外部的成员</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;向下类型转换&quot;&gt;&lt;a href=&quot;#向下类型转换&quot; class=&quot;headerlink&quot; title=&quot;向下类型转换&quot;&gt;&lt;/a&gt;向下类型转换&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类型的常量或变量实际上是子类的实例，你可以用 &lt;code&gt;as?&lt;/code&gt; 或 &lt;co</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习42：初始化器</title>
    <link href="https://www.bboyzj.cn/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A042%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8/"/>
    <id>https://www.bboyzj.cn/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A042%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8/</id>
    <published>2023-03-12T09:43:58.000Z</published>
    <updated>2023-03-14T19:28:40.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p><code>类、枚举、结构体</code> 可以引入 <code>初始化器</code>。初始化器使用 <code>关键字init来声明</code></p></li><li><p><code>结构体、枚举、类</code> 可以有任意数量的初始化器，但是 <code>类</code> 的初始化器不同 <code>于结构体和枚举</code>，<code>类有两种初始化器，即指定初始化器和便捷初始化器。</code></p></li></ul><h1 id="存储属性的初始赋值"><a href="#存储属性的初始赋值" class="headerlink" title="存储属性的初始赋值"></a>存储属性的初始赋值</h1><ul><li><p><code>类</code> 的 <code>存储属性需要有默认值</code>，而 <code>结构体、枚举不需要</code></p></li><li><p>类设置默认值方式也有两种：一种是 <code>定义存储属性时设置默认值（Optional）</code>，另一种是通过 <code>初始化器为存储属性设置默认值</code> </p></li><li><p>类的初始化器有两种，一种 <code>指定初始化器</code>，另一种 <code>便捷初始化器</code></p></li><li><p>指定初始化器又分为两种：一种 <code>初始化器</code> 不带参数，另一种 <code>自定义初始化器</code> 带参数</p></li></ul><h1 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h1><blockquote><p><code>可选类型</code> 的存储属性，不需要设置默认值，因为它本身 <code>可能有值</code> 或 <code>可能没有值</code>，编译器会自动设置默认的初始化器</p></blockquote><ul><li>直接设置默认值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    // 1、声明一个 Optional 默认值</span><br><span class="line">    var name: String?</span><br><span class="line">    // 2、直接设置默认值</span><br><span class="line">    var name: String = &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以通过 <code>闭包</code> 设置默认值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var name: String &#123;</span><br><span class="line">        // 在这个闭包中给 name 创建一个默认值</span><br><span class="line">        return &quot;ZJ&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指定初始化器为存储属性设置默认值"><a href="#指定初始化器为存储属性设置默认值" class="headerlink" title="指定初始化器为存储属性设置默认值"></a>指定初始化器为存储属性设置默认值</h1><blockquote><p> 初始化器创建实例时被调用，最简答的形式是不带任何参数的实例方法，已关键字 <code>init</code> 命名，即 <code>指定初始化器</code></p></blockquote><ul><li>可选类型的存储属性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clas Person &#123;</span><br><span class="line">    var name: String？</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义初始化器设置默认值，带参数</li></ul><p>可以通过 <code>输入参数</code> 来自定义初始化器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    // 0.不带参数</span><br><span class="line">    init() &#123;</span><br><span class="line">        self.name = &quot;ZJ&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    // 1.实际参数和形式参数相同</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.实际参数 和 形式参数 不同</span><br><span class="line">    init(to name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.通配符实际参数</span><br><span class="line">    init(_ name: String) &#123;</span><br><span class="line">        self.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = Person(name: &quot;ZJ&quot;)</span><br><span class="line">let p1 = Person(to: &quot;ZJ&quot;)</span><br><span class="line">let p2 = Person(&quot;ZJ&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>注：指定初始化器分为两种：一种是不带参数，一种是带参数<br>初始化器可以有任意数量</p></blockquote><h1 id="类的继承和构造"><a href="#类的继承和构造" class="headerlink" title="类的继承和构造"></a>类的继承和构造</h1><p>类中的所有存储属性-&gt;包括继承父类的所有存储属性：都必须在构造过程中 <code>设置默认值</code></p><p>1、<code>swift</code> 中为类提供了两种初始化器：<code>指定初始化器</code> 和 <code>便捷初始化器</code></p><ul><li>指定初始化器</li></ul><p>类中主要的初始化器，设置类中所有属性默认值，并往上调用父类的初始化器设置所有属性的默认值</p><ul><li>便捷初始化器</li></ul><p>类中次要的、辅助型的初始化器，可以调用类中的指定初始化器，并提供默认值</p><p>2、指定初始化器和便捷初始化器语法</p><ul><li>指定初始化器和简单初始化器一样</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>便捷初始化器，需要在 <code>init</code> 前放置 <code>convenience</code> 关键字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    // 未设置默认值的存储属性</span><br><span class="line">    var name: String</span><br><span class="line">    // 指定初始化器 用来给存储属性设置默认值</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    // 便捷初始化器</span><br><span class="line">    convenience init() &#123;</span><br><span class="line">        // 横向代理：必须调用一个指定的初始化器</span><br><span class="line">        self.init(name: &quot;ZJ&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = Person()</span><br><span class="line">print(p.name)</span><br></pre></td></tr></table></figure><blockquote><p>类的初始化器代理规则<br>1、指定初始化器必须调用其直接父类的指定初始化器<br>2、便捷初始化器必须调从同类调用一个指定初始化器<br>3、便捷初始化器最终必须调用一个指定初始化器</p><p>更方便的记忆方法<br>1、指定初始化器必须总是向上代理<br>2、便捷初始化器必须是横向代理</p></blockquote><p>3、初始化器继承和重写</p><ul><li>子类默认是 <code>不继承</code> 父类的初始化器，实际上是通过 <code>重写</code> 父类的初始化器，切需要带上 <code>override</code> 关键字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 继承和重写</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name:String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student: Person &#123;</span><br><span class="line">    // 重写父类的初始化器</span><br><span class="line">    override init(name: String) &#123;</span><br><span class="line">        var newName = &quot;my name is \(name)&quot;</span><br><span class="line">        super .init(name: newName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let s = Student(name: &quot;ZJ&quot;)</span><br><span class="line">print(s.name)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">my name is ZJ</span><br></pre></td></tr></table></figure><ul><li>初始化器的自动继承</li></ul><blockquote><p>1、如果子类没有定义任何初始化器，它将自动继承父类的所有指定初始化器<br>2、如果子类实现了继承自父类的指定初始化器，那么它将自动继承父类的便捷初始化器</p></blockquote><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name:String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    convenience init() &#123;</span><br><span class="line">        self.init(name: &quot;ZJ&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = Person()</span><br><span class="line">print(p.name)</span><br><span class="line">// 打印结果 ZJ</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">class Student: Person &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">    // 本类的指定初始化器</span><br><span class="line">    init(name: String,age: Int) &#123;</span><br><span class="line">        self.age = age</span><br><span class="line">        // 实现父类的指定初始化器</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    convenience override init(name: String) &#123;</span><br><span class="line">        self.init(name: name, age: 32)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let s = Student()</span><br><span class="line">let s1 = Student(name: &quot;ZJ&quot;)</span><br><span class="line">let s2 = Student(name: &quot;ZJ&quot;, age: 32)</span><br><span class="line">print(s.age)</span><br><span class="line">// 打印结果 32</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="安全检查"><a href="#安全检查" class="headerlink" title="安全检查"></a>安全检查</h1><ul><li>子类指定初始化器向上委托父类初始化器前，子类的所有属性都要完成初始化</li><li>之类指定初始化器必须先向上委托父类初始化器，才能修改父类的所有属性</li><li>便捷初始化器必须先委托同类初始化器，才能为任意属性赋值</li><li>方法的调用在所有指定初始化器之后。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 安全检查</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">    // 指定初始化器</span><br><span class="line">    init(name: String, age: Int) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    convenience init()&#123;</span><br><span class="line">        self.init(name: &quot;[Unnamed]&quot;, age: 0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Teacher: Person &#123;</span><br><span class="line">    // 工资</span><br><span class="line">    var salary: Int</span><br><span class="line">    // 自己的指定初始化器</span><br><span class="line">    init(name: String, age: Int, salary: Int) &#123;</span><br><span class="line">        // 1.先赋值自己的所有属性</span><br><span class="line">        self.salary = salary</span><br><span class="line">        // 2.调用父类的指定初始化器</span><br><span class="line">        super.init(name: name, age: age)</span><br><span class="line">        // 3.修改父类的所有属性</span><br><span class="line">        self.name = name + &quot;老师&quot;</span><br><span class="line">        // 6.调用方法</span><br><span class="line">        test()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func test() &#123;</span><br><span class="line">        print(&quot;test&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    convenience init(salary: Int) &#123;</span><br><span class="line">        // 4.必须调用本类的指定初始化器</span><br><span class="line">        self.init(name: &quot;ZJ&quot;, age: 32, salary: salary)</span><br><span class="line">        // 5.调用本类的指定初始化器后，才能赋值本类的所有属性</span><br><span class="line">        self.salary = self.salary + 1000</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="失败初始化器"><a href="#失败初始化器" class="headerlink" title="失败初始化器"></a>失败初始化器</h1><p>如果在构造过程有可能失败，则需要定义一个可失败的初始化器，在 <code>init</code> 关键字 <code>后面</code> 添加 <code>?</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">    init?(age: Int) &#123;</span><br><span class="line">        if age &gt; 200 &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = Person(age: 300)</span><br><span class="line">print(p)</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">nil</span><br></pre></td></tr></table></figure><h1 id="反初始化器"><a href="#反初始化器" class="headerlink" title="反初始化器"></a>反初始化器</h1><ul><li><p>类实例 <code>被释放时</code>，反初始化器立即被调用。用 <code>deinit</code> 关键字写反初始化器。</p></li><li><p>反初始化器在 <code>实例释放前自动被调用</code>。不能自己调用。可以被子类继承。先子类 -&gt; 父类</p></li><li><p>每个类只能有一个</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line">    // perform the deinitialization</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="必要初始化器"><a href="#必要初始化器" class="headerlink" title="必要初始化器"></a>必要初始化器</h1><ul><li>在类的初始化器前加 <code>required</code> 修饰符表明所有该子类必须实现该初始化器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 必要初始化器</span><br><span class="line">class SomeClass &#123;</span><br><span class="line">    required init()&#123;</span><br><span class="line">        // 初始化器的实现代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子类重写父类的必要初始化器时，子类的初始化器前也添加 <code>required</code> 关键字，表明可继承</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 必要初始化器</span><br><span class="line">class SomeSubClass: SomeClass &#123;</span><br><span class="line">    required init()&#123;</span><br><span class="line">        // 初始化器的实现代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;类、枚举、结构体&lt;/code&gt; 可以引入 &lt;code&gt;初始化器&lt;/code&gt;。初始化器使用 &lt;code&gt;关键字</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习41：泛型</title>
    <link href="https://www.bboyzj.cn/2023/03/11/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A041%EF%BC%9A%E6%B3%9B%E5%9E%8B/"/>
    <id>https://www.bboyzj.cn/2023/03/11/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A041%EF%BC%9A%E6%B3%9B%E5%9E%8B/</id>
    <published>2023-03-10T20:40:24.000Z</published>
    <updated>2023-03-11T20:49:13.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul><li><p>泛型代码能根据所定义的要求写出可以用于任何类型的灵活的、可复用的函数。可以编写出可复用、意图表达清晰、抽象的代码。</p></li><li><p><code>泛型 </code>是Swift最强大的特性之一，<code>很多Swift标准库</code> 是基于 <code>泛型</code> 代码构建的。如，Swift 的 <code>Array和Dictionary类型都是泛型集合</code>；你也可以创建一个容纳 <code>Int</code> 值的数组，或者容纳 <code>String</code> 值的数组，甚至容纳任何 <code>Swift</code> 可以创建的其他类型的数组。同样，可以创建一个存储任何指定类型值的字典，而且类型没有限制。</p></li><li><p>泛型所解决的问题：<code>代码的复用性和抽象能力</code>。比如，交换两个值，这里的值可以是Int、Double、String。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//经典例子swap，使用泛型，可以满足不同类型参数的调用</span><br><span class="line">func swap&lt;T&gt;(_ a: inout T, _ b: inout T)&#123;</span><br><span class="line">    let tmp = a</span><br><span class="line">    a = b</span><br><span class="line">    b = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><p>主要讲3点：<code>类型约束、关联类型、Where语句</code></p><ul><li>类型约束</li></ul><p>在一个 <code>类型参数后面放置协议或者是类</code>，例如下面的例子，要求类型参数T遵循 <code>Equatable</code> 协议。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func test&lt;T:Equatable&gt;(_ a: T, _ b: T) -&gt; Bool &#123;</span><br><span class="line">    return a == b</span><br><span class="line">&#125;</span><br><span class="line">test(1, 2)</span><br><span class="line">// 打印结果 false</span><br><span class="line">test(&quot;A&quot;, &quot;a&quot;)</span><br><span class="line">// 打印结果 false</span><br></pre></td></tr></table></figure><blockquote><p>Equatable协议：可以比较值相等的协议，即可以使用 <code>==</code> 比较</p></blockquote><ul><li>关联类型</li></ul><blockquote><p>在定义协议时，使用 <code>关联类型</code> 给 <code>协议</code> 中用到的 <code>类型</code> 起一个 <code>占位符名称</code>。关联类型 <code>只能用于协议</code>，并且是通过关键字 <code>associatedtype</code> 指定。</p></blockquote><p>下面这个示例，仿写的一个栈的结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Stack &#123;</span><br><span class="line">    var items = [Int]()</span><br><span class="line">    // 入栈</span><br><span class="line">    mutating func push(_ item: Int) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    // 出栈</span><br><span class="line">    mutating func pop() -&gt; Int?&#123;</span><br><span class="line">        if items.isEmpty &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该结构体中有个成员 <code>item</code>，是个只能存储 <code>Int</code> 类型的数组，如果想使用其他类型呢？ 可以通过协议来实现 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protocol StackProtocol &#123;</span><br><span class="line">    // 协议中使用类型的占位符</span><br><span class="line">    associatedtype Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Stack: StackProtocol&#123;</span><br><span class="line">    // 在使用时，需要指定具体的类型</span><br><span class="line">    typealias Item = Int</span><br><span class="line">    </span><br><span class="line">    var items = [Item]()</span><br><span class="line">    // 入栈</span><br><span class="line">    mutating func push(_ item: Int) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    // 出栈</span><br><span class="line">    mutating func pop() -&gt; Int?&#123;</span><br><span class="line">        if items.isEmpty &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在尝试用 <code>泛型</code> 实现上面的功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 泛型实现</span><br><span class="line">struct Stack&lt;T&gt; &#123;</span><br><span class="line">    var items = [T]()</span><br><span class="line">    // 入栈</span><br><span class="line">    mutating func push(_ item: T) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    // 出栈</span><br><span class="line">    mutating func pop() -&gt; T?&#123;</span><br><span class="line">        if items.isEmpty &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型的优势和强大，暴露无疑</p><ul><li>where</li></ul><p><code>where语句</code> 主要用于 <code>表明泛型需要满足的条件</code>，即 <code>限制形式参数的要求</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// where</span><br><span class="line">protocol StackProtocol &#123;</span><br><span class="line">    // 协议中使用类型的占位符</span><br><span class="line">    associatedtype Item</span><br><span class="line">    // 实例属性</span><br><span class="line">    var itemCount: Int &#123; get &#125;</span><br><span class="line">    // 出栈</span><br><span class="line">    mutating func pop() -&gt; Item?</span><br><span class="line">    // 下标获取</span><br><span class="line">    func index(of index: Int) -&gt; Item</span><br><span class="line">&#125;</span><br><span class="line">struct Stack: StackProtocol &#123;</span><br><span class="line">    // 在使用时，需要指定具体的类型</span><br><span class="line">    typealias Item = Int</span><br><span class="line">    // 存储属性</span><br><span class="line">    var items = [Item]()</span><br><span class="line">    // 计算属性</span><br><span class="line">    var itemCount: Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return items.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 入栈</span><br><span class="line">    mutating func push(_ item: Item)&#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    // 出栈</span><br><span class="line">    mutating func pop() -&gt; Item?&#123;</span><br><span class="line">        if items.isEmpty &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    // 下标获取</span><br><span class="line">    func index(of index: Int) -&gt; Item&#123;</span><br><span class="line">        return items[index]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> whrer语句</span><br><span class="line"> T1.Item == T2.Item 表示 T1和T2中的类型必须相等</span><br><span class="line"> T1.Item: Equatable 表示 T1的类型必须遵循Equatable协议，意味着T2也要尊徐Equatable协议</span><br><span class="line"> */</span><br><span class="line">func compare&lt;T1: StackProtocol, T2: StackProtocol&gt;(_ stack1: T1,_ stack2: T2) -&gt; Bool where T1.Item == T2.Item, T1.Item: Equatable &#123;</span><br><span class="line">    // 如果数量相等，则遍历</span><br><span class="line">    guard stack1.itemCount == stack2.itemCount else &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    // 遍历</span><br><span class="line">    for i in 0..&lt;stack1.itemCount &#123;</span><br><span class="line">        if stack1.index(of: i) != stack2.index(of: i) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 扩展协议中的 Iem 遵循 Equatable</span><br><span class="line">extension StackProtocol where Item: Equatable &#123;&#125;</span><br></pre></td></tr></table></figure><p>当希望 <code>泛型指定类型</code> 拥有特定功能，可以这么写，在上述写法的基础上 <code>增加extension：</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 扩展协议中 Item 指定具体类型</span><br><span class="line">extension StackProtocol where Item == Int &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 简单的泛型函数</span><br><span class="line">func testGen&lt;T&gt;(_ value: T) -&gt; T &#123;</span><br><span class="line">    let tmp = value</span><br><span class="line">    return tmp</span><br><span class="line">&#125;</span><br><span class="line">class Teacher &#123;</span><br><span class="line">    var age: Int = 18</span><br><span class="line">    var name: String = &quot;ZJ&quot;</span><br><span class="line">&#125;</span><br><span class="line">// 传入Int类型</span><br><span class="line">testGen(10)</span><br><span class="line">// 传入元组</span><br><span class="line">testGen((1,2))</span><br><span class="line">// 传入实例对象</span><br><span class="line">testGen(Teacher())</span><br></pre></td></tr></table></figure><p>从以上代码可以看出，泛型函数 <code>可以接受任何类型</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>泛型主要用于解决代码的 <code>抽象能力</code>，以及提升代码的 <code>复用性</code></li><li>如果一个泛型 <code>遵循了某个协议</code>，则在使用时，要求具体的类型也是必须遵循某个协议的；</li><li>在定义协议时，可以使用 <code>关联类型</code> 给协议中用到的 <code>类型</code> 起一个 <code>占位符名称</code>；</li><li><code>where语句</code> 主要用于表明泛型需要满足的条件，即 <code>限制形式参数的要求</code>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;泛型代码能根据所定义的要求写出可以用于任何类型的灵活的、可复用的函数。可以编写出可复用、意图表达清晰、抽象的代码。&lt;/p&gt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>OC学习20：UIViewController生命周期</title>
    <link href="https://www.bboyzj.cn/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A020%EF%BC%9AUIViewController%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://www.bboyzj.cn/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A020%EF%BC%9AUIViewController%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2023-03-09T21:15:32.000Z</published>
    <updated>2023-03-09T21:47:29.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UIViewController生命周期相关方法"><a href="#UIViewController生命周期相关方法" class="headerlink" title="UIViewController生命周期相关方法"></a>UIViewController生命周期相关方法</h1><ul><li><ul><li>(instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil;</li></ul></li></ul><p>非storyBoard(xib或非xib)都走这个方法</p><ul><li><ul><li>(instancetype)initWithCoder:(NSCoder *)aDecoder;</li></ul></li></ul><p>如果连接了串联图storyBoard 走这个方法</p><ul><li><ul><li>(void)awakeFromNib;</li></ul></li></ul><p>xib 加载 完成</p><ul><li>+(void)load</li></ul><p>load 在代码加载的时候，对象还没有被初始化的时候就已经调⽤了，可以⽤<br>来做⼀些全局的swizzle,只调⽤⼀次</p><ul><li>+(void)initialize</li></ul><p>类的初始化方法</p><ul><li>-(instancetype)init</li></ul><p>对象初始化方法</p><ul><li>-(void)loadView</li></ul><p>加载视图:当访问UIViewController的view属性时，view如果此时是nil，那么VC会自动调用loadView方法来初始化一个UIView并赋值给view属性。此方法用在初始化关键view，需要注意的是，在view初始化之前，不能先调用view的getter方法，否则将导致死循环（除非先调用了[super loadView];）如果没有重载loadView方法，则UIViewController会从nib或StoryBoard中查找默认的loadView，默认的loadView会返回一个空白的UIView对象。</p><ul><li>-(void)viewDidLoad</li></ul><p>视图加载完成</p><ul><li>-(void)viewWillAppear:(BOOL)animated</li></ul><p>将要展示:在view即将添加到视图层级中（显示给用户）且任意显示动画切换之前调用,此时self.view.superview为nil.这个方法中完成任何与试图显示相关的任务，例如改变视图方向、状态栏方向、视图显示样式等。</p><ul><li>-(void)viewWillLayoutSubviews</li></ul><p>将要布局子视图,self.view.superview为_UIParallaxDimmingView</p><ul><li>-(void)viewDidLayoutSubviews</li></ul><p>已经布局子视图</p><ul><li>-(void)viewDidAppear:(BOOL)animated</li></ul><p>已经展示:在view被添加到视图层级中，显示动画切换之后调用（这时view已经添加到supperView中）。在这个方法中执行视图显示相关附件任务，如果重载了这个方法，必须在方法中调用[supper viewDidAppear];,此时self.view.superview为UIViewControllerWrapperView。</p><ul><li>-(void)viewWillDisappear:(BOOL)animated</li></ul><p>将要消失:view即将从supperView中移除，移除动画切换之后调用，此时已调用removeFromSuperview。此时self.view.superview还是superview为UIViewControllerWrapperView.</p><ul><li>-(void)viewDidDisappear:(BOOL)animated</li></ul><p>已经消失:view从superView中移除，移除动画切换之后调用，此时已调用removeFromSuperview。此时self.view.superview还是superview为nil.</p><ul><li>-(void)dideMemoryWarning</li></ul><p>内存警告</p><ul><li>-(void)dealloc</li></ul><p>销毁释放</p><h1 id="声明周期"><a href="#声明周期" class="headerlink" title="声明周期"></a>声明周期</h1><blockquote><p>-[ViewController initWithCoder:]<br>-[ViewController awakeFromNib]<br>-[ViewController loadView]<br>-[ViewController viewDidLoad]<br>-[ViewController viewWillAppear:]<br>-[ViewController viewWillLayoutSubviews]<br>-[ViewController viewDidLayoutSubviews]<br>-[ViewController viewDidAppear:]<br>-[ViewController viewWillDisappear:]<br>-[ViewController viewDidDisappear:]<br>-[ViewController dealloc]<br>-[ViewController didReceiveMemoryWarning]</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UIViewController生命周期相关方法&quot;&gt;&lt;a href=&quot;#UIViewController生命周期相关方法&quot; class=&quot;headerlink&quot; title=&quot;UIViewController生命周期相关方法&quot;&gt;&lt;/a&gt;UIViewControll</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习19：UIView的生命周期</title>
    <link href="https://www.bboyzj.cn/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A019%EF%BC%9AUIView%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://www.bboyzj.cn/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A019%EF%BC%9AUIView%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2023-03-09T21:03:36.000Z</published>
    <updated>2023-03-09T21:38:16.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UIView生命周期相关函数"><a href="#UIView生命周期相关函数" class="headerlink" title="UIView生命周期相关函数"></a>UIView生命周期相关函数</h1><ul><li><ul><li>(instancetype)initWithFrame:(CGRect)frame;</li></ul></li></ul><p>构造方法,初始化时调用,不会调用init方法</p><ul><li>-(instancetype)init</li></ul><p>构造方法,内部会调用initWithFrame方法</p><ul><li><ul><li>(instancetype)initWithCoder:(NSCoder *)aDecoder;</li></ul></li></ul><p>xib归档初始化视图后调用,如果xib中添加了子控件会在didAddSubview方法调用后调用</p><ul><li><ul><li>(void)awakeFromNib;</li></ul></li></ul><p>唤醒xib,可以布局子控件</p><ul><li>-(void)willMoveToSuperview:(UIView *)newSuperview</li></ul><p>父视图将要更改为指定的父视图,当前视图被添加到父视图时调用</p><ul><li>-(void)didMoveToSuperview</li></ul><p>父视图已更改时调用</p><ul><li>-(void)willMoveToWindow:(UIWindow *)newWindow</li></ul><p>其窗口对象将要更改时调用</p><ul><li>-(void)didMoveToWindow</li></ul><p>窗口对象已经更改时调用</p><ul><li>-(void)layoutSubviews</li></ul><p>布局子控件</p><ul><li>-(void)drawRect:(CGRect)rect</li></ul><p>绘制视图</p><ul><li>-(void)dealloc</li></ul><p>销毁</p><ul><li><ul><li>(void)didAddSubview:(UIView *)subview;</li></ul></li></ul><p>添加子控件时调用</p><ul><li><ul><li>(void)willRemoveSubview:(UIView *)subview;</li></ul></li></ul><p>将要移除子控件</p><h1 id="init方式创建视图-并添加到父视图中展示-不添加子控件-其生命周期调用顺序为"><a href="#init方式创建视图-并添加到父视图中展示-不添加子控件-其生命周期调用顺序为" class="headerlink" title="init方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为:"></a>init方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为:</h1><blockquote><p>[NoXibView initWithFrame:]<br>[NoXibView init]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView layoutSubviews]</p></blockquote><h1 id="initWithFrame方式创建视图-并添加到父视图中展示-不添加子控件-其生命周期调用顺序为"><a href="#initWithFrame方式创建视图-并添加到父视图中展示-不添加子控件-其生命周期调用顺序为" class="headerlink" title="initWithFrame方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为:"></a>initWithFrame方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为:</h1><blockquote><p>[NoXibView initWithFrame:]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView layoutSubviews]<br>[NoXibView drawRect:]</p></blockquote><h1 id="移除销毁是调用顺序"><a href="#移除销毁是调用顺序" class="headerlink" title="移除销毁是调用顺序:"></a>移除销毁是调用顺序:</h1><blockquote><p>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView removeFromSuperview]<br>[NoXibView dealloc]</p></blockquote><h1 id="添加子控件展示时调用顺序"><a href="#添加子控件展示时调用顺序" class="headerlink" title="添加子控件展示时调用顺序:"></a>添加子控件展示时调用顺序:</h1><blockquote><p>[NoXibView initWithFrame:]<br>[NoXibView didAddSubview:]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView layoutSubviews]<br>[NoXibView drawRect:]</p></blockquote><h1 id="添加子控件移除销毁时调用顺序"><a href="#添加子控件移除销毁时调用顺序" class="headerlink" title="添加子控件移除销毁时调用顺序:"></a>添加子控件移除销毁时调用顺序:</h1><blockquote><p>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView removeFromSuperview]<br>[NoXibView dealloc]<br>[NoXibView willRemoveSubview:]</p></blockquote><h1 id="xib创建初始化视图-xib中不添加子控件时调用顺序"><a href="#xib创建初始化视图-xib中不添加子控件时调用顺序" class="headerlink" title="xib创建初始化视图, xib中不添加子控件时调用顺序:"></a>xib创建初始化视图, xib中不添加子控件时调用顺序:</h1><blockquote><p>[XibView initWithCoder:]<br>[XibView awakeFromNib]<br>[XibView willMoveToSuperview:]<br>[XibView didMoveToSuperview]<br>[XibView willMoveToWindow:]<br>[XibView didMoveToWindow]<br>[XibView layoutSubviews]<br>[XibView layoutSubviews]<br>[XibView drawRect:]</p></blockquote><h1 id="xib创建初始化视图-xib中添加子控件时调用顺序"><a href="#xib创建初始化视图-xib中添加子控件时调用顺序" class="headerlink" title="xib创建初始化视图, xib中添加子控件时调用顺序:"></a>xib创建初始化视图, xib中添加子控件时调用顺序:</h1><blockquote><p>[XibView didAddSubview:]<br>[XibView initWithCoder:]<br>[XibView awakeFromNib]<br>[XibView willMoveToSuperview:]<br>[XibView didMoveToSuperview]<br>[XibView willMoveToWindow:]<br>[XibView didMoveToWindow]<br>[XibView layoutSubviews]<br>[XibView layoutSubviews]<br>[XibView drawRect:]</p></blockquote><h1 id="移除销毁时调用顺序-有子控件"><a href="#移除销毁时调用顺序-有子控件" class="headerlink" title="移除销毁时调用顺序,有子控件:"></a>移除销毁时调用顺序,有子控件:</h1><blockquote><p>[XibView willMoveToWindow:]<br>[XibView didMoveToWindow]<br>[XibView willMoveToSuperview:]<br>[XibView didMoveToSuperview]<br>[XibView removeFromSuperview]<br>[NoXibView dealloc]<br>[NoXibView willRemoveSubview:]</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UIView生命周期相关函数&quot;&gt;&lt;a href=&quot;#UIView生命周期相关函数&quot; class=&quot;headerlink&quot; title=&quot;UIView生命周期相关函数&quot;&gt;&lt;/a&gt;UIView生命周期相关函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;(instan</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
