<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张建的博客</title>
  <icon>https://www.gravatar.com/avatar/134cc2bfaf649e446f661778f4112fca</icon>
  <subtitle>成功的道路上只有荆棘，没有坦途</subtitle>
  <link href="https://www.bboyzj.cn/atom.xml" rel="self"/>
  
  <link href="https://www.bboyzj.cn/"/>
  <updated>2023-03-09T13:13:50.007Z</updated>
  <id>https://www.bboyzj.cn/</id>
  
  <author>
    <name>小J</name>
    <email>13718004742@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift学习：继承</title>
    <link href="https://www.bboyzj.cn/2023/03/09/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A042%EF%BC%9A%E7%BB%A7%E6%89%BF/"/>
    <id>https://www.bboyzj.cn/2023/03/09/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A042%EF%BC%9A%E7%BB%A7%E6%89%BF/</id>
    <published>2023-03-09T12:33:59.000Z</published>
    <updated>2023-03-09T13:13:50.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>swift中，<code>只有类支持继承</code></li><li>swift中 <code>类没有统一的基类</code>。</li><li>没有继承任何父类的类是基类，但其实它是有一个父类的，叫 <code>_SwiftObject</code></li><li>被 <code>final</code> 修饰的 <code>属性、方法、下标</code> 禁止被 <code>重写</code>，禁止被 <code>继承</code></li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul><li>swift中的继承与其他语言类似，主要是 <code>子类继承父类</code> 的 <code>属性、方法、下标</code> 及其他的特征</li><li>子类可以 <code>调用和访问</code> 父类的 <code>属性、方法、下标</code></li><li>子类可以 <code>重写</code> 父类的 <code>属性、方法、下标</code></li></ul><h1 id="继承的基本使用"><a href="#继承的基本使用" class="headerlink" title="继承的基本使用"></a>继承的基本使用</h1><ul><li>定义一个基类</li></ul><h1 id="重写的基本使用"><a href="#重写的基本使用" class="headerlink" title="重写的基本使用"></a>重写的基本使用</h1><ul><li><p>重写父类的 <code>属性、方法、下标</code> 用关键字 <code>override</code> ，编译器会根据此关键字进行检查父类是不是有提供相应的声明</p></li><li><p>重写的 <code>属性、方法、下标</code> 想要访问父类用 <code>super</code> 关键字，如果 <code>super.someProperty、someMethod、some[someIndex]</code></p></li></ul><h2 id="属性重写"><a href="#属性重写" class="headerlink" title="属性重写"></a>属性重写</h2><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><h2 id="下标重写"><a href="#下标重写" class="headerlink" title="下标重写"></a>下标重写</h2><h2 id="属性观察器重写"><a href="#属性观察器重写" class="headerlink" title="属性观察器重写"></a>属性观察器重写</h2><h1 id="禁止重写"><a href="#禁止重写" class="headerlink" title="禁止重写"></a>禁止重写</h1><ul><li>可以用 <code>final</code> 关键字禁止被 <code>继承</code></li><li>禁止继承属性： final var（变量属性）、final let（常量属性）</li><li>禁止继承方法：final func（实例方法）、final class（类方法）、</li><li>禁止继承下标：final subscribe（下标）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;swift中，&lt;code&gt;只有类支持继承&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;swift中 &lt;code&gt;类没有统一的基类&lt;/code</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习：swift中方法的调用</title>
    <link href="https://www.bboyzj.cn/2023/03/09/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/"/>
    <id>https://www.bboyzj.cn/2023/03/09/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</id>
    <published>2023-03-09T08:29:57.000Z</published>
    <updated>2023-03-09T08:29:57.676Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>性能优化03：Crash检测和优化方案</title>
    <link href="https://www.bboyzj.cn/2023/03/09/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603%EF%BC%9ACrash%E6%A3%80%E6%B5%8B%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <id>https://www.bboyzj.cn/2023/03/09/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603%EF%BC%9ACrash%E6%A3%80%E6%B5%8B%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</id>
    <published>2023-03-08T21:32:04.000Z</published>
    <updated>2023-03-08T21:36:50.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="检测方式"><a href="#检测方式" class="headerlink" title="检测方式"></a>检测方式</h1><h1 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h1 id=&quot;检测方式&quot;&gt;&lt;a href=&quot;#检测方式&quot; class=&quot;headerlink&quot; title=&quot;检测方式&quot;&gt;&lt;/a&gt;检测方式&lt;/h</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>OC学习13：上传App Store所需各图标和图片尺寸</title>
    <link href="https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A013%EF%BC%9A%E4%B8%8A%E4%BC%A0App-Store%E6%89%80%E9%9C%80%E5%90%84%E5%9B%BE%E6%A0%87%E5%92%8C%E5%9B%BE%E7%89%87%E5%B0%BA%E5%AF%B8/"/>
    <id>https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A013%EF%BC%9A%E4%B8%8A%E4%BC%A0App-Store%E6%89%80%E9%9C%80%E5%90%84%E5%9B%BE%E6%A0%87%E5%92%8C%E5%9B%BE%E7%89%87%E5%B0%BA%E5%AF%B8/</id>
    <published>2023-03-08T19:13:37.000Z</published>
    <updated>2023-03-08T20:50:44.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="App-Icon-图标尺寸"><a href="#App-Icon-图标尺寸" class="headerlink" title="App Icon 图标尺寸"></a>App Icon 图标尺寸</h1><table><thead><tr><th align="center">型号</th><th align="center">分辨率（pt）</th><th align="center">像素（px）</th><th align="center">图片后缀</th></tr></thead><tbody><tr><td align="center">iPhone</td><td align="center">20</td><td align="center">40x40</td><td align="center">2x</td></tr><tr><td align="center">iPhone</td><td align="center">20</td><td align="center">60x60</td><td align="center">3x</td></tr><tr><td align="center">iPhone</td><td align="center">29</td><td align="center">58x58</td><td align="center">2x</td></tr><tr><td align="center">iPhone</td><td align="center">29</td><td align="center">87x87</td><td align="center">3x</td></tr><tr><td align="center">iPhone</td><td align="center">40</td><td align="center">80x80</td><td align="center">2x</td></tr><tr><td align="center">iPhone</td><td align="center">40</td><td align="center">120x120</td><td align="center">3x</td></tr><tr><td align="center">iPhone</td><td align="center">60</td><td align="center">120x120</td><td align="center">2x</td></tr><tr><td align="center">iPhone</td><td align="center">60</td><td align="center">180x180</td><td align="center">2x</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">iPad</td><td align="center">20</td><td align="center">20x20</td><td align="center">1x</td></tr><tr><td align="center">iPad</td><td align="center">20</td><td align="center">40x40</td><td align="center">2x</td></tr><tr><td align="center">iPad</td><td align="center">29</td><td align="center">29x29</td><td align="center">1x</td></tr><tr><td align="center">iPad</td><td align="center">29</td><td align="center">58x58</td><td align="center">2x</td></tr><tr><td align="center">iPad</td><td align="center">40</td><td align="center">40x40</td><td align="center">1x</td></tr><tr><td align="center">iPad</td><td align="center">40</td><td align="center">80x80</td><td align="center">2x</td></tr><tr><td align="center">iPad</td><td align="center">76</td><td align="center">76x76</td><td align="center">1x</td></tr><tr><td align="center">iPad</td><td align="center">76</td><td align="center">152x152</td><td align="center">2x</td></tr><tr><td align="center">iPad</td><td align="center">83.5</td><td align="center">167x167</td><td align="center">2x</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">App Store</td><td align="center">1024</td><td align="center">1024x1024</td><td align="center">1x</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="App-Store-引导页图片尺寸"><a href="#App-Store-引导页图片尺寸" class="headerlink" title="App Store 引导页图片尺寸"></a>App Store 引导页图片尺寸</h1><table><thead><tr><th align="center">屏幕大小（英寸）</th><th align="center">像素（px）</th></tr></thead><tbody><tr><td align="center">5.5</td><td align="center">886x1920</td></tr><tr><td align="center">6.5</td><td align="center">1080x1920</td></tr><tr><td align="center">12.9</td><td align="center">1200x1600</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;App-Icon-图标尺寸&quot;&gt;&lt;a href=&quot;#App-Icon-图标尺寸&quot; class=&quot;headerlink&quot; title=&quot;App Icon 图标尺寸&quot;&gt;&lt;/a&gt;App Icon 图标尺寸&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th alig</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习12：HTTP状态码大全</title>
    <link href="https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A012%EF%BC%9AHTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    <id>https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A012%EF%BC%9AHTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E5%85%A8/</id>
    <published>2023-03-08T19:12:49.000Z</published>
    <updated>2023-03-08T21:20:21.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HTTP状态码（HTTP Status Code）是用来表示网页服务器HTTP响应状态的3位数字代码。</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>所有状态码的第一个数字代表了响应的五种状态之一，其分类如下：</p><table><thead><tr><th align="center">状态码</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1xx</td><td align="center">信息，表示临时响应并需要请求者继续执行操作</td></tr><tr><td align="center">2xx</td><td align="center">成功，操作被成功接收并处理</td></tr><tr><td align="center">3xx</td><td align="center">表示要完成请求，需要进一步操作。通常这些代码用来重定向</td></tr><tr><td align="center">4xx</td><td align="center">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="center">5xx</td><td align="center">这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错</td></tr></tbody></table><h1 id="状态码详解"><a href="#状态码详解" class="headerlink" title="状态码详解"></a>状态码详解</h1><ul><li>1xx：</li></ul><blockquote><p>100：（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</p><p>101：（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</p><p>102：由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</p></blockquote><ul><li>2xx：</li></ul><blockquote><p>200：（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</p><p>201：（已创建） 请求成功并且服务器创建了新的资源。</p><p>202：（已接受） 服务器已接受请求，但尚未处理。</p><p>203：（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</p><p>204：（无内容） 服务器成功处理了请求，但没有返回任何内容。</p><p>205：（重置内容） 服务器成功处理了请求，但没有返回任何内容。</p><p>206：（部分内容） 服务器成功处理了部分 GET 请求。</p><p>208：（已经报告）一个DAV的绑定成员被前一个请求枚举，并且没有被再一次包括。</p><p>226：（IM Used）服务器已经满足了请求所要的资源，并且响应是一个或者多个实例操作应用于当前实</p></blockquote><ul><li>3xx：</li></ul><blockquote><p>300：（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p><p>301：（永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</p><p>302：（临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>303：（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</p><p>304：（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</p><p>305：（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</p><p>307：（临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p></blockquote><ul><li>4xx：</li></ul><blockquote><p>400:（错误请求) 服务器不理解请求的语法。</p><p>401：(未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p><p>402：该状态码是为了将来可能的需求而预留的。</p><p>403：（禁止) 服务器拒绝请求。</p><p>404：（未找到) 服务器找不到请求的网页。</p><p>405：（方法禁用) 禁用请求中指定的方法。</p><p>406：（不接受) 无法使用请求的内容特性响应请求的网页。</p><p>407：（需要代理授权) 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</p><p>408：（请求超时) 服务器等候请求时发生超时。</p><p>409：（冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</p><p>410：（已删除) 如果请求的资源已永久删除，服务器就会返回此响应。</p><p>411：（需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。</p><p>412：（未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。</p><p>413：（请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</p><p>414：（请求的 URI 过长) 请求的 URI（通常为网址）过长，服务器无法处理。</p><p>415：（不支持的媒体类型) 请求的格式不受请求页面的支持。</p><p>416：（请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。</p><p>417：（未满足期望值) 服务器未满足”期望”请求标头字段的要求。</p><p>418：（我是一个茶壶）这个代码是在1998年作为传统的IETF April Fools‘ jokes被定义的在RFC2324，超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现。RFC指定了这个代码应该是由茶罐返回给速溶咖啡。</p><p>419：（认证超时）并不是HTTP标注的一部分，419认证超时表示以前的有效证明已经失效了。同时也被用于401未认证的替代选择为了从其它被拒绝访问的已认证客户端中指定服务器的资源。</p><p>420：（方法失效）不是HTTP的标准，但是被Spring定义在HTTP状态类中当方法失时使用。这个状态码已经不推荐在Spring中使用。</p><p>420：（提高你的耐心）也不是HTTP标准的一部分，但是被版本1的Twitter搜索和趋势APi返回当客户端的速率被限制的时候。其它的服务提供商可能会使用429太多的请求响应码来代替。</p><p>421：从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</p><p>422：请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked</p><p>当前资源被锁定。（RFC 4918 WebDAV）</p><p>424：由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</p><p>425：在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</p><p>426：客户端应当切换到TLS&#x2F;1.0。（RFC 2817）</p><p>428：(需要前置条件)原始服务器需要有条件的请求。当客户端GET一个资源的状态的时候，同时又PUT回给服务器，与此同时第三方修改状态到服务器上的时候，为了避免丢失更新的问题发生将会导致冲突。</p><p>429：（过多请求）用户已经发送了太多的请求在指定的时间里。用于限制速率。</p><p>431：（请求头部字段太大）服务器由于一个单独的请求头部字段或者是全部的字段太大而不愿意处理请求。</p><p>440：（登陆超时（微软））一个微软的扩展，意味着你的会话已经超时。</p><p>444：（无响应）被使用在Nginx的日志中表明服务器没有返回信息给客户端并且关闭了连接（在威慑恶意软件的时候比较有用）。</p><p>449：（重试（微软））一个微软的扩展。请求应该在执行适当的动作之后被重试。</p><p>450：（被Windows家长控制阻塞（微软））一个微软的扩展。这个错误是当Windows家长控制打开并且阻塞指定网页的访问的时候被指定。</p><p>451：（由于法律原因而无效（因特网草稿））被定义在因特网草稿“一个新的HTTP状态码用于法律限制的资源”。被用于当资源的访问由于法律原因被禁止的时候。例如检查制度或者是政府强制要求禁止访问。一个例子是1953年dystopian的小说Fahrenheit 451就是一个非法的资源。</p><p>451：（重定向（微软））被用在Exchange ActiveSync中如果一个更有效的服务器能够被使用或者是服务器不能访问用户的邮箱。客户端会假定重新执行HTTP自动发现协议去寻找更适合的服务器。</p><p>494：（请求头太大（Nginx））Nginx内置代码和431类似，但是是被更早地引入在版本0.9.4（在2011年1月21日）。</p><p>495：（证书错误（Nginx））Nginx内置的代码，当使用SSL客户端证书的时候错误会出现为了在日志错误中区分它和4XX和一个错误页面的重定向。。</p><p>496：（没有证书（Nginx））Nginx内置的代码，当客户端不能提供证书在日志中分辨4XX和一个错误页面的重定向。</p><p>497：（HTTP到HTTPS（Nginx））Nginx内置的代码，被用于原始的HTTP的请求发送给HTTPS端口去分辨4XX在日志中和一个错误页面的重定向。</p><p>498：（令牌超时或失效（Esri））由ArcGIS for Server返回。这个代码意味着令牌的超时或者是失效。</p><p>499：（客户端关闭请求（Nginx））被用在Nginx日志去表明一个连接已经被客户端关闭当服务器仍然正在处理它的请求，是的服务器无法返货状态码。</p><p>499：（需要令牌（Esri））由ArcGIS for Server返回。意味着需要一个令牌（如果没有令牌被提交）。</p></blockquote><ul><li>5xx：</li></ul><blockquote><p>500：（服务器内部错误） 服务器遇到错误，无法完成请求。</p><p>501：（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</p><p>502：（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</p><p>503：（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</p><p>504：（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p><p>505：（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p><p>506：由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</p><p>507：服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</p><p>508：（发现环路）服务器发现了一个无限的循环档处理请求的时候。</p><p>509：服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</p><p>510：获取资源所需要的策略并没有没满足。（RFC 2774）。</p><p>511：（需要网络授权）客户端需要授权去火的网络的访问权限。一般用于代理交互中被用来进行网络的访问控制。</p><p>520：（未知错误）这个状态码也没有被指定在任何RFC中，并且只会被一些服务器返回，例如微软的Azure和CloudFlare服务器:”520错误。本质上是一个捕获全部的响应当原始服务器返回一些未知的或者一些不能被忍受或者被解释的(协议违反或者空响应)”。</p><p>598：（网络读取超时异常(未知)）这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络读取超时在一个客户端之前的代理的后面。</p><p>599：（网络连接超时异常(未知)）这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络连接超时在一个客户端之前的代理的后面。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;HTTP状态码（HTTP Status Code）是用来表示网页服务器HTTP响应状态的3位数字代码。&lt;/p&gt;
&lt;h1 id=&quot;类型&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习11：Xcode 常用的快捷键大全</title>
    <link href="https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A011%EF%BC%9AXcode-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/"/>
    <id>https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A011%EF%BC%9AXcode-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/</id>
    <published>2023-03-08T19:12:11.000Z</published>
    <updated>2023-03-08T20:26:04.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通用快捷键"><a href="#通用快捷键" class="headerlink" title="通用快捷键"></a>通用快捷键</h1><blockquote><p>Command + A ：全选<br>Command + C ：复制<br>Command + V ：粘贴<br>Command + X ：剪切<br>Command + Z ：撤销<br>Command + Shift + Z ： 撤销刚才的撤销</p></blockquote><h1 id="文件快捷键"><a href="#文件快捷键" class="headerlink" title="文件快捷键"></a>文件快捷键</h1><blockquote><p>Command + S ：保存<br>Command + Shift + S ：另存为</p></blockquote><h1 id="项目快捷键"><a href="#项目快捷键" class="headerlink" title="项目快捷键"></a>项目快捷键</h1><blockquote><p>Command + Shift + N ：新建项目<br>Command + N ：新建文件<br>Command + O ：打开文件<br>Command + D ：快速复制一段代码<br>Optional + 单击 ：显示描述文件<br>Command +  单击：跳转函数<br>Command + Optional + 上&#x2F;下箭头 ：快速切换.h和.m文件</p><p>Command + 0 ：显示&#x2F;隐藏导航器面板<br>Command + Optional + 0 ：显示&#x2F;隐藏工具面板<br>Command + Shift + o ：快速搜索</p></blockquote><h1 id="注释快捷键"><a href="#注释快捷键" class="headerlink" title="注释快捷键"></a>注释快捷键</h1><blockquote><p>Command + Optional + &#x2F; ：快速注释<br>Command + &#x2F; ：单行注释</p></blockquote><h1 id="折叠-x2F-展开快捷键"><a href="#折叠-x2F-展开快捷键" class="headerlink" title="折叠&#x2F;展开快捷键"></a>折叠&#x2F;展开快捷键</h1><blockquote><p>Command + Optional + 左箭头 ：折叠代码<br>Command + Optional + 右箭头 ：展开代码</p></blockquote><h1 id="文字快捷键"><a href="#文字快捷键" class="headerlink" title="文字快捷键"></a>文字快捷键</h1><blockquote><p>Command + - ：缩小文字<br>Command + + ：放大文字</p></blockquote><h1 id="调试运行、停止"><a href="#调试运行、停止" class="headerlink" title="调试运行、停止"></a>调试运行、停止</h1><blockquote><p>Command + B ：编译<br>Command + R ：运行<br>Command + . ：停止<br>Command + Shift + K ：清理</p></blockquote><h1 id="移动代码块"><a href="#移动代码块" class="headerlink" title="移动代码块"></a>移动代码块</h1><blockquote><p>Command + [ ：左移代码块<br>Command + ] ：右移代码块</p></blockquote><blockquote><p>Command + Optional + [ ：上移代码块<br>Command + Optional + ] ：下移代码块</p></blockquote><h1 id="移动光标快捷键"><a href="#移动光标快捷键" class="headerlink" title="移动光标快捷键"></a>移动光标快捷键</h1><blockquote><p>Command + 左&#x2F;右箭头 ：将光标移动至行首&#x2F;尾<br>Command + 上&#x2F;下箭头 ：将光标移动至文档行首&#x2F;尾</p></blockquote><blockquote><p>Command + Shift + 左&#x2F;右箭头 ：向左&#x2F;右选择一个单词</p></blockquote><blockquote><p>Command + Shift + 左&#x2F;右箭头 ：选择到行首&#x2F;尾</p></blockquote><h1 id="调试快捷键"><a href="#调试快捷键" class="headerlink" title="调试快捷键"></a>调试快捷键</h1><blockquote><p>Command + \ ：设置&#x2F;取消断点</p></blockquote><h1 id="窗口快捷键"><a href="#窗口快捷键" class="headerlink" title="窗口快捷键"></a>窗口快捷键</h1><blockquote><p>Command + H ：隐藏<br>Command + M ：最小化<br>Command + P ：打印<br>Command + Q ：退出项目<br>Command + W ：关闭当前文件</p></blockquote><h1 id="窗口切换快捷键"><a href="#窗口切换快捷键" class="headerlink" title="窗口切换快捷键"></a>窗口切换快捷键</h1><blockquote><p>Command + Tab ：程序间切换<br>Command + ~ ：窗口间切换</p></blockquote><h1 id="屏幕快捷键"><a href="#屏幕快捷键" class="headerlink" title="屏幕快捷键"></a>屏幕快捷键</h1><blockquote><p>Command + Shift + F3 ：截图整个屏幕<br>Command + Shift + F4 ：截取指定区域</p></blockquote><h1 id="系统快捷键"><a href="#系统快捷键" class="headerlink" title="系统快捷键"></a>系统快捷键</h1><blockquote><p>Command + Optional + ESC ：强制退出程序<br>Command + Space ：切换语言<br>Command + Shift + ？：帮助 </p></blockquote><h1 id="编辑快捷键"><a href="#编辑快捷键" class="headerlink" title="编辑快捷键"></a>编辑快捷键</h1><blockquote><p>Command + Delete ：删除<br>Command + Shift + Delete ：清空垃圾桶<br>Command + Shift + A ：打开应用程序目录<br>Command + Shift + C ：打开 Computer 目录<br>Command + Shift + H ：打开 Home 目录</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通用快捷键&quot;&gt;&lt;a href=&quot;#通用快捷键&quot; class=&quot;headerlink&quot; title=&quot;通用快捷键&quot;&gt;&lt;/a&gt;通用快捷键&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Command + A ：全选&lt;br&gt;Command + C ：复制&lt;br&gt;Command</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习10：iPhone各系列尺寸大全</title>
    <link href="https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A010%EF%BC%9AiPhone%E5%90%84%E7%B3%BB%E5%88%97%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%85%A8/"/>
    <id>https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A010%EF%BC%9AiPhone%E5%90%84%E7%B3%BB%E5%88%97%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%85%A8/</id>
    <published>2023-03-08T19:11:14.000Z</published>
    <updated>2023-03-08T21:07:28.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iPhone手机尺寸大全"><a href="#iPhone手机尺寸大全" class="headerlink" title="iPhone手机尺寸大全"></a>iPhone手机尺寸大全</h1><table><thead><tr><th align="center">机型</th><th align="center">屏幕尺寸 （英寸）</th><th align="center">分辨率（pt）</th><th align="center">像素（px）</th><th align="center">图片后缀</th><th align="center">安全区域（上&#x2F;下）</th></tr></thead><tbody><tr><td align="center">iPhone4&#x2F;4s</td><td align="center">3.5</td><td align="center">320x480</td><td align="center">640x960</td><td align="center">@2x</td><td align="center"></td></tr><tr><td align="center">iPhone5&#x2F;5c&#x2F;5s&#x2F;SE</td><td align="center">4</td><td align="center">320x568</td><td align="center">640x1136</td><td align="center">@2x</td><td align="center"></td></tr><tr><td align="center">iPhone6&#x2F;6s&#x2F;7&#x2F;8</td><td align="center">4.7</td><td align="center">375x667</td><td align="center">750x1334</td><td align="center">@2x</td><td align="center"></td></tr><tr><td align="center">iPhone6&#x2F;6s&#x2F;7&#x2F;8 Plus</td><td align="center">5.5</td><td align="center">414x736</td><td align="center">1080x1920</td><td align="center">@3x</td><td align="center"></td></tr><tr><td align="center">iPhoneX&#x2F;iPhoneXS&#x2F;11Pro</td><td align="center">5.8</td><td align="center">375x812</td><td align="center">1125x2436</td><td align="center">@3x</td><td align="center">44&#x2F;34</td></tr><tr><td align="center">iPhoneXR&#x2F;11</td><td align="center">6.1</td><td align="center">414x896</td><td align="center">828x1792</td><td align="center">@2x</td><td align="center">48&#x2F;34</td></tr><tr><td align="center">iPhoneXSMax&#x2F;11ProMax</td><td align="center">6.5</td><td align="center">414x896</td><td align="center">1242x2688</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone12mini（&gt;&#x3D;iOS14） iPhone13mini（&gt;&#x3D;iOS15）</td><td align="center">5.4</td><td align="center">360x780</td><td align="center">1080x2340</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone12&#x2F;12Pro iPhone13&#x2F;13Pro</td><td align="center">6.1</td><td align="center">390x844</td><td align="center">1170x2532</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone12&#x2F;13ProMax</td><td align="center">6.7</td><td align="center">428x926</td><td align="center">1284x2778</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone14 （&gt;&#x3D;iOS16）</td><td align="center">6.1</td><td align="center">390x844</td><td align="center">1170x2532</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone14 Plus</td><td align="center">6.7</td><td align="center">428x926</td><td align="center">1284x2778</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone14 Pro</td><td align="center">6.1</td><td align="center">393x852</td><td align="center">1179x2556</td><td align="center">@3x</td><td align="center">59&#x2F;34</td></tr><tr><td align="center">iPhone14 Pro Max</td><td align="center">6.7</td><td align="center">430x932</td><td align="center">1290x2796</td><td align="center">@3x</td><td align="center">59&#x2F;34</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iPhone手机尺寸大全&quot;&gt;&lt;a href=&quot;#iPhone手机尺寸大全&quot; class=&quot;headerlink&quot; title=&quot;iPhone手机尺寸大全&quot;&gt;&lt;/a&gt;iPhone手机尺寸大全&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;c</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习12：修改项目名称</title>
    <link href="https://www.bboyzj.cn/2023/03/08/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A008%EF%BC%9A%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.bboyzj.cn/2023/03/08/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A008%EF%BC%9A%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E7%9A%84%E6%B5%81%E7%A8%8B/</id>
    <published>2023-03-08T12:20:10.000Z</published>
    <updated>2023-03-09T07:11:19.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>如果我们在项目中集成三方库 <code>SDwebImage</code> 时，报错 <code>Framework not found Pods_________</code>，说明 <code>工程名称用汉字了</code>，这个时候就需要更改项目名</p></li><li><p>在开发过程中需求想更改项目名</p></li></ul><h1 id="修改名称"><a href="#修改名称" class="headerlink" title="修改名称"></a>修改名称</h1><p>Xcode 修改 工程名</p><ul><li>打开 <code>Xcode</code> 的 <code>Show the File Inspector</code>，修改 <code>Name</code> 为 <code>FirstFrameDemo</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082129005.png"                                     ></p><ul><li>修改成 <code>FirstFrameDemo</code> 之后，回车， 这里 Xcode 列举了可以为我们做的更改的名称</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082130570.png"                                     ></p><ul><li><p>点击 Rename -&gt; OK，Xcode 为我们重命名了一部分。</p></li><li><p>关闭项目工程，修改项目文件夹名称（由原工程名 -&gt; 修改成新的工程名）</p></li></ul><p>修改前：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16782822322176.jpg"                                     ></p><p>修改后：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082130315.png"                                     ></p><ul><li>修改项目文件名（右击选择包内容）</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082130950.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16782822658087.jpg"                                     ></p><ul><li>点击 project.phxproj 文件，将 <code>获取视频的第一帧</code> 替换成 <code>FirstFrameDemo</code> ，全部替换 All -&gt; Done</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16782822796912.jpg"                                     ></p><ul><li>打开项目 <code>FirstFrameDemo.xcworkspace</code> ，项目内全局替换 <code>获取视频的第一帧 -&gt; FirstFrameDemo</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082131991.png"                                     ></p><ul><li>修改 <code>Podfile</code> 文件中项目名称</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082131395.png"                                     ></p><ul><li>打开终端，切换到当前项目目录下，执行 <code>pos intall</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082131192.png"                                     ></p><ul><li>删除旧的 <code>workspace</code> 文件</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082132150.png"                                     ></p><ul><li>至此项目名已经完全修改完成了</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082133952.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果我们在项目中集成三方库 &lt;code&gt;SDwebImage&lt;/code&gt; 时，报错 &lt;code&gt;Framework no</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习11：Pch文件</title>
    <link href="https://www.bboyzj.cn/2023/03/08/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A009%EF%BC%9APch%E6%96%87%E4%BB%B6/"/>
    <id>https://www.bboyzj.cn/2023/03/08/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A009%EF%BC%9APch%E6%96%87%E4%BB%B6/</id>
    <published>2023-03-08T11:43:38.000Z</published>
    <updated>2023-03-08T18:54:39.914Z</updated>
    
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习10：UITableViw点击事件和页面上的手势冲突怎么解决？</title>
    <link href="https://www.bboyzj.cn/2023/03/07/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A007%EF%BC%9AUITableViw%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%92%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/"/>
    <id>https://www.bboyzj.cn/2023/03/07/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A007%EF%BC%9AUITableViw%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%92%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/</id>
    <published>2023-03-07T11:17:26.000Z</published>
    <updated>2023-03-08T11:41:42.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h1><p>下面以一个例子讲解</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16782753246943.jpg"                                     ></p><p>图中 <code>superView</code> 有两个 <code>subView</code>，分别是 <code>testView</code> 和 <code>testBtn</code>。我们在 <code>superView</code> 和 <code>testView</code> 都重载 <code>touchsBegan:withEvent、touchsEnded:withEvent、 touchsMoved:withEvent、touchsCancelled:withEvent方法</code>，并且在 <code>superView</code> 上添加单击手势 <code>UITapGestureRecognizer</code>，action名为tapAction，给testBtn绑定action名为testBtnClicked。</p><p>主要代码如下：</p><ul><li>SuperView</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)initUI&#123;</span><br><span class="line">    UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapAction)];</span><br><span class="line">    [self addGestureRecognizer:tap];</span><br><span class="line">    </span><br><span class="line">    [self addSubview:self.testView];</span><br><span class="line">    [self addSubview:self.testBtn];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;=========&gt; superView touchs Began&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">     NSLog(@&quot;=========&gt; superView touchs Moved&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">     NSLog(@&quot;=========&gt; superView touchs Ended&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">     NSLog(@&quot;=========&gt; superView touchs Cancelled&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)tapAction &#123;</span><br><span class="line">     NSLog(@&quot;=========&gt; single Tapped&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)clickBtn &#123;</span><br><span class="line">     NSLog(@&quot;=========&gt; click btn&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>textView</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//testView</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;=========&gt; testView touchs Began&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;=========&gt; testView touchs Moved&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;=========&gt; testView touchs Ended&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;=========&gt; testView touchs Cancelled&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>情景O：注释 手势 ，分别点击 superView 和 testView：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2023-03-08 17:58:44.408166+0800 手势冲突[20427:1092257] =========&gt; superView touchs Began</span><br><span class="line">2023-03-08 17:58:44.544181+0800 手势冲突[20427:1092257] =========&gt; superView touchs Ended</span><br><span class="line"></span><br><span class="line">2023-03-08 17:58:54.666862+0800 手势冲突[20427:1092257] =========&gt; testView touchs Began</span><br><span class="line">2023-03-08 17:58:54.825938+0800 手势冲突[20427:1092257] =========&gt; testView touchs Ended</span><br></pre></td></tr></table></figure></div><ul><li>情景A：单击 superView ，输出结果：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2023-03-08 17:32:44.983101+0800 手势冲突[20227:1064772] =========&gt; superView touchs Began</span><br><span class="line">2023-03-08 17:32:45.043310+0800 手势冲突[20227:1064772] =========&gt; single Tapped</span><br><span class="line">2023-03-08 17:32:45.043538+0800 手势冲突[20227:1064772] =========&gt; superView touchs Cancelled</span><br></pre></td></tr></table></figure></div><ul><li>情景B：单击 testView，输出结果：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2023-03-08 17:43:16.370199+0800 手势冲突[20326:1077469] =========&gt; testView touchs Began</span><br><span class="line">2023-03-08 17:43:16.430723+0800 手势冲突[20326:1077469] =========&gt; single Tapped</span><br><span class="line">2023-03-08 17:43:16.430939+0800 手势冲突[20326:1077469] =========&gt; testView touchs Cancelled</span><br></pre></td></tr></table></figure></div><ul><li>情景C：单击 testBtn，输出结果：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023-03-08 17:43:40.690096+0800 手势冲突[20326:1077469] =========&gt; click btn</span><br></pre></td></tr></table></figure></div><ul><li>情景D：按住 testView，过3秒后或更久释放，输出结果：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2023-03-08 17:43:50.678603+0800 手势冲突[20326:1077469] =========&gt; testView touchs Began</span><br><span class="line">2023-03-08 17:43:53.499119+0800 手势冲突[20326:1077469] =========&gt; testView touchs Ended</span><br></pre></td></tr></table></figure></div><h2 id="情景-O、A、B-分析"><a href="#情景-O、A、B-分析" class="headerlink" title="情景 O、A、B 分析"></a>情景 <code>O、A、B</code> 分析</h2><p>开发文档可知：</p><blockquote><p>Gesture Recognizers Get the First Opportunity to Recognize a Touch.</p><p>A window delays the delivery of touch objects to the view so that the gesture recognizer can analyze the touch first. During the delay, if the gesture recognizer recognizes a touch gesture, then the window never delivers the touch object to the view, and also cancels any touch objects it previously sent to the view that were part of that recognized sequence.</p></blockquote><p>Google翻译：</p><blockquote><p>手势识别器获得识别触摸的第一个机会。</p><p>一个窗口延迟将触摸对象传递到视图，使得手势识别器可以首先分析触摸。 在延迟期间，如果手势识别<br>器识别出触摸手势，则窗口不会将触摸对象传递到视图，并且还将先前发送到作为识别的序列的一部分的视图的任何触摸对象取消。</p></blockquote><ul><li><code>触摸事件首先传递到手势上，如果手势识别成功了，就会取消事件的继续传递</code>，否则，事件还是会被响应链处理。系统维持了与响应链关联的所有手势，事件首先传递给手势，然后才传递给响应链。这样我们就解释A和B的场景了</li></ul><h2 id="情景-C-分析："><a href="#情景-C-分析：" class="headerlink" title="情景 C 分析："></a>情景 <code>C</code> 分析：</h2><p>iOS 开发文档里这样说：</p><blockquote><p>In iOS 6.0 and later, default control actions prevent overlapping gesture recognizer behavior. For example, the default action for a button is a single tap. If you have a single tap gesture recognizer attached to a button’s parent view, and the user taps the button, then the button’s action method receives the touch event instead of the gesture recognizer. This applies only to gesture recognition that overlaps the default action for a control, which includes:</p><p>A single finger single tap on a UIButton, UISwitch, UISegmentedControl, UIStepper,and UIPageControl.A single finger swipe on the knob of a UISlider, in a direction parallel to the slider.A single finger pan gesture on the knob of a UISwitch, in a direction parallel to the switch.</p></blockquote><p>Google 翻译为：</p><blockquote><p>在iOS 6.0及更高版本中，默认控制操作可防止重叠的手势识别器行为。 例如，按钮的默认操作是单击。 如果您有一个单击手势识别器附加到按钮的父视图，并且用户点击按钮，则按钮的动作方法接收触摸事件而不是手势识别器。 这仅适用于与控件的默认操作重叠的手势识别，其中包括：</p><p>单个手指单击UIButton，UISwitch，UISegmentedControl，UIStepper和UIPageControl.<br>单个手指在UISlider的旋钮上滑动，在平行于滑块的方向上。在UISwitch的旋钮上的单个手指平移手势 与开关平行的方向。</p></blockquote><ul><li>因此，在情景C，点击testBtn的action，按钮获取了事件响应，不会把事件响应传递给父视图的supView</li></ul><h2 id="情景-C-分析：-1"><a href="#情景-C-分析：-1" class="headerlink" title="情景 C 分析："></a>情景 <code>C</code> 分析：</h2><ul><li>长按testView已经不是单击事件了，tap手势就不会识别</li></ul><h1 id="实际开发中遇到的问题"><a href="#实际开发中遇到的问题" class="headerlink" title="实际开发中遇到的问题"></a>实际开发中遇到的问题</h1><ul><li><p>父视图上先后添加了一个 <code>UIGestureRecognizer</code> 和一个 <code>UITableView</code></p></li><li><p>我们发现在点击 <code>UITableView</code> 的 <code>cell</code> 的时候，并没有触发 <code>-(void)tableView:(UITableView*)tableView didSelectRowAtIndexPath:(NSIndexPath*)indexPath;</code> 方法。</p></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于 cell 继承 cell -&gt; UIView -&gt; UIResponder，是可以接收和处理事件的，但是添加了 <code>tap</code> 后会导致 <code>cell</code> 响应链无法正常响应，导致 <code>手势冲突</code></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在我们点击 <code>cell</code> 的时候，不让父视图的 <code>手势</code> 干扰子视图cell的点击事件或者说响应链正常传递，一般会重写 <code>UIGestureRecognizerDelegate</code> 中的<code> - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch</code><br>方法。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch&#123;</span><br><span class="line">    // 如果是UITableViewCell类或子类响应事件</span><br><span class="line">    if ([touch.view isKindOfClass:[UITableViewCell class]]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    //默认都需要响应</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">2023-03-08 18:19:39.851593+0800 手势冲突[20552:1111844] -[ParentV tableView:didSelectRowAtIndexPath:]</span><br><span class="line">2023-03-08 18:19:40.583123+0800 手势冲突[20552:1111844] -[ParentV tableView:didSelectRowAtIndexPath:]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;举例说明&quot;&gt;&lt;a href=&quot;#举例说明&quot; class=&quot;headerlink&quot; title=&quot;举例说明&quot;&gt;&lt;/a&gt;举例说明&lt;/h1&gt;&lt;p&gt;下面以一个例子讲解&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
        </summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习06：截取视频文件第一帧的方法有哪些？</title>
    <link href="https://www.bboyzj.cn/2023/03/07/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A006%EF%BC%9A%E6%88%AA%E5%8F%96%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E7%AC%AC%E4%B8%80%E5%B8%A7%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <id>https://www.bboyzj.cn/2023/03/07/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A006%EF%BC%9A%E6%88%AA%E5%8F%96%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E7%AC%AC%E4%B8%80%E5%B8%A7%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</id>
    <published>2023-03-07T11:16:39.000Z</published>
    <updated>2023-03-08T18:53:13.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>iOS 中获取视频第一帧有两种方式</p><h1 id="第一种：使用AVFoundation获取"><a href="#第一种：使用AVFoundation获取" class="headerlink" title="第一种：使用AVFoundation获取"></a>第一种：使用AVFoundation获取</h1><p>将耗时的操作放在异步执行队列 <code>dispatch_async</code>，防止造成线程堵塞，刷新UI放在 <code>主线程</code></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)getFirstFrameFromVideoWithUrl:(NSURL *)url&#123;</span><br><span class="line">    AVURLAsset *asset = [[AVURLAsset alloc] initWithURL:url options:nil];</span><br><span class="line">    AVAssetImageGenerator *assetGennerator = [[AVAssetImageGenerator alloc] initWithAsset:asset];</span><br><span class="line">    assetGennerator.appliesPreferredTrackTransform = YES;</span><br><span class="line">    CMTime time = CMTimeMakeWithSeconds(0.0, 600);</span><br><span class="line">    CMTime actualTime;</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    CGImageRef image = [assetGennerator copyCGImageAtTime:time actualTime:&amp;actualTime error:&amp;error];</span><br><span class="line">    UIImage *videoImg = [[UIImage alloc] initWithCGImage:image];</span><br><span class="line">    CGImageRelease(image);</span><br><span class="line">    return videoImg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="第二种方式：使用SDWebImage获取，并缓存图片"><a href="#第二种方式：使用SDWebImage获取，并缓存图片" class="headerlink" title="第二种方式：使用SDWebImage获取，并缓存图片"></a>第二种方式：使用SDWebImage获取，并缓存图片</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (void)method2&#123;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:@&quot;https://klxxcdn.oss-cn-hangzhou.aliyuncs.com/histudy/hrm/media/bg1.mp4&quot;];</span><br><span class="line">    NSString *urlKey = url.absoluteString;</span><br><span class="line">    // 先从缓存中查找是否有图片</span><br><span class="line">    SDImageCache *imgCache = [SDImageCache sharedImageCache];</span><br><span class="line">    UIImage *memoryImg = [imgCache imageFromCacheForKey:urlKey];</span><br><span class="line">    if (memoryImg) &#123;</span><br><span class="line">        self.imgV.image = memoryImg;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        // 从磁盘中查找是否有图片</span><br><span class="line">        UIImage *diskImg = [imgCache imageFromDiskCacheForKey:urlKey];</span><br><span class="line">        if (diskImg) &#123;</span><br><span class="line">            self.imgV.image = diskImg;</span><br><span class="line">        &#125;else &#123; // 如果都不存在</span><br><span class="line">            // 开启异步线程下载图片</span><br><span class="line">            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">                AVURLAsset *asset = [[AVURLAsset alloc] initWithURL:url options:nil];</span><br><span class="line">                NSParameterAssert(asset);</span><br><span class="line">                AVAssetImageGenerator *assetGenerator = [[AVAssetImageGenerator alloc] initWithAsset:asset];</span><br><span class="line">                assetGenerator.appliesPreferredTrackTransform = YES;</span><br><span class="line">                assetGenerator.apertureMode = AVAssetImageGeneratorApertureModeEncodedPixels;</span><br><span class="line">                CGImageRef thumbImgRef = NULL;</span><br><span class="line">                CFTimeInterval thumbImgTime = 1;</span><br><span class="line">                NSError *thumbImgError = nil;</span><br><span class="line">                thumbImgRef = [assetGenerator copyCGImageAtTime:CMTimeMake(thumbImgTime, 60) actualTime:NULL error:&amp;thumbImgError];</span><br><span class="line">                if (!thumbImgRef)&#123;</span><br><span class="line">                    NSLog(@&quot;thumbImgError:%@&quot;,thumbImgError);</span><br><span class="line">                &#125;</span><br><span class="line">                UIImage *thumbImg = thumbImgRef ? [[UIImage alloc] initWithCGImage:thumbImgRef] : nil;</span><br><span class="line">                // 主线程显示UI</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    SDImageCache *imgCache = [SDImageCache sharedImageCache];</span><br><span class="line">                    [imgCache storeImage:thumbImg forKey:urlKey completion:^&#123;</span><br><span class="line">                        NSLog(@&quot;store Image success&quot;);</span><br><span class="line">                    &#125;];</span><br><span class="line">                    self.imgV.image = thumbImg;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;iOS 中获取视频第一帧有两种方式&lt;/p&gt;
&lt;h1 id=&quot;第一种：使用AVFoundation获取&quot;&gt;&lt;a href=&quot;#第一种：使用AV</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习05：分类和扩展</title>
    <link href="https://www.bboyzj.cn/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A005%EF%BC%9A%E5%88%86%E7%B1%BB%E5%92%8C%E6%89%A9%E5%B1%95/"/>
    <id>https://www.bboyzj.cn/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A005%EF%BC%9A%E5%88%86%E7%B1%BB%E5%92%8C%E6%89%A9%E5%B1%95/</id>
    <published>2023-03-06T13:50:50.000Z</published>
    <updated>2023-03-08T19:02:49.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类-Category"><a href="#分类-Category" class="headerlink" title="分类 Category"></a>分类 Category</h1><ul><li><p>Category 的主要作用是为 <code>已经存在的类添加(扩展)方法</code></p></li><li><p>已存在的类可以是 <code>系统的类</code> 或 <code>自定义的类</code> </p></li><li><p>不能定义 <code>变量（成员变量或实例变量）</code></p></li><li><p>一般情况下也可以定义 <code>属性</code>，但是 <code>不会实现</code> 它的 <code>set</code> 和 <code>get</code> 方法，需要利用 <code>runtime</code> 机制去实现它的 <code>set</code> 和 <code>get</code> 方法。</p></li><li><p>分类文件有 <code>.h</code> 和 <code>.m</code> 两个文件，文件名 <code>@interface 类名 (分类名)</code></p></li></ul><h2 id="创建-系统-分类"><a href="#创建-系统-分类" class="headerlink" title="创建 系统 分类"></a>创建 系统 分类</h2><ul><li><code>command + n</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090249910.png"                                     ></p><ul><li>点击 <code>Objective-C File</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090249569.png"                                     ></p><ul><li>创建完成后会生成 <code>系统文件名+Category.h</code> 和 <code>系统文件名+Category.m</code> 两个文件</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090250512.png"                                     ></p><ul><li>在分类中可以添加 <code>实例方法和类方法</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface UIViewController (Cate)</span><br><span class="line">- (void)sayHello;</span><br><span class="line">+ (void)sayBye;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">==============</span><br><span class="line"></span><br><span class="line">@implementation UIViewController (Cate)</span><br><span class="line">- (void)sayHello&#123;</span><br><span class="line">    NSLog(@&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)sayBye&#123;</span><br><span class="line">    NSLog(@&quot;bye&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>在本类中调用，需要引入头文件  <code>文件名+Category.h</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> // 分类</span><br><span class="line">[self sayHello];</span><br><span class="line">[ViewController sayBye];</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">Category[30386:1690552] bye</span><br><span class="line">2023-03-06 22:06:37.369596+0800 Category[30386:1690552] hello</span><br><span class="line">2023-03-06 22:06:37.369794+0800 Category[30386:1690552] bye</span><br></pre></td></tr></table></figure></div><h2 id="自定义的类-添加-分类"><a href="#自定义的类-添加-分类" class="headerlink" title="自定义的类 添加 分类"></a>自定义的类 添加 分类</h2><ul><li>创建方式类似</li></ul><p>与系统类类似，在 <code>class</code> 中选择自定义的类 <code>Person</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090250135.png"                                     ></p><h2 id="可以在-分类中声明并实现-两个方法，在本类中调用"><a href="#可以在-分类中声明并实现-两个方法，在本类中调用" class="headerlink" title="可以在 分类中声明并实现 两个方法，在本类中调用"></a>可以在 <code>分类中声明并实现</code> 两个方法，在本类中调用</h2><ul><li>分类中声明并实现</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface Person (Category)</span><br><span class="line">- (void)sayHello;</span><br><span class="line">+ (void)sayBye;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line"></span><br><span class="line">@implementation Person (Category)</span><br><span class="line">- (void)sayHello&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)sayBye&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>本类中调用，编译运行，查看打印结果</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        // 本类中调用分类添加的方法</span><br><span class="line">        [self sayHello];</span><br><span class="line">        [Person sayBye];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">2023-03-07 08:14:34.439456+0800 Category[3555:114948] -[Person(Category) sayHello]</span><br><span class="line">2023-03-07 08:14:34.439626+0800 Category[3555:114948] +[Person(Category) sayBye]</span><br></pre></td></tr></table></figure></div><p>那么问题来了，既然本类中可以调用，那么在其他类中是否也可以调用呢？</p><h2 id="其他类中调用-分类-方法"><a href="#其他类中调用-分类-方法" class="headerlink" title="其他类中调用 分类 方法"></a>其他类中调用 分类 方法</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 自定义的类</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">#import &quot;Person+Category.h&quot;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 自定义的类</span><br><span class="line">    Person * p = [[Person alloc] init];</span><br><span class="line">    [p sayHello];</span><br><span class="line">    [Person sayBye];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">2023-03-07 08:19:57.913133+0800 Category[3631:119871] -[Person(Category) sayHello]</span><br><span class="line">2023-03-07 08:19:57.913667+0800 Category[3631:119871] +[Person(Category) sayBye]</span><br></pre></td></tr></table></figure></div><p>由打印结果可知，在VC中时可以调用的</p><p>那么问题又来了，如果本类中和分类中均实现了 <code>同样的方法</code> 会调用哪个？</p><h2 id="分类和本类实现了同样的方法"><a href="#分类和本类实现了同样的方法" class="headerlink" title="分类和本类实现了同样的方法"></a>分类和本类实现了同样的方法</h2><ul><li>在 <code>Person</code> 类中实现一个 <code>sayHello</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)sayHello&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>在 VC 中调用 sayHello</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 自定义的类</span><br><span class="line">Person * p = [[Person alloc] init];</span><br><span class="line">[p sayHello];</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">2023-03-07 08:24:09.821814+0800 Category[3670:122944] -[Person(Category) sayHello]</span><br></pre></td></tr></table></figure></div><p>由打印结果可知，调用的是 <code>分类</code> 的方法，由此我们可以推断，<code>本类的方法被分类替代了</code></p><h1 id="扩展-Extension"><a href="#扩展-Extension" class="headerlink" title="扩展 Extension"></a>扩展 Extension</h1><ul><li>是类的一部分，在编译器和头文件里的@interface一级实现文件里的@implement一起形成一个完整的类，它伴随着类的产生而产生，亦随之一起消亡</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>声明 <code>私有属性、私有方法、私有成员变量</code>，想要被访问 <code>@public</code></li><li>扩展不能为系统类添加扩展（必须有一个类的源码才能添加一个类的Extension），所以你无法为系统的类添加Extension</li><li>成员变量和实例变量是 <code>私有的</code>，不能被外界访问，</li><li>属性可以被外界访问，由于没有实现调用会 <code>carsh</code></li><li>方法可以被外界访问，由于没有实现set和get方法，访问会 <code>carsh</code></li><li>扩展只有一个 <code>.h</code> 文件，因此 所有的都是没办法调用</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>创建 <code>Extension</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090251689.png"                                     ></p><ul><li>自定义类中的代码</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">#import &quot;Person+Extension.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (void)sayHello&#123;</span><br><span class="line">    NSLog(@&quot;%s hello&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>在 <code>#import &quot;Person+Ext.h&quot;</code> 中实现如下代码</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface UIViewController ()</span><br><span class="line">&#123;</span><br><span class="line">    NSString * name;</span><br><span class="line">    @public int age;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic,copy)NSString * sex;</span><br><span class="line">- (void)sayHello;</span><br><span class="line">+ (void)sayBye;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>在 <code>VC</code> 中调用</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Person * p = [Person new];</span><br><span class="line">    // 调用报错或崩溃</span><br><span class="line">//    p-&gt;age = 30;</span><br><span class="line">//    p-&gt;name = &quot;ZJ&quot;;</span><br><span class="line">//    p.sex = @&quot;男&quot;;</span><br><span class="line">//    [Person sayBye];</span><br><span class="line"></span><br><span class="line">    [p sayHello];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">2023-03-06 22:35:02.277867+0800 Extension[30580:1704777] -[Person sayHello] hello</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>如果只有声明没有实现，则调用会 <code>Crash</code></p><h1 id="分类-和-扩展的区别"><a href="#分类-和-扩展的区别" class="headerlink" title="分类 和 扩展的区别"></a>分类 和 扩展的区别</h1><ul><li><p>category 在运行时决议。extension 在编译时决议。所以扩展中的方法没有被实现编译器会报警告，分类中没有被实现编译器不会警告</p></li><li><p>分类原则上只能添加方法，不能添加属性（因为没有实现属性的seter和getter方法，可以通过runtime添加）。扩展能添加方法、实例变量，默认是@private类型的，且只能作用于自身类</p></li><li><p>分类有自己的实现部分。扩展没有实现部分，只能依托对应的类的实现部分。</p></li><li><p>分类可以为系统添加分类。扩展不能为系统添加分类。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分类-Category&quot;&gt;&lt;a href=&quot;#分类-Category&quot; class=&quot;headerlink&quot; title=&quot;分类 Category&quot;&gt;&lt;/a&gt;分类 Category&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Category 的主要作用是为 &lt;code&gt;已经</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习04：JSON和XML数据解析</title>
    <link href="https://www.bboyzj.cn/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A004%EF%BC%9AJSON%E5%92%8CXML%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.bboyzj.cn/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A004%EF%BC%9AJSON%E5%92%8CXML%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/</id>
    <published>2023-03-06T06:09:53.000Z</published>
    <updated>2023-03-07T12:01:51.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>在 <code>iOS</code> 开发中，常见的数据传输格式有两种：<code>JSON和XML</code>。</p></li><li><p>服务器返回客户端的数据，一般都是 <code>JSON格式或XML格式（文件下载除外）</code></p></li><li><p><code>JSON</code> 由于 <code>体积小、传输快速 </code>等优点，逐渐成为了 <code>主流的数据传输格式</code>。</p></li></ul><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>在 iOS 中，常见解析方案有以下几种：</p><ul><li><p>第三方框架：JSONKit、SBJson、TouchJSON（性能从左到右，越来越差）</p></li><li><p>性能最好的是使用 <code>苹果原生的框架</code>： <code>NSJSONSerialization</code></p></li><li><p>JSON格式很像OC中的数组和字典，key必须用双引号</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:22&#125;、[&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:22&#125;,&#123;&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:22&#125;]</span><br></pre></td></tr></table></figure></div><h2 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061810849.png"                                     ></p><h2 id="JSON-转-OC"><a href="#JSON-转-OC" class="headerlink" title="JSON 转 OC"></a>JSON 转 OC</h2><ul><li>第一个参数：要解析的JSON数据，是NSData类型也就是二进制数据</li><li>第二个参数：解析JSON的可选配置参数<ul><li>NSJSONReadingMutableContainers 解析出来的字典和数组是可变的</li><li>NSJSONReadingFragmentsAllowed 解析出来的对象中的字符串是可变的</li><li>NSJSONReadingMutableLeaves 被解析的数据如果既不是字典也不是数组，那么就使用这个</li></ul></li><li>第三个参数：错误信息</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary * dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&amp;error];</span><br></pre></td></tr></table></figure></div><h2 id="OC-转-JSON"><a href="#OC-转-JSON" class="headerlink" title="OC 转 JSON"></a>OC 转 JSON</h2><ul><li>第一个参数：要转换成JSON数据的OC对象，这里是一个字典</li><li>第二个参数：NSJSONWritingPrettyPrinted 对转换之后的JSON对象进行排版，无意义</li><li>第三个参数：错误信息</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSData *data = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;error];</span><br></pre></td></tr></table></figure></div><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><ul><li>XML 可扩展标记语言，是一种数据交互格式，也叫XML文档</li><li>XML 被设计用来传输和存储数据</li></ul><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>常见的XML文档由三部分组成</p><ul><li>文档声明</li></ul><p>在XML文档最前面，必须编写一个文档声明，用来声明XML文档的类型</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 最简单的声明</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line"></span><br><span class="line">// 用encoding属性说明文档的字符编码</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br></pre></td></tr></table></figure></div><ul><li><p>元素</p><ul><li>一个元素包括了 <code>开始标签和结束标签</code>，</li><li>有内容的元素 <code>&lt;name&gt;Tom&lt;/name&gt;</code>；没内容的元素 <code>&lt;from&gt;&lt;/from&gt;</code>，可简写成 <code>&lt;from/&gt;</code></li><li>元素可嵌套其他元素，不可出现交叉嵌套</li></ul></li><li><p>属性</p></li></ul><p>一个元素最多可以拥有多个属性，属性值必须用双引号 <code>&quot; &quot;</code> 或 单引号 <code>&#39; &#39;</code> 括住</p><ul><li>示例</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line">    &lt;person id=&quot;p1&quot;&gt;</span><br><span class="line">        &lt;name&gt;Tom&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;24&lt;/age&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure></div><h2 id="XML-解析的方法"><a href="#XML-解析的方法" class="headerlink" title="XML 解析的方法"></a>XML 解析的方法</h2><p>要想从XML中提取信息，就得解析XML，目前针对XML的解析有两种方式：</p><ul><li>SAX：从根元素开始，按照顺序一个元素一个元素的往下解析，可用于解析大、小文件</li><li>DOM：一次性将整个XML文档加载到内存中，适合较小的文件</li></ul><p><code>iOS</code> 中解析 <code>XML</code> 有两种：</p><ul><li><p>苹果原生：使用 <code>NSXMLParse</code>，SAX方式解析，使用简答</p></li><li><p>第三方框架：<code>libxml2、GDataXML</code></p><ul><li><code>libxml2</code> 纯 c 语音，默认包含在iOS SDK中，同时支持DOM和SAX方式解析</li><li><code>GDataXMLDOM</code> 解析，由 <code>google</code> 基于 <code>libxml2</code> 开发</li></ul></li></ul><p>解析XML大文件建议用：<code>NSXMLParse、libxml2</code><br>解析XML小文件上述三种都可以</p><h2 id="NSXMLParse-使用"><a href="#NSXMLParse-使用" class="headerlink" title="NSXMLParse 使用"></a>NSXMLParse 使用</h2><ul><li><p>添加NSXMLParserDelegate协议</p></li><li><p>获取XML文件，初始化NSXMLParser，并开启解析</p></li><li><p>实现协议中的方法</p></li></ul><p><strong>XMLElement 文件</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@interface XMLElement : NSObject</span><br><span class="line">// 元素名称</span><br><span class="line">@property (nonatomic,strong)NSString *name;</span><br><span class="line">//元素节点文本</span><br><span class="line">@property (nonatomic,strong)NSMutableString *text;</span><br><span class="line">@property (nonatomic,strong)NSDictionary *attribute;</span><br><span class="line">@property (nonatomic,strong)XMLElement *parent;</span><br><span class="line">@property (nonatomic,strong)NSMutableArray&lt;XMLElement *&gt; *childElement;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">🔽</span><br><span class="line"></span><br><span class="line">#import &quot;XMLElement.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation XMLElement</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _text=[[NSMutableString alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (NSMutableArray&lt;XMLElement *&gt; *)childElement&#123;</span><br><span class="line">    if (!_childElement) &#123;</span><br><span class="line">        _childElement = [[NSMutableArray alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    return _childElement;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)description&#123;</span><br><span class="line">    NSDictionary *dic = [self convertToDic];</span><br><span class="line">    if ([NSJSONSerialization isValidJSONObject:dic]) &#123;</span><br><span class="line">        NSError *error;</span><br><span class="line">        NSData *jsonData=[NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;error];</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            return @&quot;&#123;&#125;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (jsonData) &#123;</span><br><span class="line">            @try &#123;</span><br><span class="line">                NSString *jsonStr = [[NSString alloc]initWithData:jsonData encoding:NSUTF8StringEncoding];</span><br><span class="line">                return jsonStr;</span><br><span class="line">            &#125; @catch (NSException *exception) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return @&quot;&#123;&#125;&quot;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">- (NSDictionary *)convertToDic&#123;</span><br><span class="line">    NSMutableDictionary *dic = [[NSMutableDictionary alloc] init];</span><br><span class="line">    if (self.name) &#123;</span><br><span class="line">        dic[self.name]=self.text;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.attribute &amp;&amp; self.attribute.count &gt; 0) &#123;</span><br><span class="line">        [dic addEntriesFromDictionary:self.attribute];</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.childElement &amp;&amp; self.childElement.count &gt; 0) &#123;</span><br><span class="line">        NSMutableArray *child=[[NSMutableArray alloc]init];</span><br><span class="line">        for (XMLElement *element in self.childElement) &#123;</span><br><span class="line">            NSDictionary *childDic = [element convertToDic];</span><br><span class="line">            if (element.childElement &amp;&amp; element.childElement.count &gt; 0) &#123;</span><br><span class="line">                [child addObject:childDic];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                [dic addEntriesFromDictionary:childDic];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (child.count &gt; 0) &#123;</span><br><span class="line">            dic[@&quot;child&quot;]=child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dic;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p><strong>XMLParserManager 文件</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;XMLElement.h&quot;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">typedef void(^ParserXMLCompletion) (BOOL success, XMLElement * _Nullable data,NSError * _Nullable error);</span><br><span class="line">@interface XMLParserManager : NSObject</span><br><span class="line">@property(nonatomic,copy)ParserXMLCompletion completion;</span><br><span class="line">- (void)parserXMLWithUrl:(NSURL *)url completion:(ParserXMLCompletion)completion;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">🔽</span><br><span class="line"></span><br><span class="line">#import &quot;XMLParserManager.h&quot;</span><br><span class="line"></span><br><span class="line">@interface XMLParserManager()&lt;NSXMLParserDelegate&gt;</span><br><span class="line">@property (nonatomic,strong)NSXMLParser *parser;</span><br><span class="line">@property (nonatomic,strong)XMLElement *rootElement;</span><br><span class="line">@property (nonatomic,strong)XMLElement *currentElement;</span><br><span class="line">@end</span><br><span class="line">@implementation XMLParserManager</span><br><span class="line">- (void)parserXMLWithUrl:(NSURL *)url completion:(ParserXMLCompletion)completion&#123;</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        self.completion = completion;</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        NSInputStream *fileInput=[[NSInputStream alloc] initWithURL:url];</span><br><span class="line">        // 创建一个解析器</span><br><span class="line">        _parser = [[NSXMLParser alloc] initWithStream:fileInput];</span><br><span class="line">        // 设置代理</span><br><span class="line">        _parser.delegate = self;</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^&#123;</span><br><span class="line">            __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">            // 开始解析</span><br><span class="line">            [strongSelf.parser parse];</span><br><span class="line">            // 解析错误</span><br><span class="line">            if (weakSelf.parser.parserError) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    if (completion) &#123;</span><br><span class="line">                        completion(NO,nil,strongSelf.parser.parserError);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 文档开始</span><br><span class="line">-(void)parserDidStartDocument:(NSXMLParser *)parser&#123;</span><br><span class="line">    self.rootElement = nil;</span><br><span class="line">    self.currentElement = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 开始解析某个节点</span><br><span class="line"> parser xml对象</span><br><span class="line"> elementName 标签</span><br><span class="line"> namespaceURI 命名控件指向的链接</span><br><span class="line"> qName 命名控件名称</span><br><span class="line"> attributeDict 节点的所有属性</span><br><span class="line"> */</span><br><span class="line">-(void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary&lt;NSString *,NSString *&gt; *)attributeDict&#123;</span><br><span class="line"></span><br><span class="line">    if (!self.rootElement) &#123;</span><br><span class="line">        self.rootElement = [[XMLElement alloc]init];</span><br><span class="line">        self.currentElement = self.rootElement;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        XMLElement *element = [[XMLElement alloc]init];</span><br><span class="line">        // 父节点</span><br><span class="line">        element.parent = self.currentElement;</span><br><span class="line">        // 当前元素的子节点</span><br><span class="line">        [self.currentElement.childElement addObject:element];</span><br><span class="line">        element.name = elementName;</span><br><span class="line">        // 更换当前元素</span><br><span class="line">        self.currentElement = element;</span><br><span class="line">    &#125;</span><br><span class="line">    // 元素名和属性</span><br><span class="line">    self.currentElement.name = elementName;</span><br><span class="line">    self.currentElement.attribute = attributeDict;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当解析器找到开始标记和结束标记之间的字符时，调用这个方法解析当前节点的所有字符</span><br><span class="line">- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string&#123;</span><br><span class="line">    // 获取当前元素的内容</span><br><span class="line">    [self.currentElement.text appendString:string];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结束解析</span><br><span class="line">-(void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName&#123;</span><br><span class="line">    self.currentElement = self.currentElement.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文档结束</span><br><span class="line">-(void)parserDidEndDocument:(NSXMLParser *)parser&#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    if (self &amp;&amp; self.completion) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">            strongSelf.completion(YES, strongSelf.rootElement, nil);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解析失败</span><br><span class="line">- (void)parser:(NSXMLParser *)parser validationErrorOccurred:(NSError *)validationError&#123;</span><br><span class="line">    if (self.completion) &#123;</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">            strongSelf.completion(NO, nil,validationError);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p><strong>VC 调用</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;XMLParserManager.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,strong)XMLParserManager *manager;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    [self parserXML];</span><br><span class="line">&#125;</span><br><span class="line">-(void)parserXML&#123;</span><br><span class="line">    NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;xmlText&quot; ofType:@&quot;xml&quot;];</span><br><span class="line">    NSURL *url = [NSURL fileURLWithPath:path];</span><br><span class="line">    _manager=[[XMLParserManager alloc]init];</span><br><span class="line">    [_manager parserXMLWithUrl:url completion:^(BOOL success, XMLElement * _Nullable data, NSError * _Nullable error) &#123;</span><br><span class="line">            if (success) &#123;</span><br><span class="line">                NSLog(@&quot;%@&quot;,data);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                NSLog(@&quot;error = %@&quot;,error);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    NSLog(@&quot;start == &quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><h2 id="GDataXML-使用"><a href="#GDataXML-使用" class="headerlink" title="GDataXML 使用"></a>GDataXML 使用</h2><ul><li>GDataXMLDocument：xml解析入口</li><li>GdataXMLElement：保存查找的数据</li><li>GdataXMLNode：保存解析的数据</li></ul><p><strong>第一步：集成 GDataXML-HTML</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target &#x27;XML文件解析&#x27; do</span><br><span class="line">  # Comment the next line if you don&#x27;t want to use dynamic frameworks</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  pod &#x27;GDataXML-HTML&#x27;, &#x27;~&gt; 1.4.1&#x27;</span><br><span class="line"></span><br><span class="line">  # Pods for XML文件解析</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></div><p><strong>第二步：项目中配置</strong></p><ul><li><p>pod 安装 GDataXML</p></li><li><p>选中target -&gt; Build Settings -&gt; Link Binary With Libraried，搜索添加 <code>libxml2</code></p></li><li><p>Header Search Paths 添加 <code>/usr/include/libxml2</code> </p></li><li><p>Other Linker Flags 添加 <code>-lxml2</code></p></li><li><p>引入头文件使用</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)GDataParserXML&#123;</span><br><span class="line">    // 加载xmlwen文件</span><br><span class="line">    NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;xmlText&quot; ofType:@&quot;xml&quot;];</span><br><span class="line">    NSURL *url = [NSURL fileURLWithPath:path];</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfURL:url];</span><br><span class="line">    NSError *error= nil;</span><br><span class="line">    GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithData:data error:&amp;error];</span><br><span class="line">    // 拿到根元素，得到根元素下所有子孙元素</span><br><span class="line">    NSArray * elementList =[doc.rootElement elementsForName:@&quot;book&quot;];</span><br><span class="line">    for (GDataXMLElement *element in elementList) &#123;</span><br><span class="line">        NSString *title=((GDataXMLElement *)[[element elementsForName:@&quot;title&quot;] firstObject]).stringValue;</span><br><span class="line">        NSString *author=((GDataXMLElement *)[[element elementsForName:@&quot;author&quot;] firstObject]).stringValue;</span><br><span class="line">        NSString *year=((GDataXMLElement *)[[element elementsForName:@&quot;year&quot;] firstObject]).stringValue;</span><br><span class="line">        NSString *price=((GDataXMLElement *)[[element elementsForName:@&quot;price&quot;] firstObject]).stringValue;</span><br><span class="line">        NSLog(@&quot;title = %@  author = %@  year = %@ price = %@&quot;,title,author,year,price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在 &lt;code&gt;iOS&lt;/code&gt; 开发中，常见的数据传输格式有两种：&lt;code&gt;JSON和XML&lt;/code&gt;。&lt;/p</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习40：类&amp;结构体&amp;枚举：下标和下标重载</title>
    <link href="https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A040%EF%BC%9A%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE%EF%BC%9A%E4%B8%8B%E6%A0%87%E5%92%8C%E4%B8%8B%E6%A0%87%E9%87%8D%E8%BD%BD/"/>
    <id>https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A040%EF%BC%9A%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE%EF%BC%9A%E4%B8%8B%E6%A0%87%E5%92%8C%E4%B8%8B%E6%A0%87%E9%87%8D%E8%BD%BD/</id>
    <published>2023-03-05T12:28:10.000Z</published>
    <updated>2023-03-09T08:02:27.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h1><ul><li><p>类、结构体和枚举可以定义 <code>下标</code>，它可以作为访问集合、列表或序列号成员元素的快捷方式。你可以使用下标通过索引值来设置或检索值而不需要为设置和检索分别使用实例方法</p></li><li><p>你可以为一个类型定义多个下标，并且下标会基于传入的索引值的类型选择合适的下标重载使用。下标没有限制单个维度，你可以使用多个输入形参来定义下标以满足自定义类型的需求</p></li></ul><h1 id="下标语法"><a href="#下标语法" class="headerlink" title="下标语法"></a>下标语法</h1><ul><li>下标脚本允许你通过在实例名后面的方括号内写一个或多个值对该类的实例进行查询。它的语法类似于实例方法和计算属性。使用关键字 <code>subscript</code> 来定义下标，并且指定一个或多个输入形式参数和返回类型，与实例方法一样。与实例方法不同的是，下标可以是读写也可以是只读的</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;下标&quot;&gt;&lt;a href=&quot;#下标&quot; class=&quot;headerlink&quot; title=&quot;下标&quot;&gt;&lt;/a&gt;下标&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类、结构体和枚举可以定义 &lt;code&gt;下标&lt;/code&gt;，它可以作为访问集合、列表或序列号成员元素的快捷方式。你可以使用下</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习39：为类&amp;结构体&amp;枚举添加属性和方法</title>
    <link href="https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A039%EF%BC%9A%E4%B8%BA%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <id>https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A039%EF%BC%9A%E4%B8%BA%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/</id>
    <published>2023-03-05T10:25:21.000Z</published>
    <updated>2023-03-09T09:14:55.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为类、结构体、枚举添加-属性"><a href="#为类、结构体、枚举添加-属性" class="headerlink" title="为类、结构体、枚举添加 属性"></a>为类、结构体、枚举添加 属性</h1><h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><ul><li><code>存储属性</code> 是一个作为特定类和结构体实例一部分的 <code>常量或变量</code>。存储属性要么是变量存储属性（由 <code>var</code> 关键字引入），要么是常量存储属性（由 <code>let</code> 关键字引入）</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 存储属性</span><br><span class="line">class DataManager &#123;</span><br><span class="line">    // 变量存储属性</span><br><span class="line">    var fileName = &quot;tex&quot;</span><br><span class="line">    // 常量存储属性</span><br><span class="line">    let age = 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="常量结构体实例的存储属性"><a href="#常量结构体实例的存储属性" class="headerlink" title="常量结构体实例的存储属性"></a>常量结构体实例的存储属性</h2><ul><li>如果你创建了一个 <code>结构体的实例</code> 并且把这个 <code>实例赋值给常量</code>，你 <code>不能修改</code> 这个实例的属性，即使是声明为变量的属性</li></ul><h2 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h2><ul><li><p><code>延迟存储属性的初始值在第一次使用时才进行计算</code>。你可以通过在其声明前面标注 <code>lazy 修饰语</code> 来表示一个 <code>延迟存储属性</code></p></li><li><p>如果被标记为 <code>lazy</code> 修饰符的属性同时被多个线程访问并且属性还没有被初始化，则无法保证属性只初始化一次。</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 存储属性</span><br><span class="line">class DataManager &#123;</span><br><span class="line">    // 延迟存储属性</span><br><span class="line">    lazy var data = [String]()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><ul><li>除了存储属性，<code>类、结构体、枚举</code> 还能定义 <code>计算属性</code>，而它实际并不是存储值。相反，它提供一个读取器和一个可选的设置器来间接得到和设置其它的属性和值。类似于 <code>OC</code> 的 <code>set/get</code> 方法去设值和取值</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 计算属性</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Size &#123;</span><br><span class="line">    var width = 0.0,height = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Rect &#123;</span><br><span class="line">    // 存储属性</span><br><span class="line">    var origin = Point()</span><br><span class="line">    var size = Size()</span><br><span class="line">    // 计算属性：可以通过origin 和 size 计算出来</span><br><span class="line">    var center: Point &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            let centerX = origin.x + size.width/2.0</span><br><span class="line">            let centerY = origin.y + size.height/2.0</span><br><span class="line">            return Point(x:centerX, y:centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        set(newCenter) &#123;</span><br><span class="line">            origin.x = newCenter.x - size.width/2.0</span><br><span class="line">            origin.y = newCenter.y - size.height/2.0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="简写-setter"><a href="#简写-setter" class="headerlink" title="简写 setter"></a>简写 setter</h2><ul><li>如果一个计算属性的设置器没有为将要被设置的值定义一个名字，那么它将被默认命名为 <code>newValue</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set &#123;</span><br><span class="line">    origin.x = newValue.x - size.width/2.0</span><br><span class="line">    origin.y = newValue.y - size.height/2.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="简写-getter"><a href="#简写-getter" class="headerlink" title="简写 getter"></a>简写 getter</h2><ul><li>如果整个 <code>getter</code> 的函数体是一个单一的表达式，那么 <code>getter</code> 隐士返回这个表达式</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 简写 get</span><br><span class="line">get &#123;</span><br><span class="line">    Point(x: origin.x + size.width/2.0,y: origin.y + size.height/2.0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h2><ul><li><p>一个 <code>有读取器</code> 但是 <code>没有设置器</code> 的 <code>计算属性</code> 就是所谓的 <code>只读计算属性</code>。只读计算属性返回一个值，也可以通过点语法访问，但是不能被修改为另一个值</p></li><li><p>你必须用 <code>var关键字</code> 定义计算属性（包括只读计算属性）为变量属性，因为它的值不是固定的。<code>let关键字</code> 只能用于常量属性，用于明确哪些值一旦作为实例初始化就不能更改</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 只读计算属性</span><br><span class="line">struct Rect &#123;</span><br><span class="line">    // 存储属性</span><br><span class="line">    var origin = Point()</span><br><span class="line">    var size = Size()</span><br><span class="line">    // 计算属性：可以通过origin 和 size 计算出来</span><br><span class="line">    var center: Point &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return Point(x: origin.x + size.width/2.0,y: origin.y + size.height/2.0)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="属性观察者"><a href="#属性观察者" class="headerlink" title="属性观察者"></a>属性观察者</h2><ul><li><p><code>willSet</code> 会在该值被存储之前被调用</p></li><li><p><code>didSet</code> 会在一个新值被存储之后被调用</p></li><li><p>如果你实现了一个 <code>willSet</code> 观察者，新的属性值会以常量形式参数传递。你可以再你的 <code>willSet</code> 实现中为这个参数定义名字。如果你没有为它命名，那么它会使用默认值的名字 <code>newValue</code></p></li><li><p>如果你实现了一个 <code>didSet</code> 观察者，一个包含旧属性值的常量形式参数将会被传递。你可以为它命名，也可以使用默认值的形式参数名 <code>oldValue</code>。如果你在属性自己的 <code>disSet</code> 观察者里给自己赋值，你赋值的新值就会取代刚刚设置的值。</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 属性观察者</span><br><span class="line">class StepCounter &#123;</span><br><span class="line">    var totalSteps: Int = 0 &#123;</span><br><span class="line">        willSet(newValue) &#123;</span><br><span class="line">            print(&quot;totalSteps to \(newValue)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            if totalSteps &gt; oldValue &#123;</span><br><span class="line">                print(&quot;add \(totalSteps - oldValue) steps&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let stepCounter = StepCounter()</span><br><span class="line">stepCounter.totalSteps = 100</span><br><span class="line">stepCounter.totalSteps = 200</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">totalSteps to 100</span><br><span class="line">add 100 steps</span><br><span class="line">totalSteps to 200</span><br><span class="line">add 100 steps</span><br></pre></td></tr></table></figure></div><h2 id="全局和局部变量"><a href="#全局和局部变量" class="headerlink" title="全局和局部变量"></a>全局和局部变量</h2><ul><li><code>观察属性的能力同样对全局变量和局部变量有效</code>。<code>全局变量</code> 是定义在 <code>任何函数、方法、闭包或者类型环境之外的变量</code>。<code>局部变量</code> 是定义在 <code>函数、方法或闭包环境之中的变量</code>。</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 全局变量</span><br><span class="line">var count: Int = 0 &#123;</span><br><span class="line">    willSet &#123;</span><br><span class="line">        print(&quot;will set count to \(newValue)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    didSet &#123;</span><br><span class="line">        print(&quot;did change count from \(oldValue) to \(count)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">count = 10</span><br><span class="line"></span><br><span class="line">==============</span><br><span class="line">will set count to 10</span><br><span class="line">did change count from 0 to 10</span><br></pre></td></tr></table></figure></div><h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><ul><li>使用 <code>static</code> 关键字来定义 <code>类型属性</code>。对于 <code>类</code> 的 <code>类型属性</code>，你可以使用 <code>class</code> 关键字来 <code>允许子类重写父类的实现</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 类型属性</span><br><span class="line">class SomeClass &#123;</span><br><span class="line">    static var storedProperty = &quot;some value&quot;</span><br><span class="line">    static var computedProperty: Int &#123;</span><br><span class="line">        return 27</span><br><span class="line">    &#125;</span><br><span class="line">    // 重写get方法</span><br><span class="line">    class var overrideComputedProperty: Int &#123;</span><br><span class="line">        return 107</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></div><h1 id="为类、结构体、枚举添加-方法"><a href="#为类、结构体、枚举添加-方法" class="headerlink" title="为类、结构体、枚举添加 方法"></a>为类、结构体、枚举添加 方法</h1><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><ul><li><p><code>实例方法</code> 是属于 <code>特定类实例、结构体实例或枚举实例的函数</code>。他们为这些实例提供功能性，要么通过提供访问和修改实例属性的方法，要么通过提供与实例目的相关的功能</p></li><li><p>每一个类的实例都隐含一个叫做 <code>self</code> 的属性，它完全与实例本身相等。你可以用 <code>self</code> 属性在当前实例中调用自身的方法</p></li><li><p>实际上，你不需要经常在代码中写 <code>self</code>。如果你没有显示地写出 <code>self</code>，<code>swift</code> 会在你方法中使用已知属性或方法的时候假定你调用了当前实例中的属性或者方法</p></li><li><p>例外就是当一个实例方法的形式参数名与实例中某个属性拥有相同的名字的时候。在这种情况下，形式参数名具有优先权，并且调用属性的时候使用更加严谨的方式就很有必要了。你可以使用 <code>self</code> 属性来 <code>区分形式参数名和属性名</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    // 实例方法</span><br><span class="line">    func pringInfo() &#123;</span><br><span class="line">        print(&quot;x is \(x),y is \(y)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p = Point(x: 2,y: 2)</span><br><span class="line">p.pringInfo()</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">x is 2.0,y is 2.0</span><br></pre></td></tr></table></figure></div><h2 id="实例方法-self"><a href="#实例方法-self" class="headerlink" title="实例方法 self"></a>实例方法 self</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    // 实例方法 self</span><br><span class="line">    func isToTheRightOf(x: Double) -&gt; Bool &#123;</span><br><span class="line">        return self.x &gt; x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let somePoint = Point(x: 2.0,y: 3.0)</span><br><span class="line">if somePoint.isToTheRightOf(x: 1.0) &#123;</span><br><span class="line">    print(&quot;the point is x \(somePoint.x)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">the point is x 2.0</span><br></pre></td></tr></table></figure></div><h2 id="在实例方法中修改属性"><a href="#在实例方法中修改属性" class="headerlink" title="在实例方法中修改属性"></a>在实例方法中修改属性</h2><ul><li><p><code>结构体和枚举是值类型</code>。默认情况下，<code>值类型属性不能被自身的实例方法修改</code></p></li><li><p>你可以选择在 <code>func</code> 关键字前放一个 <code>mutating(异变方法)</code> 关键字来 <code>指定可以修改属性</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 修改属性</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    // 异变方法</span><br><span class="line">    mutating func moveBy(x deltaX: Double,y deltaY: Double) &#123;</span><br><span class="line">        x += deltaX</span><br><span class="line">        y += deltaY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var somePoint = Point(x: 1.0, y: 3.0)</span><br><span class="line">somePoint.moveBy(x: 2.0,y: 2.0)</span><br><span class="line">print(&quot;\(somePoint.x) \(somePoint.y)&quot;)</span><br><span class="line"></span><br><span class="line">===========</span><br><span class="line">3.0 5.0</span><br></pre></td></tr></table></figure></div><h2 id="在-mutating-方法中赋值给-self"><a href="#在-mutating-方法中赋值给-self" class="headerlink" title="在 mutating 方法中赋值给 self"></a>在 mutating 方法中赋值给 self</h2><ul><li><code>mutating</code> 方法可以指定整个实例给隐含的 <code>self</code> 属性</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// self</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    // 异变方法</span><br><span class="line">    mutating func moveBy(x deltaX: Double,y deltaY: Double) &#123;</span><br><span class="line">        self = Point(x:x+deltaX,y:y+deltaY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var somePoint = Point(x: 2.0, y: 4.0)</span><br><span class="line">somePoint.moveBy(x: 2.0,y: 2.0)</span><br><span class="line">print(&quot;\(somePoint.x) \(somePoint.y)&quot;)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">4.0 6.0</span><br></pre></td></tr></table></figure></div><h2 id="枚举的-mutating-方法"><a href="#枚举的-mutating-方法" class="headerlink" title="枚举的 mutating 方法"></a>枚举的 mutating 方法</h2><ul><li>枚举的 <code>异变方法</code> 可以设置隐含的 <code>self</code> 属性为相同枚举里的不同成员</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 枚举 mutating 方法</span><br><span class="line">enum StateSwitch &#123;</span><br><span class="line">    case off,low,high</span><br><span class="line">    mutating func next() &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .off:</span><br><span class="line">            self = .low</span><br><span class="line">        case .low:</span><br><span class="line">            self = .high</span><br><span class="line">        case .high:</span><br><span class="line">            self = .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var light = StateSwitch.low</span><br><span class="line">light.next()</span><br><span class="line">light.next()</span><br></pre></td></tr></table></figure></div><h2 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h2><ul><li>通过在 <code>func</code> 关键字前用 <code>static</code> 关键字来明确一个类型方法。类同样可以使用 <code>class关键字</code> 来允许子类重写父类对类型方法的实现</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 实例方法 self</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    func pringInfo() &#123;</span><br><span class="line">        print(&quot;x is \(x),y is \(y)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 类方法</span><br><span class="line">    static func printTypeInfo() &#123;</span><br><span class="line">        print(&quot;A Point&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p = Point(x: 2,y: 2)</span><br><span class="line">p.pringInfo()</span><br><span class="line">// 类方法用类型调用</span><br><span class="line">Point.printTypeInfo()</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">x is 2.0,y is 2.0</span><br><span class="line">A Point</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为类、结构体、枚举添加-属性&quot;&gt;&lt;a href=&quot;#为类、结构体、枚举添加-属性&quot; class=&quot;headerlink&quot; title=&quot;为类、结构体、枚举添加 属性&quot;&gt;&lt;/a&gt;为类、结构体、枚举添加 属性&lt;/h1&gt;&lt;h2 id=&quot;存储属性&quot;&gt;&lt;a href=&quot;#存</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习37：扩展</title>
    <link href="https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A046%EF%BC%9A%E6%89%A9%E5%B1%95/"/>
    <id>https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A046%EF%BC%9A%E6%89%A9%E5%B1%95/</id>
    <published>2023-03-05T09:05:03.000Z</published>
    <updated>2023-03-09T15:54:51.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇将详细总结介绍Swift扩展的用法：</p><ul><li><p>扩展就是<code> 为现有的类、结构体、枚举类型或者协议类型添加新功能</code></p></li><li><p>这也包括了为无访问权限的源代码扩展类型的能力(即逆向建模)</p></li><li><p>扩展和 <code>Objective-C</code> 中的 <code>category</code> 类似，与 <code>Objective-C</code> 不同的是扩展 <code>没有名字</code></p></li></ul><h1 id="extension-的能力"><a href="#extension-的能力" class="headerlink" title="extension 的能力"></a>extension 的能力</h1><ul><li>添加 <code>计算型实例属性</code> 和 <code>计算型类型属性</code>。</li><li>定义 <code>实例方法和类型方法</code></li><li>添加 <code>新初始化器</code></li><li>定义下标 </li><li>使现有的类型尊徐某协议</li><li>扩展可以向一个类型添加新的方法，但是不能重写已有的方法</li></ul><blockquote><p>使用注意：</p></blockquote><ul><li>不可以添加 <code>存储属性</code>，也不可以为已有属性添加属性观察器</li><li>扩展中不能为类添加新的 <code>指定构造器</code>，因为 <code>指定构造器和析构器</code> 必须由原始的类来实现</li></ul><h1 id="添加计算属性"><a href="#添加计算属性" class="headerlink" title="添加计算属性"></a>添加计算属性</h1><ul><li>扩展 <code>不可以添加存储型属性，也不可以为已有属性添加属性观察器</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extension Double&#123;</span><br><span class="line">    // 注意：扩展不能扩展存储型属性</span><br><span class="line">    // var km: Double = 0.0 //报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16783717667666.jpg"                                     ></p><ul><li>扩展可以添加新的计算型属性</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extension Double &#123;</span><br><span class="line">    // 注意：扩展不能添加存储属性</span><br><span class="line">    //    var km: Double = 0.0</span><br><span class="line">    // 计算属性</span><br><span class="line">    var km: Double &#123; return self * 1_000.0&#125;</span><br><span class="line">    var m: Double &#123; return self &#125;</span><br><span class="line">    var cm: Double &#123; return self / 100.0 &#125;</span><br><span class="line">    var mm: Double &#123; return self / 1_000.0 &#125;</span><br><span class="line">    var ft: Double &#123; return self / 3.28084 &#125;</span><br><span class="line">&#125;</span><br><span class="line">let oneInch = 25.4</span><br><span class="line">print(&quot;one inch is \(oneInch) meters&quot;)</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">one inch is 25.4 meters</span><br></pre></td></tr></table></figure></div><h1 id="添加初始化器"><a href="#添加初始化器" class="headerlink" title="添加初始化器"></a>添加初始化器</h1><ul><li><p>扩展能为类 <code>添加新的初始化器</code></p></li><li><p>扩展能为类 <code>添加新的便捷初始化器</code></p></li><li><p>不能为类添加 <code>指定初始化器或反初始化器</code>，指定初始化器或反初始化器 <code>必须由原来的类实现提供</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension Rect&#123;</span><br><span class="line">    // 便捷初始化器</span><br><span class="line">    init(center:Point, size:Size) &#123;</span><br><span class="line">        let origin_x = center.x - size.width/2</span><br><span class="line">        let origin_y = center.y - size.height/2</span><br><span class="line">        // 便捷初始化器必须调用指定初始化器</span><br><span class="line">        self.init(origin:Point(x: origin_x, y: origin_y),size:size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let rect3 = Rect(center: Point(x:200, y:200), size: Size(width: 100, height: 100))</span><br></pre></td></tr></table></figure></div><h1 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h1><ul><li>扩展可以为已有的类型添加新的 <code>实例方法和类方法</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 添加方法</span><br><span class="line">extension Int &#123;</span><br><span class="line">    func repetions(task: () -&gt; Void) &#123;</span><br><span class="line">        for _ in 0..&lt;self &#123;</span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3.repetions &#123;</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="添加异变方法"><a href="#添加异变方法" class="headerlink" title="添加异变方法"></a>添加异变方法</h1><ul><li>通过 <code>mutationg</code> 关键字，可以 <code>修改实例方法本身</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension Int &#123;</span><br><span class="line">    mutating func square() &#123;</span><br><span class="line">        self = self * self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var someInt = 3</span><br><span class="line">someInt.square()</span><br><span class="line">print(someInt)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">9</span><br></pre></td></tr></table></figure></div><h1 id="添加下标"><a href="#添加下标" class="headerlink" title="添加下标"></a>添加下标</h1><ul><li>扩展可以为已有类型添加新下标。</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">extension Int &#123;</span><br><span class="line">    subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        var base = 1</span><br><span class="line">        for i in 0..&lt;index &#123;</span><br><span class="line">            base *= 10</span><br><span class="line">        &#125;</span><br><span class="line">        return (self / base) % 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(746381295[0])</span><br><span class="line">print(746381295[1])</span><br><span class="line">print(746381295[2])</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line">5</span><br><span class="line">9</span><br><span class="line">2</span><br></pre></td></tr></table></figure></div><h1 id="添加内嵌类型"><a href="#添加内嵌类型" class="headerlink" title="添加内嵌类型"></a>添加内嵌类型</h1><ul><li>扩展可以为已有的 <code>类、结构体和枚举添加新的嵌套类型</code>。</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 添加内嵌类型</span><br><span class="line">extension Int &#123;</span><br><span class="line">    enum Kind &#123;</span><br><span class="line">        // 负数 0 正数</span><br><span class="line">        case neg,zero,pos</span><br><span class="line">    &#125;</span><br><span class="line">    var kind: Kind &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            return .zero</span><br><span class="line">        case let x where x &gt; 0:</span><br><span class="line">            return .pos</span><br><span class="line">        default:</span><br><span class="line">            return .neg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(8.kind)</span><br><span class="line">print(0.kind)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">pos</span><br><span class="line">zero</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇将详细总结介绍Swift扩展的用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;扩展就是&lt;code&gt; 为现有的类、结构体、枚举类型或者协议类型添加</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习37：协议</title>
    <link href="https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A045%EF%BC%9A%E5%8D%8F%E8%AE%AE/"/>
    <id>https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A045%EF%BC%9A%E5%8D%8F%E8%AE%AE/</id>
    <published>2023-03-05T09:04:54.000Z</published>
    <updated>2023-03-09T15:53:11.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协议的语法"><a href="#协议的语法" class="headerlink" title="协议的语法"></a>协议的语法</h1><ul><li><p>自定义类 声明时，协议名放在类名的冒号 <code>:</code> 之后，多个协议用逗号分开</p></li><li><p>若是一个类拥有父类，应该将父类名放在遵循的协议名之前，以逗号分隔。</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 单个协议</span><br><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    // dosomething</span><br><span class="line">&#125;</span><br><span class="line">// 多个协议</span><br><span class="line">protocol SomeStruct: FirstProtocol,AnotherProtocol &#123;</span><br><span class="line">    // structure definition</span><br><span class="line">&#125;</span><br><span class="line">// 继承父类</span><br><span class="line">class SomeClass: SomeSuperClass,FirstProtocol,AnotherProtocol &#123;</span><br><span class="line">    // class definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h1><p>协议可以要求遵循协议的类型提供特定名称和类型的 <code>实例属性或类型属性</code>。协议不具体说明属性是存储属性还是计算属性，它只具体要求属性有特定的名称和类型。</p><ul><li><p>协议同时要求一个属性必须明确是 <code>可读的/可读可写</code> 的，类型声明后加上 <code>&#123; set get &#125;</code> 来表示属性是 <code>可读可写</code> 的；</p></li><li><p>协议要求属性为 <code>可读和可写的</code>，用 <code>var</code> 修饰</p></li><li><p>协议要求属性为 <code>可读的</code>，用 <code>var</code> 或 <code>let</code> 修饰</p></li></ul><p>示例：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    var mustBeSettable: Int &#123; get set &#125;          // 可读可写</span><br><span class="line">    var doesNotNeedToBeSettable: Int &#123; get &#125;     // 可读</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>协议定义 <code>类</code> 属性时，前面添加 <code>static</code> 关键字。当类的实现使用 <code>class</code> 或 <code>static</code> 关键字声明属性时，这个规则仍适用</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol AnotherProtocol &#123;</span><br><span class="line">    static var someTypeProperty: Int &#123; get set &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h1><ul><li><p>协议可以定义 实例方法和类方法，书写方式与正常的 实例方法和类方法相同</p></li><li><p>协议定义 <code>类方法</code> 时，添加 <code>static</code> 关键字，当类的实现使用 <code>class</code> 或 <code>static</code> 关键字声明属性时，这个规则仍适用</p></li></ul><h1 id="定义-mutating-异变方法"><a href="#定义-mutating-异变方法" class="headerlink" title="定义 mutating 异变方法"></a>定义 mutating 异变方法</h1><ul><li>协议也可以定义 <code>异变</code> 方法，需要添加 <code>mutating</code> 关键字，这允许结构体和枚举能采用响应的协议并猫族方法要求</li></ul><h1 id="定义初始化器"><a href="#定义初始化器" class="headerlink" title="定义初始化器"></a>定义初始化器</h1><ul><li>协议允许定义 <code>指定的初始化器</code>，和一般初始化器一样，只是不用写大括号也就是初始化器的实体</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    init(someParameter: Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="定义初始化器要求类的实现"><a href="#定义初始化器要求类的实现" class="headerlink" title="定义初始化器要求类的实现"></a>定义初始化器要求类的实现</h1><ul><li><p>你可以通过实现指定的初始化器或便捷初始化器来使遵循该协议的类满足协议的初始化器要求。</p></li><li><p>在这两种情况下，你必须使用 required 关键字修饰初始化器的实现</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass: SomeProtocol &#123;</span><br><span class="line">    </span><br><span class="line">    required init(someParameter: Int) &#123;</span><br><span class="line">        // initializer ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>如果一个子类重写了父类指定的初始化器，并且遵循协议实现了初始化器要求，那么就要为这个初始化器的实现添加 <code>required</code> 和 <code>override</code> 两个修饰符</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    init()</span><br><span class="line">&#125;</span><br><span class="line">class SomeSuperClass &#123;</span><br><span class="line">    init() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SomeClass: SomeSuperClass,SomeProtocol &#123;</span><br><span class="line">    </span><br><span class="line">    required override init() &#123;</span><br><span class="line">        // initializer ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="将协议作为类型"><a href="#将协议作为类型" class="headerlink" title="将协议作为类型"></a>将协议作为类型</h1><ul><li>在函数、方法或者初始化器里作为形式参数类型或返回类型</li><li>作为常量、变量或者属性的类型</li><li>作为数组、字典或者其他存储器的元素的类型</li></ul><h1 id="协议继承"><a href="#协议继承" class="headerlink" title="协议继承"></a>协议继承</h1><ul><li>协议可以继承一个或多个其他协议并且可以在它继承的基础上添加更多要求。</li><li>协议继承的语法和类继承的语法相似，只不过可以选择列出多个继承的协议，使用逗号分割</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol InherProtocol: SomProtocol,AnotherProtocol &#123;</span><br><span class="line">    // structure definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="类专属的协议"><a href="#类专属的协议" class="headerlink" title="类专属的协议"></a>类专属的协议</h1><ul><li>通过添加 <code>AnyObject</code> 关键字到协议的继承列表，你就可以 <code>限制协议只能被类类型采用</code>（并且不是结构体或枚举）</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeClassOnlyProtocol: AnyObject,SomeProtocol &#123;</span><br><span class="line">    // structure definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="协议组合"><a href="#协议组合" class="headerlink" title="协议组合"></a>协议组合</h1><ul><li><p>可以使用协议组合来复合多个协议到一个要求里</p></li><li><p>协议组合使用 <code>SomeProtocol &amp; AnotherProtocol</code> 的形式。</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 协议组合</span><br><span class="line">protocol Named &#123;</span><br><span class="line">    var name: String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line">protocol Aged &#123;</span><br><span class="line">    var age: Int &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct Person: Named,Aged &#123;</span><br><span class="line">    // 如果这个地方不定义属性会报错</span><br><span class="line">    // name属性是可读可写的，满足协议可读的要求</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = Person(name: &quot;ZJ&quot;, age: 30)</span><br><span class="line"></span><br><span class="line">// 满足了两个协议的要求，才能传递 参数</span><br><span class="line">func wish(to: Named &amp; Aged) &#123;</span><br><span class="line">    print(&quot;name \(to.name) age \(to.age)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wish(to: p)</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">name ZJ age 30</span><br></pre></td></tr></table></figure></div><h1 id="可选协议要求"><a href="#可选协议要求" class="headerlink" title="可选协议要求"></a>可选协议要求</h1><ul><li><p><code>Objective-C</code> 协议可选使用 <code>optional</code> 修饰符。Swift 中也是允许协议可选的，使用 <code>@objc</code> 标志标记</p></li><li><p>@objc 协议只能被继承自 <code>Objective-C</code> 类或其他 <code>@objc</code> 类采用，不能被结构体或枚举采纳</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;协议的语法&quot;&gt;&lt;a href=&quot;#协议的语法&quot; class=&quot;headerlink&quot; title=&quot;协议的语法&quot;&gt;&lt;/a&gt;协议的语法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;自定义类 声明时，协议名放在类名的冒号 &lt;code&gt;:&lt;/code&gt; 之后，多个协议用逗号分开&lt;/</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习37：类</title>
    <link href="https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A041%EF%BC%9A%E7%B1%BB/"/>
    <id>https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A041%EF%BC%9A%E7%B1%BB/</id>
    <published>2023-03-05T09:04:46.000Z</published>
    <updated>2023-03-09T13:38:38.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ul><li><p><code>swift</code> 也是一种 <code>面向对象</code> 的编程语言。</p></li><li><p>swift中 <code>类</code> 可以定义 <code>属性(常量、变量)和方法</code></p></li></ul><h1 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h1><ul><li>存储属性：存储实例的常量和变量</li><li>计算属性：通过某种方式计算出来的属性</li><li>类属性：与整个自身相关的属性</li></ul><h1 id="定义-swift-类"><a href="#定义-swift-类" class="headerlink" title="定义 swift 类"></a>定义 swift 类</h1><p>我们使用 <code>class</code> 关键字在 <code>swift</code> 中创建一个类。例如：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名 : SuperClass&#123;</span><br><span class="line">    // 定义属性和方法等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>注：<br>定义的类，可以没有父类<br>通常情况下，定义类时，继承自 <code>_SwiftObject</code></p></blockquote><h1 id="类作用"><a href="#类作用" class="headerlink" title="类作用"></a>类作用</h1><ul><li>定义 <code>属性</code> 用于存储值</li><li>定义 <code>方法</code> 用于提供功能</li><li>定义 <code>下标</code> 用于访问值</li><li>定义 <code>构造器</code> 用于生成初始化值</li><li>通过 <code>扩展</code> 以增加默认实现的功能</li><li>符合 <code>协议</code> 以对某类提供标准功能</li></ul><p>与结构体相对，类还有如下功能：</p><ul><li><code>继承</code> 允许一个类继承另一个类的特征</li><li>类型转换允许在运行时检查和解释一个类实例的类型</li><li>解构器允许一个类实例释放任何其所被分配的资源</li><li>引用计数允许对一个类的多次引用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;swift&lt;/code&gt; 也是一种 &lt;code&gt;面向对象&lt;/code&gt; 的编程语言。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习37：结构体</title>
    <link href="https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A043%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A043%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2023-03-05T09:04:39.000Z</published>
    <updated>2023-03-09T07:25:12.561Z</updated>
    
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习38：枚举</title>
    <link href="https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A038%EF%BC%9A%E6%9E%9A%E4%B8%BE/"/>
    <id>https://www.bboyzj.cn/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A038%EF%BC%9A%E6%9E%9A%E4%B8%BE/</id>
    <published>2023-03-05T09:04:28.000Z</published>
    <updated>2023-03-09T07:24:53.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="增强的枚举"><a href="#增强的枚举" class="headerlink" title="增强的枚举"></a>增强的枚举</h1><h2 id="枚举的语法"><a href="#枚举的语法" class="headerlink" title="枚举的语法"></a>枚举的语法</h2><ul><li><p>用 <code>enum</code> 关键字来定义一个枚举，然后将其所有的定义内容放在一个大括号 <code>&#123;&#125;</code> 中</p></li><li><p>多个成员值可以出现在同一行中，用逗号隔开</p></li><li><p>每个枚举都定义了一个全新的类型。正如swift中其它类型那样，它的名称（例如： ComP）需要首字母大写。给枚举类型起一个单数的而不是复数的名字，从而使得他们能够顾名思义</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum ComP &#123;</span><br><span class="line">    case east</span><br><span class="line">    case south</span><br><span class="line">    case west</span><br><span class="line">    case north</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">enum ComP2 &#123;</span><br><span class="line">    case ease, south, west, north</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="使用-Switch-语句来匹配枚举值"><a href="#使用-Switch-语句来匹配枚举值" class="headerlink" title="使用 Switch 语句来匹配枚举值"></a>使用 Switch 语句来匹配枚举值</h2><ul><li>你可以用 <code>switch</code> 语句来匹配每一个单独的枚举值</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let directionToHead = ComP.south</span><br><span class="line">switch directionToHead &#123;</span><br><span class="line">case .east:</span><br><span class="line">    print(&quot;east&quot;)</span><br><span class="line">case .south:</span><br><span class="line">    print(&quot;south&quot;)</span><br><span class="line">case .west:</span><br><span class="line">    print(&quot;west&quot;)</span><br><span class="line">case .north:</span><br><span class="line">    print(&quot;north&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">south</span><br></pre></td></tr></table></figure></div><h2 id="遍历枚举的-case"><a href="#遍历枚举的-case" class="headerlink" title="遍历枚举的 case"></a>遍历枚举的 case</h2><ul><li>枚举也可以被遍历，需要遵守 <code>CaseIterable</code> 协议来 <code>允许枚举被遍历</code>，写法：在枚举名后面写 <code>:CaseIterable</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 遍历枚举</span><br><span class="line">enum ComP : CaseIterable&#123;</span><br><span class="line">    case east</span><br><span class="line">    case south</span><br><span class="line">    case west</span><br><span class="line">    case north</span><br><span class="line">&#125;</span><br><span class="line">for direction in ComP.allCases &#123;</span><br><span class="line">    print(direction)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">east</span><br><span class="line">south</span><br><span class="line">west</span><br><span class="line">north</span><br></pre></td></tr></table></figure></div><p>或者</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 遍历枚举</span><br><span class="line">enum ComP2 : CaseIterable&#123;</span><br><span class="line">    case east, south, west, north</span><br><span class="line">&#125;</span><br><span class="line">print(ComP2.allCases)</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">[__lldb_expr_75.ComP2.east, __lldb_expr_75.ComP2.south, __lldb_expr_75.ComP2.west, __lldb_expr_75.ComP2.north]</span><br></pre></td></tr></table></figure></div><h2 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h2><ul><li>可以定义swift枚举来存储任意给定类型的关联值，如果需要的话不同枚举成员关联值的类型可以不同</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 关联值</span><br><span class="line">enum Barcde &#123;</span><br><span class="line">    case upc(Int,Int,Int,Int) // 元组</span><br><span class="line">    case qrCode(String) // 元组</span><br><span class="line">&#125;</span><br><span class="line">var productBarcode = Barcde.upc(5,111,33,245)</span><br><span class="line">print(productBarcode)</span><br><span class="line">productBarcode = .qrCode(&quot;aaaaaddddd&quot;)</span><br><span class="line">print(productBarcode)</span><br><span class="line"></span><br><span class="line">==============</span><br><span class="line">upc(5, 111, 33, 245)</span><br><span class="line">qrCode(&quot;aaaaaddddd&quot;)</span><br></pre></td></tr></table></figure></div><h2 id="关联值绑定"><a href="#关联值绑定" class="headerlink" title="关联值绑定"></a>关联值绑定</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 关联值绑定</span><br><span class="line">switch productBarcode &#123;</span><br><span class="line">case .upc(let a,let b,let c,let d):</span><br><span class="line">    print(&quot;UPC: \(a) \(b) \(c) \(d)&quot;)</span><br><span class="line">case .qrCode(let codeString):</span><br><span class="line">    print(&quot;QR Code: \(codeString)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">QR Code: aaaaaddddd</span><br></pre></td></tr></table></figure></div><h2 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h2><ul><li>枚举成员可以用相同类型的默认值预先填充（称为<code>原始值</code>）</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 原始值</span><br><span class="line">enum carS: Character &#123;</span><br><span class="line">    case tab = &quot;\t&quot;</span><br><span class="line">    case lineFeed = &quot;\n&quot;</span><br><span class="line">    case carrReturn = &quot;\r&quot;</span><br><span class="line">&#125;</span><br><span class="line">let car = carS.tab</span><br><span class="line">print(car.rawValue)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303051804980.png"                                     ></p><h2 id="预设原始值"><a href="#预设原始值" class="headerlink" title="预设原始值"></a>预设原始值</h2><ul><li>当你操作存储整数或字符串原始值枚举的时候，你不必显示地给每一个成员都分配一个原始值。当你没有分配时，swift将自动为你分配值</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 预设原始值</span><br><span class="line">enum ComP: Int &#123;</span><br><span class="line">    case ease = 4,south,west,north</span><br><span class="line">&#125;</span><br><span class="line">print(ComP.south.rawValue)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">5</span><br></pre></td></tr></table></figure></div><h2 id="从原始值初始化"><a href="#从原始值初始化" class="headerlink" title="从原始值初始化"></a>从原始值初始化</h2><ul><li>当你用原始值定义了一个枚举，那么枚举就会自动收到一个可以接受原始值类型的初始化器（叫做 <code>rawValue</code> 的形式参数）然后返回一个枚举成员或者 <code>nil</code>。你可以用这个初始化器来尝试创建一个枚举的 新实例</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 初始化器</span><br><span class="line">enum ComP: Int &#123;</span><br><span class="line">    case ease = 4,south,west,north</span><br><span class="line">&#125;</span><br><span class="line">let direction = ComP(rawValue: 6)</span><br><span class="line">print(direction)</span><br><span class="line">let direction2 = ComP(rawValue: 8)</span><br><span class="line">print(direction2)</span><br><span class="line">========</span><br><span class="line">Optional(__lldb_expr_82.ComP.west)</span><br><span class="line">nil</span><br></pre></td></tr></table></figure></div><h2 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h2><ul><li><p><code>递归枚举是拥有另一个枚举作为枚举成员关联值的枚举</code>。当编译器操作递归枚举时必须插入 简介寻址层。你可以在声明枚举成员之前使用 indrect 关键字来明确它是递归的</p></li><li><p>如果说表达式 (5+4)*2 在乘法右侧有一个数但有其他表达式在乘法的左侧</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 递归枚举</span><br><span class="line">indirect enum ArExp &#123;</span><br><span class="line">    case number(Int)</span><br><span class="line">    case add(ArExp,ArExp)</span><br><span class="line">    case mutiply(ArExp,ArExp)</span><br><span class="line">&#125;</span><br><span class="line">let firstExp = ArExp.number(5)</span><br><span class="line">let secondExp = ArExp.number(4)</span><br><span class="line">let addExp = ArExp.add(firstExp,secondExp)</span><br><span class="line">let thirdExp = ArExp.number(2)</span><br><span class="line">let mutipExp = ArExp.mutiply(addExp,thirdExp)</span><br><span class="line">print(mutipExp)</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">mutiply(__lldb_expr_89.ArExp.add(__lldb_expr_89.ArExp.number(5), __lldb_expr_89.ArExp.number(4)), __lldb_expr_89.ArExp.number(2))</span><br></pre></td></tr></table></figure></div><p>我们可以写一个函数来执行这个表达式</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func eval(_ exp: ArExp) -&gt; Int &#123;</span><br><span class="line">    switch exp &#123;</span><br><span class="line">    case .number(let value):</span><br><span class="line">        return value</span><br><span class="line">    case .add(let first,let second):</span><br><span class="line">        return eval(first) + eval(second)</span><br><span class="line">    case .mutiply(let first,let second):</span><br><span class="line">        return eval(first) * eval(second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(eval(mutipExp))</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">18</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;增强的枚举&quot;&gt;&lt;a href=&quot;#增强的枚举&quot; class=&quot;headerlink&quot; title=&quot;增强的枚举&quot;&gt;&lt;/a&gt;增强的枚举&lt;/h1&gt;&lt;h2 id=&quot;枚举的语法&quot;&gt;&lt;a href=&quot;#枚举的语法&quot; class=&quot;headerlink&quot; title=&quot;枚举的</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
</feed>
