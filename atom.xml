<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张建的博客</title>
  <icon>https://www.gravatar.com/avatar/134cc2bfaf649e446f661778f4112fca</icon>
  <subtitle>成功的道路上只有荆棘，没有坦途</subtitle>
  <link href="https://www.bboyzj.cn/atom.xml" rel="self"/>
  
  <link href="https://www.bboyzj.cn/"/>
  <updated>2023-03-02T08:40:40.772Z</updated>
  <id>https://www.bboyzj.cn/</id>
  
  <author>
    <name>小J</name>
    <email>13718004742@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OC学习01：文件导入#include,#import,@class区别</title>
    <link href="https://www.bboyzj.cn/2023/03/02/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5#include,#import,@class%E5%8C%BA%E5%88%AB/"/>
    <id>https://www.bboyzj.cn/2023/03/02/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5#include,#import,@class%E5%8C%BA%E5%88%AB/</id>
    <published>2023-03-02T08:39:08.000Z</published>
    <updated>2023-03-02T08:40:40.772Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Blog-05：Picgo+Gitee图床</title>
    <link href="https://www.bboyzj.cn/2023/03/01/Blog-05%EF%BC%9APicgo-Gitee%E5%9B%BE%E5%BA%8A/"/>
    <id>https://www.bboyzj.cn/2023/03/01/Blog-05%EF%BC%9APicgo-Gitee%E5%9B%BE%E5%BA%8A/</id>
    <published>2023-03-01T11:25:22.000Z</published>
    <updated>2023-03-01T17:50:09.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近发现上传到 GitHub 上的图片大部分不能使用了，然后上网查了一下，应该是 DNS 的问题，网上也有很多解决方案，有兴趣的可以去网上找找，本文主要介绍 <code>Picgo + Gitee</code> 做图床。</p><h1 id="Picgo-介绍"><a href="#Picgo-介绍" class="headerlink" title="Picgo 介绍"></a>Picgo 介绍</h1><p><code>picgo</code> 是一款功能实用、操作简捷的图床工具，图床工具简单来说就是本地图片上传自动转换成链接的一款工具。</p><p>picgo 本体支持如下图床：</p><ul><li>七牛图床 v1.0</li><li>腾讯云 COS v4\v5 版本 v1.1 &amp; v1.5.0</li><li>又拍云 v1.2.0</li><li>GitHub v1.5.0</li><li>SM.MS V2 v2.3.0-beta.0</li><li>阿里云 OSS v1.6.0</li><li>Imgur v1.6.0</li></ul><p>Tips: 本体不再增加默认的图床支持。你可以自行开发第三方图床插件。</p><h1 id="特色功能"><a href="#特色功能" class="headerlink" title="特色功能"></a>特色功能</h1><ul><li>支持拖拽图片上传</li><li>支持快捷键上传剪贴板里第一张图片</li><li>Windows 和 macOS 支持右键图片文件通过菜单上传 (v2.1.0+)</li><li>上传图片后自动复制链接到剪贴板</li><li>支持自定义复制到剪贴板的链接格式</li><li>支持修改快捷键，默认快速上传快捷键：command+shift+p（macOS） | control+shift+p（Windows\Linux）</li><li>支持插件系统，已有插件支持 <code>Gitee、青云等第三方图床</code></li></ul><p>Tips:</p><ul><li>请确保你安装了 <code>Node.js</code>， 并且版本 &gt;&#x3D; 8。</li><li>默认上传图床为 <code>SM.MS</code>。<code>picgo</code> 上传之后，会自动将上传成功的 URL复制到你的剪贴板，支持5种复制格式。</li><li>Mini窗口只支持Windows（圆形）和Linux（方形），macOS可以使用顶部栏图标。（因为Windows和Linux的任务栏不支持拖拽事件）</li></ul><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li><code>nodejs</code> 环境</li><li><code>picgo</code> 客户端</li><li><code>picgo</code> 的 <code>Gitee</code> 上传插件</li><li><code>git、Gitee</code> 账号和一个公开仓库</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li><a class="link"   href="https://nodejs.org/zh-cn/download/" >nodejs官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 安装</li></ul><p>点击链接下载安装 nodejs，安装完成后，查看版本</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % node -v</span><br><span class="line">v18.14.2</span><br><span class="line">mac@bogon ~ % npm -v</span><br><span class="line">mac@bogon ~ % npm -v</span><br><span class="line">9.5.0</span><br></pre></td></tr></table></figure></div><ul><li>安装 <code>picgo</code> 客户端</li></ul><p><a class="link"   href="https://github.com/Molunerfinn/picgo/releases" >picgo安装链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>如果电脑是 <code>Intel</code> 就选 <code>x64</code>，如果电脑是 <code>M1</code> 就选 <code>arm64</code></p><ul><li>安装 git</li></ul><p>Mac 默认是已经安装好了 git</p><h1 id="注册-x2F-登录-Gitee-账号"><a href="#注册-x2F-登录-Gitee-账号" class="headerlink" title="注册&#x2F;登录 Gitee 账号"></a>注册&#x2F;登录 Gitee 账号</h1><ul><li><p><a class="link"   href="https://gitee.com/" >Gitee <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 首页按要求自行注册&#x2F;登录即可</p></li><li><p>新建一个 <code>Gitee</code> 仓库</p></li></ul><p>仓库名：随意，如 Picgo<br>私有<br>创建</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012136074.png"                                     ></p><ul><li>将仓库 <code>开源</code></li></ul><p>由于创建仓库的时候只能 <code>私有</code>，所以此步配置 <code>开源</code> 操作如下：</p><p>进入仓库 -&gt; 管理 -&gt; 基本信息 -&gt; 开源（空仓库不允许） -&gt; 保存</p><ul><li>生成 Token</li></ul><p><code>Token</code> 用于 <code>picgo</code> 操作 Gitee repository：</p><p>点击头像 -&gt; 设置 -&gt; 私人令牌 -&gt; 生成新令牌 -&gt; 提交</p><p>复制你生成的令牌，只显示一次，再次刷新则看不见了，因此你要保存好</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16776726761906.jpg"                                     ></p><h1 id="配置-picgo"><a href="#配置-picgo" class="headerlink" title="配置 picgo"></a>配置 picgo</h1><ul><li>启动 picgo -&gt; 插件设置 -&gt; 搜索 Gitee -&gt; 点击插件图标 <code>安装</code> 即可，本文使用 <code>gitee 2.0.5</code> 插件来进行演示</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012133116.jpg"                                     ></p><p>Tips： 插件装完后，重启生效</p><h1 id="配置-Gitee-插件"><a href="#配置-Gitee-插件" class="headerlink" title="配置 Gitee 插件"></a>配置 Gitee 插件</h1><p>进入 <code>图床设置</code> -&gt; gitee， 依次填入相关配置如下所示，填写如下：</p><ul><li><p>repo： 用户名&#x2F;仓库名（必填）， <code>bboy-zhang-jian/picgo</code></p></li><li><p>path: 上传路径，仓库里的图片保存路径（非必填）</p></li><li><p>token: 私人令牌（必填），刚才保存的 <code>token</code></p></li><li><p>message: 提交消息（非必填）</p></li><li><p>path: 上传路径，仓库里的图片保存路径（非必填）</p></li><li><p>customPath: 定制路径（非必填）</p></li><li><p>customUrl: 图片定制URL（非必填）</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012137612.png"                                     ></p><h1 id="将仓库开源"><a href="#将仓库开源" class="headerlink" title="将仓库开源"></a>将仓库开源</h1><p>头像 -&gt; 仓库 -&gt; 管理 -&gt; 公开 -&gt; 仓库公开须知全部 <code>勾选</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012138939.png"                                     ></p><h1 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h1><ul><li>将图片拖动到 <code>上传区</code> 里</li><li>快捷键 <code>Ctrl + shift + p</code></li></ul><h1 id="出现-Error-Cannot-find-module-‘node-sass’"><a href="#出现-Error-Cannot-find-module-‘node-sass’" class="headerlink" title="出现 Error: Cannot find module ‘node-sass’"></a>出现 Error: Cannot find module ‘node-sass’</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % npm install node -sass -save</span><br></pre></td></tr></table></figure></div><p>不用管了，版本不一致导致的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近发现上传到 GitHub 上的图片大部分不能使用了，然后上网查了一下，应该是 DNS 的问题，网上也有很多解决方案，有兴趣的可以去网上找</summary>
      
    
    
    
    <category term="Blog" scheme="https://www.bboyzj.cn/categories/Blog/"/>
    
    
    <category term="博客搭建" scheme="https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>OC学习01：事件传递链和响应链</title>
    <link href="https://www.bboyzj.cn/2023/03/01/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/"/>
    <id>https://www.bboyzj.cn/2023/03/01/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/</id>
    <published>2023-03-01T09:30:34.000Z</published>
    <updated>2023-03-01T10:40:20.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <code>iOS</code> 中只有继承 <code>UIResponder</code> 的 <code>对象</code> 才能够接收并处理事件，<code>UIResponder</code> 是所有响应对象的 <code>基类</code>。继承关系如下：</p><ul><li>UIApplication -&gt; UIResponder -&gt; NSObject</li><li>UIViewController -&gt; UIResponder -&gt; NSObject</li><li>UIWindow -&gt; UIViww -&gt; UIResponder -&gt; NSObject</li><li>UIButton -&gt; UIControl -&gt; UIView -&gt; UIResponder -&gt; NSObject</li><li>UIView -&gt; UIResponder -&gt; NSObject</li></ul><h1 id="事件链"><a href="#事件链" class="headerlink" title="事件链"></a>事件链</h1><ul><li><p><code>响应链</code>：由离用户最近的view向系统传递。<br>顺序： superViews –&gt; RootViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate</p></li><li><p><code>传递链</code>：由系统向离用户最近的view传递。<br>顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; RootViewController -&gt; subViews</p></li></ul><h1 id="传递链"><a href="#传递链" class="headerlink" title="传递链"></a>传递链</h1><ul><li>事件传递的两个核心方法</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 返回哪个视图进行事件响应</span><br><span class="line">- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;  </span><br><span class="line">// 判断某一个点击的位置是否在视图范围内</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;</span><br></pre></td></tr></table></figure></div><ul><li><p>其中 UIView 不接受事件处理的情况有</p></li><li><p>hidden &#x3D; YES 视图被隐藏</p></li><li><p>userInteractionEnabled &#x3D; NO 不接受响应事件</p></li><li><p>alpha &lt;&#x3D; 0.01,透明视图不接收响应事件</p></li><li><p>子视图超出父视图范围</p></li><li><p>需响应视图被其他视图盖住</p></li><li><p>是否重写了其父视图以及自身的hitTest方法</p></li><li><p>是否重写了其父视图以及自身的pointInside方法</p></li><li><p>流程描述</p><ul><li>当iOS程序发生触摸事件后，系统会利用 <code>Runloop</code> 将事件加入到 <code>UIApplication</code> 的任务队列中</li><li><code>UIApplication</code> 分发触摸事件到 <code>UIWindow</code></li><li>然后 <code>UIWindow</code> 依次向下分发给 <code>UIView</code></li><li><code>UIView</code> 调用 <code>hitTest:withEvent:</code> 方法返回一个最终响应的视图</li><li>在 <code>hitTest:withEvent:</code> 方法中就会去调用 <code>pointInside: withEvent:</code> 去判断当前点击的 <code>point</code> 是否在 <code>UIView</code> 范围内，如果是的话，就会去 <code>逆序遍历</code> 它的子视图来查找最终响应的 <code>子视图</code></li><li>遍历的方式是使用 <code>倒序</code> 的方式来遍历子视图，也就是说最后添加的子视图会最先遍历，在每一个视图中都会去调用它的 <code>hitTest:withEvent:</code> 方法，可以理解为是一个 <code>递归调用</code></li><li>最终会返回一个响应视图，如果返回视图有值，那么这个视图就作为最终响应视图，结束整个事件传递；如果没有值，那么就会将UIView作为响应者</li></ul></li></ul><h1 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h1><p>响应者链的事件传递过程</p><ul><li>如果 <code>view</code> 的控制器存在，就传递给控制器处理；如果控制器不存在，则传递给它的 <code>父视图</code></li><li>在视图层次结构的最顶层，如果也不能处理收到的事件，则将事件传递给 <code>UIWindow</code> 对象进行处理</li><li>如果 <code>UIWindow</code> 对象也不处理，则将事件传递给 <code>UIApplication</code> 对象</li><li>如果 <code>UIApplication</code> 也不能处理该事件，则将该事件丢弃</li></ul><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ul><li>实现一个按钮的点击范围扩大效果</li></ul><p>思路：自定义一个按钮，重写 <code>poinstInSide</code> 方法，增大内边距，返回一个新的bounds</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJBtn.h&quot;</span><br><span class="line">@implementation ZJBtn</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 当前btn大小</span><br><span class="line">    CGRect btnBounds = self.bounds;</span><br><span class="line">    // 扩大按钮的点击范围，增大内边距</span><br><span class="line">    btnBounds = CGRectInset(btnBounds, -50, -50);</span><br><span class="line">    // 若点击的点在新的bounds里，返回YES</span><br><span class="line">    return CGRectContainsPoint(btnBounds, point);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>子视图超过父视图部分仍然能响应</li></ul><p>思路：正常情况下子视图超出部分是不能响应事件的，需重写 <code>hitTest:withEvent</code> 方法，指定 <code>子视图</code> 可点击</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;VA.h&quot;</span><br><span class="line"></span><br><span class="line">@interface VA ()</span><br><span class="line">@property (nonatomic,strong)UIButton * btn;</span><br><span class="line">@end</span><br><span class="line">@implementation VA</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame&#123;</span><br><span class="line">    self = [super initWithFrame:frame];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        [self addSubview:self.btn];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)clickBtn&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIButton *)btn&#123;</span><br><span class="line">    if (!_btn) &#123;</span><br><span class="line">        _btn = [[UIButton alloc] initWithFrame:CGRectMake(-50, 20, self.frame.size.width + 100, 100)];</span><br><span class="line">        _btn.backgroundColor = [UIColor blueColor];</span><br><span class="line">        [_btn addTarget:self action:@selector(clickBtn) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    &#125;</span><br><span class="line">    return _btn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 子视图超过父视图部分，需要点击超出范围的部分也有相应</span><br><span class="line"> */</span><br><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 判断btn能否接收事件</span><br><span class="line">    if (self.btn.userInteractionEnabled == NO || self.btn.hidden == YES || self.btn.alpha &lt;= 0.01) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 把当前点转换成btn坐标系上的点</span><br><span class="line">    CGPoint btnP = [self convertPoint:point toView:self.btn];</span><br><span class="line">    // 当触摸点在btn上时，才让按钮相应事件</span><br><span class="line">    if ([self.btn pointInside:btnP withEvent:event]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,NSStringFromCGPoint(btnP));</span><br><span class="line">        return self.btn;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;父视图相应&quot;);</span><br><span class="line">    return [super hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 &lt;code&gt;iOS&lt;/code&gt; 中只有继承 &lt;code&gt;UIResponder&lt;/code&gt; 的 &lt;code&gt;对象&lt;/code&gt; 才能</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试题：Swift</title>
    <link href="https://www.bboyzj.cn/2023/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASwift/"/>
    <id>https://www.bboyzj.cn/2023/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASwift/</id>
    <published>2023-03-01T08:57:50.000Z</published>
    <updated>2023-03-02T06:41:01.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="swift-和-oc-的区别？"><a href="#swift-和-oc-的区别？" class="headerlink" title="swift 和 oc 的区别？"></a>swift 和 oc 的区别？</h1><ul><li><code>swift</code> 是静态语言，有类型判断。<code>OC</code> 是动态语言。</li><li><code>swift</code> 可以面向 <code>函数、协议、对象</code> 编程；oc以面向 <code>对象</code> 编程为主，可以引入 <code>Reactive Cocoa类库</code> 来进行函数式编程</li><li><code>Swift</code> 是 <code>类型安全</code> 的语言。<code>OC</code> 不是类型安全的语言。</li><li><code>Swift</code> 大部分都是 <code>值类型</code>，少部分是 <code>Class引用类型</code>。OC 有的是 <code>值类型</code>，有的是 <code>指针类型</code>。</li></ul><h1 id="swift类型？Swiift-值类型-和-引用类型的区别？特点？"><a href="#swift类型？Swiift-值类型-和-引用类型的区别？特点？" class="headerlink" title="swift类型？Swiift 值类型 和 引用类型的区别？特点？"></a>swift类型？Swiift 值类型 和 引用类型的区别？特点？</h1><ul><li><p>swift的类型分为 <code>值类型</code> 和 <code>引用类型</code>。</p><ul><li><p>值类型：在swift中定义的很多类型都是值类型：如 <code>struct、enum、Int、Float、Bool、String、Array、Dictionary、String</code> 等都是 <code>值类型</code>。</p></li><li><p>引用类型：只有 <code>class</code> 为引用类型</p></li></ul></li><li><p>区别</p><ul><li><p>值类型：传递和赋值时是一个 <code>副本</code>，使用过程中不会影响 <code>源数据</code></p></li><li><p>引用类型：传递和赋值是 <code>本身（内存地址）</code>，使用过程中会影响源数据</p></li></ul></li></ul><h1 id="常用的关键字"><a href="#常用的关键字" class="headerlink" title="常用的关键字"></a>常用的关键字</h1><ul><li><p>final：</p><ul><li>只能用于 <code>类</code> 中，修饰的 <code>方法、属性</code>，不能被重写</li><li><code>final</code> 修饰的类，不能被继承</li></ul></li><li><p>inout：</p><ul><li><code>将值类型 转为 引用类型</code></li></ul></li><li><p>mutating：</p><ul><li>涉及到修改自身内存用</li></ul></li><li><p>#available</p><ul><li>用来判断平台和操作系统</li></ul></li><li><p>@available</p><ul><li>用于修饰 方法、属性、协议、扩展，用来表达它的可用性</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;swift-和-oc-的区别？&quot;&gt;&lt;a href=&quot;#swift-和-oc-的区别？&quot; class=&quot;headerlink&quot; title=&quot;swift 和 oc 的区别？&quot;&gt;&lt;/a&gt;swift 和 oc 的区别？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;swift&lt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-面试题" scheme="https://www.bboyzj.cn/tags/Swift-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试题：OC</title>
    <link href="https://www.bboyzj.cn/2023/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AOC/"/>
    <id>https://www.bboyzj.cn/2023/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AOC/</id>
    <published>2023-03-01T08:57:33.000Z</published>
    <updated>2023-03-02T06:47:20.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OC算法"><a href="#OC算法" class="headerlink" title="OC算法"></a>OC算法</h1><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><p>1）依次比较相邻两个元素，顺序错误则交换位置；需要两层循环，外层循环控制趟数，内层循环控制比较次数</p><p>2）例子：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;5&quot;,@&quot;4&quot;]];</span><br><span class="line">    // 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">    for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序</span><br><span class="line">        for (int j = 0; j &lt; arr.count - i - 1; j++) &#123;</span><br><span class="line">            // 相邻元素比较，若逆序则交换</span><br><span class="line">            if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123;</span><br><span class="line">                [arr exchangeObjectAtIndex:j withObjectAtIndex:j + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h2><p>1）从第一个元素与其他元素比较找到最小值，重复操作，直到最后一位结束；需要两层循环，外层循环趟数，里层循环比较次数</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithObjects:@&quot;2&quot;,@&quot;1&quot;,@&quot;5&quot;,@&quot;3&quot;, nil];</span><br><span class="line">// 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">    // 里循环获比较换位</span><br><span class="line">    for (int j = i + 1; j &lt; arr.count; j ++) &#123;</span><br><span class="line">        if ([arr[i] intValue] &gt; [arr[j] intValue]) &#123;</span><br><span class="line">            [arr exchangeObjectAtIndex:i withObjectAtIndex:j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;arr:%@&quot;,arr);</span><br></pre></td></tr></table></figure></div><h2 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3. 直接插入排序"></a>3. 直接插入排序</h2><p>1） 始终定义第一个元素为 <code>已排序</code> 的，将剩余元素定义为 <code>未排序</code> 逐个插入到 <code>已排序</code> 的排列中；不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = @[@2,@1,@3,@5,@4].mutableCopy;</span><br><span class="line">// 插入排序的原理：始终定义第一个元素为有序的，将元素逐个插入到有序的排列中</span><br><span class="line">// 其特点是：不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去</span><br><span class="line">for(int i = 0;i &lt; arr.count;i++)&#123;</span><br><span class="line">    // 待排序值</span><br><span class="line">    NSNumber * temp = arr[i];</span><br><span class="line">    // 已排序下标</span><br><span class="line">    int j = i - 1;</span><br><span class="line">    // 待排序与已排序比较，从后向前比较</span><br><span class="line">    while (j &gt;= 0 &amp;&amp; [arr[j] integerValue] &gt; [temp integerValue]) &#123;</span><br><span class="line">        // 如果已排序的 &gt; 待排序的 往后移动一个位置</span><br><span class="line">        [arr replaceObjectAtIndex:(j + 1) withObject:arr[j]];</span><br><span class="line">        j --;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 空出来的位置插入新元素</span><br><span class="line">    [arr replaceObjectAtIndex:(j + 1) withObject:temp];</span><br><span class="line">    NSLog(@&quot;arr:%@&quot;,arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:26:19.242271+0800 插入排序[4184:77845] arr:(</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><p>1）希尔排序相当于 <code>直接插入排序加强版</code>，引入了 <code>增量</code> 的概念；直到增量为 <code>1</code> 时，再进行直接插入排序</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = @[@7,@3,@8,@5,@2,@6,@1,@4].mutableCopy;</span><br><span class="line">// 其实间隔值设值为总数的一半</span><br><span class="line">int gap = arr.count/2;</span><br><span class="line">// 直到间隔小于1时结束</span><br><span class="line">while (gap &gt;= 1) &#123;</span><br><span class="line">    // i 待排元素，以 步距 gap 从后向前扫描</span><br><span class="line">    for(int i = 0;i &lt; arr.count;i++)&#123;</span><br><span class="line">        // 待排元素</span><br><span class="line">        NSNumber * temp = arr[i];</span><br><span class="line">        // 当前位置</span><br><span class="line">        int j = i;</span><br><span class="line">        // 跳跃式比较</span><br><span class="line">        while (j &gt;= gap &amp;&amp; [arr[j - gap] integerValue] &gt; [temp integerValue] ) &#123;</span><br><span class="line">            [arr replaceObjectAtIndex:j withObject:arr[j - gap]];</span><br><span class="line">            j -= gap;</span><br><span class="line">        &#125;</span><br><span class="line">        // 空出来位置，插入待排序</span><br><span class="line">        [arr replaceObjectAtIndex:j withObject:temp];</span><br><span class="line">    &#125;</span><br><span class="line">    // 改变步长</span><br><span class="line">    gap = gap/2;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;arr:%@&quot;,arr);</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:22:41.910840+0800 插入排序[4124:74568] arr:(</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5,</span><br><span class="line">    6,</span><br><span class="line">    7,</span><br><span class="line">    8</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h2 id="5-斐波那契数列"><a href="#5-斐波那契数列" class="headerlink" title="5. 斐波那契数列"></a>5. 斐波那契数列</h2><p>1）也就是 <code>兔子数列</code>，当前数是前两个数列之和</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    NSInteger num = 10;</span><br><span class="line">    NSInteger total = [self getTotalNum:num];</span><br><span class="line">    NSLog(@&quot;total:%ld&quot;,total);</span><br><span class="line">&#125;</span><br><span class="line">- (NSInteger)getTotalNum:(NSInteger)num&#123;</span><br><span class="line">    if(num == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(num == 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return [self getTotalNum:num-2] + [self getTotalNum:num-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:28:32.672554+0800 斐波那契数列[4285:80606] total:89</span><br></pre></td></tr></table></figure></div><h2 id="6-二分查找"><a href="#6-二分查找" class="headerlink" title="6. 二分查找"></a>6. 二分查找</h2><p>1）<code>有序的数组</code>，将数组分割成两份，利用查找的值跟中间值进行比较，如果查找的值大于中间值，就在数组的右边进行查找；如果查找的值小于中间值，就在数组的左边进行查找。如此循环的执行下去，最终找到符合的值。</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NSArray * arr = @[@(1),@(3),@(5),@(6),@(8),@(10)];</span><br><span class="line">int key = [@(5) intValue];</span><br><span class="line">int min = 0;</span><br><span class="line">int max = arr.count - 1;</span><br><span class="line">int mid;</span><br><span class="line">while (min &lt;= max) &#123;</span><br><span class="line">    // 计算中间下标</span><br><span class="line">    mid = (min + max) / 2;</span><br><span class="line">    // 如果目标值 &gt; 中间下标的中间值</span><br><span class="line">    if (key &gt; [arr[mid] intValue]) &#123;</span><br><span class="line">        //最小变为中间下标+1</span><br><span class="line">        min = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果目标值 &lt; 中间下标的中间值</span><br><span class="line">    else if (key &lt; [arr[mid] intValue])&#123;</span><br><span class="line">        //最大变为中间下标-1</span><br><span class="line">        max = max - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 否则，正好</span><br><span class="line">    else &#123;</span><br><span class="line">        NSLog(@&quot;key:%d&quot;,mid);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:33:18.661324+0800 二分查找[4607:86953] key:2</span><br></pre></td></tr></table></figure></div><h2 id="7-递归算法"><a href="#7-递归算法" class="headerlink" title="7. 递归算法"></a>7. 递归算法</h2><p>递归求和1+2+..+n?</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    int sum = [self sum:4];</span><br><span class="line">    NSLog(@&quot;sum:%d&quot;,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)sum:(int)n&#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return [self sum:n-1] + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><a href="http://www.bboyzj.cn/2020/08/09/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8E%A2%E7%B4%A2/">OC数据结构01：链表的探索</a></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p><a href="http://www.bboyzj.cn/2020/08/26/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%A2%E7%B4%A2/">OC数据结构02：二叉树探索</a></p><h1 id="OC常见的面试题"><a href="#OC常见的面试题" class="headerlink" title="OC常见的面试题"></a>OC常见的面试题</h1><h2 id="什么是野指针？"><a href="#什么是野指针？" class="headerlink" title="什么是野指针？"></a>什么是野指针？</h2><p>是一个没有指向 <code>任何内存</code> 的 <code>指针</code>，尝试使用它会导致 <code>应用程序崩溃</code></p><h2 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h2><p>一个 <code>对象</code> 没有被释放，会 <code>内存泄漏</code>，内存泄漏会导致应用程序占用的内存会越来越大，直到应用程序无内存可用时，会导致 <code>应用程序崩溃</code></p><h2 id="iOS-关键词有哪些？各有什么作用？-重点"><a href="#iOS-关键词有哪些？各有什么作用？-重点" class="headerlink" title="iOS 关键词有哪些？各有什么作用？ 重点"></a>iOS 关键词有哪些？各有什么作用？ <strong>重点</strong></h2><ul><li>readwrite</li></ul><p><code>可读可写</code> 特性，同时生成get方法和set方法的声明和实现</p><ul><li>readonly</li></ul><p><code>只读</code> 特性，只会生成get方法的声明和实现，不希望属性在类外改变</p><ul><li>retain</li></ul><p><code>持有</code> 特性，retaincount 会 +1,用于 <code>MRC</code></p><ul><li>nonatomic</li></ul><p><code>非原子</code> 特性</p><ul><li>atomic</li></ul><p><code>原子</code> 特性，默认属性</p><p>atomic不是绝对线程安全的，只是对 <code>setter/getter</code> 方法使用了 <code>自旋锁(spinlock_t)</code>，内部使用 <code>互斥锁(os_unfair_lock)</code>，保证了 <code>读/写</code> 安全。</p><p>atomic并不能保证 <code>整个对象</code> 是线程安全的，需要对 <code>整个对象</code> 进行 <code>加锁</code> 来保证线程安全：</p><pre><code>*  NSLock（互斥锁）*  dispathch_semaphore（信号量）*  @synchronized（互斥递归锁）</code></pre><ul><li>assign</li></ul><p>可以修饰 <code>基本数据类型和对象</code>。</p><p>通常用于修饰 <code>基本数据类型</code>，如Int、CGFloat、Double等，这是因为 <code>基本数据类型放在栈区</code>，栈由编译器自动分配和释放内存，栈先进后出，基本数据类型出栈后，assign修饰的基本数据类型就不存在了，不会出现 <code>野指针</code></p><p>修饰对象，如NSString、实例对象等，引用计数不会增加，但 <code>assign</code> 修饰对象释放后，<code>指针</code> 不会被系统置为nil，会产生 <code>野指针</code> 或 <code>EXC_BAD_ACCESS</code> 错误。</p><ul><li>strong</li></ul><p>强引用，<code>只修饰对象</code>，属性默认修饰符</p><p><code>指向并持有该对象</code>，其修饰的对象引用计数会 <code>+1</code>，引用计数不为 <code>0</code> 则不会被销毁，需要将其置为 <code>nil</code> 可以销毁。否则会出现 <code>内存泄漏</code>。</p><ul><li>weak</li></ul><p>弱引用，<code>只修饰对象</code>。</p><p><code>指向但并不拥有该对象</code>，引用计数不增加。该对象自动在内存中销毁。</p><ul><li>copy</li></ul><p>用于修饰 <code>不可变的对象</code>。</p><p>比如NSString、NSDictionary、NSArray等。</p><h2 id="浅拷贝和深拷贝-重点"><a href="#浅拷贝和深拷贝-重点" class="headerlink" title="浅拷贝和深拷贝 重点"></a>浅拷贝和深拷贝 <strong>重点</strong></h2><ul><li>浅拷贝</li></ul><p>浅拷贝，拷贝了一个新的指针，与原对象指针指向同一块内存，<code>引用计数 + 1</code>；(A,CopyA &#x3D; [A copy]，A 变化，CopyA 的值也变化)</p><ul><li>深拷贝</li></ul><p>深拷贝，拷贝了一个新的对象，指向新的内存，新对象的 <code>引用计数为 1</code>，源对象引用计数不变；(A,MutableA &#x3D; [A mutbleCopy]，A 变化，MutableA 的值不变)。</p><h2 id="NSString-x2F-NSArray-x2F-NSDictionary和NSMutableString-x2F-NSMutableArray-x2F-NSMutableDictionary-进行copy和mutableCopy区别？重点"><a href="#NSString-x2F-NSArray-x2F-NSDictionary和NSMutableString-x2F-NSMutableArray-x2F-NSMutableDictionary-进行copy和mutableCopy区别？重点" class="headerlink" title="NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？重点"></a>NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？<strong>重点</strong></h2><ul><li><p>对于不可变NSString&#x2F;NSArray&#x2F;NSDictionary，copy浅拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝)</p></li><li><p>对于可变NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary，copy深拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝)</p></li></ul><h2 id="自定义对象的copy和mutableCopy？-重点"><a href="#自定义对象的copy和mutableCopy？-重点" class="headerlink" title="自定义对象的copy和mutableCopy？ 重点"></a>自定义对象的copy和mutableCopy？ <strong>重点</strong></h2><ul><li>copy和mutableCopy都是深拷贝(属性：浅拷贝）</li></ul><h1 id="属性用copy还是strong？-重点"><a href="#属性用copy还是strong？-重点" class="headerlink" title="属性用copy还是strong？ 重点"></a>属性用copy还是strong？ <strong>重点</strong></h1><ul><li><p>对于不可变属性，推荐用copy，目的是为了 <code>让本属性不受外界影响</code>，无论给我传入可变还是不可变对象，我本身持有的就是一个不可变的副本，被set时，改变的是这个副本。</p></li><li><p>对于可变属性，推荐用strong，因为copy修饰后，会变成不可变对象，再调用可变对象函数时会 crash</p></li></ul><h2 id="一个APP是如何唤醒另一个APP的？-重点"><a href="#一个APP是如何唤醒另一个APP的？-重点" class="headerlink" title="一个APP是如何唤醒另一个APP的？ 重点"></a>一个APP是如何唤醒另一个APP的？ <strong>重点</strong></h2><p>URL Scheme：iOS有一个特性就是将 <code>自身绑定</code> 到一个自定义的 <code>URL Scheme</code> 上，该 <code>scheme</code> 用于从 <code>浏览器或其他应用中启动本应用</code>。</p><h2 id="单例的写法和作用？-重点"><a href="#单例的写法和作用？-重点" class="headerlink" title="单例的写法和作用？ 重点"></a>单例的写法和作用？ <strong>重点</strong></h2><p>单例模式的作用：可以保证程序运行过程中，一个类只返回一个实例，供外界访问；static保证类只分配一次内存；dispatch_once方法保证调用一次，并自动加锁，线程安全</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static id _instance = nil; // 定义static全局变量，保证只分配一次内存</span><br><span class="line">+ (id)shareInstance&#123;</span><br><span class="line">    return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">+ (id)copyWithZone:(struct _NSZone *)zone&#123;</span><br><span class="line">    static dispatch_once_t onceToken; // 声明一个静态的GcD单次任务</span><br><span class="line">    // 保证只执行一次</span><br><span class="line">    dispatch_once(&amp;onceToken,^&#123; // </span><br><span class="line">        _instance = [super allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">这么写可以保证下面两种方式返回同一个实例</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>Single * p1 &#x3D; [Single shareInstance];<br>Single * p2 &#x3D; [[Single alloc] init];<br>NSLog(@”%d”,p1&#x3D;&#x3D;p2); &#x2F;&#x2F; 1</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## HTTPS和HTTP的区别？ **重点**</span><br><span class="line"></span><br><span class="line">* HTTP：超文本传输协议，信息明文传输；端口号80；响应速度快（使用TCP三次握手，客户端和服务端需要交换3个包）；</span><br><span class="line"></span><br><span class="line">* HTTPS：是由 HTTP+SSL/TLS 加密传输；端口号443；响应速度慢（除了使用TCP三个包，还要加上SSL握手的9个包）；需要到CA申请证书</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## TCP 和 UDP 区别? **重点**</span><br><span class="line"></span><br><span class="line">* 都是 `传输层` 协议</span><br><span class="line"></span><br><span class="line">* TCP协议是 `面向连接的可靠的传输层协议`。UDP协议是 `面向非连接的传输层协议`</span><br><span class="line"></span><br><span class="line">* TCP需要 `建立连接和断开连接`。UDP不需要连接。</span><br><span class="line"></span><br><span class="line">* TCP传 `输数据没有大小限制`。UDP `传输数据有大小限制`。</span><br><span class="line"></span><br><span class="line">* TCP会 `处理数据丢包重发`。UDP不会处理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># HTTP和socket区别？ **重点**</span><br><span class="line"></span><br><span class="line">* `HTTP` 应用层协议；`socket` 不属于协议范畴，而是一个接口（API），是对TCP/IP协议的封装</span><br><span class="line">* `HTTP` 是基于 `请求-响应` 形式 `短连接`，即客户端发送一次请求，服务端响应后立即 `断开连接`；socket 是基于TCP协议的 `长链接`，理论上 客户端和服务端一旦建立连接将不会主动断开</span><br><span class="line">* HTTP 传输慢，数据量大，安全差；socket 数据可自定义，数据量小，安全性高，适合信息实时交互（推送、聊天等）</span><br><span class="line"></span><br><span class="line">## staitc 和 const 的区别？ **重点**</span><br><span class="line"></span><br><span class="line">* const：表示 `只读` 的意思</span><br><span class="line"></span><br><span class="line">    * `const` 放在 `类型` 前：可以改变指针的指向，可以改变指针指向的内容</span><br><span class="line">    </span><br><span class="line">    * `const` 放在 `变量` 前：不可以改变指针的指向，不可以改变指针指向的内容</span><br><span class="line"></span><br><span class="line">* static： `静态变量`，可修饰 `局部变量和全局变量`，可修饰方法</span><br><span class="line"></span><br><span class="line">    * `static` 可修饰 `局部/全局变量`，称为 `局部静态变量和全局静态变量`，只初始化一次，只分配一次内存，生命周期被改变，不再是作用域内</span><br><span class="line"></span><br><span class="line">    * `static` 修饰的 `方法`，可以在不同文件下重名，互不影响运行</span><br><span class="line"></span><br><span class="line">## 通用链接（Universal Links）**重点**</span><br><span class="line"></span><br><span class="line">* 服务端配置 `HTTPS` 证书 和添加 `apple-app-site-association` 地址关联文件</span><br><span class="line"></span><br><span class="line">* 移动端在plist添加 `Associated Domains` 关联域权限</span><br><span class="line"></span><br><span class="line">## 简述GET和POST请求的区别？ **重点**</span><br><span class="line"></span><br><span class="line">* GET 传输数据 `有缓存`；POST 传输数据 `没有缓存`</span><br><span class="line"></span><br><span class="line">* GET的 `参数` 放在 `URL` 的后面，并且第一个参数用 `?` 号拼接，后面的从第二个参数开始，直到最后一个，用 `&amp;` 分割；POST的 `参数` 放在 `请求体` 里面，并且第一个参数用 `,` 号拼接，后面从第二开始，直到最后用 `&amp;` 分割;</span><br><span class="line"></span><br><span class="line">* GET一般用于 `获取数据`；POST一般用于 `向服务器提交数据`</span><br><span class="line"></span><br><span class="line">* `GET` 的参数是暴漏在 `地址栏` 的，不安全；`POST` 的参数隐藏在 `请求体` 里面，相对安全一点;</span><br><span class="line"></span><br><span class="line">* GET请求提交数据受浏览器限制 `1k`，POST请求理论上无限制。</span><br><span class="line"></span><br><span class="line">## iOS中几种常见的设计模式？  **重点**</span><br><span class="line"></span><br><span class="line">* `代理模式`</span><br><span class="line"></span><br><span class="line">一对一的依赖关系，当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。</span><br><span class="line"></span><br><span class="line">* `观察者模式`</span><br><span class="line"></span><br><span class="line">KVO机制 和 Notification通知机制</span><br><span class="line"></span><br><span class="line">* `单例模式`</span><br><span class="line"></span><br><span class="line">保证程序运行过程中，一个类只返回一个实例，供外界访问</span><br><span class="line"></span><br><span class="line">* `工厂模式`</span><br><span class="line"></span><br><span class="line">通过一个类方法，`根据已有模板批量生产对象`。</span><br><span class="line"></span><br><span class="line">* `MVC模式`</span><br><span class="line"></span><br><span class="line">Model即数据模型</span><br><span class="line"></span><br><span class="line">view即视图</span><br><span class="line"></span><br><span class="line">controller即控制器</span><br><span class="line"></span><br><span class="line">## RunLoop是什么？ **重点**</span><br><span class="line"></span><br><span class="line">* 概念 </span><br><span class="line"></span><br><span class="line">`RunLoop` 又叫 `运行循环`，内部就是一个 `do-while循环`，在这个循环内部不断 `处理各种任务，保证程序持续运行`。</span><br><span class="line"></span><br><span class="line">* 目的</span><br><span class="line"></span><br><span class="line">RunLoop存在的目的： 就是当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，`提高程序性能，节省CPU资源`，该做事的时候做事，该休息的时候休息</span><br><span class="line"></span><br><span class="line">## RunLoop的作用？ **重点**</span><br><span class="line"></span><br><span class="line">* `保持程序持续运行`。</span><br><span class="line">   App一启动就会开启主线程，主线程在开启的时候就会开启主线程对应的RunLoop，RunLoop能保证线程不被销毁，主线程不销毁，程序就会持续运行。</span><br><span class="line"></span><br><span class="line">* `处理App中各类事件`。</span><br><span class="line">   事件响应、手势识别、界面刷新、AutoreleasePool自动释放池、NSTimer等事件处理。</span><br><span class="line"></span><br><span class="line">* `节省CPU资源，提高程序性能`。</span><br><span class="line">   如概述所述，当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，提高程序性能，节省资源，该做事的时候做事，该休息的时候休息。</span><br><span class="line"></span><br><span class="line">## 可以用Runloop实现什么功能？ **重点**</span><br><span class="line"></span><br><span class="line">* 线程保活</span><br><span class="line"></span><br><span class="line">往 `runloop` 中添加 `[[NSPort alloc] init]` 事件，</span><br><span class="line"></span><br><span class="line">* 解决NSTimer在滑动时停止工作的问题</span><br><span class="line"></span><br><span class="line">`default` 模式改为 `common` 模式</span><br><span class="line"></span><br><span class="line">* 检测卡顿</span><br><span class="line"></span><br><span class="line">如果我们要利用 `RunLoop` 原理来监控卡顿的话，就是要关注这两个阶段。RunLoop 在进入睡眠之前和唤醒后的两个 `loop` 状态定义的值，分别是 `kCFRunLoopBeforeWaiting` 和 `kCFRunLoopAfterWaiting` ，也就是要触发 `Source0` 回调和接收 `mach_port` 消息两个状态。</span><br><span class="line"></span><br><span class="line">## RunLoop接收几种输入源，系统默认定义了几种模式？ **重点**</span><br><span class="line"></span><br><span class="line">* 输入源有两种</span><br><span class="line">基于 `端口` 的输入源（port）</span><br><span class="line">`自定义` 的输入源（custom）</span><br><span class="line"></span><br><span class="line">* 系统定义的RunLoop模式有五种，最常用的有三种，如下所示：</span><br><span class="line">NSDefaultRunLoopMode</span><br><span class="line">默认模式，主线程中默认是NSDefaultRunLoopMode</span><br><span class="line">UITrackingRunLoopMode</span><br><span class="line">视图滚动模式，RunLoop会处于该模式下</span><br><span class="line">NSRunLoopCommonModes</span><br><span class="line">并不是真正意义上的Mode，是一个占位用的“Mode”，默认包含了NSDefaultRunLoopMode和UITrackingRunLoopMode两种模式</span><br><span class="line"></span><br><span class="line">## RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？ **重点**</span><br><span class="line"></span><br><span class="line">* 每一个线程都有一个runloop，主线程的runloop默认启动。子线程的runloop默认不启动</span><br><span class="line">* mode：主要用来指定事件在运行时循环的优先级</span><br><span class="line">* 作用：保持程序的持续运行、随时处理各种事件、节省cpu资源(没事件休息释放资源)，提高程序的性能。</span><br><span class="line"></span><br><span class="line">## 怎么理解Objective-C是动态运行时语言。 **重点**</span><br><span class="line"></span><br><span class="line">主要是 `将数据类型的确定和函数的调用由编译时推迟到了运行时`。这个问题其实浅涉及到两个概念，`运行时和多态`。</span><br><span class="line"></span><br><span class="line">* 运行时：简单来说，运行时机制使我们 `直到运行时才去确定数据类型和要调用的函数`。</span><br><span class="line"></span><br><span class="line">* 多态：`不同对象以自己的方式响应相同的消息的能力` 叫做多态。</span><br><span class="line"></span><br><span class="line">## runtime项目中具体应用？ **重点**</span><br><span class="line"></span><br><span class="line">* `方法交换`。</span><br><span class="line">* 给 `分类添加属性`。 </span><br><span class="line">* 动态添加方法。</span><br><span class="line">* 字典转模型。</span><br><span class="line">* 数组越界。</span><br><span class="line">* 动态获取成员属性、成员变量、实例方法</span><br><span class="line"></span><br><span class="line">## KVC是什么？**重点**</span><br><span class="line"></span><br><span class="line">`KVC` 全程 `Key Value Coding`，中文 `键值编码`，是由 `NSKeyValueCoding` 非正式协议启动的一种机制，`对象` 采用该协议来 `间接访问对象的属性`。</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li><p>(nullable id)valueForKey:(NSString *)key;     </p></li><li><p>(nullable id)valueForKeyPath:(NSString *)keyPath; </p></li><li><p>(void)setValue:(nullable id)value forKey:(NSString *)key;</p></li><li><p>(void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; </p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[KVC底层原理：](http://www.bboyzj.cn/2021/01/17/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8622%EF%BC%9AKVC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/)</span><br><span class="line"></span><br><span class="line">## KVO是什么？**重点**</span><br><span class="line"></span><br><span class="line">`KVO` 全程 `Key Value Observing`，中文 `键值观察`，它 `用于监听实例对象属性的变化`。</span><br><span class="line"></span><br><span class="line">## KVO的实现原理？(KVO的本质是什么？) **重点**</span><br><span class="line"></span><br><span class="line">当一个 `实例对象` 的 `属性注册了KVO`，实例对象 `isa指针` 的指向在注册KVO观察者之后，由 `原有类` 改为 `中间类(NSKVONotifing_类名)`；`中间类` 重写了 `属性setter方法、class、dealloc、_isKVOA` 方法；`dealloc` 方法中，移除 `KVO` 观察者之后，实例对象isa 指向由 `中间类` 更改为 `原有类`;中间类 从创建后就 `一直存在内存中`，不会被销毁。</span><br><span class="line"></span><br><span class="line">## KVO实际应用 **重点**</span><br><span class="line"></span><br><span class="line">* 观察 `实例对象` 的 `属性` 变化</span><br><span class="line"></span><br><span class="line">* 观察 `实例对象` 的 `容器` 变化</span><br><span class="line"></span><br><span class="line">   观察容器用： `mutableArrayValueForKey`</span><br><span class="line">   </span><br><span class="line">[KVO底层原理：](http://www.bboyzj.cn/2021/01/25/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8623%EF%BC%9AKVO%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/) </span><br><span class="line"></span><br><span class="line">## category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？**重点**</span><br><span class="line"></span><br><span class="line">* `category` 原则上它 `只能增加方法`，`不能增加成员（实例）变量`。可以添加属性，但是不会自动生成实例变量_name和setter和getter方法。可以添加方法</span><br><span class="line"></span><br><span class="line">* `扩展` 主要用来为一个类添加额外的原来没有的 `实例变量、方法和属性`。extension常用的形式并不是以一个单独的.h文件存在，而是寄生在类的.m文件中。</span><br><span class="line"></span><br><span class="line">类扩展中：</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>@interface Person (){<br>  int age; &#x2F;&#x2F;实例变量<br>}<br>@property (nonatomic,copy)NSString * name;&#x2F;&#x2F;属性</p></li><li><p>(void)run;&#x2F;&#x2F;方法<br>@end</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## iOS开发中有多少类型的线程？  **重点**</span><br><span class="line"></span><br><span class="line">* pthread</span><br><span class="line"></span><br><span class="line">一套用于 `C` 的多线程 `API`、适用于 `Unix / Linux / Windows` 等系统、跨平台、可移植、使用难度大</span><br><span class="line"></span><br><span class="line">* NSThread</span><br><span class="line"></span><br><span class="line">使用更加面向对象、简单易用，可直接操作线程对象</span><br><span class="line"></span><br><span class="line">* GCD</span><br><span class="line"></span><br><span class="line">旨在替代NSThread等线程技术、充分利用设备的 `多核`、基于 `C` 的底层的 API</span><br><span class="line"></span><br><span class="line">* NSOperation</span><br><span class="line"></span><br><span class="line">`NSOperation` 是基于 `GCD` 之上的更高一层的封装， `NSOpetation` 需要配合 `NSOpetationQueue` 来实现多线程</span><br><span class="line"></span><br><span class="line">## 根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？  **重点**</span><br><span class="line"></span><br><span class="line">dispatch_group_t + dispatch_group_enter + dispatch_group_leave + dispatch_group_notify</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 10个网络请求顺序回调? GCD如何实现？**重点**</span><br><span class="line"></span><br><span class="line">dispatch_group_t + dispatch_semaphore_t：信号量（dispatch_semaphore_wait + dispatch_group_leave）</span><br><span class="line"></span><br><span class="line">## GCD和NSOperation的区别？ **重点**</span><br><span class="line"></span><br><span class="line">* `GCD执行效率更高`，而且由于队列中执行的是由block构成的任务，这是一个轻量级的数据结构，写起来更方便</span><br><span class="line">* GCD只支持FIFO的队列，而 `NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序`</span><br><span class="line">* NSOperationQueue甚至可以跨队列设置依赖关系，但是GCD只能通过设置串行队列，或者在队列内添加barrier(dispatch_barrier_async)任务，才能控制执行顺序,较为复杂</span><br><span class="line">* `NSOperationQueue因为面向对象`，所以 `支持KVO`，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished）、是否取消（isCanceld）</span><br><span class="line"></span><br><span class="line">具体的底层看 [OC底层原理27：GCD之 NSThread &amp; GCD &amp; NSOperation](http://www.bboyzj.cn/2021/03/23/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8627%EF%BC%9AGCD%E4%B9%8B%2520NSThread%2520&amp;%2520GCD%2520&amp;%2520NSOperation/)</span><br><span class="line"></span><br><span class="line">## 什么是Block？ **重点**</span><br><span class="line"></span><br><span class="line">`Block` 是将 `函数及其上下文封装起来的对象`</span><br><span class="line"></span><br><span class="line">## Block的本质 **重点**</span><br><span class="line"> </span><br><span class="line">* block 的 `本质` 是 `对象、函数、结构`体，由于block函数没有名称，也被称为 `匿名函数`</span><br><span class="line"></span><br><span class="line">## Block的分类？ **重点**</span><br><span class="line"></span><br><span class="line">* 分为 `全局Block(_NSConcreteGlobalBlock)、栈Block(_NSConcreteStackBlock)、堆Block(_NSConcreteMallocBlock)` 三种形式。</span><br><span class="line"></span><br><span class="line">* 其中 `栈Block存储在栈(stack)区`，`堆Block存储在堆(heap)区`，`全局Block存储在已初始化数据(.data)区`。</span><br><span class="line"></span><br><span class="line">    * 堆：动态分配内存，需要程序员自己申请，程序员自己管理</span><br><span class="line">    * 栈：自动分配内存，自动销毁，先入后出，栈上的内容存在自动销毁的情况</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">具体看底层原理 [OC底层原理30：Block底层原理](http://www.bboyzj.cn/2021/04/22/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8630%EF%BC%9ABlock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 循环引用的几种情况和解决方式？ **重点**</span><br><span class="line"></span><br><span class="line">* Block</span><br><span class="line"></span><br><span class="line">原因： `self` 强引用了 `block`，而 `block` 内部又调用了 `self`</span><br><span class="line">解决： 使用 `Weak-Strong Dance`</span><br><span class="line"></span><br><span class="line">* Delegate</span><br><span class="line"></span><br><span class="line">原因：委托者和被委托人之间的相互强引用问题 `strong`</span><br><span class="line">解决：用 `weak` 进行弱引用 `或者` 通过中间对象(代理对象)的方式来解决(效率更加高的中间对象NSProxy：不需要进行发送消息和动态解析，直接进行消息转发)</span><br><span class="line"></span><br><span class="line">* NSTimer</span><br><span class="line"></span><br><span class="line">原因：self → timer → self(target) 的循环持有链</span><br><span class="line">解决：在适当的时机销毁 </span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>[_timer invalidate];<br>_timer &#x3D; nil;</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># OC 如何进行内存管理的？ **重点**</span><br><span class="line"></span><br><span class="line">* 自动内存管理 ARC</span><br><span class="line">* 手动内存管理</span><br><span class="line">* 自动释放池</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 内存优化 **重点**</span><br><span class="line"></span><br><span class="line">* cell复用</span><br><span class="line">* 绘制的话：用CAShaperLayer，渲染快，内存使用高效</span><br><span class="line">* 按需加载：懒加载</span><br><span class="line">* 合理利用缓存：比如三方图片压缩缓存</span><br><span class="line">* 尽量使用透明View：控件有背景色增大内存消耗</span><br><span class="line"></span><br><span class="line"># 启动优化 **重点**</span><br><span class="line"></span><br><span class="line">* pre-main 阶段：`二进制重排`</span><br><span class="line"></span><br><span class="line">    * 尽量 `少用外部动态库`，苹果官方建议自定义的动态库最好 `不要超过6个`，如果超过6个，需要 `合并` 动态库</span><br><span class="line"></span><br><span class="line">    * 减少 `OC` 类，因为类越多，越耗时</span><br><span class="line"></span><br><span class="line">    * 将不必须在 `+load` 方法中做的事情延迟到 `+initialize` 中，尽量不要用 `C++` 虚函数</span><br><span class="line"></span><br><span class="line">* main 阶段：mian -&gt; didFinishLaunching</span><br><span class="line"></span><br><span class="line">    * 减少启动初始化的流程，`能懒加载的懒加载，能延迟的延迟，能放后台初始化的放后台`，尽量少占用主线程的启动时间</span><br><span class="line"></span><br><span class="line">    * 优化代码逻辑，去除非必须的代码逻辑，减少每个流程的消耗时间</span><br><span class="line"></span><br><span class="line">    * 启动阶段能 `使用多线程` 来初始化的，就使用多线程</span><br><span class="line"></span><br><span class="line">    * 尽量 `使用纯代码` 来进行UI框架的搭建，尤其是主UI框架，例如 UITabBarController，尽量避免使用Xib或者SB，相比纯代码而言，这种更耗时</span><br><span class="line"></span><br><span class="line">    * 删除废弃类、方法</span><br><span class="line"> </span><br><span class="line">## 屏幕卡顿优化 **重点**</span><br><span class="line"></span><br><span class="line">**主要是用Runloop进行FPS监测**</span><br><span class="line"></span><br><span class="line">主要从减轻 `CPU` 和 `GPU` 消耗入手，保证写一个 `VSync` 到来时，`CPU` 和 `GPU` 能够写作完成下一帧的渲染并缓存到帧缓冲区</span><br><span class="line"></span><br><span class="line">* 卡顿优化在 `CPU` 层面：</span><br><span class="line"></span><br><span class="line">1）尽量用轻量级的对象，比如 `用不到事件处理` 的地方，可以考虑使用 `CALayer` 取代 `UIView`</span><br><span class="line">2）不要频繁地调用 `UIView` 的相关属性，比如 `frame、bounds、transform` 等属性，尽量减少不必要的修改</span><br><span class="line">3）尽量 `提前计算好布局`，在有需要时一次性调整对应的属性，不要多次修改属性</span><br><span class="line">4）图片的 `size` 最好刚好跟 `UIImageView` 的 `size` 保持一致</span><br><span class="line">5）`控制`一下线程的最大并发数量</span><br><span class="line">6）尽量把 `耗时的操作放到子线程`：如text宽高获取等</span><br><span class="line"></span><br><span class="line">* 卡顿优化在 GPU层面：</span><br><span class="line"></span><br><span class="line">1）GPU能处理的 `最大纹理` 尺寸是 `4096x4096`，一旦超过这个尺寸，就会占用 `CPU` 资源进行处理，所以纹理尽量不要超过这个尺寸</span><br><span class="line">2）尽量 `减少视图数量和层次`</span><br><span class="line">3）`减少透明的视图`（alpha&lt;1），不透明的就设置 `opaque` 为 `YES`</span><br><span class="line">4）尽量 `避免出现离屏渲染`：圆角、阴影、遮罩等</span><br><span class="line"> </span><br><span class="line">## 卡顿优化：tableView优化 **重点**</span><br><span class="line"></span><br><span class="line">* 最常用的就是`cell的复用`， 注册复用标识符</span><br><span class="line"></span><br><span class="line">* `避免cell的重新布局`，初始化时就布局好</span><br><span class="line"></span><br><span class="line">* `提前计算并缓存cell的高度`</span><br><span class="line"></span><br><span class="line">* `减少cell中控件的数量`，少动态添加 view</span><br><span class="line"></span><br><span class="line">* `避免背景透明`</span><br><span class="line"></span><br><span class="line">* 能`使用局部更新` 的就使用 `局部更新`</span><br><span class="line"></span><br><span class="line">* 加载网络数据，`下载图片，使用异步加载`，并缓存</span><br><span class="line"></span><br><span class="line">* `按需加载cell`：cell滚动很快时，只加载范围内的cell</span><br><span class="line"></span><br><span class="line">* `不要实现无用的代理方法`，tableView只遵守两个协议</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"># 网络优化 **重点**</span><br><span class="line"></span><br><span class="line">* DNS优化：即域名解析优化，缓存 ip</span><br><span class="line">* 资源优化：</span><br><span class="line">    * 图片webp，比png/jpg小</span><br><span class="line">    * 数据传输用ProtocolBuffer代替json，数据小，序列化和反序列化也简单</span><br><span class="line">* 请求压缩、请求合并</span><br><span class="line">* 数据缓存</span><br><span class="line">* 网络环境监测</span><br><span class="line">    * 针对性请求重试</span><br><span class="line"></span><br><span class="line">## TCP三次握手，四次挥手过程？**重点**</span><br><span class="line"></span><br><span class="line">1. 为什么是三次握手，而不是二次握手？</span><br><span class="line"></span><br><span class="line">三次握手是为了建立一个可靠的数据传输通道：</span><br><span class="line"></span><br><span class="line">* 刚开始客户端和服务端处于关闭状态，而且服务端B一直处于监听状态，时刻监听是否有建立连接的请求</span><br><span class="line"></span><br><span class="line">* 当客户端需要建立连接的时候就会发送一个 `请求连接` 的报文，此报文是 `同步报文SYN=1`，并且会生成一个 `随机的序号seq=x`，这是第一次握手</span><br><span class="line"></span><br><span class="line">* 当服务端接收到请求连接报文时，会发送一个 `确认连接` 的报文，此报文是 `同步报文SYN=1`，并且 `确认报文ACK=1`，同时服务端也会生成一个 `随机的序号seq=y`，并且将 `确认报文确认号ack=x+1`，回传给客户端，这是第二次握手</span><br><span class="line"></span><br><span class="line">* 当客户端接收到服务端的 `ACK确认报文后`，会回复一个 `ACK确认报文`，用于确认确认报文已经收到，此报文 `ACK=1，seq=x+1，ack=y+1`，这是第三次握手</span><br><span class="line"></span><br><span class="line">2. 四次挥手</span><br><span class="line"></span><br><span class="line">四次挥手则是为了保证数据传输完成接收再关闭连接。</span><br><span class="line"></span><br><span class="line">* 客户端断开连接时会发送一个 `请求断开连接` 的报文，此报文是 `FIN=1`，并且会生成一个 `随机的序号seq=u`，发送给服务端，这是第一次挥手</span><br><span class="line"></span><br><span class="line">* 服务端接收到请求断开连接 `FIN报文` 后，回复一个 `确认断开连接` 报文 `ACK=1,seq=v,ack=u+1`，这是第二次挥手</span><br><span class="line"></span><br><span class="line">* 当服务端数据发送完后，再发送一个FIN报文给客户端，通知客户端，服务端准备关闭连接，此报文 `FIN=1,ACK=1,ack=u+1,seq=w`，这是第三次挥手</span><br><span class="line"></span><br><span class="line">* 当客户端收到 `FIN确认报文`，再发送一个FIN确认报文 `ACK=1,seq=u+1,ack=w+1`，并进入` TIME-WAIT` 等待，等待 `2MSL` 后关闭连接，这是第四次挥手</span><br><span class="line"> </span><br><span class="line"># 事件链 **重点**</span><br><span class="line"></span><br><span class="line">[OC学习01：事件传递链和响应链](https://www.bboyzj.cn/2023/03/01/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/)</span><br><span class="line"></span><br><span class="line">* 传递链：由系统向离用户最近的view传递。</span><br><span class="line">  顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; ViewController -&gt; subViews</span><br><span class="line"></span><br><span class="line">* 响应链：由离用户最近的view向系统传递。</span><br><span class="line">  顺序： superViews –&gt; ViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate</span><br><span class="line"></span><br><span class="line"># 事件传递的两个核心方法？ **重点**</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>&#x2F;&#x2F; 返回最适合处理事件的视图</p></li><li><p>(nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;<br>&#x2F;&#x2F; 判断点是否在这个View内部</p></li><li><p>(BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 第一个方法返回的是一个 `UIView`，是用来寻找最终哪一个视图来响应这个事件</span><br><span class="line">* 第二个方法是用来判断某一个点击的位置是否在视图范围内，如果在就返回YES</span><br><span class="line"></span><br><span class="line"># 实现一个按钮的点击范围扩大效果 **重点**</span><br><span class="line"></span><br><span class="line">自定义一个按钮，继承UIButton，重写 `pointInside:withEvent:` 方法，</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li><li><p>(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{<br>  &#x2F;&#x2F; 当前btn大小<br>  CGRect btnBounds &#x3D; self.bounds;<br>  &#x2F;&#x2F; 扩大按钮的点击范围，增大内边距<br>  btnBounds &#x3D; CGRectInset(btnBounds, -10, -10);<br>  &#x2F;&#x2F; 若点击的点在新的bounds里，返回YES<br>  return CGRectContainsPoint(btnBounds, point);<br>}</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 子视图超过父视图部分仍然能响应 **重点**</span><br><span class="line"></span><br><span class="line">重写 `hitTest:withEvent` 方法，让 `子视图` 去相应事件</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li><li><p>(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{<br>  &#x2F;&#x2F; 判断btn能否接收事件<br>  if (self.btn.userInteractionEnabled &#x3D;&#x3D; NO || self.btn.hidden &#x3D;&#x3D; YES || self.btn.alpha &lt;&#x3D; 0.01) {<br>  return nil;<br>  }<br>  &#x2F;&#x2F; 把当前点转换成btn坐标系上的点<br>  CGPoint btnP &#x3D; [self convertPoint:point toView:self.btn];<br>  &#x2F;&#x2F; 当触摸点在btn上时，才让按钮相应事件<br>  if ([self.btn pointInside:btnP withEvent:event]) {<br>  NSLog(@”%@”,NSStringFromCGPoint(btnP));<br>  return self.btn;<br>  }<br>  NSLog(@”父视图相应”);<br>  return [super hitTest:point withEvent:event];<br>}</p></li></ul><p>&#96;&#96;&#96;</p><h1 id="面试官问还有什么想问的？-重点"><a href="#面试官问还有什么想问的？-重点" class="headerlink" title="面试官问还有什么想问的？ 重点"></a>面试官问还有什么想问的？ <strong>重点</strong></h1><p>技术面不问薪资待遇，人事面问薪资待遇</p><ul><li>问岗位：</li></ul><ol><li>在这个岗位上，会直接 <code>接触到哪些类型的项目？</code></li><li>这个岗位的主要职责是什么？主要的KPI是什么？</li><li>这个岗位如何评估绩效，试用期需要达到什么指标？</li><li>这个岗位的最大挑战是什么？</li></ol><ul><li>问团队：</li></ul><ol><li><code>团队的基本情况？</code></li><li>这个团队在公司的角色是什么？</li><li>可以跟我介绍一下我的领导吗？</li></ol><ul><li>问公司</li></ul><ol><li><code>公司的文化氛围是什么样的？</code></li><li>员工的晋升机制是什么样的？我这个岗位的晋升机会如何？</li><li>这个岗位所在的团队如何支持公司目标的实现？</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OC算法&quot;&gt;&lt;a href=&quot;#OC算法&quot; class=&quot;headerlink&quot; title=&quot;OC算法&quot;&gt;&lt;/a&gt;OC算法&lt;/h1&gt;&lt;h2 id=&quot;1-冒泡排序&quot;&gt;&lt;a href=&quot;#1-冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;1. 冒泡</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-面试题" scheme="https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Blog-04：主题完善</title>
    <link href="https://www.bboyzj.cn/2023/03/01/Blog-04%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/"/>
    <id>https://www.bboyzj.cn/2023/03/01/Blog-04%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/</id>
    <published>2023-03-01T02:54:01.000Z</published>
    <updated>2023-03-01T17:50:03.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们以 <a class="link"   href="https://github.com/shenliyang/hexo-theme-snippet" >Snippet <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 主题问例</p><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ git clone git://github.com/shenliyang/hexo-theme-snippet.git themes/hexo-theme-snippet</span><br></pre></td></tr></table></figure></div><h1 id="安装主题插件"><a href="#安装主题插件" class="headerlink" title="安装主题插件"></a>安装主题插件</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S</span><br></pre></td></tr></table></figure></div><h1 id="部署主题"><a href="#部署主题" class="headerlink" title="部署主题"></a>部署主题</h1><p>具体部署看下面的链接：1、2、3步骤可省略</p><p><a class="link"   href="https://github.com/shenliyang/hexo-theme-snippet" >Snippet <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们以 &lt;a class=&quot;link&quot;   href=&quot;https://github.com/shenliyang/hexo-theme-s</summary>
      
    
    
    
    <category term="Blog" scheme="https://www.bboyzj.cn/categories/Blog/"/>
    
    
    <category term="博客搭建" scheme="https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Blog-03：Github域名绑定阿里云域名</title>
    <link href="https://www.bboyzj.cn/2023/03/01/Blog-03%EF%BC%9AGithub%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/"/>
    <id>https://www.bboyzj.cn/2023/03/01/Blog-03%EF%BC%9AGithub%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/</id>
    <published>2023-03-01T02:17:25.000Z</published>
    <updated>2023-03-01T11:26:07.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注册域名"><a href="#注册域名" class="headerlink" title="注册域名"></a>注册域名</h1><p>去 <a class="link"   href="https://dc.console.aliyun.com/" >阿里云 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 注册账号、并购买域名，具体流程这里就不一一介绍了</p><h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><ul><li>在终端 <code>ping</code> 一下之前配置的静态页面地址,可以获取到对应的ip地址:</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % ping BboyZJ.github.io</span><br><span class="line">PING bboyzj.github.io (185.199.109.153): 56 data bytes</span><br><span class="line">64 bytes from 185.199.109.153: icmp_seq=0 ttl=50 time=261.217 ms</span><br><span class="line">64 bytes from 185.199.109.153: icmp_seq=1 ttl=50 time=337.547 ms</span><br><span class="line">64 bytes from 185.199.109.153: icmp_seq=2 ttl=50 time=260.716 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><ul><li>@解析</li></ul><p>记录类型：A<br>主机记录：@<br>解析请求来源：默认<br>记录值：185.199.109.153<br>TTL：10分钟</p><p>点击确定</p><ul><li>www解析</li></ul><p>记录类型：CNAME<br>主机记录：www<br>解析线路来源：默认<br>记录值：BboyZJ.github.io<br>TTL：10分钟</p><p>点击确定</p><ul><li>配置项目 <code>CNAME</code></li></ul><p>在 <code>Blog/source</code> 目录下，新建 <code>CNAME</code> 文件，内容输入阿里云申请的域名 <a href="http://www.bboyzj.cn/">www.bboyzj.cn</a></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/Blog/source </span><br><span class="line">mac@bogon source % touch CNAME</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16776380930111.jpg"                      alt="16776380930111"                ></p><ul><li>配置 <code>Blog</code> 目录下 <code>_config.yml</code> 文件，<code>URL</code> 模块</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="line">url: https://www.bboyzj.cn</span><br><span class="line">root: /BboyZJ.github.io/</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></pre></td></tr></table></figure></div><ul><li>执行</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % hexo clean</span><br><span class="line">mac@bogon ~ % hexo g</span><br><span class="line">mac@bogon ~ % hexo d</span><br></pre></td></tr></table></figure></div><p>提交陈成功后，就可以在 <code>GitHub</code> 和 <a href="http://www.bboyzj.cn/">www.bboyzj.cn</a> 个人域名绑定上了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;注册域名&quot;&gt;&lt;a href=&quot;#注册域名&quot; class=&quot;headerlink&quot; title=&quot;注册域名&quot;&gt;&lt;/a&gt;注册域名&lt;/h1&gt;&lt;p&gt;去 &lt;a class=&quot;link&quot;   href=&quot;https://dc.console.aliyun.com/&quot; &gt;阿里云</summary>
      
    
    
    
    <category term="博客搭建" scheme="https://www.bboyzj.cn/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Blog" scheme="https://www.bboyzj.cn/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Blog-02：部署博客到GitHub</title>
    <link href="https://www.bboyzj.cn/2023/03/01/Blog-02%EF%BC%9A%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0GitHub/"/>
    <id>https://www.bboyzj.cn/2023/03/01/Blog-02%EF%BC%9A%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0GitHub/</id>
    <published>2023-03-01T01:12:01.000Z</published>
    <updated>2023-03-01T13:45:55.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h1><p>前往 <a class="link"   href="https://github.com/" >Github <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 网站，注册一个新用户。用邮箱注册的一定前往邮箱去验证邮件。</p><h1 id="部署到-GitHub-上"><a href="#部署到-GitHub-上" class="headerlink" title="部署到 GitHub 上"></a>部署到 GitHub 上</h1><ul><li>新建 <code>reponsity</code> 仓库</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012145840.png"                                     ></p><p>仓库名设置成 <code>用户名.github.io</code> ，比如我的是 <code>BboyZJ.github.io</code>，选择 Public，勾选 <code>Add a README file</code> ，最后 <code>Create respository</code></p><h1 id="配置秘钥"><a href="#配置秘钥" class="headerlink" title="配置秘钥"></a>配置秘钥</h1><ul><li>查看秘钥</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">$ cat id_rsa.pub</span><br></pre></td></tr></table></figure></div><ul><li>添加SSH秘钥：头像 -&gt; Setting -&gt; SSH and GPG keys</li></ul><p><code>Title</code> 随意写，<code>Key</code> 需要填写刚才复制的 <code>秘钥</code> 文本内容</p><ul><li>添加完成，验证链接</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">Hi BboyZJ! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></div><h1 id="上传文件到-GitHub"><a href="#上传文件到-GitHub" class="headerlink" title="上传文件到 GitHub"></a>上传文件到 GitHub</h1><ul><li>配置 <code>Blog</code> 下 <code>_config.yml</code> 中的 <code>Deployment</code> 模块</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/BboyZJ/BboyZJ.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></div><ul><li>安装部署插件</li></ul><p>通过 Hexo 发布到 GitHub，需要安装部署插件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></div><ul><li>部署</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/Blog</span><br><span class="line">mac@bogon ~ % hexo g</span><br><span class="line">mac@bogon ~ % hexo d</span><br></pre></td></tr></table></figure></div><ul><li>访问</li></ul><p>这时我们的 <code>GitHub</code> 域名 <code>https://BboyZJ.github.io</code> 就可以看到 <code>Hexo</code> 网站了，如果没显示出来就 <code>刷新</code> 一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;注册GitHub账号&quot;&gt;&lt;a href=&quot;#注册GitHub账号&quot; class=&quot;headerlink&quot; title=&quot;注册GitHub账号&quot;&gt;&lt;/a&gt;注册GitHub账号&lt;/h1&gt;&lt;p&gt;前往 &lt;a class=&quot;link&quot;   href=&quot;https://git</summary>
      
    
    
    
    <category term="Blog" scheme="https://www.bboyzj.cn/categories/Blog/"/>
    
    
    <category term="博客搭建" scheme="https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.bboyzj.cn/2023/03/01/hello-world/"/>
    <id>https://www.bboyzj.cn/2023/03/01/hello-world/</id>
    <published>2023-02-28T23:51:10.086Z</published>
    <updated>2023-02-28T23:51:10.086Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a class=&quot;link&quot;   href=&quot;https://hexo.io/&quot; &gt;Hexo &lt;i class=&quot;fa-regular fa-arrow-up-right-from-square fa-sm&quot;&gt;&lt;/i&gt;&lt;/a&gt;! This is yo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Blog-01：Hexo个人博客搭建</title>
    <link href="https://www.bboyzj.cn/2023/03/01/Blog-01%EF%BC%9AHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://www.bboyzj.cn/2023/03/01/Blog-01%EF%BC%9AHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2023-02-28T23:39:40.000Z</published>
    <updated>2023-03-01T15:11:35.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><ul><li>什么是Hexo？</li></ul><p>简介：<code>Hexo</code> 是一个快速、简洁且高效的博客框架。想要详细的了解 <a class="link"   href="https://hexo.io/zh-cn/docs/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，去官网学习。<code>Hexo</code> 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h1 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h1><ul><li>检查是否安装 <code>homebrew</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % brew -v</span><br><span class="line">Homebrew 3.6.21-28-ge6548a8</span><br><span class="line">Homebrew/homebrew-core (git revision 5434c8344e8; last commit 2023-02-09)</span><br><span class="line">Homebrew/homebrew-cask (git revision 15c2c1fa53; last commit 2023-02-09)</span><br><span class="line">mac@bogon ~ % </span><br></pre></td></tr></table></figure></div><p>如果顺利显示版本号，说明homebrew已经安装。否则，输入以下命令进行安装：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></div><ul><li>安装过程如果出现下面的问题</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</span><br></pre></td></tr></table></figure></div><p>解决:</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % /usr/bin/ruby -e &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)&quot;</span><br></pre></td></tr></table></figure></div><ul><li>安装 <code>Node.js</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % brew install node</span><br><span class="line">mac@bogon ~ % node -v</span><br><span class="line">v18.14.2</span><br></pre></td></tr></table></figure></div><ol start="3"><li>安装Git<br>Mac系统默认已经安装好了，所以不需要再安装</li></ol><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往安装 <code>Hexo</code> 步骤。</p><ul><li>使用npm完成 <code>hexo</code> 安装</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % npm install -g hexo-cli</span><br><span class="line">mac@bogon ~ % hexo -v</span><br><span class="line"></span><br><span class="line">hexo-cli: 4.1.0</span><br><span class="line">os: Darwin 21.6.0 darwin x64</span><br><span class="line">node: 12.16.1</span><br><span class="line">v8: 7.8.279.23-node.31</span><br><span class="line">uv: 1.34.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.7</span><br><span class="line">ares: 1.15.0</span><br><span class="line">modules: 72</span><br><span class="line">nghttp2: 1.40.0</span><br><span class="line">napi: 5</span><br><span class="line">llhttp: 2.0.4</span><br><span class="line">http_parser: 2.9.3</span><br><span class="line">openssl: 1.1.1d</span><br><span class="line">cldr: 35.1</span><br><span class="line">icu: 64.2</span><br><span class="line">tz: 2019c</span><br><span class="line">unicode: 12.1</span><br><span class="line">mac@bogon ~ % </span><br></pre></td></tr></table></figure></div><h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><ul><li>桌面新建 <code>Blog</code> 文件夹，打开终端，cd到 <code>Blog</code> 下，执行:</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/Blog </span><br><span class="line">mac@bogon Blog % hexo init</span><br><span class="line"></span><br><span class="line">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class="line">INFO  Install dependencies</span><br><span class="line">npm notice </span><br><span class="line">npm notice New major version of npm available! 7.3.0 -&gt; 9.5.1</span><br><span class="line">npm notice Changelog: https://github.com/npm/cli/releases/tag/v9.5.1</span><br><span class="line">npm notice Run npm install -g npm@9.5.1 to update!</span><br><span class="line">npm notice </span><br><span class="line">INFO  Start blogging with Hexo!</span><br><span class="line">mac@bogon Blog % </span><br></pre></td></tr></table></figure></div><p>【目录文件】：</p><p>_config.landscape.yml：网站本地配置信息<br>_config.yml：网站的配置信息，可以在此配置大部分的参数<br>source–posts：存放 <code>md</code> 文件<br>themes：主题文件夹，<a class="link"   href="https://hexo.io/themes/%20" >常用主题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 会放入这里<br>public：Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去</p><h1 id="hexo-测试"><a href="#hexo-测试" class="headerlink" title="hexo 测试"></a>hexo 测试</h1><ul><li>生成静态页面</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % hexo g</span><br></pre></td></tr></table></figure></div><p>会在根目录 <code>Blog\</code> 下生成 <code>public</code> 文件夹，里面包含相应的 <code>html</code> 页面。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012142095.png"                                     ></p><ul><li>启动服务器</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % hexo s</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012143213.png"                                     ></p><p>打开浏览器，输入网址: <a class="link"   href="http://localhost:4000/" >http://localhost:4000 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，即可看到hexo生成的静态页面。</p><ul><li>停止服务器</li></ul><p><code>Ctrl + C</code></p><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>hexo提供了很多主题可以参考，下面以 <a class="link"   href="https://github.com/littlewin-wang/hexo-theme-casual.git" >hexo-theme-casual <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 主题为例</p><ul><li>安装主题插件</li></ul><blockquote><p><a class="link"   href="https://github.com/EvanNotFound/hexo-theme-redefine" >hexo-theme-redefine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure></div><blockquote><p><a class="link"   href="https://github.com/littlewin-wang/hexo-theme-casual" >hexo-theme-casual <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ npm install --save hexo-renderer-jade hexo-renderer-scss hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-generator-search</span><br></pre></td></tr></table></figure></div><blockquote><p>hexo-theme-redefine</p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ npm install --save hexo-renderer-jade hexo-renderer-scss hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-generator-search</span><br></pre></td></tr></table></figure></div><blockquote><p> <a class="link"   href="https://github.com/shenliyang/hexo-theme-snippet" >hexo-theme-snippet <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S</span><br></pre></td></tr></table></figure></div><blockquote><p><a class="link"   href="https://github.com/jerryc127/hexo-theme-butterfly" >hexo-theme-butterfly <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ npm install hexo-renderer-pug hexo-renderer-stylus</span><br></pre></td></tr></table></figure></div><ul><li>下载主题</li></ul><p>进入主题的 <code>github</code> 下载页，点击 <code>code -&gt; clone</code>，复制 <code>https</code> 下载链接，进入 博库Blog目录，运行下面的命令：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % cd /Users/mac/Desktop/Blog </span><br><span class="line">mac@bogon Blog % cd themes </span><br><span class="line">mac@bogon themes % git clone https://github.com/littlewin-wang/hexo-theme-casual.git</span><br></pre></td></tr></table></figure></div><p>【注】：主题存放的目录是 <code>Blog/themes</code>，为了方便管理，每一个下载的主题都建一个单独的目录，我这个主题的目录是 <code>hexo-theme-casual</code>，可以下载多个主题:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012144981.png"                                     ></p><ul><li>主题应用</li></ul><p>找到 <code>博客Blog</code> 目录下的配置文件 <code>_config.yml</code>，找到 <code>Extensions</code> 模块，修改 <code>theme</code> 字段：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: hexo-theme-casual</span><br></pre></td></tr></table></figure></div><ul><li>启动本地服务器</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % hexo s</span><br><span class="line"></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br><span class="line">[Browsersync] Access URLs:</span><br><span class="line"> ----------------------------------</span><br><span class="line">          UI: http://localhost:3001</span><br><span class="line"> ----------------------------------</span><br><span class="line"> UI External: http://localhost:3001</span><br><span class="line"> ----------------------------------</span><br></pre></td></tr></table></figure></div><ul><li>查看效果</li></ul><p>通过 <a class="link"   href="http://localhost:4000/" >http://localhost:4000/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 查看修改后的效果</p><ul><li>主题更新</li></ul><p>这一步不是必须的，如果主题有优化，我们需要在本地同步更新一下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % /Users/mac/Desktop/Blog/themes/casual </span><br><span class="line">mac@bogon Blog % git pull</span><br></pre></td></tr></table></figure></div><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><ul><li>清除旧的内容</li></ul><p><code>hexo clean</code></p><ul><li>生成静态发布页面</li></ul><p><code>hexo g</code></p><ul><li>发布页面</li></ul><p><code>hexo d</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo&quot;&gt;&lt;a href=&quot;#Hexo&quot; class=&quot;headerlink&quot; title=&quot;Hexo&quot;&gt;&lt;/a&gt;Hexo&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;什么是Hexo？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简介：&lt;code&gt;Hexo&lt;/code&gt; 是一个快速、简洁且高效的</summary>
      
    
    
    
    <category term="Blog" scheme="https://www.bboyzj.cn/categories/Blog/"/>
    
    
    <category term="博客搭建" scheme="https://www.bboyzj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习14：在Swift里如何处理算术结果溢出</title>
    <link href="https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A014%EF%BC%9A%E5%9C%A8Swift%E9%87%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%AE%97%E6%9C%AF%E7%BB%93%E6%9E%9C%E6%BA%A2%E5%87%BA/"/>
    <id>https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A014%EF%BC%9A%E5%9C%A8Swift%E9%87%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%AE%97%E6%9C%AF%E7%BB%93%E6%9E%9C%E6%BA%A2%E5%87%BA/</id>
    <published>2023-02-22T17:31:22.000Z</published>
    <updated>2023-03-01T17:30:15.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="溢出运算符"><a href="#溢出运算符" class="headerlink" title="溢出运算符"></a>溢出运算符</h1><ul><li><p>在默认情况下，当向一个整数赋超出它容量的值时，<code>swift</code> 会报错而不是生成一个无效的数，给我们操作过大或过小的数时提供了额外的安全性</p></li><li><p>同时提供三个算术溢出运算符来让系统支持整数溢出运算</p><ul><li>溢出加法 <code>&amp;+</code></li><li>溢出减法 <code>&amp;-</code></li><li>溢出乘法 <code>&amp;*</code></li></ul></li></ul><h1 id="值溢出"><a href="#值溢出" class="headerlink" title="值溢出"></a>值溢出</h1><ul><li>数值可以出现向上溢出或向下溢出</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020128841.png"                                     ></p><ul><li><p>溢出也会发生在有符号整型数值上</p></li><li><p>对于无符号与有符号整型数值来说，当出现溢出时，它们会从数值所能容纳的最大数变成最小的数，同样的，当发生下溢时，它们会从所能容纳的最小数变成最大的数</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020128708.png"                                     ></p><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><ul><li>上溢出</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020128353.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020128449.png"                                     ></p><ul><li>下溢出</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020129637.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020129471.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;溢出运算符&quot;&gt;&lt;a href=&quot;#溢出运算符&quot; class=&quot;headerlink&quot; title=&quot;溢出运算符&quot;&gt;&lt;/a&gt;溢出运算符&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在默认情况下，当向一个整数赋超出它容量的值时，&lt;code&gt;swift&lt;/code&gt; 会报错而不是生</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习13：赋值和算术运算符</title>
    <link href="https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A013%EF%BC%9A%E8%B5%8B%E5%80%BC%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://www.bboyzj.cn/2023/02/23/Swift%E5%AD%A6%E4%B9%A013%EF%BC%9A%E8%B5%8B%E5%80%BC%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2023-02-22T17:30:48.000Z</published>
    <updated>2023-03-01T17:25:29.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li><p>一元运算符对一个目标进行操作。一元前缀运算符（如!b），一元后缀运算符（b!）</p></li><li><p>二元运算符对两个目标进行操作（a+b）同时因为它们出现在两个目标之间，所以是中缀</p></li><li><p>三元运算符操作三个目标，<code>swift</code> 语言也仅有一个 <code>三元运算符</code>，三元条件运算符（a?b:c）</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020122710.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020122158.png"                                     ></p><h1 id="swift-运算符的改进"><a href="#swift-运算符的改进" class="headerlink" title="swift 运算符的改进"></a>swift 运算符的改进</h1><ul><li><p>swift在支持 <code>c</code> 中的大多数标准运算符的同时也增加了一些排除常见代码错误的能力</p></li><li><p>赋值符号 <code>=</code> 不会返回值，以防止它被无用于等于符号 <code>==</code> </p></li><li><p>算术符号 <code>+、-、*、/、%</code> 以及其他可以监测并阻止值溢出，以避免你在操作比存储类型允许的范围更大或更小的数字时得到各种奇怪的结果</p></li></ul><h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><ul><li><p>赋值运算符将一个值赋值给另外一个值</p></li><li><p>如果赋值符号右侧是拥有多个值的元组，它的元素将会一次性地拆分成常量或者变量</p></li><li><p>Swift 的赋值符号自身不会返回值</p></li></ul><h1 id="算术运算符-标准运算符"><a href="#算术运算符-标准运算符" class="headerlink" title="算术运算符-标准运算符"></a>算术运算符-标准运算符</h1><ul><li><p>标准算术运算符 <code>+ - * /</code></p></li><li><p>算术运算符同时也支持 <code>String</code> 的拼接</p></li><li><p><code>swift</code> 算术运算符默认不允许值溢出</p></li></ul><h1 id="算术运算符-余数运算符"><a href="#算术运算符-余数运算符" class="headerlink" title="算术运算符 - 余数运算符"></a>算术运算符 - 余数运算符</h1><ul><li><p>余数运算符 <code>a%b</code> 可以求出多少个 <code>b</code> 的倍数能够刚好放进 <code>a</code> 中并且返回剩下的值（就是我们所谓的余数）</p></li><li><p>当 <code>a</code> 是负数时也适用相同的方法来进行计算</p></li><li><p>当 <code>b</code> 为负数时它的正负号被忽略掉。这意味着 <code>a%b</code> 与 <code>a%-b</code> 能够获得相同的答案</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020123693.png"                                     ></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let c = 9 % 4</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">let d = 9 % -4</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">let e = -9 % 4</span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020124939.png"                                     ></p><h1 id="算术运算符-一元"><a href="#算术运算符-一元" class="headerlink" title="算术运算符 - 一元"></a>算术运算符 - 一元</h1><ul><li><p>数字值的正负号可以用前缀 <code>-</code> 来切换，我们称之为一元减号运算符</p></li><li><p>一元减号运算符 <code>-</code> 直接在要进行操作的值前边放置，不加任何空格</p></li><li><p>一元加号运算符 <code>+</code> 直接返回它操作的值，不会对其进行任何的修改</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一元运算符对一个目标进行操作。一元前缀运算符（如!b），一元后缀运算符（b!）&lt;/p&gt;
&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习12：获取子串和字符串比较</title>
    <link href="https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A012%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AD%90%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/"/>
    <id>https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A012%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AD%90%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/</id>
    <published>2023-02-21T18:59:39.000Z</published>
    <updated>2023-03-01T17:25:21.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h1><ul><li><p>使用下标或者类似 <code>prefix(_:)</code> 的方法得到的子字符串是 <code>Substring</code> 类型</p></li><li><p><code>Substring</code> 拥有 <code>String</code> 的大部分方法</p></li><li><p><code>Substring</code> 可以转成 <code>String</code> 类型</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;hello,world&quot;</span><br><span class="line">let index = str.firstIndex(of: &quot;,&quot;) ?? str.endIndex</span><br><span class="line">let begin = str[..&lt;index]</span><br><span class="line">let new = String(begin)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020120015.png"                                     ></p><ul><li><p>子字符串重用一部分原字符串的内存</p></li><li><p>修改字符串或子字符串之前都不需要花费拷贝内存的代价</p></li><li><p><code>String</code> 和 <code>Substring</code> 都遵循 <code>StringProtocol</code> 协议，也就是说它基本上都能很方便的兼容所有接受 <code>StringProtocol</code> 值的字符串操作函数</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020121376.png"                                     ></p><h1 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h1><ul><li><p>字符串和字符相等性 <code>==</code> 和 <code>!=</code></p></li><li><p>前缀相等性 <code>hasPrefis(_:)</code></p></li><li><p>后缀相等性 <code>hasSubffix(_:)</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &quot;1&quot;</span><br><span class="line">var str2 = &quot;2&quot;</span><br><span class="line">print(str1 == str2)</span><br><span class="line">print(str1.hasPrefix(&quot;1&quot;))</span><br><span class="line">print(str2.hasSuffix(&quot;2&quot;))</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020121878.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;子字符串&quot;&gt;&lt;a href=&quot;#子字符串&quot; class=&quot;headerlink&quot; title=&quot;子字符串&quot;&gt;&lt;/a&gt;子字符串&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用下标或者类似 &lt;code&gt;prefix(_:)&lt;/code&gt; 的方法得到的子字符串是 &lt;code&gt;Su</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习11：索引访问和修改字符串</title>
    <link href="https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A011%EF%BC%9A%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A011%EF%BC%9A%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2023-02-21T18:59:05.000Z</published>
    <updated>2023-03-01T17:18:31.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h1><ul><li><p>每一个 <code>String</code> 值都有相关的索引类型，<code>String.Index</code>，他相当于每个 <code>Character</code> 在字符串中的位置</p></li><li><p><code>startIndex</code> 属性来访问 <code>String</code> 中第一个 <code>Character</code> 的位置。<code>endIndex</code> 属性就是 <code>String</code> 中最后一个字符串的位置</p></li><li><p><code>endIndex</code> 属性并不是字符串下标脚本的合法实际参数</p></li><li><p>如果 <code>String</code> 为空，则 <code>startIndex</code> 与 <code>endIndex</code> 相等</p></li><li><p>使用 <code>index(before:)</code> 和 <code>index(after:)</code> 方法来访问给定索引的前后</p></li><li><p>要访问给定索引更远的索引，你可以使用 <code>index(_:offetBy:)</code></p></li><li><p>使用 <code>indices</code> 属性来访问字符串中每个字符的索引</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var greeting = &quot;Hello, playground&quot;</span><br><span class="line">greeting[greeting.startIndex]</span><br><span class="line">greeting[greeting.index(before: greeting.endIndex)]</span><br><span class="line">greeting[greeting.index(after: greeting.startIndex)]</span><br><span class="line">let index = greeting.index(greeting.startIndex, offsetBy: 7)</span><br><span class="line">greeting[index]</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020116804.png"                                     ></p><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><ul><li><p>插入字符，使用 <code>insert(_:at:)</code> 方法</p></li><li><p>插入到另一个字符串的内容到特定的索引，使用 <code>insert(contentsOf:at:)</code> 方法</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello&quot;</span><br><span class="line">str.insert(&quot;!&quot;, at: str.endIndex)</span><br><span class="line">str.insert(contentsOf: &quot; world&quot;, at: str.firstIndex(of: &quot;!&quot;)!)</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020117964.png"                                     ></p><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><ul><li>移除字符，使用 <code>remove(at:)</code> 方法</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello&quot;</span><br><span class="line">str.remove(at: str.index(before: str.endIndex))</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020117857.png"                                     ></p><ul><li>移除一小段特定范围的字符串，使用 <code>removeSubrange(_:)</code> 方法</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello&quot;</span><br><span class="line">let range = str.index(str.endIndex, offsetBy: -str.count)..&lt;str.endIndex</span><br><span class="line">str.removeSubrange(range)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020117645.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字符串索引&quot;&gt;&lt;a href=&quot;#字符串索引&quot; class=&quot;headerlink&quot; title=&quot;字符串索引&quot;&gt;&lt;/a&gt;字符串索引&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;每一个 &lt;code&gt;String&lt;/code&gt; 值都有相关的索引类型，&lt;code&gt;String.I</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习10：字符串常见操作</title>
    <link href="https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A010%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
    <id>https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A010%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</id>
    <published>2023-02-21T18:58:45.000Z</published>
    <updated>2023-03-01T17:15:30.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串的可变性"><a href="#字符串的可变性" class="headerlink" title="字符串的可变性"></a>字符串的可变性</h1><ul><li><code>var</code> 指定的可以修改</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020114183.png"                                     ></p><ul><li><code>let</code> 指定的不可修改</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020106762.png"                                     ></p><ul><li>对比 Object-C (NSString 和 NSMutableString)</li></ul><h1 id="字符串是-值类型"><a href="#字符串是-值类型" class="headerlink" title="字符串是 值类型"></a>字符串是 值类型</h1><ul><li><p><code>String</code> 值在传递给方法或函数的时候会被复制过去</p></li><li><p>赋值给常量或变量的时候也是一样</p></li><li><p>Swift 编译器优化了字符串使用的资源，实际上拷贝只会在确实需要的时候才进行</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &quot;hello&quot;</span><br><span class="line">var str2 = str1</span><br><span class="line">print(str1 == str2)</span><br><span class="line">str1.append(&quot;,world&quot;)</span><br><span class="line">print(str1)</span><br><span class="line">print(str2)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020109392.png"                                     ></p><h1 id="操作字符"><a href="#操作字符" class="headerlink" title="操作字符"></a>操作字符</h1><ul><li><p><code>for in</code> 循环遍历 <code>String</code> 中的每一个独立的 <code>Character</code></p></li><li><p><code>Character</code> 类型</p></li><li><p><code>String</code> 值可以通过传入 <code>Character</code> 数组来构造</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello&quot;</span><br><span class="line">for c in str&#123;</span><br><span class="line">    print(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020109024.png"                                     ></p><h1 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h1><ul><li><p>使用加运算符 <code>+</code> 创建新字符串</p></li><li><p>使用 <code>+</code> 赋值符号 <code>+=</code> 在已经存在的 <code>String</code> 值末尾追加一个 <code>String</code> 值</p></li><li><p>使用 <code>String</code> 类型的 <code>append()</code> 方法来可以给一个 <code>String</code> 变量的末尾追加 <code>Character</code> 值</p></li></ul><h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><ul><li><p>字符串插值是一种从混合常量、变量、字面量和表达式的字符串字面量构造新 <code>String</code> 值的方法</p></li><li><p>每一个你插入到字符串字面量的元素都要被一对圆括号包裹，然后使用反斜杠前缀 <code>\()</code></p></li><li><p>类似于 <code>NSString</code> 的 <code>stringWithFormat</code> 方法，但是更加简便，更强大</p></li><li><p>可以在扩展字符串分割符中创建一个包含在其他情况下会被当做字符串插值的字符</p></li><li><p>要在使用扩展分隔符的字符串中使用字符串插值，在反斜杠后使用匹配首尾井号数量的井号</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;6 * 7 = \(6 * 7)&quot;</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020110881.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020115034.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字符串的可变性&quot;&gt;&lt;a href=&quot;#字符串的可变性&quot; class=&quot;headerlink&quot; title=&quot;字符串的可变性&quot;&gt;&lt;/a&gt;字符串的可变性&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var&lt;/code&gt; 指定的可以修改&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img </summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习09：字符串创建和使用</title>
    <link href="https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A009%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A009%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/</id>
    <published>2023-02-21T18:58:24.000Z</published>
    <updated>2023-03-01T17:06:09.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初始化空串"><a href="#初始化空串" class="headerlink" title="初始化空串"></a>初始化空串</h1><ul><li><p>字面量</p></li><li><p>初始化器语法</p></li><li><p><code>isEmpty</code> 检查是否为空串</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var emptyString = &quot;&quot;</span><br><span class="line">var anotherEmptyString = String()</span><br><span class="line"></span><br><span class="line">if emptyString.isEmpty &#123;</span><br><span class="line">    print(&quot;Nothing to see here&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020103809.png"                                     ></p><h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><ul><li><p>字符串字面量是被双引号 <code>“”</code> 包裹的固定顺序文本字符</p></li><li><p><code>Swift</code> 会为 <code>str</code> 常量推断类型为 <code>String</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;some string&quot;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020104645.png"                                     ></p><h1 id="多行字面量"><a href="#多行字面量" class="headerlink" title="多行字面量"></a>多行字面量</h1><ul><li><p>多行字符串字面量是用三个双引号引起来的一系列字符</p></li><li><p>多行字符串字面量把所有行包括在引号内，开始和结束默认不会有换行符</p></li><li><p>如果为了书写美观而不换行在后面加 \</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let someStr = &quot;&quot;&quot;</span><br><span class="line">1\</span><br><span class="line">2\</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">print(someStr)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020104457.png"                                     ></p><ul><li><p>要让多行字符串字面量起始或结束于换行，就在第一或最后一行写一个空行</p></li><li><p>多行字符串可以 <code>缩进</code> 以匹配周围的代码。双引号（”””）前的空格会告诉Swift其他行前应该有多少空白是需要忽略的</p></li><li><p>如果你在某行的空格超过了结束的双引号（”””），那么这些空格会被包含</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    let someStr = &quot;&quot;&quot;</span><br><span class="line">    1</span><br><span class="line">    2</span><br><span class="line">        3</span><br><span class="line">    4</span><br><span class="line">    5</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">print(someStr)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020104509.png"                                     ></p><h1 id="字符串里的特殊字符"><a href="#字符串里的特殊字符" class="headerlink" title="字符串里的特殊字符"></a>字符串里的特殊字符</h1><ul><li><p>转义特殊字符 \o（空字符）,\（反斜杠），\t（水平制表符），\n（换行符），\r（回车符），\”（双引号）以及 &#39;（单引号）</p></li><li><p>任意的 <code>Unicode</code> 标量，写作 <code>\u&#123;&#125;n</code>，里边的 <code>n</code> 是一个 <code>1-8</code> 位的16进制数字，其值是合法 <code>Unicode</code> 值</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;\u&#123;24&#125;&quot;</span><br></pre></td></tr></table></figure></div><ul><li>可以在多行字符串字面量中包含双引号（”）而不需要转义。要在多行字符串中包含文本 “”””””，转义至少一个双引号</li></ul><h1 id="扩展字符串分隔符-Raw-String"><a href="#扩展字符串分隔符-Raw-String" class="headerlink" title="扩展字符串分隔符(Raw String)"></a>扩展字符串分隔符(Raw String)</h1><ul><li><p>在字符串字面量中放置扩展分隔符来使 <code>包含特殊字符的字符串</code> 不让他们真的生效</p></li><li><p>把字符串放在双引号 (“) 内并由 (#) 包裹</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = #&quot;1\n2\n3\n&quot;#</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020105441.png"                                     ></p><ul><li>如果字符串里面有 <code>&quot;#</code> 则首尾需要两个 <code>##</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = ##&quot;1\&quot;#n2\#n3\#n&quot;##</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020105787.png"                                     ></p><ul><li>如果你需要字符串中某个特殊符号的效果，使用匹配你包裹的 <code>#</code> 号数量的 <code>#</code> 号，并在前面写转义符号 <code>\</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = #&quot;1\#n2\#n3\#n&quot;#</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020105373.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初始化空串&quot;&gt;&lt;a href=&quot;#初始化空串&quot; class=&quot;headerlink&quot; title=&quot;初始化空串&quot;&gt;&lt;/a&gt;初始化空串&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;字面量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初始化器语法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;cod</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习08：Optional的使用Optional实现原理探索</title>
    <link href="https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A008%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8Optional%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/"/>
    <id>https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A008%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8Optional%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/</id>
    <published>2023-02-21T18:56:00.000Z</published>
    <updated>2023-03-01T17:03:15.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Optional-实现探究"><a href="#Optional-实现探究" class="headerlink" title="Optional-实现探究"></a>Optional-实现探究</h1><ul><li><p><code>Optional</code> 其实是一个标准库里的一个  <code>public 的 enum</code> 类型，而且是 <code>泛型</code> 的，泛型的类型是 <code>Wrapped</code></p></li><li><p>用标准库实现语言特性的典型</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020100711.png"                                     ></p><ul><li><p>Optional.none 就是 <code>nil</code></p></li><li><p>Optional.some 则包装了实际的值</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str:Optional&lt;String&gt; = &quot;abc&quot;</span><br><span class="line">if let actualStr = str &#123;</span><br><span class="line">    let count = actualStr.count</span><br><span class="line">    print(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020101182.png"                                     ></p><h1 id="Optional-解包实现"><a href="#Optional-解包实现" class="headerlink" title="Optional-解包实现"></a>Optional-解包实现</h1><ul><li>泛型属性 <code>unsafelyUnwrapped</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020102043.png"                                     ></p><ul><li>理论上我我们可以直接调用 <code>unsafelyUnwrapped</code> 获取可选项的值</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str:String? = &quot;abc&quot;</span><br><span class="line">let count = str.unsafelyUnwrapped.count</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020102203.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Optional-实现探究&quot;&gt;&lt;a href=&quot;#Optional-实现探究&quot; class=&quot;headerlink&quot; title=&quot;Optional-实现探究&quot;&gt;&lt;/a&gt;Optional-实现探究&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Optional&lt;/c</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习07：Optional的使用</title>
    <link href="https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A007%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A007%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-02-21T18:55:20.000Z</published>
    <updated>2023-03-01T16:54:26.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么需要-Optional？"><a href="#为什么需要-Optional？" class="headerlink" title="为什么需要 Optional？"></a>为什么需要 Optional？</h1><ul><li>Object-C 里的 <code>nil</code> 是无类型的指针</li><li>Object-C 里面的数组、字典、集合等不允许放入 <code>nil</code></li><li>Object-C 所有 <code>对象的变量</code> 都可以为 <code>nil</code></li><li>Object-C 只能用在对象上，而在其他地方又用其他特殊值（例如NSNotFound）表示值的缺失</li></ul><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><ul><li><p>通过在 <code>变量类型</code> 后面加 <code>?</code> 表示</p><ul><li>这里有一个值，它等于 x</li></ul><p>  或者</p><ul><li>这里根本没有值</li></ul></li><li><p>你可以通过给可选变量赋值一个 <code>nil</code> 来将之设置为没有值</p><ul><li><p>在 Object-C 中 <code>nil</code> 是一个指向不存在对象的指针</p></li><li><p>在 Swift 中，<code>nil</code> 不是指针，它是 <code>值缺失的一种特殊类型</code>，任何类型的可选项都可以设置成 <code>nil</code> 而不仅仅是对象</p><ul><li>只有可选项才能设置为 nil</li></ul></li></ul></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str: String = nil</span><br><span class="line">var str1: String? = nil  </span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020049740.png"                                     ></p><h1 id="Optional-If-语句以及强制解包"><a href="#Optional-If-语句以及强制解包" class="headerlink" title="Optional-If 语句以及强制解包"></a>Optional-If 语句以及强制解包</h1><ul><li>可选项是没法直接使用的</li><li>需要用 <code>!</code> 号强制解包后才能使用（意思是我知道这个可选项里面有值，使用吧）</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str: String? = &quot;abc&quot;</span><br><span class="line">let count = str.count</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020050383.png"                                     ></p><p>需要改成如下代码，才能正确执行</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str: String? = &quot;abc&quot;</span><br><span class="line">let count = str!.count</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020050208.png"                                     ></p><p>或</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str: String? = &quot;abc&quot;</span><br><span class="line">if str != nil &#123;</span><br><span class="line">    let count = str!.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020051471.png"                                     ></p><h1 id="Optional-绑定"><a href="#Optional-绑定" class="headerlink" title="Optional-绑定"></a>Optional-绑定</h1><ul><li><p>可以使用 <code>可选绑定</code> 来判断可选项是否包含值，如果包含就把赋值给一个临时的 <code>常量或变量</code></p></li><li><p>可选绑定可以与 <code>if</code> 和 <code>while</code> 的语句使用来检查可选项内部的值，并赋值给一个变量或常量</p></li><li><p>同一个 <code>if</code> 语句中包含多可选项绑定，用逗号分割即可。如果任一可选绑定结果是 <code>nil</code> 或者 <code>布尔值</code> 为 <code>false</code> ，那么整个 <code>if</code> 判断会被看做 <code>false</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str:String? = &quot;abc&quot;</span><br><span class="line">if let actualStr = str &#123;</span><br><span class="line">    let count = actualStr.count</span><br><span class="line">    print(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020052194.png"                                     ></p><h1 id="Optional-隐士解包"><a href="#Optional-隐士解包" class="headerlink" title="Optional - 隐士解包"></a>Optional - 隐士解包</h1><ul><li><p>有些可选项一旦被设定值之后，就会一直拥有值，在这种情况下，就可以去掉检查的需求，也不必每次访问的时候都进行解包</p></li><li><p>通过有声明的类型后边添加一个叹号（String!）而非问号（String?）来书写隐士解包可选项</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str:String! = &quot;abc&quot;</span><br><span class="line">let count = str.count</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020052565.png"                                     ></p><ul><li>隐士解包可选项主要被用在Swift <code>类</code> 的初始化过程中</li></ul><h1 id="Optional-可选链"><a href="#Optional-可选链" class="headerlink" title="Optional-可选链"></a>Optional-可选链</h1><ul><li><p>可选项后面加问号</p></li><li><p>如果可选项不为nil，返回一个可选项结果，否则为nil</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str:String? = &quot;abc&quot;</span><br><span class="line">let count = str?.count</span><br><span class="line">let lastIndex = count - 1</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020054934.png"                                     ></p><p>将上面的代码改为：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var str:String? = &quot;abc&quot;</span><br><span class="line">let count = str?.count</span><br><span class="line">//let lastIndex = count - 1</span><br><span class="line">if count != nil &#123;</span><br><span class="line">    let lastIndex = count! - 1</span><br><span class="line">    print(lastIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020054879.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么需要-Optional？&quot;&gt;&lt;a href=&quot;#为什么需要-Optional？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要 Optional？&quot;&gt;&lt;/a&gt;为什么需要 Optional？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Object-C 里的 </summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习06：Tuple元组</title>
    <link href="https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A006%EF%BC%9ATuple%E5%85%83%E7%BB%84/"/>
    <id>https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A006%EF%BC%9ATuple%E5%85%83%E7%BB%84/</id>
    <published>2023-02-21T18:54:43.000Z</published>
    <updated>2023-03-01T16:48:14.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h1><ul><li><code>元组</code> 把多个值合并成单一的复合型的值</li><li><code>元组</code> 内的值可以是任何类型，而且可以不必是统一类型</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let error = (1,&quot;没有权限&quot;)</span><br><span class="line">print(error.0)</span><br><span class="line">print(error.1)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020044769.png"                                     ></p><h1 id="元素命名"><a href="#元素命名" class="headerlink" title="元素命名"></a>元素命名</h1><ul><li>元组中的每一个元素可以指定对应的元素名称</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let error = (errorCode:1,errorMessage:&quot;没有权限&quot;)</span><br><span class="line">print(error.errorCode)</span><br><span class="line">print(error.errorMessage)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020044807.png"                                     ></p><ul><li>如果没有指定名称的元素也可以使用下标的方式来引用</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let error = (1,&quot;没有权限&quot;)</span><br><span class="line">print(error.0)</span><br><span class="line">print(error.1)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020045931.png"                                     ></p><h1 id="Tuple-修改"><a href="#Tuple-修改" class="headerlink" title="Tuple 修改"></a>Tuple 修改</h1><ul><li>用 <code>var</code> 定义的元组就是可变元组，<code>let</code> 定义的元组就是不可变元组</li><li>不管是可变还是不可变元组，元组在创建后就不能增加和删除元素</li><li>可以对可变元组的元素进行修改，但是不能改变其类型</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var error = (errorCode:1,errorMessage:&quot;没有权限&quot;)</span><br><span class="line">error.errorCode = 2</span><br><span class="line">error.errorMessage = &quot;2&quot;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020045043.png"                                     ></p><ul><li><code>any</code> 类型可以改为任何类型</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var error: (Any,String) = (1,&quot;没有权限&quot;)</span><br><span class="line">error.0 = 2</span><br><span class="line">print(error)</span><br><span class="line">error.0 = &quot;abc&quot;</span><br><span class="line">print(error)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020046096.png"                                     ></p><h1 id="Tuple-分解"><a href="#Tuple-分解" class="headerlink" title="Tuple 分解"></a>Tuple 分解</h1><ul><li>将一个元组的内容分解成单独的常量或变量</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let error = (1,&quot;没有权限&quot;)</span><br><span class="line">let (errorCode,errorMessage) = error</span><br><span class="line">print(errorCode)</span><br><span class="line">print(errorMessage)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020047401.png"                                     ></p><ul><li>如果只需要使用其中的一部分数据，不需要的数据可以用下划线 <code>_</code> 代替</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let error = (1,&quot;没有权限&quot;)</span><br><span class="line">let (_,errorMessage) = error</span><br><span class="line">print(errorMessage)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020047151.png"                                     ></p><h1 id="作为函数返回值"><a href="#作为函数返回值" class="headerlink" title="作为函数返回值"></a>作为函数返回值</h1><ul><li>使用 <code>Tuple</code> 为函数返回多个值</li><li>返回值的 <code>Tuple</code> 可以再函数的返回类型部分被命名</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func writeToFile(content:String) -&gt; (errorCode:Int,errorMessage:String) &#123;</span><br><span class="line">    return (1,&quot;没有权限&quot;)</span><br><span class="line">&#125;</span><br><span class="line">let error = writeToFile(content: &quot;&quot;)</span><br><span class="line">print(error)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020048486.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Tuple&quot;&gt;&lt;a href=&quot;#Tuple&quot; class=&quot;headerlink&quot; title=&quot;Tuple&quot;&gt;&lt;/a&gt;Tuple&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;元组&lt;/code&gt; 把多个值合并成单一的复合型的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;元组&lt;/c</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习05：数值类型</title>
    <link href="https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A005%EF%BC%9A%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    <id>https://www.bboyzj.cn/2023/02/22/Swift%E5%AD%A6%E4%B9%A005%EF%BC%9A%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/</id>
    <published>2023-02-21T18:53:56.000Z</published>
    <updated>2023-03-01T16:43:16.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h1><ul><li><p>Swift 提供了 <code>8，16，32，64</code> 位编码的有符号和无符号整数</p></li><li><p>命名方式：例如 8位无符号整数的类型是 UInt8，32位有符号整数的类型是 Int32</p></li><li><p>通过 <code>min</code> 和 <code>max</code> 属性来访问每个整数类型的最小值和最大值</p></li><li><p>Swift 提供了一个额外的整数类型：Int，它拥有与当前平台的原生字相同的长度</p></li><li><p>同时 <code>Swift</code> 也提供 <code>UInt</code> 类型，来表示平台长度相关的无符号整型</p></li><li><p>建议在用到证书的地方都使用 Int</p></li></ul><h1 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h1><ul><li>Double：64位浮点数，至少有 15 位数字的精度</li><li>Float：32位浮点数，至少有 6 为数字的精度</li><li>在两种类型都可以的情况下，推荐使用 Double 类型</li></ul><h1 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020041147.png"                                     ></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = 8</span><br><span class="line">let b: UInt8 = 240</span><br><span class="line">print(&quot;UInt8 min \(UInt8.min),UInt8 max \(UInt8.max)&quot;)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020042980.png"                                     ></p><h1 id="Bool"><a href="#Bool" class="headerlink" title="Bool"></a>Bool</h1><ul><li>Bool：true 和 false</li><li>Swift 的类型安全机制会阻止你用一个非布尔量的值替换掉 Bool</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let i = 1</span><br><span class="line">if i &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020042119.png"                                     ></p><p>我们修改一下</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020042345.png"                                     ></p><h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><ul><li>类型别名是一个为 <code>已存在类型</code> 定义的一个 <code>可选择的名字</code></li><li>你可以用关键字 <code>typealias</code> 定义一个类型的别名</li><li>当你想通过在一个在上下文中看起来更合适可具有表达行的名字来引用一个已存在的类型时，这时别名就非常有用了</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 音频采样率</span><br><span class="line">typealias AudioSample = UInt8</span><br><span class="line">let sample:AudioSample = 32</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020043905.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;整数&quot;&gt;&lt;a href=&quot;#整数&quot; class=&quot;headerlink&quot; title=&quot;整数&quot;&gt;&lt;/a&gt;整数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Swift 提供了 &lt;code&gt;8，16，32，64&lt;/code&gt; 位编码的有符号和无符号整数&lt;/p&gt;
&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-学习篇" scheme="https://www.bboyzj.cn/tags/Swift-%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    
  </entry>
  
</feed>
