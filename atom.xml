<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张建的博客</title>
  <icon>https://www.gravatar.com/avatar/134cc2bfaf649e446f661778f4112fca</icon>
  <subtitle>成功的道路上只有荆棘，没有坦途</subtitle>
  <link href="https://www.bboyzj.cn/atom.xml" rel="self"/>
  
  <link href="https://www.bboyzj.cn/"/>
  <updated>2023-03-09T21:47:29.431Z</updated>
  <id>https://www.bboyzj.cn/</id>
  
  <author>
    <name>小J</name>
    <email>13718004742@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OC学习20：UIViewController生命周期</title>
    <link href="https://www.bboyzj.cn/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A020%EF%BC%9AUIViewController%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://www.bboyzj.cn/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A020%EF%BC%9AUIViewController%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2023-03-09T21:15:32.000Z</published>
    <updated>2023-03-09T21:47:29.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UIViewController生命周期相关方法"><a href="#UIViewController生命周期相关方法" class="headerlink" title="UIViewController生命周期相关方法"></a>UIViewController生命周期相关方法</h1><ul><li><ul><li>(instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil;</li></ul></li></ul><p>非storyBoard(xib或非xib)都走这个方法</p><ul><li><ul><li>(instancetype)initWithCoder:(NSCoder *)aDecoder;</li></ul></li></ul><p>如果连接了串联图storyBoard 走这个方法</p><ul><li><ul><li>(void)awakeFromNib;</li></ul></li></ul><p>xib 加载 完成</p><ul><li>+(void)load</li></ul><p>load 在代码加载的时候，对象还没有被初始化的时候就已经调⽤了，可以⽤<br>来做⼀些全局的swizzle,只调⽤⼀次</p><ul><li>+(void)initialize</li></ul><p>类的初始化方法</p><ul><li>-(instancetype)init</li></ul><p>对象初始化方法</p><ul><li>-(void)loadView</li></ul><p>加载视图:当访问UIViewController的view属性时，view如果此时是nil，那么VC会自动调用loadView方法来初始化一个UIView并赋值给view属性。此方法用在初始化关键view，需要注意的是，在view初始化之前，不能先调用view的getter方法，否则将导致死循环（除非先调用了[super loadView];）如果没有重载loadView方法，则UIViewController会从nib或StoryBoard中查找默认的loadView，默认的loadView会返回一个空白的UIView对象。</p><ul><li>-(void)viewDidLoad</li></ul><p>视图加载完成</p><ul><li>-(void)viewWillAppear:(BOOL)animated</li></ul><p>将要展示:在view即将添加到视图层级中（显示给用户）且任意显示动画切换之前调用,此时self.view.superview为nil.这个方法中完成任何与试图显示相关的任务，例如改变视图方向、状态栏方向、视图显示样式等。</p><ul><li>-(void)viewWillLayoutSubviews</li></ul><p>将要布局子视图,self.view.superview为_UIParallaxDimmingView</p><ul><li>-(void)viewDidLayoutSubviews</li></ul><p>已经布局子视图</p><ul><li>-(void)viewDidAppear:(BOOL)animated</li></ul><p>已经展示:在view被添加到视图层级中，显示动画切换之后调用（这时view已经添加到supperView中）。在这个方法中执行视图显示相关附件任务，如果重载了这个方法，必须在方法中调用[supper viewDidAppear];,此时self.view.superview为UIViewControllerWrapperView。</p><ul><li>-(void)viewWillDisappear:(BOOL)animated</li></ul><p>将要消失:view即将从supperView中移除，移除动画切换之后调用，此时已调用removeFromSuperview。此时self.view.superview还是superview为UIViewControllerWrapperView.</p><ul><li>-(void)viewDidDisappear:(BOOL)animated</li></ul><p>已经消失:view从superView中移除，移除动画切换之后调用，此时已调用removeFromSuperview。此时self.view.superview还是superview为nil.</p><ul><li>-(void)dideMemoryWarning</li></ul><p>内存警告</p><ul><li>-(void)dealloc</li></ul><p>销毁释放</p><h1 id="声明周期"><a href="#声明周期" class="headerlink" title="声明周期"></a>声明周期</h1><blockquote><p>-[ViewController initWithCoder:]<br>-[ViewController awakeFromNib]<br>-[ViewController loadView]<br>-[ViewController viewDidLoad]<br>-[ViewController viewWillAppear:]<br>-[ViewController viewWillLayoutSubviews]<br>-[ViewController viewDidLayoutSubviews]<br>-[ViewController viewDidAppear:]<br>-[ViewController viewWillDisappear:]<br>-[ViewController viewDidDisappear:]<br>-[ViewController dealloc]<br>-[ViewController didReceiveMemoryWarning]</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UIViewController生命周期相关方法&quot;&gt;&lt;a href=&quot;#UIViewController生命周期相关方法&quot; class=&quot;headerlink&quot; title=&quot;UIViewController生命周期相关方法&quot;&gt;&lt;/a&gt;UIViewControll</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习19：UIView的生命周期</title>
    <link href="https://www.bboyzj.cn/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A019%EF%BC%9AUIView%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://www.bboyzj.cn/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A019%EF%BC%9AUIView%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2023-03-09T21:03:36.000Z</published>
    <updated>2023-03-09T21:38:16.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UIView生命周期相关函数"><a href="#UIView生命周期相关函数" class="headerlink" title="UIView生命周期相关函数"></a>UIView生命周期相关函数</h1><ul><li><ul><li>(instancetype)initWithFrame:(CGRect)frame;</li></ul></li></ul><p>构造方法,初始化时调用,不会调用init方法</p><ul><li>-(instancetype)init</li></ul><p>构造方法,内部会调用initWithFrame方法</p><ul><li><ul><li>(instancetype)initWithCoder:(NSCoder *)aDecoder;</li></ul></li></ul><p>xib归档初始化视图后调用,如果xib中添加了子控件会在didAddSubview方法调用后调用</p><ul><li><ul><li>(void)awakeFromNib;</li></ul></li></ul><p>唤醒xib,可以布局子控件</p><ul><li>-(void)willMoveToSuperview:(UIView *)newSuperview</li></ul><p>父视图将要更改为指定的父视图,当前视图被添加到父视图时调用</p><ul><li>-(void)didMoveToSuperview</li></ul><p>父视图已更改时调用</p><ul><li>-(void)willMoveToWindow:(UIWindow *)newWindow</li></ul><p>其窗口对象将要更改时调用</p><ul><li>-(void)didMoveToWindow</li></ul><p>窗口对象已经更改时调用</p><ul><li>-(void)layoutSubviews</li></ul><p>布局子控件</p><ul><li>-(void)drawRect:(CGRect)rect</li></ul><p>绘制视图</p><ul><li>-(void)dealloc</li></ul><p>销毁</p><ul><li><ul><li>(void)didAddSubview:(UIView *)subview;</li></ul></li></ul><p>添加子控件时调用</p><ul><li><ul><li>(void)willRemoveSubview:(UIView *)subview;</li></ul></li></ul><p>将要移除子控件</p><h1 id="init方式创建视图-并添加到父视图中展示-不添加子控件-其生命周期调用顺序为"><a href="#init方式创建视图-并添加到父视图中展示-不添加子控件-其生命周期调用顺序为" class="headerlink" title="init方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为:"></a>init方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为:</h1><blockquote><p>[NoXibView initWithFrame:]<br>[NoXibView init]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView layoutSubviews]</p></blockquote><h1 id="initWithFrame方式创建视图-并添加到父视图中展示-不添加子控件-其生命周期调用顺序为"><a href="#initWithFrame方式创建视图-并添加到父视图中展示-不添加子控件-其生命周期调用顺序为" class="headerlink" title="initWithFrame方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为:"></a>initWithFrame方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为:</h1><blockquote><p>[NoXibView initWithFrame:]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView layoutSubviews]<br>[NoXibView drawRect:]</p></blockquote><h1 id="移除销毁是调用顺序"><a href="#移除销毁是调用顺序" class="headerlink" title="移除销毁是调用顺序:"></a>移除销毁是调用顺序:</h1><blockquote><p>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView removeFromSuperview]<br>[NoXibView dealloc]</p></blockquote><h1 id="添加子控件展示时调用顺序"><a href="#添加子控件展示时调用顺序" class="headerlink" title="添加子控件展示时调用顺序:"></a>添加子控件展示时调用顺序:</h1><blockquote><p>[NoXibView initWithFrame:]<br>[NoXibView didAddSubview:]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView layoutSubviews]<br>[NoXibView drawRect:]</p></blockquote><h1 id="添加子控件移除销毁时调用顺序"><a href="#添加子控件移除销毁时调用顺序" class="headerlink" title="添加子控件移除销毁时调用顺序:"></a>添加子控件移除销毁时调用顺序:</h1><blockquote><p>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView removeFromSuperview]<br>[NoXibView dealloc]<br>[NoXibView willRemoveSubview:]</p></blockquote><h1 id="xib创建初始化视图-xib中不添加子控件时调用顺序"><a href="#xib创建初始化视图-xib中不添加子控件时调用顺序" class="headerlink" title="xib创建初始化视图, xib中不添加子控件时调用顺序:"></a>xib创建初始化视图, xib中不添加子控件时调用顺序:</h1><blockquote><p>[XibView initWithCoder:]<br>[XibView awakeFromNib]<br>[XibView willMoveToSuperview:]<br>[XibView didMoveToSuperview]<br>[XibView willMoveToWindow:]<br>[XibView didMoveToWindow]<br>[XibView layoutSubviews]<br>[XibView layoutSubviews]<br>[XibView drawRect:]</p></blockquote><h1 id="xib创建初始化视图-xib中添加子控件时调用顺序"><a href="#xib创建初始化视图-xib中添加子控件时调用顺序" class="headerlink" title="xib创建初始化视图, xib中添加子控件时调用顺序:"></a>xib创建初始化视图, xib中添加子控件时调用顺序:</h1><blockquote><p>[XibView didAddSubview:]<br>[XibView initWithCoder:]<br>[XibView awakeFromNib]<br>[XibView willMoveToSuperview:]<br>[XibView didMoveToSuperview]<br>[XibView willMoveToWindow:]<br>[XibView didMoveToWindow]<br>[XibView layoutSubviews]<br>[XibView layoutSubviews]<br>[XibView drawRect:]</p></blockquote><h1 id="移除销毁时调用顺序-有子控件"><a href="#移除销毁时调用顺序-有子控件" class="headerlink" title="移除销毁时调用顺序,有子控件:"></a>移除销毁时调用顺序,有子控件:</h1><blockquote><p>[XibView willMoveToWindow:]<br>[XibView didMoveToWindow]<br>[XibView willMoveToSuperview:]<br>[XibView didMoveToSuperview]<br>[XibView removeFromSuperview]<br>[NoXibView dealloc]<br>[NoXibView willRemoveSubview:]</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UIView生命周期相关函数&quot;&gt;&lt;a href=&quot;#UIView生命周期相关函数&quot; class=&quot;headerlink&quot; title=&quot;UIView生命周期相关函数&quot;&gt;&lt;/a&gt;UIView生命周期相关函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;(instan</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC面试题：Block</title>
    <link href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ABlock/"/>
    <id>https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ABlock/</id>
    <published>2023-03-09T18:31:11.000Z</published>
    <updated>2023-03-09T21:52:35.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Block的本质"><a href="#Block的本质" class="headerlink" title="Block的本质"></a>Block的本质</h1><ul><li>block 的 <code>本质</code> 是 <code>对象、函数、结构</code>体，由于block函数没有名称，也被称为 <code>匿名函数</code></li></ul><h1 id="Block的分类？"><a href="#Block的分类？" class="headerlink" title="Block的分类？"></a>Block的分类？</h1><ul><li><p>分为 <code>全局Block(_NSConcreteGlobalBlock)、栈Block(_NSConcreteStackBlock)、堆Block(_NSConcreteMallocBlock)</code> 三种形式。</p></li><li><p>其中 <code>栈Block存储在栈(stack)区</code>，<code>堆Block存储在堆(heap)区</code>，<code>全局Block存储在已初始化数据(.data)区</code>。</p><ul><li>堆：动态分配内存，需要程序员自己申请，程序员自己管理</li><li>栈：自动分配内存，自动销毁，先入后出，栈上的内容存在自动销毁的情况</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Block的本质&quot;&gt;&lt;a href=&quot;#Block的本质&quot; class=&quot;headerlink&quot; title=&quot;Block的本质&quot;&gt;&lt;/a&gt;Block的本质&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;block 的 &lt;code&gt;本质&lt;/code&gt; 是 &lt;code&gt;对象、函数、结构</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-面试题" scheme="https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>OC面试题：Runtime</title>
    <link href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARuntime/"/>
    <id>https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARuntime/</id>
    <published>2023-03-09T18:30:47.000Z</published>
    <updated>2023-03-09T19:50:38.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="runtime如何通过selector找到对应的IMP地址？"><a href="#runtime如何通过selector找到对应的IMP地址？" class="headerlink" title="runtime如何通过selector找到对应的IMP地址？"></a>runtime如何通过selector找到对应的IMP地址？</h1><ul><li><p>class_getMethodImplementation(Class cls, SEL name);</p></li><li><p>method_getImplementation(Method m)</p></li></ul><h1 id="Runtime-如何实现-weak-属性"><a href="#Runtime-如何实现-weak-属性" class="headerlink" title="Runtime 如何实现 weak 属性?"></a>Runtime 如何实现 weak 属性?</h1><p><code>Runtime</code> 对 <code>注册的类</code>，会进行 <code>布局</code>，会将 <code>weak</code> 对象放入一个 <code>hash</code> 表中。 用 <code>weak</code> 指向的 <code>对象内存地址</code> 作为 <code>key</code>，当此对象的引用计数为0的时候会调用对象的 <code>dealloc</code> 方法， 假设 <code>weak</code> 指向的对象内存地址是a，那么就会以a为key，在这个 <code>weak</code> hash表中搜索，找到所有以a为key的 <code>weak</code> 对象，从而设置为 <code>nil</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;runtime如何通过selector找到对应的IMP地址？&quot;&gt;&lt;a href=&quot;#runtime如何通过selector找到对应的IMP地址？&quot; class=&quot;headerlink&quot; title=&quot;runtime如何通过selector找到对应的IMP地址？&quot;&gt;</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-面试题" scheme="https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>OC面试题：Runloop</title>
    <link href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARunloop/"/>
    <id>https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARunloop/</id>
    <published>2023-03-09T18:30:37.000Z</published>
    <updated>2023-03-09T19:51:04.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PerformSelector和runloop的关系？"><a href="#PerformSelector和runloop的关系？" class="headerlink" title="PerformSelector和runloop的关系？"></a>PerformSelector和runloop的关系？</h1><ul><li>基础用法：默认在主线程的runloop，会执行，因为此方法是发送消息，objc_msgSend</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelector:@selector(name:) withObject:@“张建&quot;];</span><br></pre></td></tr></table></figure></div><ul><li>performSelector 在子线程默认不执行，需要加入到 runloop 中并开启</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PerformSelector和runloop的关系？&quot;&gt;&lt;a href=&quot;#PerformSelector和runloop的关系？&quot; class=&quot;headerlink&quot; title=&quot;PerformSelector和runloop的关系？&quot;&gt;&lt;/a&gt;Perfo</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-面试题" scheme="https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>OC面试题：算法</title>
    <link href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%97%E6%B3%95/"/>
    <id>https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%97%E6%B3%95/</id>
    <published>2023-03-09T18:22:53.000Z</published>
    <updated>2023-03-09T18:26:38.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>1）依次比较相邻两个元素，顺序错误则交换位置；需要两层循环，外层循环控制趟数，内层循环控制比较次数</p><p>2）例子：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;5&quot;,@&quot;4&quot;]];</span><br><span class="line">    // 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">    for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序</span><br><span class="line">        for (int j = 0; j &lt; arr.count - i - 1; j++) &#123;</span><br><span class="line">            // 相邻元素比较，若逆序则交换</span><br><span class="line">            if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123;</span><br><span class="line">                [arr exchangeObjectAtIndex:j withObjectAtIndex:j + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>1）从第一个元素与其他元素比较找到最小值，重复操作，直到最后一位结束；需要两层循环，外层循环趟数，里层循环比较次数</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithObjects:@&quot;2&quot;,@&quot;1&quot;,@&quot;5&quot;,@&quot;3&quot;, nil];</span><br><span class="line">// 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">    // 里循环获比较换位</span><br><span class="line">    for (int j = i + 1; j &lt; arr.count; j ++) &#123;</span><br><span class="line">        if ([arr[i] intValue] &gt; [arr[j] intValue]) &#123;</span><br><span class="line">            [arr exchangeObjectAtIndex:i withObjectAtIndex:j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;arr:%@&quot;,arr);</span><br></pre></td></tr></table></figure></div><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p>1） 始终定义第一个元素为 <code>已排序</code> 的，将剩余元素定义为 <code>未排序</code> 逐个插入到 <code>已排序</code> 的排列中；不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = @[@2,@1,@3,@5,@4].mutableCopy;</span><br><span class="line">// 插入排序的原理：始终定义第一个元素为有序的，将元素逐个插入到有序的排列中</span><br><span class="line">// 其特点是：不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去</span><br><span class="line">for(int i = 0;i &lt; arr.count;i++)&#123;</span><br><span class="line">    // 待排序值</span><br><span class="line">    NSNumber * temp = arr[i];</span><br><span class="line">    // 已排序下标</span><br><span class="line">    int j = i - 1;</span><br><span class="line">    // 待排序与已排序比较，从后向前比较</span><br><span class="line">    while (j &gt;= 0 &amp;&amp; [arr[j] integerValue] &gt; [temp integerValue]) &#123;</span><br><span class="line">        // 如果已排序的 &gt; 待排序的 往后移动一个位置</span><br><span class="line">        [arr replaceObjectAtIndex:(j + 1) withObject:arr[j]];</span><br><span class="line">        j --;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 空出来的位置插入新元素</span><br><span class="line">    [arr replaceObjectAtIndex:(j + 1) withObject:temp];</span><br><span class="line">    NSLog(@&quot;arr:%@&quot;,arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:26:19.242271+0800 插入排序[4184:77845] arr:(</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>1）希尔排序相当于 <code>直接插入排序加强版</code>，引入了 <code>增量</code> 的概念；直到增量为 <code>1</code> 时，再进行直接插入排序</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = @[@7,@3,@8,@5,@2,@6,@1,@4].mutableCopy;</span><br><span class="line">// 其实间隔值设值为总数的一半</span><br><span class="line">int gap = arr.count/2;</span><br><span class="line">// 直到间隔小于1时结束</span><br><span class="line">while (gap &gt;= 1) &#123;</span><br><span class="line">    // i 待排元素，以 步距 gap 从后向前扫描</span><br><span class="line">    for(int i = 0;i &lt; arr.count;i++)&#123;</span><br><span class="line">        // 待排元素</span><br><span class="line">        NSNumber * temp = arr[i];</span><br><span class="line">        // 当前位置</span><br><span class="line">        int j = i;</span><br><span class="line">        // 跳跃式比较</span><br><span class="line">        while (j &gt;= gap &amp;&amp; [arr[j - gap] integerValue] &gt; [temp integerValue] ) &#123;</span><br><span class="line">            [arr replaceObjectAtIndex:j withObject:arr[j - gap]];</span><br><span class="line">            j -= gap;</span><br><span class="line">        &#125;</span><br><span class="line">        // 空出来位置，插入待排序</span><br><span class="line">        [arr replaceObjectAtIndex:j withObject:temp];</span><br><span class="line">    &#125;</span><br><span class="line">    // 改变步长</span><br><span class="line">    gap = gap/2;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;arr:%@&quot;,arr);</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:22:41.910840+0800 插入排序[4124:74568] arr:(</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5,</span><br><span class="line">    6,</span><br><span class="line">    7,</span><br><span class="line">    8</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>1）也就是 <code>兔子数列</code>，当前数是前两个数列之和</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    NSInteger num = 10;</span><br><span class="line">    NSInteger total = [self getTotalNum:num];</span><br><span class="line">    NSLog(@&quot;total:%ld&quot;,total);</span><br><span class="line">&#125;</span><br><span class="line">- (NSInteger)getTotalNum:(NSInteger)num&#123;</span><br><span class="line">    if(num == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(num == 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return [self getTotalNum:num-2] + [self getTotalNum:num-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:28:32.672554+0800 斐波那契数列[4285:80606] total:89</span><br></pre></td></tr></table></figure></div><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>1）<code>有序的数组</code>，将数组分割成两份，利用查找的值跟中间值进行比较，如果查找的值大于中间值，就在数组的右边进行查找；如果查找的值小于中间值，就在数组的左边进行查找。如此循环的执行下去，最终找到符合的值。</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NSArray * arr = @[@(1),@(3),@(5),@(6),@(8),@(10)];</span><br><span class="line">int key = [@(5) intValue];</span><br><span class="line">int min = 0;</span><br><span class="line">int max = arr.count - 1;</span><br><span class="line">int mid;</span><br><span class="line">while (min &lt;= max) &#123;</span><br><span class="line">    // 计算中间下标</span><br><span class="line">    mid = (min + max) / 2;</span><br><span class="line">    // 如果目标值 &gt; 中间下标的中间值</span><br><span class="line">    if (key &gt; [arr[mid] intValue]) &#123;</span><br><span class="line">        //最小变为中间下标+1</span><br><span class="line">        min = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果目标值 &lt; 中间下标的中间值</span><br><span class="line">    else if (key &lt; [arr[mid] intValue])&#123;</span><br><span class="line">        //最大变为中间下标-1</span><br><span class="line">        max = max - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 否则，正好</span><br><span class="line">    else &#123;</span><br><span class="line">        NSLog(@&quot;key:%d&quot;,mid);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:33:18.661324+0800 二分查找[4607:86953] key:2</span><br></pre></td></tr></table></figure></div><h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><p>递归求和1+2+..+n?</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    int sum = [self sum:4];</span><br><span class="line">    NSLog(@&quot;sum:%d&quot;,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)sum:(int)n&#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return [self sum:n-1] + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;p&gt;1）依次比较相邻两个元素，顺序错误则交换位置；需要两层循环，外层循环控制趟数，内层循环控制比较次数&lt;/p&gt;
&lt;p&gt;2）例子：</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-面试题" scheme="https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>OC面试题：多线程</title>
    <link href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-03-09T18:22:02.000Z</published>
    <updated>2023-03-09T21:52:44.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你了解线程么？谈谈你对进程和线程的理解？"><a href="#你了解线程么？谈谈你对进程和线程的理解？" class="headerlink" title="你了解线程么？谈谈你对进程和线程的理解？"></a>你了解线程么？谈谈你对进程和线程的理解？</h1><ul><li><p>进程是 <code>系统进行资源分配和调度的基本单位</code>，是操作系统结构的基础，进程是程序的实体。</p></li><li><p>线程是 <code>独立调度和分派的基本单位</code>，一条线程是进程中一个单一顺序的控制流。</p></li><li><p>同一进程中多条线程共享进程中的全部系统资源，一个进程有很多线程，一个进程可以并发多个线程。</p></li></ul><h1 id="iOS中，有哪些实现多线程的方式？"><a href="#iOS中，有哪些实现多线程的方式？" class="headerlink" title="iOS中，有哪些实现多线程的方式？"></a>iOS中，有哪些实现多线程的方式？</h1><blockquote><p>Pthread<br>   特点：C语言。跨平台，可移植，使用难度大。生命周期：自己管理。<br>NSThread<br>  特点：OC语言。面向对象，简单易用，可直接操作线程。生命周期：自己管理。<br>GCD<br>  特点：替代NSThread，充分利用多核的技术。生命周期：系统管理。<br>NSOperaton<br>  特点：基于GCD的封装。比GCD多了一些简单实用的功能。生命周期：系统管理。</p></blockquote><h1 id="请说一下多线程中-GCD-和-NSOperation-的区别？"><a href="#请说一下多线程中-GCD-和-NSOperation-的区别？" class="headerlink" title="请说一下多线程中 GCD 和 NSOperation 的区别？"></a>请说一下多线程中 GCD 和 NSOperation 的区别？</h1><p><strong>GCD：</strong></p><ul><li><p><code>提供了一次性执行的代码 dispatch_once</code> ，也就是说保证了一段代码在程序执行的过程中只被执行一次，并且是线程安全的！，实现的单例。</p></li><li><p>提供了 <code>延迟执行</code> 的简便方法 <code>dispatch_after</code>。</p></li><li><p>提供了 <code>调度组</code> 的使用，监听一些列异步方法之行结束之后，我们得到统一的通知</p><ul><li>dispatch_group</li><li>dispatch_group_async</li><li>dispatch_group_notify</li><li>dispatch_group_enter&#x2F;dispatch_group_leave</li></ul></li><li><p>提供了 <code>快速迭代的方式dispatch_apply</code>。按照指定的次序将制定的任务追加到指定的队列中，并等待全部队列执行结束！</p></li><li><p>提供了信号量 <code>dispatch_semaphore_t</code>，使用信号量可以实现安全的多线程！（加锁的一种方式）</p><ul><li>dispatch_semaphore_wait：信号量减1，阻塞当前线程</li><li>dispatch_semaphore_signal：信号量加1，释放当前线程</li></ul></li><li><p>提供了栅栏函数 <code>dispatch_barrier_async</code>，使用栅栏函数 <code>可以实现线程的多读单写</code>！</p></li></ul><p><strong>​​​​​​NSOpearion：</strong></p><ul><li><p>NSOperatoin是对GCD更高层次的封装</p></li><li><p>NSOperation可以设置两个操作之间的依赖关系。</p></li><li><p>NSOperation是个抽象类，开发中使用它的两个子类，NSBlockOperation&#x2F;NSInvocationOperation。</p></li><li><p>使用KVO，观察NSOperation的各种状态（isExecuted是否正在执行，isFinished是否结束，isCancled是否取消）。无法判断GCD的状态。</p></li><li><p>NSOperation可以设置操作的优先级。</p></li><li><p>NSoperation可以方便的取消一个操作的执行</p></li><li><p>可以重写NSOperation的main和start函数。</p></li></ul><h1 id="dispatch-once-是怎么保证线程安全的？"><a href="#dispatch-once-是怎么保证线程安全的？" class="headerlink" title="dispatch_once 是怎么保证线程安全的？"></a>dispatch_once 是怎么保证线程安全的？</h1><p>定义一个dispatch_once_t的静态变量，标识下面的diapatch_once的block是否执行过了，static修饰会默认将 <code>onceToken其初始化为0</code>，当值为0时才会 <code>执行block代码块</code> 里面的内容，此时onceToken不为0，当block执行完成，<code>底层会将oneceToken设置为-1</code>，以后再调用的话不会再走block代码块。</p><h1 id="dispatch-after延迟执行，执行时间是准确的吗？"><a href="#dispatch-after延迟执行，执行时间是准确的吗？" class="headerlink" title="dispatch_after延迟执行，执行时间是准确的吗？"></a>dispatch_after延迟执行，执行时间是准确的吗？</h1><p>dispatch_after的延迟执行时间不是准确的，因为dispatch_after是在指定时间之后将任务添加到主队列，并不是在指定时间之后开始执行处理！</p><h1 id="说说你对-dispatch-apply-的理解？"><a href="#说说你对-dispatch-apply-的理解？" class="headerlink" title="说说你对 dispatch_apply 的理解？"></a>说说你对 dispatch_apply 的理解？</h1><ul><li><p><code>dispatch_apply</code> 是GCD提供的一种 <code>快速迭代的函数</code>，按照指定的次数将指定的任务追加到指定的队列中，并等待全部任务结束。</p></li><li><p>如果用在串行队列，就和for循环一样，按顺序同步执行。</p></li><li><p>如果用在并发队列，追加到队列的任务会异步执行，并且等待全部任务结束！</p></li></ul><h1 id="说说你对dispatch-group的理解？"><a href="#说说你对dispatch-group的理解？" class="headerlink" title="说说你对dispatch_group的理解？"></a>说说你对dispatch_group的理解？</h1><ul><li><p>GCD提供的队列组，有两种使用方式 <code>dispatch_group_async</code> 和 <code>dispatch_group_enter/dispatch_group_leave</code>，使用过程中要根据任务类型选择使用哪种方式。</p></li><li><p>如果任务类型是同步任务：使用 <code>dispatch_group_async</code> 和 <code>dispatch_group_enter/dispatch_group_leave</code> 是同样的，可以实现相同的功能。</p></li><li><p>如果任务类型是异步任务：比如（AF）网络请求，使用dispatch_group_async不能等到所有异步任务执行完成，就会去执行dispatch_group_notify中的代码，使用dispatch_group_enter&#x2F;dispatch_group_leave可以实现执行完添加的异步任务，最后执行dispatch_group_notify中的代码</p></li><li><p>如果你要实现这样一个功能，请求网络A和B,然后根据A&#x2F;B返回的内容去刷新页面，如果使用dispatch_group，那么只能使用 <code>dispatch_grouo_enter/dispatch_grouo_leave</code>！！！使用dispatch_group_async是不能实现这个功能的！</p></li></ul><h1 id="说说你项目中的哪些功能使用了dispatch-semaphore-t，解决了什么问题？"><a href="#说说你项目中的哪些功能使用了dispatch-semaphore-t，解决了什么问题？" class="headerlink" title="说说你项目中的哪些功能使用了dispatch_semaphore_t，解决了什么问题？"></a>说说你项目中的哪些功能使用了dispatch_semaphore_t，解决了什么问题？</h1><p>使用信号量 <code>dispatch_semaphore_t</code> 可以实现 <code>异步任务的顺序执行</code>（也就是 <code>将异步任务转换为同步任务执行</code>）不要阻塞主线程！。也是多线程加锁的一种实现方式，保证线程安全。</p><ul><li><p>dispatch_semaphore_create(intptr_t value) 创建一个队列组，传入得值&gt;&#x3D;0，传入的值控制控制并发线程的数量！！！，如果我们传入2，那么就表示当前最多有两个线程同时执行。</p></li><li><p>dispatch_semaphore_signal(dispatch_semaphore_t dsema) 增加信号量，使信号量的值加1！</p></li><li><p>dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout) 等待当前线程，直到某个时间释放！！！</p></li></ul><h1 id="说说你对NSOperation-x2F-NSOperationQueue的使用和理解？"><a href="#说说你对NSOperation-x2F-NSOperationQueue的使用和理解？" class="headerlink" title="说说你对NSOperation&#x2F;NSOperationQueue的使用和理解？"></a>说说你对NSOperation&#x2F;NSOperationQueue的使用和理解？</h1><ol><li><p>NSOperation&#x2F;NSOperationQueue 是系统提供的一套多线程实现方案。实际上NSOperation&#x2F;NSOperationQueue是基于GCD更高层次的封装，完全面向对象，比GCD简单易用，代码可读性更高。</p></li><li><p>使用步骤：</p></li></ol><ul><li><p>创建操作，将操作封装到NSOperation对象中,执行的顺序取决于操作之间的相对优先级，操作执行结束的顺序，取决于操作本身！</p></li><li><p>创建队列 NSOperationQueue，将操作添加到队列中，一个队列中同时能并发执行的最大操作数由maxConcurrentOperationCount 决定，也就是一个操作队列中的操作是串行还是并发执行，由maxConcurrentOperationCount它决定！</p><ul><li>maxConcurrentOperationCount &#x3D; -1，默认，并发执行</li><li>maxConcurrentOperationCount &#x3D; 1，串行执行</li><li>maxConcurrentOperationCount &#x3D; 3，并发执行</li></ul></li><li><p>系统会将队列中的操作取出，在新线程中执行操作。</p></li><li><p>操作有几种状态</p><ul><li>op1.isReady; 是否准备就绪</li><li>op1.isExecuting; 是否正在执行</li><li>op1.isCancelled; 是否已经取消</li><li>op1.isFinished; 是否执行完成</li></ul></li><li><p>取消操作和队列</p><ul><li>[op1 cancel]; 取消操作，实际上是标记isCancelled状态</li><li>[queue cancelAllOperations]; 取消队列</li></ul></li></ul><h1 id="你是否在定义过NSOperation"><a href="#你是否在定义过NSOperation" class="headerlink" title="你是否在定义过NSOperation?"></a>你是否在定义过NSOperation?</h1><p>自定义NSOperation可以通过重写main或者start方法。重写main方法，不需要管理操作的状态属性isExecuting和isFinished。重写start方法需要管理操作的状态属性。</p><h1 id="【面试题】：如果在工作中有这样一个需求，使用AFNetworking请求A接口拿到A接口返回的id-a，用id-a作为参数去请求B接口，拿到B网络返回的name-b去查数据库，然后刷新页面。该怎么实现呢？"><a href="#【面试题】：如果在工作中有这样一个需求，使用AFNetworking请求A接口拿到A接口返回的id-a，用id-a作为参数去请求B接口，拿到B网络返回的name-b去查数据库，然后刷新页面。该怎么实现呢？" class="headerlink" title="【面试题】：如果在工作中有这样一个需求，使用AFNetworking请求A接口拿到A接口返回的id_a，用id_a作为参数去请求B接口，拿到B网络返回的name_b去查数据库，然后刷新页面。该怎么实现呢？"></a>【面试题】：如果在工作中有这样一个需求，使用AFNetworking请求A接口拿到A接口返回的id_a，用id_a作为参数去请求B接口，拿到B网络返回的name_b去查数据库，然后刷新页面。该怎么实现呢？</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) dispatch_semaphore_t semaphore;</span><br><span class="line">@property (nonatomic, assign) dispatch_queue_t queue;</span><br><span class="line"> </span><br><span class="line">- (void)viewDidLoad&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //：测试</span><br><span class="line">    [self semaphoreSync];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)semaphoreSync&#123;</span><br><span class="line">    // 创建信号量，传入参数0</span><br><span class="line">    self.semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    // 创建队列，这里串行和并发并无区别</span><br><span class="line">    self.queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    // 开启一个新线程，</span><br><span class="line">    // 这里之所以要创建一个新线程，而不是在当前（主线程）执行，是因为，AF的网络请求返回默认是在主线程中执行，如果我们在当前线程执行一下操作，会发生线程死锁的现象，</span><br><span class="line">    dispatch_async(self.queue, ^&#123;</span><br><span class="line">        // 任务A</span><br><span class="line">        int ida = [self requestA];</span><br><span class="line">        // 任务B</span><br><span class="line">        NSString *name = [self requestB:ida];</span><br><span class="line">        // 任务C</span><br><span class="line">        NSDictionary *res = [self queryDB:name];</span><br><span class="line">        NSLog(@&quot;%@&quot;, res);</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            // 刷新页面</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (int)requestA&#123;</span><br><span class="line">    __block int ida = 0;</span><br><span class="line">    // AF</span><br><span class="line">    NSArray *paths = @[@(self.currentPage), @(pageNum), @(100)];</span><br><span class="line">    [[ZJNetWorkManager shareManager] GetWithUrlString:TC_API(GetCourseList) paths:paths successedBlock:^(BOOL successed, id  _Nonnull jsonObject) &#123;</span><br><span class="line">        ida = 1;</span><br><span class="line">        // 释放信号量，信号量加1，释放当前线程，然后执行return操作</span><br><span class="line">        dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">    &#125; failedBlock:^(NSError * _Nonnull error) &#123;</span><br><span class="line">        dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line">    // 信号量减1，阻塞当前线程</span><br><span class="line">    dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"> </span><br><span class="line">    return ida;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (NSString *)requestB:(int)ida&#123;</span><br><span class="line">    __block NSString *name;</span><br><span class="line">    NSArray *paths = @[@(self.currentPage), @(pageNum), @(100), @(ida)];</span><br><span class="line">    [[ZJNetWorkManager shareManager] GetWithUrlString:TC_API(GetCourseList) paths:paths successedBlock:^(BOOL successed, id  _Nonnull jsonObject) &#123;</span><br><span class="line">        name = @&quot;你好👋&quot;;</span><br><span class="line">        dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">    &#125; failedBlock:^(NSError * _Nonnull error) &#123;</span><br><span class="line">        dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line">        </span><br><span class="line">    dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"> </span><br><span class="line">    return name;</span><br><span class="line">&#125; </span><br><span class="line">- (NSDictionary *)queryDB:(NSString *)name&#123;</span><br><span class="line">    //查询数据库，返回结果</span><br><span class="line">    return @&#123;@&quot;name&quot;:@&quot;name&quot;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="【面试题】根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？"><a href="#【面试题】根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？" class="headerlink" title="【面试题】根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？"></a>【面试题】根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？</h1><p>dispatch_group_t + dispatch_group_enter + dispatch_group_leave + dispatch_group_notify</p><h1 id="【面试题】请实现一个多读单写的功能？"><a href="#【面试题】请实现一个多读单写的功能？" class="headerlink" title="【面试题】请实现一个多读单写的功能？"></a>【面试题】请实现一个多读单写的功能？</h1><p>我们可以用 <code>dispatch_barrier_async</code> 实现</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@interface TKReadWhiteSafeDic() &#123;</span><br><span class="line">    // 定义一个并发队列</span><br><span class="line">    dispatch_queue_t concurrent_queue;</span><br><span class="line">    </span><br><span class="line">    // 用户数据中心, 可能多个线程需要数据访问</span><br><span class="line">    NSMutableDictionary *userCenterDic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 多读单写模型</span><br><span class="line">@implementation TKReadWhiteSafeDic</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        // 通过宏定义 DISPATCH_QUEUE_CONCURRENT 创建一个并发队列</span><br><span class="line">        concurrent_queue = dispatch_queue_create(&quot;read_write_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">        // 创建数据容器</span><br><span class="line">        userCenterDic = [NSMutableDictionary dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)objectForKey:(NSString *)key &#123;</span><br><span class="line">    __block id obj;</span><br><span class="line">    // 同步读取指定数据</span><br><span class="line">    dispatch_sync(concurrent_queue, ^&#123;</span><br><span class="line">        obj = [userCenterDic objectForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setObject:(id)obj forKey:(NSString *)key &#123;</span><br><span class="line">    // 异步栅栏调用设置数据</span><br><span class="line">    dispatch_barrier_async(concurrent_queue, ^&#123;</span><br><span class="line">        [userCenterDic setObject:obj forKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>读操作为啥同步dispatch_sync</li></ul><blockquote><p>读的话通常都是直接想要结果，需要同步返回结果，如果是异步获取的话就根网络请求一样了。</p></blockquote><ul><li>写操作为啥异步dispatch_barrier_async</li></ul><blockquote><p>写操作是因为不需要等待写操作完成，所以用异步。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;你了解线程么？谈谈你对进程和线程的理解？&quot;&gt;&lt;a href=&quot;#你了解线程么？谈谈你对进程和线程的理解？&quot; class=&quot;headerlink&quot; title=&quot;你了解线程么？谈谈你对进程和线程的理解？&quot;&gt;&lt;/a&gt;你了解线程么？谈谈你对进程和线程的理解？&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-面试题" scheme="https://www.bboyzj.cn/tags/OC-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习：继承</title>
    <link href="https://www.bboyzj.cn/2023/03/09/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A042%EF%BC%9A%E7%BB%A7%E6%89%BF/"/>
    <id>https://www.bboyzj.cn/2023/03/09/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A042%EF%BC%9A%E7%BB%A7%E6%89%BF/</id>
    <published>2023-03-09T12:33:59.000Z</published>
    <updated>2023-03-09T13:13:50.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>swift中，<code>只有类支持继承</code></li><li>swift中 <code>类没有统一的基类</code>。</li><li>没有继承任何父类的类是基类，但其实它是有一个父类的，叫 <code>_SwiftObject</code></li><li>被 <code>final</code> 修饰的 <code>属性、方法、下标</code> 禁止被 <code>重写</code>，禁止被 <code>继承</code></li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul><li>swift中的继承与其他语言类似，主要是 <code>子类继承父类</code> 的 <code>属性、方法、下标</code> 及其他的特征</li><li>子类可以 <code>调用和访问</code> 父类的 <code>属性、方法、下标</code></li><li>子类可以 <code>重写</code> 父类的 <code>属性、方法、下标</code></li></ul><h1 id="继承的基本使用"><a href="#继承的基本使用" class="headerlink" title="继承的基本使用"></a>继承的基本使用</h1><ul><li>定义一个基类</li></ul><h1 id="重写的基本使用"><a href="#重写的基本使用" class="headerlink" title="重写的基本使用"></a>重写的基本使用</h1><ul><li><p>重写父类的 <code>属性、方法、下标</code> 用关键字 <code>override</code> ，编译器会根据此关键字进行检查父类是不是有提供相应的声明</p></li><li><p>重写的 <code>属性、方法、下标</code> 想要访问父类用 <code>super</code> 关键字，如果 <code>super.someProperty、someMethod、some[someIndex]</code></p></li></ul><h2 id="属性重写"><a href="#属性重写" class="headerlink" title="属性重写"></a>属性重写</h2><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><h2 id="下标重写"><a href="#下标重写" class="headerlink" title="下标重写"></a>下标重写</h2><h2 id="属性观察器重写"><a href="#属性观察器重写" class="headerlink" title="属性观察器重写"></a>属性观察器重写</h2><h1 id="禁止重写"><a href="#禁止重写" class="headerlink" title="禁止重写"></a>禁止重写</h1><ul><li>可以用 <code>final</code> 关键字禁止被 <code>继承</code></li><li>禁止继承属性： final var（变量属性）、final let（常量属性）</li><li>禁止继承方法：final func（实例方法）、final class（类方法）、</li><li>禁止继承下标：final subscribe（下标）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;swift中，&lt;code&gt;只有类支持继承&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;swift中 &lt;code&gt;类没有统一的基类&lt;/code</summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-课程篇" scheme="https://www.bboyzj.cn/tags/Swift-%E8%AF%BE%E7%A8%8B%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习：swift中方法的调用</title>
    <link href="https://www.bboyzj.cn/2023/03/09/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/"/>
    <id>https://www.bboyzj.cn/2023/03/09/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</id>
    <published>2023-03-09T08:29:57.000Z</published>
    <updated>2023-03-09T08:29:57.676Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>性能优化03：Crash检测和优化方案</title>
    <link href="https://www.bboyzj.cn/2023/03/09/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603%EF%BC%9ACrash%E6%A3%80%E6%B5%8B%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <id>https://www.bboyzj.cn/2023/03/09/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603%EF%BC%9ACrash%E6%A3%80%E6%B5%8B%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</id>
    <published>2023-03-08T21:32:04.000Z</published>
    <updated>2023-03-09T19:15:28.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="Crash原因"><a href="#Crash原因" class="headerlink" title="Crash原因"></a>Crash原因</h1><h1 id="Crash原因和解决"><a href="#Crash原因和解决" class="headerlink" title="Crash原因和解决"></a>Crash原因和解决</h1><ol><li>找不到方法的实现 unrecognized selector sent to instance</li></ol><ul><li><p>原因：找不到方法iOS系统抛出异常崩溃</p></li><li><p>解决方案：给NSObject添加一个分类，实现消息转发的几个方法</p></li></ul><ol start="2"><li>KVC造成的crash</li></ol><ul><li><p>原因：给不存在的key（包括key为nil）设置value</p></li><li><p>解决方法：</p></li><li><p>如果属性存在，利用iOS的反射机制来规避，NSStringFromSelector(@selector())将SEL反射为字符串作为key。这样在@selector()中传入方法名的过程中，编译器会有合法性检查，如果方法不存在或未实现会报黄色警告。</p></li><li><p>重写类的setValue:forUndefinedKey:和valueForUndefinedKey:</p></li></ul><ol start="3"><li>KVO引起的崩溃</li></ol><ul><li><p>原因：添加了观察者，没有在正确的时机移除</p></li><li><p>解决方案：addObserver和removeObserver一定要成对出现</p></li></ul><ol start="4"><li>集合类相关崩溃</li></ol><ul><li><p>原因：越界、添加nil、越界、添加nil</p></li><li><p>解决方案：</p></li></ul><p>给集合类添加category重写原来的方法，在内部做判段<br>使用Runtime把原来的方法替换成自定义的安全方法</p><ol start="5"><li>多线程中的崩溃</li></ol><p>原因:子线程中更新UI</p><p>解决方案：主线程更新UI</p><h1 id="Crash收集"><a href="#Crash收集" class="headerlink" title="Crash收集"></a>Crash收集</h1><h1 id="检测方式"><a href="#检测方式" class="headerlink" title="检测方式"></a>检测方式</h1><ol><li><p>第三方框架：Bugly</p></li><li><p>iTunes Store收集：上传App Store的app，苹果有帮我们收集，Xcode-&gt;Windows-&gt;Organizer</p></li><li><p>NSSetUncaughtExceptionHandler：iOS SDK 中提供了一个现成的函数</p></li></ol><h1 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h1 id=&quot;Crash原因&quot;&gt;&lt;a href=&quot;#Crash原因&quot; class=&quot;headerlink&quot; title=&quot;Crash原因&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>OC学习13：上传App Store所需各图标和图片尺寸</title>
    <link href="https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A013%EF%BC%9A%E4%B8%8A%E4%BC%A0App-Store%E6%89%80%E9%9C%80%E5%90%84%E5%9B%BE%E6%A0%87%E5%92%8C%E5%9B%BE%E7%89%87%E5%B0%BA%E5%AF%B8/"/>
    <id>https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A013%EF%BC%9A%E4%B8%8A%E4%BC%A0App-Store%E6%89%80%E9%9C%80%E5%90%84%E5%9B%BE%E6%A0%87%E5%92%8C%E5%9B%BE%E7%89%87%E5%B0%BA%E5%AF%B8/</id>
    <published>2023-03-08T19:13:37.000Z</published>
    <updated>2023-03-08T20:50:44.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="App-Icon-图标尺寸"><a href="#App-Icon-图标尺寸" class="headerlink" title="App Icon 图标尺寸"></a>App Icon 图标尺寸</h1><table><thead><tr><th align="center">型号</th><th align="center">分辨率（pt）</th><th align="center">像素（px）</th><th align="center">图片后缀</th></tr></thead><tbody><tr><td align="center">iPhone</td><td align="center">20</td><td align="center">40x40</td><td align="center">2x</td></tr><tr><td align="center">iPhone</td><td align="center">20</td><td align="center">60x60</td><td align="center">3x</td></tr><tr><td align="center">iPhone</td><td align="center">29</td><td align="center">58x58</td><td align="center">2x</td></tr><tr><td align="center">iPhone</td><td align="center">29</td><td align="center">87x87</td><td align="center">3x</td></tr><tr><td align="center">iPhone</td><td align="center">40</td><td align="center">80x80</td><td align="center">2x</td></tr><tr><td align="center">iPhone</td><td align="center">40</td><td align="center">120x120</td><td align="center">3x</td></tr><tr><td align="center">iPhone</td><td align="center">60</td><td align="center">120x120</td><td align="center">2x</td></tr><tr><td align="center">iPhone</td><td align="center">60</td><td align="center">180x180</td><td align="center">2x</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">iPad</td><td align="center">20</td><td align="center">20x20</td><td align="center">1x</td></tr><tr><td align="center">iPad</td><td align="center">20</td><td align="center">40x40</td><td align="center">2x</td></tr><tr><td align="center">iPad</td><td align="center">29</td><td align="center">29x29</td><td align="center">1x</td></tr><tr><td align="center">iPad</td><td align="center">29</td><td align="center">58x58</td><td align="center">2x</td></tr><tr><td align="center">iPad</td><td align="center">40</td><td align="center">40x40</td><td align="center">1x</td></tr><tr><td align="center">iPad</td><td align="center">40</td><td align="center">80x80</td><td align="center">2x</td></tr><tr><td align="center">iPad</td><td align="center">76</td><td align="center">76x76</td><td align="center">1x</td></tr><tr><td align="center">iPad</td><td align="center">76</td><td align="center">152x152</td><td align="center">2x</td></tr><tr><td align="center">iPad</td><td align="center">83.5</td><td align="center">167x167</td><td align="center">2x</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">App Store</td><td align="center">1024</td><td align="center">1024x1024</td><td align="center">1x</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="App-Store-引导页图片尺寸"><a href="#App-Store-引导页图片尺寸" class="headerlink" title="App Store 引导页图片尺寸"></a>App Store 引导页图片尺寸</h1><table><thead><tr><th align="center">屏幕大小（英寸）</th><th align="center">像素（px）</th></tr></thead><tbody><tr><td align="center">5.5</td><td align="center">886x1920</td></tr><tr><td align="center">6.5</td><td align="center">1080x1920</td></tr><tr><td align="center">12.9</td><td align="center">1200x1600</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;App-Icon-图标尺寸&quot;&gt;&lt;a href=&quot;#App-Icon-图标尺寸&quot; class=&quot;headerlink&quot; title=&quot;App Icon 图标尺寸&quot;&gt;&lt;/a&gt;App Icon 图标尺寸&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th alig</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习12：HTTP状态码大全</title>
    <link href="https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A012%EF%BC%9AHTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    <id>https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A012%EF%BC%9AHTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E5%85%A8/</id>
    <published>2023-03-08T19:12:49.000Z</published>
    <updated>2023-03-08T21:20:21.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HTTP状态码（HTTP Status Code）是用来表示网页服务器HTTP响应状态的3位数字代码。</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>所有状态码的第一个数字代表了响应的五种状态之一，其分类如下：</p><table><thead><tr><th align="center">状态码</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1xx</td><td align="center">信息，表示临时响应并需要请求者继续执行操作</td></tr><tr><td align="center">2xx</td><td align="center">成功，操作被成功接收并处理</td></tr><tr><td align="center">3xx</td><td align="center">表示要完成请求，需要进一步操作。通常这些代码用来重定向</td></tr><tr><td align="center">4xx</td><td align="center">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="center">5xx</td><td align="center">这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错</td></tr></tbody></table><h1 id="状态码详解"><a href="#状态码详解" class="headerlink" title="状态码详解"></a>状态码详解</h1><ul><li>1xx：</li></ul><blockquote><p>100：（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</p><p>101：（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</p><p>102：由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</p></blockquote><ul><li>2xx：</li></ul><blockquote><p>200：（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</p><p>201：（已创建） 请求成功并且服务器创建了新的资源。</p><p>202：（已接受） 服务器已接受请求，但尚未处理。</p><p>203：（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</p><p>204：（无内容） 服务器成功处理了请求，但没有返回任何内容。</p><p>205：（重置内容） 服务器成功处理了请求，但没有返回任何内容。</p><p>206：（部分内容） 服务器成功处理了部分 GET 请求。</p><p>208：（已经报告）一个DAV的绑定成员被前一个请求枚举，并且没有被再一次包括。</p><p>226：（IM Used）服务器已经满足了请求所要的资源，并且响应是一个或者多个实例操作应用于当前实</p></blockquote><ul><li>3xx：</li></ul><blockquote><p>300：（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p><p>301：（永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</p><p>302：（临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>303：（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</p><p>304：（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</p><p>305：（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</p><p>307：（临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p></blockquote><ul><li>4xx：</li></ul><blockquote><p>400:（错误请求) 服务器不理解请求的语法。</p><p>401：(未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p><p>402：该状态码是为了将来可能的需求而预留的。</p><p>403：（禁止) 服务器拒绝请求。</p><p>404：（未找到) 服务器找不到请求的网页。</p><p>405：（方法禁用) 禁用请求中指定的方法。</p><p>406：（不接受) 无法使用请求的内容特性响应请求的网页。</p><p>407：（需要代理授权) 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</p><p>408：（请求超时) 服务器等候请求时发生超时。</p><p>409：（冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</p><p>410：（已删除) 如果请求的资源已永久删除，服务器就会返回此响应。</p><p>411：（需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。</p><p>412：（未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。</p><p>413：（请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</p><p>414：（请求的 URI 过长) 请求的 URI（通常为网址）过长，服务器无法处理。</p><p>415：（不支持的媒体类型) 请求的格式不受请求页面的支持。</p><p>416：（请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。</p><p>417：（未满足期望值) 服务器未满足”期望”请求标头字段的要求。</p><p>418：（我是一个茶壶）这个代码是在1998年作为传统的IETF April Fools‘ jokes被定义的在RFC2324，超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现。RFC指定了这个代码应该是由茶罐返回给速溶咖啡。</p><p>419：（认证超时）并不是HTTP标注的一部分，419认证超时表示以前的有效证明已经失效了。同时也被用于401未认证的替代选择为了从其它被拒绝访问的已认证客户端中指定服务器的资源。</p><p>420：（方法失效）不是HTTP的标准，但是被Spring定义在HTTP状态类中当方法失时使用。这个状态码已经不推荐在Spring中使用。</p><p>420：（提高你的耐心）也不是HTTP标准的一部分，但是被版本1的Twitter搜索和趋势APi返回当客户端的速率被限制的时候。其它的服务提供商可能会使用429太多的请求响应码来代替。</p><p>421：从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</p><p>422：请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked</p><p>当前资源被锁定。（RFC 4918 WebDAV）</p><p>424：由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</p><p>425：在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</p><p>426：客户端应当切换到TLS&#x2F;1.0。（RFC 2817）</p><p>428：(需要前置条件)原始服务器需要有条件的请求。当客户端GET一个资源的状态的时候，同时又PUT回给服务器，与此同时第三方修改状态到服务器上的时候，为了避免丢失更新的问题发生将会导致冲突。</p><p>429：（过多请求）用户已经发送了太多的请求在指定的时间里。用于限制速率。</p><p>431：（请求头部字段太大）服务器由于一个单独的请求头部字段或者是全部的字段太大而不愿意处理请求。</p><p>440：（登陆超时（微软））一个微软的扩展，意味着你的会话已经超时。</p><p>444：（无响应）被使用在Nginx的日志中表明服务器没有返回信息给客户端并且关闭了连接（在威慑恶意软件的时候比较有用）。</p><p>449：（重试（微软））一个微软的扩展。请求应该在执行适当的动作之后被重试。</p><p>450：（被Windows家长控制阻塞（微软））一个微软的扩展。这个错误是当Windows家长控制打开并且阻塞指定网页的访问的时候被指定。</p><p>451：（由于法律原因而无效（因特网草稿））被定义在因特网草稿“一个新的HTTP状态码用于法律限制的资源”。被用于当资源的访问由于法律原因被禁止的时候。例如检查制度或者是政府强制要求禁止访问。一个例子是1953年dystopian的小说Fahrenheit 451就是一个非法的资源。</p><p>451：（重定向（微软））被用在Exchange ActiveSync中如果一个更有效的服务器能够被使用或者是服务器不能访问用户的邮箱。客户端会假定重新执行HTTP自动发现协议去寻找更适合的服务器。</p><p>494：（请求头太大（Nginx））Nginx内置代码和431类似，但是是被更早地引入在版本0.9.4（在2011年1月21日）。</p><p>495：（证书错误（Nginx））Nginx内置的代码，当使用SSL客户端证书的时候错误会出现为了在日志错误中区分它和4XX和一个错误页面的重定向。。</p><p>496：（没有证书（Nginx））Nginx内置的代码，当客户端不能提供证书在日志中分辨4XX和一个错误页面的重定向。</p><p>497：（HTTP到HTTPS（Nginx））Nginx内置的代码，被用于原始的HTTP的请求发送给HTTPS端口去分辨4XX在日志中和一个错误页面的重定向。</p><p>498：（令牌超时或失效（Esri））由ArcGIS for Server返回。这个代码意味着令牌的超时或者是失效。</p><p>499：（客户端关闭请求（Nginx））被用在Nginx日志去表明一个连接已经被客户端关闭当服务器仍然正在处理它的请求，是的服务器无法返货状态码。</p><p>499：（需要令牌（Esri））由ArcGIS for Server返回。意味着需要一个令牌（如果没有令牌被提交）。</p></blockquote><ul><li>5xx：</li></ul><blockquote><p>500：（服务器内部错误） 服务器遇到错误，无法完成请求。</p><p>501：（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</p><p>502：（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</p><p>503：（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</p><p>504：（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p><p>505：（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p><p>506：由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</p><p>507：服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</p><p>508：（发现环路）服务器发现了一个无限的循环档处理请求的时候。</p><p>509：服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</p><p>510：获取资源所需要的策略并没有没满足。（RFC 2774）。</p><p>511：（需要网络授权）客户端需要授权去火的网络的访问权限。一般用于代理交互中被用来进行网络的访问控制。</p><p>520：（未知错误）这个状态码也没有被指定在任何RFC中，并且只会被一些服务器返回，例如微软的Azure和CloudFlare服务器:”520错误。本质上是一个捕获全部的响应当原始服务器返回一些未知的或者一些不能被忍受或者被解释的(协议违反或者空响应)”。</p><p>598：（网络读取超时异常(未知)）这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络读取超时在一个客户端之前的代理的后面。</p><p>599：（网络连接超时异常(未知)）这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络连接超时在一个客户端之前的代理的后面。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;HTTP状态码（HTTP Status Code）是用来表示网页服务器HTTP响应状态的3位数字代码。&lt;/p&gt;
&lt;h1 id=&quot;类型&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习11：Xcode 常用的快捷键大全</title>
    <link href="https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A011%EF%BC%9AXcode-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/"/>
    <id>https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A011%EF%BC%9AXcode-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/</id>
    <published>2023-03-08T19:12:11.000Z</published>
    <updated>2023-03-08T20:26:04.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通用快捷键"><a href="#通用快捷键" class="headerlink" title="通用快捷键"></a>通用快捷键</h1><blockquote><p>Command + A ：全选<br>Command + C ：复制<br>Command + V ：粘贴<br>Command + X ：剪切<br>Command + Z ：撤销<br>Command + Shift + Z ： 撤销刚才的撤销</p></blockquote><h1 id="文件快捷键"><a href="#文件快捷键" class="headerlink" title="文件快捷键"></a>文件快捷键</h1><blockquote><p>Command + S ：保存<br>Command + Shift + S ：另存为</p></blockquote><h1 id="项目快捷键"><a href="#项目快捷键" class="headerlink" title="项目快捷键"></a>项目快捷键</h1><blockquote><p>Command + Shift + N ：新建项目<br>Command + N ：新建文件<br>Command + O ：打开文件<br>Command + D ：快速复制一段代码<br>Optional + 单击 ：显示描述文件<br>Command +  单击：跳转函数<br>Command + Optional + 上&#x2F;下箭头 ：快速切换.h和.m文件</p><p>Command + 0 ：显示&#x2F;隐藏导航器面板<br>Command + Optional + 0 ：显示&#x2F;隐藏工具面板<br>Command + Shift + o ：快速搜索</p></blockquote><h1 id="注释快捷键"><a href="#注释快捷键" class="headerlink" title="注释快捷键"></a>注释快捷键</h1><blockquote><p>Command + Optional + &#x2F; ：快速注释<br>Command + &#x2F; ：单行注释</p></blockquote><h1 id="折叠-x2F-展开快捷键"><a href="#折叠-x2F-展开快捷键" class="headerlink" title="折叠&#x2F;展开快捷键"></a>折叠&#x2F;展开快捷键</h1><blockquote><p>Command + Optional + 左箭头 ：折叠代码<br>Command + Optional + 右箭头 ：展开代码</p></blockquote><h1 id="文字快捷键"><a href="#文字快捷键" class="headerlink" title="文字快捷键"></a>文字快捷键</h1><blockquote><p>Command + - ：缩小文字<br>Command + + ：放大文字</p></blockquote><h1 id="调试运行、停止"><a href="#调试运行、停止" class="headerlink" title="调试运行、停止"></a>调试运行、停止</h1><blockquote><p>Command + B ：编译<br>Command + R ：运行<br>Command + . ：停止<br>Command + Shift + K ：清理</p></blockquote><h1 id="移动代码块"><a href="#移动代码块" class="headerlink" title="移动代码块"></a>移动代码块</h1><blockquote><p>Command + [ ：左移代码块<br>Command + ] ：右移代码块</p></blockquote><blockquote><p>Command + Optional + [ ：上移代码块<br>Command + Optional + ] ：下移代码块</p></blockquote><h1 id="移动光标快捷键"><a href="#移动光标快捷键" class="headerlink" title="移动光标快捷键"></a>移动光标快捷键</h1><blockquote><p>Command + 左&#x2F;右箭头 ：将光标移动至行首&#x2F;尾<br>Command + 上&#x2F;下箭头 ：将光标移动至文档行首&#x2F;尾</p></blockquote><blockquote><p>Command + Shift + 左&#x2F;右箭头 ：向左&#x2F;右选择一个单词</p></blockquote><blockquote><p>Command + Shift + 左&#x2F;右箭头 ：选择到行首&#x2F;尾</p></blockquote><h1 id="调试快捷键"><a href="#调试快捷键" class="headerlink" title="调试快捷键"></a>调试快捷键</h1><blockquote><p>Command + \ ：设置&#x2F;取消断点</p></blockquote><h1 id="窗口快捷键"><a href="#窗口快捷键" class="headerlink" title="窗口快捷键"></a>窗口快捷键</h1><blockquote><p>Command + H ：隐藏<br>Command + M ：最小化<br>Command + P ：打印<br>Command + Q ：退出项目<br>Command + W ：关闭当前文件</p></blockquote><h1 id="窗口切换快捷键"><a href="#窗口切换快捷键" class="headerlink" title="窗口切换快捷键"></a>窗口切换快捷键</h1><blockquote><p>Command + Tab ：程序间切换<br>Command + ~ ：窗口间切换</p></blockquote><h1 id="屏幕快捷键"><a href="#屏幕快捷键" class="headerlink" title="屏幕快捷键"></a>屏幕快捷键</h1><blockquote><p>Command + Shift + F3 ：截图整个屏幕<br>Command + Shift + F4 ：截取指定区域</p></blockquote><h1 id="系统快捷键"><a href="#系统快捷键" class="headerlink" title="系统快捷键"></a>系统快捷键</h1><blockquote><p>Command + Optional + ESC ：强制退出程序<br>Command + Space ：切换语言<br>Command + Shift + ？：帮助 </p></blockquote><h1 id="编辑快捷键"><a href="#编辑快捷键" class="headerlink" title="编辑快捷键"></a>编辑快捷键</h1><blockquote><p>Command + Delete ：删除<br>Command + Shift + Delete ：清空垃圾桶<br>Command + Shift + A ：打开应用程序目录<br>Command + Shift + C ：打开 Computer 目录<br>Command + Shift + H ：打开 Home 目录</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通用快捷键&quot;&gt;&lt;a href=&quot;#通用快捷键&quot; class=&quot;headerlink&quot; title=&quot;通用快捷键&quot;&gt;&lt;/a&gt;通用快捷键&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Command + A ：全选&lt;br&gt;Command + C ：复制&lt;br&gt;Command</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习10：iPhone各系列尺寸大全</title>
    <link href="https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A010%EF%BC%9AiPhone%E5%90%84%E7%B3%BB%E5%88%97%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%85%A8/"/>
    <id>https://www.bboyzj.cn/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A010%EF%BC%9AiPhone%E5%90%84%E7%B3%BB%E5%88%97%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%85%A8/</id>
    <published>2023-03-08T19:11:14.000Z</published>
    <updated>2023-03-08T21:07:28.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iPhone手机尺寸大全"><a href="#iPhone手机尺寸大全" class="headerlink" title="iPhone手机尺寸大全"></a>iPhone手机尺寸大全</h1><table><thead><tr><th align="center">机型</th><th align="center">屏幕尺寸 （英寸）</th><th align="center">分辨率（pt）</th><th align="center">像素（px）</th><th align="center">图片后缀</th><th align="center">安全区域（上&#x2F;下）</th></tr></thead><tbody><tr><td align="center">iPhone4&#x2F;4s</td><td align="center">3.5</td><td align="center">320x480</td><td align="center">640x960</td><td align="center">@2x</td><td align="center"></td></tr><tr><td align="center">iPhone5&#x2F;5c&#x2F;5s&#x2F;SE</td><td align="center">4</td><td align="center">320x568</td><td align="center">640x1136</td><td align="center">@2x</td><td align="center"></td></tr><tr><td align="center">iPhone6&#x2F;6s&#x2F;7&#x2F;8</td><td align="center">4.7</td><td align="center">375x667</td><td align="center">750x1334</td><td align="center">@2x</td><td align="center"></td></tr><tr><td align="center">iPhone6&#x2F;6s&#x2F;7&#x2F;8 Plus</td><td align="center">5.5</td><td align="center">414x736</td><td align="center">1080x1920</td><td align="center">@3x</td><td align="center"></td></tr><tr><td align="center">iPhoneX&#x2F;iPhoneXS&#x2F;11Pro</td><td align="center">5.8</td><td align="center">375x812</td><td align="center">1125x2436</td><td align="center">@3x</td><td align="center">44&#x2F;34</td></tr><tr><td align="center">iPhoneXR&#x2F;11</td><td align="center">6.1</td><td align="center">414x896</td><td align="center">828x1792</td><td align="center">@2x</td><td align="center">48&#x2F;34</td></tr><tr><td align="center">iPhoneXSMax&#x2F;11ProMax</td><td align="center">6.5</td><td align="center">414x896</td><td align="center">1242x2688</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone12mini（&gt;&#x3D;iOS14） iPhone13mini（&gt;&#x3D;iOS15）</td><td align="center">5.4</td><td align="center">360x780</td><td align="center">1080x2340</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone12&#x2F;12Pro iPhone13&#x2F;13Pro</td><td align="center">6.1</td><td align="center">390x844</td><td align="center">1170x2532</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone12&#x2F;13ProMax</td><td align="center">6.7</td><td align="center">428x926</td><td align="center">1284x2778</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone14 （&gt;&#x3D;iOS16）</td><td align="center">6.1</td><td align="center">390x844</td><td align="center">1170x2532</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone14 Plus</td><td align="center">6.7</td><td align="center">428x926</td><td align="center">1284x2778</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone14 Pro</td><td align="center">6.1</td><td align="center">393x852</td><td align="center">1179x2556</td><td align="center">@3x</td><td align="center">59&#x2F;34</td></tr><tr><td align="center">iPhone14 Pro Max</td><td align="center">6.7</td><td align="center">430x932</td><td align="center">1290x2796</td><td align="center">@3x</td><td align="center">59&#x2F;34</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iPhone手机尺寸大全&quot;&gt;&lt;a href=&quot;#iPhone手机尺寸大全&quot; class=&quot;headerlink&quot; title=&quot;iPhone手机尺寸大全&quot;&gt;&lt;/a&gt;iPhone手机尺寸大全&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;c</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习12：修改项目名称</title>
    <link href="https://www.bboyzj.cn/2023/03/08/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A008%EF%BC%9A%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.bboyzj.cn/2023/03/08/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A008%EF%BC%9A%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E7%9A%84%E6%B5%81%E7%A8%8B/</id>
    <published>2023-03-08T12:20:10.000Z</published>
    <updated>2023-03-09T07:11:19.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>如果我们在项目中集成三方库 <code>SDwebImage</code> 时，报错 <code>Framework not found Pods_________</code>，说明 <code>工程名称用汉字了</code>，这个时候就需要更改项目名</p></li><li><p>在开发过程中需求想更改项目名</p></li></ul><h1 id="修改名称"><a href="#修改名称" class="headerlink" title="修改名称"></a>修改名称</h1><p>Xcode 修改 工程名</p><ul><li>打开 <code>Xcode</code> 的 <code>Show the File Inspector</code>，修改 <code>Name</code> 为 <code>FirstFrameDemo</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082129005.png"                                     ></p><ul><li>修改成 <code>FirstFrameDemo</code> 之后，回车， 这里 Xcode 列举了可以为我们做的更改的名称</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082130570.png"                                     ></p><ul><li><p>点击 Rename -&gt; OK，Xcode 为我们重命名了一部分。</p></li><li><p>关闭项目工程，修改项目文件夹名称（由原工程名 -&gt; 修改成新的工程名）</p></li></ul><p>修改前：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16782822322176.jpg"                                     ></p><p>修改后：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082130315.png"                                     ></p><ul><li>修改项目文件名（右击选择包内容）</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082130950.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16782822658087.jpg"                                     ></p><ul><li>点击 project.phxproj 文件，将 <code>获取视频的第一帧</code> 替换成 <code>FirstFrameDemo</code> ，全部替换 All -&gt; Done</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16782822796912.jpg"                                     ></p><ul><li>打开项目 <code>FirstFrameDemo.xcworkspace</code> ，项目内全局替换 <code>获取视频的第一帧 -&gt; FirstFrameDemo</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082131991.png"                                     ></p><ul><li>修改 <code>Podfile</code> 文件中项目名称</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082131395.png"                                     ></p><ul><li>打开终端，切换到当前项目目录下，执行 <code>pos intall</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082131192.png"                                     ></p><ul><li>删除旧的 <code>workspace</code> 文件</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082132150.png"                                     ></p><ul><li>至此项目名已经完全修改完成了</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303082133952.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果我们在项目中集成三方库 &lt;code&gt;SDwebImage&lt;/code&gt; 时，报错 &lt;code&gt;Framework no</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习11：Pch文件</title>
    <link href="https://www.bboyzj.cn/2023/03/08/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A009%EF%BC%9APch%E6%96%87%E4%BB%B6/"/>
    <id>https://www.bboyzj.cn/2023/03/08/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A009%EF%BC%9APch%E6%96%87%E4%BB%B6/</id>
    <published>2023-03-08T11:43:38.000Z</published>
    <updated>2023-03-08T18:54:39.914Z</updated>
    
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习10：UITableViw点击事件和页面上的手势冲突怎么解决？</title>
    <link href="https://www.bboyzj.cn/2023/03/07/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A007%EF%BC%9AUITableViw%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%92%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/"/>
    <id>https://www.bboyzj.cn/2023/03/07/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A007%EF%BC%9AUITableViw%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%92%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/</id>
    <published>2023-03-07T11:17:26.000Z</published>
    <updated>2023-03-08T11:41:42.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h1><p>下面以一个例子讲解</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16782753246943.jpg"                                     ></p><p>图中 <code>superView</code> 有两个 <code>subView</code>，分别是 <code>testView</code> 和 <code>testBtn</code>。我们在 <code>superView</code> 和 <code>testView</code> 都重载 <code>touchsBegan:withEvent、touchsEnded:withEvent、 touchsMoved:withEvent、touchsCancelled:withEvent方法</code>，并且在 <code>superView</code> 上添加单击手势 <code>UITapGestureRecognizer</code>，action名为tapAction，给testBtn绑定action名为testBtnClicked。</p><p>主要代码如下：</p><ul><li>SuperView</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)initUI&#123;</span><br><span class="line">    UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapAction)];</span><br><span class="line">    [self addGestureRecognizer:tap];</span><br><span class="line">    </span><br><span class="line">    [self addSubview:self.testView];</span><br><span class="line">    [self addSubview:self.testBtn];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;=========&gt; superView touchs Began&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">     NSLog(@&quot;=========&gt; superView touchs Moved&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">     NSLog(@&quot;=========&gt; superView touchs Ended&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">     NSLog(@&quot;=========&gt; superView touchs Cancelled&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)tapAction &#123;</span><br><span class="line">     NSLog(@&quot;=========&gt; single Tapped&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)clickBtn &#123;</span><br><span class="line">     NSLog(@&quot;=========&gt; click btn&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>textView</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//testView</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;=========&gt; testView touchs Began&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;=========&gt; testView touchs Moved&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;=========&gt; testView touchs Ended&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;=========&gt; testView touchs Cancelled&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>情景O：注释 手势 ，分别点击 superView 和 testView：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2023-03-08 17:58:44.408166+0800 手势冲突[20427:1092257] =========&gt; superView touchs Began</span><br><span class="line">2023-03-08 17:58:44.544181+0800 手势冲突[20427:1092257] =========&gt; superView touchs Ended</span><br><span class="line"></span><br><span class="line">2023-03-08 17:58:54.666862+0800 手势冲突[20427:1092257] =========&gt; testView touchs Began</span><br><span class="line">2023-03-08 17:58:54.825938+0800 手势冲突[20427:1092257] =========&gt; testView touchs Ended</span><br></pre></td></tr></table></figure></div><ul><li>情景A：单击 superView ，输出结果：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2023-03-08 17:32:44.983101+0800 手势冲突[20227:1064772] =========&gt; superView touchs Began</span><br><span class="line">2023-03-08 17:32:45.043310+0800 手势冲突[20227:1064772] =========&gt; single Tapped</span><br><span class="line">2023-03-08 17:32:45.043538+0800 手势冲突[20227:1064772] =========&gt; superView touchs Cancelled</span><br></pre></td></tr></table></figure></div><ul><li>情景B：单击 testView，输出结果：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2023-03-08 17:43:16.370199+0800 手势冲突[20326:1077469] =========&gt; testView touchs Began</span><br><span class="line">2023-03-08 17:43:16.430723+0800 手势冲突[20326:1077469] =========&gt; single Tapped</span><br><span class="line">2023-03-08 17:43:16.430939+0800 手势冲突[20326:1077469] =========&gt; testView touchs Cancelled</span><br></pre></td></tr></table></figure></div><ul><li>情景C：单击 testBtn，输出结果：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023-03-08 17:43:40.690096+0800 手势冲突[20326:1077469] =========&gt; click btn</span><br></pre></td></tr></table></figure></div><ul><li>情景D：按住 testView，过3秒后或更久释放，输出结果：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2023-03-08 17:43:50.678603+0800 手势冲突[20326:1077469] =========&gt; testView touchs Began</span><br><span class="line">2023-03-08 17:43:53.499119+0800 手势冲突[20326:1077469] =========&gt; testView touchs Ended</span><br></pre></td></tr></table></figure></div><h2 id="情景-O、A、B-分析"><a href="#情景-O、A、B-分析" class="headerlink" title="情景 O、A、B 分析"></a>情景 <code>O、A、B</code> 分析</h2><p>开发文档可知：</p><blockquote><p>Gesture Recognizers Get the First Opportunity to Recognize a Touch.</p><p>A window delays the delivery of touch objects to the view so that the gesture recognizer can analyze the touch first. During the delay, if the gesture recognizer recognizes a touch gesture, then the window never delivers the touch object to the view, and also cancels any touch objects it previously sent to the view that were part of that recognized sequence.</p></blockquote><p>Google翻译：</p><blockquote><p>手势识别器获得识别触摸的第一个机会。</p><p>一个窗口延迟将触摸对象传递到视图，使得手势识别器可以首先分析触摸。 在延迟期间，如果手势识别<br>器识别出触摸手势，则窗口不会将触摸对象传递到视图，并且还将先前发送到作为识别的序列的一部分的视图的任何触摸对象取消。</p></blockquote><ul><li><code>触摸事件首先传递到手势上，如果手势识别成功了，就会取消事件的继续传递</code>，否则，事件还是会被响应链处理。系统维持了与响应链关联的所有手势，事件首先传递给手势，然后才传递给响应链。这样我们就解释A和B的场景了</li></ul><h2 id="情景-C-分析："><a href="#情景-C-分析：" class="headerlink" title="情景 C 分析："></a>情景 <code>C</code> 分析：</h2><p>iOS 开发文档里这样说：</p><blockquote><p>In iOS 6.0 and later, default control actions prevent overlapping gesture recognizer behavior. For example, the default action for a button is a single tap. If you have a single tap gesture recognizer attached to a button’s parent view, and the user taps the button, then the button’s action method receives the touch event instead of the gesture recognizer. This applies only to gesture recognition that overlaps the default action for a control, which includes:</p><p>A single finger single tap on a UIButton, UISwitch, UISegmentedControl, UIStepper,and UIPageControl.A single finger swipe on the knob of a UISlider, in a direction parallel to the slider.A single finger pan gesture on the knob of a UISwitch, in a direction parallel to the switch.</p></blockquote><p>Google 翻译为：</p><blockquote><p>在iOS 6.0及更高版本中，默认控制操作可防止重叠的手势识别器行为。 例如，按钮的默认操作是单击。 如果您有一个单击手势识别器附加到按钮的父视图，并且用户点击按钮，则按钮的动作方法接收触摸事件而不是手势识别器。 这仅适用于与控件的默认操作重叠的手势识别，其中包括：</p><p>单个手指单击UIButton，UISwitch，UISegmentedControl，UIStepper和UIPageControl.<br>单个手指在UISlider的旋钮上滑动，在平行于滑块的方向上。在UISwitch的旋钮上的单个手指平移手势 与开关平行的方向。</p></blockquote><ul><li>因此，在情景C，点击testBtn的action，按钮获取了事件响应，不会把事件响应传递给父视图的supView</li></ul><h2 id="情景-C-分析：-1"><a href="#情景-C-分析：-1" class="headerlink" title="情景 C 分析："></a>情景 <code>C</code> 分析：</h2><ul><li>长按testView已经不是单击事件了，tap手势就不会识别</li></ul><h1 id="实际开发中遇到的问题"><a href="#实际开发中遇到的问题" class="headerlink" title="实际开发中遇到的问题"></a>实际开发中遇到的问题</h1><ul><li><p>父视图上先后添加了一个 <code>UIGestureRecognizer</code> 和一个 <code>UITableView</code></p></li><li><p>我们发现在点击 <code>UITableView</code> 的 <code>cell</code> 的时候，并没有触发 <code>-(void)tableView:(UITableView*)tableView didSelectRowAtIndexPath:(NSIndexPath*)indexPath;</code> 方法。</p></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于 cell 继承 cell -&gt; UIView -&gt; UIResponder，是可以接收和处理事件的，但是添加了 <code>tap</code> 后会导致 <code>cell</code> 响应链无法正常响应，导致 <code>手势冲突</code></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在我们点击 <code>cell</code> 的时候，不让父视图的 <code>手势</code> 干扰子视图cell的点击事件或者说响应链正常传递，一般会重写 <code>UIGestureRecognizerDelegate</code> 中的<code> - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch</code><br>方法。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch&#123;</span><br><span class="line">    // 如果是UITableViewCell类或子类响应事件</span><br><span class="line">    if ([touch.view isKindOfClass:[UITableViewCell class]]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    //默认都需要响应</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">2023-03-08 18:19:39.851593+0800 手势冲突[20552:1111844] -[ParentV tableView:didSelectRowAtIndexPath:]</span><br><span class="line">2023-03-08 18:19:40.583123+0800 手势冲突[20552:1111844] -[ParentV tableView:didSelectRowAtIndexPath:]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;举例说明&quot;&gt;&lt;a href=&quot;#举例说明&quot; class=&quot;headerlink&quot; title=&quot;举例说明&quot;&gt;&lt;/a&gt;举例说明&lt;/h1&gt;&lt;p&gt;下面以一个例子讲解&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
        </summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习06：截取视频文件第一帧的方法有哪些？</title>
    <link href="https://www.bboyzj.cn/2023/03/07/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A006%EF%BC%9A%E6%88%AA%E5%8F%96%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E7%AC%AC%E4%B8%80%E5%B8%A7%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <id>https://www.bboyzj.cn/2023/03/07/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A006%EF%BC%9A%E6%88%AA%E5%8F%96%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E7%AC%AC%E4%B8%80%E5%B8%A7%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</id>
    <published>2023-03-07T11:16:39.000Z</published>
    <updated>2023-03-08T18:53:13.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>iOS 中获取视频第一帧有两种方式</p><h1 id="第一种：使用AVFoundation获取"><a href="#第一种：使用AVFoundation获取" class="headerlink" title="第一种：使用AVFoundation获取"></a>第一种：使用AVFoundation获取</h1><p>将耗时的操作放在异步执行队列 <code>dispatch_async</code>，防止造成线程堵塞，刷新UI放在 <code>主线程</code></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)getFirstFrameFromVideoWithUrl:(NSURL *)url&#123;</span><br><span class="line">    AVURLAsset *asset = [[AVURLAsset alloc] initWithURL:url options:nil];</span><br><span class="line">    AVAssetImageGenerator *assetGennerator = [[AVAssetImageGenerator alloc] initWithAsset:asset];</span><br><span class="line">    assetGennerator.appliesPreferredTrackTransform = YES;</span><br><span class="line">    CMTime time = CMTimeMakeWithSeconds(0.0, 600);</span><br><span class="line">    CMTime actualTime;</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    CGImageRef image = [assetGennerator copyCGImageAtTime:time actualTime:&amp;actualTime error:&amp;error];</span><br><span class="line">    UIImage *videoImg = [[UIImage alloc] initWithCGImage:image];</span><br><span class="line">    CGImageRelease(image);</span><br><span class="line">    return videoImg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="第二种方式：使用SDWebImage获取，并缓存图片"><a href="#第二种方式：使用SDWebImage获取，并缓存图片" class="headerlink" title="第二种方式：使用SDWebImage获取，并缓存图片"></a>第二种方式：使用SDWebImage获取，并缓存图片</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (void)method2&#123;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:@&quot;https://klxxcdn.oss-cn-hangzhou.aliyuncs.com/histudy/hrm/media/bg1.mp4&quot;];</span><br><span class="line">    NSString *urlKey = url.absoluteString;</span><br><span class="line">    // 先从缓存中查找是否有图片</span><br><span class="line">    SDImageCache *imgCache = [SDImageCache sharedImageCache];</span><br><span class="line">    UIImage *memoryImg = [imgCache imageFromCacheForKey:urlKey];</span><br><span class="line">    if (memoryImg) &#123;</span><br><span class="line">        self.imgV.image = memoryImg;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        // 从磁盘中查找是否有图片</span><br><span class="line">        UIImage *diskImg = [imgCache imageFromDiskCacheForKey:urlKey];</span><br><span class="line">        if (diskImg) &#123;</span><br><span class="line">            self.imgV.image = diskImg;</span><br><span class="line">        &#125;else &#123; // 如果都不存在</span><br><span class="line">            // 开启异步线程下载图片</span><br><span class="line">            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">                AVURLAsset *asset = [[AVURLAsset alloc] initWithURL:url options:nil];</span><br><span class="line">                NSParameterAssert(asset);</span><br><span class="line">                AVAssetImageGenerator *assetGenerator = [[AVAssetImageGenerator alloc] initWithAsset:asset];</span><br><span class="line">                assetGenerator.appliesPreferredTrackTransform = YES;</span><br><span class="line">                assetGenerator.apertureMode = AVAssetImageGeneratorApertureModeEncodedPixels;</span><br><span class="line">                CGImageRef thumbImgRef = NULL;</span><br><span class="line">                CFTimeInterval thumbImgTime = 1;</span><br><span class="line">                NSError *thumbImgError = nil;</span><br><span class="line">                thumbImgRef = [assetGenerator copyCGImageAtTime:CMTimeMake(thumbImgTime, 60) actualTime:NULL error:&amp;thumbImgError];</span><br><span class="line">                if (!thumbImgRef)&#123;</span><br><span class="line">                    NSLog(@&quot;thumbImgError:%@&quot;,thumbImgError);</span><br><span class="line">                &#125;</span><br><span class="line">                UIImage *thumbImg = thumbImgRef ? [[UIImage alloc] initWithCGImage:thumbImgRef] : nil;</span><br><span class="line">                // 主线程显示UI</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    SDImageCache *imgCache = [SDImageCache sharedImageCache];</span><br><span class="line">                    [imgCache storeImage:thumbImg forKey:urlKey completion:^&#123;</span><br><span class="line">                        NSLog(@&quot;store Image success&quot;);</span><br><span class="line">                    &#125;];</span><br><span class="line">                    self.imgV.image = thumbImg;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;iOS 中获取视频第一帧有两种方式&lt;/p&gt;
&lt;h1 id=&quot;第一种：使用AVFoundation获取&quot;&gt;&lt;a href=&quot;#第一种：使用AV</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习05：分类和扩展</title>
    <link href="https://www.bboyzj.cn/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A005%EF%BC%9A%E5%88%86%E7%B1%BB%E5%92%8C%E6%89%A9%E5%B1%95/"/>
    <id>https://www.bboyzj.cn/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A005%EF%BC%9A%E5%88%86%E7%B1%BB%E5%92%8C%E6%89%A9%E5%B1%95/</id>
    <published>2023-03-06T13:50:50.000Z</published>
    <updated>2023-03-08T19:02:49.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类-Category"><a href="#分类-Category" class="headerlink" title="分类 Category"></a>分类 Category</h1><ul><li><p>Category 的主要作用是为 <code>已经存在的类添加(扩展)方法</code></p></li><li><p>已存在的类可以是 <code>系统的类</code> 或 <code>自定义的类</code> </p></li><li><p>不能定义 <code>变量（成员变量或实例变量）</code></p></li><li><p>一般情况下也可以定义 <code>属性</code>，但是 <code>不会实现</code> 它的 <code>set</code> 和 <code>get</code> 方法，需要利用 <code>runtime</code> 机制去实现它的 <code>set</code> 和 <code>get</code> 方法。</p></li><li><p>分类文件有 <code>.h</code> 和 <code>.m</code> 两个文件，文件名 <code>@interface 类名 (分类名)</code></p></li></ul><h2 id="创建-系统-分类"><a href="#创建-系统-分类" class="headerlink" title="创建 系统 分类"></a>创建 系统 分类</h2><ul><li><code>command + n</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090249910.png"                                     ></p><ul><li>点击 <code>Objective-C File</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090249569.png"                                     ></p><ul><li>创建完成后会生成 <code>系统文件名+Category.h</code> 和 <code>系统文件名+Category.m</code> 两个文件</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090250512.png"                                     ></p><ul><li>在分类中可以添加 <code>实例方法和类方法</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface UIViewController (Cate)</span><br><span class="line">- (void)sayHello;</span><br><span class="line">+ (void)sayBye;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">==============</span><br><span class="line"></span><br><span class="line">@implementation UIViewController (Cate)</span><br><span class="line">- (void)sayHello&#123;</span><br><span class="line">    NSLog(@&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)sayBye&#123;</span><br><span class="line">    NSLog(@&quot;bye&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>在本类中调用，需要引入头文件  <code>文件名+Category.h</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> // 分类</span><br><span class="line">[self sayHello];</span><br><span class="line">[ViewController sayBye];</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">Category[30386:1690552] bye</span><br><span class="line">2023-03-06 22:06:37.369596+0800 Category[30386:1690552] hello</span><br><span class="line">2023-03-06 22:06:37.369794+0800 Category[30386:1690552] bye</span><br></pre></td></tr></table></figure></div><h2 id="自定义的类-添加-分类"><a href="#自定义的类-添加-分类" class="headerlink" title="自定义的类 添加 分类"></a>自定义的类 添加 分类</h2><ul><li>创建方式类似</li></ul><p>与系统类类似，在 <code>class</code> 中选择自定义的类 <code>Person</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090250135.png"                                     ></p><h2 id="可以在-分类中声明并实现-两个方法，在本类中调用"><a href="#可以在-分类中声明并实现-两个方法，在本类中调用" class="headerlink" title="可以在 分类中声明并实现 两个方法，在本类中调用"></a>可以在 <code>分类中声明并实现</code> 两个方法，在本类中调用</h2><ul><li>分类中声明并实现</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface Person (Category)</span><br><span class="line">- (void)sayHello;</span><br><span class="line">+ (void)sayBye;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line"></span><br><span class="line">@implementation Person (Category)</span><br><span class="line">- (void)sayHello&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)sayBye&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>本类中调用，编译运行，查看打印结果</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        // 本类中调用分类添加的方法</span><br><span class="line">        [self sayHello];</span><br><span class="line">        [Person sayBye];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">2023-03-07 08:14:34.439456+0800 Category[3555:114948] -[Person(Category) sayHello]</span><br><span class="line">2023-03-07 08:14:34.439626+0800 Category[3555:114948] +[Person(Category) sayBye]</span><br></pre></td></tr></table></figure></div><p>那么问题来了，既然本类中可以调用，那么在其他类中是否也可以调用呢？</p><h2 id="其他类中调用-分类-方法"><a href="#其他类中调用-分类-方法" class="headerlink" title="其他类中调用 分类 方法"></a>其他类中调用 分类 方法</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 自定义的类</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">#import &quot;Person+Category.h&quot;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 自定义的类</span><br><span class="line">    Person * p = [[Person alloc] init];</span><br><span class="line">    [p sayHello];</span><br><span class="line">    [Person sayBye];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">2023-03-07 08:19:57.913133+0800 Category[3631:119871] -[Person(Category) sayHello]</span><br><span class="line">2023-03-07 08:19:57.913667+0800 Category[3631:119871] +[Person(Category) sayBye]</span><br></pre></td></tr></table></figure></div><p>由打印结果可知，在VC中时可以调用的</p><p>那么问题又来了，如果本类中和分类中均实现了 <code>同样的方法</code> 会调用哪个？</p><h2 id="分类和本类实现了同样的方法"><a href="#分类和本类实现了同样的方法" class="headerlink" title="分类和本类实现了同样的方法"></a>分类和本类实现了同样的方法</h2><ul><li>在 <code>Person</code> 类中实现一个 <code>sayHello</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)sayHello&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>在 VC 中调用 sayHello</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 自定义的类</span><br><span class="line">Person * p = [[Person alloc] init];</span><br><span class="line">[p sayHello];</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">2023-03-07 08:24:09.821814+0800 Category[3670:122944] -[Person(Category) sayHello]</span><br></pre></td></tr></table></figure></div><p>由打印结果可知，调用的是 <code>分类</code> 的方法，由此我们可以推断，<code>本类的方法被分类替代了</code></p><h1 id="扩展-Extension"><a href="#扩展-Extension" class="headerlink" title="扩展 Extension"></a>扩展 Extension</h1><ul><li>是类的一部分，在编译器和头文件里的@interface一级实现文件里的@implement一起形成一个完整的类，它伴随着类的产生而产生，亦随之一起消亡</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>声明 <code>私有属性、私有方法、私有成员变量</code>，想要被访问 <code>@public</code></li><li>扩展不能为系统类添加扩展（必须有一个类的源码才能添加一个类的Extension），所以你无法为系统的类添加Extension</li><li>成员变量和实例变量是 <code>私有的</code>，不能被外界访问，</li><li>属性可以被外界访问，由于没有实现调用会 <code>carsh</code></li><li>方法可以被外界访问，由于没有实现set和get方法，访问会 <code>carsh</code></li><li>扩展只有一个 <code>.h</code> 文件，因此 所有的都是没办法调用</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>创建 <code>Extension</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090251689.png"                                     ></p><ul><li>自定义类中的代码</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">#import &quot;Person+Extension.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (void)sayHello&#123;</span><br><span class="line">    NSLog(@&quot;%s hello&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>在 <code>#import &quot;Person+Ext.h&quot;</code> 中实现如下代码</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface UIViewController ()</span><br><span class="line">&#123;</span><br><span class="line">    NSString * name;</span><br><span class="line">    @public int age;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic,copy)NSString * sex;</span><br><span class="line">- (void)sayHello;</span><br><span class="line">+ (void)sayBye;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>在 <code>VC</code> 中调用</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Person * p = [Person new];</span><br><span class="line">    // 调用报错或崩溃</span><br><span class="line">//    p-&gt;age = 30;</span><br><span class="line">//    p-&gt;name = &quot;ZJ&quot;;</span><br><span class="line">//    p.sex = @&quot;男&quot;;</span><br><span class="line">//    [Person sayBye];</span><br><span class="line"></span><br><span class="line">    [p sayHello];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">2023-03-06 22:35:02.277867+0800 Extension[30580:1704777] -[Person sayHello] hello</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>如果只有声明没有实现，则调用会 <code>Crash</code></p><h1 id="分类-和-扩展的区别"><a href="#分类-和-扩展的区别" class="headerlink" title="分类 和 扩展的区别"></a>分类 和 扩展的区别</h1><ul><li><p>category 在运行时决议。extension 在编译时决议。所以扩展中的方法没有被实现编译器会报警告，分类中没有被实现编译器不会警告</p></li><li><p>分类原则上只能添加方法，不能添加属性（因为没有实现属性的seter和getter方法，可以通过runtime添加）。扩展能添加方法、实例变量，默认是@private类型的，且只能作用于自身类</p></li><li><p>分类有自己的实现部分。扩展没有实现部分，只能依托对应的类的实现部分。</p></li><li><p>分类可以为系统添加分类。扩展不能为系统添加分类。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分类-Category&quot;&gt;&lt;a href=&quot;#分类-Category&quot; class=&quot;headerlink&quot; title=&quot;分类 Category&quot;&gt;&lt;/a&gt;分类 Category&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Category 的主要作用是为 &lt;code&gt;已经</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习04：JSON和XML数据解析</title>
    <link href="https://www.bboyzj.cn/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A004%EF%BC%9AJSON%E5%92%8CXML%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.bboyzj.cn/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A004%EF%BC%9AJSON%E5%92%8CXML%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/</id>
    <published>2023-03-06T06:09:53.000Z</published>
    <updated>2023-03-07T12:01:51.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>在 <code>iOS</code> 开发中，常见的数据传输格式有两种：<code>JSON和XML</code>。</p></li><li><p>服务器返回客户端的数据，一般都是 <code>JSON格式或XML格式（文件下载除外）</code></p></li><li><p><code>JSON</code> 由于 <code>体积小、传输快速 </code>等优点，逐渐成为了 <code>主流的数据传输格式</code>。</p></li></ul><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>在 iOS 中，常见解析方案有以下几种：</p><ul><li><p>第三方框架：JSONKit、SBJson、TouchJSON（性能从左到右，越来越差）</p></li><li><p>性能最好的是使用 <code>苹果原生的框架</code>： <code>NSJSONSerialization</code></p></li><li><p>JSON格式很像OC中的数组和字典，key必须用双引号</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:22&#125;、[&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:22&#125;,&#123;&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:22&#125;]</span><br></pre></td></tr></table></figure></div><h2 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061810849.png"                                     ></p><h2 id="JSON-转-OC"><a href="#JSON-转-OC" class="headerlink" title="JSON 转 OC"></a>JSON 转 OC</h2><ul><li>第一个参数：要解析的JSON数据，是NSData类型也就是二进制数据</li><li>第二个参数：解析JSON的可选配置参数<ul><li>NSJSONReadingMutableContainers 解析出来的字典和数组是可变的</li><li>NSJSONReadingFragmentsAllowed 解析出来的对象中的字符串是可变的</li><li>NSJSONReadingMutableLeaves 被解析的数据如果既不是字典也不是数组，那么就使用这个</li></ul></li><li>第三个参数：错误信息</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary * dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&amp;error];</span><br></pre></td></tr></table></figure></div><h2 id="OC-转-JSON"><a href="#OC-转-JSON" class="headerlink" title="OC 转 JSON"></a>OC 转 JSON</h2><ul><li>第一个参数：要转换成JSON数据的OC对象，这里是一个字典</li><li>第二个参数：NSJSONWritingPrettyPrinted 对转换之后的JSON对象进行排版，无意义</li><li>第三个参数：错误信息</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSData *data = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;error];</span><br></pre></td></tr></table></figure></div><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><ul><li>XML 可扩展标记语言，是一种数据交互格式，也叫XML文档</li><li>XML 被设计用来传输和存储数据</li></ul><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>常见的XML文档由三部分组成</p><ul><li>文档声明</li></ul><p>在XML文档最前面，必须编写一个文档声明，用来声明XML文档的类型</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 最简单的声明</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line"></span><br><span class="line">// 用encoding属性说明文档的字符编码</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br></pre></td></tr></table></figure></div><ul><li><p>元素</p><ul><li>一个元素包括了 <code>开始标签和结束标签</code>，</li><li>有内容的元素 <code>&lt;name&gt;Tom&lt;/name&gt;</code>；没内容的元素 <code>&lt;from&gt;&lt;/from&gt;</code>，可简写成 <code>&lt;from/&gt;</code></li><li>元素可嵌套其他元素，不可出现交叉嵌套</li></ul></li><li><p>属性</p></li></ul><p>一个元素最多可以拥有多个属性，属性值必须用双引号 <code>&quot; &quot;</code> 或 单引号 <code>&#39; &#39;</code> 括住</p><ul><li>示例</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line">    &lt;person id=&quot;p1&quot;&gt;</span><br><span class="line">        &lt;name&gt;Tom&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;24&lt;/age&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure></div><h2 id="XML-解析的方法"><a href="#XML-解析的方法" class="headerlink" title="XML 解析的方法"></a>XML 解析的方法</h2><p>要想从XML中提取信息，就得解析XML，目前针对XML的解析有两种方式：</p><ul><li>SAX：从根元素开始，按照顺序一个元素一个元素的往下解析，可用于解析大、小文件</li><li>DOM：一次性将整个XML文档加载到内存中，适合较小的文件</li></ul><p><code>iOS</code> 中解析 <code>XML</code> 有两种：</p><ul><li><p>苹果原生：使用 <code>NSXMLParse</code>，SAX方式解析，使用简答</p></li><li><p>第三方框架：<code>libxml2、GDataXML</code></p><ul><li><code>libxml2</code> 纯 c 语音，默认包含在iOS SDK中，同时支持DOM和SAX方式解析</li><li><code>GDataXMLDOM</code> 解析，由 <code>google</code> 基于 <code>libxml2</code> 开发</li></ul></li></ul><p>解析XML大文件建议用：<code>NSXMLParse、libxml2</code><br>解析XML小文件上述三种都可以</p><h2 id="NSXMLParse-使用"><a href="#NSXMLParse-使用" class="headerlink" title="NSXMLParse 使用"></a>NSXMLParse 使用</h2><ul><li><p>添加NSXMLParserDelegate协议</p></li><li><p>获取XML文件，初始化NSXMLParser，并开启解析</p></li><li><p>实现协议中的方法</p></li></ul><p><strong>XMLElement 文件</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@interface XMLElement : NSObject</span><br><span class="line">// 元素名称</span><br><span class="line">@property (nonatomic,strong)NSString *name;</span><br><span class="line">//元素节点文本</span><br><span class="line">@property (nonatomic,strong)NSMutableString *text;</span><br><span class="line">@property (nonatomic,strong)NSDictionary *attribute;</span><br><span class="line">@property (nonatomic,strong)XMLElement *parent;</span><br><span class="line">@property (nonatomic,strong)NSMutableArray&lt;XMLElement *&gt; *childElement;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">🔽</span><br><span class="line"></span><br><span class="line">#import &quot;XMLElement.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation XMLElement</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _text=[[NSMutableString alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (NSMutableArray&lt;XMLElement *&gt; *)childElement&#123;</span><br><span class="line">    if (!_childElement) &#123;</span><br><span class="line">        _childElement = [[NSMutableArray alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    return _childElement;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)description&#123;</span><br><span class="line">    NSDictionary *dic = [self convertToDic];</span><br><span class="line">    if ([NSJSONSerialization isValidJSONObject:dic]) &#123;</span><br><span class="line">        NSError *error;</span><br><span class="line">        NSData *jsonData=[NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;error];</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            return @&quot;&#123;&#125;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (jsonData) &#123;</span><br><span class="line">            @try &#123;</span><br><span class="line">                NSString *jsonStr = [[NSString alloc]initWithData:jsonData encoding:NSUTF8StringEncoding];</span><br><span class="line">                return jsonStr;</span><br><span class="line">            &#125; @catch (NSException *exception) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return @&quot;&#123;&#125;&quot;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">- (NSDictionary *)convertToDic&#123;</span><br><span class="line">    NSMutableDictionary *dic = [[NSMutableDictionary alloc] init];</span><br><span class="line">    if (self.name) &#123;</span><br><span class="line">        dic[self.name]=self.text;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.attribute &amp;&amp; self.attribute.count &gt; 0) &#123;</span><br><span class="line">        [dic addEntriesFromDictionary:self.attribute];</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.childElement &amp;&amp; self.childElement.count &gt; 0) &#123;</span><br><span class="line">        NSMutableArray *child=[[NSMutableArray alloc]init];</span><br><span class="line">        for (XMLElement *element in self.childElement) &#123;</span><br><span class="line">            NSDictionary *childDic = [element convertToDic];</span><br><span class="line">            if (element.childElement &amp;&amp; element.childElement.count &gt; 0) &#123;</span><br><span class="line">                [child addObject:childDic];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                [dic addEntriesFromDictionary:childDic];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (child.count &gt; 0) &#123;</span><br><span class="line">            dic[@&quot;child&quot;]=child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dic;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p><strong>XMLParserManager 文件</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;XMLElement.h&quot;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">typedef void(^ParserXMLCompletion) (BOOL success, XMLElement * _Nullable data,NSError * _Nullable error);</span><br><span class="line">@interface XMLParserManager : NSObject</span><br><span class="line">@property(nonatomic,copy)ParserXMLCompletion completion;</span><br><span class="line">- (void)parserXMLWithUrl:(NSURL *)url completion:(ParserXMLCompletion)completion;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">🔽</span><br><span class="line"></span><br><span class="line">#import &quot;XMLParserManager.h&quot;</span><br><span class="line"></span><br><span class="line">@interface XMLParserManager()&lt;NSXMLParserDelegate&gt;</span><br><span class="line">@property (nonatomic,strong)NSXMLParser *parser;</span><br><span class="line">@property (nonatomic,strong)XMLElement *rootElement;</span><br><span class="line">@property (nonatomic,strong)XMLElement *currentElement;</span><br><span class="line">@end</span><br><span class="line">@implementation XMLParserManager</span><br><span class="line">- (void)parserXMLWithUrl:(NSURL *)url completion:(ParserXMLCompletion)completion&#123;</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        self.completion = completion;</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        NSInputStream *fileInput=[[NSInputStream alloc] initWithURL:url];</span><br><span class="line">        // 创建一个解析器</span><br><span class="line">        _parser = [[NSXMLParser alloc] initWithStream:fileInput];</span><br><span class="line">        // 设置代理</span><br><span class="line">        _parser.delegate = self;</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^&#123;</span><br><span class="line">            __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">            // 开始解析</span><br><span class="line">            [strongSelf.parser parse];</span><br><span class="line">            // 解析错误</span><br><span class="line">            if (weakSelf.parser.parserError) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    if (completion) &#123;</span><br><span class="line">                        completion(NO,nil,strongSelf.parser.parserError);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 文档开始</span><br><span class="line">-(void)parserDidStartDocument:(NSXMLParser *)parser&#123;</span><br><span class="line">    self.rootElement = nil;</span><br><span class="line">    self.currentElement = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 开始解析某个节点</span><br><span class="line"> parser xml对象</span><br><span class="line"> elementName 标签</span><br><span class="line"> namespaceURI 命名控件指向的链接</span><br><span class="line"> qName 命名控件名称</span><br><span class="line"> attributeDict 节点的所有属性</span><br><span class="line"> */</span><br><span class="line">-(void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary&lt;NSString *,NSString *&gt; *)attributeDict&#123;</span><br><span class="line"></span><br><span class="line">    if (!self.rootElement) &#123;</span><br><span class="line">        self.rootElement = [[XMLElement alloc]init];</span><br><span class="line">        self.currentElement = self.rootElement;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        XMLElement *element = [[XMLElement alloc]init];</span><br><span class="line">        // 父节点</span><br><span class="line">        element.parent = self.currentElement;</span><br><span class="line">        // 当前元素的子节点</span><br><span class="line">        [self.currentElement.childElement addObject:element];</span><br><span class="line">        element.name = elementName;</span><br><span class="line">        // 更换当前元素</span><br><span class="line">        self.currentElement = element;</span><br><span class="line">    &#125;</span><br><span class="line">    // 元素名和属性</span><br><span class="line">    self.currentElement.name = elementName;</span><br><span class="line">    self.currentElement.attribute = attributeDict;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当解析器找到开始标记和结束标记之间的字符时，调用这个方法解析当前节点的所有字符</span><br><span class="line">- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string&#123;</span><br><span class="line">    // 获取当前元素的内容</span><br><span class="line">    [self.currentElement.text appendString:string];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结束解析</span><br><span class="line">-(void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName&#123;</span><br><span class="line">    self.currentElement = self.currentElement.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文档结束</span><br><span class="line">-(void)parserDidEndDocument:(NSXMLParser *)parser&#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    if (self &amp;&amp; self.completion) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">            strongSelf.completion(YES, strongSelf.rootElement, nil);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解析失败</span><br><span class="line">- (void)parser:(NSXMLParser *)parser validationErrorOccurred:(NSError *)validationError&#123;</span><br><span class="line">    if (self.completion) &#123;</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">            strongSelf.completion(NO, nil,validationError);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p><strong>VC 调用</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;XMLParserManager.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,strong)XMLParserManager *manager;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    [self parserXML];</span><br><span class="line">&#125;</span><br><span class="line">-(void)parserXML&#123;</span><br><span class="line">    NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;xmlText&quot; ofType:@&quot;xml&quot;];</span><br><span class="line">    NSURL *url = [NSURL fileURLWithPath:path];</span><br><span class="line">    _manager=[[XMLParserManager alloc]init];</span><br><span class="line">    [_manager parserXMLWithUrl:url completion:^(BOOL success, XMLElement * _Nullable data, NSError * _Nullable error) &#123;</span><br><span class="line">            if (success) &#123;</span><br><span class="line">                NSLog(@&quot;%@&quot;,data);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                NSLog(@&quot;error = %@&quot;,error);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    NSLog(@&quot;start == &quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><h2 id="GDataXML-使用"><a href="#GDataXML-使用" class="headerlink" title="GDataXML 使用"></a>GDataXML 使用</h2><ul><li>GDataXMLDocument：xml解析入口</li><li>GdataXMLElement：保存查找的数据</li><li>GdataXMLNode：保存解析的数据</li></ul><p><strong>第一步：集成 GDataXML-HTML</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target &#x27;XML文件解析&#x27; do</span><br><span class="line">  # Comment the next line if you don&#x27;t want to use dynamic frameworks</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  pod &#x27;GDataXML-HTML&#x27;, &#x27;~&gt; 1.4.1&#x27;</span><br><span class="line"></span><br><span class="line">  # Pods for XML文件解析</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></div><p><strong>第二步：项目中配置</strong></p><ul><li><p>pod 安装 GDataXML</p></li><li><p>选中target -&gt; Build Settings -&gt; Link Binary With Libraried，搜索添加 <code>libxml2</code></p></li><li><p>Header Search Paths 添加 <code>/usr/include/libxml2</code> </p></li><li><p>Other Linker Flags 添加 <code>-lxml2</code></p></li><li><p>引入头文件使用</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)GDataParserXML&#123;</span><br><span class="line">    // 加载xmlwen文件</span><br><span class="line">    NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;xmlText&quot; ofType:@&quot;xml&quot;];</span><br><span class="line">    NSURL *url = [NSURL fileURLWithPath:path];</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfURL:url];</span><br><span class="line">    NSError *error= nil;</span><br><span class="line">    GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithData:data error:&amp;error];</span><br><span class="line">    // 拿到根元素，得到根元素下所有子孙元素</span><br><span class="line">    NSArray * elementList =[doc.rootElement elementsForName:@&quot;book&quot;];</span><br><span class="line">    for (GDataXMLElement *element in elementList) &#123;</span><br><span class="line">        NSString *title=((GDataXMLElement *)[[element elementsForName:@&quot;title&quot;] firstObject]).stringValue;</span><br><span class="line">        NSString *author=((GDataXMLElement *)[[element elementsForName:@&quot;author&quot;] firstObject]).stringValue;</span><br><span class="line">        NSString *year=((GDataXMLElement *)[[element elementsForName:@&quot;year&quot;] firstObject]).stringValue;</span><br><span class="line">        NSString *price=((GDataXMLElement *)[[element elementsForName:@&quot;price&quot;] firstObject]).stringValue;</span><br><span class="line">        NSLog(@&quot;title = %@  author = %@  year = %@ price = %@&quot;,title,author,year,price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在 &lt;code&gt;iOS&lt;/code&gt; 开发中，常见的数据传输格式有两种：&lt;code&gt;JSON和XML&lt;/code&gt;。&lt;/p</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
