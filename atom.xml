<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张建的博客</title>
  <icon>https://www.gravatar.com/avatar/134cc2bfaf649e446f661778f4112fca</icon>
  <subtitle>成功的道路上只有荆棘，没有坦途</subtitle>
  <link href="https://www.bboyzj.cn/atom.xml" rel="self"/>
  
  <link href="https://www.bboyzj.cn/"/>
  <updated>2023-03-30T05:45:47.542Z</updated>
  <id>https://www.bboyzj.cn/</id>
  
  <author>
    <name>小J</name>
    <email>13718004742@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>性能优化05：Network 网络</title>
    <link href="https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605%EF%BC%9ANetwork%20%E7%BD%91%E7%BB%9C/"/>
    <id>https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605%EF%BC%9ANetwork%20%E7%BD%91%E7%BB%9C/</id>
    <published>2023-09-10T04:13:29.000Z</published>
    <updated>2023-03-30T05:45:47.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="弱网优化"><a href="#弱网优化" class="headerlink" title="弱网优化"></a>弱网优化</h1><ul><li><p>所谓弱网络，指在网络不好的情况下使用APP，如 <code>2G、3G网络</code>，用户的网络速度基本在 <code>10k/s~60k/s</code>。</p></li><li><p>考虑海外应用的话，就必须考虑弱网优化的方案了。</p></li><li><p>苹果建议，使用苹果内置的 <code>Network Link Conditioner</code> 来模拟网络环境处理 <code>APP</code> 的体验问题，在Xcode和手机都可以开启</p></li></ul><h1 id="Xcode：系统偏好设置"><a href="#Xcode：系统偏好设置" class="headerlink" title="Xcode：系统偏好设置"></a>Xcode：系统偏好设置</h1><h1 id="iPhone：开发者-gt-Network-Link-Conditioner"><a href="#iPhone：开发者-gt-Network-Link-Conditioner" class="headerlink" title="iPhone：开发者 -&gt; Network Link Conditioner"></a>iPhone：开发者 -&gt; Network Link Conditioner</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;弱网优化&quot;&gt;&lt;a href=&quot;#弱网优化&quot; class=&quot;headerlink&quot; title=&quot;弱网优化&quot;&gt;&lt;/a&gt;弱网优化&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;所谓弱网络，指在网络不好的情况下使用APP，如 &lt;code&gt;2G、3G网络&lt;/code&gt;，用户的网络速度基</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>性能优化04：Energy 耗电</title>
    <link href="https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604%EF%BC%9AEnergy%20%E8%80%97%E7%94%B5/"/>
    <id>https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604%EF%BC%9AEnergy%20%E8%80%97%E7%94%B5/</id>
    <published>2023-09-10T04:13:29.000Z</published>
    <updated>2023-03-30T05:53:39.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>所有应用程序在执行网络操作、更新用户界面或在CPU上运行代码时都会消耗能量。随着用户越来越多地依赖电池电量，以及应用程序的激增，能效已成为用户体验中不可或缺的一部分。</p><h1 id="电池寿命"><a href="#电池寿命" class="headerlink" title="电池寿命"></a>电池寿命</h1><p>随着能源效率的下降，<code>电池</code> 的寿命也会下降。同时消耗过多的资源会导致界面滞后，对用户输入的响应会很慢。随着越来越多的应用程序使用越来越多的资源，系统工作起来越来越努力，速度也越来越快，设备的物理温度也在逐渐升高。当这种情况发生时，系统会采取措施将温度降低到更容易接受的水平。</p><h1 id="能量消耗的因素"><a href="#能量消耗的因素" class="headerlink" title="能量消耗的因素"></a>能量消耗的因素</h1><ol><li><p>CPU: CPU是能源的主要消耗者。高CPU使用周期会迅速耗尽用户的电池。 CPU使用率超过20%就会快速耗干电池电量——建议只在必要时通过 <code>批处理、调度和优先级排序</code> 来完成工作。</p></li><li><p>GPU: 图形处理器(显卡的处理器)，乱使用GPU会导致交互差，并且降低电池寿命。</p></li><li><p>Network：大多数iOS应用程序执行网络操作。当联网发生时，蜂窝无线电和Wi-Fi等组件就会启动并消耗能量。通过 <code>批量处理和减少事务、压缩数据和适当处理错误</code>，您的应用程序可以为节能做出重大贡献。</p></li><li><p>Location: 许多应用程序发出位置请求是为了记录用户的物理活动或提供基于环境的警报。能量消耗随着精确度的提高和位置请求的延长而增加。你的应用应该尽可能减少定位活动的准确性和持续时间。当不再需要时停止位置请求。</p></li><li><p>Background: <code>后台</code> 状态App仍会消耗电量，App要按需执行后台操作，并使用延迟APNS来保证系统运算高效执行。另外，在app进入后台状态是，立即减少动作，并且通知系统一次这些动作已经完成</p></li><li><p>Bluetooth: 长时间的 <code>蓝牙</code> 活动会耗尽iOS设备和蓝牙设备的电池。只要可能，批处理和缓冲蓝牙活动，并减少对数据的轮询。</p></li><li><p>Device wakes：iOS设备依靠睡眠来延长电池寿命。无论设备何时唤醒，都会有很高的开销成本，因为必须为屏幕和其他资源提供电源。你的应用程序，尤其是在后台操作时，应该尽可能空闲，除非绝对必要，避免用推送通知或其他活动唤醒设备</p></li></ol><h1 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h1><ol><li><p>Time Profile：时间分析器分析模板。使用此模板对正在运行的进程执行低开销的基于时间的采样。Time Profiler 监视应用程序中正在运行的线程，并定期采样。为每个样本收集完整的回溯，允许您深入查看样本，以准确找到代码中花费大量时间的位置。</p></li><li><p>Animation Hitches：核心动画分析模板。使用此模板可以测量图形性能和CPU使用率。启用模板 Core Animation 的 <code>Flash Updated Regions</code> 设置，以查看应用中发生的每个屏幕更新，并观察不必要或意外的更新。</p></li><li><p>Activity Monitor: 活动监视器分析模板。使用此模板可以监视整体CPU，磁盘I&#x2F;O和网络使用情况。</p></li></ol><h1 id="Energy-log调试和演示"><a href="#Energy-log调试和演示" class="headerlink" title="Energy log调试和演示"></a>Energy log调试和演示</h1><ol><li>检查第一步，是通过xcode开发工具的 <code>energy impact</code> 来整体查看app的耗电情况。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303231852146.png"                                     ></p><p>Overhead：表示开销，包括CPU的唤起，无线电模组(蓝牙&amp;WiFi)，和其他系统资源的调用等。</p><ol start="2"><li>检查第二步：通过instrument工具的 <code>energy log</code> 来检测具体的耗电模块。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303231853126.png"                                     ></p><h1 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h1><ol><li>cpu层面的优化</li></ol><ul><li>尽量降低CPU</li><li>少使用定时器</li><li>优化I&#x2F;O操作<ul><li>写入数据最好一次性写入</li><li>读取数据最好使用GCD异步操作</li><li>数据流比较大，建议使用数据库</li></ul></li><li>适当使用多线程，不宜过多，不要阻塞主线程</li><li>优化算法，减少循环次数</li><li>避免庞大的 <code>xib、storyBoard</code>， 尽量使用纯代码开发</li></ul><ol start="2"><li>GPU 层面的优化</li></ol><ul><li>减少视图刷新，按需刷新；</li><li>尽量少使用圆角和透明度；</li></ul><ol start="3"><li>Network 网络请求层面的优化</li></ol><ul><li>减少、压缩网络数据</li><li>如果多次请求的结果是相同的，尽量使用缓存</li><li>使用断点续传，否则网络不稳定时可能多次传输相同的内容</li><li>网络不可用时，不要尝试执行网络请求</li><li>让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间</li><li>批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载</li></ul><ol start="4"><li>Location 定位层面优化</li></ol><ul><li>如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电</li><li>如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务</li><li>尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest</li><li>需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新</li><li>尽量不要使用startMonitoringSignificantLocationChanges，优先考虑startMonitoringForRegion</li></ul><ol start="5"><li>Bluetooth, Background</li></ol><ul><li>蓝牙按需取用，定位之后要关闭或降低定位频率，进入后台关闭定位，停止定时器运行等</li></ul><ol start="4"><li>硬件检测优化(不常用)</li></ol><ul><li>用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;所有应用程序在执行网络操作、更新用户界面或在CPU上运行代码时都会消耗能量。随着用户越来越多地依赖电池电量，以及应用程序的激增，能效已成为用</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>性能优化06：启动优化</title>
    <link href="https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>https://www.bboyzj.cn/2023/09/10/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</id>
    <published>2023-09-10T04:13:29.000Z</published>
    <updated>2023-03-30T06:10:57.318Z</updated>
    
    <content type="html"><![CDATA[<p>启动优化查看以下三篇文章：</p><p><a href="https://www.bboyzj.cn/2021/05/04/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8632%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">OC底层原理32：启动优化（一）基本概念</a></p><p><a href="https://www.bboyzj.cn/2021/05/11/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8633%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/">OC底层原理33：启动优化（二）优化建议</a></p><p><a href="https://www.bboyzj.cn/2021/05/17/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8634%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%87%8D%E6%8E%92/">OC底层原理34：启动优化（三）二进制重排</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;启动优化查看以下三篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bboyzj.cn/2021/05/04/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8632%EF%BC%9A%E5%</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>OC学习53：后台保活方案</title>
    <link href="https://www.bboyzj.cn/2023/05/28/OC/OC%E5%AD%A6%E4%B9%A053%EF%BC%9A%E5%90%8E%E5%8F%B0%E4%BF%9D%E6%B4%BB%E6%96%B9%E6%A1%88/"/>
    <id>https://www.bboyzj.cn/2023/05/28/OC/OC%E5%AD%A6%E4%B9%A053%EF%BC%9A%E5%90%8E%E5%8F%B0%E4%BF%9D%E6%B4%BB%E6%96%B9%E6%A1%88/</id>
    <published>2023-05-28T13:07:44.000Z</published>
    <updated>2023-05-28T14:17:34.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>实现后台保活方案前，我们需要了解iOS应用程序的 <code>生命周期</code>。因为iOS系统的资源是有限的的，应用程序在前台和后台的状态是不一样的。在后台，程序会受到系统的限制，以提高电池使用和用户体验。</p><h1 id="应用程序的生命周期"><a href="#应用程序的生命周期" class="headerlink" title="应用程序的生命周期"></a>应用程序的生命周期</h1><ol><li>应用程序状态</li></ol><ul><li><p>Not Running：未运行 - 程序未启动</p></li><li><p>Inactive：未激活 - 程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态</p></li><li><p>Active：激活 - 程序在前台运行且接收到事件。这也是前台的一个正常的模式</p></li><li><p>Background：后台 - 程序在后台而且能执行代码。大多数程序进入这个状态后会在这个状态上停留一会儿。时间到了之后会进入 <code>挂起(Suspended)状态</code>。有的程序经过特殊的请求可以长期处于Background状态</p></li><li><p>Suspended：挂起 - 程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中，当系统内存低时，系统就把挂起的程序清除掉，为前提程序提供更多的内存。</p></li></ul><p>下图是程序状态变化图：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305282120170.png"                                     ></p><ol start="2"><li>应用程序状态的代理回调</li></ol><ul><li>程序进程启动但还没进入状态保存</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br></pre></td></tr></table></figure></div><ul><li>启动基本完成程序准备开始运行</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br></pre></td></tr></table></figure></div><ul><li>程序将要进入 <code>非活动状态</code> 执行，再此期间，应用程序不接受消息或事件，比如：来电话了</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationWillResignActive:(UIApplication *)application</span><br></pre></td></tr></table></figure></div><ul><li>当应用程序入活动状态执行</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application </span><br></pre></td></tr></table></figure></div><ul><li>当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</span><br></pre></td></tr></table></figure></div><ul><li>当程序从后台将要重新回到前台时候调用</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationWillEnterForeground:(UIApplication *)application</span><br></pre></td></tr></table></figure></div><ul><li>当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作。这个需要要设置UIApplicationExitsOnSuspend的键值。</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationWillTerminate:(UIApplication *)application</span><br></pre></td></tr></table></figure></div><ol start="3"><li>应用程序启动的执行顺序</li></ol><ul><li>启动程序</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">willFinishLaunchingWithOptions</span><br><span class="line">didFinishLaunchingWithOptions</span><br><span class="line">applicationDidBecomeActive</span><br></pre></td></tr></table></figure></div><ul><li>按下home键</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">applicationWillResignActive</span><br><span class="line">applicationDidEnterBackground</span><br></pre></td></tr></table></figure></div><ul><li>再打开程序</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">applicationWillEnterForeground</span><br><span class="line">applicationDidBecomeActive</span><br></pre></td></tr></table></figure></div><ol start="4"><li>应用程序的生命周期</li></ol><ul><li>应用程序进入前台</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305282143266.png"                                     ></p><ul><li>应用程序进入后台</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305282143126.png"                                     ></p><ul><li>关于 main 函数</li></ul><p>main函数是程序启动的入口，在iOS app中，main函数的功能被最小化，它的主要工作都交给了UIKit framework：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([MyAppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><code>UIApplicationMain</code> 函数有四个参数，你不需要改变这些参数值，不过我们也需要理解这些参数和程序是如何开始的</p><p><code>argc</code> 和 <code>argv</code> 参数包含了系统带过来的 <code>启动时间</code>。第三个参数确定了主要应用程序类的名称，这个参数指定为nil，这样 <code>UIKit</code> 就会使用默认的程序类 <code>UIApplication</code>。第四个参数是程序自定义的 <code>代理类名</code>，这个类 <code>负责系统和代码之间的交互</code>。它一般在Xcode新建项目时会自动生成。</p><p>另外 <code>UIApplicationMain</code> 函数加载了程序主界面的文件。虽然这个函数加载了界面文件，但是没有放到应用程序的windows上，你需要在Delegate的<code>application:willFinishLaunchingWithOptions</code> 方法中加载它。</p><p>一个应用程序可以有一个主的storyboard文件或者有一个主的nib文件，但不能同时有两个存在。</p><p>如果程序在启动时没有自动加载主要的故事版或nib文件，你可以 <code>application:willFinishLaunchingWithOptions</code> 方法里准备windows的展示。</p><h1 id="后台保活方案"><a href="#后台保活方案" class="headerlink" title="后台保活方案"></a>后台保活方案</h1><p>iOS 有两种后台运行保活方案：</p><ul><li><p>第一种：无声音乐保活（即在后台开启音频播放，只不过不需要播放出音量且不能影响其他音乐播放软件）</p></li><li><p>第二种：Background Task</p><ul><li><p>iOS 13.0以后只能申请短短的30s</p></li><li><p>在iOS7.0~iOS13.0以前可以申请3分钟，可以经过处理申请更多的保活时间</p></li></ul></li></ul><ol><li>无声音乐保活</li></ol><ul><li>第一步：打开应用的 <code>Target</code> 页面 <code>Signing &amp; Cabailities</code>，添加 <code>Capability（Background Modes）</code> 勾选 <code>Audio，AirPlay，and Picture in Picture</code> 选项</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305282153148.png"                                     ></p><ul><li>第二步：我们需要监听 UIApplicationWillEnterForegroundNotification（应用进入前台通知）和 UIApplicationDidEnterBackgroundNotification（应用进入后台通知）</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 监听 前后台</span><br><span class="line">- (void)addNotification&#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(appWillEnterForeground) name:UIApplicationWillEnterForegroundNotification object:nil];</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(appDidEnterBackground) name:UIApplicationDidEnterBackgroundNotification object:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>第三步：编写音乐播放类</li></ul><p>BackgroundTool.h</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;BackgroundTool.h&quot;</span><br><span class="line">#import &lt;AVFoundation/AVFoundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface BackgroundTool ()&lt;AVAudioPlayerDelegate&gt;</span><br><span class="line">@property (nonatomic,strong)AVAudioPlayer * audioPlayer; // 音频播放器</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p>Background.m </p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 音乐 播放 停止</span><br><span class="line">// 开始播放音乐</span><br><span class="line">- (void)startPlayer&#123;</span><br><span class="line">    AVAudioSession *session = [AVAudioSession sharedInstance];</span><br><span class="line">    if (@available(iOS 10.0, *)) &#123;</span><br><span class="line">        [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayAndRecord withOptions:(AVAudioSessionCategoryOptionMixWithOthers | AVAudioSessionCategoryOptionAllowBluetooth | AVAudioSessionCategoryOptionAllowBluetoothA2DP) error:nil];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayAndRecord withOptions:(AVAudioSessionCategoryOptionMixWithOthers | AVAudioSessionCategoryOptionDefaultToSpeaker) error:nil];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    [session setActive:YES error:nil];</span><br><span class="line">    </span><br><span class="line">    // 播放资源</span><br><span class="line">    NSURL * url = [[NSBundle mainBundle] URLForResource:@&quot;backgroundVolue.mp3&quot; withExtension:nil];</span><br><span class="line">    self.audioPlayer = [[AVAudioPlayer alloc] initWithContentsOfURL:url error:nil];</span><br><span class="line">    self.audioPlayer.volume = 0.01;</span><br><span class="line">    [self.audioPlayer prepareToPlay];</span><br><span class="line">    [self.audioPlayer setDelegate:self];</span><br><span class="line">    self.audioPlayer.numberOfLoops = -1;</span><br><span class="line">    BOOL ret = [self.audioPlayer play];</span><br><span class="line">    if (!ret) &#123;</span><br><span class="line">        DLogInfo(@&quot;play failed,please turn on audio background mode&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    DLogInfo(@&quot;star play success&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 停止播放音乐</span><br><span class="line">- (void)stopPlayer&#123;</span><br><span class="line">    [self.audioPlayer stop];</span><br><span class="line">    self.audioPlayer = nil;</span><br><span class="line">    AVAudioSession * session = [AVAudioSession sharedInstance];</span><br><span class="line">    [session setActive:NO error:nil];</span><br><span class="line">    DLogInfo(@&quot;stop in play background success&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ol start="2"><li>Background Task</li></ol><ul><li>第一步：我们需要监听 UIApplicationWillEnterForegroundNotification（应用进入前台通知）和 UIApplicationDidEnterBackgroundNotification（应用进入后台通知）</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 监听 前后台</span><br><span class="line">- (void)addNotification&#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(appWillEnterForeground) name:UIApplicationWillEnterForegroundNotification object:nil];</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(appDidEnterBackground) name:UIApplicationDidEnterBackgroundNotification object:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>第二步：使用 Background Task 申请保活时间，在应用进入后台时开启保活，在应用进入前台时关闭保活</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,assign)UIBackgroundTaskIdentifier backgroundTaskIdentifier; // 后台任务</span><br><span class="line">@property (nonatomic,strong)NSTimer * timer; // 计时器</span><br><span class="line">@property (nonatomic,assign)int applyTimes; // 申请时间</span><br><span class="line"></span><br><span class="line">#pragma mark - 系统任务</span><br><span class="line">// 开始系统任务</span><br><span class="line">- (void)startSystemTask&#123;</span><br><span class="line">    // 申请</span><br><span class="line">    self.backgroundTaskIdentifier = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        DLogInfo(@&quot;BackgroundTask time gone&quot;);</span><br><span class="line">        [self stopSystemTask];</span><br><span class="line">    &#125;];</span><br><span class="line">    // 开启计时器</span><br><span class="line">    [self startTimer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 申请更多保活时间</span><br><span class="line">- (void)applyForMoreTime&#123;</span><br><span class="line">    if ([UIApplication sharedApplication].backgroundTimeRemaining &lt; 10) &#123;</span><br><span class="line">        self.applyTimes += 1;</span><br><span class="line">        DLogInfo(@&quot;Try to apply for more time:%d&quot;,self.applyTimes);</span><br><span class="line">        [[UIApplication sharedApplication] endBackgroundTask:self.backgroundTaskIdentifier];</span><br><span class="line">        self.backgroundTaskIdentifier = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">            [self stopSystemTask];</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 开始计时器</span><br><span class="line">- (void)startTimer&#123;</span><br><span class="line">    // 开始计时器 申请更多保活时间</span><br><span class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:5.0 target:self selector:@selector(applyForMoreTime) userInfo:nil repeats:YES];</span><br><span class="line">    [self.timer fire]; // 在这里我判断了申请次数，加上第一次申请保活时间的次数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 停止计时器</span><br><span class="line">- (void)stopTimer&#123;</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">    self.timer = nil;</span><br><span class="line">    self.applyTimes = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结束系统任务</span><br><span class="line">- (void)stopSystemTask&#123;</span><br><span class="line">    if (self.backgroundTaskIdentifier) &#123;</span><br><span class="line">        [[UIApplication sharedApplication] endBackgroundTask:self.backgroundTaskIdentifier];</span><br><span class="line">        self.backgroundTaskIdentifier = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;实现后台保活方案前，我们需要了解iOS应用程序的 &lt;code&gt;生命周期&lt;/code&gt;。因为iOS系统的资源是有限的的，应用程序在前台和后台的</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习51：App之间相互跳转</title>
    <link href="https://www.bboyzj.cn/2023/05/25/OC/OC%E5%AD%A6%E4%B9%A052%EF%BC%9AApp%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E8%B7%B3%E8%BD%AC/"/>
    <id>https://www.bboyzj.cn/2023/05/25/OC/OC%E5%AD%A6%E4%B9%A052%EF%BC%9AApp%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E8%B7%B3%E8%BD%AC/</id>
    <published>2023-05-25T13:28:55.000Z</published>
    <updated>2023-05-25T13:28:56.694Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>OC学习51：Postman工具使用</title>
    <link href="https://www.bboyzj.cn/2023/05/25/OC/OC%E5%AD%A6%E4%B9%A051%EF%BC%9APostman%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.bboyzj.cn/2023/05/25/OC/OC%E5%AD%A6%E4%B9%A051%EF%BC%9APostman%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</id>
    <published>2023-05-25T12:54:49.000Z</published>
    <updated>2023-05-28T13:04:04.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在开发中，我们经常会对接口进行调试，那么我们在没有实现自己网络请求的情况下，一般会通过postman 去测试接口是否是好用的</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol><li><p>打开 <code>postman</code> ，新建一个 <code>request</code> 请求，并输入 <code>url</code></p></li><li><p>由于 <code>postman</code> 的 <code>post Body</code> 请求是 <code>JSON</code> 格式的，所以在 <code>postman</code> 中点击 <code>body</code>，选择 <code>RAW</code>，在选择 <code>JSON</code> 格式，把接口信息中的body输入到空白栏中，如下图：</p></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305282041043.png"                                     ></p><ol start="3"><li>点击Send按钮，查看响应结果；</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305282041321.png"                                     ></p><ol start="4"><li><code>postman</code> 中 <code>post</code> 数据类型说明</li></ol><ul><li><p>none: 表示不传递数据</p></li><li><p>form-data: http请求中的 <code>multipart/form-data</code>,它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开，<code>既可以上传键值对，也可以上传文件</code></p></li><li><p>x-www-form-urlencoded: application&#x2F;x-www-form-urlencoded，会将表单内的数据转换为 <code>键值对</code></p></li><li><p>raw: 可以上传任意格式的文本，可以上传 <code>text、json、xml、html</code> 等；</p></li><li><p>binary: Content-Type:application&#x2F;octet-stream,只可以上传 <code>二进制数据</code>，通常用来上传，由于没有键值，所以一次只能上传一个文件</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在开发中，我们经常会对接口进行调试，那么我们在没有实现自己网络请求的情况下，一般会通过postman 去测试接口是否是好用的&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Xcode学习06：Xcode设置App允许运行的最低iOS系统版本</title>
    <link href="https://www.bboyzj.cn/2023/05/25/Xcode/Xcode%E5%AD%A6%E4%B9%A006%EF%BC%9AXcode%E8%AE%BE%E7%BD%AEApp%E5%85%81%E8%AE%B8%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%80%E4%BD%8EiOS%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC/"/>
    <id>https://www.bboyzj.cn/2023/05/25/Xcode/Xcode%E5%AD%A6%E4%B9%A006%EF%BC%9AXcode%E8%AE%BE%E7%BD%AEApp%E5%85%81%E8%AE%B8%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%80%E4%BD%8EiOS%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC/</id>
    <published>2023-05-25T07:03:07.000Z</published>
    <updated>2023-05-28T13:01:22.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>App项目所必须要设置的，允许App运行的最低iOS系统版本。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ol><li>打开Xcode工程，<code>target-&gt;Build Settings -&gt; Deployment -&gt;iOS Deployment Target</code></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16849984137282.jpg"                                     ></p><p>由上图可知，我目前能配置的最低iOS系统是 <code>iOS 11.0</code>，明显不能满足我的开发要求，那么要怎么办呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;App项目所必须要设置的，允许App运行的最低iOS系统版本。&lt;/p&gt;
&lt;h1 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;h</summary>
      
    
    
    
    <category term="Xcode" scheme="https://www.bboyzj.cn/categories/Xcode/"/>
    
    
    <category term="Xcode-常用" scheme="https://www.bboyzj.cn/tags/Xcode-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>OC学习50：用清华大学镜像解决Cocoapods install慢的问题</title>
    <link href="https://www.bboyzj.cn/2023/05/25/OC/OC%E5%AD%A6%E4%B9%A050%EF%BC%9A%E7%94%A8%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E9%95%9C%E5%83%8F%E8%A7%A3%E5%86%B3Cocoapods-install%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://www.bboyzj.cn/2023/05/25/OC/OC%E5%AD%A6%E4%B9%A050%EF%BC%9A%E7%94%A8%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E9%95%9C%E5%83%8F%E8%A7%A3%E5%86%B3Cocoapods-install%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-05-25T05:40:45.000Z</published>
    <updated>2023-05-25T05:42:42.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/" >清华大学镜像网址 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p><h1 id="替换镜像源"><a href="#替换镜像源" class="headerlink" title="替换镜像源"></a>替换镜像源</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo remove master</span><br><span class="line">$ pod repo add master https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git</span><br><span class="line">$ pod repo update</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>or </p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.cocoapods/repos</span><br><span class="line">$ pod repo remove master</span><br><span class="line">$ git clone https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git master</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://mirrors.tuna.tsinghua.edu.cn/&quot; &gt;清华大学镜像</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习49：App内打开URL的方法</title>
    <link href="https://www.bboyzj.cn/2023/05/25/OC/OC%E5%AD%A6%E4%B9%A049%EF%BC%9AApp%E5%86%85%E6%89%93%E5%BC%80URL%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://www.bboyzj.cn/2023/05/25/OC/OC%E5%AD%A6%E4%B9%A049%EF%BC%9AApp%E5%86%85%E6%89%93%E5%BC%80URL%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2023-05-25T05:24:36.000Z</published>
    <updated>2023-05-28T15:27:25.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>iOS 系统由于其 Sandbox的安全机制，系统内各App之间不能共享信息；官方给出了一些方案 <code>URL Scheme/Universal Link</code> 等以解决 App 之间的通信</p><h1 id="原生App之间的跳转"><a href="#原生App之间的跳转" class="headerlink" title="原生App之间的跳转"></a>原生App之间的跳转</h1><p>原生App间的相互跳转，也可以称为白名单App间的跳转，常见用法是第三方分享、登录、支付等，假设有 <code>AppA</code> 和 <code>AppB</code> 两个应用，实现 <code>AppA</code> 启动 <code>AppB</code> 的，有两种方案：</p><ul><li><p>第一种方法：URL Scheme</p></li><li><p>第二种方法：Unversal Link</p></li></ul><ol><li>URL Scheme</li></ol><ul><li>将 <code>AppB</code> 注册到手机系统中，应用 <code>AppB -&gt; Target -&gt; Info -&gt; URL Types</code> 自定义一个 <code>URL Schemes</code> 如：schemeb</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16852867380772.jpg"                                     ></p><ul><li>在 <code>AppA</code> 中将 <code>AppB</code> 列入 白名单，<code>AppA -&gt; Target -&gt; Info.plist</code> 中添加 <code>Queried URL Schemes</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305282322342.png"                                     ></p><ul><li>AppA 启动 AppB</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)clickBtn&#123;</span><br><span class="line">    /*</span><br><span class="line">    如果想跳转到AppB指定页面。URL中添加指定页面的路径：例如：schemeb://home</span><br><span class="line">    */</span><br><span class="line">    NSURL * scheme_b = [NSURL URLWithString:@&quot;schemeb://&quot;];</span><br><span class="line">    if ([[UIApplication sharedApplication] canOpenURL:scheme_b]) &#123;</span><br><span class="line">        if (@available(iOS 10.0, *)) &#123;</span><br><span class="line">            [[UIApplication sharedApplication] openURL:scheme_b</span><br><span class="line">                    options:@&#123;&#125; completionHandler:^(BOOL success) &#123;</span><br><span class="line">                        </span><br><span class="line">            &#125;];;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            [[UIApplication sharedApplication] openURL:scheme_b];;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        NSLog(@&quot;未找到b应用&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><p>AppB中接收到AppA的URL进行处理，App处于后台和未启动要分别处理</p><ul><li><p>AppB 未启动时，在 didFinishLaunchingWithOptions 中接收 URL，并做处理</p></li><li><p>AppB 在后台时，AppDelegate 中会调用 openURL 方法</p></li></ul></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><ol start="2"><li>Unversal Link</li></ol><h1 id="原生App与系统App间的跳转"><a href="#原生App与系统App间的跳转" class="headerlink" title="原生App与系统App间的跳转"></a>原生App与系统App间的跳转</h1><h1 id="原生App和网页间的跳转"><a href="#原生App和网页间的跳转" class="headerlink" title="原生App和网页间的跳转"></a>原生App和网页间的跳转</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;iOS 系统由于其 Sandbox的安全机制，系统内各App之间不能共享信息；官方给出了一些方案 &lt;code&gt;URL Scheme/Univ</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习48：OC项目中连接VPN的流程</title>
    <link href="https://www.bboyzj.cn/2023/05/25/OC/OC%E5%AD%A6%E4%B9%A048%EF%BC%9AOC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%BF%9E%E6%8E%A5VPN%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.bboyzj.cn/2023/05/25/OC/OC%E5%AD%A6%E4%B9%A048%EF%BC%9AOC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%BF%9E%E6%8E%A5VPN%E7%9A%84%E6%B5%81%E7%A8%8B/</id>
    <published>2023-05-25T01:37:09.000Z</published>
    <updated>2023-05-25T06:03:18.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>VPN 的英文全称是 <code>Virtual Private Network</code> ，翻译过来就是 <code>虚拟专用网络</code> 。虚拟专用网络(VPN)的主要功能是：在公用网络上建立专用网络，进行加密通讯。</p><h1 id="VPN作用"><a href="#VPN作用" class="headerlink" title="VPN作用"></a>VPN作用</h1><ol><li>VPN可以提高上网的安全性</li></ol><p>因为使用VPN时所用的网络访问都是加密进行的，所以使用VPN上网，安全性就更高，黑客很难截取用户的重要信息。如果你使用公共WIFI上网（例如在咖啡馆上网）时，需要做安全性强的操作（比如使用网上银行或网上投资账户），那么建议你连上VPN，因为这样会大大提高安全性。</p><ol start="2"><li>VPN可以隐藏上网者的身份</li></ol><p>因为VPN用户访问任何网站都是通过VPN服务器间接访问的，所以被访问的网站看到的访问者是VPN服务器，而不是VPN用户本人的电脑，这样VPN用户就能对要访问的网站隐藏自己的真正身份。</p><ol start="3"><li>VPN可以突破网站的地域限制</li></ol><p>很多网站都有地域限制，比如百度在不同省份提供不同的内容，北京用户访问百度时看到的是简体网站的内容，香港用户看到的是香港繁体的内容。网站的这种功能是通过查看访问者的IP地址属于哪个地区来实现的。而VPN可以用来突破这种IP限制。比如：香港的用户想要看到大陆版百度的内容，可以先连接到一台位于的VPN服务器。这样百度网站就会以为访问着来自大陆，而提供大陆版的内容。基于同样的道理，海外华人可以通过VPN网络封锁回国，观看仅限国内用户观看的视频内容。另外，VPN还可以用来在网上购物时省钱，因为一些酒店和租车网站对不同地区有不同的价格，本地人给予优惠，通过VPN换成不同地域的IP往往可以省钱。</p><ol start="4"><li>突破网络封锁</li></ol><p>为什么VPN可以用来网络封锁呢？先让我们看看网站是如何被封锁的。当用户外地想要访问公司ERP时，因为不是内网所以无法连接上。而如果你通过VPN访问这个网站，我们前面提到，VPN用户访问任何网站都是通过VPN服务器代为访问的，用户连接的其实是VPN服务器，而不是公司ERP（只是告诉VPN服务器你要访问公司ERP），然后VPN服务器去连接公司ERP，把公司ERP的内容回传给你。这样的话，实际与公司内部ERP交换信息的您的VPN服务器，而不是您的电脑，同时因为VPN传输是加密的，如果有黑对对您网络监控无法破解你和VPN服务器之间在传输什么信息。所以您公司的数据安全性大大增加。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>连接VPN的代码是由我一个Go语言的同事实现的，我需要将其封装好的.a静态库和.h头文件导入到项目中，用.c文件中的实现去调用.h中暴露出来的方法名，去.a静态库中查询即可</li></ul><p>具体文件有三个：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251310486.png"                                     ></p><ul><li>将iOS_GO这个文件夹导入到项目中</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251310087.png"                                     ></p><p>Xcode会自动将 <code>.a静态库</code> 链接二进制，在 <code>target -&gt; bulid phases -&gt; link binary with libraries</code> 下查看：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251310342.png"                                     ></p><ol start="2"><li>查看一下.h文件下暴露的函数</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251311429.png"                                     ></p><ol start="3"><li>查看.c文件下方法的使用</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251311156.png"                                     ></p><ul><li>第一个方法 <code>mira_start</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sd = mira_start(&quot;第一个参数&quot;, &quot;https://ip:post&quot;);</span><br></pre></td></tr></table></figure></div><p>通过两个参数去 <code>建立VPN连接</code></p><ul><li>通过 <code>sd</code> 获取连接成功的 <code>客户端App的ip地址</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sleep (5);</span><br><span class="line">char addr_out[100];</span><br><span class="line">get_ip(sd, addr_out, sizeof(addr_out));</span><br><span class="line"></span><br><span class="line">printf(&quot;-----------------------------------------\n&quot;);</span><br><span class="line">printf(&quot;IP addr %s\n&quot;, addr_out);</span><br><span class="line">printf(&quot;-----------------------------------------\n&quot;);</span><br></pre></td></tr></table></figure></div><ul><li>第二个方法 update_map(“域名”, “<a href="https://ip:post">https://ip:post</a>“);</li></ul><p>这个方法的作用是 <code>设置代理</code>，一个 <code>ip地址</code> 可以对应 <code>一个或多个域名</code>，如果没有指定特殊的端口号，默认的端口号是 <code>443</code></p><ul><li>如果返回了 <code>客户端App的ip地址</code> 那么代表你成功建立了 VPN 连接了</li></ul><blockquote><p>注：<br>1、VPN建立连接是要保证App在前台的情况下才不会断开<br>2、如果切换到后台VPN会断开连接，切换到前台时会恢复连接<br>3、VPN的主要作用就是用 <code>外网</code> 访问 <code>内网</code>（实现外网访问内网的服务器请求或者h5等）</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;VPN 的英文全称是 &lt;code&gt;Virtual Private Network&lt;/code&gt; ，翻译过来就是 &lt;code&gt;虚拟专用网络&lt;/</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习32：Cloning into &#39;tsinghua-git-cocoapods&#39;...卡住不动</title>
    <link href="https://www.bboyzj.cn/2023/05/23/Swift/Swift%E5%AD%A6%E4%B9%A032%EF%BC%9ACloning-into-tsinghua-git-cocoapods-%E5%8D%A1%E4%BD%8F%E4%B8%8D%E5%8A%A8/"/>
    <id>https://www.bboyzj.cn/2023/05/23/Swift/Swift%E5%AD%A6%E4%B9%A032%EF%BC%9ACloning-into-tsinghua-git-cocoapods-%E5%8D%A1%E4%BD%8F%E4%B8%8D%E5%8A%A8/</id>
    <published>2023-05-23T02:25:19.000Z</published>
    <updated>2023-05-25T05:17:12.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>在使用 <code>cocoapods</code> 安装 <code>三方库</code> 的时候，使用 <code>pod install --verbose</code> 或者 <code>pod update --verbose</code> 的时候会卡住在如下图所示：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251313485.png"                                     ></p><p><strong>原因分析：</strong></p><p><a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git" >https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>这个是清华的镜像源，你需要将现在的镜像源更换成清华的镜像源</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.cocoapods/repos </span><br><span class="line">$ pod repo remove master</span><br><span class="line">$ git clone https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git master</span><br></pre></td></tr></table></figure></div><p>然后记得去项目中Podfile里添加如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &#x27;https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git&#x27;</span><br></pre></td></tr></table></figure></div><ul><li>如果你遇到 fetal: Could not read from remote repository</li></ul><p>原因分析：首先看一下git源 <code>git@172.16.21.253:platgorm_ios/JITLog.git</code> 说明是一个内网的git仓库源</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251314897.png"                                     ></p><p>解决办法：如果你想下载并使用需要去配置 <code>SSK Key</code>，然后去让管理员给你 <code>开启访问并下载的权限</code>。</p><ul><li>OC 项目导入 <code>.framework</code> 静态库 <code>SDK</code>，报错如下：</li></ul><p>直接将文件夹拖入到项目中</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibrary not loaded: @rpath/JIT_GM_SSL.framework/JIT_GM_SSL 并crash</span><br></pre></td></tr></table></figure></div><p>解决办法：将 <code>Do Not Embed</code> 改为 <code>Embed &amp; Sign</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251314424.png"                                     ></p><h1 id="pod-install-和-pod-update-区别"><a href="#pod-install-和-pod-update-区别" class="headerlink" title="pod install 和 pod update 区别"></a>pod install 和 pod update 区别</h1><ul><li><p><code>pod install</code> 除了首次安装时使用,之后增删也可以用</p></li><li><p><code>pod update</code> 只有在需要更新pod时使用</p></li></ul><p><strong>区别：</strong></p><ul><li><p>要理解他们的区别，就不能不提 <code>Podfile.lock</code> 这个文件了；从后缀可以看出这是一个锁。锁什么呢？锁住 <code>pods</code> 的版本。在首次执行 <code>pod install</code> 时，<code>cocoapods</code> 根据 <code>podfile</code> 文件来 <code>导入合适版本的pods</code>。</p></li><li><p>然后，<code>Podfile.lock</code> 文件被创建，此次所有 <code>pod版本信息</code> 会被记录在该文件中。之后再执行 <code>pod install</code> 时，会先从 <code>Podfile.lock</code> 文件读取信息。已有记录的 <code>pod</code> 会维持原版本。无记录的 <code>pod</code> 则根据 <code>Podfile</code> 导入合适版本的 <code>pod</code>，然后新导入的 <code>pod</code> 信息也会被记录在 <code>Podfile.lock</code> 文件中</p></li><li><p>总之 <code>Podfile.lock</code> 就是 <code>锁住版本信息</code> 的作用</p></li><li><p>如果想要升级版本，那么就需要使用 <code>pod update</code> 了，<code>pod update</code> 会或略 <code>Podfile.lock</code> 文件，直接升级 <code>pod</code> 到 <code>Podfile</code> 允许的最新版本。</p></li><li><p><code>pod update</code> 执行后最新的版本信息也会记录到 <code>Podfile.lock</code> 文件，如果指向更新其中一个库，使用 pod update podname(库名)</p></li></ul><p><strong>举例说明：</strong></p><ul><li>第一步：</li></ul><p>首先，张三新建了一个工程，创建了 <code>Podfile</code>，在Podfile中引入了 <code>A、B、C</code>  三个 <code>pod</code>。</p><p>然后执行 <code>pod install</code>，<code>A、B、C</code> 被导入，假设版本都是1.0.0。</p><p><code>Podfile.lock</code> 会被创建， 记录下A、B、C 的版本为1.0.0。</p><ul><li>第二步：</li></ul><p>过了一段事件，张三在Podfile中新增了pod D。</p><p>假设D的版本也是1.0.0，而B已经发布了新版本1.1.0。</p><p>张三仅想导入D，而保持B的版本不变，避免更新B带来的风险。</p><p>于是张三执行了 <code>pod install</code>。</p><p>执行中，<code>CocoaPods</code> 发现 <code>Podfile.lock</code> 中B的版本是 <code>1.0.0</code>，于是B维持不变。发现新增了D，于是导入了1.0.0的D，并将D的信息记录到 <code>Podfile.lock</code>。</p><ul><li>第三步：</li></ul><p>又过了一段时间，李四加入了项目。</p><p>假设C的已经发布了新版本1.2.0。</p><p>李四clone项目后，他使用 <code>pod install</code>。</p><p>命令执行时，发现A、B、C、D在Podfile.lock中都有记录，因此他获取的A、B、C、D也会都是记录的1.0.0。</p><p>这样就保证了张三和李四使用的第三方是一致的。</p><ul><li>第四步：</li></ul><p>半个月后，张三觉得B的1.1.0足够成熟，可以集成了，但是C的1.2.0还需要再等等。</p><p>于是，他执行了 <code>pod update B</code> 来升级B，但维持C的版本为1.0.0。</p><p><code>CocoaPods</code> 会忽略 <code>Podfile.lock</code> 中记录的B的信息，强行更新 <code>B</code> 到 <code>1.1.0</code>。</p><p>然后张三本地的 <code>Podfile.lock</code> 中B的版本信息也会更新到 1.1.0。</p><p>张三提交，李四拉取后，执行 <code>pod install</code>，于是李四的B也更新到 1.1.0。又跟张三保持一致了。</p><p><strong>总结：</strong></p><p>需要更新 <code>pod</code> 版本时使用 <code>pod update（更新全部）</code>，如果想更新其中一个用 <code>pod update 库名</code> ，其他情况下使用 <code>pod install</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在使用 &lt;code&gt;cocoapods&lt;/code&gt; 安装 &lt;code&gt;三方库&lt;/code&gt; 的时候，使用 &lt;code&gt;pod </summary>
      
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-常用" scheme="https://www.bboyzj.cn/tags/Swift-%E5%B8%B8%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>OC学习47：Mac电脑连接网线配置</title>
    <link href="https://www.bboyzj.cn/2023/05/21/OC/OC%E5%AD%A6%E4%B9%A047%EF%BC%9AMac%E7%94%B5%E8%84%91%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BA%BF%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.bboyzj.cn/2023/05/21/OC/OC%E5%AD%A6%E4%B9%A047%EF%BC%9AMac%E7%94%B5%E8%84%91%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BA%BF%E9%85%8D%E7%BD%AE/</id>
    <published>2023-05-21T04:48:11.000Z</published>
    <updated>2023-05-25T05:12:15.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本人的Mac电脑是2015款的，系统是 <code>maxOS Monterey</code> 版本 12.6.5，由于Mac电脑本身不带插网线的口，因此需要自己买一个转接口（注：我的是USB口转网线接口）</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li>系统偏好设置 -&gt; 网络 配置如下：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251311210.png"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本人的Mac电脑是2015款的，系统是 &lt;code&gt;maxOS Monterey&lt;/code&gt; 版本 12.6.5，由于Mac电脑本身不带插</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习45：Mac电脑配置VPN</title>
    <link href="https://www.bboyzj.cn/2023/05/21/OC/OC%E5%AD%A6%E4%B9%A045%EF%BC%9AMac%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AEVPN/"/>
    <id>https://www.bboyzj.cn/2023/05/21/OC/OC%E5%AD%A6%E4%B9%A045%EF%BC%9AMac%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AEVPN/</id>
    <published>2023-05-21T03:54:17.000Z</published>
    <updated>2023-05-25T05:57:58.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>主要参数：<br>服务器：l2tp.rtmap.com<br>用户名：yourname# 还没有用户名的，请到VPN申请网址申请<br>密  码：yourpassword<br>共享秘钥：rtmap.com<br>VPN类型：使用预共享共享密钥的L2TP&#x2F;Ipesc</p><h1 id="MacOS-配置-VPN"><a href="#MacOS-配置-VPN" class="headerlink" title="MacOS 配置 VPN"></a>MacOS 配置 VPN</h1><ol><li>打开 系统偏好设置-&gt;网络</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251345938.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251345654.png"                                     ></p><ol start="2"><li>在窗口的左下角单击 + 按钮</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251345085.png"                                     ></p><ol start="3"><li>在下拉菜单选择 VPN</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251345734.png"                                     ></p><ol start="4"><li>VPN类型 下拉菜单选择 <code>L2TP/IPSec</code></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251346218.png"                                     ></p><ol start="5"><li><p>服务名称 中输入任意内容，也可默认</p></li><li><p>在 服务器地址 中输入你的 <code>VPN</code> 服务器 <code>IP</code></p></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251346772.png"                                     ></p><ol start="7"><li>点击 <code>认证设置</code> 部分</li></ol><ul><li><p>选择 <code>密码</code> 单选按钮，然后输入你的 <code>VPN</code> 密码</p></li><li><p>在及其鉴定部分，选择 <code>共享的秘钥</code> ，然后输入你的 <code>VPN服务器上设置的预共享秘钥</code></p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305211213292.png"                                     ></p><ol start="8"><li><p>保持群组名称字段空白</p></li><li><p>点击 好</p></li><li><p>选中 在菜单栏中显示 VPN 状态 复选框</p></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251347729.png"                                     ></p><ol start="11"><li>单击 高级 按钮，并选中 通过VPN连接发送所有流量</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251347288.png"                                     ></p><ol start="12"><li>单击 <code>TCP/IP</code> 选项卡，并在 <code>配置IPV6</code> 部分选择 <code>仅本地链接</code></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251348442.png"                                     ></p><ol start="13"><li><p>单击 <code>好</code> 关闭高级设置，然后单击 应用 保存 VPN 连接信息</p></li><li><p>最后一步（可选）</p></li></ol><p>修改 <code>DNS</code> 为 <code>10.10.10.55</code>，如果不使用 <code>rt.com</code> 内网域名，这里可以不设置</p><ol start="15"><li>点击 应用，再点击 <code>连接</code></li></ol><h1 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h1><ol><li>进入 <code>设置-&gt;通用-&gt;VPN与设备管理-&gt;VPN-&gt;添加VPN配置</code></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251349761.png"                                     ></p><ol start="2"><li><p>单击 <code>类型</code>，选择 <code>L2TP</code></p></li><li><p>在 <code>描述</code> 字段中输入任意内容</p></li><li><p>在 <code>服务器</code> 字段中输入你的 VPN服务器IP：<code>l2tp.rtmap.com</code></p></li><li><p>在 <code>账户</code> 字段中输入你的 <code>VPN用户名</code></p></li><li><p>在 <code>密码</code> 字段中输入你的 <code>VPN 密码</code></p></li><li><p>在 <code>秘钥</code> 字段中输入你的 VPN IPsec PSK：<code>rtmap.com</code></p></li><li><p>启动 <code>发送所有流程</code> 选项</p></li><li><p>单击右上角的 <code>完成</code></p></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16849941707920.jpg"                                     ></p><ol start="10"><li>启动 <code>VPN</code> 连接</li></ol><h1 id="拉取内网flutter-huamao-ios代码"><a href="#拉取内网flutter-huamao-ios代码" class="headerlink" title="拉取内网flutter_huamao_ios代码"></a>拉取内网flutter_huamao_ios代码</h1><ol><li>拉取SSH，<code>不允许</code>，需要配置SSH或者知道秘钥</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mac@MacdeMacBook-Pro Desktop % git clone git@192.168.14.12:ios/flutter_huamao_ios.git</span><br><span class="line">Cloning into &#x27;flutter_huamao_ios&#x27;...</span><br><span class="line">git@192.168.14.12&#x27;s password: </span><br><span class="line">Permission denied, please try again.</span><br></pre></td></tr></table></figure></div><ol start="2"><li>拉取HTTPS，<code>允许</code>，输入 <code>账户用户名和密码</code> 即可</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mac@MacdeMacBook-Pro Desktop % git clone http://192.168.14.12/ios/flutter_huamao_ios.git</span><br><span class="line">Cloning into &#x27;flutter_huamao_ios&#x27;...</span><br><span class="line">Username for &#x27;http://192.168.14.12&#x27;: wangjinchang</span><br><span class="line">Password for &#x27;http://wangjinchang@192.168.14.12&#x27;: </span><br><span class="line">remote: Counting objects: 4448, done.</span><br><span class="line">remote: Compressing objects: 100% (2617/2617), done.</span><br><span class="line">remote: Total 4448 (delta 2162), reused 3907 (delta 1805)</span><br><span class="line">Receiving objects: 100% (4448/4448), 77.10 MiB | 2.31 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (2162/2162), done.</span><br><span class="line">Updating files: 100% (1598/1598), done.</span><br></pre></td></tr></table></figure></div><h1 id="拉取flutter-humao代码"><a href="#拉取flutter-humao代码" class="headerlink" title="拉取flutter_humao代码"></a>拉取flutter_humao代码</h1><ol><li>由于是混合开发，所以需要两部分代码都需要clone下来，注意与上面iOS代码在同级目录下</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@MacdeMacBook-Pro Desktop % http://192.168.14.12/android/flutter_huamao.git</span><br></pre></td></tr></table></figure></div><p>要不然会出现如下错误：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251356546.png"                                     ></p><ol start="2"><li>安装三方SDK库</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mac@MacdeMacBook-Pro flutter_huamao % cd /Users/mac/Desktop/humao/flutter_huamao</span><br><span class="line">mac@MacdeMacBook-Pro flutter_huamao % flutter clean</span><br><span class="line">mac@MacdeMacBook-Pro flutter_huamao % flutter pub get</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>下载成功：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251357484.png"                                     ></p><p>接下来切换到iOS项目下执行：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@MacdeMacBook-Pro flutter_huamao % cd /Users/mac/Desktop/humao/flutter_huamao_ios</span><br><span class="line">mac@MacdeMacBook-Pro flutter_huamao_ios % pod install</span><br></pre></td></tr></table></figure></div><p>成功安装iOS三方库：</p><ol start="3"><li>发现错误</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251357677.png"                                     ></p><p>说明当前flutter的Dart版本太高，需要下载一个低版本的flutter</p><p>检查当前Mac是什么架构：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@MacdeMacBook-Pro flutter_huamao % uname -a</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251357793.png"                                     ></p><p><strong>出现如下问题：</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251357356.png"                                     ></p><p>这种错误一般是由于使用 git:&#x2F;&#x2F;*** 下载会出现，改成使用 https:&#x2F;&#x2F; 方式访问即可。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global url.https://github.com/.insteadOf git://github.com/</span><br><span class="line">git config --global url.&quot;https://&quot;.insteadOf git://</span><br></pre></td></tr></table></figure></div><p>vim 打开 .git&#x2F;config 文件，并在最后添加如下内容：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[url &quot;git@github.com:&quot;]</span><br><span class="line">    pushInsteadOf = git://github.com/</span><br><span class="line">    pushInsteadOf = https://github.com/</span><br></pre></td></tr></table></figure></div><p><strong>出现如下错误：</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251357773.png"                                     ></p><p>一个字重新下载，<code>等待</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;主要参数：&lt;br&gt;服务器：l2tp.rtmap.com				&lt;br&gt;用户名：yourname					# 还没有用户名的，请到VPN申请网</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC数据结构03：哈希表的探索</title>
    <link href="https://www.bboyzj.cn/2023/05/20/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>https://www.bboyzj.cn/2023/05/20/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%8E%A2%E7%B4%A2/</id>
    <published>2023-05-20T03:12:13.000Z</published>
    <updated>2023-05-20T14:22:47.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希表定义"><a href="#哈希表定义" class="headerlink" title="哈希表定义"></a>哈希表定义</h1><ul><li><p><code>哈希表（hash table，也叫散列表）</code>，是根据 <code>键（key）</code> 直接访问在内存存储位置的数据结构。也就是说，它通过 <code>把关键码值映射到表中一个位置来访问记录</code>，以加快查找速度，这个 <code>映射函数</code> 叫做 <code>散列函数</code>，存放记录的数组叫做散列表。</p></li><li><p>给定一个 <code>键key</code>，存在 <code>函数f(x)</code> 和 <code>表M</code>，将 <code>键key</code> 代入 <code>函数f(key)</code>，若能得到 <code>包含键key记录在表中的地址</code>，则称 <code>表M为哈希（Hash）表</code>，<code>函数f(key)为哈希(Hash)函数</code></p></li></ul><h1 id="哈希冲突定义"><a href="#哈希冲突定义" class="headerlink" title="哈希冲突定义"></a>哈希冲突定义</h1><ul><li>对不同的 <code>key</code> 可能得到同一个 <code>哈希地址</code>，即 <code>k1≠k2，而f(k1)=f(k2)</code>，这种现象称为<code>哈希冲突</code>，即 <code>不同的key</code> 经过 <code>hash</code> 处理后都可能得到相同的 <code>hash</code> 值。</li></ul><h1 id="哈希表的本质"><a href="#哈希表的本质" class="headerlink" title="哈希表的本质"></a>哈希表的本质</h1><ul><li>哈希表本质是一个 <code>数组</code>，数组中每一个元素称为 <code>箱子</code>，箱子中存放的是 <code>键值对</code>，根据 <code>下标index</code> 从数组中取 <code>value</code>。关键是如何获取 <code>index</code>，这就需要一个固定的函数（哈希函数），将 <code>key</code> 转换为 <code>index</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305201205754.png"                                     ></p><h1 id="哈希查找步骤"><a href="#哈希查找步骤" class="headerlink" title="哈希查找步骤"></a>哈希查找步骤</h1><p>使用哈希函数将被查找的键映射（转换）为数组的索引，理想情况下（hash 函数设计合理）不同的键映射的数组下标也不同，所有的查找时间复杂度为 O(1)。但是实际情况下不是这样的，所以哈希查找的第二步就是 <code>处理哈希碰撞冲突</code>。</p><h1 id="常用哈希函数"><a href="#常用哈希函数" class="headerlink" title="常用哈希函数"></a>常用哈希函数</h1><ul><li><p>哈希查找第一步就是使用哈希函数将 <code>键</code> 映射成 <code>索引</code>，这种映射函数就是哈希函数。</p></li><li><p>如果有一个保存 M个元素的 数组，那么就需要一个能够将任意键转换为该数组范围内的索引（0 ~ M-1）的哈希函数，哈希函数需要易于计算并且能够均匀分布所有键。</p></li><li><p>在实际中，我们的键并不都是数字，有可能是字符串，还有可能是几个值的组合等，所以需要实现自己的哈希函数：</p><ul><li><p>直接寻址法：哈希函数为线性函数， f(k)&#x3D;ak+b，a和b为常数</p></li><li><p>数字分析法；</p></li><li><p>平方取中法：将关键字平方以后取中间几位</p></li><li><p>折叠法：先按照一定规则拆分再组合，例如书的索引ISBN 978-7-121-33637-9，可以拆合为97+87+12+13+36+37+9&#x3D;291，哈希值为291</p></li><li><p>随机数法：选择一个随机函数，把关键字的随机函数值作为它的哈希值。通常当关键字的长度不等时用这种方法。</p></li><li><p>除留余数法：f(k)&#x3D;k%n，假设哈希表的长度为m，则n一般为不超过m的最大质数，用于关键字位数较多，并且关键字中每一位上数字分布大致均匀。</p></li></ul></li></ul><h1 id="哈希函数的特征"><a href="#哈希函数的特征" class="headerlink" title="哈希函数的特征"></a>哈希函数的特征</h1><ul><li><p>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</p></li><li><p>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；</p></li><li><p>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</p></li><li><p>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</p></li></ul><h1 id="哈希碰撞冲突的解决方法"><a href="#哈希碰撞冲突的解决方法" class="headerlink" title="哈希碰撞冲突的解决方法"></a>哈希碰撞冲突的解决方法</h1><p><code>哈希碰撞冲突</code> 就是对于不同的关键字，经过哈希函数计算以后的哈希值相同。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305201206333.png"                                     ></p><ol><li><p>开放寻址法：使用数组中的空位解决碰撞，当碰撞发生时（即一个键的hash值对应数组的下标被另外一个键占用）直接将下标索引加一（inde +&#x3D; 1），这样出现三种情况：</p><ul><li>未命中（数组下标中的值为空，没有占用）：存入</li><li>命中（数组下标中的值不为空，占用）：继续 index+&#x3D;1 ，直到遇到没有占用的</li></ul></li><li><p>链地址法：简单来说就是 <code>数组 + 链表</code>，将 <code>键</code> 通过 <code>hash</code> 函数映射为大小为 <code>M</code> 的数组的下标索引，数组的每一个元素指向一个链表，链表中的每一个结点存储着 <code>hash</code> 出来的索引值为结点下标的键值对。</p></li><li><p>再散列法</p></li></ol><p>不同的散列函数，地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间；</p><ol start="4"><li>建立一个公共溢出区</li></ol><h1 id="Apple方案选择"><a href="#Apple方案选择" class="headerlink" title="Apple方案选择"></a>Apple方案选择</h1><p>解决哈希冲突的拉链法和开放定址线性探测法，Apple 都在使用，具体使用哪一种是根据存储数据的生命周期和特性决定的：</p><ul><li><p><code>@synchronized</code> 使用的是 <code>链地址法</code>，链地址法多用于存储的数据是通用类型，能够被反复利用，就像 <code>@synchronized</code> 存储的是锁是一种无关业务的实现结构，程序运行时多个对象使用同一个锁的概率相当高，有效的节省了内存。</p></li><li><p><code>weak</code> 对象 <code>associatedObject</code> 采用的是开放定址法，开放定址线性探测法用于存储的数据是临时的，用完尽快释放，就像 associatedObject，weak。</p></li></ul><h1 id="Hash-在-iOS-中的应用分析"><a href="#Hash-在-iOS-中的应用分析" class="headerlink" title="Hash 在 iOS 中的应用分析"></a>Hash 在 iOS 中的应用分析</h1><ol><li>关联对象 <code>AssociatedObject</code> 的底层实现采用的数据存储结构（<code>Hash 表 + Hash 表</code>）</li></ol><p>关联对象采用的是 <code>HashMap 嵌套 HashMap</code> 的结构存储数据的，简单来说就是根据对象从第一个 <code>HashMap</code> 中取出存储对象所有关联对象的第二个 <code>HashMap</code>，然后根据属性名从第二个 <code>HashMap</code> 中取出属性对应的值和策略。</p><ul><li><p>已知条件一：<code>对象</code>，因此引出第一个 <code>HashMap</code>（AssociationsHashMap），用一个能唯一代表对象的值作为 <code>key</code>，用存储对象的所有关联对象的结构（名字：<code>值+策略</code>）作为 <code>value</code>；</p></li><li><p>已知条件二：<code>属性名字</code>，因此引出第二个 <code>HashMap</code>（ObjectAssociationMap），用属性名字作为key，用属性名字对应的结构体<code>（值+策略）</code>作为 <code>value</code>。</p></li></ul><ol start="2"><li><code>weak</code> 底层实现采用的数据存储结构 <code>（Hash 表 + 数组）</code></li></ol><p><code>weak</code> 采用的是一个全局的 <code>HashMap</code> 嵌套数组的结构存储数据的，销毁对象（weak 指针指向的对象）的时候，根据对象从 <code>HashMap</code> 中找到存放所有指向该对象的 <code>weak</code> 指针的数组，然后将数组中的所有元素都置为 <code>nil</code>。</p><p><code>weak</code> 的最大特点就是在对象销毁时，自动置 <code>nil</code>，减少访问野指针的风险，这也是设计 <code>weak</code> 的初衷。</p><p>方案设计实现好后，<code>weak</code> 指针置 <code>nil</code> 的基本步骤：</p><p>对象 <code>dealloc</code> 的时候，从全局的 <code>HashMap</code> 中，根据一个唯一代表对象的值作为 <code>key</code>，找到存储所有指向该对象的 <code>weak</code> 指针的数组；将数组中的所有元素都置为 <code>nil</code>。</p><ol start="3"><li>KVO 底层实现采用的数据存储结构（Hash 表 + 数组）</li></ol><p>一个对象可以被 <code>n</code> 个对象观察，一对象的 <code>n</code> 个属性又可以分别被 <code>n</code> 个对象观察。</p><ol start="4"><li>iOS App 签名的原理（MD5 + 哈希表 + 非对称加密 RSA）</li></ol><p>一致性哈希算法 + 非对称加解密算法：</p><ul><li><p>数字签名：传递数据时会将原始的数据和数字签名一起发送，对方拿到数据后，通过同样的 <code>Hash</code> 算法得到原始数据的 <code>Hash</code> 的值，然后通过非对称加密，将数字签名中的校验 <code>Hash</code> 值解密出来，最后对比两个 <code>Hash</code> 值是否一致。</p></li><li><p>代码签名：代码签名就是对可执行文件或脚本进行数字签名，用来确认软件在签名后未被修改或损坏的措施。它的原理和数字签名类似，只不过把签名的不是数据，而是代码。</p></li></ul><ol><li><p>对象的引用计数存储的位置（Hash 表）</p></li><li><p>NSDictionary 的实现原理（Hash 表）</p></li><li><p>Runloop 与 线程 的存储关系</p></li></ol><ul><li><p>线程和 Runloop 之间是一一（子线程可以没有）对应的，其关系是保存在一个全局的 Dictionary 里。</p></li><li><p><code>Runloop</code> 保存在一个 <code>全局的可变字典</code> 中，<code>key</code> 是 <code>pthread_t</code>，<code>value</code> 是 <code>cfrunloopref</code>，即 <code>Hash</code> 表。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;哈希表定义&quot;&gt;&lt;a href=&quot;#哈希表定义&quot; class=&quot;headerlink&quot; title=&quot;哈希表定义&quot;&gt;&lt;/a&gt;哈希表定义&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;哈希表（hash table，也叫散列表）&lt;/code&gt;，是根据 &lt;code&gt;键（ke</summary>
      
    
    
    
    <category term="算法" scheme="https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结和算法" scheme="https://www.bboyzj.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>OC学习44：正向代理和反向代理服务器</title>
    <link href="https://www.bboyzj.cn/2023/05/19/OC/OC%E5%AD%A6%E4%B9%A044%EF%BC%9A%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://www.bboyzj.cn/2023/05/19/OC/OC%E5%AD%A6%E4%B9%A044%EF%BC%9A%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2023-05-19T06:26:45.000Z</published>
    <updated>2023-05-25T05:18:08.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><ol><li>概述</li></ol><p><code>正向代理</code> 就是代理服务器介于用户客户端和目标服务器之间，用户指定想要获取的目标内容，通过客户端先向 <code>代理服务器</code> 发送请求，再由代理服务器发送到目标服务器，随后将获得的内容返回用户客户端。正向代理的情况下，客户端必须要进行一些需求设置，在有确定目标的前提下发送请求。</p><p><code>正向代理</code> 是 <code>代理用户客户端</code>，为客户端发送请求，使真实的用户客户端对服务器不可见。它最典型的用途就是可以用来访问受地理限制的内容、保护用户隐私、帮助爬虫爬取数据、广告效果测试、网站测试等等。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251317116.png"                                     ></p><p>正向代理代理的是 <code>用户</code></p><ol start="2"><li>优点：</li></ol><p>客户端可以对 <code>server</code> 隐藏自己的地址，从而避免受到可能的攻击</p><p>可以缓存真实服务器中的数据，提高客户端的访问速度</p><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><ol><li>概述</li></ol><p><code>反向代理</code> 是用户客户端发送请求于代理服务器，然后代理服务器将请求转发给相对的目标服务器，并将结果返回给客户端。对于客户端来说，它没有确定想要访问的目标服务器，这里的代理服务器就相当于是目标服务器，此时也不需要客户端进行任何的设置。</p><p><code>反向代理</code> 是 <code>代理服务器</code>，为服务器收发请求，使得真实的服务器对于用户客户端不可见。它的作用是隐藏服务器的IP地址、提高访问速度、保持负载平衡、保护免受黑客攻击。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305251317478.png"                                     ></p><h1 id="正向代理和反向代理区别"><a href="#正向代理和反向代理区别" class="headerlink" title="正向代理和反向代理区别"></a>正向代理和反向代理区别</h1><ul><li><p><code>正向代理</code> 和 <code>反向代理</code> 都是介于用户客户端与服务器之间的，它在中间都起到了连接与保护的作用。它们的区别在于，<code>正向代理是用户客户端代理</code>，而 <code>反向代理是服务器代理</code>，在代理对象不同的情况下，都可以起到隐藏信息的作用；其次，正向代理一般是用户客户端设置的，而反向代理是由服务器设置的。</p></li><li><p><code>正向代理</code> 与 <code>反向代理</code> 的应用很广泛，但总的来说，普通用户们日常使用的大多是正向代理，而反向代理则主要应用于网站服务器之中，适用于大公司业务处理。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正向代理&quot;&gt;&lt;a href=&quot;#正向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理&quot;&gt;&lt;/a&gt;正向代理&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;概述&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;正向代理&lt;/code&gt; 就是代理服务器介于用户客户端和目标服务器之</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC学习44：RSA和SM2的区别？</title>
    <link href="https://www.bboyzj.cn/2023/05/19/OC/OC%E5%AD%A6%E4%B9%A044%EF%BC%9ARSA%E5%92%8CSM2%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>https://www.bboyzj.cn/2023/05/19/OC/OC%E5%AD%A6%E4%B9%A044%EF%BC%9ARSA%E5%92%8CSM2%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/</id>
    <published>2023-05-19T05:04:42.000Z</published>
    <updated>2023-05-25T05:58:17.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PEM-和-DER"><a href="#PEM-和-DER" class="headerlink" title="PEM 和 DER"></a>PEM 和 DER</h1><ul><li>PEM</li></ul><p><code>PEM</code> 文件只是 <code>DER</code> 编码数据的 <code>base64</code> 编码版本,为了区分外部DER编码字符串中的数据类型，数据周围存在页眉和页脚。PEM编码文件的示例是：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">MIGHAgEAMBMGByqGSM49AgEGCCqBHM9VAYItBG0wawIBAQQgbDojZWhRjTkpNUAb</span><br><span class="line">Kp12Zn9LpOe1u18jX5Hz5ySfRmChRANCAAS7B6RSXwuVQ1WNrJHd5oN5OOS8H1iE</span><br><span class="line">5fPqUh2IadP3SpBDpNgrRhhIicd4XaQWxHbCrgd8SEvrf9/6Kp62JCye</span><br><span class="line">-----END PRIVATE KEY-----</span><br></pre></td></tr></table></figure></div><p>第一行和最后一行表示内部应该预期的DER格式。里面的数据是DER编码信息的base64编码版本。</p><h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h1><p><code>RSA</code> 是 <code>非对称密码算法</code>，是 <code>国际上</code> 通用的非对称密码算法</p><h1 id="SM2"><a href="#SM2" class="headerlink" title="SM2"></a>SM2</h1><p><code>SM2</code> 是 <code>非对称密码算法</code>，是 <code>我们国家</code> 自己制定的非对称密码算法标准</p><h1 id="GmSSL"><a href="#GmSSL" class="headerlink" title="GmSSL"></a>GmSSL</h1><ol><li>关于 GmSSL</li></ol><p><code>GmSSL</code> 是一个开源的密码工具箱，<code>支持SM2/SM3/SM4/SM9/ZUC等国密(国家商用密码)算法、SM2国密数字证书及基于SM2证书的SSL/TLS安全通信协议</code>，支持国密硬件密码设备，提供符合国密规范的编程接口与命令行工具，可以用于构建 <code>PKI/CA、安全通信、数据加密等</code> 符合国密标准的安全应用。<code>GmSSL</code> 项目是 <code>OpenSSL</code> 项目的 <code>分支</code>，并与 <code>OpenSSL</code> 保持接口兼容。因此<code>GmSSL</code> 可以替代应用中的 <code>OpenSSL</code> 组件，并使应用自动具备 <code>基于国密</code> 的安全能力。<code>GmSSL</code> 项目采用对商业应用友好的类 <code>BSD</code> 开源许可证，开源且可以用于闭源的商业应用。</p><p>GmSSL项目由北京大学关志副研究员的密码学研究组开发维护，项目源码托管于GitHub。自2014年发布以来，GmSSL已经在多个项目和产品中获得部署与应用，并获得2015年度“一铭杯”中国Linux软件大赛二等奖(年度最高奖项)与开源中国密码类推荐项目。GmSSL项目的核心目标是通过开源的密码技术推动国内网络空间安全建设。</p><p>大家都知道OpenSSL，主要是提供国际加密算法库。但是在最新的OpenSSL 1.1.1以上版本，已经对国密算法提供了支持。</p><p>OpenSSL、GmSSL这俩提供的国密算法库，去看了下代码，代码实现是不一样的，属于条条大路通罗马。</p><ol start="2"><li><code>标准的HTTPS</code> 和 <code>国密HTTPS</code> 区别？</li></ol><p>国密SSL能够做到在同一个端口，自适应支持HTTPS&#x2F;国密HTTPS，完美解决从标准HTTPS到国密HTTPS的平滑过渡</p><h1 id="解决与系统OpenSSL冲突的问题"><a href="#解决与系统OpenSSL冲突的问题" class="headerlink" title="解决与系统OpenSSL冲突的问题"></a>解决与系统OpenSSL冲突的问题</h1><p><code>GmSSL</code> 是支持国密算法和标准的OpenSSL分支，也就是说GmSSL是在OpenSSL代码基础上添加的国密算法。</p><p>因此为了兼容OpenSSL，GmSSL编译后生成的so文件名称与OpenSSL一致，都是 <code>libcrypto.so</code>。</p><p><strong>可能存在的问题：</strong></p><p>Linux上很多软件都依赖于系统中的 <code>OpenSSL</code> 库。若你编译安装的 <code>GmSSL</code> 版本，其基于的OpenSSL分支版本，与系统中的OpenSSL版本不一致，便会产生冲突，很容易导致这些软件不可用。</p><p><strong>最简单有效的办法：将GmSSL编译为静态库。</strong></p><p><code>GmSSL</code> 命令行工具，以及我们基于该静态库开发的程序，直接内部就集成了 <code>GmSSL</code> 的二进制码，不需要去查找库了，也就不会与系统中 <code>OpenSSL</code> 产生冲突。</p><p>在安装GmSSL时，安装到指定的目录下，如&#x2F;usr&#x2F;local&#x2F;gmssl，与系统中OpenSSL路径保持独立。</p><p>这样，即 <code>从文件路径和运行</code> 时，两方面保证了 <code>GmSSL</code> 与 <code>OpenSSL</code> 不会冲突，并保持使用上的相互独立性。这的确是最完美的解决办法。</p><h1 id="GmSSL源码准备"><a href="#GmSSL源码准备" class="headerlink" title="GmSSL源码准备"></a>GmSSL源码准备</h1><p>下载 GmSSL 源码：<a class="link"   href="https://gitcode.net/mirrors/guanzhi/gmssl?utm_source=csdn_github_accelerator" >https://github.com/guanzhi/GmSSL <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h1 id="编译与安装GmSSL"><a href="#编译与安装GmSSL" class="headerlink" title="编译与安装GmSSL"></a>编译与安装GmSSL</h1><ol><li>解压并进入目录</li></ol><p>解压源码：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip GmSSL-master.zip</span><br></pre></td></tr></table></figure></div><p>进入源码目录</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/gmssl-master</span><br></pre></td></tr></table></figure></div><ol start="2"><li>编译选项</li></ol><p>配置安装路径，编译为静态库:</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % ./config --prefix=/usr/local/gmssl --openssldir=/usr/local/gmssl no-shared</span><br></pre></td></tr></table></figure></div><blockquote><p>注：<br>–prefix 表示安装路径；<br>–openssldir&#x3D;&#x2F;usr&#x2F;local&#x2F;gmssl 表示openssl 的 configure 文件路径，与系统中 openssl 的路径保持独立，在路径上避免与系统中 openssl 的冲突<br>no-shared 表示只生成静态库，在运行上避免与系统中 openssl 的冲突<br>此条命令若出错，可参考<a class="link"   href="https://blog.csdn.net/weixin_43716504/article/details/126095234" >这篇文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，修改 Configure、test&#x2F;build.info文件后，即可解决</p></blockquote><p>如下图：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16844769096294.jpg"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16844768550262.jpg"                                     ></p><p>重新输入上面的命令，成功执行：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16844769546529.jpg"                                     ></p><ol start="3"><li>编译并安装(默认编译x86_64架构的环境，即 <code>模拟器</code> 环境)</li></ol><ul><li>编译：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon gmssl-master % make</span><br></pre></td></tr></table></figure></div><p>编译成功如下图：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16844774798628.jpg"                                     ></p><ul><li>安装</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon gmssl-master % sudo make install</span><br></pre></td></tr></table></figure></div><p>输入电脑密码即可</p><p>安装成功如下图：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16844778323895.jpg"                                     ></p><p>生产模拟器下运行的静态库 <code>.a（libssl.a 和 libcrypto.a）</code> 文件，</p><ol start="4"><li>环境变量</li></ol><p>打开 <code>~/.bashrc</code> 文件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon gmssl-master % vim ~/.bashrc</span><br></pre></td></tr></table></figure></div><p>在文件末尾添加内容：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/gmssl/bin</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16844778948550.jpg"                                     ></p><p>修改完成后按 <code>esc -&gt; :wq</code> 保存退出</p><p>环境变量生效：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon gmssl-master % source ~/.bashrc </span><br></pre></td></tr></table></figure></div><ol start="5"><li>验证是否安装成功</li></ol><ul><li>GmSSL</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon gmssl-master % gmssl version -a</span><br><span class="line">GmSSL 3.1.0</span><br></pre></td></tr></table></figure></div><ul><li>OpenSSL</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon gmssl-master % openssl version -a</span><br><span class="line">LibreSSL 2.8.3</span><br><span class="line">built on: date not available</span><br><span class="line">platform: information not available</span><br><span class="line">options:  bn(64,64) rc4(16x,int) des(idx,cisc,16,int) blowfish(idx) </span><br><span class="line">compiler: information not available</span><br><span class="line">OPENSSLDIR: &quot;/private/etc/ssl&quot;</span><br></pre></td></tr></table></figure></div><h1 id="编译ARM64的静态库文件"><a href="#编译ARM64的静态库文件" class="headerlink" title="编译ARM64的静态库文件"></a>编译ARM64的静态库文件</h1><ol><li>清理</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/gmssl-master </span><br><span class="line">mac@bogon gmssl-master % make distclean</span><br></pre></td></tr></table></figure></div><ol start="2"><li>按顺序终端执行</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon gmssl-master % export CC=clang</span><br><span class="line"></span><br><span class="line">// 注意Xcode路径</span><br><span class="line">mac@bogon gmssl-master % export CROSS_TOP=/Users/mac/Desktop/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer</span><br><span class="line"></span><br><span class="line">mac@bogon gmssl-master % export CROSS_SDK=iPhoneOS.sdk</span><br><span class="line"></span><br><span class="line">mac@bogon gmssl-master % export PATH=&quot;/Users/mac/Desktop/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin:$PATH&quot;</span><br><span class="line"></span><br><span class="line">mac@bogon gmssl-master % ./configure ios64-cross no-shared --prefix=/usr/local/openssl-ios64make</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="编译armv7下的静态库文件"><a href="#编译armv7下的静态库文件" class="headerlink" title="编译armv7下的静态库文件"></a>编译armv7下的静态库文件</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon gmssl-master % export CC=clang</span><br><span class="line"></span><br><span class="line">// 注意Xcode路径</span><br><span class="line">mac@bogon gmssl-master % export CROSS_TOP=/Users/mac/Desktop/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer</span><br><span class="line"></span><br><span class="line">mac@bogon gmssl-master % export CROSS_SDK=iPhoneOS.sdk</span><br><span class="line"></span><br><span class="line">mac@bogon gmssl-master % export PATH=&quot;/Users/mac/Desktop/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin:$PATH&quot;</span><br><span class="line"></span><br><span class="line">mac@bogon gmssl-master % ./configure ios-cross no-shared --prefix=/usr/local/openssl-ios</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><ul><li>查看所有支持编译的环境:</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure></div><ul><li>合并静态库文件,使其支持真机和模拟器</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -create  模拟器.a文件路径   真机.a文件路径 -output 合成的.a文件路径</span><br></pre></td></tr></table></figure></div><ul><li>查看静态库文件支持的编辑环境</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -info  .a文件路径</span><br></pre></td></tr></table></figure></div><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol><li>将 <code>.a静态库文件</code> 和 <code>include头文件</code> 引入到项目中</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16844794032558.jpg"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PEM-和-DER&quot;&gt;&lt;a href=&quot;#PEM-和-DER&quot; class=&quot;headerlink&quot; title=&quot;PEM 和 DER&quot;&gt;&lt;/a&gt;PEM 和 DER&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;PEM&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;PEM&lt;/code&gt; 文</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-学习" scheme="https://www.bboyzj.cn/tags/OC-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC算法06：快速排序</title>
    <link href="https://www.bboyzj.cn/2023/05/12/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9506%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://www.bboyzj.cn/2023/05/12/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9506%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2023-05-12T07:28:29.000Z</published>
    <updated>2023-05-12T07:28:47.221Z</updated>
    
    
    
    
    <category term="算法" scheme="https://www.bboyzj.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结和算法" scheme="https://www.bboyzj.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift-进阶02：类、对象、属性</title>
    <link href="https://www.bboyzj.cn/2023/05/11/Swift%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/Swift-%E8%BF%9B%E9%98%B602%EF%BC%9A%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B1%9E%E6%80%A7/"/>
    <id>https://www.bboyzj.cn/2023/05/11/Swift%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/Swift-%E8%BF%9B%E9%98%B602%EF%BC%9A%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B1%9E%E6%80%A7/</id>
    <published>2023-05-11T09:26:55.000Z</published>
    <updated>2023-05-11T09:27:13.641Z</updated>
    
    
    
    
    <category term="Swift" scheme="https://www.bboyzj.cn/categories/Swift/"/>
    
    
    <category term="Swift-进阶" scheme="https://www.bboyzj.cn/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>性能优化03.2：Xcode工具Report收集Crashs</title>
    <link href="https://www.bboyzj.cn/2023/05/11/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603.2%EF%BC%9AXcode%E5%B7%A5%E5%85%B7Report%E6%94%B6%E9%9B%86Crashs/"/>
    <id>https://www.bboyzj.cn/2023/05/11/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603.2%EF%BC%9AXcode%E5%B7%A5%E5%85%B7Report%E6%94%B6%E9%9B%86Crashs/</id>
    <published>2023-05-11T07:08:02.000Z</published>
    <updated>2023-05-11T07:46:49.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>苹果官方提供了一个利用Xcode获取Report的功能，可以获取用户的 <code>Crashs</code> 信息，但是需要用户在手机设置中开启 <code>设置-&gt;隐私和安全性-&gt;分析与改进-&gt;共享iPhone分析 开启-&gt;与App开发者共享 开启</code> 均打开</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>在Xcode中 <code>Window-&gt;Organizer-&gt;Crashs</code> 对应的App，就是当前App最新一版本的 <code>crash log</code>，并且是 <code>符号化</code> 过的，可以根据crash堆栈等信息，一键可以直接跳转到程序 <code>崩溃</code> 的相关代码，这样更容易 <code>定位bug</code> 位置</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305111520940.png"                                     ></p><p><strong>什么是符号化？</strong></p><p><code>符号化</code> 是指一种手段，这种手段指的是 <code>把堆栈信息（二进制信息）解释成源码里的方法名或函数名</code>，就是所谓的 <code>符号化</code>。只有 <code>符号化</code> 成功的，才能帮助开发者定位问题。</p><h1 id="符号化的过程"><a href="#符号化的过程" class="headerlink" title="符号化的过程"></a>符号化的过程</h1><ul><li><p>编译器把 <code>源码</code> 转换成 <code>机器码</code> 的同时，也会生成一份对应的 <code>符号表</code>。<code>符号表</code> 单独存储在 <code>dSYM</code> 文件中，以节省体积。</p></li><li><p>在每一次编译过程中，都会生成新的唯一能够标识构建的 <code>UUID</code>。也就是说 <code>同一次构建</code>，<code>app+dSYM+UUID</code> 是一套的。</p></li><li><p><code>Xcode</code> 会把 <code>app的二进制信息和dSYM文件</code> 存储在你的home文件夹下，你可以通过<code> Xcode-&gt;Window-&gt;Organizer-&gt;Archives</code> 找到 <code>.xcarchive</code> 打包内容，进而找到你存档过的信息。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;苹果官方提供了一个利用Xcode获取Report的功能，可以获取用户的 &lt;code&gt;Crashs&lt;/code&gt; 信息，但是需要用户在手机设置</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="性能优化" scheme="https://www.bboyzj.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>OC底层原理43：Instruments系列（一）Instruments介绍</title>
    <link href="https://www.bboyzj.cn/2023/05/09/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8644%EF%BC%9AInstruments%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89Instruments%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.bboyzj.cn/2023/05/09/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8644%EF%BC%9AInstruments%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89Instruments%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-05-09T08:06:55.000Z</published>
    <updated>2023-05-11T09:16:28.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常程序运行时常见的错误大致分为两类</p><ul><li><p>用户使用引起的外部错误，例如缺少参数、参数错误等</p></li><li><p>程序运行时产生的内部错误，例如内存溢出、空指针、以0做除数等</p></li></ul><p>针对第一种外部错误，一般是不可控的，因为用户的行为是随机的，所以一般只能采取相应的预防措施，尽最大程度去避免这类问题</p><p>针对第二种内部错误，可以通过一些工具及时的找出问题并修正。这里就不得不提及Xcode自带的检测调试工具Instruments了。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>Instruments</code> 是一个非常灵活、且强大的工具，可以进行性能分析、动态追踪、代码分析等，让我们对程序的内部运行更加了解。主要可以做以下事情：</p><ul><li><p>用于动态调追踪和分析OS X和iOS的代码的性能分析和测试工具</p></li><li><p>支持多线程调试</p></li><li><p>支持录制和回放图形界面的操作过程</p></li><li><p>追踪代码中的问题（甚至是难以复现的）</p></li><li><p>分析程序的性能</p></li><li><p>实现程序的自动化测试</p></li><li><p>部分实现程序的压力测试</p></li><li><p>执行系统级别的通用问题最终调试</p></li></ul><p>打开方式有以下三种：</p><ul><li><p>快捷键：CMD + I（对应小写的i）</p></li><li><p>Xcode -&gt; Open Developer Tool -&gt; Instruments</p></li><li><p>项目 -&gt; Product -&gt; Profile</p></li></ul><p>Instruments具体的界面如下所示：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305111713845.png"                                     ></p><ul><li><p>Blank：创建一个空的模板，可以自定义添加各种工具</p></li><li><p>Activity Monitor：跟踪整个系统的活动，包括 <code>CPU、内存、网络和磁盘</code>。默认情况下，活动监视器模板不会在时间线窗格中显示网络或磁盘活动</p></li><li><p>Allocations：使用Allocations和VM Tracker工具来测量应用程序中的常规和虚拟内存使用情况</p></li><li><p>Animation Hitches：用于检测滚动和动画问题，以帮助您可视化和研究应用程序的图形管道。通俗来讲就是检测界面流畅度，是否有卡顿情况</p></li><li><p>App Launch：使用 <code>5</code> 秒时间配置文件和线程状态跟踪调整应用程序启动性能</p></li><li><p>Core Data：可以检测应用程序中数据的存储交互，例如数据提取、缓存缺失和存储等</p></li><li><p>CPU Counters：收集使用时间或基于事件的抽样方法的性能监控计数器（PMC）事件，使用 Counters 工具来跟踪 <code>PMC</code> 事件。</p></li><li><p>CPU Profiler：用于分析 <code>CPU</code> 工作负载的基于周期的分析器，使用硬件性能监控中断（PMI）来提供更稳定的测量，无论代码是在性能 <code>CPU</code> 还是效率 <code>CPU</code> 上运行</p></li><li><p>File Activity：用于检查系统文件的使用情况，可以检查文件的打开、关闭、读和写操作，同时也可以检测文件系统本身的改变，包括权限和所有权发生的改变。</p></li><li><p>Game Performance：用于检测游戏性能和帧率</p></li><li><p>Leaks：用来检测内存的泄漏</p></li><li><p>Logging：来自统一日志系统的日志和路标的可视化。用于导入日志存档文件的默认模板</p></li><li><p>Metal System Trace：是apple 2014年在ios平台上推出的高效底层的3D图形API，它通过减少驱动层的API调用CPU的消耗提高渲染效率。</p></li><li><p>Network：使用连接工具来分析iOS应用程序的TCP&#x2F;IP和UDP&#x2F;IP连接</p></li><li><p>SceneKit：检测的app是使用了screenKit。用于确定每一帧的工作类型，例如动画、物理、场景剔除和渲染。</p></li><li><p>SwiftUI：SwiftUI分析工具，用于跟踪视图类型的 <code>.body</code> 调用、动态视图属性随时间的更新以及识别慢帧</p></li><li><p>System Trace：操作系统中事件发生的全视图。了解线程是如何跨 <code>CPU</code> 调度的，并了解系统调用和虚拟内存故障如何影响应用程序的性能</p></li><li><p>Time Profiler：使用时间分析器工具对系统CPU上运行的进程执行低开销、基于时间的采样。随着时间的推移，多核和线程的使用效率越高，应用程序的性能就越好。时间分析器工具中的CPU和线程策略显示了应用程序对内核和线程的利用程度。</p></li><li><p>Zombies：使用分配工具来测量应用程序中的一般内存使用情况，重点是检测过度释放的“zombie”对象，即在释放后调用的对象，这些对象不再存在。</p></li></ul><p>其中常用的是以下几种，后续会分别介绍如何使用及自定义</p><ul><li><p>Allocation</p></li><li><p>Animation Hitches</p></li><li><p>App Launch</p></li><li><p>Leaks</p></li><li><p>Network</p></li><li><p>Time Profiler：</p></li><li><p>Zombies</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通常程序运行时常见的错误大致分为两类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用户使用引起的外部错误，例如缺少参数、参数错误等&lt;/p&gt;
&lt;/li&gt;
</summary>
      
    
    
    
    <category term="OC" scheme="https://www.bboyzj.cn/categories/OC/"/>
    
    
    <category term="OC-底层原理探索篇" scheme="https://www.bboyzj.cn/tags/OC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E7%AF%87/"/>
    
  </entry>
  
</feed>
