<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>性能优化02：卡顿检测</title>
      <link href="/BboyZJ.github.io/2023/03/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602%EF%BC%9A%E5%8D%A1%E9%A1%BF%E6%A3%80%E6%B5%8B/"/>
      <url>/BboyZJ.github.io/2023/03/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602%EF%BC%9A%E5%8D%A1%E9%A1%BF%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>性能优化01：内存泄漏检测</title>
      <link href="/BboyZJ.github.io/2023/03/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B/"/>
      <url>/BboyZJ.github.io/2023/03/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OC学习03：内存管理</title>
      <link href="/BboyZJ.github.io/2023/03/02/OC%E5%AD%A6%E4%B9%A003%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/BboyZJ.github.io/2023/03/02/OC%E5%AD%A6%E4%B9%A003%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要介绍 <code>内存的五大区</code> 、<code>函数栈</code> 和 <code>内存管理</code></p><h1 id="内存五大区"><a href="#内存五大区" class="headerlink" title="内存五大区"></a>内存五大区</h1><p>在iOS中，内存主要分为 <code>栈区、堆区、全局区、常量区、代码区</code> 五个区域，如下图所示：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021853105.png"                                     ></p><h2 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h2><p><strong>定义</strong></p><ul><li><p>栈是 <code>系统数据结构</code>，其对应的 <code>进程或者线程是唯一的</code></p></li><li><p>栈是 <code>向低地址扩展</code> 的数据结构</p></li><li><p>栈是一块 <code>连续的内存区域</code>，遵循 <code>先进后出（FILO）</code> 原则</p></li><li><p>栈区一般在 <code>运行时</code> 分配</p></li></ul><p><strong>存储</strong></p><p>栈区是由 <code>编译器自动分配并释放</code>的，主要用来存储</p><ul><li><p><code>局部变量</code></p></li><li><p><code>函数的参数</code>，例如函数的隐藏参数（id self, SEL _cmd）</p></li></ul><p><strong>优缺点</strong></p><ul><li><p>优点：因为栈是由 <code>编译器自动分配并释放</code> 的，不会产生内存碎片，所以 <code>快速高效</code></p></li><li><p>确定：栈的 <code>内存大小有限制，数据不灵活</code></p><ul><li><code>iOS主线程大小是1MB</code></li><li>其他线程是 <code>512KB</code></li><li><code>MAC</code> 只有 <code>8MB</code></li></ul></li></ul><p>以上内存大小的说明，在<a class="link"   href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW7" >Threading Programming Guide <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中有相关说明，如下图：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021857274.png"                                     ></p><h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><p><strong>定义</strong></p><ul><li><p>堆是 <code>向高地址扩展</code> 的数据结构</p></li><li><p>堆是 <code>不连续的内存区域</code>，类似于 <code>链表结构</code>（便于增删，不便于查询），遵循 <code>先进先出（FIFO）</code>原则</p></li><li><p>堆的 <code>地址空间</code> 在iOS中是是动态的</p></li><li><p>堆区的分配一般是以在 <code>运行时分配</code></p></li></ul><p><strong>存储</strong></p><p>堆区是 <code>由程序员动态分配和释放</code> 的，如果程序员不释放，程序结束后，可能由操作系统回收，主要用于存放：</p><ul><li><p><code>OC</code> 中使用 <code>alloc</code> 、 <code>new</code> 开辟空间创建 <code>对象</code> ，或者 <code>block经过copy后</code> </p></li><li><p><code>C</code> 语言中使用 <code>malloc、calloc、realloc</code> 分配的空间，需要 <code>free</code> 释放</p></li><li><p>一般一个 <code>new/alloc</code> 就要对应一个 <code>release</code>，在 <code>ARC</code> 下编译器会自动在合适位置为 <code>OC</code> 对象添加 <code>release</code> 操作，会在当前 <code>线程Runloop退出或休眠时销毁这些对象</code>。<code>MRC</code> 则需程序员手动释放。</p></li></ul><p><strong>优缺点</strong></p><ul><li><p>优点：灵活方便，数据适应面广泛</p></li><li><p>缺点：需 <code>手动管理、速度慢</code>，容易产生内存碎片</p></li></ul><p>当需要访问堆中数据时，一般需要 <code>先通过对象读取到栈区的指针地址</code>，然后通过 <code>指针地址访问堆区</code></p><h2 id="全局区（静态区，即-bss-amp-data）"><a href="#全局区（静态区，即-bss-amp-data）" class="headerlink" title="全局区（静态区，即.bss &amp; .data）"></a>全局区（静态区，即.bss &amp; .data）</h2><p>全局区是 <code>编译时分配</code> 的内存空间，在程序运行过程中，此内存中的数据一直存在，<code>程序结束后由系统释放</code>，主要存放：</p><ul><li><p><code>未初始化的全局变量和静态变量</code>，即BSS区（.bss）</p></li><li><p><code>已初始化的全局变量和静态变量</code>，即DATA区（.data）</p></li></ul><p>其中，<code>全局变量</code> 是指变量值可以在 <code>运行时被动态修改</code>，而 <code>静态变量</code> 是 <code>static</code> 修饰的变量，包含 <code>静态局部变量</code> 和 <code>静态全局变量</code></p><h2 id="常量区（即-rodata）"><a href="#常量区（即-rodata）" class="headerlink" title="常量区（即.rodata）"></a>常量区（即.rodata）</h2><p>常量区是 <code>编译时分配</code> 的内存空间，在 <code>程序结束后由系统释放</code>，主要存放：</p><ul><li>已经使用了的，且没有指向的 <code>字符串常量</code></li></ul><p>字符串常量因为可能在程序中被多次使用，所以在程序运行之前就会提前分配内存</p><h2 id="代码区（即-text）"><a href="#代码区（即-text）" class="headerlink" title="代码区（即.text）"></a>代码区（即.text）</h2><p>代码区是 <code>由编译时分配</code>，主要用于存放 <code>程序运行时的代码</code>，代码会被编译成 <code>二进制存进内存</code> 的</p><h2 id="内存五大区验证"><a href="#内存五大区验证" class="headerlink" title="内存五大区验证"></a>内存五大区验证</h2><p>运行下面的一段代码，看看变量在内存中是如何分配的：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a = 10; // 全局区（已初始化的全局变量）</span><br><span class="line">char * b; // 全局区(未初始化的全局变量)</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    NSInteger i = 123; // 栈区（局部变量）</span><br><span class="line">    NSLog(@&quot;i的内存地址：%p&quot;, &amp;i);</span><br><span class="line">    </span><br><span class="line">    NSString *string = @&quot;ZJ&quot;; // 常量区（字符串常量）</span><br><span class="line">    NSLog(@&quot;string的内存地址：%p&quot;, string);</span><br><span class="line">    NSLog(@&quot;&amp;string的内存地址：%p&quot;, &amp;string);</span><br><span class="line">    </span><br><span class="line">    NSObject *obj = [[NSObject alloc] init]; // 堆区（alloc对象）</span><br><span class="line">    NSLog(@&quot;obj的内存地址：%p&quot;, obj);</span><br><span class="line">    NSLog(@&quot;&amp;obj的内存地址：%p&quot;, &amp;obj);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2022-03-11 14:34:25.438913+0800 内存五大区[70321:4340509] i的内存地址：0x16f6f5a18</span><br><span class="line">2022-03-11 14:34:25.438976+0800 内存五大区[70321:4340509] string的内存地址：0x100710098</span><br><span class="line">2022-03-11 14:34:25.438997+0800 内存五大区[70321:4340509] &amp;string的内存地址：0x16f6f5a10</span><br><span class="line">2022-03-11 14:34:25.439014+0800 内存五大区[70321:4340509] obj的内存地址：0x280fa0bc0</span><br><span class="line">2022-03-11 14:34:25.439031+0800 内存五大区[70321:4340509] &amp;obj的内存地址：0x16f6f5a08</span><br></pre></td></tr></table></figure></div><ul><li><p>对于 <code>局部变量i</code>， 存放在栈区</p></li><li><p>对于 <code>字符串对象string</code>，分别打印了 <code>string得对象地址</code> 和 <code>string对象的指针地址</code></p><ul><li>string的 <code>对象地址</code> 是是存放在 <code>常量区</code></li><li>string <code>对象的指针地址</code>，是存放在 <code>栈区</code></li></ul></li><li><p>对于 <code>alloc创建的对象obj</code>，分别打印了 <code>obj得对象地址</code> 和 <code>obj对象的指针地址</code></p><ul><li>obj的 <code>对象地址</code> 是存放在 <code>堆区</code> </li><li>obj <code>对象的指针地址</code> 是存放在 <code>栈区</code></li></ul></li></ul><h1 id="函数栈"><a href="#函数栈" class="headerlink" title="函数栈"></a>函数栈</h1><ul><li><p><code>函数栈</code> 又称为 <code>栈区</code>，在内存中从高地址往低地址分配，与堆区相对，具体图示请看上面</p></li><li><p><code>栈帧</code> 是指 <code>函数（运行中且未完成）占用的一块独立的连续内存区域</code></p></li><li><p>应用中新创建的 <code>每个线程都有专用的栈空间</code>，栈可以在线程期间自由使用，而线程中有千千万万的函数调用，这些函数 <code>共享</code> 进程的这个 <code>栈空间</code>。<code>每个函数所使用的栈空间是一个栈帧，所有栈帧就组成了这个线程完成的栈</code></p></li><li><p><code>函数调用是发生在栈上</code> 的，每个 <code>函数的相关信息</code>（例如局部变量、调用记录等）都 <code>存储在一个栈帧</code> 中，每执行一次 <code>函数调用</code>，就会生成一个与其相关的栈帧，然后将其 <code>栈帧压入函数栈</code>，而当函数 <code>执行结束</code>，则将此函数对应的 <code>栈帧出栈并释放掉</code></p></li></ul><p>如下图所示，是经典图- <code>ARM的栈帧布局方式</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021911717.png"                                     ></p><ul><li><p>其中 <code>main stack frame</code> 为调用函数的栈帧</p></li><li><p><code>func1 stack frame</code> 为当前 <code>当前函数（被调用者）的栈帧</code></p></li><li><p><code>栈底</code> 在 <code>高</code> 地址，栈向下增长</p></li><li><p><code>FP</code> 就是 <code>栈基址</code>，它指向函数的 <code>栈帧起始地址</code></p></li><li><p><code>SP</code> 则是函数的 <code>栈指针</code>，它指向 <code>栈顶</code> 的位置</p></li><li><p><code>ARM压栈</code> 的 <code>顺序</code> 很是规则（也比较容易被黑客攻破），依次为 <code>当前函数指针PC</code>、<code>返回指针LR</code>、<code>栈指针SP</code>、<code>栈基址FP</code>、<code>传入参数个数及指针</code>、<code>本地变量</code> 和 <code>临时变量</code>。如果函数准备调用另一个函数，跳转之前临时变量区先要保存另一个函数的参数</p></li><li><p><code>ARM</code> 也可以 <code>用栈基址和栈指针明确标示栈帧的位置</code>，栈指针SP一直移动，ARM的特点是，<code>两个栈空间内的地址（SP+FP）前面，必然有两个代码地址（PC+LP）明确标示着调用函数位置内的某个地址</code></p></li></ul><h2 id="堆栈溢出"><a href="#堆栈溢出" class="headerlink" title="堆栈溢出"></a>堆栈溢出</h2><p>一般情况下应用程序是不需要考虑堆和栈的大小的，但是事实上堆和栈不是无上限的，<code>过多的递归会导致栈溢出</code>，<code>过多的alloc变量会导致堆溢出</code></p><p>所以 <code>预防堆栈溢出</code> 的方法：</p><ul><li><p><code>避免层次过深</code> 的 <code>递归</code> 调用</p></li><li><p><code>不要使用过多的局部变量</code>，控制局部变量的大小</p></li><li><p><code>避免分配</code> 占用空间 <code>太大的对象</code>，并 <code>及时释放</code></p></li><li><p>实在不行，适当的情景下 <code>调用系统API修改线程的堆栈大小</code></p></li></ul><h2 id="栈帧示例"><a href="#栈帧示例" class="headerlink" title="栈帧示例"></a>栈帧示例</h2><p>描述下面代码的栈帧变化</p><p>栈帧程序示例</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int Add(int x,int y) &#123;</span><br><span class="line">    int z = 0;</span><br><span class="line">    z = x + y;</span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    int ret = Add(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序执行时，栈区中栈帧的变化如下图所示：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021912743.png"                                     ></p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>在iOS中开发中，我们或多或少都听说过内存管理。iOS的内存管理一般指的是OC对象的内存管理，因为OC对象分配在堆内存，堆内存需要程序员自己去动态分配和回收；基础数据类型(非OC对象)则分配在栈内存中，超过作用域就会由系统检测回收。如果我们在开发过程中，对内存管理得不到位，就有可能造成内存泄露。</p></li><li><p>我们通常讲的内存管理，实际上从发展的角度来说，分为两个阶段：<code>MRC和ARC</code>。</p><ul><li><p>MRC指的是 <code>手动内存管理</code>，在开发过程中需要开发者手动去编写内存管理的代码；</p></li><li><p>ARC指的是 <code>自动内存管理</code>，在此内存管理模式下由LLVM编译器和OC运行时库生成相应内存管理的代码。</p></li></ul></li></ul><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><ul><li><p>在 <code>OC</code> 中，使用 <code>引用计数</code> 来 <code>进行内存管理</code>。</p></li><li><p>每个对象都有一个与其相对应的引用计数器，当持有一个对象，这个对象的引用计数就会递增；当这个对象的某个持有被释放，这个对象的引用计数就会递减。当这个对象的引用计数变为0，那么这个对象就会被系统回收。</p></li><li><p>当一个对象使用完没有释放，此时其引用计数永远大于1。该对象就会一直占用其分配在堆内存的空间，就会导致内存泄露。内存泄露到一定程度有可能导致内存溢出，进而导致程序崩溃。</p></li></ul><h2 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h2><ol><li>简介</li></ol><p>全称 Manual Reference Counting，管理通过使用 <code>retain, release</code>, 以及 <code>autorelease</code> 的消息发送来实现。</p><ul><li>retain: 持有（拥有）对象，对象引用数加 1</li><li>release: 释放对象，对象引用数减 1</li><li>autorelease: 通知系统，在 <code>@autoreleasepool</code> 代码块结束时，对对象调用 <code>release</code></li></ul><ol start="2"><li>管理原则</li></ol><ul><li>自己创建的对象，自己获得拥有权</li></ul><p>在苹果规定中，使用 <code>alloc/new/copy/mutableCopy</code> 创建返回的对象归调用者所有，例如以下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* NSMutableArray类对象A */</span><br><span class="line">NSMutableArray *array = [[NSMutableArray alloc] init];    </span><br><span class="line">NSLog(@&quot;%p&quot;, array);</span><br><span class="line">[array release]; // 释放</span><br></pre></td></tr></table></figure></div><p>由于对象 <code>A</code> 由 <code>alloc</code> 生成，符合苹果规定，<code>指针变量array指向并持有对象A</code>，引用计数器会加 1。另外，array在使用完对象A后需要对其进行释放。当调用release后，释放了其对对象A的引用，计数器减1。对象A此时引用计数值为零，所以对象A被回收。不能访问已经被回收的对象，会发生崩溃。</p><ul><li>别人创建的对象，可以通过 <code>retain</code> 来获得拥有权</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 例如已有 fooArray, 通过 array 方法获得其引用</span><br><span class="line">NSArray *bar = [fooArray array];</span><br><span class="line"></span><br><span class="line">// 不可以直接调用 release，因为没有拥有权</span><br><span class="line">// [bar release];</span><br><span class="line"></span><br><span class="line">// 需要先 retain 来获得拥有权，然后才能释放</span><br><span class="line">[bar retain];</span><br><span class="line">[bar release];</span><br></pre></td></tr></table></figure></div><ul><li><p>你所拥有的对象不再需要使用时，必须将其释放</p></li><li><p>不能释放你不拥有的对象</p></li></ul><ol start="3"><li>retain</li></ol><ul><li>retain和属性</li></ul><p>我们可以通过属性来保存对象，如果一个属性为强引用，我们就可以通过属性的实例变量和存取方法来对某个对象进行操作，例如某个属性的setter方法如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)setPerson:(Person *)person &#123;</span><br><span class="line"></span><br><span class="line">    [person retain];</span><br><span class="line">    </span><br><span class="line">    [_person release];</span><br><span class="line">    </span><br><span class="line">    _person = person;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>我们通过 <code>retain新值</code>，<code>release旧值</code>，再给实例变量更新值。</p><p>需要注意的一点是：需要先retain新值，再release旧值。因为如果新旧值是同一个对象的话，先release就有可能导致该对象被系统回收，再去retain就没有任何意义了。例如下面这个例子：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong)Person *person;</span><br><span class="line">@end</span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">  </span><br><span class="line">    // 实例变量持有Person类对象(P对象)。这样赋值不会调用set方法</span><br><span class="line">    _person = [[Person alloc] init];</span><br><span class="line">    </span><br><span class="line">    // 调用set方法</span><br><span class="line">    self.person = _person;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setPerson:(Person *)person &#123;</span><br><span class="line">    // release释放对P对象的引用，P对象引用计数值变为零，则P对象被系统回收</span><br><span class="line">    [_person release];</span><br><span class="line"></span><br><span class="line">    // 由于P对象已经被回收，再去retain就容易出问题</span><br><span class="line">    [person retain];</span><br><span class="line">    </span><br><span class="line">    _person = person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>由于P对象被回收，对应其所分配的内存被置于 <code>可用内存池</code> 中。如果该内存未被覆写，那么P对象依然有效；如果内存被覆写，那么实例变量_person就会指向一个被覆写的未知对象的指针，那么实例变量就变成一个 <code>悬挂指针</code>。</p><ul><li>retain和数组</li></ul><p>如果我们把一个对象加入到一个数组中，那么该数组的addObject方法会对该对象调用retain方法。例如以下代码：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// person获得并持有P对象，P对象引用计数为1</span><br><span class="line">Person *person = [[Person alloc] init]; // Person类对象生成的P对象</span><br><span class="line">    </span><br><span class="line">NSMutableArray *array = [NSMutableArray array];</span><br><span class="line">    </span><br><span class="line">// person被加入到数组，对象P引用计数值为2</span><br><span class="line">[array addObject:person];</span><br><span class="line">    </span><br></pre></td></tr></table></figure></div><p>此时，对象P被person和array两个变量同时持有。</p><ol start="4"><li>release</li></ol><ul><li>自己持有的对象自己释放</li></ul><p>当我们持有一个对象，如果在不需要继续使用该对象，我们需要对其进行释放(release)。例如以下代码：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// array获得并持有NSArray类对象</span><br><span class="line">NSArray *array = [[NSArray alloc] init];</span><br><span class="line">    </span><br><span class="line">// 当不再需要使用该对象时，需要释放</span><br><span class="line">[array release];</span><br><span class="line">    </span><br><span class="line">// obj获得但不持有该对象</span><br><span class="line">id obj = [NSArray array];</span><br></pre></td></tr></table></figure></div><ul><li>非自己持有的对象不要释放</li></ul><p>当我们不持有某个对象，却对该对象进行释放，应用程序就会崩溃。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获得并持有A对象</span><br><span class="line">Person *p = [[Person alloc] init]; // Person类对象A</span><br><span class="line">    </span><br><span class="line">// 对象A引用计数为零，所以对象A被回收</span><br><span class="line">[p release];</span><br><span class="line"></span><br><span class="line">// 释放非自己持有的对象</span><br><span class="line">[p release];</span><br></pre></td></tr></table></figure></div><p>另外，我们也不能访问某个已经被释放的对象，该对象所占的堆空间如果被覆写就会发生崩溃的情况。</p><ol start="5"><li>autorelease</li></ol><p><code>autorelease</code> 指的是自动释放，当一个对象收到 <code>autorelease</code> 的时候，该 <code>对象就会被注册到当前处于栈顶的自动释放池（autorelease pool）</code>。如果没有主动生成自动释放池，则当前自动释放池对应的是主运行循环的自动释放池。在当前线程的RunLoop进入休眠前，就会对被注册到该自动释放池的所有对象进行一次release操作。</p><p>autorelease和release的区别是：</p><ul><li><p>release：是马上释放对某个对象的强引用；</p></li><li><p>autorelease：是延迟释放某个对象的生命周期。</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 外部调用</span><br><span class="line">    Person *p = [Person person];</span><br><span class="line">    NSLog(@&quot;%p&quot;, p); //使用无须retain</span><br><span class="line"></span><br><span class="line">    // 持有则需要retain</span><br><span class="line">    [p retain];</span><br><span class="line">    _person = p;</span><br><span class="line">    [_person release];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Person类内部定义</span><br><span class="line">+ (id)person &#123;</span><br><span class="line"></span><br><span class="line">    //创建的Person类对象由person获得并持有</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">   </span><br><span class="line">    // [person release];</span><br><span class="line"></span><br><span class="line">    // 将 person 对象放入自动释放池</span><br><span class="line">    [person autorelease];</span><br><span class="line">    </span><br><span class="line">    return person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在外部调用，从方法名person知道，创建的对象由p指针变量获得但不持有。在函数内部，person获得并持有了Person类对象，所返回的person对象的引用计数加1。换句话说，调用者需要额外处理这多出来的一个持有操作。另外，我们不能在函数内部调用release，不然对象还没返回就已经被系统回收。这时候使用autorelease就能很好地解决这个问题。</p><p>只要把要返回的对象调用autorelease方法，注册到自动释放池就能延长person对象的生命周期，使其在 autorelease pool销毁(drain)前依然能够存活。</p><p>另外，person对象在返回时调用了 <code>autorelease方法</code>。该对象已经在自动释放池中，我们可以直接使用对象p，无须再通过[p retain]访问；不过，如果要用实例变量持有该对象，则需要对变量p进行一次retain操作，实例变量使用完该对象需要释放该对象。</p><ol start="6"><li>autorelease pool</li></ol><ul><li><code>autorelease pool</code> 和 <code>RunLoop(运行循环)</code></li></ul><p>当应用程序启动，系统默认会 <code>开启一条线程</code>，该线程就是 <code>主线程</code>。主线程也有一个与之对应的自动释放池。</p><p><code>每条线程都包含一个与其对应的自动释放池</code>，当某条线程被终止的时候，对应该线程的自动释放池会被销毁。同时，处于该自动释放池的对象将会进行一次 <code>release</code> 操作。</p><p>，例如我们常见的 <code>ARC</code> 下的 <code>main.h</code> 文件：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>该自动释放池用来释放在主线程下注册到该自动释放池的对象。</p><p>需要注意的是，当我们 <code>开启一条子线程</code>，并且在该线程 <code>开启RunLoop</code> 的时候，需要为其增加一个<code>autorelease pool</code>，这样有助于保证内存的安全。</p><ul><li>autorelease pool和降低内存峰值</li></ul><p>当我们执行一些复杂的操作，特别是如果这些复杂的操作要被循环执行，那么中间会免不了会产生一些临时变量。当被加到主线程自动释放池的对象越来越来多，却没有得到及时释放，就会导致内存溢出。这个时候，我们可以手动添加自动释放池来解决这个问题。如以下例子所示：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; largeNumber; i++) &#123;</span><br><span class="line">        </span><br><span class="line">    // 创建自动释放池</span><br><span class="line">    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">    </span><br><span class="line">    // 产生许多被注册到自动释放池的临时对象</span><br><span class="line">    id obj = [Person personWithComplexOperation];</span><br><span class="line">    </span><br><span class="line">    // 释放池中对象</span><br><span class="line">    [pool drain];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如上述例子所示，我们执行的循环次数是一个非常大的数字。并且调用personWithComplexOperation方法的过程中会产生许多临时对象，所产生的临时对象有可能会被注册到自动释放池中。我们通过手动生成一个自动释放池，并且在每次循环结束前把该自动释放池的对象执行release操作释放掉，这样就能有效地降低内存的峰值了。</p><h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><ol><li>概述</li></ol><ul><li><p>Automatic Reference Counting，<code>自动引用计数</code>，即 <code>ARC</code>，<code>WWDC2011</code> 和 <code>iOS5</code> 所引入的最大的变革和最激动人心的变化。ARC是新的LLVM 3.0编译器的一项特性，使用ARC，可以说举解决了广大iOS开发者所憎恨的手动内存管理的麻烦。</p></li><li><p>此处的 <code>A</code> 就是 <code>automatic</code>。其实 <code>ARC</code> 只是比 <code>MRC</code> 多了一步，就是在 <code>编译时编译器自动帮开发者添加 retain, release 以及 autorelease 的调用</code>，底层的内存管理机制还是和 <code>MRC</code> 一样。</p></li><li><p>在 <code>ARC</code> 模式下，我们通常在对象变量的声明里用 <code>属性标记符</code> 来指引 <code>ARC</code> 机制来管理我们的对象变量，它们是：<code>strong, retain, weak, copy, assign</code>。默认标记是 <code>strong</code></p></li></ul><ol start="2"><li>标记符的区别</li></ol><ul><li>strong: 顾名思义，就是 <code>强引用</code>，对应 <code>MRC</code> 下的 <code>retain</code>，即引用数加 1</li><li>retain: 同 <code>strong</code></li><li>weak: 弱引用，不增加引用数，引用的对象被释放后变为 <code>nil</code></li><li>copy: 对对象进行 <code>copy</code> 后再赋值，因此对象必须遵循 <code>NSCopying</code> 协议。如：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property(copy)Foo *foo;</span><br><span class="line">...</span><br><span class="line">self.foo = bar;  // 相当于 self.foo = [bar copy];</span><br></pre></td></tr></table></figure></div><ul><li>assign: 一般用于原始数据类型（primitive type）的赋值。可以用于对象，效果相当于 weak，可是有一个坑是当对象被释放后，assign 属性的变量不会变成 nil，而是成为 <code>野指针</code>（dangling pointer），因此不建议使用在对象上。</li></ul><p>借助以上的属性标记符，我们可以在对象声明的时候集中制定它们的内存管理策略，清晰明了。</p><ol start="3"><li>ARC的判断原则</li></ol><p>ARC判断一个对象是否需要释放不是通过引用计数来进行判断的，而是通过强指针来进行判断的。那么什么是强指针?</p><ul><li><p>强指针</p><ul><li>默认所有对象的指针变量都是强指针</li><li>被__strong修饰的指针</li></ul></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *p1 = [[Person alloc] init];</span><br><span class="line">__strong  Person *p2 = [[Person alloc] init];</span><br></pre></td></tr></table></figure></div><ul><li><p>弱指针</p><ul><li>被 <code>__weak</code> 修饰的指针</li></ul></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak  Person *p = [[Person alloc] init];</span><br></pre></td></tr></table></figure></div><p><strong>ARC如何通过强指针来判断？</strong></p><ul><li>只要还有一个强指针变量指向对象，对象就会保持在内存中</li></ul><ol start="4"><li>ARC的使用</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // 不用写release, main函数执行完毕后p会被自动释放</span><br><span class="line">    Person *p = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="5"><li>ARC的注意点</li></ol><ul><li>不允许调用对象的 <code>release方法</code></li><li>不允许调用 <code>autorelease方法</code></li><li>重写父类的dealloc方法时，不能再调用 <code>[super dealloc]</code>;</li></ul><ol start="6"><li>ARC下单对象内存管理</li></ol><ul><li>局部变量释放对象随之被释放</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">    &#125; // 执行到这一行局部变量p释放</span><br><span class="line">    // 由于没有强指针指向对象, 所以对象也释放</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>清空指针对象随之被释放</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">        p = nil; // 执行到这一行, 由于没有强指针指向对象, 所以对象被释放</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>默认清空所有指针都是强指针</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">        // p1和p2都是强指针</span><br><span class="line">        Person *p1 = [[Person alloc] init];</span><br><span class="line">        __strong Person *p2 = [[Person alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li><p>弱指针需要明确说明</p><ul><li>注意: 千万不要使用弱指针保存新创建的对象</li></ul></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">        // p是弱指针, 对象会被立即释放</span><br><span class="line">        __weak Person *p1 = [[Person alloc] init];</span><br><span class="line">        NSLog(@&quot;%@&quot;,p);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-07-31 18:02:51.021697+0800 iOS-OC之ARC[2134:984503] (null)</span><br></pre></td></tr></table></figure></div><ol start="7"><li>ARC下多对象内存管理</li></ol><p>ARC和MRC一样, 想拥有某个对象必须用强指针保存对象, 但是不需要在dealloc方法中release</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">// MRC写法</span><br><span class="line">//@property (nonatomic, retain) Dog *dog;</span><br><span class="line"></span><br><span class="line">// ARC写法</span><br><span class="line">@property (nonatomic, strong) Dog *dog;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><h2 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h2><ol><li>概述</li></ol><ul><li><p><code>AutoreleasePool</code>（自动释放池）是 <code>OC</code> 中的一种 <code>内存自动回收机制</code>。</p></li><li><p>当向一个对象发送 <code>autorelease</code> 消息时，会将对象加入到自动释放池，这个对象不会立即释放，而是等到 <code>runloop休眠或超出autoreleasepool作用域</code> 之后进行 <code>释放</code>。</p></li></ul><ol start="2"><li>MRC 下使用自动释放池</li></ol><p>在MRC环境中使用自动释放池需要用到 <code>NSAutoreleasePool</code> 对象，其生命周期就相当于C语言变量的作用域。对于所有调用过 autorelease方法的对象，在废弃NSAutoreleasePool对象时，都将调用release实例方法。用源代码表示如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// MRC环境下的测试：</span><br><span class="line">// 第一步：生成并持有释放池NSAutoreleasePool对象;</span><br><span class="line">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line"></span><br><span class="line">// 第二步：调用对象的autorelease实例方法;</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line"></span><br><span class="line">// 第三步：废弃NSAutoreleasePool对象;</span><br><span class="line">[pool drain];   // 向pool管理的所有对象发送消息，相当于[obj release]</span><br><span class="line"></span><br><span class="line">// obj已经释放，再次调用会崩溃(Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT))</span><br><span class="line">NSLog(@&quot;打印obj：%@&quot;, obj); </span><br></pre></td></tr></table></figure></div><ol start="3"><li><code>ARC</code> 下使用自动释放池</li></ol><p>ARC环境不能使用NSAutoreleasePool类也不能调用autorelease方法，代替它们实现对象自动释放的是 <code>@autoreleasepool块</code>。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ARC环境下的测试：</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">    id obj = [[NSObject alloc] init];</span><br><span class="line">    NSLog(@&quot;打印obj：%@&quot;, obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="ARC-下-AutoReleasePool-内部实现"><a href="#ARC-下-AutoReleasePool-内部实现" class="headerlink" title="ARC 下 AutoReleasePool 内部实现"></a>ARC 下 AutoReleasePool 内部实现</h2><h3 id="使用-autoreleasepool"><a href="#使用-autoreleasepool" class="headerlink" title="使用@autoreleasepool{}"></a>使用@autoreleasepool{}</h3><p>我们在main函数中写入自动释放池相关的测试代码如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>为了探究释放池的底层实现，我们在终端使用 clang -rewrite-objc + 文件名命令将上述OC代码转化为 <code>C++</code> 源码：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */</span><br><span class="line">    &#123;</span><br><span class="line">        __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_d37e0d_mi_0);</span><br><span class="line">     &#125; // 大括号对应释放池的作用域</span><br><span class="line">     </span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在经过编译器 <code>clang</code> 命令转化后，我们看到的所谓的 <code>@autoreleasePool块</code>，其实对应着<br><code>__AtAutoreleasePool的结构体</code>。</p><h3 id="分析结构体-AtAutoreleasePool-的具体实现"><a href="#分析结构体-AtAutoreleasePool-的具体实现" class="headerlink" title="分析结构体 __AtAutoreleasePool 的具体实现"></a>分析结构体 <code>__AtAutoreleasePool</code> 的具体实现</h3><p>在源码中找到 <code>__AtAutoreleasePool结构体</code> 的实现代码，具体如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);</span><br><span class="line"></span><br><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>__AtAutoreleasePool结构体包含了：<code>构造函数、析构函数和一个对象</code>；</p><p>构造函数内部调用：<code>objc_autoreleasePoolPush()</code> 方法，返回对象<code>atautoreleasepoolobj</code></p><p>析构函数内部调用：<code>objc_autoreleasePoolPop()</code> 方法，传入对象<code>atautoreleasepoolobj</code></p><ul><li>分析main函数中 __autoreleasepool结构体实例的生命周期是这样的：</li></ul><p>__autoreleasepool是一个自动变量，其构造函数是在程序执行到声明这个对象的位置时调用的，而其析构函数则是在程序执行到离开这个对象的作用域时调用。所以，我们可以将上面main函数的代码简化如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123;</span><br><span class="line">        void *atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kb_06b822gn59df4d1zt99361xw0000gn_T_main_d39a79_mi_0);</span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><code>objc_autoreleasePoolPush</code> 与 <code>objc_autoreleasePoolPop</code><br>进一步观察自动释放池构造函数与析构函数的实现，其实它们都只是对<br><code>AutoreleasePoolPage</code> 对应静态方法 <code>push</code> 和 <code>pop</code> 的封装：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void *objc_autoreleasePoolPush(void) &#123;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void objc_autoreleasePoolPop(void *ctxt) &#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="理解-AutoreleasePoolPage"><a href="#理解-AutoreleasePoolPage" class="headerlink" title="理解 AutoreleasePoolPage"></a>理解 <code>AutoreleasePoolPage</code></h3><p><code>AutoreleasePoolPage</code> 是一个 <code>C++</code> 中的类，打开Runtime的源码工程，在NSObject.mm文件中可以找到它的定义，摘取其中的关键代码如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage &#123;</span><br><span class="line">#   define EMPTY_POOL_PLACEHOLDER ((id*)1)  // 空池占位</span><br><span class="line">#   define POOL_BOUNDARY nil                // 即哨兵对象</span><br><span class="line">    static pthread_key_t const key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    static uint8_t const SCRIBBLE = 0xA3;  // 0xA3A3A3A3 after releasing</span><br><span class="line">    static size_t const SIZE = </span><br><span class="line">#if PROTECT_AUTORELEASEPOOL</span><br><span class="line">        PAGE_MAX_SIZE;  // must be multiple of vm page size</span><br><span class="line">#else</span><br><span class="line">        PAGE_MAX_SIZE;  // size and alignment, power of 2</span><br><span class="line">#endif</span><br><span class="line">    static size_t const COUNT = SIZE / sizeof(id);</span><br><span class="line">    magic_t const magic;                  // 校验AutoreleasePagePoolPage结构是否完整</span><br><span class="line">    id *next;                             // 指向新加入的autorelease对象的下一个位置，初始化时指向begin()</span><br><span class="line">    pthread_t const thread;               // 当前所在线程，AutoreleasePool是和线程一一对应的</span><br><span class="line">    AutoreleasePoolPage * const parent;   // 指向父节点page，第一个结点的parent值为nil</span><br><span class="line">    AutoreleasePoolPage *child;           // 指向子节点page，最后一个结点的child值为nil</span><br><span class="line">    uint32_t const depth;                 // 链表深度，节点个数</span><br><span class="line">    uint32_t hiwat;                       // 数据容纳的一个上限</span><br><span class="line">    //......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p><code>AutoreleasePoolPage</code> 中拥有 <code>parent 和 child 指针</code>，分别指向上一个和下一个 <code>page</code>；当前一个page的空间被占满(每个AutorelePoolPage的大小为4096字节)时，就会新建一个AutorelePoolPage对象并连接到链表中，后来的Autorelease对象也会添加到新的page中；<br>另外，当next&#x3D;&#x3D; begin()时，表示AutoreleasePoolPage为空；当next &#x3D;&#x3D; end()，表示AutoreleasePoolPage已满。</p><ul><li>理解 <code>哨兵对象(POOL_BOUNDARY)的作用</code>，而它的作用事实上也就是为了 <code>起到一个标识的作用</code>。</li></ul><p>每当自动释放池初始化调用 <code>objc_autoreleasePoolPush</code> 方法时，总会通过 <code>AutoreleasePoolPage</code> 的 <code>push</code> 方法，将 <code>POOL_BOUNDARY</code> 放到当前 <code>page</code> 的栈顶，并且返回这个对象 <code>atautoreleasepoolobj</code>；</p><p>而在自动释放池释放调用 <code>objc_autoreleasePoolPop</code> 方法时，又会将 <code>atautoreleasepoolobj对象</code> 以参数传入，这样自动释放池就会向释放池中对象发送release消息，直至找到第一个边界对象为止。</p><h3 id="理解-objc-autoreleasePoolPush-方法"><a href="#理解-objc-autoreleasePoolPush-方法" class="headerlink" title="理解 objc_autoreleasePoolPush 方法"></a>理解 <code>objc_autoreleasePoolPush</code> 方法</h3><p>经过前面的分析，<code>objc_autoreleasePoolPush</code> 最终调用的是 <code>AutoreleasePoolPage</code> 的 <code>push</code> 方法，该方法的具体实现如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static inline void *push() &#123;</span><br><span class="line">   return autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line">&#123;</span><br><span class="line">   AutoreleasePoolPage *page = hotPage();</span><br><span class="line">   if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">       return page-&gt;add(obj);</span><br><span class="line">   &#125; else if (page) &#123;</span><br><span class="line">       return autoreleaseFullPage(obj, page);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">1.        return autoreleaseNoPage(obj);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 压栈操作：将对象加入AutoreleaseNoPage并移动栈顶的指针</span><br><span class="line">id *add(id obj) &#123;</span><br><span class="line">    id *ret = next;</span><br><span class="line">    *next = obj;</span><br><span class="line">    next++;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当前hotPage已满时调用</span><br><span class="line">static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        if (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        else page = new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; while (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当前hotpage不存在时调用</span><br><span class="line">static id *autoreleaseNoPage(id obj) &#123;</span><br><span class="line">    AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line"></span><br><span class="line">    if (obj != POOL_SENTINEL) &#123;</span><br><span class="line">        page-&gt;add(POOL_SENTINEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>观察上述代码，每次调用 <code>push</code> 其实就是 <code>创建一个新的AutoreleasePoolPage</code>，在对应的AutoreleasePoolPage中插入一个 <code>POOL_BOUNDARY</code> ，并且返回插入的 <code>POOL_BOUNDARY</code> 的内存地址。自动释放池最终都会通过 <code>page-&gt;add(obj)</code> 方法 <code>将对象添加到page中</code>，而这一过程被分为三种情况：</p><pre><code>* 当前page存在且不满，调用 `page-&gt;add(obj)` 方法将 `对象` 添加至page的栈中，即next指向的位置* 当前page存在但是已满，调用 autoreleaseFullPage 初始化一个新的 page，调用page-&gt;add(obj)方法将对象添加至page的栈中* 当前page不存在时，调用 autoreleaseNoPage 创建一个 hotPage，再调用page-&gt;add(obj) 方法将对象添加至page的栈中</code></pre><h3 id="理解-objc-autoreleasePoolPop-方法"><a href="#理解-objc-autoreleasePoolPop-方法" class="headerlink" title="理解 objc_autoreleasePoolPop 方法"></a>理解 <code>objc_autoreleasePoolPop</code> 方法</h3><ul><li><p><code>AutoreleasePool</code> 的释放调用的是 <code>objc_autoreleasePoolPop</code> 方法，此时需要传入  <code>atautoreleasepoolobj</code> 对象作为参数。</p></li><li><p>同理，我们找到 <code>objc_autoreleasePoolPop</code> 最终调用的方法，即 <code>AutoreleasePoolPage</code> 的pop方法，该方法的具体实现如下</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static inline void pop(void *token)   // POOL_BOUNDARY的地址</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line"></span><br><span class="line">    page = pageForPointer(token);   // 通过POOL_BOUNDARY找到对应的page</span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    if (DebugPoolAllocation  &amp;&amp;  *stop != POOL_SENTINEL) &#123;</span><br><span class="line">        // This check is not valid with DebugPoolAllocation off</span><br><span class="line">        // after an autorelease with a pool page but no pool in place.</span><br><span class="line">        _objc_fatal(&quot;invalid or prematurely-freed autorelease pool %p; &quot;, </span><br><span class="line">                    token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (PrintPoolHiwat) printHiwat();   // 记录最高水位标记</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);   // 向栈中的对象发送release消息，直到遇到第一个哨兵对象</span><br><span class="line"></span><br><span class="line">    // memory: delete empty children</span><br><span class="line">    // 删除空掉的节点</span><br><span class="line">    if (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        // special case: delete everything during page-per-pool debugging</span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125; else if (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        // special case: delete everything for pop(top) </span><br><span class="line">        // when debugging missing autorelease pools</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125; </span><br><span class="line">    else if (page-&gt;child) &#123;</span><br><span class="line">        // hysteresis: keep one empty child if page is more than half full</span><br><span class="line">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="【总结】"><a href="#【总结】" class="headerlink" title="【总结】"></a><strong>【总结】</strong></h3><p>【结构】：</p><ul><li><p>自动释放池的压栈和出栈，通过结构体的构造函数和析构函数实现：</p><ul><li><p>压栈：调用 <code>objc_autoreleasePoolPush()</code> 函数，内部调用的是 <code>AutoreleasePoolPage</code> 的 <code>push()</code> 方法，返回 <code>atautoreleasepoolobj</code> 对象</p></li><li><p>出栈：调用  <code>objc_autoreleasePololPop()</code> 函数，内部调用的是 <code>AutoreleasePoolPage</code> 的 <code>pop()</code> 方法，传入 <code>atautoreleasepoolobj</code> 对象</p></li></ul></li></ul><p>【容量】：</p><ul><li>池页大小为4096字节，每一页都包含56字节的成员变量，但一个自动释放池中，只会压栈一个哨兵对象，占8字节</li></ul><p>【原理】：</p><ul><li><p>自动释放池的本质是 <code>__AtAutoreleasePool</code> 结构体，包含构造函数和析构函数</p></li><li><p>结构体声明，触发构造函数，调用 <code>objc_autoreleasePoolPush()</code> 函数，对象压栈</p><ul><li><p>如果存在page，并且没有存满，调用add函数</p><ul><li>将对象压栈</li></ul></li><li><p>如果存在page，但存储已满，调用autoreleaseFullPage函数</p><ul><li>遍历链表，找到最后一个空白的子页面</li><li>对其进行创建新页</li><li>设置为热页面</li><li>添加对象</li></ul></li><li><p>否则，不存在page，调用autoreleaseNoPage函数</p><ul><li>通过父类AutoreleasePoolPageData进行初始化</li><li>begin：获取对象压栈的起始位置</li><li>objc_thread_self：通过tls获取当前线程</li><li>链接双向链表</li><li>设置为热页面</li><li>pushExtraBoundary为YES，哨兵对象压栈</li><li>对象压栈</li></ul></li></ul></li><li><p>结构体出作用域，触发析构函数，调用 <code>objc_autoreleasePoolPop()</code> 函数，对象出栈</p><ul><li>调用popPage函数，传入stop为哨兵对象的位置</li><li>当前页中对象出栈，到stop位置停止</li><li>调用kill函数，销毁当前页面</li></ul></li></ul><h1 id="AutoreleasePool在主线程上的释放时机"><a href="#AutoreleasePool在主线程上的释放时机" class="headerlink" title="AutoreleasePool在主线程上的释放时机"></a>AutoreleasePool在主线程上的释放时机</h1><ul><li>分析主线程RunLoop管理自动释放池并释放对象的详细过程，我们在如下Demo中的主线程中设置断点，并执行lldb命令：po [NSRunLoop currentRunLoop]，具体效果如下：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/89028090-42d71580-d35e-11ea-8578-2bdf6240de0a.png"                                     ></p><p>我们看到主线程RunLoop中有两个与自动释放池相关的Observer,对应CFRunLoopActivity的类型如下:</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),          //0x1，启动Runloop循环</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),            </span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),        </span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),  //0xa0，即将进入休眠     </span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),   </span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),           //0xa0，退出RunLoop循环  </span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></div><p>结合RunLoop监听的事件类型，分析主线程上自动释放池的使用过程如下：</p><ul><li><p>App启动后，苹果在主线程RunLoop里注册了两个Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler();</p></li><li><p>第一个Observer监视的事件</p><ul><li><code>Entry(即将进入Loop)</code>，其回调内会调用 _objc_autoreleasePoolPush()创建自动释放池。</li></ul></li><li><p>第二个Observer监视了两个事件 :</p><ul><li><p><code>BeforeWaiting(准备进入休眠)</code> 时调用_objc_autoreleasePoolPop()和_objc_autoreleasePoolPush()释放旧的池并创建新池；</p></li><li><p>Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop()来释放自动释放池。</p></li></ul></li><li><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄漏，开发者也不必显示创建AutoreleasePool了;</p></li><li><p>之后的时机</p><ul><li><p>程序启动到加载完成后，主线程对应的RunLoop会停下来等待用户交互</p></li><li><p>用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</p></li><li><p>RunLoop检测到事件后，就会创建自动释放池;</p></li><li><p>所有的延迟释放对象都会被添加到这个池子中;</p></li><li><p>在一次完整的运行循环结束之前，会向池中所有对象发送release消息，然后自动释放池被销毁;</p></li></ul></li></ul><h1 id="AutoreleasePool子线程上的释放时机"><a href="#AutoreleasePool子线程上的释放时机" class="headerlink" title="AutoreleasePool子线程上的释放时机"></a>AutoreleasePool子线程上的释放时机</h1><p>子线程默认不开启RunLoop，那么其中的延时对象该如何释放呢？其实这依然要从Thread和AutoreleasePool的关系来考虑：</p><ul><li><p>就是说，每一个线程都会维护自己的 <code>Autoreleasepool栈</code>，所以子线程虽然默认没有开启RunLoop，但是依然存在AutoreleasePool，在 <code>子线程退出</code> 的时候会去释放autorelease对象。</p></li><li><p>前面讲到过，ARC会根据一些情况进行优化，添加__autoreleasing修饰符，其实这就相当于对需要延时释放的对象调用了autorelease方法。从源码分析的角度来看，如果子线程中没有创建AutoreleasePool ，而一旦产生了Autorelease对象，就会调用autoreleaseNoPage方法自动创建hotpage，并将对象加入到其栈中。所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。</p></li></ul><h1 id="AutoreleasePool需要手动添加的情况"><a href="#AutoreleasePool需要手动添加的情况" class="headerlink" title="AutoreleasePool需要手动添加的情况"></a>AutoreleasePool需要手动添加的情况</h1><ul><li><p>尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建 <code>AutoreleasePool</code>，而其中的延时对象将在当前释放池的作用域结束时释放。苹果文档中说明了三种情况，我们可能会需要手动添加自动释放池：</p><ul><li>编写的不是基于UI框架的程序，例如命令行工具；</li><li>通过循环方式创建大量临时对象；</li><li>使用非Cocoa程序创建的子线程；</li></ul></li></ul><p>而在ARC环境下的实际开发中，我们最常遇到的也是第二种情况，以下面的代码为例：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    for (int i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">        NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">        NSLog(@&quot;打印obj：%@&quot;, obj);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><p>上述代码中，obj因为离开作用域所以会被加入最近一次创建的自动释放池中，而这个释放池就是主线程上的RunLoop管理的；因为for循环在当前线程没有执行完毕，Runloop也就没有完成当前这一次的迭代，所以导致大量对象被延时释放。释放池中的对象将会在viewDidAppear方法执行前就被销毁。在此情况下，我们就有必要通过手动干预的方式及时释放不需要的对象，减少内存消耗；优化的代码如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    for (int i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">        @autoreleasepool&#123;</span><br><span class="line">             NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">             NSLog(@&quot;打印obj：%@&quot;, obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习02：文件导入#include,#import,@class区别</title>
      <link href="/BboyZJ.github.io/2023/03/02/OC%E5%AD%A6%E4%B9%A002%EF%BC%9A%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5#include,#import,@class%E5%8C%BA%E5%88%AB/"/>
      <url>/BboyZJ.github.io/2023/03/02/OC%E5%AD%A6%E4%B9%A002%EF%BC%9A%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5#include,#import,@class%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p><code>#include</code> 、 <code>#import</code> 和 <code>@class</code> 都是用来 <code>包含头文件</code></p></li><li><p><code>C/C++</code> 只能用 <code>#include</code> 包含头文件，没有 <code>#import</code> 和 <code>@class</code></p></li><li><p><code>OC</code> 中 <code>#include</code> 、 <code>#import</code> 和 <code>@class</code> 都可以用</p></li></ul><p>那么问题来了，三种包含头文件方式在 <code>OC</code> 中有什么区别呢？</p><h1 id="include、import"><a href="#include、import" class="headerlink" title="include、import"></a>include、import</h1><ul><li><p>#include 会重复导入头文件，重复导入会报重复定义的错误；#import 不会重复导入头文件，允许交叉编译</p></li><li><p>#include &lt;xxx.h&gt; 或 #import &lt;xxx.h&gt; ：用于导入 <code>系统自带文件</code>，在 <code>系统文件目录下查找</code></p></li><li><p>#include “xxx.h” 或 #import “xxx.h” ：用于导入 <code>用户自定义的文件</code>，查找顺序：<code>用户文件目录 -&gt; 安装文件目录 -&gt; 系统文件目录</code>，所以 “xxx.h” 一般用来导入用户自定义的文件</p></li></ul><h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><ul><li>@class XXXClassName ： 用于声明一个类，用于解决互相引用的问题（A引用B，B引用A）</li></ul><h1 id="include-示例"><a href="#include-示例" class="headerlink" title="include 示例"></a>include 示例</h1><ul><li><code>A文件导入两次B文件</code>：报重复定义错误</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">// include 不允许重复导入两次</span><br><span class="line">#include &quot;VB.h&quot;</span><br><span class="line">#include &quot;VB.h&quot;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface VA : UIView</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p>command + b 编译报错：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021812383.png"                                     ></p><ul><li>A引用B，B引用C，A再引用C：同样 <code>报重复定义错误</code>，相当于A引用了两次C</li></ul><h1 id="import-示例"><a href="#import-示例" class="headerlink" title="import 示例"></a>import 示例</h1><ul><li>导入两次A文件，不报错</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 导入两次A文件</span><br><span class="line">#import &quot;A.h&quot;</span><br><span class="line">#import &quot;A.h&quot;</span><br></pre></td></tr></table></figure></div><h1 id="class-使用场景"><a href="#class-使用场景" class="headerlink" title="class 使用场景"></a>class 使用场景</h1><ul><li>A类引用B类，B类引用A：互相引用报错</li></ul><p>A.h文件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;B.h&quot;</span><br><span class="line">@interface A : UIView</span><br><span class="line">@property (nonatomic,strong)B * b;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p>B.h文件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;A.h&quot;</span><br><span class="line">@interface B : UIView</span><br><span class="line">@property (nonatomic,strong)A * a;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021813725.png"                                     ></p><ul><li>可以用 <code>@class</code> 方式进行引用，一个用@class或者两个都用 @class</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//#import &quot;A.h&quot;</span><br><span class="line"></span><br><span class="line">// class声明A</span><br><span class="line">@class A;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog-05：Picgo+Gitee图床</title>
      <link href="/BboyZJ.github.io/2023/03/01/Blog-05%EF%BC%9APicgo-Gitee%E5%9B%BE%E5%BA%8A/"/>
      <url>/BboyZJ.github.io/2023/03/01/Blog-05%EF%BC%9APicgo-Gitee%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近发现上传到 GitHub 上的图片大部分不能使用了，然后上网查了一下，应该是 DNS 的问题，网上也有很多解决方案，有兴趣的可以去网上找找，本文主要介绍 <code>Picgo + Gitee</code> 做图床。</p><h1 id="Picgo-介绍"><a href="#Picgo-介绍" class="headerlink" title="Picgo 介绍"></a>Picgo 介绍</h1><p><code>picgo</code> 是一款功能实用、操作简捷的图床工具，图床工具简单来说就是本地图片上传自动转换成链接的一款工具。</p><p>picgo 本体支持如下图床：</p><ul><li>七牛图床 v1.0</li><li>腾讯云 COS v4\v5 版本 v1.1 &amp; v1.5.0</li><li>又拍云 v1.2.0</li><li>GitHub v1.5.0</li><li>SM.MS V2 v2.3.0-beta.0</li><li>阿里云 OSS v1.6.0</li><li>Imgur v1.6.0</li></ul><p>Tips: 本体不再增加默认的图床支持。你可以自行开发第三方图床插件。</p><h1 id="特色功能"><a href="#特色功能" class="headerlink" title="特色功能"></a>特色功能</h1><ul><li>支持拖拽图片上传</li><li>支持快捷键上传剪贴板里第一张图片</li><li>Windows 和 macOS 支持右键图片文件通过菜单上传 (v2.1.0+)</li><li>上传图片后自动复制链接到剪贴板</li><li>支持自定义复制到剪贴板的链接格式</li><li>支持修改快捷键，默认快速上传快捷键：command+shift+p（macOS） | control+shift+p（Windows\Linux）</li><li>支持插件系统，已有插件支持 <code>Gitee、青云等第三方图床</code></li></ul><p>Tips:</p><ul><li>请确保你安装了 <code>Node.js</code>， 并且版本 &gt;&#x3D; 8。</li><li>默认上传图床为 <code>SM.MS</code>。<code>picgo</code> 上传之后，会自动将上传成功的 URL复制到你的剪贴板，支持5种复制格式。</li><li>Mini窗口只支持Windows（圆形）和Linux（方形），macOS可以使用顶部栏图标。（因为Windows和Linux的任务栏不支持拖拽事件）</li></ul><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li><code>nodejs</code> 环境</li><li><code>picgo</code> 客户端</li><li><code>picgo</code> 的 <code>Gitee</code> 上传插件</li><li><code>git、Gitee</code> 账号和一个公开仓库</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li><a class="link"   href="https://nodejs.org/zh-cn/download/" >nodejs官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 安装</li></ul><p>点击链接下载安装 nodejs，安装完成后，查看版本</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % node -v</span><br><span class="line">v18.14.2</span><br><span class="line">mac@bogon ~ % npm -v</span><br><span class="line">mac@bogon ~ % npm -v</span><br><span class="line">9.5.0</span><br></pre></td></tr></table></figure></div><ul><li>安装 <code>picgo</code> 客户端</li></ul><p><a class="link"   href="https://github.com/Molunerfinn/picgo/releases" >picgo安装链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>如果电脑是 <code>Intel</code> 就选 <code>x64</code>，如果电脑是 <code>M1</code> 就选 <code>arm64</code></p><ul><li>安装 git</li></ul><p>Mac 默认是已经安装好了 git</p><h1 id="注册-x2F-登录-Gitee-账号"><a href="#注册-x2F-登录-Gitee-账号" class="headerlink" title="注册&#x2F;登录 Gitee 账号"></a>注册&#x2F;登录 Gitee 账号</h1><ul><li><p><a class="link"   href="https://gitee.com/" >Gitee <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 首页按要求自行注册&#x2F;登录即可</p></li><li><p>新建一个 <code>Gitee</code> 仓库</p></li></ul><p>仓库名：随意，如 Picgo<br>私有<br>创建</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012136074.png"                                     ></p><ul><li>将仓库 <code>开源</code></li></ul><p>由于创建仓库的时候只能 <code>私有</code>，所以此步配置 <code>开源</code> 操作如下：</p><p>进入仓库 -&gt; 管理 -&gt; 基本信息 -&gt; 开源（空仓库不允许） -&gt; 保存</p><ul><li>生成 Token</li></ul><p><code>Token</code> 用于 <code>picgo</code> 操作 Gitee repository：</p><p>点击头像 -&gt; 设置 -&gt; 私人令牌 -&gt; 生成新令牌 -&gt; 提交</p><p>复制你生成的令牌，只显示一次，再次刷新则看不见了，因此你要保存好</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16776726761906.jpg"                                     ></p><h1 id="配置-picgo"><a href="#配置-picgo" class="headerlink" title="配置 picgo"></a>配置 picgo</h1><ul><li>启动 picgo -&gt; 插件设置 -&gt; 搜索 Gitee -&gt; 点击插件图标 <code>安装</code> 即可，本文使用 <code>gitee 2.0.5</code> 插件来进行演示</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012133116.jpg"                                     ></p><p>Tips： 插件装完后，重启生效</p><h1 id="配置-Gitee-插件"><a href="#配置-Gitee-插件" class="headerlink" title="配置 Gitee 插件"></a>配置 Gitee 插件</h1><p>进入 <code>图床设置</code> -&gt; gitee， 依次填入相关配置如下所示，填写如下：</p><ul><li><p>repo： 用户名&#x2F;仓库名（必填）， <code>bboy-zhang-jian/picgo</code></p></li><li><p>path: 上传路径，仓库里的图片保存路径（非必填）</p></li><li><p>token: 私人令牌（必填），刚才保存的 <code>token</code></p></li><li><p>message: 提交消息（非必填）</p></li><li><p>path: 上传路径，仓库里的图片保存路径（非必填）</p></li><li><p>customPath: 定制路径（非必填）</p></li><li><p>customUrl: 图片定制URL（非必填）</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012137612.png"                                     ></p><h1 id="将仓库开源"><a href="#将仓库开源" class="headerlink" title="将仓库开源"></a>将仓库开源</h1><p>头像 -&gt; 仓库 -&gt; 管理 -&gt; 公开 -&gt; 仓库公开须知全部 <code>勾选</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012138939.png"                                     ></p><h1 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h1><ul><li>将图片拖动到 <code>上传区</code> 里</li><li>快捷键 <code>Ctrl + shift + p</code></li></ul><h1 id="出现-Error-Cannot-find-module-‘node-sass’"><a href="#出现-Error-Cannot-find-module-‘node-sass’" class="headerlink" title="出现 Error: Cannot find module ‘node-sass’"></a>出现 Error: Cannot find module ‘node-sass’</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % npm install node-sass</span><br></pre></td></tr></table></figure></div><p>不用管了，版本不一致导致的</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习01：事件传递链和响应链</title>
      <link href="/BboyZJ.github.io/2023/03/01/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/"/>
      <url>/BboyZJ.github.io/2023/03/01/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <code>iOS</code> 中只有继承 <code>UIResponder</code> 的 <code>对象</code> 才能够接收并处理事件，<code>UIResponder</code> 是所有响应对象的 <code>基类</code>。继承关系如下：</p><ul><li>UIApplication -&gt; UIResponder -&gt; NSObject</li><li>UIViewController -&gt; UIResponder -&gt; NSObject</li><li>UIWindow -&gt; UIViww -&gt; UIResponder -&gt; NSObject</li><li>UIButton -&gt; UIControl -&gt; UIView -&gt; UIResponder -&gt; NSObject</li><li>UIView -&gt; UIResponder -&gt; NSObject</li></ul><h1 id="事件链"><a href="#事件链" class="headerlink" title="事件链"></a>事件链</h1><ul><li><p><code>传递链</code>：由系统向离用户最近的view传递。<br>顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; RootViewController -&gt; subViews</p></li><li><p><code>响应链</code>：由离用户最近的view向系统传递。<br>顺序： superViews –&gt; RootViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate</p></li></ul><h1 id="传递链"><a href="#传递链" class="headerlink" title="传递链"></a>传递链</h1><ul><li>事件传递的两个核心方法</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 返回哪个视图进行事件响应</span><br><span class="line">- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;  </span><br><span class="line">// 判断某一个点击的位置是否在视图范围内</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;</span><br></pre></td></tr></table></figure></div><ul><li><p>其中 <code>UIView</code> 不接受事件处理的情况有</p></li><li><p>hidden &#x3D; YES 视图被隐藏</p></li><li><p>userInteractionEnabled &#x3D; NO 不接受响应事件</p></li><li><p>alpha &lt;&#x3D; 0.01,透明视图不接收响应事件</p></li><li><p>子视图超出父视图范围</p></li><li><p>需响应视图被其他视图盖住</p></li><li><p>是否重写了其父视图以及自身的hitTest方法</p></li><li><p>是否重写了其父视图以及自身的pointInside方法</p></li><li><p>流程描述</p><ul><li>当iOS程序发生触摸事件后，系统会利用 <code>Runloop</code> 将事件加入到 <code>UIApplication</code> 的任务队列中</li><li><code>UIApplication</code> 分发触摸事件到 <code>UIWindow</code></li><li>然后 <code>UIWindow</code> 依次向下分发给 <code>UIView</code></li><li><code>UIView</code> 调用 <code>hitTest:withEvent:</code> 方法返回一个最终响应的视图</li><li>在 <code>hitTest:withEvent:</code> 方法中就会去调用 <code>pointInside: withEvent:</code> 去判断当前点击的 <code>point</code> 是否在 <code>UIView</code> 范围内，如果是的话，就会去 <code>逆序遍历</code> 它的子视图来查找最终响应的 <code>子视图</code></li><li>遍历的方式是使用 <code>倒序</code> 的方式来遍历子视图，也就是说最后添加的子视图会最先遍历，在每一个视图中都会去调用它的 <code>hitTest:withEvent:</code> 方法，可以理解为是一个 <code>递归调用</code></li><li>最终会返回一个响应视图，如果返回视图有值，那么这个视图就作为最终响应视图，结束整个事件传递；如果没有值，那么就会将UIView作为响应者</li></ul></li></ul><h1 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h1><p>响应者链的事件传递过程</p><ul><li>如果 <code>view</code> 的控制器存在，就传递给控制器处理；如果控制器不存在，则传递给它的 <code>父视图</code></li><li>在视图层次结构的最顶层，如果也不能处理收到的事件，则将事件传递给 <code>UIWindow</code> 对象进行处理</li><li>如果 <code>UIWindow</code> 对象也不处理，则将事件传递给 <code>UIApplication</code> 对象</li><li>如果 <code>UIApplication</code> 也不能处理该事件，则将该事件丢弃</li></ul><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ul><li>实现一个按钮的点击范围扩大效果</li></ul><p>思路：自定义一个按钮，重写 <code>poinstInSide</code> 方法，增大内边距，返回一个新的bounds</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJBtn.h&quot;</span><br><span class="line">@implementation ZJBtn</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 当前btn大小</span><br><span class="line">    CGRect btnBounds = self.bounds;</span><br><span class="line">    // 扩大按钮的点击范围，增大内边距</span><br><span class="line">    btnBounds = CGRectInset(btnBounds, -50, -50);</span><br><span class="line">    // 若点击的点在新的bounds里，返回YES</span><br><span class="line">    return CGRectContainsPoint(btnBounds, point);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>子视图超过父视图部分仍然能响应</li></ul><p>思路：正常情况下子视图超出部分是不能响应事件的，需重写 <code>hitTest:withEvent</code> 方法，指定 <code>子视图</code> 可点击</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;VA.h&quot;</span><br><span class="line"></span><br><span class="line">@interface VA ()</span><br><span class="line">@property (nonatomic,strong)UIButton * btn;</span><br><span class="line">@end</span><br><span class="line">@implementation VA</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame&#123;</span><br><span class="line">    self = [super initWithFrame:frame];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        [self addSubview:self.btn];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)clickBtn&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIButton *)btn&#123;</span><br><span class="line">    if (!_btn) &#123;</span><br><span class="line">        _btn = [[UIButton alloc] initWithFrame:CGRectMake(-50, 20, self.frame.size.width + 100, 100)];</span><br><span class="line">        _btn.backgroundColor = [UIColor blueColor];</span><br><span class="line">        [_btn addTarget:self action:@selector(clickBtn) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    &#125;</span><br><span class="line">    return _btn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 子视图超过父视图部分，需要点击超出范围的部分也有相应</span><br><span class="line"> */</span><br><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 判断btn能否接收事件</span><br><span class="line">    if (self.btn.userInteractionEnabled == NO || self.btn.hidden == YES || self.btn.alpha &lt;= 0.01) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 把当前点转换成btn坐标系上的点</span><br><span class="line">    CGPoint btnP = [self convertPoint:point toView:self.btn];</span><br><span class="line">    // 当触摸点在btn上时，才让按钮相应事件</span><br><span class="line">    if ([self.btn pointInside:btnP withEvent:event]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,NSStringFromCGPoint(btnP));</span><br><span class="line">        return self.btn;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;父视图相应&quot;);</span><br><span class="line">    return [super hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS面试题：Swift</title>
      <link href="/BboyZJ.github.io/2023/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASwift/"/>
      <url>/BboyZJ.github.io/2023/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASwift/</url>
      
        <content type="html"><![CDATA[<h1 id="swift-和-oc-的区别？"><a href="#swift-和-oc-的区别？" class="headerlink" title="swift 和 oc 的区别？"></a>swift 和 oc 的区别？</h1><ul><li><code>swift</code> 是静态语言，有类型判断。<code>OC</code> 是动态语言。</li><li><code>swift</code> 可以面向 <code>函数、协议、对象</code> 编程；oc以面向 <code>对象</code> 编程为主，可以引入 <code>Reactive Cocoa类库</code> 来进行函数式编程</li><li><code>Swift</code> 是 <code>类型安全</code> 的语言。<code>OC</code> 不是类型安全的语言。</li><li><code>Swift</code> 大部分都是 <code>值类型</code>，少部分是 <code>Class引用类型</code>。OC 有的是 <code>值类型</code>，有的是 <code>指针类型</code>。</li></ul><h1 id="swift类型？Swiift-值类型-和-引用类型的区别？特点？"><a href="#swift类型？Swiift-值类型-和-引用类型的区别？特点？" class="headerlink" title="swift类型？Swiift 值类型 和 引用类型的区别？特点？"></a>swift类型？Swiift 值类型 和 引用类型的区别？特点？</h1><ul><li><p>swift的类型分为 <code>值类型</code> 和 <code>引用类型</code>。</p><ul><li><p>值类型：在swift中定义的很多类型都是值类型：如 <code>struct、enum、Int、Float、Bool、String、Array、Dictionary、String</code> 等都是 <code>值类型</code>。</p></li><li><p>引用类型：只有 <code>class</code> 为引用类型</p></li></ul></li><li><p>区别</p><ul><li><p>值类型：传递和赋值时是一个 <code>副本</code>，使用过程中不会影响 <code>源数据</code></p></li><li><p>引用类型：传递和赋值是 <code>本身（内存地址）</code>，使用过程中会影响源数据</p></li></ul></li></ul><h1 id="常用的关键字"><a href="#常用的关键字" class="headerlink" title="常用的关键字"></a>常用的关键字</h1><ul><li><p>final：</p><ul><li>只能用于 <code>类</code> 中，修饰的 <code>方法、属性</code>，不能被重写</li><li><code>final</code> 修饰的类，不能被继承</li></ul></li><li><p>inout：</p><ul><li><code>将值类型 转为 引用类型</code></li></ul></li><li><p>mutating：</p><ul><li>涉及到修改自身内存用</li></ul></li><li><p>#available</p><ul><li>用来判断平台和操作系统</li></ul></li><li><p>@available</p><ul><li>用于修饰 方法、属性、协议、扩展，用来表达它的可用性</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS面试题：OC</title>
      <link href="/BboyZJ.github.io/2023/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AOC/"/>
      <url>/BboyZJ.github.io/2023/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AOC/</url>
      
        <content type="html"><![CDATA[<h1 id="OC算法"><a href="#OC算法" class="headerlink" title="OC算法"></a>OC算法</h1><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><p>1）依次比较相邻两个元素，顺序错误则交换位置；需要两层循环，外层循环控制趟数，内层循环控制比较次数</p><p>2）例子：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;5&quot;,@&quot;4&quot;]];</span><br><span class="line">    // 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">    for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序</span><br><span class="line">        for (int j = 0; j &lt; arr.count - i - 1; j++) &#123;</span><br><span class="line">            // 相邻元素比较，若逆序则交换</span><br><span class="line">            if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123;</span><br><span class="line">                [arr exchangeObjectAtIndex:j withObjectAtIndex:j + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h2><p>1）从第一个元素与其他元素比较找到最小值，重复操作，直到最后一位结束；需要两层循环，外层循环趟数，里层循环比较次数</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithObjects:@&quot;2&quot;,@&quot;1&quot;,@&quot;5&quot;,@&quot;3&quot;, nil];</span><br><span class="line">// 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">    // 里循环获比较换位</span><br><span class="line">    for (int j = i + 1; j &lt; arr.count; j ++) &#123;</span><br><span class="line">        if ([arr[i] intValue] &gt; [arr[j] intValue]) &#123;</span><br><span class="line">            [arr exchangeObjectAtIndex:i withObjectAtIndex:j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;arr:%@&quot;,arr);</span><br></pre></td></tr></table></figure></div><h2 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3. 直接插入排序"></a>3. 直接插入排序</h2><p>1） 始终定义第一个元素为 <code>已排序</code> 的，将剩余元素定义为 <code>未排序</code> 逐个插入到 <code>已排序</code> 的排列中；不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = @[@2,@1,@3,@5,@4].mutableCopy;</span><br><span class="line">// 插入排序的原理：始终定义第一个元素为有序的，将元素逐个插入到有序的排列中</span><br><span class="line">// 其特点是：不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去</span><br><span class="line">for(int i = 0;i &lt; arr.count;i++)&#123;</span><br><span class="line">    // 待排序值</span><br><span class="line">    NSNumber * temp = arr[i];</span><br><span class="line">    // 已排序下标</span><br><span class="line">    int j = i - 1;</span><br><span class="line">    // 待排序与已排序比较，从后向前比较</span><br><span class="line">    while (j &gt;= 0 &amp;&amp; [arr[j] integerValue] &gt; [temp integerValue]) &#123;</span><br><span class="line">        // 如果已排序的 &gt; 待排序的 往后移动一个位置</span><br><span class="line">        [arr replaceObjectAtIndex:(j + 1) withObject:arr[j]];</span><br><span class="line">        j --;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 空出来的位置插入新元素</span><br><span class="line">    [arr replaceObjectAtIndex:(j + 1) withObject:temp];</span><br><span class="line">    NSLog(@&quot;arr:%@&quot;,arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:26:19.242271+0800 插入排序[4184:77845] arr:(</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><p>1）希尔排序相当于 <code>直接插入排序加强版</code>，引入了 <code>增量</code> 的概念；直到增量为 <code>1</code> 时，再进行直接插入排序</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = @[@7,@3,@8,@5,@2,@6,@1,@4].mutableCopy;</span><br><span class="line">// 其实间隔值设值为总数的一半</span><br><span class="line">int gap = arr.count/2;</span><br><span class="line">// 直到间隔小于1时结束</span><br><span class="line">while (gap &gt;= 1) &#123;</span><br><span class="line">    // i 待排元素，以 步距 gap 从后向前扫描</span><br><span class="line">    for(int i = 0;i &lt; arr.count;i++)&#123;</span><br><span class="line">        // 待排元素</span><br><span class="line">        NSNumber * temp = arr[i];</span><br><span class="line">        // 当前位置</span><br><span class="line">        int j = i;</span><br><span class="line">        // 跳跃式比较</span><br><span class="line">        while (j &gt;= gap &amp;&amp; [arr[j - gap] integerValue] &gt; [temp integerValue] ) &#123;</span><br><span class="line">            [arr replaceObjectAtIndex:j withObject:arr[j - gap]];</span><br><span class="line">            j -= gap;</span><br><span class="line">        &#125;</span><br><span class="line">        // 空出来位置，插入待排序</span><br><span class="line">        [arr replaceObjectAtIndex:j withObject:temp];</span><br><span class="line">    &#125;</span><br><span class="line">    // 改变步长</span><br><span class="line">    gap = gap/2;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;arr:%@&quot;,arr);</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:22:41.910840+0800 插入排序[4124:74568] arr:(</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5,</span><br><span class="line">    6,</span><br><span class="line">    7,</span><br><span class="line">    8</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h2 id="5-斐波那契数列"><a href="#5-斐波那契数列" class="headerlink" title="5. 斐波那契数列"></a>5. 斐波那契数列</h2><p>1）也就是 <code>兔子数列</code>，当前数是前两个数列之和</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    NSInteger num = 10;</span><br><span class="line">    NSInteger total = [self getTotalNum:num];</span><br><span class="line">    NSLog(@&quot;total:%ld&quot;,total);</span><br><span class="line">&#125;</span><br><span class="line">- (NSInteger)getTotalNum:(NSInteger)num&#123;</span><br><span class="line">    if(num == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(num == 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return [self getTotalNum:num-2] + [self getTotalNum:num-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:28:32.672554+0800 斐波那契数列[4285:80606] total:89</span><br></pre></td></tr></table></figure></div><h2 id="6-二分查找"><a href="#6-二分查找" class="headerlink" title="6. 二分查找"></a>6. 二分查找</h2><p>1）<code>有序的数组</code>，将数组分割成两份，利用查找的值跟中间值进行比较，如果查找的值大于中间值，就在数组的右边进行查找；如果查找的值小于中间值，就在数组的左边进行查找。如此循环的执行下去，最终找到符合的值。</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NSArray * arr = @[@(1),@(3),@(5),@(6),@(8),@(10)];</span><br><span class="line">int key = [@(5) intValue];</span><br><span class="line">int min = 0;</span><br><span class="line">int max = arr.count - 1;</span><br><span class="line">int mid;</span><br><span class="line">while (min &lt;= max) &#123;</span><br><span class="line">    // 计算中间下标</span><br><span class="line">    mid = (min + max) / 2;</span><br><span class="line">    // 如果目标值 &gt; 中间下标的中间值</span><br><span class="line">    if (key &gt; [arr[mid] intValue]) &#123;</span><br><span class="line">        //最小变为中间下标+1</span><br><span class="line">        min = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果目标值 &lt; 中间下标的中间值</span><br><span class="line">    else if (key &lt; [arr[mid] intValue])&#123;</span><br><span class="line">        //最大变为中间下标-1</span><br><span class="line">        max = max - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 否则，正好</span><br><span class="line">    else &#123;</span><br><span class="line">        NSLog(@&quot;key:%d&quot;,mid);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:33:18.661324+0800 二分查找[4607:86953] key:2</span><br></pre></td></tr></table></figure></div><h2 id="7-递归算法"><a href="#7-递归算法" class="headerlink" title="7. 递归算法"></a>7. 递归算法</h2><p>递归求和1+2+..+n?</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    int sum = [self sum:4];</span><br><span class="line">    NSLog(@&quot;sum:%d&quot;,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)sum:(int)n&#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return [self sum:n-1] + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><a href="http://www.bboyzj.cn/2020/08/09/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8E%A2%E7%B4%A2/">OC数据结构01：链表的探索</a></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p><a href="http://www.bboyzj.cn/2020/08/26/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%A2%E7%B4%A2/">OC数据结构02：二叉树探索</a></p><h1 id="OC常见的面试题"><a href="#OC常见的面试题" class="headerlink" title="OC常见的面试题"></a>OC常见的面试题</h1><h2 id="什么是野指针？"><a href="#什么是野指针？" class="headerlink" title="什么是野指针？"></a>什么是野指针？</h2><p>是一个没有指向 <code>任何内存</code> 的 <code>指针</code>，尝试使用它会导致 <code>应用程序崩溃</code></p><h2 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h2><p>一个 <code>对象</code> 没有被释放，会 <code>内存泄漏</code>，内存泄漏会导致应用程序占用的内存会越来越大，直到应用程序无内存可用时，会导致 <code>应用程序崩溃</code></p><h2 id="iOS-关键词有哪些？各有什么作用？-重点"><a href="#iOS-关键词有哪些？各有什么作用？-重点" class="headerlink" title="iOS 关键词有哪些？各有什么作用？ 重点"></a>iOS 关键词有哪些？各有什么作用？ <strong>重点</strong></h2><ul><li>readwrite</li></ul><p><code>可读可写</code> 特性，同时生成get方法和set方法的声明和实现</p><ul><li>readonly</li></ul><p><code>只读</code> 特性，只会生成get方法的声明和实现，不希望属性在类外改变</p><ul><li>retain</li></ul><p><code>持有</code> 特性，retaincount 会 +1,用于 <code>MRC</code></p><ul><li>nonatomic</li></ul><p><code>非原子</code> 特性</p><ul><li>atomic</li></ul><p><code>原子</code> 特性，默认属性</p><p>atomic不是绝对线程安全的，只是对 <code>setter/getter</code> 方法使用了 <code>自旋锁(spinlock_t)</code>，内部使用 <code>互斥锁(os_unfair_lock)</code>，保证了 <code>读/写</code> 安全。</p><p>atomic并不能保证 <code>整个对象</code> 是线程安全的，需要对 <code>整个对象</code> 进行 <code>加锁</code> 来保证线程安全：</p><pre><code>*  NSLock（互斥锁）*  dispathch_semaphore（信号量）*  @synchronized（互斥递归锁）</code></pre><ul><li>assign</li></ul><p>可以修饰 <code>基本数据类型和对象</code>。</p><p>通常用于修饰 <code>基本数据类型</code>，如Int、CGFloat、Double等，这是因为 <code>基本数据类型放在栈区</code>，栈由编译器自动分配和释放内存，栈先进后出，基本数据类型出栈后，assign修饰的基本数据类型就不存在了，不会出现 <code>野指针</code></p><p>修饰对象，如NSString、实例对象等，引用计数不会增加，但 <code>assign</code> 修饰对象释放后，<code>指针</code> 不会被系统置为nil，会产生 <code>野指针</code> 或 <code>EXC_BAD_ACCESS</code> 错误。</p><ul><li>strong</li></ul><p>强引用，<code>只修饰对象</code>，属性默认修饰符</p><p><code>指向并持有该对象</code>，其修饰的对象引用计数会 <code>+1</code>，引用计数不为 <code>0</code> 则不会被销毁，需要将其置为 <code>nil</code> 可以销毁。否则会出现 <code>内存泄漏</code>。</p><ul><li>weak</li></ul><p>弱引用，<code>只修饰对象</code>。</p><p><code>指向但并不拥有该对象</code>，引用计数不增加。该对象自动在内存中销毁。</p><ul><li>copy</li></ul><p>用于修饰 <code>不可变的对象</code>。</p><p>比如NSString、NSDictionary、NSArray等。</p><h2 id="浅拷贝和深拷贝-重点"><a href="#浅拷贝和深拷贝-重点" class="headerlink" title="浅拷贝和深拷贝 重点"></a>浅拷贝和深拷贝 <strong>重点</strong></h2><ul><li>浅拷贝</li></ul><p>浅拷贝，拷贝了一个新的指针，与原对象指针指向同一块内存，<code>引用计数 + 1</code>；(A,CopyA &#x3D; [A copy]，A 变化，CopyA 的值也变化)</p><ul><li>深拷贝</li></ul><p>深拷贝，拷贝了一个新的对象，指向新的内存，新对象的 <code>引用计数为 1</code>，源对象引用计数不变；(A,MutableA &#x3D; [A mutbleCopy]，A 变化，MutableA 的值不变)。</p><h2 id="NSString-x2F-NSArray-x2F-NSDictionary和NSMutableString-x2F-NSMutableArray-x2F-NSMutableDictionary-进行copy和mutableCopy区别？重点"><a href="#NSString-x2F-NSArray-x2F-NSDictionary和NSMutableString-x2F-NSMutableArray-x2F-NSMutableDictionary-进行copy和mutableCopy区别？重点" class="headerlink" title="NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？重点"></a>NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？<strong>重点</strong></h2><ul><li><p>对于不可变NSString&#x2F;NSArray&#x2F;NSDictionary，copy浅拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝)</p></li><li><p>对于可变NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary，copy深拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝)</p></li></ul><h2 id="自定义对象的copy和mutableCopy？-重点"><a href="#自定义对象的copy和mutableCopy？-重点" class="headerlink" title="自定义对象的copy和mutableCopy？ 重点"></a>自定义对象的copy和mutableCopy？ <strong>重点</strong></h2><ul><li>copy和mutableCopy都是深拷贝(属性：浅拷贝）</li></ul><h1 id="属性用copy还是strong？-重点"><a href="#属性用copy还是strong？-重点" class="headerlink" title="属性用copy还是strong？ 重点"></a>属性用copy还是strong？ <strong>重点</strong></h1><ul><li><p>对于不可变属性，推荐用copy，目的是为了 <code>让本属性不受外界影响</code>，无论给我传入可变还是不可变对象，我本身持有的就是一个不可变的副本，被set时，改变的是这个副本。</p></li><li><p>对于可变属性，推荐用strong，因为copy修饰后，会变成不可变对象，再调用可变对象函数时会 crash</p></li></ul><h2 id="一个APP是如何唤醒另一个APP的？-重点"><a href="#一个APP是如何唤醒另一个APP的？-重点" class="headerlink" title="一个APP是如何唤醒另一个APP的？ 重点"></a>一个APP是如何唤醒另一个APP的？ <strong>重点</strong></h2><p>URL Scheme：iOS有一个特性就是将 <code>自身绑定</code> 到一个自定义的 <code>URL Scheme</code> 上，该 <code>scheme</code> 用于从 <code>浏览器或其他应用中启动本应用</code>。</p><h2 id="单例的写法和作用？-重点"><a href="#单例的写法和作用？-重点" class="headerlink" title="单例的写法和作用？ 重点"></a>单例的写法和作用？ <strong>重点</strong></h2><p>单例模式的作用：可以保证程序运行过程中，一个类只返回一个实例，供外界访问；static保证类只分配一次内存；dispatch_once方法保证调用一次，并自动加锁，线程安全</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static id _instance = nil; // 定义static全局变量，保证只分配一次内存</span><br><span class="line">+ (id)shareInstance&#123;</span><br><span class="line">    return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">+ (id)copyWithZone:(struct _NSZone *)zone&#123;</span><br><span class="line">    static dispatch_once_t onceToken; // 声明一个静态的GcD单次任务</span><br><span class="line">    // 保证只执行一次</span><br><span class="line">    dispatch_once(&amp;onceToken,^&#123; // </span><br><span class="line">        _instance = [super allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">这么写可以保证下面两种方式返回同一个实例</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>Single * p1 &#x3D; [Single shareInstance];<br>Single * p2 &#x3D; [[Single alloc] init];<br>NSLog(@”%d”,p1&#x3D;&#x3D;p2); &#x2F;&#x2F; 1</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## HTTPS和HTTP的区别？ **重点**</span><br><span class="line"></span><br><span class="line">* HTTP：超文本传输协议，信息明文传输；端口号80；响应速度快（使用TCP三次握手，客户端和服务端需要交换3个包）；</span><br><span class="line"></span><br><span class="line">* HTTPS：是由 HTTP+SSL/TLS 加密传输；端口号443；响应速度慢（除了使用TCP三个包，还要加上SSL握手的9个包）；需要到CA申请证书</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## TCP 和 UDP 区别? **重点**</span><br><span class="line"></span><br><span class="line">* 都是 `传输层` 协议</span><br><span class="line"></span><br><span class="line">* TCP协议是 `面向连接的可靠的传输层协议`。UDP协议是 `面向非连接的传输层协议`</span><br><span class="line"></span><br><span class="line">* TCP需要 `建立连接和断开连接`。UDP不需要连接。</span><br><span class="line"></span><br><span class="line">* TCP传 `输数据没有大小限制`。UDP `传输数据有大小限制`。</span><br><span class="line"></span><br><span class="line">* TCP会 `处理数据丢包重发`。UDP不会处理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># HTTP和socket区别？ **重点**</span><br><span class="line"></span><br><span class="line">* `HTTP` 应用层协议；`socket` 不属于协议范畴，而是一个接口（API），是对TCP/IP协议的封装</span><br><span class="line">* `HTTP` 是基于 `请求-响应` 形式 `短连接`，即客户端发送一次请求，服务端响应后立即 `断开连接`；socket 是基于TCP协议的 `长链接`，理论上 客户端和服务端一旦建立连接将不会主动断开</span><br><span class="line">* HTTP 传输慢，数据量大，安全差；socket 数据可自定义，数据量小，安全性高，适合信息实时交互（推送、聊天等）</span><br><span class="line"></span><br><span class="line">## staitc 和 const 的区别？ **重点**</span><br><span class="line"></span><br><span class="line">* const：表示 `只读` 的意思</span><br><span class="line"></span><br><span class="line">    * `const` 放在 `类型` 前：可以改变指针的指向，可以改变指针指向的内容</span><br><span class="line">    </span><br><span class="line">    * `const` 放在 `变量` 前：不可以改变指针的指向，不可以改变指针指向的内容</span><br><span class="line"></span><br><span class="line">* static： `静态变量`，可修饰 `局部变量和全局变量`，可修饰方法</span><br><span class="line"></span><br><span class="line">    * `static` 可修饰 `局部/全局变量`，称为 `局部静态变量和全局静态变量`，只初始化一次，只分配一次内存，生命周期被改变，不再是作用域内</span><br><span class="line"></span><br><span class="line">    * `static` 修饰的 `方法`，可以在不同文件下重名，互不影响运行</span><br><span class="line"></span><br><span class="line">## 通用链接（Universal Links）**重点**</span><br><span class="line"></span><br><span class="line">* 服务端配置 `HTTPS` 证书 和添加 `apple-app-site-association` 地址关联文件</span><br><span class="line"></span><br><span class="line">* 移动端在plist添加 `Associated Domains` 关联域权限</span><br><span class="line"></span><br><span class="line">## 简述GET和POST请求的区别？ **重点**</span><br><span class="line"></span><br><span class="line">* GET 传输数据 `有缓存`；POST 传输数据 `没有缓存`</span><br><span class="line"></span><br><span class="line">* GET的 `参数` 放在 `URL` 的后面，并且第一个参数用 `?` 号拼接，后面的从第二个参数开始，直到最后一个，用 `&amp;` 分割；POST的 `参数` 放在 `请求体` 里面，并且第一个参数用 `,` 号拼接，后面从第二开始，直到最后用 `&amp;` 分割;</span><br><span class="line"></span><br><span class="line">* GET一般用于 `获取数据`；POST一般用于 `向服务器提交数据`</span><br><span class="line"></span><br><span class="line">* `GET` 的参数是暴漏在 `地址栏` 的，不安全；`POST` 的参数隐藏在 `请求体` 里面，相对安全一点;</span><br><span class="line"></span><br><span class="line">* GET请求提交数据受浏览器限制 `1k`，POST请求理论上无限制。</span><br><span class="line"></span><br><span class="line">## iOS中几种常见的设计模式？  **重点**</span><br><span class="line"></span><br><span class="line">* `代理模式`</span><br><span class="line"></span><br><span class="line">一对一的依赖关系，当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。</span><br><span class="line"></span><br><span class="line">* `观察者模式`</span><br><span class="line"></span><br><span class="line">KVO机制 和 Notification通知机制</span><br><span class="line"></span><br><span class="line">* `单例模式`</span><br><span class="line"></span><br><span class="line">保证程序运行过程中，一个类只返回一个实例，供外界访问</span><br><span class="line"></span><br><span class="line">* `工厂模式`</span><br><span class="line"></span><br><span class="line">通过一个类方法，`根据已有模板批量生产对象`。</span><br><span class="line"></span><br><span class="line">* `MVC模式`</span><br><span class="line"></span><br><span class="line">Model即数据模型</span><br><span class="line"></span><br><span class="line">view即视图</span><br><span class="line"></span><br><span class="line">controller即控制器</span><br><span class="line"></span><br><span class="line">## RunLoop是什么？ **重点**</span><br><span class="line"></span><br><span class="line">* 概念 </span><br><span class="line"></span><br><span class="line">`RunLoop` 又叫 `运行循环`，内部就是一个 `do-while循环`，在这个循环内部不断 `处理各种任务，保证程序持续运行`。</span><br><span class="line"></span><br><span class="line">* 目的</span><br><span class="line"></span><br><span class="line">RunLoop存在的目的： 就是当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，`提高程序性能，节省CPU资源`，该做事的时候做事，该休息的时候休息</span><br><span class="line"></span><br><span class="line">## RunLoop的作用？ **重点**</span><br><span class="line"></span><br><span class="line">* `保持程序持续运行`。</span><br><span class="line">   App一启动就会开启主线程，主线程在开启的时候就会开启主线程对应的RunLoop，RunLoop能保证线程不被销毁，主线程不销毁，程序就会持续运行。</span><br><span class="line"></span><br><span class="line">* `处理App中各类事件`。</span><br><span class="line">   事件响应、手势识别、界面刷新、AutoreleasePool自动释放池、NSTimer等事件处理。</span><br><span class="line"></span><br><span class="line">* `节省CPU资源，提高程序性能`。</span><br><span class="line">   如概述所述，当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，提高程序性能，节省资源，该做事的时候做事，该休息的时候休息。</span><br><span class="line"></span><br><span class="line">## 可以用Runloop实现什么功能？ **重点**</span><br><span class="line"></span><br><span class="line">* tableView 滚动时图片不加载</span><br><span class="line"></span><br><span class="line">SDWebImage + Runloop，图片延迟加载,滑动不加载图片</span><br><span class="line"></span><br><span class="line">* 线程保活</span><br><span class="line"></span><br><span class="line">往 `runloop` 中添加 `[[NSPort alloc] init]` 事件，</span><br><span class="line"></span><br><span class="line">* 解决NSTimer在滑动时停止工作的问题</span><br><span class="line"></span><br><span class="line">`default` 模式改为 `common` 模式</span><br><span class="line"></span><br><span class="line">* 检测卡顿</span><br><span class="line"></span><br><span class="line">`displaylink + runloop 进行卡顿检测，将数值和页面绑定上传到服务器`</span><br><span class="line"></span><br><span class="line">## RunLoop接收几种输入源，系统默认定义了几种模式？ **重点**</span><br><span class="line"></span><br><span class="line">* 输入源有两种</span><br><span class="line">基于 `端口` 的输入源（port）</span><br><span class="line">`自定义` 的输入源（custom）</span><br><span class="line"></span><br><span class="line">* 系统定义的RunLoop模式有五种，最常用的有三种，如下所示：</span><br><span class="line">NSDefaultRunLoopMode</span><br><span class="line">默认模式，主线程中默认是NSDefaultRunLoopMode</span><br><span class="line">UITrackingRunLoopMode</span><br><span class="line">视图滚动模式，RunLoop会处于该模式下</span><br><span class="line">NSRunLoopCommonModes</span><br><span class="line">并不是真正意义上的Mode，是一个占位用的“Mode”，默认包含了NSDefaultRunLoopMode和UITrackingRunLoopMode两种模式</span><br><span class="line"></span><br><span class="line">## RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？ **重点**</span><br><span class="line"></span><br><span class="line">* 每一个线程都有一个runloop，主线程的runloop默认启动。子线程的runloop默认不启动</span><br><span class="line">* mode：主要用来指定事件在运行时循环的优先级</span><br><span class="line">* 作用：保持程序的持续运行、随时处理各种事件、节省cpu资源(没事件休息释放资源)，提高程序的性能。</span><br><span class="line"></span><br><span class="line">## 怎么理解Objective-C是动态运行时语言。 **重点**</span><br><span class="line"></span><br><span class="line">主要是 `将数据类型的确定和函数的调用由编译时推迟到了运行时`。这个问题其实浅涉及到两个概念，`运行时和多态`。</span><br><span class="line"></span><br><span class="line">* 运行时：简单来说，运行时机制使我们 `直到运行时才去确定数据类型和要调用的函数`。</span><br><span class="line"></span><br><span class="line">* 多态：`不同对象以自己的方式响应相同的消息的能力` 叫做多态。</span><br><span class="line"></span><br><span class="line">## runtime项目中具体应用？ **重点**</span><br><span class="line"></span><br><span class="line">* `方法交换`。</span><br><span class="line">* 给 `分类添加属性`。 </span><br><span class="line">* 动态添加方法。</span><br><span class="line">* 字典转模型。</span><br><span class="line">* 数组越界。</span><br><span class="line">* 动态获取成员属性、成员变量、实例方法</span><br><span class="line"></span><br><span class="line">## KVC是什么？**重点**</span><br><span class="line"></span><br><span class="line">`KVC` 全程 `Key Value Coding`，中文 `键值编码`，是由 `NSKeyValueCoding` 非正式协议启动的一种机制，`对象` 采用该协议来 `间接访问对象的属性`。</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li><p>(nullable id)valueForKey:(NSString *)key;     </p></li><li><p>(nullable id)valueForKeyPath:(NSString *)keyPath; </p></li><li><p>(void)setValue:(nullable id)value forKey:(NSString *)key;</p></li><li><p>(void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; </p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[KVC底层原理：](http://www.bboyzj.cn/2021/01/17/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8622%EF%BC%9AKVC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/)</span><br><span class="line"></span><br><span class="line">## KVO是什么？**重点**</span><br><span class="line"></span><br><span class="line">`KVO` 全程 `Key Value Observing`，中文 `键值观察`，它 `用于监听实例对象属性的变化`。</span><br><span class="line"></span><br><span class="line">## KVO的实现原理？(KVO的本质是什么？) **重点**</span><br><span class="line"></span><br><span class="line">当一个 `实例对象` 的 `属性注册了KVO`，实例对象 `isa指针` 的指向在注册KVO观察者之后，由 `原有类` 改为 `中间类(NSKVONotifing_类名)`；`中间类` 重写了 `属性setter方法、class、dealloc、_isKVOA` 方法；`dealloc` 方法中，移除 `KVO` 观察者之后，实例对象isa 指向由 `中间类` 更改为 `原有类`;中间类 从创建后就 `一直存在内存中`，不会被销毁。</span><br><span class="line"></span><br><span class="line">## KVO实际应用 **重点**</span><br><span class="line"></span><br><span class="line">* 观察 `实例对象` 的 `属性` 变化</span><br><span class="line"></span><br><span class="line">* 观察 `实例对象` 的 `容器` 变化</span><br><span class="line"></span><br><span class="line">   观察容器用： `mutableArrayValueForKey`</span><br><span class="line">   </span><br><span class="line">[KVO底层原理：](http://www.bboyzj.cn/2021/01/25/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8623%EF%BC%9AKVO%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/) </span><br><span class="line"></span><br><span class="line">## category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？**重点**</span><br><span class="line"></span><br><span class="line">* `category` 原则上它 `只能增加方法`，`不能增加成员（实例）变量`。可以添加属性，但是不会自动生成实例变量_name和setter和getter方法。可以添加方法</span><br><span class="line"></span><br><span class="line">* `扩展` 主要用来为一个类添加额外的原来没有的 `实例变量、方法和属性`。extension常用的形式并不是以一个单独的.h文件存在，而是寄生在类的.m文件中。</span><br><span class="line"></span><br><span class="line">类扩展中：</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>@interface Person (){<br>  int age; &#x2F;&#x2F;实例变量<br>}<br>@property (nonatomic,copy)NSString * name;&#x2F;&#x2F;属性</p></li><li><p>(void)run;&#x2F;&#x2F;方法<br>@end</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## iOS开发中有多少类型的线程？  **重点**</span><br><span class="line"></span><br><span class="line">* pthread</span><br><span class="line"></span><br><span class="line">一套用于 `C` 的多线程 `API`、适用于 `Unix / Linux / Windows` 等系统、跨平台、可移植、使用难度大</span><br><span class="line"></span><br><span class="line">* NSThread</span><br><span class="line"></span><br><span class="line">使用更加面向对象、简单易用，可直接操作线程对象</span><br><span class="line"></span><br><span class="line">* GCD</span><br><span class="line"></span><br><span class="line">旨在替代NSThread等线程技术、充分利用设备的 `多核`、基于 `C` 的底层的 API</span><br><span class="line"></span><br><span class="line">* NSOperation</span><br><span class="line"></span><br><span class="line">`NSOperation` 是基于 `GCD` 之上的更高一层的封装， `NSOpetation` 需要配合 `NSOpetationQueue` 来实现多线程</span><br><span class="line"></span><br><span class="line">## 根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？  **重点**</span><br><span class="line"></span><br><span class="line">dispatch_group_t + dispatch_group_enter + dispatch_group_leave + dispatch_group_notify</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 10个网络请求顺序回调? GCD如何实现？**重点**</span><br><span class="line"></span><br><span class="line">dispatch_group_t + dispatch_semaphore_t：信号量（dispatch_semaphore_wait + dispatch_group_leave）</span><br><span class="line"></span><br><span class="line">## GCD和NSOperation的区别？ **重点**</span><br><span class="line"></span><br><span class="line">* `GCD执行效率更高`，而且由于队列中执行的是由block构成的任务，这是一个轻量级的数据结构，写起来更方便</span><br><span class="line">* GCD只支持FIFO的队列，而 `NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序`</span><br><span class="line">* NSOperationQueue甚至可以跨队列设置依赖关系，但是GCD只能通过设置串行队列，或者在队列内添加barrier(dispatch_barrier_async)任务，才能控制执行顺序,较为复杂</span><br><span class="line">* `NSOperationQueue因为面向对象`，所以 `支持KVO`，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished）、是否取消（isCanceld）</span><br><span class="line"></span><br><span class="line">具体的底层看 [OC底层原理27：GCD之 NSThread &amp; GCD &amp; NSOperation](http://www.bboyzj.cn/2021/03/23/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8627%EF%BC%9AGCD%E4%B9%8B%2520NSThread%2520&amp;%2520GCD%2520&amp;%2520NSOperation/)</span><br><span class="line"></span><br><span class="line">## 什么是Block？ **重点**</span><br><span class="line"></span><br><span class="line">`Block` 是将 `函数及其上下文封装起来的对象`</span><br><span class="line"></span><br><span class="line">## Block的本质 **重点**</span><br><span class="line"> </span><br><span class="line">* block 的 `本质` 是 `对象、函数、结构`体，由于block函数没有名称，也被称为 `匿名函数`</span><br><span class="line"></span><br><span class="line">## Block的分类？ **重点**</span><br><span class="line"></span><br><span class="line">* 分为 `全局Block(_NSConcreteGlobalBlock)、栈Block(_NSConcreteStackBlock)、堆Block(_NSConcreteMallocBlock)` 三种形式。</span><br><span class="line"></span><br><span class="line">* 其中 `栈Block存储在栈(stack)区`，`堆Block存储在堆(heap)区`，`全局Block存储在已初始化数据(.data)区`。</span><br><span class="line"></span><br><span class="line">    * 堆：动态分配内存，需要程序员自己申请，程序员自己管理</span><br><span class="line">    * 栈：自动分配内存，自动销毁，先入后出，栈上的内容存在自动销毁的情况</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">具体看底层原理 [OC底层原理30：Block底层原理](http://www.bboyzj.cn/2021/04/22/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8630%EF%BC%9ABlock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 循环引用的几种情况和解决方式？ **重点**</span><br><span class="line"></span><br><span class="line">* Block</span><br><span class="line"></span><br><span class="line">原因： `self` 强引用了 `block`，而 `block` 内部又调用了 `self`</span><br><span class="line">解决： 使用 `Weak-Strong Dance`</span><br><span class="line"></span><br><span class="line">* Delegate</span><br><span class="line"></span><br><span class="line">原因：委托者和被委托人之间的相互强引用问题 `strong`</span><br><span class="line">解决：用 `weak` 进行弱引用 `或者` 通过中间对象(代理对象)的方式来解决(效率更加高的中间对象NSProxy：不需要进行发送消息和动态解析，直接进行消息转发)</span><br><span class="line"></span><br><span class="line">* NSTimer</span><br><span class="line"></span><br><span class="line">原因：self → timer → self(target) 的循环持有链</span><br><span class="line">解决：在适当的时机销毁 </span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>[_timer invalidate];<br>_timer &#x3D; nil;</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># OC 如何进行内存管理的？ **重点**</span><br><span class="line"></span><br><span class="line">* 手动内存管理 MRC</span><br><span class="line"></span><br><span class="line">* 自动内存管理 ARC</span><br><span class="line">    </span><br><span class="line">    LLVM + Runtime 会为我们代码自动插入 retain 和 release 以及 autorelease等代码,不需要我们手动管理</span><br><span class="line">    </span><br><span class="line">* 自动释放池</span><br><span class="line"></span><br><span class="line"># 自动释放池原理 **重点**</span><br><span class="line"></span><br><span class="line">* 自动释放池的本质是 `__AtAutoreleasePool` 结构体，包含构造函数和析构函数</span><br><span class="line"></span><br><span class="line">* 结构体声明，触发构造函数，调用 `objc_autoreleasePoolPush()` 函数，对象压栈</span><br><span class="line"></span><br><span class="line">* 结构体出作用域，触发析构函数，调用 `objc_autoreleasePoolPop()` 函数，对象出栈</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 内存优化 **重点**</span><br><span class="line"></span><br><span class="line">* cell复用</span><br><span class="line">* 绘制的话：用CAShaperLayer，渲染快，内存使用高效</span><br><span class="line">* 按需加载：懒加载</span><br><span class="line">* 合理利用缓存：比如三方图片压缩缓存</span><br><span class="line">* 尽量使用透明View：控件有背景色增大内存消耗</span><br><span class="line"></span><br><span class="line"># 启动优化 **重点**</span><br><span class="line"></span><br><span class="line">* pre-main 阶段：`二进制重排`</span><br><span class="line"></span><br><span class="line">    * 尽量 `少用外部动态库`，苹果官方建议自定义的动态库最好 `不要超过6个`，如果超过6个，需要 `合并` 动态库</span><br><span class="line"></span><br><span class="line">    * 减少 `OC` 类，因为类越多，越耗时</span><br><span class="line"></span><br><span class="line">    * 将不必须在 `+load` 方法中做的事情延迟到 `+initialize` 中，尽量不要用 `C++` 虚函数</span><br><span class="line"></span><br><span class="line">* main 阶段：mian -&gt; didFinishLaunching</span><br><span class="line"></span><br><span class="line">    * 减少启动初始化的流程，`能懒加载的懒加载，能延迟的延迟，能放后台初始化的放后台`，尽量少占用主线程的启动时间</span><br><span class="line"></span><br><span class="line">    * 优化代码逻辑，去除非必须的代码逻辑，减少每个流程的消耗时间</span><br><span class="line"></span><br><span class="line">    * 启动阶段能 `使用多线程` 来初始化的，就使用多线程</span><br><span class="line"></span><br><span class="line">    * 尽量 `使用纯代码` 来进行UI框架的搭建，尤其是主UI框架，例如 UITabBarController，尽量避免使用Xib或者SB，相比纯代码而言，这种更耗时</span><br><span class="line"></span><br><span class="line">    * 删除废弃类、方法</span><br><span class="line"> </span><br><span class="line">## 卡顿监听 **重点**</span><br><span class="line"></span><br><span class="line">**主要是用displayLink + Runloop进行FPS监测**</span><br><span class="line"></span><br><span class="line">主要从减轻 `CPU` 和 `GPU` 消耗入手，保证写一个 `VSync` 到来时，`CPU` 和 `GPU` 能够写作完成下一帧的渲染并缓存到帧缓冲区</span><br><span class="line"></span><br><span class="line">* 卡顿优化在 `CPU` 层面：</span><br><span class="line"></span><br><span class="line">1）尽量用轻量级的对象，比如 `用不到事件处理` 的地方，可以考虑使用 `CALayer` 取代 `UIView`</span><br><span class="line">2）不要频繁地调用 `UIView` 的相关属性，比如 `frame、bounds、transform` 等属性，尽量减少不必要的修改</span><br><span class="line">3）尽量 `提前计算好布局`，在有需要时一次性调整对应的属性，不要多次修改属性</span><br><span class="line">4）图片的 `size` 最好刚好跟 `UIImageView` 的 `size` 保持一致</span><br><span class="line">5）`控制`一下线程的最大并发数量</span><br><span class="line">6）尽量把 `耗时的操作放到子线程`：如text宽高获取等</span><br><span class="line"></span><br><span class="line">* 卡顿优化在 GPU层面：</span><br><span class="line"></span><br><span class="line">1）GPU能处理的 `最大纹理` 尺寸是 `4096x4096`，一旦超过这个尺寸，就会占用 `CPU` 资源进行处理，所以纹理尽量不要超过这个尺寸</span><br><span class="line">2）尽量 `减少视图数量和层次`</span><br><span class="line">3）`减少透明的视图`（alpha&lt;1），不透明的就设置 `opaque` 为 `YES`</span><br><span class="line">4）尽量 `避免出现离屏渲染`：圆角、阴影、遮罩等</span><br><span class="line"> </span><br><span class="line">## 卡顿优化：tableView优化 **重点**</span><br><span class="line"></span><br><span class="line">* 最常用的就是`cell的复用`， 注册复用标识符</span><br><span class="line"></span><br><span class="line">* `避免cell的重新布局`，初始化时就布局好</span><br><span class="line"></span><br><span class="line">* `提前计算并缓存cell的高度`</span><br><span class="line"></span><br><span class="line">* `减少cell中控件的数量`，少动态添加 view</span><br><span class="line"></span><br><span class="line">* `避免背景透明`</span><br><span class="line"></span><br><span class="line">* 能`使用局部更新` 的就使用 `局部更新`</span><br><span class="line"></span><br><span class="line">* 加载网络数据，`下载图片，使用异步加载`，并缓存</span><br><span class="line"></span><br><span class="line">* `按需加载cell`：cell滚动很快时，只加载范围内的cell</span><br><span class="line"></span><br><span class="line">* `不要实现无用的代理方法`，tableView只遵守两个协议</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"># 网络优化 **重点**</span><br><span class="line"></span><br><span class="line">* DNS优化：即域名解析优化，缓存 ip</span><br><span class="line">* 资源优化：</span><br><span class="line">    * 图片webp，比png/jpg小</span><br><span class="line">    * 数据传输用ProtocolBuffer代替json，数据小，序列化和反序列化也简单</span><br><span class="line">* 请求压缩、请求合并</span><br><span class="line">* 数据缓存</span><br><span class="line">* 网络环境监测</span><br><span class="line">    * 针对性请求重试</span><br><span class="line"></span><br><span class="line">## TCP三次握手，四次挥手过程？**重点**</span><br><span class="line"></span><br><span class="line">1. 为什么是三次握手，而不是二次握手？</span><br><span class="line"></span><br><span class="line">三次握手是为了建立一个可靠的数据传输通道：</span><br><span class="line"></span><br><span class="line">* 刚开始客户端和服务端处于关闭状态，而且服务端B一直处于监听状态，时刻监听是否有建立连接的请求</span><br><span class="line"></span><br><span class="line">* 当客户端需要建立连接的时候就会发送一个 `请求连接` 的报文，此报文是 `同步报文SYN=1`，并且会生成一个 `随机的序号seq=x`，这是第一次握手</span><br><span class="line"></span><br><span class="line">* 当服务端接收到请求连接报文时，会发送一个 `确认连接` 的报文，此报文是 `同步报文SYN=1`，并且 `确认报文ACK=1`，同时服务端也会生成一个 `随机的序号seq=y`，并且将 `确认报文确认号ack=x+1`，回传给客户端，这是第二次握手</span><br><span class="line"></span><br><span class="line">* 当客户端接收到服务端的 `ACK确认报文后`，会回复一个 `ACK确认报文`，用于确认确认报文已经收到，此报文 `ACK=1，seq=x+1，ack=y+1`，这是第三次握手</span><br><span class="line"></span><br><span class="line">2. 四次挥手</span><br><span class="line"></span><br><span class="line">四次挥手则是为了保证数据传输完成接收再关闭连接。</span><br><span class="line"></span><br><span class="line">* 客户端断开连接时会发送一个 `请求断开连接` 的报文，此报文是 `FIN=1`，并且会生成一个 `随机的序号seq=u`，发送给服务端，这是第一次挥手</span><br><span class="line"></span><br><span class="line">* 服务端接收到请求断开连接 `FIN报文` 后，回复一个 `确认断开连接` 报文 `ACK=1,seq=v,ack=u+1`，这是第二次挥手</span><br><span class="line"></span><br><span class="line">* 当服务端数据发送完后，再发送一个FIN报文给客户端，通知客户端，服务端准备关闭连接，此报文 `FIN=1,ACK=1,ack=u+1,seq=w`，这是第三次挥手</span><br><span class="line"></span><br><span class="line">* 当客户端收到 `FIN确认报文`，再发送一个FIN确认报文 `ACK=1,seq=u+1,ack=w+1`，并进入` TIME-WAIT` 等待，等待 `2MSL` 后关闭连接，这是第四次挥手</span><br><span class="line"> </span><br><span class="line"># 事件链 **重点**</span><br><span class="line"></span><br><span class="line">[OC学习01：事件传递链和响应链](https://www.bboyzj.cn/2023/03/01/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/)</span><br><span class="line"></span><br><span class="line">* 传递链：由系统向离用户最近的view传递。</span><br><span class="line">  顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; ViewController -&gt; subViews</span><br><span class="line"></span><br><span class="line">* 响应链：由离用户最近的view向系统传递。</span><br><span class="line">  顺序： superViews –&gt; ViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate</span><br><span class="line"></span><br><span class="line"># 事件传递的两个核心方法？ **重点**</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>&#x2F;&#x2F; 返回最适合处理事件的视图</p></li><li><p>(nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;<br>&#x2F;&#x2F; 判断点是否在这个View内部</p></li><li><p>(BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 第一个方法返回的是一个 `UIView`，是用来寻找最终哪一个视图来响应这个事件</span><br><span class="line">* 第二个方法是用来判断某一个点击的位置是否在视图范围内，如果在就返回YES</span><br><span class="line"></span><br><span class="line"># 实现一个按钮的点击范围扩大效果 **重点**</span><br><span class="line"></span><br><span class="line">自定义一个按钮，继承UIButton，重写 `pointInside:withEvent:` 方法，</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li><li><p>(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{<br>  &#x2F;&#x2F; 当前btn大小<br>  CGRect btnBounds &#x3D; self.bounds;<br>  &#x2F;&#x2F; 扩大按钮的点击范围，增大内边距<br>  btnBounds &#x3D; CGRectInset(btnBounds, -10, -10);<br>  &#x2F;&#x2F; 若点击的点在新的bounds里，返回YES<br>  return CGRectContainsPoint(btnBounds, point);<br>}</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 子视图超过父视图部分仍然能响应 **重点**</span><br><span class="line"></span><br><span class="line">重写 `hitTest:withEvent` 方法，让 `子视图` 去相应事件</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li><li><p>(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{<br>  &#x2F;&#x2F; 判断btn能否接收事件<br>  if (self.btn.userInteractionEnabled &#x3D;&#x3D; NO || self.btn.hidden &#x3D;&#x3D; YES || self.btn.alpha &lt;&#x3D; 0.01) {<br>  return nil;<br>  }<br>  &#x2F;&#x2F; 把当前点转换成btn坐标系上的点<br>  CGPoint btnP &#x3D; [self convertPoint:point toView:self.btn];<br>  &#x2F;&#x2F; 当触摸点在btn上时，才让按钮相应事件<br>  if ([self.btn pointInside:btnP withEvent:event]) {<br>  NSLog(@”%@”,NSStringFromCGPoint(btnP));<br>  return self.btn;<br>  }<br>  NSLog(@”父视图相应”);<br>  return [super hitTest:point withEvent:event];<br>}</p></li></ul><p>&#96;&#96;&#96;</p><h1 id="面试官问还有什么想问的？-重点"><a href="#面试官问还有什么想问的？-重点" class="headerlink" title="面试官问还有什么想问的？ 重点"></a>面试官问还有什么想问的？ <strong>重点</strong></h1><p>技术面不问薪资待遇，人事面问薪资待遇</p><ul><li>问岗位：</li></ul><ol><li>在这个岗位上，会直接 <code>接触到哪些类型的项目？</code></li><li>这个岗位的主要职责是什么？主要的KPI是什么？</li><li>这个岗位如何评估绩效，试用期需要达到什么指标？</li><li>这个岗位的最大挑战是什么？</li></ol><ul><li>问团队：</li></ul><ol><li><code>团队的基本情况？</code></li><li>这个团队在公司的角色是什么？</li><li>可以跟我介绍一下我的领导吗？</li></ol><ul><li>问公司</li></ul><ol><li><code>公司的文化氛围是什么样的？</code></li><li>员工的晋升机制是什么样的？我这个岗位的晋升机会如何？</li><li>这个岗位所在的团队如何支持公司目标的实现？</li></ol>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog-04：主题完善</title>
      <link href="/BboyZJ.github.io/2023/03/01/Blog-04%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/"/>
      <url>/BboyZJ.github.io/2023/03/01/Blog-04%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们以 <a class="link"   href="https://github.com/shenliyang/hexo-theme-snippet" >Snippet <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 主题问例</p><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ git clone git://github.com/shenliyang/hexo-theme-snippet.git themes/hexo-theme-snippet</span><br></pre></td></tr></table></figure></div><h1 id="安装主题插件"><a href="#安装主题插件" class="headerlink" title="安装主题插件"></a>安装主题插件</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S</span><br></pre></td></tr></table></figure></div><h1 id="部署主题"><a href="#部署主题" class="headerlink" title="部署主题"></a>部署主题</h1><p>具体部署看下面的链接：1、2、3步骤可省略</p><p><a class="link"   href="https://github.com/shenliyang/hexo-theme-snippet" >Snippet <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog-03：Github域名绑定阿里云域名</title>
      <link href="/BboyZJ.github.io/2023/03/01/Blog-03%EF%BC%9AGithub%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/"/>
      <url>/BboyZJ.github.io/2023/03/01/Blog-03%EF%BC%9AGithub%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="注册域名"><a href="#注册域名" class="headerlink" title="注册域名"></a>注册域名</h1><p>去 <a class="link"   href="https://dc.console.aliyun.com/" >阿里云 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 注册账号、并购买域名，具体流程这里就不一一介绍了</p><h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><ul><li>在终端 <code>ping</code> 一下之前配置的静态页面地址,可以获取到对应的ip地址:</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % ping BboyZJ.github.io</span><br><span class="line">PING bboyzj.github.io (185.199.109.153): 56 data bytes</span><br><span class="line">64 bytes from 185.199.109.153: icmp_seq=0 ttl=50 time=261.217 ms</span><br><span class="line">64 bytes from 185.199.109.153: icmp_seq=1 ttl=50 time=337.547 ms</span><br><span class="line">64 bytes from 185.199.109.153: icmp_seq=2 ttl=50 time=260.716 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><ul><li>@解析</li></ul><p>记录类型：A<br>主机记录：@<br>解析请求来源：默认<br>记录值：185.199.109.153<br>TTL：10分钟</p><p>点击确定</p><ul><li>www解析</li></ul><p>记录类型：CNAME<br>主机记录：www<br>解析线路来源：默认<br>记录值：BboyZJ.github.io<br>TTL：10分钟</p><p>点击确定</p><ul><li>配置项目 <code>CNAME</code></li></ul><p>在 <code>Blog/source</code> 目录下，新建 <code>CNAME</code> 文件，内容输入阿里云申请的域名 <a href="http://www.bboyzj.cn/">www.bboyzj.cn</a></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/Blog/source </span><br><span class="line">mac@bogon source % touch CNAME</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16776380930111.jpg"                      alt="16776380930111"                ></p><ul><li>配置 <code>Blog</code> 目录下 <code>_config.yml</code> 文件，<code>URL</code> 模块</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="line">url: https://www.bboyzj.cn</span><br><span class="line">root: /BboyZJ.github.io/</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></pre></td></tr></table></figure></div><ul><li>执行</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % hexo clean</span><br><span class="line">mac@bogon ~ % hexo g</span><br><span class="line">mac@bogon ~ % hexo d</span><br></pre></td></tr></table></figure></div><p>提交陈成功后，就可以在 <code>GitHub</code> 和 <a href="http://www.bboyzj.cn/">www.bboyzj.cn</a> 个人域名绑定上了</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog-02：部署博客到GitHub</title>
      <link href="/BboyZJ.github.io/2023/03/01/Blog-02%EF%BC%9A%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0GitHub/"/>
      <url>/BboyZJ.github.io/2023/03/01/Blog-02%EF%BC%9A%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0GitHub/</url>
      
        <content type="html"><![CDATA[<h1 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h1><p>前往 <a class="link"   href="https://github.com/" >Github <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 网站，注册一个新用户。用邮箱注册的一定前往邮箱去验证邮件。</p><h1 id="部署到-GitHub-上"><a href="#部署到-GitHub-上" class="headerlink" title="部署到 GitHub 上"></a>部署到 GitHub 上</h1><ul><li>新建 <code>reponsity</code> 仓库</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012145840.png"                                     ></p><p>仓库名设置成 <code>用户名.github.io</code> ，比如我的是 <code>BboyZJ.github.io</code>，选择 Public，勾选 <code>Add a README file</code> ，最后 <code>Create respository</code></p><h1 id="配置秘钥"><a href="#配置秘钥" class="headerlink" title="配置秘钥"></a>配置秘钥</h1><ul><li>查看秘钥</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">$ cat id_rsa.pub</span><br></pre></td></tr></table></figure></div><ul><li>添加SSH秘钥：头像 -&gt; Setting -&gt; SSH and GPG keys</li></ul><p><code>Title</code> 随意写，<code>Key</code> 需要填写刚才复制的 <code>秘钥</code> 文本内容</p><ul><li>添加完成，验证链接</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">Hi BboyZJ! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></div><h1 id="上传文件到-GitHub"><a href="#上传文件到-GitHub" class="headerlink" title="上传文件到 GitHub"></a>上传文件到 GitHub</h1><ul><li>配置 <code>Blog</code> 下 <code>_config.yml</code> 中的 <code>Deployment</code> 模块</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/BboyZJ/BboyZJ.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></div><ul><li>安装部署插件</li></ul><p>通过 Hexo 发布到 GitHub，需要安装部署插件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></div><ul><li>部署</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/Blog</span><br><span class="line">mac@bogon ~ % hexo g</span><br><span class="line">mac@bogon ~ % hexo d</span><br></pre></td></tr></table></figure></div><ul><li>访问</li></ul><p>这时我们的 <code>GitHub</code> 域名 <code>https://BboyZJ.github.io</code> 就可以看到 <code>Hexo</code> 网站了，如果没显示出来就 <code>刷新</code> 一下</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/BboyZJ.github.io/2023/03/01/hello-world/"/>
      <url>/BboyZJ.github.io/2023/03/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Blog-01：Hexo个人博客搭建</title>
      <link href="/BboyZJ.github.io/2023/03/01/Blog-01%EF%BC%9AHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/BboyZJ.github.io/2023/03/01/Blog-01%EF%BC%9AHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><ul><li>什么是Hexo？</li></ul><p>简介：<code>Hexo</code> 是一个快速、简洁且高效的博客框架。想要详细的了解 <a class="link"   href="https://hexo.io/zh-cn/docs/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，去官网学习。<code>Hexo</code> 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h1 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h1><ul><li>检查是否安装 <code>homebrew</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % brew -v</span><br><span class="line">Homebrew 3.6.21-28-ge6548a8</span><br><span class="line">Homebrew/homebrew-core (git revision 5434c8344e8; last commit 2023-02-09)</span><br><span class="line">Homebrew/homebrew-cask (git revision 15c2c1fa53; last commit 2023-02-09)</span><br><span class="line">mac@bogon ~ % </span><br></pre></td></tr></table></figure></div><p>如果顺利显示版本号，说明homebrew已经安装。否则，输入以下命令进行安装：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></div><ul><li>安装过程如果出现下面的问题</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</span><br></pre></td></tr></table></figure></div><p>解决:</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % /usr/bin/ruby -e &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)&quot;</span><br></pre></td></tr></table></figure></div><ul><li>安装 <code>Node.js</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % brew install node</span><br><span class="line">mac@bogon ~ % node -v</span><br><span class="line">v18.14.2</span><br></pre></td></tr></table></figure></div><ol start="3"><li>安装Git<br>Mac系统默认已经安装好了，所以不需要再安装</li></ol><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往安装 <code>Hexo</code> 步骤。</p><ul><li>使用npm完成 <code>hexo</code> 安装</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % npm install -g hexo-cli</span><br><span class="line">mac@bogon ~ % hexo -v</span><br><span class="line"></span><br><span class="line">hexo-cli: 4.1.0</span><br><span class="line">os: Darwin 21.6.0 darwin x64</span><br><span class="line">node: 12.16.1</span><br><span class="line">v8: 7.8.279.23-node.31</span><br><span class="line">uv: 1.34.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.7</span><br><span class="line">ares: 1.15.0</span><br><span class="line">modules: 72</span><br><span class="line">nghttp2: 1.40.0</span><br><span class="line">napi: 5</span><br><span class="line">llhttp: 2.0.4</span><br><span class="line">http_parser: 2.9.3</span><br><span class="line">openssl: 1.1.1d</span><br><span class="line">cldr: 35.1</span><br><span class="line">icu: 64.2</span><br><span class="line">tz: 2019c</span><br><span class="line">unicode: 12.1</span><br><span class="line">mac@bogon ~ % </span><br></pre></td></tr></table></figure></div><h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><ul><li>桌面新建 <code>Blog</code> 文件夹，打开终端，cd到 <code>Blog</code> 下，执行:</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/Blog </span><br><span class="line">mac@bogon Blog % hexo init</span><br><span class="line"></span><br><span class="line">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class="line">INFO  Install dependencies</span><br><span class="line">npm notice </span><br><span class="line">npm notice New major version of npm available! 7.3.0 -&gt; 9.5.1</span><br><span class="line">npm notice Changelog: https://github.com/npm/cli/releases/tag/v9.5.1</span><br><span class="line">npm notice Run npm install -g npm@9.5.1 to update!</span><br><span class="line">npm notice </span><br><span class="line">INFO  Start blogging with Hexo!</span><br><span class="line">mac@bogon Blog % </span><br></pre></td></tr></table></figure></div><p>【目录文件】：</p><p>_config.landscape.yml：网站本地配置信息<br>_config.yml：网站的配置信息，可以在此配置大部分的参数<br>source–posts：存放 <code>md</code> 文件<br>themes：主题文件夹，<a class="link"   href="https://hexo.io/themes/%20" >常用主题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 会放入这里<br>public：Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去</p><h1 id="hexo-测试"><a href="#hexo-测试" class="headerlink" title="hexo 测试"></a>hexo 测试</h1><ul><li>生成静态页面</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % hexo g</span><br></pre></td></tr></table></figure></div><p>会在根目录 <code>Blog\</code> 下生成 <code>public</code> 文件夹，里面包含相应的 <code>html</code> 页面。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012142095.png"                                     ></p><ul><li>启动服务器</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % hexo s</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012143213.png"                                     ></p><p>打开浏览器，输入网址: <a class="link"   href="http://localhost:4000/" >http://localhost:4000 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，即可看到hexo生成的静态页面。</p><ul><li>停止服务器</li></ul><p><code>Ctrl + C</code></p><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>hexo提供了很多主题可以参考，下面以 <a class="link"   href="https://github.com/littlewin-wang/hexo-theme-casual.git" >hexo-theme-casual <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 主题为例</p><ul><li>安装主题插件</li></ul><blockquote><p><a class="link"   href="https://github.com/EvanNotFound/hexo-theme-redefine" >hexo-theme-redefine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure></div><blockquote><p><a class="link"   href="https://github.com/littlewin-wang/hexo-theme-casual" >hexo-theme-casual <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ npm install --save hexo-renderer-jade hexo-renderer-scss hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-generator-search</span><br></pre></td></tr></table></figure></div><blockquote><p>hexo-theme-redefine</p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ npm install --save hexo-renderer-jade hexo-renderer-scss hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-generator-search</span><br></pre></td></tr></table></figure></div><blockquote><p> <a class="link"   href="https://github.com/shenliyang/hexo-theme-snippet" >hexo-theme-snippet <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S</span><br></pre></td></tr></table></figure></div><blockquote><p><a class="link"   href="https://github.com/jerryc127/hexo-theme-butterfly" >hexo-theme-butterfly <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line">mac@bogon Blog % $ npm install hexo-renderer-pug hexo-renderer-stylus</span><br></pre></td></tr></table></figure></div><ul><li>下载主题</li></ul><p>进入主题的 <code>github</code> 下载页，点击 <code>code -&gt; clone</code>，复制 <code>https</code> 下载链接，进入 博库Blog目录，运行下面的命令：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % cd /Users/mac/Desktop/Blog </span><br><span class="line">mac@bogon Blog % cd themes </span><br><span class="line">mac@bogon themes % git clone https://github.com/littlewin-wang/hexo-theme-casual.git</span><br></pre></td></tr></table></figure></div><p>【注】：主题存放的目录是 <code>Blog/themes</code>，为了方便管理，每一个下载的主题都建一个单独的目录，我这个主题的目录是 <code>hexo-theme-casual</code>，可以下载多个主题:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012144981.png"                                     ></p><ul><li>主题应用</li></ul><p>找到 <code>博客Blog</code> 目录下的配置文件 <code>_config.yml</code>，找到 <code>Extensions</code> 模块，修改 <code>theme</code> 字段：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: hexo-theme-casual</span><br></pre></td></tr></table></figure></div><ul><li>启动本地服务器</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % hexo s</span><br><span class="line"></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br><span class="line">[Browsersync] Access URLs:</span><br><span class="line"> ----------------------------------</span><br><span class="line">          UI: http://localhost:3001</span><br><span class="line"> ----------------------------------</span><br><span class="line"> UI External: http://localhost:3001</span><br><span class="line"> ----------------------------------</span><br></pre></td></tr></table></figure></div><ul><li>查看效果</li></ul><p>通过 <a class="link"   href="http://localhost:4000/" >http://localhost:4000/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 查看修改后的效果</p><ul><li>主题更新</li></ul><p>这一步不是必须的，如果主题有优化，我们需要在本地同步更新一下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % /Users/mac/Desktop/Blog/themes/casual </span><br><span class="line">mac@bogon Blog % git pull</span><br></pre></td></tr></table></figure></div><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><ul><li>清除旧的内容</li></ul><p><code>hexo clean</code></p><ul><li>生成静态发布页面</li></ul><p><code>hexo g</code></p><ul><li>发布页面</li></ul><p><code>hexo d</code></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习14：在Swift里如何处理算术结果溢出</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A014%EF%BC%9A%E5%9C%A8Swift%E9%87%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%AE%97%E6%9C%AF%E7%BB%93%E6%9E%9C%E6%BA%A2%E5%87%BA/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A014%EF%BC%9A%E5%9C%A8Swift%E9%87%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%AE%97%E6%9C%AF%E7%BB%93%E6%9E%9C%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="溢出运算符"><a href="#溢出运算符" class="headerlink" title="溢出运算符"></a>溢出运算符</h1><ul><li><p>在默认情况下，当向一个整数赋超出它容量的值时，<code>swift</code> 会报错而不是生成一个无效的数，给我们操作过大或过小的数时提供了额外的安全性</p></li><li><p>同时提供三个算术溢出运算符来让系统支持整数溢出运算</p><ul><li>溢出加法 <code>&amp;+</code></li><li>溢出减法 <code>&amp;-</code></li><li>溢出乘法 <code>&amp;*</code></li></ul></li></ul><h1 id="值溢出"><a href="#值溢出" class="headerlink" title="值溢出"></a>值溢出</h1><ul><li>数值可以出现向上溢出或向下溢出</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020128841.png"                                     ></p><ul><li><p>溢出也会发生在有符号整型数值上</p></li><li><p>对于无符号与有符号整型数值来说，当出现溢出时，它们会从数值所能容纳的最大数变成最小的数，同样的，当发生下溢时，它们会从所能容纳的最小数变成最大的数</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020128708.png"                                     ></p><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><ul><li>上溢出</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020128353.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020128449.png"                                     ></p><ul><li>下溢出</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020129637.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020129471.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习13：赋值和算术运算符</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A013%EF%BC%9A%E8%B5%8B%E5%80%BC%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A013%EF%BC%9A%E8%B5%8B%E5%80%BC%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li><p>一元运算符对一个目标进行操作。一元前缀运算符（如!b），一元后缀运算符（b!）</p></li><li><p>二元运算符对两个目标进行操作（a+b）同时因为它们出现在两个目标之间，所以是中缀</p></li><li><p>三元运算符操作三个目标，<code>swift</code> 语言也仅有一个 <code>三元运算符</code>，三元条件运算符（a?b:c）</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020122710.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020122158.png"                                     ></p><h1 id="swift-运算符的改进"><a href="#swift-运算符的改进" class="headerlink" title="swift 运算符的改进"></a>swift 运算符的改进</h1><ul><li><p>swift在支持 <code>c</code> 中的大多数标准运算符的同时也增加了一些排除常见代码错误的能力</p></li><li><p>赋值符号 <code>=</code> 不会返回值，以防止它被无用于等于符号 <code>==</code> </p></li><li><p>算术符号 <code>+、-、*、/、%</code> 以及其他可以监测并阻止值溢出，以避免你在操作比存储类型允许的范围更大或更小的数字时得到各种奇怪的结果</p></li></ul><h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><ul><li><p>赋值运算符将一个值赋值给另外一个值</p></li><li><p>如果赋值符号右侧是拥有多个值的元组，它的元素将会一次性地拆分成常量或者变量</p></li><li><p>Swift 的赋值符号自身不会返回值</p></li></ul><h1 id="算术运算符-标准运算符"><a href="#算术运算符-标准运算符" class="headerlink" title="算术运算符-标准运算符"></a>算术运算符-标准运算符</h1><ul><li><p>标准算术运算符 <code>+ - * /</code></p></li><li><p>算术运算符同时也支持 <code>String</code> 的拼接</p></li><li><p><code>swift</code> 算术运算符默认不允许值溢出</p></li></ul><h1 id="算术运算符-余数运算符"><a href="#算术运算符-余数运算符" class="headerlink" title="算术运算符 - 余数运算符"></a>算术运算符 - 余数运算符</h1><ul><li><p>余数运算符 <code>a%b</code> 可以求出多少个 <code>b</code> 的倍数能够刚好放进 <code>a</code> 中并且返回剩下的值（就是我们所谓的余数）</p></li><li><p>当 <code>a</code> 是负数时也适用相同的方法来进行计算</p></li><li><p>当 <code>b</code> 为负数时它的正负号被忽略掉。这意味着 <code>a%b</code> 与 <code>a%-b</code> 能够获得相同的答案</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020123693.png"                                     ></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let c = 9 % 4</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">let d = 9 % -4</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">let e = -9 % 4</span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020124939.png"                                     ></p><h1 id="算术运算符-一元"><a href="#算术运算符-一元" class="headerlink" title="算术运算符 - 一元"></a>算术运算符 - 一元</h1><ul><li><p>数字值的正负号可以用前缀 <code>-</code> 来切换，我们称之为一元减号运算符</p></li><li><p>一元减号运算符 <code>-</code> 直接在要进行操作的值前边放置，不加任何空格</p></li><li><p>一元加号运算符 <code>+</code> 直接返回它操作的值，不会对其进行任何的修改</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习12：获取子串和字符串比较</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A012%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AD%90%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A012%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AD%90%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h1 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h1><ul><li><p>使用下标或者类似 <code>prefix(_:)</code> 的方法得到的子字符串是 <code>Substring</code> 类型</p></li><li><p><code>Substring</code> 拥有 <code>String</code> 的大部分方法</p></li><li><p><code>Substring</code> 可以转成 <code>String</code> 类型</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;hello,world&quot;</span><br><span class="line">let index = str.firstIndex(of: &quot;,&quot;) ?? str.endIndex</span><br><span class="line">let begin = str[..&lt;index]</span><br><span class="line">let new = String(begin)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020120015.png"                                     ></p><ul><li><p>子字符串重用一部分原字符串的内存</p></li><li><p>修改字符串或子字符串之前都不需要花费拷贝内存的代价</p></li><li><p><code>String</code> 和 <code>Substring</code> 都遵循 <code>StringProtocol</code> 协议，也就是说它基本上都能很方便的兼容所有接受 <code>StringProtocol</code> 值的字符串操作函数</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020121376.png"                                     ></p><h1 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h1><ul><li><p>字符串和字符相等性 <code>==</code> 和 <code>!=</code></p></li><li><p>前缀相等性 <code>hasPrefis(_:)</code></p></li><li><p>后缀相等性 <code>hasSubffix(_:)</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &quot;1&quot;</span><br><span class="line">var str2 = &quot;2&quot;</span><br><span class="line">print(str1 == str2)</span><br><span class="line">print(str1.hasPrefix(&quot;1&quot;))</span><br><span class="line">print(str2.hasSuffix(&quot;2&quot;))</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020121878.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习11：索引访问和修改字符串</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A011%EF%BC%9A%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A011%EF%BC%9A%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h1><ul><li><p>每一个 <code>String</code> 值都有相关的索引类型，<code>String.Index</code>，他相当于每个 <code>Character</code> 在字符串中的位置</p></li><li><p><code>startIndex</code> 属性来访问 <code>String</code> 中第一个 <code>Character</code> 的位置。<code>endIndex</code> 属性就是 <code>String</code> 中最后一个字符串的位置</p></li><li><p><code>endIndex</code> 属性并不是字符串下标脚本的合法实际参数</p></li><li><p>如果 <code>String</code> 为空，则 <code>startIndex</code> 与 <code>endIndex</code> 相等</p></li><li><p>使用 <code>index(before:)</code> 和 <code>index(after:)</code> 方法来访问给定索引的前后</p></li><li><p>要访问给定索引更远的索引，你可以使用 <code>index(_:offetBy:)</code></p></li><li><p>使用 <code>indices</code> 属性来访问字符串中每个字符的索引</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var greeting = &quot;Hello, playground&quot;</span><br><span class="line">greeting[greeting.startIndex]</span><br><span class="line">greeting[greeting.index(before: greeting.endIndex)]</span><br><span class="line">greeting[greeting.index(after: greeting.startIndex)]</span><br><span class="line">let index = greeting.index(greeting.startIndex, offsetBy: 7)</span><br><span class="line">greeting[index]</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020116804.png"                                     ></p><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><ul><li><p>插入字符，使用 <code>insert(_:at:)</code> 方法</p></li><li><p>插入到另一个字符串的内容到特定的索引，使用 <code>insert(contentsOf:at:)</code> 方法</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello&quot;</span><br><span class="line">str.insert(&quot;!&quot;, at: str.endIndex)</span><br><span class="line">str.insert(contentsOf: &quot; world&quot;, at: str.firstIndex(of: &quot;!&quot;)!)</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020117964.png"                                     ></p><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><ul><li>移除字符，使用 <code>remove(at:)</code> 方法</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello&quot;</span><br><span class="line">str.remove(at: str.index(before: str.endIndex))</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020117857.png"                                     ></p><ul><li>移除一小段特定范围的字符串，使用 <code>removeSubrange(_:)</code> 方法</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello&quot;</span><br><span class="line">let range = str.index(str.endIndex, offsetBy: -str.count)..&lt;str.endIndex</span><br><span class="line">str.removeSubrange(range)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020117645.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习10：字符串常见操作</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A010%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A010%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串的可变性"><a href="#字符串的可变性" class="headerlink" title="字符串的可变性"></a>字符串的可变性</h1><ul><li><code>var</code> 指定的可以修改</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020114183.png"                                     ></p><ul><li><code>let</code> 指定的不可修改</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020106762.png"                                     ></p><ul><li>对比 Object-C (NSString 和 NSMutableString)</li></ul><h1 id="字符串是-值类型"><a href="#字符串是-值类型" class="headerlink" title="字符串是 值类型"></a>字符串是 值类型</h1><ul><li><p><code>String</code> 值在传递给方法或函数的时候会被复制过去</p></li><li><p>赋值给常量或变量的时候也是一样</p></li><li><p>Swift 编译器优化了字符串使用的资源，实际上拷贝只会在确实需要的时候才进行</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &quot;hello&quot;</span><br><span class="line">var str2 = str1</span><br><span class="line">print(str1 == str2)</span><br><span class="line">str1.append(&quot;,world&quot;)</span><br><span class="line">print(str1)</span><br><span class="line">print(str2)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020109392.png"                                     ></p><h1 id="操作字符"><a href="#操作字符" class="headerlink" title="操作字符"></a>操作字符</h1><ul><li><p><code>for in</code> 循环遍历 <code>String</code> 中的每一个独立的 <code>Character</code></p></li><li><p><code>Character</code> 类型</p></li><li><p><code>String</code> 值可以通过传入 <code>Character</code> 数组来构造</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello&quot;</span><br><span class="line">for c in str&#123;</span><br><span class="line">    print(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020109024.png"                                     ></p><h1 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h1><ul><li><p>使用加运算符 <code>+</code> 创建新字符串</p></li><li><p>使用 <code>+</code> 赋值符号 <code>+=</code> 在已经存在的 <code>String</code> 值末尾追加一个 <code>String</code> 值</p></li><li><p>使用 <code>String</code> 类型的 <code>append()</code> 方法来可以给一个 <code>String</code> 变量的末尾追加 <code>Character</code> 值</p></li></ul><h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><ul><li><p>字符串插值是一种从混合常量、变量、字面量和表达式的字符串字面量构造新 <code>String</code> 值的方法</p></li><li><p>每一个你插入到字符串字面量的元素都要被一对圆括号包裹，然后使用反斜杠前缀 <code>\()</code></p></li><li><p>类似于 <code>NSString</code> 的 <code>stringWithFormat</code> 方法，但是更加简便，更强大</p></li><li><p>可以在扩展字符串分割符中创建一个包含在其他情况下会被当做字符串插值的字符</p></li><li><p>要在使用扩展分隔符的字符串中使用字符串插值，在反斜杠后使用匹配首尾井号数量的井号</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;6 * 7 = \(6 * 7)&quot;</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020110881.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020115034.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习09：字符串创建和使用</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A009%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A009%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="初始化空串"><a href="#初始化空串" class="headerlink" title="初始化空串"></a>初始化空串</h1><ul><li><p>字面量</p></li><li><p>初始化器语法</p></li><li><p><code>isEmpty</code> 检查是否为空串</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var emptyString = &quot;&quot;</span><br><span class="line">var anotherEmptyString = String()</span><br><span class="line"></span><br><span class="line">if emptyString.isEmpty &#123;</span><br><span class="line">    print(&quot;Nothing to see here&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020103809.png"                                     ></p><h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><ul><li><p>字符串字面量是被双引号 <code>“”</code> 包裹的固定顺序文本字符</p></li><li><p><code>Swift</code> 会为 <code>str</code> 常量推断类型为 <code>String</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;some string&quot;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020104645.png"                                     ></p><h1 id="多行字面量"><a href="#多行字面量" class="headerlink" title="多行字面量"></a>多行字面量</h1><ul><li><p>多行字符串字面量是用三个双引号引起来的一系列字符</p></li><li><p>多行字符串字面量把所有行包括在引号内，开始和结束默认不会有换行符</p></li><li><p>如果为了书写美观而不换行在后面加 \</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let someStr = &quot;&quot;&quot;</span><br><span class="line">1\</span><br><span class="line">2\</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">print(someStr)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020104457.png"                                     ></p><ul><li><p>要让多行字符串字面量起始或结束于换行，就在第一或最后一行写一个空行</p></li><li><p>多行字符串可以 <code>缩进</code> 以匹配周围的代码。双引号（”””）前的空格会告诉Swift其他行前应该有多少空白是需要忽略的</p></li><li><p>如果你在某行的空格超过了结束的双引号（”””），那么这些空格会被包含</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    let someStr = &quot;&quot;&quot;</span><br><span class="line">    1</span><br><span class="line">    2</span><br><span class="line">        3</span><br><span class="line">    4</span><br><span class="line">    5</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">print(someStr)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020104509.png"                                     ></p><h1 id="字符串里的特殊字符"><a href="#字符串里的特殊字符" class="headerlink" title="字符串里的特殊字符"></a>字符串里的特殊字符</h1><ul><li><p>转义特殊字符 \o（空字符）,\（反斜杠），\t（水平制表符），\n（换行符），\r（回车符），\”（双引号）以及 &#39;（单引号）</p></li><li><p>任意的 <code>Unicode</code> 标量，写作 <code>\u&#123;&#125;n</code>，里边的 <code>n</code> 是一个 <code>1-8</code> 位的16进制数字，其值是合法 <code>Unicode</code> 值</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;\u&#123;24&#125;&quot;</span><br></pre></td></tr></table></figure></div><ul><li>可以在多行字符串字面量中包含双引号（”）而不需要转义。要在多行字符串中包含文本 “”””””，转义至少一个双引号</li></ul><h1 id="扩展字符串分隔符-Raw-String"><a href="#扩展字符串分隔符-Raw-String" class="headerlink" title="扩展字符串分隔符(Raw String)"></a>扩展字符串分隔符(Raw String)</h1><ul><li><p>在字符串字面量中放置扩展分隔符来使 <code>包含特殊字符的字符串</code> 不让他们真的生效</p></li><li><p>把字符串放在双引号 (“) 内并由 (#) 包裹</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = #&quot;1\n2\n3\n&quot;#</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020105441.png"                                     ></p><ul><li>如果字符串里面有 <code>&quot;#</code> 则首尾需要两个 <code>##</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = ##&quot;1\&quot;#n2\#n3\#n&quot;##</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020105787.png"                                     ></p><ul><li>如果你需要字符串中某个特殊符号的效果，使用匹配你包裹的 <code>#</code> 号数量的 <code>#</code> 号，并在前面写转义符号 <code>\</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = #&quot;1\#n2\#n3\#n&quot;#</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020105373.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习08：Optional的使用Optional实现原理探索</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A008%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8Optional%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A008%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8Optional%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Optional-实现探究"><a href="#Optional-实现探究" class="headerlink" title="Optional-实现探究"></a>Optional-实现探究</h1><ul><li><p><code>Optional</code> 其实是一个标准库里的一个  <code>public 的 enum</code> 类型，而且是 <code>泛型</code> 的，泛型的类型是 <code>Wrapped</code></p></li><li><p>用标准库实现语言特性的典型</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020100711.png"                                     ></p><ul><li><p>Optional.none 就是 <code>nil</code></p></li><li><p>Optional.some 则包装了实际的值</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str:Optional&lt;String&gt; = &quot;abc&quot;</span><br><span class="line">if let actualStr = str &#123;</span><br><span class="line">    let count = actualStr.count</span><br><span class="line">    print(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020101182.png"                                     ></p><h1 id="Optional-解包实现"><a href="#Optional-解包实现" class="headerlink" title="Optional-解包实现"></a>Optional-解包实现</h1><ul><li>泛型属性 <code>unsafelyUnwrapped</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020102043.png"                                     ></p><ul><li>理论上我我们可以直接调用 <code>unsafelyUnwrapped</code> 获取可选项的值</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str:String? = &quot;abc&quot;</span><br><span class="line">let count = str.unsafelyUnwrapped.count</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020102203.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习07：Optional的使用</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A007%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A007%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要-Optional？"><a href="#为什么需要-Optional？" class="headerlink" title="为什么需要 Optional？"></a>为什么需要 Optional？</h1><ul><li>Object-C 里的 <code>nil</code> 是无类型的指针</li><li>Object-C 里面的数组、字典、集合等不允许放入 <code>nil</code></li><li>Object-C 所有 <code>对象的变量</code> 都可以为 <code>nil</code></li><li>Object-C 只能用在对象上，而在其他地方又用其他特殊值（例如NSNotFound）表示值的缺失</li></ul><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><ul><li><p>通过在 <code>变量类型</code> 后面加 <code>?</code> 表示</p><ul><li>这里有一个值，它等于 x</li></ul><p>  或者</p><ul><li>这里根本没有值</li></ul></li><li><p>你可以通过给可选变量赋值一个 <code>nil</code> 来将之设置为没有值</p><ul><li><p>在 Object-C 中 <code>nil</code> 是一个指向不存在对象的指针</p></li><li><p>在 Swift 中，<code>nil</code> 不是指针，它是 <code>值缺失的一种特殊类型</code>，任何类型的可选项都可以设置成 <code>nil</code> 而不仅仅是对象</p><ul><li>只有可选项才能设置为 nil</li></ul></li></ul></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str: String = nil</span><br><span class="line">var str1: String? = nil  </span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020049740.png"                                     ></p><h1 id="Optional-If-语句以及强制解包"><a href="#Optional-If-语句以及强制解包" class="headerlink" title="Optional-If 语句以及强制解包"></a>Optional-If 语句以及强制解包</h1><ul><li>可选项是没法直接使用的</li><li>需要用 <code>!</code> 号强制解包后才能使用（意思是我知道这个可选项里面有值，使用吧）</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str: String? = &quot;abc&quot;</span><br><span class="line">let count = str.count</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020050383.png"                                     ></p><p>需要改成如下代码，才能正确执行</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str: String? = &quot;abc&quot;</span><br><span class="line">let count = str!.count</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020050208.png"                                     ></p><p>或</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str: String? = &quot;abc&quot;</span><br><span class="line">if str != nil &#123;</span><br><span class="line">    let count = str!.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020051471.png"                                     ></p><h1 id="Optional-绑定"><a href="#Optional-绑定" class="headerlink" title="Optional-绑定"></a>Optional-绑定</h1><ul><li><p>可以使用 <code>可选绑定</code> 来判断可选项是否包含值，如果包含就把赋值给一个临时的 <code>常量或变量</code></p></li><li><p>可选绑定可以与 <code>if</code> 和 <code>while</code> 的语句使用来检查可选项内部的值，并赋值给一个变量或常量</p></li><li><p>同一个 <code>if</code> 语句中包含多可选项绑定，用逗号分割即可。如果任一可选绑定结果是 <code>nil</code> 或者 <code>布尔值</code> 为 <code>false</code> ，那么整个 <code>if</code> 判断会被看做 <code>false</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str:String? = &quot;abc&quot;</span><br><span class="line">if let actualStr = str &#123;</span><br><span class="line">    let count = actualStr.count</span><br><span class="line">    print(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020052194.png"                                     ></p><h1 id="Optional-隐士解包"><a href="#Optional-隐士解包" class="headerlink" title="Optional - 隐士解包"></a>Optional - 隐士解包</h1><ul><li><p>有些可选项一旦被设定值之后，就会一直拥有值，在这种情况下，就可以去掉检查的需求，也不必每次访问的时候都进行解包</p></li><li><p>通过有声明的类型后边添加一个叹号（String!）而非问号（String?）来书写隐士解包可选项</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str:String! = &quot;abc&quot;</span><br><span class="line">let count = str.count</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020052565.png"                                     ></p><ul><li>隐士解包可选项主要被用在Swift <code>类</code> 的初始化过程中</li></ul><h1 id="Optional-可选链"><a href="#Optional-可选链" class="headerlink" title="Optional-可选链"></a>Optional-可选链</h1><ul><li><p>可选项后面加问号</p></li><li><p>如果可选项不为nil，返回一个可选项结果，否则为nil</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str:String? = &quot;abc&quot;</span><br><span class="line">let count = str?.count</span><br><span class="line">let lastIndex = count - 1</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020054934.png"                                     ></p><p>将上面的代码改为：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var str:String? = &quot;abc&quot;</span><br><span class="line">let count = str?.count</span><br><span class="line">//let lastIndex = count - 1</span><br><span class="line">if count != nil &#123;</span><br><span class="line">    let lastIndex = count! - 1</span><br><span class="line">    print(lastIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020054879.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习06：Tuple元组</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A006%EF%BC%9ATuple%E5%85%83%E7%BB%84/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A006%EF%BC%9ATuple%E5%85%83%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h1><ul><li><code>元组</code> 把多个值合并成单一的复合型的值</li><li><code>元组</code> 内的值可以是任何类型，而且可以不必是统一类型</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let error = (1,&quot;没有权限&quot;)</span><br><span class="line">print(error.0)</span><br><span class="line">print(error.1)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020044769.png"                                     ></p><h1 id="元素命名"><a href="#元素命名" class="headerlink" title="元素命名"></a>元素命名</h1><ul><li>元组中的每一个元素可以指定对应的元素名称</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let error = (errorCode:1,errorMessage:&quot;没有权限&quot;)</span><br><span class="line">print(error.errorCode)</span><br><span class="line">print(error.errorMessage)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020044807.png"                                     ></p><ul><li>如果没有指定名称的元素也可以使用下标的方式来引用</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let error = (1,&quot;没有权限&quot;)</span><br><span class="line">print(error.0)</span><br><span class="line">print(error.1)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020045931.png"                                     ></p><h1 id="Tuple-修改"><a href="#Tuple-修改" class="headerlink" title="Tuple 修改"></a>Tuple 修改</h1><ul><li>用 <code>var</code> 定义的元组就是可变元组，<code>let</code> 定义的元组就是不可变元组</li><li>不管是可变还是不可变元组，元组在创建后就不能增加和删除元素</li><li>可以对可变元组的元素进行修改，但是不能改变其类型</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var error = (errorCode:1,errorMessage:&quot;没有权限&quot;)</span><br><span class="line">error.errorCode = 2</span><br><span class="line">error.errorMessage = &quot;2&quot;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020045043.png"                                     ></p><ul><li><code>any</code> 类型可以改为任何类型</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var error: (Any,String) = (1,&quot;没有权限&quot;)</span><br><span class="line">error.0 = 2</span><br><span class="line">print(error)</span><br><span class="line">error.0 = &quot;abc&quot;</span><br><span class="line">print(error)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020046096.png"                                     ></p><h1 id="Tuple-分解"><a href="#Tuple-分解" class="headerlink" title="Tuple 分解"></a>Tuple 分解</h1><ul><li>将一个元组的内容分解成单独的常量或变量</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let error = (1,&quot;没有权限&quot;)</span><br><span class="line">let (errorCode,errorMessage) = error</span><br><span class="line">print(errorCode)</span><br><span class="line">print(errorMessage)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020047401.png"                                     ></p><ul><li>如果只需要使用其中的一部分数据，不需要的数据可以用下划线 <code>_</code> 代替</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let error = (1,&quot;没有权限&quot;)</span><br><span class="line">let (_,errorMessage) = error</span><br><span class="line">print(errorMessage)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020047151.png"                                     ></p><h1 id="作为函数返回值"><a href="#作为函数返回值" class="headerlink" title="作为函数返回值"></a>作为函数返回值</h1><ul><li>使用 <code>Tuple</code> 为函数返回多个值</li><li>返回值的 <code>Tuple</code> 可以再函数的返回类型部分被命名</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func writeToFile(content:String) -&gt; (errorCode:Int,errorMessage:String) &#123;</span><br><span class="line">    return (1,&quot;没有权限&quot;)</span><br><span class="line">&#125;</span><br><span class="line">let error = writeToFile(content: &quot;&quot;)</span><br><span class="line">print(error)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020048486.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习05：数值类型</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A005%EF%BC%9A%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A005%EF%BC%9A%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h1><ul><li><p>Swift 提供了 <code>8，16，32，64</code> 位编码的有符号和无符号整数</p></li><li><p>命名方式：例如 8位无符号整数的类型是 UInt8，32位有符号整数的类型是 Int32</p></li><li><p>通过 <code>min</code> 和 <code>max</code> 属性来访问每个整数类型的最小值和最大值</p></li><li><p>Swift 提供了一个额外的整数类型：Int，它拥有与当前平台的原生字相同的长度</p></li><li><p>同时 <code>Swift</code> 也提供 <code>UInt</code> 类型，来表示平台长度相关的无符号整型</p></li><li><p>建议在用到证书的地方都使用 Int</p></li></ul><h1 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h1><ul><li>Double：64位浮点数，至少有 15 位数字的精度</li><li>Float：32位浮点数，至少有 6 为数字的精度</li><li>在两种类型都可以的情况下，推荐使用 Double 类型</li></ul><h1 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020041147.png"                                     ></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = 8</span><br><span class="line">let b: UInt8 = 240</span><br><span class="line">print(&quot;UInt8 min \(UInt8.min),UInt8 max \(UInt8.max)&quot;)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020042980.png"                                     ></p><h1 id="Bool"><a href="#Bool" class="headerlink" title="Bool"></a>Bool</h1><ul><li>Bool：true 和 false</li><li>Swift 的类型安全机制会阻止你用一个非布尔量的值替换掉 Bool</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let i = 1</span><br><span class="line">if i &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020042119.png"                                     ></p><p>我们修改一下</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020042345.png"                                     ></p><h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><ul><li>类型别名是一个为 <code>已存在类型</code> 定义的一个 <code>可选择的名字</code></li><li>你可以用关键字 <code>typealias</code> 定义一个类型的别名</li><li>当你想通过在一个在上下文中看起来更合适可具有表达行的名字来引用一个已存在的类型时，这时别名就非常有用了</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 音频采样率</span><br><span class="line">typealias AudioSample = UInt8</span><br><span class="line">let sample:AudioSample = 32</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020043905.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习04：变量和常量</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A004%EF%BC%9A%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A004%EF%BC%9A%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="声明变量和常量"><a href="#声明变量和常量" class="headerlink" title="声明变量和常量"></a>声明变量和常量</h1><ul><li>使用关键字 <code>let</code> 声明常量</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = 1</span><br><span class="line">a = 2</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020038869.png"                                     ></p><p>由于 <code>x</code> 是常量，不能给常量赋值，会报错</p><ul><li>使用关键字 <code>var</code> 声明变量</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var b = 1</span><br><span class="line">b = 2</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020038019.png"                                     ></p><ul><li>可以在一行中声明多个变量和常量，用逗号分割</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x = 0.0,y = 1.0,z = 2.0</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020039534.png"                                     ></p><h1 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h1><ul><li><p>在声明一个变量或常量时提供类型标注，来明确变量或常量能够存储值的类型</p></li><li><p>添加 <code>类型标注</code> 的方法是在 <code>变量或常量</code> 的名字后面加一个 <code>冒号</code>，再跟一个 <code>空格</code>，最后加上使用的 <code>类型名称</code></p></li><li><p>可以在一行中定义多个相关的变量为相同的类型，用 <code>逗号</code> 分割，只要在最后的变量名字后加上类型标注</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a: String</span><br><span class="line">a = &quot;hello&quot;</span><br><span class="line">a = 10</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020039355.png"                                     ></p><h1 id="常量和变量命名"><a href="#常量和变量命名" class="headerlink" title="常量和变量命名"></a>常量和变量命名</h1><ul><li><p>常量和变量的名字几乎可以使用任何字符，甚至包括 <code>Unicode</code> 字符</p></li><li><p>常量和变量的名字不能包含 <code>空白字符、数学符号、箭头、保留的（或者无效的）Unicode码位、连线和制表符</code>。也不能以 <code>数字</code> 开头，尽管数字几乎可以使用在名字其他的任何地方</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let π = 3.1415</span><br><span class="line">let 你好 = &quot;你好世界&quot;</span><br><span class="line">let 🐶🐂 = &quot;dog,cow&quot;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020040575.png"                                     ></p><h1 id="打印常量和变量"><a href="#打印常量和变量" class="headerlink" title="打印常量和变量"></a>打印常量和变量</h1><ul><li><p>print(_:separator:teminator)</p></li><li><p>字符串插入</p></li></ul><p>用 <code>\()</code> 来插入</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let π = 3.1415</span><br><span class="line">let 你好 = &quot;你好世界&quot;</span><br><span class="line">let 🐶🐂 = &quot;dog,cow&quot;</span><br><span class="line"></span><br><span class="line">print(π)</span><br><span class="line">print(&quot;\(你好)&quot;)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020040638.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习03：Playgorund使用</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A003%EF%BC%9APlayground%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A003%EF%BC%9APlayground%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>Swift 的 <code>Playgorund</code> 是为了让人人都能愉快的学习 <code>swift</code> 编程</li><li>但发展至今，这个工具越来越强大</li></ul><h1 id="Playgorund-使用"><a href="#Playgorund-使用" class="headerlink" title="Playgorund 使用"></a>Playgorund 使用</h1><ul><li>创建一个 <code>Playgorund</code> 应用</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020034182.png"                                     ></p><ul><li>Next，默认名 <code>MyPlayground</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020035090.png"                                     ></p><ul><li>可以通过 New -&gt; Playground Page 创建多个 <code>Playground</code> 来学习</li></ul><p>注：快捷键</p><p>command + option + n 创建 Playground Page</p><p>command + shift + enter 快速运行程序</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020035896.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16776886044720.jpg"                                     ></p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><ul><li>写一个求和的函数</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 求和函数</span><br><span class="line">func sum(a:Int,b:Int) -&gt; Int &#123;</span><br><span class="line">    return a+b</span><br><span class="line">&#125;</span><br><span class="line">// 调用求和函数 赋值给 常量 c</span><br><span class="line">let c = sum(a: 1, b: 2)</span><br><span class="line">// 打印常量 c</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020037021.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习02：REPL交互式解释器</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A002%EF%BC%9AREPL%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A002%EF%BC%9AREPL%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul><li>xcode 6.1 引进了另外一种以交互式的方式来体验 <code>Swift</code> 的方法</li><li>Read Eval PrintLoop，简称REPL</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><code>REPL</code> 除了可以 <code>定义常量和变量</code> 外，还是可 <code>定义函数</code></p><ul><li>打开终端输入</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % swift</span><br><span class="line">mac@bogon ~ % swift repl</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020033029.png"                                     ></p><h1 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020032935.png"                                     ></p><h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020031861.png"                                     ></p><h1 id="REPL-其他命令"><a href="#REPL-其他命令" class="headerlink" title="REPL 其他命令"></a>REPL 其他命令</h1><ul><li>退出：:quit</li><li>帮助：:help</li><li>将光标移动到当前行的开始处：Control + A</li><li>将光标移动到当前行的结束处：Control + E</li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习01：Swift编译流程</title>
      <link href="/BboyZJ.github.io/2023/02/21/Swift%E5%AD%A6%E4%B9%A001%EF%BC%9ASwift%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
      <url>/BboyZJ.github.io/2023/02/21/Swift%E5%AD%A6%E4%B9%A001%EF%BC%9ASwift%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="编译器架构"><a href="#编译器架构" class="headerlink" title="编译器架构"></a>编译器架构</h1><p>Swift编译过程和OC基本类似，仅仅是前端编译器不一样。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020024798.png"                                     ></p><ul><li><code>OC/C</code> 前端编译器是 <code>Clang</code></li><li><code>Swift</code> 先解析成 <code>Swift AST</code>（抽象语法树），通过 <code>swiftc</code> 这个命令行参数，编译成 <code>Swift IL</code></li><li><code>OC</code> 和 <code>Swift</code> 最后均编译成 <code>LLVM IR</code> 中间层表示</li><li><code>OC</code> 和 <code>Swift</code> 最终通过 后端编译器 <code>LLVM compiler</code> ，编译成最终的在具体地址上可以执行的二进制，包括x86、arm和other</li></ul><h1 id="详细编译流程"><a href="#详细编译流程" class="headerlink" title="详细编译流程"></a>详细编译流程</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020025648.png"                                     ></p><ul><li>Swift 先解析成 <code>AST（抽象语法树）</code></li><li>经过一系列工具编程 <code>Swift</code> 的 <code>SIL(中间语言)</code></li><li>再经过 <code>分析、IR工具</code> 转成 <code>LLVM IR(中间表示层)</code>   </li><li>最终通过 后端编译器 LLVM compiler 编译成 .o 目标文件</li></ul><h1 id="命令行流程"><a href="#命令行流程" class="headerlink" title="命令行流程"></a>命令行流程</h1><p>使用终端创建一个简单的 <code>main.swift</code> 文件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd Desktop</span><br><span class="line">mac@bogon Desktop % touch main.swift</span><br></pre></td></tr></table></figure></div><p>此时你可以在桌面看到一个 <code>main.swift</code> 文件</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020026247.png"                                     ></p><p>在该文件下写下两个数相加的一个函数</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func sum(a:Int,b:Int) -&gt; Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let value = sum(a: 1, b: 2)</span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020027637.png"                                     ></p><ul><li>打开命令行工具</li></ul><p><code>mac@bogon ~ % cd Desktop</code></p><ul><li>生成 <code>AST</code> 抽象语法树</li></ul><p><code>mac@bogon ~ % swiftc main.swift -dump-ast</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020027831.png"                                     ></p><ul><li>生成 <code>SIL</code> 中间语言</li></ul><p><code>mac@bogon ~ % swiftc main.swift -emit-sil</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/20230302002831.png"                                     ></p><ul><li>生成 LLVM IR 中间表示层</li></ul><p><code>mac@bogon ~ % swiftc main.swift -emit-ir</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020029775.png"                                     ></p><ul><li>生成 Assembly Language 汇编语言</li></ul><p><code>mac@bogon ~ % swiftc main.swift -emit-assembly</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020030034.png"                                     ></p><ul><li>生成二进制文件</li></ul><p><code>mac@bogon ~ % swiftc -o main.out main.swift</code></p><p>命令行输入：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/01swift编译流程 </span><br><span class="line">mac@bogon 01swift编译流程 % swiftc -o main.out main.swift</span><br><span class="line">mac@bogon 01swift编译流程 % ./main.out</span><br><span class="line">3</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习00：简介</title>
      <link href="/BboyZJ.github.io/2020/08/22/Swift%E5%AD%A6%E4%B9%A000%EF%BC%9A%E7%AE%80%E4%BB%8B/"/>
      <url>/BboyZJ.github.io/2020/08/22/Swift%E5%AD%A6%E4%B9%A000%EF%BC%9A%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Swift介绍"><a href="#Swift介绍" class="headerlink" title="Swift介绍"></a>Swift介绍</h1><p>Swift是Apple在2014年6月WWDC发布的全新的编程语言。</p><p>Swift是一种高性能系统编程语言，提供了对现有C和OC代码框架的无缝访问，并且是内存安全的。</p><p>Swift语言更加简洁，是一门类型安全的语言。</p><h1 id="Swift和OC的区别"><a href="#Swift和OC的区别" class="headerlink" title="Swift和OC的区别"></a>Swift和OC的区别</h1><ol><li>编程范式</li></ol><ul><li>Swift可以 <code>面试协议编程、函数式编程和面向对象编程</code></li><li>OC以 <code>面向对象编程</code> 为主，当然你可以引入 <code>Reactive Cocoa</code> 的类库来进行函数式编程</li></ul><ol start="2"><li>类型安全</li></ol><ul><li>Swift是一门 <code>类型安全的语言</code>。鼓励程序员在代码中清楚明确值的类型。如果代码中使用一个字符串String，那么你不能错误地传递一个整型Int给它。因为Swift是类型安全的，它会在代码编译的时候做类型检查，并且把所有不匹配的类型作为一个错误标记出来。这样使得程序员在开发中尽可能早地发现和修正错误。</li><li>而OC则 <code>不是类型安全的语言</code>，你声明一个NSString变量，仍然可以传递一个NSNumber给它，尽管编译器会抱怨，但是你仍然可以作为NSNumber来使用它。</li></ul><ol start="3"><li>值类型的增强</li></ol><ul><li>在Swift中，典型的有 <code>struct、enum</code> 以及 <code>元祖tuple</code> 都是值类型。而平时使用的Int、Double、Float 、String 、Array 、Dictionary、Set其实都是用结构体实现的，也是 <code>值类型</code>。</li><li>OC中，NSNumber、NSString以及集合类对象都是指针类型。</li></ul><ol start="4"><li>枚举增强</li></ol><ul><li>Swift的枚举可以使用 <code>整型、浮点型、字符串等</code>，还能拥有 <code>属性和方法</code>，甚至支持 <code>泛型、协议、扩展等</code>。</li><li>OC里面的枚举则鸡肋很多。</li></ul><ol start="5"><li>泛型</li></ol><ul><li>Swift中 <code>支持泛型</code>，也支持泛型的类型约束等特性</li><li>苹果推出了Swift2.0版本，为了让开发者从OC更好的国度到Swift上，苹果也为OC带来了Gennerics泛型支持，不过OC的泛型约束也仅停留在编译器警告阶段。</li></ul><ol start="6"><li>协议和扩展</li></ol><ul><li>Swift对协议的支持更加丰富，配合扩展（extension）、泛型、关联类型等可以实现面向协议编程，从而大大提高代码的灵活性。同时swift中的protocol还可以用于值类型，如结构体和枚举</li><li>OC的协议却反强约束，提供optional特性往往成为很多问题得来源，而如果放弃optional又会让实现代价过大。</li></ul><ol start="7"><li>函数和闭包</li></ol><ul><li>Swift函数是一等公民，可以直接定义函数类型变量，可以作为其他函数参数传递，可以作为函数的返回值类型。</li><li>OC里面函数仍然是次等公民，需要selector封装或者使用block才能模拟Swift中类似的效果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
