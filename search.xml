<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OC学习04：JSON和XML数据解析</title>
      <link href="/BboyZJ.github.io/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A004%EF%BC%9AJSON%E5%92%8CXML%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
      <url>/BboyZJ.github.io/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A004%EF%BC%9AJSON%E5%92%8CXML%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>在 <code>iOS</code> 开发中，常见的数据传输格式有两种：<code>JSON和XML</code>。</p></li><li><p>服务器返回客户端的数据，一般都是 <code>JSON格式或XML格式（文件下载除外）</code></p></li><li><p><code>JSON</code> 由于体积小、传输快速等优点，逐渐成为了 <code>主流的数据传输格式</code>。</p></li></ul><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>在 iOS 中，常见解析方案有以下几种：</p><ul><li><p>第三方框架：JSONKit、SBJson、TouchJSON（性能从左到右，越来越差）</p></li><li><p>性能最好的是使用苹果原生的框架： <code>NSJSONSerialization</code></p></li><li><p>JSON格式很想OC中的数组和字典，key必须用双引号</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:22&#125;、[&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:22&#125;,&#123;&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:22&#125;]</span><br></pre></td></tr></table></figure></div><h2 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061810849.png"                                     ></p><h2 id="JSON-转-OC"><a href="#JSON-转-OC" class="headerlink" title="JSON 转 OC"></a>JSON 转 OC</h2><ul><li>第一个参数：要解析的JSON数据，是NSData类型也就是二进制数据</li><li>第二个参数：解析JSON的可选配置参数<ul><li>NSJSONReadingMutableContainers 解析出来的字典和数组是可变的</li><li>NSJSONReadingFragmentsAllowed 解析出来的对象中的字符串是可变的</li><li>NSJSONReadingMutableLeaves 被解析的数据如果既不是字典也不是数组，那么就使用这个</li></ul></li><li>第三个参数：错误信息</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary * dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&amp;error];</span><br></pre></td></tr></table></figure></div><h2 id="OC-转-JSON"><a href="#OC-转-JSON" class="headerlink" title="OC 转 JSON"></a>OC 转 JSON</h2><ul><li>第一个参数：要转换成JSON数据的OC对象，这里是一个字典</li><li>第二个参数：NSJSONWritingPrettyPrinted 对转换之后的JSON对象进行排版，无意义</li><li>第三个参数：错误信息</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSData *data = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;error];</span><br></pre></td></tr></table></figure></div><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><ul><li>XML 可扩展标记语言，是一种数据交互格式，也叫XML文档</li><li>XML 被设计用来传输和存储数据</li></ul><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>常见的XML文档由三部分组成</p><ul><li>文档声明</li></ul><p>在XML文档最前面，必须编写一个文档声明，用来声明XML文档的类型</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 最简单的声明</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line"></span><br><span class="line">// 用encoding属性说明文档的字符编码</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br></pre></td></tr></table></figure></div><ul><li><p>元素</p><ul><li>一个元素包括了 <code>开始标签和结束标签</code>，</li><li>有内容的元素 <code>&lt;name&gt;Tom&lt;/name&gt;</code>；没内容的元素 <code>&lt;from&gt;&lt;/from&gt;</code>，可简写成 <code>&lt;from/&gt;</code></li><li>元素可嵌套其他元素，不可出现交叉嵌套</li></ul></li><li><p>属性</p></li></ul><p>一个元素最多可以拥有多个属性，属性值必须用双引号 <code>&quot; &quot;</code> 或 单引号 <code>&#39; &#39;</code> 括住</p><ul><li>示例</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line">    &lt;person id=&quot;p1&quot;&gt;</span><br><span class="line">        &lt;name&gt;Tom&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;24&lt;/age&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure></div><h2 id="XML-解析的方法"><a href="#XML-解析的方法" class="headerlink" title="XML 解析的方法"></a>XML 解析的方法</h2><p>要想从XML中提取信息，就得解析XML，目前针对XML的解析有两种方式：</p><ul><li>SAX：从根元素开始，按照顺序一个元素一个元素的往下解析，可用于解析大、小文件</li><li>DOM：一次性将整个XML文档加载到内存中，适合较小的文件</li></ul><p><code>iOS</code> 中解析 <code>XML</code> 有两种：</p><ul><li><p>苹果原生：使用 <code>NSXMLParse</code>，SAX方式解析，使用简答</p></li><li><p>第三方框架：<code>libxml2、GDataXML</code></p><ul><li><code>libxml2</code> 纯 c 语音，默认包含在iOS SDK中，同时支持DOM和SAX方式解析</li><li><code>GDataXMLDOM</code> 解析，由 <code>google</code> 基于 <code>libxml2</code> 开发</li></ul></li></ul><p>解析XML大文件建议用：<code>NSXMLParse、libxml2</code><br>解析XML小文件上述三种都可以</p><h2 id="NSXMLParse-使用"><a href="#NSXMLParse-使用" class="headerlink" title="NSXMLParse 使用"></a>NSXMLParse 使用</h2><ul><li><p>添加NSXMLParserDelegate协议</p></li><li><p>获取XML文件，初始化NSXMLParser，并开启解析</p></li><li><p>实现协议中的方法</p></li></ul><p><strong>XMLElement 文件</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@interface XMLElement : NSObject</span><br><span class="line">// 元素名称</span><br><span class="line">@property (nonatomic,strong)NSString *name;</span><br><span class="line">//元素节点文本</span><br><span class="line">@property (nonatomic,strong)NSMutableString *text;</span><br><span class="line">@property (nonatomic,strong)NSDictionary *attribute;</span><br><span class="line">@property (nonatomic,strong)XMLElement *parent;</span><br><span class="line">@property (nonatomic,strong)NSMutableArray&lt;XMLElement *&gt; *childElement;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">🔽</span><br><span class="line"></span><br><span class="line">#import &quot;XMLElement.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation XMLElement</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _text=[[NSMutableString alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (NSMutableArray&lt;XMLElement *&gt; *)childElement&#123;</span><br><span class="line">    if (!_childElement) &#123;</span><br><span class="line">        _childElement = [[NSMutableArray alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    return _childElement;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)description&#123;</span><br><span class="line">    NSDictionary *dic = [self convertToDic];</span><br><span class="line">    if ([NSJSONSerialization isValidJSONObject:dic]) &#123;</span><br><span class="line">        NSError *error;</span><br><span class="line">        NSData *jsonData=[NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;error];</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            return @&quot;&#123;&#125;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (jsonData) &#123;</span><br><span class="line">            @try &#123;</span><br><span class="line">                NSString *jsonStr = [[NSString alloc]initWithData:jsonData encoding:NSUTF8StringEncoding];</span><br><span class="line">                return jsonStr;</span><br><span class="line">            &#125; @catch (NSException *exception) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return @&quot;&#123;&#125;&quot;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">- (NSDictionary *)convertToDic&#123;</span><br><span class="line">    NSMutableDictionary *dic = [[NSMutableDictionary alloc] init];</span><br><span class="line">    if (self.name) &#123;</span><br><span class="line">        dic[self.name]=self.text;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.attribute &amp;&amp; self.attribute.count &gt; 0) &#123;</span><br><span class="line">        [dic addEntriesFromDictionary:self.attribute];</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.childElement &amp;&amp; self.childElement.count &gt; 0) &#123;</span><br><span class="line">        NSMutableArray *child=[[NSMutableArray alloc]init];</span><br><span class="line">        for (XMLElement *element in self.childElement) &#123;</span><br><span class="line">            NSDictionary *childDic = [element convertToDic];</span><br><span class="line">            if (element.childElement &amp;&amp; element.childElement.count &gt; 0) &#123;</span><br><span class="line">                [child addObject:childDic];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                [dic addEntriesFromDictionary:childDic];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (child.count &gt; 0) &#123;</span><br><span class="line">            dic[@&quot;child&quot;]=child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dic;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p><strong>XMLParserManager 文件</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;XMLElement.h&quot;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">typedef void(^ParserXMLCompletion) (BOOL success, XMLElement * _Nullable data,NSError * _Nullable error);</span><br><span class="line">@interface XMLParserManager : NSObject</span><br><span class="line">@property(nonatomic,copy)ParserXMLCompletion completion;</span><br><span class="line">- (void)parserXMLWithUrl:(NSURL *)url completion:(ParserXMLCompletion)completion;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">🔽</span><br><span class="line"></span><br><span class="line">#import &quot;XMLParserManager.h&quot;</span><br><span class="line"></span><br><span class="line">@interface XMLParserManager()&lt;NSXMLParserDelegate&gt;</span><br><span class="line">@property (nonatomic,strong)NSXMLParser *parser;</span><br><span class="line">@property (nonatomic,strong)XMLElement *rootElement;</span><br><span class="line">@property (nonatomic,strong)XMLElement *currentElement;</span><br><span class="line">@end</span><br><span class="line">@implementation XMLParserManager</span><br><span class="line">- (void)parserXMLWithUrl:(NSURL *)url completion:(ParserXMLCompletion)completion&#123;</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        self.completion = completion;</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        NSInputStream *fileInput=[[NSInputStream alloc] initWithURL:url];</span><br><span class="line">        // 创建一个解析器</span><br><span class="line">        _parser = [[NSXMLParser alloc] initWithStream:fileInput];</span><br><span class="line">        // 设置代理</span><br><span class="line">        _parser.delegate = self;</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^&#123;</span><br><span class="line">            __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">            // 开始解析</span><br><span class="line">            [strongSelf.parser parse];</span><br><span class="line">            // 解析错误</span><br><span class="line">            if (weakSelf.parser.parserError) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    if (completion) &#123;</span><br><span class="line">                        completion(NO,nil,strongSelf.parser.parserError);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 文档开始</span><br><span class="line">-(void)parserDidStartDocument:(NSXMLParser *)parser&#123;</span><br><span class="line">    self.rootElement = nil;</span><br><span class="line">    self.currentElement = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 开始解析某个节点</span><br><span class="line"> parser xml对象</span><br><span class="line"> elementName 标签</span><br><span class="line"> namespaceURI 命名控件指向的链接</span><br><span class="line"> qName 命名控件名称</span><br><span class="line"> attributeDict 节点的所有属性</span><br><span class="line"> */</span><br><span class="line">-(void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary&lt;NSString *,NSString *&gt; *)attributeDict&#123;</span><br><span class="line"></span><br><span class="line">    if (!self.rootElement) &#123;</span><br><span class="line">        self.rootElement = [[XMLElement alloc]init];</span><br><span class="line">        self.currentElement = self.rootElement;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        XMLElement *element = [[XMLElement alloc]init];</span><br><span class="line">        // 父节点</span><br><span class="line">        element.parent = self.currentElement;</span><br><span class="line">        // 当前元素的子节点</span><br><span class="line">        [self.currentElement.childElement addObject:element];</span><br><span class="line">        element.name = elementName;</span><br><span class="line">        // 更换当前元素</span><br><span class="line">        self.currentElement = element;</span><br><span class="line">    &#125;</span><br><span class="line">    // 元素名和属性</span><br><span class="line">    self.currentElement.name = elementName;</span><br><span class="line">    self.currentElement.attribute = attributeDict;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当解析器找到开始标记和结束标记之间的字符时，调用这个方法解析当前节点的所有字符</span><br><span class="line">- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string&#123;</span><br><span class="line">    // 获取当前元素的内容</span><br><span class="line">    [self.currentElement.text appendString:string];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结束解析</span><br><span class="line">-(void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName&#123;</span><br><span class="line">    self.currentElement = self.currentElement.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文档结束</span><br><span class="line">-(void)parserDidEndDocument:(NSXMLParser *)parser&#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    if (self &amp;&amp; self.completion) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">            strongSelf.completion(YES, strongSelf.rootElement, nil);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解析失败</span><br><span class="line">- (void)parser:(NSXMLParser *)parser validationErrorOccurred:(NSError *)validationError&#123;</span><br><span class="line">    if (self.completion) &#123;</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">            strongSelf.completion(NO, nil,validationError);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p><strong>VC 调用</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;XMLParserManager.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,strong)XMLParserManager *manager;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    [self parserXML];</span><br><span class="line">&#125;</span><br><span class="line">-(void)parserXML&#123;</span><br><span class="line">    NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;xmlText&quot; ofType:@&quot;xml&quot;];</span><br><span class="line">    NSURL *url = [NSURL fileURLWithPath:path];</span><br><span class="line">    _manager=[[XMLParserManager alloc]init];</span><br><span class="line">    [_manager parserXMLWithUrl:url completion:^(BOOL success, XMLElement * _Nullable data, NSError * _Nullable error) &#123;</span><br><span class="line">            if (success) &#123;</span><br><span class="line">                NSLog(@&quot;%@&quot;,data);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                NSLog(@&quot;error = %@&quot;,error);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    NSLog(@&quot;start == &quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><h2 id="GDataXML-使用"><a href="#GDataXML-使用" class="headerlink" title="GDataXML 使用"></a>GDataXML 使用</h2><ul><li>GDataXMLDocument：xml解析入口</li><li>GdataXMLElement：保存查找的数据</li><li>GdataXMLNode：保存解析的数据</li></ul><p><strong>第一步：集成 GDataXML-HTML</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target &#x27;XML文件解析&#x27; do</span><br><span class="line">  # Comment the next line if you don&#x27;t want to use dynamic frameworks</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  pod &#x27;GDataXML-HTML&#x27;, &#x27;~&gt; 1.4.1&#x27;</span><br><span class="line"></span><br><span class="line">  # Pods for XML文件解析</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></div><p><strong>第二步：项目中配置</strong></p><ul><li><p>pod 安装 GDataXML</p></li><li><p>选中target -&gt; Build Settings -&gt; Link Binary With Libraried，搜索添加 <code>libxml2</code></p></li><li><p>Header Search Paths 添加 <code>/usr/include/libxml2</code> </p></li><li><p>Other Linker Flags 添加 <code>-lxml2</code></p></li><li><p>引入头文件使用</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习40：类&amp;结构体&amp;枚举：下标和下标重载</title>
      <link href="/BboyZJ.github.io/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A040%EF%BC%9A%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE%EF%BC%9A%E4%B8%8B%E6%A0%87%E5%92%8C%E4%B8%8B%E6%A0%87%E9%87%8D%E8%BD%BD/"/>
      <url>/BboyZJ.github.io/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A040%EF%BC%9A%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE%EF%BC%9A%E4%B8%8B%E6%A0%87%E5%92%8C%E4%B8%8B%E6%A0%87%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h1><ul><li><p>类、结构体和枚举可以定义 <code>下标</code>，它可以作为访问集合、列表或序列号成员元素的快捷方式。你可以使用下标通过索引值来设置或检索值而不需要为设置和检索分别使用实例方法</p></li><li><p>你可以为一个类型定义多个下标，并且下标会基于传入的索引值的类型选择合适的下标重载使用。下标没有限制单个维度，你可以使用多个输入形参来定义下标以满足自定义类型的需求</p></li></ul><h1 id="下标语法"><a href="#下标语法" class="headerlink" title="下标语法"></a>下标语法</h1><ul><li>下标脚本允许你通过在实例名后面的方括号内写一个或多个值对该类的实例进行查询。它的语法类似于实例方法和计算属性。使用关键字 subscript 来定义下标，并且指定一个或多个输入形式参数和返回类型，与实例方法一样。与实例方法不同的是，下标可以是读写也可以是只读的</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习39：为类&amp;结构体&amp;枚举添加属性和方法</title>
      <link href="/BboyZJ.github.io/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A039%EF%BC%9A%E4%B8%BA%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"/>
      <url>/BboyZJ.github.io/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A039%EF%BC%9A%E4%B8%BA%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="为类、结构体、枚举添加-属性"><a href="#为类、结构体、枚举添加-属性" class="headerlink" title="为类、结构体、枚举添加 属性"></a>为类、结构体、枚举添加 属性</h1><h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><ul><li><code>存储属性</code> 是一个作为特定类和结构体实例一部分的 <code>常量或变量</code>。存储属性要么是变量存储属性（由 <code>var</code> 关键字引入），要么是常量存储属性（由 <code>let</code> 关键字引入）</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 存储属性</span><br><span class="line">class DataManager &#123;</span><br><span class="line">    // 变量存储属性</span><br><span class="line">    var fileName = &quot;tex&quot;</span><br><span class="line">    // 常量存储属性</span><br><span class="line">    let age = 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="常量结构体实例的存储属性"><a href="#常量结构体实例的存储属性" class="headerlink" title="常量结构体实例的存储属性"></a>常量结构体实例的存储属性</h2><ul><li>如果你创建了一个 <code>结构体的实例</code> 并且把这个 <code>实例赋值给常量</code>，你 <code>不能修改</code> 这个实例的属性，即使是声明为变量的属性</li></ul><h2 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h2><ul><li><p><code>延迟存储属性的初始值在第一次使用时才进行计算</code>。你可以通过在其声明前面标注 <code>lazy 修饰语</code> 来表示一个 <code>延迟存储属性</code></p></li><li><p>如果被标记为 <code>lazy</code> 修饰符的属性同时被多个线程访问并且属性还没有被初始化，则无法保证属性只初始化一次。</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 存储属性</span><br><span class="line">class DataManager &#123;</span><br><span class="line">    // 延迟存储属性</span><br><span class="line">    lazy var data = [String]()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><ul><li>除了存储属性，<code>类、结构体、枚举</code> 还能定义 <code>计算属性</code>，而它实际并不是存储值。相反，它提供一个读取器和一个可选的设置器来间接得到和设置其它的属性和值。类似于 <code>OC</code> 的 <code>set/get</code> 方法去设值和取值</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 计算属性</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Size &#123;</span><br><span class="line">    var width = 0.0,height = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Rect &#123;</span><br><span class="line">    // 存储属性</span><br><span class="line">    var origin = Point()</span><br><span class="line">    var size = Size()</span><br><span class="line">    // 计算属性：可以通过origin 和 size 计算出来</span><br><span class="line">    var center: Point &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            let centerX = origin.x + size.width/2.0</span><br><span class="line">            let centerY = origin.y + size.height/2.0</span><br><span class="line">            return Point(x:centerX, y:centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        set(newCenter) &#123;</span><br><span class="line">            origin.x = newCenter.x - size.width/2.0</span><br><span class="line">            origin.y = newCenter.y - size.height/2.0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="简写-setter"><a href="#简写-setter" class="headerlink" title="简写 setter"></a>简写 setter</h2><ul><li>如果一个计算属性的设置器没有为将要被设置的值定义一个名字，那么它将被默认命名为 <code>newValue</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set &#123;</span><br><span class="line">    origin.x = newValue.x - size.width/2.0</span><br><span class="line">    origin.y = newValue.y - size.height/2.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="简写-getter"><a href="#简写-getter" class="headerlink" title="简写 getter"></a>简写 getter</h2><ul><li>如果整个 <code>getter</code> 的函数体是一个单一的表达式，那么 <code>getter</code> 隐士返回这个表达式</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 简写 get</span><br><span class="line">get &#123;</span><br><span class="line">    Point(x: origin.x + size.width/2.0,y: origin.y + size.height/2.0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h2><ul><li><p>一个 <code>有读取器</code> 但是 <code>没有设置器</code> 的 <code>计算属性</code> 就是所谓的 <code>只读计算属性</code>。只读计算属性返回一个值，也可以通过点语法访问，但是不能被修改为另一个值</p></li><li><p>你必须用 <code>var关键字</code> 定义计算属性（包括只读计算属性）为变量属性，因为它的值不是固定的。let关键字 只能用于常量属性，用于明确哪些值一旦作为实例初始化就不能更改</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 只读计算属性</span><br><span class="line">struct Rect &#123;</span><br><span class="line">    // 存储属性</span><br><span class="line">    var origin = Point()</span><br><span class="line">    var size = Size()</span><br><span class="line">    // 计算属性：可以通过origin 和 size 计算出来</span><br><span class="line">    var center: Point &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return Point(x: origin.x + size.width/2.0,y: origin.y + size.height/2.0)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="属性观察者"><a href="#属性观察者" class="headerlink" title="属性观察者"></a>属性观察者</h2><ul><li><p><code>willSet</code> 会在该值被存储之前被调用</p></li><li><p><code>didSet</code> 会在一个新值被存储之后被调用</p></li><li><p>如果你实现了一个 <code>willSet</code> 观察者，新的属性值会以常量形式参数传递。你可以再你的 <code>willSet</code> 实现中为这个参数定义名字。如果你没有为它命名，那么它会使用默认值的名字 <code>newValue</code></p></li><li><p>如果你实现了一个 <code>didSet</code> 观察者，一个包含旧属性值的常量形式参数将会被传递。你可以为它命名，也可以使用默认值的形式参数名 <code>oldValue</code>。如果你在属性自己的 <code>disSet</code> 观察者里给自己赋值，你赋值的新值就会取代刚刚设置的值。</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 属性观察者</span><br><span class="line">class StepCounter &#123;</span><br><span class="line">    var totalSteps: Int = 0 &#123;</span><br><span class="line">        willSet(newValue) &#123;</span><br><span class="line">            print(&quot;totalSteps to \(newValue)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            if totalSteps &gt; oldValue &#123;</span><br><span class="line">                print(&quot;add \(totalSteps - oldValue) steps&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let stepCounter = StepCounter()</span><br><span class="line">stepCounter.totalSteps = 100</span><br><span class="line">stepCounter.totalSteps = 200</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">totalSteps to 100</span><br><span class="line">add 100 steps</span><br><span class="line">totalSteps to 200</span><br><span class="line">add 100 steps</span><br></pre></td></tr></table></figure></div><h2 id="全局和局部变量"><a href="#全局和局部变量" class="headerlink" title="全局和局部变量"></a>全局和局部变量</h2><ul><li><code>观察属性的能力同样对全局变量和局部变量有效</code>。<code>全局变量</code> 是定义在 <code>任何函数、方法、闭包或者类型环境之外的变量</code>。<code>局部变量</code> 是定义在 <code>函数、方法或闭包环境之中的变量</code>。</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 全局变量</span><br><span class="line">var count: Int = 0 &#123;</span><br><span class="line">    willSet &#123;</span><br><span class="line">        print(&quot;will set count to \(newValue)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    didSet &#123;</span><br><span class="line">        print(&quot;did change count from \(oldValue) to \(count)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">count = 10</span><br><span class="line"></span><br><span class="line">==============</span><br><span class="line">will set count to 10</span><br><span class="line">did change count from 0 to 10</span><br></pre></td></tr></table></figure></div><h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><ul><li>使用 <code>static</code> 关键字来定义 <code>类型属性</code>。对于 <code>类</code> 的 <code>类型属性</code>，你可以使用 <code>class</code> 关键字来 <code>允许子类重写父类的实现</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 类型属性</span><br><span class="line">class SomeClass &#123;</span><br><span class="line">    static var storedProperty = &quot;some value&quot;</span><br><span class="line">    static var computedProperty: Int &#123;</span><br><span class="line">        return 27</span><br><span class="line">    &#125;</span><br><span class="line">    // 重写get方法</span><br><span class="line">    class var overrideComputedProperty: Int &#123;</span><br><span class="line">        return 107</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></div><h1 id="为类、结构体、枚举添加-方法"><a href="#为类、结构体、枚举添加-方法" class="headerlink" title="为类、结构体、枚举添加 方法"></a>为类、结构体、枚举添加 方法</h1><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><ul><li><p><code>实例方法</code> 是属于 <code>特定类实例、结构体实例或枚举实例的函数</code>。他们为这些实例提供功能性，要么通过提供访问和修改实例属性的方法，要么通过提供与实例目的相关的功能</p></li><li><p>每一个类的实例都隐含一个叫做 <code>self</code> 的属性，它完全与实例本身相等。你可以用 self 属性在当前实例中调用自身的方法</p></li><li><p>实际上，你不需要经常在代码中写 <code>self</code>。如果你没有显示地写出 <code>self</code>，<code>swift</code> 会在你方法中使用已知属性或方法的时候假定你调用了当前实例中的属性或者方法</p></li><li><p>例外就是当一个实例方法的形式参数名与实例中某个属性拥有相同的名字的时候。在这种情况下，形式参数名具有优先权，并且调用属性的时候使用更加严谨的方式就很有必要了。你可以使用 <code>self</code> 属性来 <code>区分形式参数名和属性名</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    // 实例方法</span><br><span class="line">    func pringInfo() &#123;</span><br><span class="line">        print(&quot;x is \(x),y is \(y)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p = Point(x: 2,y: 2)</span><br><span class="line">p.pringInfo()</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">x is 2.0,y is 2.0</span><br></pre></td></tr></table></figure></div><h2 id="实例方法-self"><a href="#实例方法-self" class="headerlink" title="实例方法 self"></a>实例方法 self</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    // 实例方法 self</span><br><span class="line">    func isToTheRightOf(x: Double) -&gt; Bool &#123;</span><br><span class="line">        return self.x &gt; x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let somePoint = Point(x: 2.0,y: 3.0)</span><br><span class="line">if somePoint.isToTheRightOf(x: 1.0) &#123;</span><br><span class="line">    print(&quot;the point is x \(somePoint.x)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">the point is x 2.0</span><br></pre></td></tr></table></figure></div><h2 id="在实例方法中修改属性"><a href="#在实例方法中修改属性" class="headerlink" title="在实例方法中修改属性"></a>在实例方法中修改属性</h2><ul><li><p><code>结构体和枚举是值类型</code>。默认情况下，<code>值类型属性不能被自身的实例方法修改</code></p></li><li><p>你可以选择在 <code>func</code> 关键字前放一个 <code>mutating(异变方法)</code> 关键字来 <code>指定可以修改属性</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 修改属性</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    // 异变方法</span><br><span class="line">    mutating func moveBy(x deltaX: Double,y deltaY: Double) &#123;</span><br><span class="line">        x += deltaX</span><br><span class="line">        y += deltaY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var somePoint = Point(x: 1.0, y: 3.0)</span><br><span class="line">somePoint.moveBy(x: 2.0,y: 2.0)</span><br><span class="line">print(&quot;\(somePoint.x) \(somePoint.y)&quot;)</span><br><span class="line"></span><br><span class="line">===========</span><br><span class="line">3.0 5.0</span><br></pre></td></tr></table></figure></div><h2 id="在-mutating-方法中赋值给-self"><a href="#在-mutating-方法中赋值给-self" class="headerlink" title="在 mutating 方法中赋值给 self"></a>在 mutating 方法中赋值给 self</h2><ul><li><code>mutating</code> 方法可以指定整个实例给隐含的 <code>self</code> 属性</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// self</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    // 异变方法</span><br><span class="line">    mutating func moveBy(x deltaX: Double,y deltaY: Double) &#123;</span><br><span class="line">        self = Point(x:x+deltaX,y:y+deltaY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var somePoint = Point(x: 2.0, y: 4.0)</span><br><span class="line">somePoint.moveBy(x: 2.0,y: 2.0)</span><br><span class="line">print(&quot;\(somePoint.x) \(somePoint.y)&quot;)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">4.0 6.0</span><br></pre></td></tr></table></figure></div><h2 id="枚举的-mutating-方法"><a href="#枚举的-mutating-方法" class="headerlink" title="枚举的 mutating 方法"></a>枚举的 mutating 方法</h2><ul><li>枚举的 <code>异变方法</code> 可以设置隐含的 <code>self</code> 属性为相同枚举里的不同成员</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 枚举 mutating 方法</span><br><span class="line">enum StateSwitch &#123;</span><br><span class="line">    case off,low,high</span><br><span class="line">    mutating func next() &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .off:</span><br><span class="line">            self = .low</span><br><span class="line">        case .low:</span><br><span class="line">            self = .high</span><br><span class="line">        case .high:</span><br><span class="line">            self = .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var light = StateSwitch.low</span><br><span class="line">light.next()</span><br><span class="line">light.next()</span><br></pre></td></tr></table></figure></div><h2 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h2><ul><li>通过在 <code>func</code> 关键字前用 <code>static</code> 关键字来明确一个类型方法。类同样可以使用 <code>class关键字</code> 来允许子类重写父类对类型方法的实现</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 实例方法 self</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    func pringInfo() &#123;</span><br><span class="line">        print(&quot;x is \(x),y is \(y)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 类方法</span><br><span class="line">    static func printTypeInfo() &#123;</span><br><span class="line">        print(&quot;A Point&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p = Point(x: 2,y: 2)</span><br><span class="line">p.pringInfo()</span><br><span class="line">// 类方法用类型调用</span><br><span class="line">Point.printTypeInfo()</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">x is 2.0,y is 2.0</span><br><span class="line">A Point</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习37：扩展</title>
      <link href="/BboyZJ.github.io/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A042%EF%BC%9A%E6%89%A9%E5%B1%95/"/>
      <url>/BboyZJ.github.io/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A042%EF%BC%9A%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习37：协议</title>
      <link href="/BboyZJ.github.io/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A041%EF%BC%9A%E5%8D%8F%E8%AE%AE/"/>
      <url>/BboyZJ.github.io/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A041%EF%BC%9A%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习37：类</title>
      <link href="/BboyZJ.github.io/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A040%EF%BC%9A%E7%B1%BB/"/>
      <url>/BboyZJ.github.io/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A040%EF%BC%9A%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习37：结构体</title>
      <link href="/BboyZJ.github.io/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A043%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/BboyZJ.github.io/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A043%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习38：枚举</title>
      <link href="/BboyZJ.github.io/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A038%EF%BC%9A%E6%9E%9A%E4%B8%BE/"/>
      <url>/BboyZJ.github.io/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A038%EF%BC%9A%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="增强的枚举"><a href="#增强的枚举" class="headerlink" title="增强的枚举"></a>增强的枚举</h1><h2 id="枚举的语法"><a href="#枚举的语法" class="headerlink" title="枚举的语法"></a>枚举的语法</h2><ul><li><p>用 <code>enum</code> 关键字来定义一个枚举，然后将其所有的定义内容放在一个大括号 <code>&#123;&#125;</code> 中</p></li><li><p>多个成员值可以出现在同一行中，用逗号隔开</p></li><li><p>每个枚举都定义了一个全新的类型。正如swift中其它类型那样，它的名称（例如： ComP）需要首字母大写。给枚举类型起一个单数的而不是复数的名字，从而使得他们能够顾名思义</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum ComP &#123;</span><br><span class="line">    case east</span><br><span class="line">    case south</span><br><span class="line">    case west</span><br><span class="line">    case north</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">enum ComP2 &#123;</span><br><span class="line">    case ease, south, west, north</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="使用-Switch-语句来匹配枚举值"><a href="#使用-Switch-语句来匹配枚举值" class="headerlink" title="使用 Switch 语句来匹配枚举值"></a>使用 Switch 语句来匹配枚举值</h2><ul><li>你可以用 <code>switch</code> 语句来匹配每一个单独的枚举值</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let directionToHead = ComP.south</span><br><span class="line">switch directionToHead &#123;</span><br><span class="line">case .east:</span><br><span class="line">    print(&quot;east&quot;)</span><br><span class="line">case .south:</span><br><span class="line">    print(&quot;south&quot;)</span><br><span class="line">case .west:</span><br><span class="line">    print(&quot;west&quot;)</span><br><span class="line">case .north:</span><br><span class="line">    print(&quot;north&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">south</span><br></pre></td></tr></table></figure></div><h2 id="遍历枚举的-case"><a href="#遍历枚举的-case" class="headerlink" title="遍历枚举的 case"></a>遍历枚举的 case</h2><ul><li>枚举也可以被遍历，需要遵守 <code>CaseIterable</code> 协议来 <code>允许枚举被遍历</code>，写法：在枚举名后面写 <code>:CaseIterable</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 遍历枚举</span><br><span class="line">enum ComP : CaseIterable&#123;</span><br><span class="line">    case east</span><br><span class="line">    case south</span><br><span class="line">    case west</span><br><span class="line">    case north</span><br><span class="line">&#125;</span><br><span class="line">for direction in ComP.allCases &#123;</span><br><span class="line">    print(direction)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">east</span><br><span class="line">south</span><br><span class="line">west</span><br><span class="line">north</span><br></pre></td></tr></table></figure></div><p>或者</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 遍历枚举</span><br><span class="line">enum ComP2 : CaseIterable&#123;</span><br><span class="line">    case east, south, west, north</span><br><span class="line">&#125;</span><br><span class="line">print(ComP2.allCases)</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">[__lldb_expr_75.ComP2.east, __lldb_expr_75.ComP2.south, __lldb_expr_75.ComP2.west, __lldb_expr_75.ComP2.north]</span><br></pre></td></tr></table></figure></div><h2 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h2><ul><li>可以定义swift枚举来存储任意给定类型的关联值，如果需要的话不同枚举成员关联值的类型可以不同</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 关联值</span><br><span class="line">enum Barcde &#123;</span><br><span class="line">    case upc(Int,Int,Int,Int) // 元组</span><br><span class="line">    case qrCode(String) // 元组</span><br><span class="line">&#125;</span><br><span class="line">var productBarcode = Barcde.upc(5,111,33,245)</span><br><span class="line">print(productBarcode)</span><br><span class="line">productBarcode = .qrCode(&quot;aaaaaddddd&quot;)</span><br><span class="line">print(productBarcode)</span><br><span class="line"></span><br><span class="line">==============</span><br><span class="line">upc(5, 111, 33, 245)</span><br><span class="line">qrCode(&quot;aaaaaddddd&quot;)</span><br></pre></td></tr></table></figure></div><h2 id="关联值绑定"><a href="#关联值绑定" class="headerlink" title="关联值绑定"></a>关联值绑定</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 关联值绑定</span><br><span class="line">switch productBarcode &#123;</span><br><span class="line">case .upc(let a,let b,let c,let d):</span><br><span class="line">    print(&quot;UPC: \(a) \(b) \(c) \(d)&quot;)</span><br><span class="line">case .qrCode(let codeString):</span><br><span class="line">    print(&quot;QR Code: \(codeString)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">QR Code: aaaaaddddd</span><br></pre></td></tr></table></figure></div><h2 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h2><ul><li>枚举成员可以用相同类型的默认值预先填充（称为<code>原始值</code>）</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 原始值</span><br><span class="line">enum carS: Character &#123;</span><br><span class="line">    case tab = &quot;\t&quot;</span><br><span class="line">    case lineFeed = &quot;\n&quot;</span><br><span class="line">    case carrReturn = &quot;\r&quot;</span><br><span class="line">&#125;</span><br><span class="line">let car = carS.tab</span><br><span class="line">print(car.rawValue)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303051804980.png"                                     ></p><h2 id="预设原始值"><a href="#预设原始值" class="headerlink" title="预设原始值"></a>预设原始值</h2><ul><li>当你操作存储整数或字符串原始值枚举的时候，你不必显示地给每一个成员都分配一个原始值。当你没有分配时，swift将自动为你分配值</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 预设原始值</span><br><span class="line">enum ComP: Int &#123;</span><br><span class="line">    case ease = 4,south,west,north</span><br><span class="line">&#125;</span><br><span class="line">print(ComP.south.rawValue)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">5</span><br></pre></td></tr></table></figure></div><h2 id="从原始值初始化"><a href="#从原始值初始化" class="headerlink" title="从原始值初始化"></a>从原始值初始化</h2><ul><li>当你用原始值定义了一个枚举，那么枚举就会自动收到一个可以接受原始值类型的初始化器（叫做 <code>rawValue</code> 的形式参数）然后返回一个枚举成员或者 <code>nil</code>。你可以用这个初始化器来尝试创建一个枚举的 新实例</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 初始化器</span><br><span class="line">enum ComP: Int &#123;</span><br><span class="line">    case ease = 4,south,west,north</span><br><span class="line">&#125;</span><br><span class="line">let direction = ComP(rawValue: 6)</span><br><span class="line">print(direction)</span><br><span class="line">let direction2 = ComP(rawValue: 8)</span><br><span class="line">print(direction2)</span><br><span class="line">========</span><br><span class="line">Optional(__lldb_expr_82.ComP.west)</span><br><span class="line">nil</span><br></pre></td></tr></table></figure></div><h2 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h2><ul><li><p><code>递归枚举是拥有另一个枚举作为枚举成员关联值的枚举</code>。当编译器操作递归枚举时必须插入 简介寻址层。你可以在声明枚举成员之前使用 indrect 关键字来明确它是递归的</p></li><li><p>如果说表达式 (5+4)*2 在乘法右侧有一个数但有其他表达式在乘法的左侧</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 递归枚举</span><br><span class="line">indirect enum ArExp &#123;</span><br><span class="line">    case number(Int)</span><br><span class="line">    case add(ArExp,ArExp)</span><br><span class="line">    case mutiply(ArExp,ArExp)</span><br><span class="line">&#125;</span><br><span class="line">let firstExp = ArExp.number(5)</span><br><span class="line">let secondExp = ArExp.number(4)</span><br><span class="line">let addExp = ArExp.add(firstExp,secondExp)</span><br><span class="line">let thirdExp = ArExp.number(2)</span><br><span class="line">let mutipExp = ArExp.mutiply(addExp,thirdExp)</span><br><span class="line">print(mutipExp)</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">mutiply(__lldb_expr_89.ArExp.add(__lldb_expr_89.ArExp.number(5), __lldb_expr_89.ArExp.number(4)), __lldb_expr_89.ArExp.number(2))</span><br></pre></td></tr></table></figure></div><p>我们可以写一个函数来执行这个表达式</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func eval(_ exp: ArExp) -&gt; Int &#123;</span><br><span class="line">    switch exp &#123;</span><br><span class="line">    case .number(let value):</span><br><span class="line">        return value</span><br><span class="line">    case .add(let first,let second):</span><br><span class="line">        return eval(first) + eval(second)</span><br><span class="line">    case .mutiply(let first,let second):</span><br><span class="line">        return eval(first) * eval(second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(eval(mutipExp))</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">18</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习35：如何使用swift中的高阶函数</title>
      <link href="/BboyZJ.github.io/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A035%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8swift%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
      <url>/BboyZJ.github.io/2023/03/05/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A035%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8swift%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><ul><li>对于演示集合里的每一个元素，以一个 <code>变换后的元素替换它</code>，形成一个新的集合</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303051527743.png"                                     ></p><p>示例：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// map：尾随闭包的形式输出</span><br><span class="line">let nums = [1,2,3,4,5]</span><br><span class="line">print(nums.map &#123; $0 * 10 &#125;)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">[10, 20, 30, 40, 50]</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303051527639.png"                                     ></p><h1 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h1><ul><li>对于原始集合里的每一个元素，通过判定来将其丢弃或者放进新集合</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303051527725.png"                                     ></p><p>示例：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// filter：尾随闭包的形式输出</span><br><span class="line">let nums = [1,2,3,4,5]</span><br><span class="line">print(nums.filter &#123; $0 &gt; 3 &#125;)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">[4, 5]</span><br></pre></td></tr></table></figure></div><h1 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h1><ul><li>对于原始集合里的每一个元素，作用于当前累计的结果上</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303051527779.png"                                     ></p><p>示例：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// reduce：尾随闭包的形式输出</span><br><span class="line">let nums = [1,2]</span><br><span class="line">print(nums.reduce(10, &#123; $0 + $1 &#125;))</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">13</span><br></pre></td></tr></table></figure></div><h1 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h1><ul><li>对于元素是集合的集合，可以得到单级的集合</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let results = [[1,2,3],[4,5,6]];</span><br><span class="line">let allResults = results.flatMap&#123; $0.map &#123; $0 &#125; &#125;</span><br><span class="line">let passMarks = results.flatMap&#123; $0.filter &#123; $0 &gt; 5 &#125; &#125;</span><br><span class="line">print(allResults)</span><br><span class="line">print(passMarks)</span><br><span class="line"></span><br><span class="line">===========</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line">[6]</span><br></pre></td></tr></table></figure></div><h1 id="compactMap"><a href="#compactMap" class="headerlink" title="compactMap"></a>compactMap</h1><ul><li>过滤空值</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// compactMap</span><br><span class="line">let keys: [String?] = [&quot;a&quot;,nil,&quot;b&quot;]</span><br><span class="line">let key = keys.map&#123; $0 &#125;</span><br><span class="line">print(key)</span><br><span class="line">let validNames = keys.compactMap&#123; $0 &#125;</span><br><span class="line">print(validNames)</span><br><span class="line">let counts = keys.compactMap&#123; $0?.count &#125;</span><br><span class="line">print(counts)</span><br><span class="line"></span><br><span class="line">==========</span><br><span class="line">[Optional(&quot;a&quot;), nil, Optional(&quot;b&quot;)]</span><br><span class="line">[&quot;a&quot;, &quot;b&quot;]</span><br><span class="line">[1, 1]</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC组件化06：Github-Desktop管理工具使用</title>
      <link href="/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9606%EF%BC%9AGithub-Desktop%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9606%EF%BC%9AGithub-Desktop%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>GitHub Desktop 简单说就是 <code>图形界面</code> 版的 <code>Git</code>，不需要命令行的操作</p><p>通过 <a class="link"   href="https://desktop.github.com/" >GitHub官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 可以下载、安装使用</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li><p>注册你的 <code>GitHub</code> 账号，已注册 <code>GitHub</code> 账号的，跳过</p></li><li><p>在 <code>GitHub Desktop</code> 登录你的账号</p></li></ul><h1 id="创建仓库：File-gt-new-repository"><a href="#创建仓库：File-gt-new-repository" class="headerlink" title="创建仓库：File -&gt; new repository"></a>创建仓库：File -&gt; new repository</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042347662.png"                                     ></p><h1 id="创建分支：branch-gt-new-branch"><a href="#创建分支：branch-gt-new-branch" class="headerlink" title="创建分支：branch -&gt; new branch"></a>创建分支：branch -&gt; new branch</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042347152.png"                                     ></p><ul><li>创建一个开发的分支 <code>zj_feature</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042348162.png"                                     ></p><h1 id="克隆仓库到-GitHub-Desktop"><a href="#克隆仓库到-GitHub-Desktop" class="headerlink" title="克隆仓库到 GitHub Desktop"></a>克隆仓库到 GitHub Desktop</h1><ul><li>File -&gt; Clone Repository</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042348676.png"                                     ></p><ul><li>切换分支</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042348034.png"                                     ></p><h1 id="修改工程代码，将-0-2-0-版本代码完成，并提交到新分支-zj-feature"><a href="#修改工程代码，将-0-2-0-版本代码完成，并提交到新分支-zj-feature" class="headerlink" title="修改工程代码，将 0.2.0 版本代码完成，并提交到新分支 zj_feature"></a>修改工程代码，将 0.2.0 版本代码完成，并提交到新分支 zj_feature</h1><ul><li><p>Summary：必填 0.2.0</p></li><li><p>Description：描述 0.2.0 版本的内容</p></li><li><p>Commit to zj_feature</p></li><li><p>push origin</p></li></ul><h1 id="合并分支："><a href="#合并分支：" class="headerlink" title="合并分支："></a>合并分支：</h1><ul><li>先切换到 <code>main</code> 主分支</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042348854.png"                                     ></p><ul><li>合并分支：branch菜单 -&gt; merge into current branch</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042348376.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042349579.png"                                     ></p><h1 id="提交-main-分支"><a href="#提交-main-分支" class="headerlink" title="提交 main 分支"></a>提交 main 分支</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042349550.png"                                     ></p><h1 id="删除分支：菜单branch-gt-delete-删除分支"><a href="#删除分支：菜单branch-gt-delete-删除分支" class="headerlink" title="删除分支：菜单branch -&gt; delete 删除分支"></a>删除分支：菜单branch -&gt; delete 删除分支</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042349616.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042350674.png"                                     ></p><h1 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h1><ul><li><p>还未提交代码：文件右键 -&gt; <code>Discard Changes</code> 放弃更改</p></li><li><p>已经提交代码：文件右键选择 -&gt; <code>Revert This Commit</code> 恢复到当前提交</p></li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>打开项目代码：Show in Finder</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042351545.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042351468.png"                                     ></p><ul><li>所有 <code>新增代码</code> 可以在工程项目中实时修改，并可以运行查看效果</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042351431.png"                                     ></p><ul><li>在 GitHub Desktop 上可以看到实时的修改</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042352356.png"                                     ></p><ul><li>修改完记得修改一下版本号</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042353544.png"                                     ></p><ul><li>提交代码到 <code>本地mian</code> 分支</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042353044.png"                                     ></p><ul><li>提交代码到 <code>远程main</code> 分支</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042354437.png"                                     ></p><h1 id="终端搜索-ZJWeakProxy-库"><a href="#终端搜索-ZJWeakProxy-库" class="headerlink" title="终端搜索 ZJWeakProxy 库"></a>终端搜索 ZJWeakProxy 库</h1><p><code>mac@bogon ~ % pod search ZJWeakProxy</code></p><p>【问题：】未搜索到自己创建的组件库</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042353662.png"                                     ></p><p>解决方法：更新本地Pod的索引文件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % rm ~/Library/Caches/CocoaPods/search_index.json</span><br><span class="line">mac@bogon ~ % pod repo update</span><br></pre></td></tr></table></figure></div><p>如果还是搜索不到：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % sudo gem install -n /usr/local/bin cocoapods --pre </span><br><span class="line">mac@bogon ~ % pod setup</span><br></pre></td></tr></table></figure></div><ul><li>再次搜索</li></ul>]]></content>
      
      
      <categories>
          
          <category> Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC组件化05：【方案二】cocoapods组件化</title>
      <link href="/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9605%EF%BC%9A%E3%80%90%E6%96%B9%E6%A1%88%E4%BA%8C%E3%80%91cocoapods%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
      <url>/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9605%EF%BC%9A%E3%80%90%E6%96%B9%E6%A1%88%E4%BA%8C%E3%80%91cocoapods%E7%BB%84%E4%BB%B6%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul><li>随着公司业务的不断发展，应用的代码体积将会越来越大，业务代码耦合也越来越多，代码量也是急剧增加</li><li>如果仅仅完成代码拆分还不足以解决业务之间的代码耦合，而组件化是一种能够解决代码耦合、业务工程能够独立运行的技术</li><li>这篇文章主要介绍远程私有库的创建和管理以及本地索引库的使用</li></ul><p>本文以创建 <code>公有库</code> 为例</p><h1 id="查看本地索引库"><a href="#查看本地索引库" class="headerlink" title="查看本地索引库"></a>查看本地索引库</h1><ul><li>我们用 <code>cocoaPods</code> 的时候，默认使用的是cocoaPods自带的索引库<br>终端中使用命令 <code>$ pod repo</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cocoapods</span><br><span class="line">- Type: git (remotes/origin/master)</span><br><span class="line">- URL:  https://github.com/CocoaPods/Specs.git</span><br><span class="line">- Path: /Users/mac/.cocoapods/repos/cocoapods</span><br><span class="line"></span><br><span class="line">trunk</span><br><span class="line">- Type: CDN</span><br><span class="line">- URL:  https://cdn.cocoapods.org/</span><br><span class="line">- Path: /Users/mac/.cocoapods/repos/trunk</span><br><span class="line"></span><br><span class="line">2 repos</span><br></pre></td></tr></table></figure></div><h1 id="组件化分类"><a href="#组件化分类" class="headerlink" title="组件化分类"></a>组件化分类</h1><ul><li><p>公有库：所有人都能使用</p></li><li><p>私有库：公司内部拥有特殊权限才能使用</p></li><li><p>framework：公私都有，动态库静态库。只能看到.h文件。</p></li></ul><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li><p><code>GitHub</code> 账号一个：上传组件工程用</p></li><li><p>安装 <code>CocoaPods</code>：创建并验证 <code>pod</code> 用</p></li><li><p>安装 <code>Git</code> 命令行 ：首次上传组件工程用</p></li><li><p>安装 <code>Github Desktop</code> 或者 <code>SourceTree</code>：后续更新组件用的，Git命令使用熟练者忽略此项</p></li></ul><h1 id="创建公有库"><a href="#创建公有库" class="headerlink" title="创建公有库"></a>创建公有库</h1><ul><li>首先在 <code>Github</code> 创建一个新的 <code>Repository</code>，你的 <code>pods</code> 最终要托管在 <code>Github</code> 平台上的，所以在 <code>Github</code> 上创建一个空的 <code>Repository</code></li></ul><p>注意：<code>库名 = 项目前缀 + 组件名称 </code> ，如 ZJWeakProxy &#x3D; 解决循环引用组件库</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042335079.png"                                     ></p><ul><li>创建完成后的信息如下：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042335792.png"                                     ></p><h1 id="注册-cocoapods-账户"><a href="#注册-cocoapods-账户" class="headerlink" title="注册 cocoapods 账户"></a>注册 cocoapods 账户</h1><ul><li><p>先安装 <code>cocoapods</code>，这个很简单，可以百度搜索自行安装</p></li><li><p>想要创建一个开源 <code>pod</code> 库，首先我们需要注册 <code>cocoapods账户</code>，基于 <code>cocoapods</code> 已经安装好的前提下，这里直接使用 <code>trunk</code> 去注册 <code>cocopods账户</code>，在终端执行：</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod trunk register 邮箱地址 &#x27;用户名&#x27; --verbose</span><br><span class="line">mac@bogon ~ % pod trunk register 13718004742@163.com &#x27;BboyZJ&#x27; --verbose</span><br></pre></td></tr></table></figure></div><p>邮箱地址：一般会使用 GitHub邮箱<br>用户名：随便</p><ul><li>注册之后，在邮箱会受到确认邮件</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042335229.png"                                     ></p><ul><li>注册成功之后可以在终端 <code>验证是否注册成功</code>：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 验证是否注册成功</span><br><span class="line">mac@bogon ~ % pod trunk me</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>查看注册信息，以后可以使用该开源pod库发布工具，也可以通过此方式查看已经发布过的pods：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % pod trunk me</span><br><span class="line">  - Name:     BboyZJ</span><br><span class="line">  - Email:    13718004742@163.com</span><br><span class="line">  - Since:    October 20th, 2021 19:20</span><br><span class="line">  - Pods:</span><br><span class="line">    - ZJSDKDemo</span><br><span class="line">    - ZJSDK_iOS</span><br><span class="line">  - Sessions:</span><br><span class="line">    - October 20th, 2021 19:20 - March 31st, 2022 04:01. IP: 114.253.15.66 </span><br><span class="line">    Description: imac</span><br><span class="line">    - February 27th, 02:33     -        July 5th, 02:37. IP:</span><br><span class="line">    114.252.233.188</span><br></pre></td></tr></table></figure></div><h1 id="在本地创建pod库"><a href="#在本地创建pod库" class="headerlink" title="在本地创建pod库"></a>在本地创建pod库</h1><ul><li>利用pod命令创建名为 <code>ZJWeakProxy</code> 的 <code>pod</code> 库</li></ul><p>注：这个名字要和 <code>GitHub</code> 创建的 <code>Repository</code> 名一致</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cd 到桌面文件夹(组件文件夹)ZJComponent目录下，这个不强制随意</span><br><span class="line">mac@bogon ~ % cd ZJComponent </span><br><span class="line"># 执行 pod lib create ZJWeakProxy</span><br><span class="line">mac@bogon ~ % pod lib create ZJWeakProxy</span><br></pre></td></tr></table></figure></div><ul><li>出现 fatal: unable to access ‘<a class="link"   href="https://github.com/CocoaPods/pod-template.git/" >https://github.com/CocoaPods/pod-template.git/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘: HTTP&#x2F;2 stream 1 was not closed cleanly before end of the underlying stream 报错</li></ul><p>原因分析：一般这是因为服务器的 <code>SSL</code> 证书没有经过第三方机构的签署，所以才报错</p><p>解决办法：解除 <code>SSL</code> 验证，再次执行</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ZJComponent % git config --global http.sslVerify false</span><br></pre></td></tr></table></figure></div><ul><li>执行完上述命令后，会问你几个问题，按需求填写即可</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 你想使用哪个平台？</span><br><span class="line">1、What platform do you want to use?? [ iOS / macOS ]</span><br><span class="line">iOS</span><br><span class="line"># 库语言选择？</span><br><span class="line">2、What language do you want to use?? [ Swift / ObjC ]</span><br><span class="line">ObjC</span><br><span class="line"># 是否需要一个demo工程，用于调试Pod？</span><br><span class="line">3、Would you like include a demo application with your library? [ Yes / No ]</span><br><span class="line">Yes</span><br><span class="line"># 你要使用哪个测试框架？</span><br><span class="line">4、Which testing frameworks will you use? [ Specta / Kiwi / None ]</span><br><span class="line">None</span><br><span class="line"># 是否要UI测试？</span><br><span class="line">5、Would you like to do view based testing? [ Yes / No ]</span><br><span class="line">NO</span><br><span class="line"># 类名前缀？</span><br><span class="line">6、What is your class prefix?</span><br><span class="line">ZJ</span><br></pre></td></tr></table></figure></div><ul><li>到这里 <code>pod</code> 库就创建完成了，它会自己打开刚才创建的pod库</li></ul><h1 id="工程目录介绍"><a href="#工程目录介绍" class="headerlink" title="工程目录介绍"></a>工程目录介绍</h1><ul><li>目录结构如下：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042336465.png"                                     ></p><p>【第1部分】：主要是用来编辑pod相关配置元数据区<br>【第2部分】：主要是用来验证pod效果区<br>【第3部分】：主要是用来 提供给别人使用暴露出来的pod，ReplaceMe空的可以删除，是提示我们可以添加自己的类</p><ul><li>配置 <code>podspec</code> 本地索引文件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  # 库名称</span><br><span class="line">  s.name             = &#x27;ZJWeakProxy&#x27;</span><br><span class="line">  # 版本号</span><br><span class="line">  s.version          = &#x27;0.1.0&#x27;</span><br><span class="line">  # 库简短介绍</span><br><span class="line">  s.summary          = &#x27;A short description of ZJWeakProxy.&#x27;</span><br><span class="line"></span><br><span class="line"># This description is used to generate tags and improve search results.</span><br><span class="line">#   * Think: What does it do? Why did you write it? What is the focus?</span><br><span class="line">#   * Try to keep it short, snappy and to the point.</span><br><span class="line">#   * Write the description between the DESC delimiters below.</span><br><span class="line">#   * Finally, don&#x27;t worry about the indent, CocoaPods strips it!</span><br><span class="line"></span><br><span class="line">  # 开源库描述</span><br><span class="line">  s.description      = &lt;&lt;-DESC</span><br><span class="line">TODO: Add long description of the pod here.</span><br><span class="line">                       DESC</span><br><span class="line">  # 开源库地址，或者是博客、社交地址等</span><br><span class="line">  s.homepage         = &#x27;https://github.com/BboyZJ/ZJWeakProxy&#x27;</span><br><span class="line">  # s.screenshots     = &#x27;www.example.com/screenshots_1&#x27;, &#x27;www.example.com/screenshots_2&#x27;</span><br><span class="line">  # 开源协议</span><br><span class="line">  s.license          = &#123; :type =&gt; &#x27;MIT&#x27;, :file =&gt; &#x27;LICENSE&#x27; &#125;</span><br><span class="line">  # 开源库作者</span><br><span class="line">  s.author           = &#123; &#x27;BboyZJ&#x27; =&gt; &#x27;13718004742@163.com&#x27; &#125;</span><br><span class="line">  # 开源库资源文件</span><br><span class="line">  s.source           = &#123; :git =&gt; &#x27;https://github.com/BBoyZJ/ZJWeakProxy.git&#x27;, :tag =&gt; s.version.to_s &#125;</span><br><span class="line">  # 社交网址</span><br><span class="line">  # s.social_media_url = &#x27;https://twitter.com/&lt;TWITTER_USERNAME&gt;&#x27;</span><br><span class="line">  # 开源库最低支持</span><br><span class="line">  s.ios.deployment_target = &#x27;10.0&#x27;</span><br><span class="line">  # 开源库源文件</span><br><span class="line">  s.source_files = &#x27;ZJWeakProxy/Classes/**/*&#x27;</span><br><span class="line">  # 添加图片等资源文件</span><br><span class="line">  # s.resource_bundles = &#123;</span><br><span class="line">  #   &#x27;ZJWeakProxy&#x27; =&gt; [&#x27;ZJWeakProxy/Assets/*.png&#x27;]</span><br><span class="line">  # &#125;</span><br><span class="line">  </span><br><span class="line">  # s.public_header_files = &#x27;Pod/Classes/**/*.h&#x27;</span><br><span class="line">  # 依赖系统库 多个用逗号隔开</span><br><span class="line">  # s.frameworks = &#x27;UIKit&#x27;, &#x27;MapKit&#x27;</span><br><span class="line">  # 引入第三方依赖库</span><br><span class="line">  # s.dependency &#x27;AFNetworking&#x27;, &#x27;~&gt; 2.3&#x27;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div><p>【s.dependency】：设置依赖三方库或其他组件，多个库可以分开写多次</p><ul><li>需要注意如图：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16779442070174.jpg"                                     ></p><ul><li><code>Readme</code> 主要是介绍这个组件的用途和使用，可以随时编辑。目前就确认一下自己的名字和邮箱就可以了</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042336844.png"                                     ></p><ul><li>协议文件，也是确认一下自己的名字和邮箱就可以了</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042337356.png"                                     ></p><h1 id="添加自己的类"><a href="#添加自己的类" class="headerlink" title="添加自己的类"></a>添加自己的类</h1><ul><li>打开pod库目录，删除ReplaceMe</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042337055.png"                                     ></p><ul><li>创建 <code>ZJWeakProxy</code> 简单类，声明一个打印函数，方便后续测试</li></ul><p><strong>注：创建类文件一定要放到 Classes 目录下</strong></p><p>.h 文件下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJWeakProxy.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ZJWeakProxy : NSProxy</span><br><span class="line">- (void)printZJWeakProxy;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p>.m 文件下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJWeakProxy.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZJWeakProxy</span><br><span class="line">- (void)printZJWeakProxy&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042338285.png"                                     ></p><ul><li>此时 <code>cd</code> 到 <code>Example</code> 路径下执行 <code>pod install</code> 命令，看看是否能将刚刚添加的库文件引入到工程中</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/ZJComponent/ZJWeakProxy/Example </span><br><span class="line">mac@bogon Example % pod install</span><br></pre></td></tr></table></figure></div><p>如果成功会在Pods中看到：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042338860.png"                                     ></p><ul><li>可以到项目中导入头文件简单使用一下</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042343398.png"                                     ></p><p>证明是可用的</p><p>【注】：<code>CocoaPods</code> 工具的另外一个优点就是，多个组件依赖同一个组件时，它会自动帮你检测安装，而 <code>不会重复导入</code>。</p><h1 id="项目上传与发布"><a href="#项目上传与发布" class="headerlink" title="项目上传与发布"></a>项目上传与发布</h1><ul><li>cd到你的项目路径下，将项目上传到GitHub中（即刚刚创建的ZJWeakProxy公有库中），依次使用下列命令行，不要遗漏</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># cd 到 组件ZJWeakProxy路径下</span><br><span class="line">mac@bogon Example % cd /Users/mac/Desktop/ZJComponent/ZJWeakProxy</span><br><span class="line"># 添加github项目路径</span><br><span class="line">mac@bogon ZJWeakProxy % git remote add origin https://github.com/BboyZ/ZJWeakProxy.git</span><br><span class="line"># 添加文件</span><br><span class="line">mac@bogon ZJWeakProxy % git add .</span><br><span class="line"># 将暂存区里的改动提交到本地的版本库</span><br><span class="line">mac@bogon ZJWeakProxy % git commit -m &quot;first commit&quot;</span><br><span class="line"># 创建分支main</span><br><span class="line">mac@bogon ZJWeakProxy % git branch -M main</span><br><span class="line"># 提交版本号并push到main分支</span><br><span class="line">mac@bogon ZJWeakProxy % git push -u origin main</span><br></pre></td></tr></table></figure></div><ul><li>在执行 <code>git push -u origin main</code> 时，如果遇到需要输入用户名和密码：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Username for &#x27;https://github.com&#x27;: BboyZJ</span><br><span class="line">Password for &#x27;https://BboyZJ@github.com&#x27;:</span><br></pre></td></tr></table></figure></div><p><strong>【注意】</strong>：这个 <code>密码</code> 不是你 <code>GitHub</code> 的登录密码，而是需要生成一个 <code>access tokens</code></p><ul><li>生成 <code>access token</code></li></ul><p>需要在 <code>GitHub</code> 个人设置页 -&gt; Settings -&gt; Developer Settings -&gt; Personal access tokens 中创建一个 <code>token</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042343972.png"                                     ></p><ul><li><p>Generate new token 生成新的 <code>token</code></p><ul><li>设置 <code>token</code> 的有效期 按需设置，访问权限等</li></ul><p>  <img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042344432.png"                                     ></p><ul><li><p>选择要授予令牌token的范围或权限</p></li><li><p>要使用token从命令行访问仓库，请选择repo</p></li></ul><p>  <img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042344063.png"                                     ></p><ul><li>要使用token从命令行删除仓库，请选择delete_repo</li></ul><p> <img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042344513.png"                                     ></p><ul><li>其他根据需要进行勾选</li></ul></li><li><p>点击 <code>Generate token</code> 生成 <code>token</code></p></li></ul><p><code>ghp_VcqgAmF...ZPJ2IGxu0</code></p><p>【注】：记得把这个 <code>token</code> 保存下来，因为下次再刷新这个页面的时候，你会看不到了</p><ul><li>在命令行输入完 <code>token</code> 密码</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Username for &#x27;https://github.com&#x27;: BboyZJ</span><br><span class="line">Password for &#x27;https://BboyZJ@github.com&#x27;: </span><br><span class="line">Enumerating objects: 91, done.</span><br><span class="line">Counting objects: 100% (91/91), done.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (83/83), done.</span><br><span class="line">Writing objects: 100% (91/91), 29.35 KiB | 2.45 MiB/s, done.</span><br><span class="line">Total 91 (delta 23), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (23/23), done.</span><br><span class="line">To https://github.com/BboyZJ/ZJWeakProxy.git</span><br><span class="line"> * [new branch]      main -&gt; main</span><br><span class="line">branch &#x27;main&#x27; set up to track &#x27;origin/main&#x27;.</span><br></pre></td></tr></table></figure></div><p>由上面看代表上传成功了</p><ul><li>打开浏览器 <a class="link"   href="https://github.com/BboyZJ/ZJWeakProxy" >https://github.com/BboyZJ/ZJWeakProxy <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，就可以看到你的pod库已经push上去了</li></ul><h1 id="打-tag-并发布到-Cocoapods"><a href="#打-tag-并发布到-Cocoapods" class="headerlink" title="打 tag 并发布到 Cocoapods"></a>打 tag 并发布到 Cocoapods</h1><p>至此，我们已经成功将本地的仓库关联并推送到远程仓库，现在我们需要发布一个可用的组件</p><ul><li>首先我们要给当前项目打一个 tag 版本号，在 podspec 中：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.version           = &#x27;0.1.0&#x27;</span><br></pre></td></tr></table></figure></div><p>指定的版本号是 0.1.0 ，那么我们就同样打个 0.1.0 的 tag</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 打 tag </span><br><span class="line">mac@bogon ZJWeakProxy % git tag 0.1.0</span><br><span class="line">// 推送到远程</span><br><span class="line">mac@bogon ZJWeakProxy % git push --tags</span><br></pre></td></tr></table></figure></div><p>打 <code>tag</code> 默认在当前分支上，这里只有 <code>master</code> ，所以不用切换分支</p><h1 id="发布到-cocoapods"><a href="#发布到-cocoapods" class="headerlink" title="发布到 cocoapods"></a>发布到 cocoapods</h1><ul><li>我们创建的项目以及标签版本号都是沿用了 <code>podspec</code> 文件中的信息，因此可以直接验证 <code>podspec</code> 文件信息是否可以通过验证，<code>podspec</code> 文件的版本号一定要和 <code>tag</code> 保持一致</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ZJWeakProxy % pod spec link</span><br></pre></td></tr></table></figure></div><p>如果通过验证，那么你会看到类似下面的提示，绿色的 <code>passed validation</code></p><ul><li>首先要通过 <code>trunk</code> 注册生成一条会话：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// pod trunk register 邮箱 用户名 描述</span><br><span class="line">mac@bogon ZJWeakProxy % pod trunk register 13718004742@163.com BboyZJ --description=ZJWeakProxy组件 </span><br></pre></td></tr></table></figure></div><p>然后去邮箱进行验证，验证成功会出现下面页面：</p><ul><li>现在，就可以将 podspec 提交给 CocoaPods 了。这个文件将是别人搜索你的组件的索引。</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ZJWeakProxy % pod trunk push ZJWeakProxy.podspec --allow-warnings</span><br></pre></td></tr></table></figure></div><ul><li>pod search 组件名</li></ul><p>上传完成之后，接可以通过 pod search ZJWeakProxy 搜索到自己的组件了，如果搜索不到，删除本地的搜索文件，命令 ：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ZJWeakProxy % rm ~/Library/Caches/CocoaPods/search_index.json</span><br></pre></td></tr></table></figure></div><p>重新 <code>search</code> 产生新的搜索文件，发布新版本则需要打新的 <code>tag</code>，重新编辑 <code>podspec</code> 文件，然后再次提交给 <code>CocoaPods</code>。</p><h1 id="集成到宿主工程"><a href="#集成到宿主工程" class="headerlink" title="集成到宿主工程"></a>集成到宿主工程</h1><p>经过上面的操作我们已经完成了组件的创建和发布，也支持了 Cocoapods 的集成。现在我们需要将该组件集成到宿主工程中去，使用方式和集成三方库是一样的。</p><ul><li>新建个带 <code>pod</code> 的项目 <code>Demo</code>，把我们做好的 <code>ZJWeakProxy</code> 加入 <code>podfile</code> 文件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Uncomment the next line to define a global platform for your project</span><br><span class="line">platform :ios, &#x27;10.0&#x27;</span><br><span class="line"></span><br><span class="line">target &#x27;ZJWeakProxy-Demo&#x27; do</span><br><span class="line">  # Comment the next line if you don&#x27;t want to use dynamic frameworks</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  # ZJWeakProxy</span><br><span class="line">  pod &#x27;ZJWeakProxy&#x27;,:git =&gt;&quot;https://github.com/BboyZJ/ZJWeakProxy.git&quot;</span><br><span class="line">  </span><br><span class="line">  # Pods for ZJWeakProxy-Demo</span><br><span class="line"></span><br><span class="line">end </span><br></pre></td></tr></table></figure></div><ul><li>执行 pod install</li></ul><p><code>mac@bogon ZJWeakProxy-Demo % pod install</code></p><p>【问题1】安装报错：[!] Unable to find a specification for <code>ZJWeakProxy</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042344858.png"                                     ></p><p>解决办法：</p><p><code>mac@bogon ZJWeakProxy-Demo % pod repo update --verbose</code></p><p>【问题2】：HTTP&#x2F;2 stream 1 was not closed cleanly before end of the underlying stream</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042345578.png"                                     ></p><p>解决办法：更改默认通信协议</p><p><code>mac@bogon ZJWeakProxy-Demo % git config --global http.version HTTP/1.1</code></p><ul><li>引入头文件并打印结果</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042345740.png"                                     ></p><h1 id="版本更新与维护"><a href="#版本更新与维护" class="headerlink" title="版本更新与维护"></a>版本更新与维护</h1><ul><li><p>现在的 <code>ZJWeakProxy</code> 库已经在GitHub上托管了，以后维护这个项目就可以了（开始本地创建的ZJWeakProxy项目就可以删除了），管理GitHub仓库，有两种方案：</p><ul><li><p>可以使用命令行 git clone <a class="link"   href="https://github.com/BboyZJ/ZJWeakProxy" >https://github.com/BboyZJ/ZJWeakProxy <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p>也可以使用 GitHub Desktop</p><ul><li>下载 <a class="link"   href="https://desktop.github.com/" >GitHub Desktop <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 登录你的用户名和密码，<code>File -&gt; Responsitory</code></li></ul></li></ul></li><li><p>其实 <code>GitHub Desktop</code> 更加可视化一些，上面History就是刚才git命令行的记录</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>终于写完了，哇哦😮！</p>]]></content>
      
      
      <categories>
          
          <category> Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC组件化04：【方案一】本地组件化</title>
      <link href="/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9604%EF%BC%9A%E3%80%90%E6%96%B9%E6%A1%88%E4%B8%80%E3%80%91%E6%9C%AC%E5%9C%B0%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
      <url>/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9604%EF%BC%9A%E3%80%90%E6%96%B9%E6%A1%88%E4%B8%80%E3%80%91%E6%9C%AC%E5%9C%B0%E7%BB%84%E4%BB%B6%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><code>本地组件化</code>：主要是通过在 <code>工程中创建library</code>，利用 <code>cocoapods</code> 的 <code>workspec</code> 进行本地管理，不需要将项目上传git，而是直接在本项目中以 <code>framework</code> 的方法进行调用</li></ul><h1 id="创建主工程"><a href="#创建主工程" class="headerlink" title="创建主工程"></a>创建主工程</h1><ul><li>首先创建一个名为 <code>Modularization</code> 的工程</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/162391343-e72a3235-b07f-41da-9fbf-cca1a55c4e8b.jpg"                                     ></p><ul><li>集成 cocoapods，进行本地管理</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhangjian@zhangjiandeMBP ~ % cd /Users/zhangjian/Desktop/Modularization </span><br><span class="line">zhangjian@zhangjiandeMBP Modularization % pod init</span><br><span class="line">Ignoring ffi-1.13.1 because its extensions are not built. Try: gem pristine ffi --version 1.13.1</span><br><span class="line">zhangjian@zhangjiandeMBP Modularization % pod install</span><br></pre></td></tr></table></figure></div><h1 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h1><p>假设有以下几个模块</p><ul><li><p><code>主工程</code>：承载主要的表层业务代码</p></li><li><p><code>Core</code>：独立存在，应用加密、接口请求等敏感代码</p></li><li><p><code>Base</code>：基类封装，拓展，基本的数据处理</p></li><li><p><code>Service</code>：服务层，封装业务工具类，例如网络层服务、持久化服务等</p></li><li><p><code>Pods</code>：三方依赖</p></li></ul><p>其中，各个模块间的关系如下图</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/162391360-04089910-c38d-4859-b4f2-dfc4de229332.jpg"                                     ></p><p>下面，我们来进行模块的创建，以 <code>Core</code> 模块为例：</p><ul><li>选择  <code>File -&gt; new -&gt; project -&gt; iOS -&gt; Framework</code>，新建一个 <code>ZJCore</code> 模块</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/162391370-c14294a9-e941-4a20-ad6d-edaa12a76afc.jpg"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/162391384-d4ee6235-4b4c-49fb-b448-2416822359df.jpg"                                     ></p><ul><li>选择正确的 <code>Group</code> 和 <code>WorkSpace</code>（这里注意：创建的 <code>library</code> 最好放在 <code>主工程根目录下</code>，否则后续的 <code>podfile</code> 执行 <code>pod install</code> 会报错）</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/162391398-93ed8a4d-7f60-48c5-af68-8db35d74d8c0.jpg"                                     ></p><p>创建成功后，看到的结果如下：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/162392357-ddca5e46-b788-4d08-9af5-7e48c475bd1f.jpg"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/162391438-632eac8a-b78a-4901-995f-f997caeea671.jpg"                                     ></p><ul><li>将创建的 <code>library</code> 的 <code>Build Settings -&gt; Mach-O Type</code> 修改为静态库 <code>Static Library</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/162391454-6eb6908f-7e29-4e00-afb5-cad186bcc1c0.jpg"                                     ></p><h1 id="主工程调用Library"><a href="#主工程调用Library" class="headerlink" title="主工程调用Library"></a>主工程调用Library</h1><ul><li>在 <code>ZJCore</code> 中新建一个文件，并添加如下代码</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJCoreSetting : NSObject</span><br><span class="line">// 声明属性</span><br><span class="line">@property (nonatomic,copy)NSString * name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ZJCoreSetting</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>在 <code>Build Phases -&gt; Headers -&gt; Public</code> 中将新建的文件拖拽到 <code>Puclic</code> 中，这样主工程才能访问该文件</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/162391477-33f10151-72cd-48ae-9b9c-0ef6e22a1e4f.jpg"                                     ></p><ul><li>在ZJCore文件中添加引用</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/162392415-896bf8dd-d51d-4d63-b548-babfc3101fc8.jpg"                                     ></p><ul><li>在主工程中，选择 <code>target -&gt; Frameworks,Libraries,and Embedded Content -&gt; + 号 -&gt; 添加 ZJCore</code>，只需要build主工程，library能够自动联编</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/162392476-8813bdd9-e9e9-4508-80e5-40b5bd8101be.jpg"                                     ></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>首先 <code>#import &lt;ZJCore/ZJCoreSetting.h&gt;</code>，然后使用</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/162392563-05712fc4-c7b3-4fde-ae68-05291475888b.jpg"                                     ></p><p>这里需要注意的是，子library之间的互相调用，与主工程调用library类似，主需要添加依赖、暴露header即可</p>]]></content>
      
      
      <categories>
          
          <category> Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC组件化03：面向协议Protocol Class的使用</title>
      <link href="/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AEProtocol-Class%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AEProtocol-Class%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="面向协议-Protocol-Class"><a href="#面向协议-Protocol-Class" class="headerlink" title="面向协议 Protocol Class"></a>面向协议 Protocol Class</h1><ul><li><p>在 <code>URL Scheme路由</code> 和 <code>target-action</code> 方案中，都存在 硬编码、参数不明确问题：URL 、Target_ 、 Action_ 的硬编码，参数都是通过字典的形式传递，类型不明确。</p></li><li><p><code>面向接口</code> 的方式能够很好的解决这两个问题。</p></li></ul><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><ul><li><p>中间件先注册 <code>Protocol</code> 和 <code>Class</code> 对应关系，将 <code>protocol</code> 和 <code>对应的类</code> 进行 <code>字典</code> 匹配</p></li><li><p>中间件返回 <code>Protocol</code> 对应的 <code>Class</code>，然后动态创建实例</p></li></ul><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>面向协议编程</li><li>安全性高</li><li>模块解耦</li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>无法多端通用</li><li>需要进行协议的注册</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ul><li>创建 <code>ZJProtocol.h</code> 协议类文件</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 将各个模块的协议统一放在一个文件中 ，在各个模块中依赖这个文件，实现其协议</span><br><span class="line">@protocol OneMoudleProtocol &lt;NSObject&gt;</span><br><span class="line">@required // 返回模块one</span><br><span class="line">+ (UIViewController *)oneMoudleVC;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol OneDetailMoudleProtocol &lt;NSObject&gt;</span><br><span class="line">@required</span><br><span class="line">+ (UIViewController *)oneDetailMoudleVCWithParas:(NSDictionary *)paras;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>创建 <code>ZJMediator</code> 协议管理类</li></ul><p>ZJMediator.h 文件下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJMediator : NSObject</span><br><span class="line">// 单例</span><br><span class="line">+ (instancetype)shareManager;</span><br><span class="line">// 注册绑定</span><br><span class="line">- (void)registerProtocol:(Protocol *)protocol class:(Class)cls;</span><br><span class="line">// 获取类</span><br><span class="line">- (Class)classFromProtocol:(Protocol *)protocol;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p>ZJMediator.m 文件下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJMediator.h&quot;</span><br><span class="line">@interface ZJMediator ()</span><br><span class="line">@property (nonatomic,strong)NSMutableDictionary * protocolCache;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJMediator</span><br><span class="line">+ (instancetype)shareManager&#123;</span><br><span class="line">    static ZJMediator * mediator;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        mediator = [[ZJMediator alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return mediator;</span><br><span class="line">&#125;</span><br><span class="line">// 注册绑定</span><br><span class="line">- (void)registerProtocol:(Protocol *)protocol class:(Class)cls&#123;</span><br><span class="line">    if (protocol &amp;&amp; cls) &#123;</span><br><span class="line">        [self.protocolCache setObject:cls forKey:NSStringFromProtocol(protocol)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 获取类</span><br><span class="line">- (Class)classFromProtocol:(Protocol *)protocol&#123;</span><br><span class="line">    return  [self.protocolCache objectForKey:NSStringFromProtocol(protocol)];</span><br><span class="line">&#125;</span><br><span class="line">// 懒加载</span><br><span class="line">- (NSMutableDictionary *)protocolCache&#123;</span><br><span class="line">    if (!_protocolCache) &#123;</span><br><span class="line">        _protocolCache = @&#123;&#125;.mutableCopy;</span><br><span class="line">    &#125;</span><br><span class="line">    return _protocolCache;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>创建 <code>OneDetailMoudleEntry</code> 模块</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;OneDetailMoudleEntry.h&quot;</span><br><span class="line">#import &quot;ZJOneDetailViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface OneDetailMoudleEntry ()&lt;OneDetailMoudleProtocol&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation OneDetailMoudleEntry</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    [[ZJMediator shareManager] registerProtocol:@protocol(OneDetailMoudleProtocol) class:[self class]];</span><br><span class="line">&#125;</span><br><span class="line">// 继承</span><br><span class="line">+ (UIViewController *)WithParas:(NSDictionary *)paras&#123;</span><br><span class="line">    ZJOneDetailViewController * detailVC = [[ZJOneDetailViewController alloc] init];</span><br><span class="line">    detailVC.name = paras[@&quot;name&quot;];</span><br><span class="line">    detailVC.age = params[@&quot;age&quot;];</span><br><span class="line">    return detailVC;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>在任何地方调用</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//下一页的点击事件</span><br><span class="line">- (void)next:(UIButton *)sender&#123;</span><br><span class="line">    </span><br><span class="line">    Class cls = [[ZJMediator shareManager] classFromProtocol:@protocol(OneDetailMoudleProtocol)];</span><br><span class="line">    UIViewController * detailVC = [cls oneDetailMoudleVCWithParas:@&#123;@&quot;name&quot;:@&quot;ZJ&quot;,@&quot;age&quot;:30&#125;];</span><br><span class="line">    [self.navigationController pushViewController:detailVC animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC组件化03：基于RuntTime的target-action的使用</title>
      <link href="/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E5%9F%BA%E4%BA%8ERuntTime%E7%9A%84target-action%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E5%9F%BA%E4%BA%8ERuntTime%E7%9A%84target-action%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>target action 是利用 <code>Runtime</code> 的 <code>performSelector:withObject:</code> 方法调用，无需注册</p><h1 id="优缺"><a href="#优缺" class="headerlink" title="优缺"></a>优缺</h1><ul><li>优点：<code>无需注册路由</code>，避免了load里注册影响启动速度</li><li>不用维护全局路由表，避免了查找对应路由</li><li>统一了路由入口</li><li>进行了一定的安全处理</li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>缺点：不能多端使用同一套路由H5，Android</li><li>增加了文件，同时在获取target，sel时存在一定的硬编码</li></ul><h1 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h1>]]></content>
      
      
      <categories>
          
          <category> Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC组件化02：基于URL Scheme的使用</title>
      <link href="/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9602%EF%BC%9A%E5%9F%BA%E4%BA%8EURL-Scheme%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9602%EF%BC%9A%E5%9F%BA%E4%BA%8EURL-Scheme%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="URL-Scheme-路由"><a href="#URL-Scheme-路由" class="headerlink" title="URL Scheme 路由"></a>URL Scheme 路由</h1><ul><li>使 <code>URL Scheme</code> 处理本地的跳转</li><li>通过中间层进行注册 <code>&amp;</code> 调用（load方法里面把被调用者注册到中间层）</li></ul><h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//协议://主机名[:端口]/路径/[?参数]#fragment</span><br><span class="line">@&quot;lstest://lsapp:11111/china/ls.com?a=1&amp;b=2&quot;</span><br></pre></td></tr></table></figure></div><ul><li>lstest：协议名</li><li>lsapp：主机名，为了区分 不同的app</li><li>端口号：可以将端口号作为 模块ID</li><li>china&#x2F;ls.com：路径，可以是跳转到模块的 指定页面</li><li>a&#x3D;1&amp;b&#x3D;2：参数，跳转的参数</li></ul><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042254171.png"                                     ></p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><ul><li><p>优点：实现简单</p></li><li><p>缺点：存在硬编码问题，参数都是通过字典的形式传递，类型不明确</p></li></ul><h1 id="URL-Scheme-路由示例"><a href="#URL-Scheme-路由示例" class="headerlink" title="URL Scheme 路由示例"></a>URL Scheme 路由示例</h1><p>思路：B组件使用URL将Block注册给路由，路由以URL为key，将Block存储起来。<br>     A组件通过URL调用路由的方法，找到对应的Block，完成对A的调用</p><ul><li>创建路由</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJRouter.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ZJRouter ()</span><br><span class="line">@property (strong,nonatomic)NSMutableDictionary * blockDic;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJRouter</span><br><span class="line">// 参数 @&#123;@&quot;&quot;:...&#125;</span><br><span class="line">+ (instancetype)shareInstance&#123;</span><br><span class="line">    static ZJRouter * router = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        router = [[self alloc] init];</span><br><span class="line">        router.blockDic = @&#123;&#125;.mutableCopy;</span><br><span class="line">    &#125;);</span><br><span class="line">    return router;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注册</span><br><span class="line">- (void)registerUrl:(NSString *)url block:(ZJRouterBlock)block&#123;</span><br><span class="line">    if (!url || !block) return;</span><br><span class="line">    if (block) &#123;</span><br><span class="line">        self.blockDic[url] = [block copy];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 执行</span><br><span class="line">- (void)excuteBlockWithUrl:(NSString *)key params:(NSDictionary *)params&#123;</span><br><span class="line">    if (!key) return;</span><br><span class="line">    ZJRouterBlock block = self.blockDic[key];</span><br><span class="line">    if (!block) return;</span><br><span class="line">    block(params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>B 组件中注册</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    [[ZJRouter shareInstance] registerUrl:@&quot;A:aTestAction&quot; block:^(NSDictionary * _Nonnull dic) &#123;</span><br><span class="line">        NSLog(@&quot;dic:%@&quot;,dic);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>A 组件中调用</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ZJRouter shareInstance] excuteBlockWithUrl:@&quot;A:aTestAction&quot; params:@&#123;@&quot;text&quot;:@&quot;文字&quot;&#125;];</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC组件化01：组件化介绍</title>
      <link href="/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9601%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%E4%BB%8B%E7%BB%8D/"/>
      <url>/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9601%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="什么组件化"><a href="#什么组件化" class="headerlink" title="什么组件化"></a>什么组件化</h1><ul><li><p>组件化其实就是 <code>将模块单独抽离、分层</code>，并指定模块间的 <code>通讯</code> 方式，从而实现 <code>解耦</code> 的一种方式，主要运用与团队开发</p></li><li><p>组件化开发就是将一个臃肿的、单一的项目，根据 <code>功能/业务/技术</code> 等进行拆分，形成一个个独立的功能组件，然后借助 <code>Cocoapods</code> 管理工具将其任意组合，集成一个完整的项目。</p></li><li><p>你可以将 <code>AFNetworking、SDWebImage、Bugly、MLeaksFinder</code> 等三方库理解为工程的一部分，属于 <code>基础组件模块</code>，我们要做的就是将项目划分多个独立功能模块，再集成一个完整的项目。</p></li></ul><h1 id="为什么要组件化？"><a href="#为什么要组件化？" class="headerlink" title="为什么要组件化？"></a>为什么要组件化？</h1><p>主要有以下四个原因</p><ul><li><p>模块间解耦</p></li><li><p>模块重用</p></li><li><p>提高团队协作开发效率</p></li><li><p>单元测试</p></li></ul><p>当项目因为各种需求，模块越来越多时，如果此时的各个模块之间是互相调用的，即 <code>你中有我，我中有你</code> 这种情况时，会造成 <code>高耦合</code> 的情况，一旦我们需要对某一模块代码进行 <code>修改</code> 时，就会 <code>牵一发而动全身</code>，导致项目难以维护</p><p><strong>其问题主要体现在以下几个方面：</strong></p><ul><li><p>修改某个功能时，同时需要修改其他模块的代码，因为在其他模块中有该模块的引用，可以理解为 <code>高耦合导致代码修改困难</code></p></li><li><p>模块对外接口不明确，甚至暴露了本不该暴露的私有接口，修改时费时费力。可以理解为 <code>接口不固定导致的接口混乱</code></p></li><li><p>高耦合代码产生的后果就是会影响团队其他成员的开发，产生 <code>代码冲突</code></p></li><li><p>当模块需要重用到其他项目时，<code>难以单独抽离</code></p></li><li><p>模块间耦合的忌口导致接口和依赖关系混乱，<code>无法进行单元测试</code></p></li></ul><p>所以为了解决以上问题，我们需要采用更规范的方式来 <code>降低模块</code> 间的 <code>耦合度</code>，这就是 <code>组件化</code>，也可以理解为 <code>模块化</code></p><p>但是，这里还需要说明一点，因为组件化也是需要一定成本的，需要花费时间设计接口、分离代码等，所以并不是所有的项目都需要组件化。如果你的项目有以下这些特征就 <code>不需要组件化</code>：</p><ul><li><p>项目较小，模块间交互简单，耦合少</p></li><li><p>项目没有被多个外部模块引用，只是一个单独的小模块</p></li><li><p>模块不需要重用，代码也很少被修改</p></li><li><p>团队规模很小</p></li><li><p>不需要编写单元测试</p></li></ul><p>如果你的有以下特性，说明你就必须要 <code>考虑进行组件化</code> 了：</p><ul><li><p>模块逻辑复杂，多个模块之间频繁互相引用</p></li><li><p>项目规模逐渐变大，修改代码变的越来越困难（这里可以理解为：修改一处代码，需要同时修改其他多个地方）</p></li><li><p>团队人数变多，提交代码经常和其他成员冲突</p></li><li><p>项目编译耗时较大</p></li><li><p>模块的单元测试经常由于其他模块的修改而失败</p></li></ul><h1 id="组件化方案"><a href="#组件化方案" class="headerlink" title="组件化方案"></a>组件化方案</h1><p>组件化方案的8条指标：</p><p>一个项目经过组件化后如何来评判，主要有以下几个 <code>标准</code>：</p><ul><li><p>模块之间没有耦合，模块内部的修改不会影响其他模块</p></li><li><p>模块可以单独编译</p></li><li><p>模块间数据传递明确</p></li><li><p>模块对外接口清晰且易维护</p></li><li><p>当模块接口改变时，此模块的外部代码能够被高效重构</p></li><li><p>尽量用最少的修改和代码，让现有项目实现模块化</p></li><li><p>支持OC和Swift，以及混编</p></li></ul><p>前4条主要用于 <code>衡量一个模块是否真正解耦</code>，后4条主要用于衡量在项目中 <code>实践中的易用程序</code></p><p><strong>组件化原则</strong></p><p>一个项目主要分为3层：<code>业务层、通用层</code> 以及 <code>基础层</code>，在进行组件化时，有以下几点说明</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/20230304232513.png"                                     ></p><ul><li><p>只能上层对下层依赖，不能下层对上层依赖，因为下层是对上层的抽象</p></li><li><p>项目公共代码资源下沉</p></li><li><p>横向的依赖尽量减少，最好下层至通用模块，或者基础模块</p></li></ul><h1 id="组件化和非组件化区别"><a href="#组件化和非组件化区别" class="headerlink" title="组件化和非组件化区别"></a>组件化和非组件化区别</h1><p>组件化能够帮助我们将大部分项目拆解成数个小组件，开发者只需要关注组件所依赖的其他组件，而无需关心完整项目的其他部分，每个组件可以自己采取所习惯的架构模式：MVC、MVVM等，就行开发一款个人独立的App那样自由</p><p>非组件化：</p><ul><li>代码高耦合度、高依赖</li><li>项目复杂、臃肿、编译时间过长（影响调试）</li><li>难以融合、集成其他产品</li><li>…</li></ul><p>组件化：</p><ul><li>代码复用性提高，可方便集成到其他项目</li><li>项目可配置，方便集成和功能回退</li><li>方便组件并行开发</li><li>可方便单元测试</li><li>…</li></ul><h1 id="组件化分层"><a href="#组件化分层" class="headerlink" title="组件化分层"></a>组件化分层</h1><p>项目组件化，最难的就是 <code>粒度</code> 问题，需要开发者根据自己的经验把控。这里给出个人认为的层次划分：</p><p>【基础组件】：宏定义&#x2F;常量&#x2F;自定义工具类，如常用的自定义分类<br>【功能组件】：项目中常用的功能，如地图&#x2F;消息推送&#x2F;分享&#x2F;登录等<br>【业务组件】：项目中的模块&#x2F;业务，如文章详情&#x2F;个人中心等<br>【中间组件】：负责项目中的路由&#x2F;消息通知&#x2F;传参&#x2F;回调等<br>【宿主工程】：项目容器，用来集成组件，调整各个组件之间的消息传递容器</p><h1 id="中间层几种方案"><a href="#中间层几种方案" class="headerlink" title="中间层几种方案"></a>中间层几种方案</h1><p>在组件化中，中间层是各个组件的通信桥梁，中间层在组件化过程中扮演着非常重要的角色。</p><p>中间层的三种方式：</p><ul><li><p>基于 <code>URL Scheme</code> 的 <code>路由</code></p></li><li><p>基于 <code>Runtime</code> 的 <code>target-action</code></p></li><li><p>面向接口 的 <code>Protocol - Class</code></p></li></ul><h1 id="基于-URL-Scheme-的三方库"><a href="#基于-URL-Scheme-的三方库" class="headerlink" title="基于 URL Scheme 的三方库"></a>基于 URL Scheme 的三方库</h1><p><code>iOS</code> 中支持的 <code>URL Scheme</code> 让我们能够在 <code>应用之间、应用内部传递消息</code>。</p><ul><li><p><a class="link"   href="https://github.com/joeldev/JLRoutes" >JLRoutes <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p><a class="link"   href="https://github.com/clayallsopp/routable-ios" >routable-ios <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p><a class="link"   href="https://github.com/lightory/HHRouter" >HHRouter <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li></ul><p>具体怎么使用，可以自行去探索</p><h1 id="基于-Runtime-的-target-action"><a href="#基于-Runtime-的-target-action" class="headerlink" title="基于 Runtime 的 target-action"></a>基于 <code>Runtime</code> 的 <code>target-action</code></h1><p>相比 <code>url scheme</code> 的提前注册、实现服务，<code>CTMediator</code> 借助 <code>OC</code> 运行时的特性，现实组件之间服务的自动发现，无需提前注册即可实现组件间的调用，因此，这种方案的可维护性、可读性、扩展性相对较高。</p><ul><li><a class="link"   href="https://github.com/casatwy/CTMediator" >CTMediator <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul><h1 id="面向接口-Protocol-Class"><a href="#面向接口-Protocol-Class" class="headerlink" title="面向接口 Protocol - Class"></a>面向接口 <code>Protocol - Class</code></h1><ul><li><code>Protocol - Class</code></li></ul><p>面向接口的方案通常由两部分组成，一个是用来管理接口协议的类（ProtocolManager），一个是具体的接口协议（ComponentProtocol）</p><h1 id="组件化的核心工具"><a href="#组件化的核心工具" class="headerlink" title="组件化的核心工具"></a>组件化的核心工具</h1><ul><li><p>组件化工程，需要一个宿主工程，负责集成所有的组件。每个组件都是一个单独的工程，通过 <code>Git</code> 私有仓库来管理。</p></li><li><p>所有组件都上传到 <code>Git</code> 仓库并支持 <code>cocoapods</code> 集成。主工程通过配置 <code>Podfile</code> 文件，然后一键 <code>pod update</code> 即可。使用 <code>Cocoapods</code> 来管理组件主要因为其本身功能强大，方便的集成整个项目，解放对依赖库的管理。使用组件化的集成方式，可以很好的避免传统项目中的代码冲突问题。</p></li><li><p>组件化的核心工具就是 <code>CocoaPods</code> ，我们要做的就是将组件项目上传到 <code>Gitee码云</code> 或者 <code>Gitlab极狐</code>，编写项目的 <code>podSpec</code> 文件让组件支持 <code>CocoaPods</code> 集成即可。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习37：对象</title>
      <link href="/BboyZJ.github.io/2023/03/04/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A037%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/BboyZJ.github.io/2023/03/04/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A037%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="swift面向对象概述"><a href="#swift面向对象概述" class="headerlink" title="swift面向对象概述"></a>swift面向对象概述</h1><h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><ul><li><p>继承</p></li><li><p>封装</p></li><li><p>多态</p></li></ul><h2 id="基本单元"><a href="#基本单元" class="headerlink" title="基本单元"></a>基本单元</h2><ul><li><p>枚举</p></li><li><p>结构体</p></li><li><p>类 </p></li><li><p>协议</p></li><li><p>扩展</p></li></ul><h2 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h2><ul><li><p>从整体功能上看 swift 的枚举、结构体、类三者具有完全平等的地位</p></li><li><p>swift 的类、结构体、枚举中都可以定义（属性、方法、下标、构造体、嵌套类型）</p></li><li><p>在swift中，<code>枚举和结构体</code> 是 <code>值类型</code>，<code>类</code> 是 <code>引用类型</code></p></li></ul><h2 id="类和结构体的相似点"><a href="#类和结构体的相似点" class="headerlink" title="类和结构体的相似点"></a>类和结构体的相似点</h2><ul><li><p><code>定义属性用来存储值</code></p></li><li><p><code>定义方法用来提供功能</code></p></li><li><p><code>定义下标脚本用来允许使用下标语法访问值</code></p></li><li><p>定义初始化器用来初始化状态</p></li><li><p>可以被扩展来默认所没有的功能</p></li><li><p>遵循协议来针对特定类型提供标准功能</p></li></ul><h2 id="类和结构体不同点"><a href="#类和结构体不同点" class="headerlink" title="类和结构体不同点"></a>类和结构体不同点</h2><ul><li><p>继承允许一个类继承另一个类的特性</p></li><li><p>类型转换允许你再运行检查和解释一个类实例的类型</p></li><li><p>反初始化器允许一个类实例释放任何其被分配的资源</p></li><li><p>引用计数器允许不止一个类对实例的引用</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习36：函数式编程</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A036%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A036%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="范式转换-函数式"><a href="#范式转换-函数式" class="headerlink" title="范式转换-函数式"></a>范式转换-函数式</h1><p>读入一个文本，确定所有单词的使用频率并从高到低排序，打印出所有单词及其频率的排序列表</p><ul><li><code>命令式编程</code> 风格尝尝迫使我们出于性能考虑，把不同的任务交织起来，以便能够用一次循环来完成多个任务</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">let words = &quot;&quot;&quot;</span><br><span class="line">This rectangle defines the size and position of the view in its superview’s coordinate system.</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">let NON_WORDS = [&quot;e&quot;,&quot;of&quot;,&quot;end&quot;,&quot;on&quot;]</span><br><span class="line"></span><br><span class="line">func wordFrep(words: String) -&gt; [String:Int] &#123;</span><br><span class="line">    var wordDict: [String:Int] = [:]</span><br><span class="line">    // 分割成一个数组</span><br><span class="line">    let wordList = words.split(separator: &quot; &quot;)</span><br><span class="line">    // 遍历数组</span><br><span class="line">    for word in wordList &#123;</span><br><span class="line">        // 数组每个元素转小写</span><br><span class="line">        let lowercaseWord = word.lowercased()</span><br><span class="line">        // 不包含元素</span><br><span class="line">        if !NON_WORDS.contains(lowercaseWord) &#123;</span><br><span class="line">            // 有count</span><br><span class="line">            if let count = wordDict[lowercaseWord] &#123;</span><br><span class="line">                wordDict[lowercaseWord] = count + 1</span><br><span class="line">            &#125;else &#123; // 无count</span><br><span class="line">                wordDict[lowercaseWord] = 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return wordDict</span><br><span class="line">&#125;</span><br><span class="line">print(wordFrep(words:words))</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">[&quot;and&quot;: 1, &quot;superview’s&quot;: 1, &quot;system.&quot;: 1, &quot;view&quot;: 1, &quot;defines&quot;: 1, &quot;its&quot;: 1, &quot;coordinate&quot;: 1, &quot;in&quot;: 1, &quot;the&quot;: 2, &quot;rectangle&quot;: 1, &quot;this&quot;: 1, &quot;size&quot;: 1, &quot;position&quot;: 1]</span><br></pre></td></tr></table></figure></div><ul><li>而 <code>函数式编程</code> 用 <code>map()、filter()</code> 这些高级函数把我们解法出来，让我们站在更高的抽象层次上去考虑问题，把问题看的更清楚</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 函数式写法</span><br><span class="line">func wordFrep2(words: String) -&gt; [String:Int] &#123;</span><br><span class="line">    var wordDict: [String:Int] = [:]</span><br><span class="line">    // 分割成一个数组</span><br><span class="line">    let wordList = words.split(separator: &quot; &quot;)</span><br><span class="line">    // map：尾随闭包的方式</span><br><span class="line">    wordList.map &#123; $0.lowercased() &#125;</span><br><span class="line">        .filter &#123; !NON_WORDS.contains( $0 ) &#125;</span><br><span class="line">        .forEach &#123; wordDict[$0] = (wordDict[$0] ?? 0) + 1 &#125;</span><br><span class="line"></span><br><span class="line">    return wordDict</span><br><span class="line">&#125;</span><br><span class="line">print(wordFrep2(words:words))</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line">[&quot;view&quot;: 1, &quot;its&quot;: 1, &quot;and&quot;: 1, &quot;defines&quot;: 1, &quot;in&quot;: 1, &quot;the&quot;: 2, &quot;size&quot;: 1, &quot;this&quot;: 1, &quot;position&quot;: 1, &quot;coordinate&quot;: 1, &quot;superview’s&quot;: 1, &quot;system.&quot;: 1, &quot;rectangle&quot;: 1]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="函数式编程-简洁"><a href="#函数式编程-简洁" class="headerlink" title="函数式编程-简洁"></a>函数式编程-简洁</h1><ul><li><p>函数式编程简洁，<code>面向对象编程</code> 通过 <code>封装不确定因素</code> 来使代码能够被人理解，<code>函数式编程</code> 通过 <code>尽量减少少不确定因素</code> 来使代码能够被人理解</p></li><li><p>在面向对象的命令式编程语言里，重用的单元是类和类之间沟通用的消息</p></li><li><p>函数式编程语言实现重用的思路很不一样。函数式语言提倡在有限的几种关键数据结果（如：list、set、map）上运用针对这些数据结构高度优化过的操作，以此构建成基本的运转机构。开发者再根据具体用途，插入自己的数据结构和高阶函数去调整机构的运转方式</p></li><li><p>比起以为创建新的类结构体系，把封装的元素降低到函数级别，更有利达到细粒度的、基础层面的重用</p></li><li><p>函数式程序员喜欢用少数几个核心数据结构，围绕它们去建立一套充分优化的运转机构。<br>面向对象程序员喜欢不断的创建新的数据结构和附属的操作，因为压倒一切的面向对象编程范式就是建立新的类和类间的消息。<br>把所有的数据结构封装成类，一方面压制了方法层面的重用，另一方面鼓励了大粒度的框架式重用。<br>函数式编程的程序结构方便我们在比较细小的层面上重用代码</p></li></ul><h1 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h1><ul><li>假设我们有一个名字列表，其中一些条目由单个字符组成。现在的任务是，将除去单字符条目之外的列表内容，放在一个逗号分割的字符串里返回，且每个名字的首字母都要大写</li></ul><h1 id="命令式解法"><a href="#命令式解法" class="headerlink" title="命令式解法"></a>命令式解法</h1><ul><li>命令式编程是按照 <code>程序是一系列改变状态的命名</code> 来建模的一种编程风格。传统的 for 循环是命令式风格的句号例子</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let names = [&quot;neal&quot;,&quot;s&quot;,&quot;stu&quot;,&quot;h&quot;,&quot;rich&quot;]</span><br><span class="line">func cleanNames(names: Array&lt;String&gt;) -&gt; String &#123;</span><br><span class="line">    var cleanedNames = &quot;&quot;</span><br><span class="line">    for name in names &#123;</span><br><span class="line">        if name.count &gt; 1 &#123;</span><br><span class="line">            cleanedNames += name.capitalized + &quot;,&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 去掉最后一个,</span><br><span class="line">    cleanedNames.remove(at: cleanedNames.index(before: cleanedNames.endIndex))</span><br><span class="line">    return cleanedNames</span><br><span class="line">&#125;</span><br><span class="line">print(cleanNames(names: names))</span><br><span class="line"></span><br><span class="line">==========</span><br><span class="line">Neal,Stu,Rich</span><br></pre></td></tr></table></figure></div><h1 id="函数式解法"><a href="#函数式解法" class="headerlink" title="函数式解法"></a>函数式解法</h1><ul><li>函数式编程将程序描述为 <code>表达式和变换</code>，以数学方程的形式建立模型，并且尽量避免可变的状态。</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 函数式解法</span><br><span class="line">let names = [&quot;neal&quot;,&quot;s&quot;,&quot;stu&quot;,&quot;h&quot;,&quot;rich&quot;]</span><br><span class="line">// 过滤</span><br><span class="line">let cleanedNames = names.filter &#123; $0.count &gt; 1 &#125;</span><br><span class="line">print(cleanedNames)</span><br><span class="line">// 首字母大写</span><br><span class="line">let cleanedNames2 = cleanedNames.map &#123; $0.capitalized &#125;</span><br><span class="line">print(cleanedNames2)</span><br><span class="line">// 拼接</span><br><span class="line">let cleanedNames3 = cleanedNames2.joined(separator: &quot;,&quot;)</span><br><span class="line">print(cleanedNames3)</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">[&quot;neal&quot;, &quot;stu&quot;, &quot;rich&quot;]</span><br><span class="line">[&quot;Neal&quot;, &quot;Stu&quot;, &quot;Rich&quot;]</span><br><span class="line">Neal,Stu,Rich</span><br></pre></td></tr></table></figure></div><p>上面的方式还可以简写：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 简写</span><br><span class="line">let cleanedName = names.filter &#123; $0.count &gt; 1 &#125;</span><br><span class="line">    .map &#123; $0.capitalized &#125;</span><br><span class="line">    .joined(separator: &quot;,&quot;)</span><br><span class="line">print(cleanedName)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">Neal,Stu,Rich</span><br></pre></td></tr></table></figure></div><h1 id="具有普遍意义的基本构造单元"><a href="#具有普遍意义的基本构造单元" class="headerlink" title="具有普遍意义的基本构造单元"></a>具有普遍意义的基本构造单元</h1><ul><li><p>筛选：<code>filter</code></p></li><li><p>映射：<code>map</code> </p></li><li><p>折叠&#x2F;化约：<code>foldLeft/reduce</code> 等</p></li></ul><h1 id="swift-的劣势-并行"><a href="#swift-的劣势-并行" class="headerlink" title="swift 的劣势-并行"></a>swift 的劣势-并行</h1><ul><li>不是线程安全的</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 函数式</span><br><span class="line">let names = [&quot;neal&quot;,&quot;s&quot;,&quot;stu&quot;,&quot;h&quot;,&quot;rich&quot;,&quot;ff&quot;,&quot;sag&quot;]</span><br><span class="line">let cleanedName = names.filter &#123; $0.count &gt; 1 &#125;</span><br><span class="line">    .map &#123; $0.capitalized &#125;</span><br><span class="line">    .joined(separator: &quot;,&quot;)</span><br><span class="line">print(cleanedName)</span><br><span class="line"></span><br><span class="line">// 数组的扩展</span><br><span class="line">extension Array where Element : Any &#123;</span><br><span class="line">    // 函数</span><br><span class="line">    public func currentMap&lt;T&gt;(_ transform: (Element) -&gt; T)  -&gt; [T] &#123;</span><br><span class="line">        let n = self.count</span><br><span class="line">        if n == 0 &#123; return [] &#125;</span><br><span class="line">        var result = Array&lt;T&gt;() // 初始化一个数组</span><br><span class="line">        result.reserveCapacity(n)</span><br><span class="line">        DispatchQueue.concurrentPerform(iterations: n) &#123; i in</span><br><span class="line">            result.append(transform(self[i]))</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 并行写法</span><br><span class="line">let cleanedName2 = names.filter &#123; $0.count &gt; 1 &#125;</span><br><span class="line">    .currentMap &#123; $0.capitalized &#125;</span><br><span class="line">    .joined(separator: &quot;,&quot;)</span><br><span class="line">print(cleanedName2)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">Neal,Stu,Rich,Ff,Sag</span><br><span class="line">Stu,Neal,Rich,Ff,Sag</span><br></pre></td></tr></table></figure></div><p>有结果可知：打印的顺序不同，或者会少，说明线程不安全</p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习34：闭包</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A034%EF%BC%9A%E9%97%AD%E5%8C%85/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A034%EF%BC%9A%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包和闭包表达式"><a href="#闭包和闭包表达式" class="headerlink" title="闭包和闭包表达式"></a>闭包和闭包表达式</h1><h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><ul><li><p>闭包是可以在你的代码中被 <code>传递和引用</code> 的功能性独立代码块</p></li><li><p>闭包能够 <code>补获和存储</code> 定义上下文的任何 <code>常量和变量</code>，这就是所谓的闭合并包裹哪些常量和变量，因此成为 <code>闭包</code>，Swift能够为你处理所有关于补获的内存管理操作</p></li><li><p><code>全局和内嵌函数</code>，实际上是 <code>特殊的闭包</code>。闭包符合以下三种形式的一种</p><ul><li><p>全局函数时一个有名字但不会补获任何值的闭包</p></li><li><p>内嵌函数时一个有名字且能从其上下层函数补获值的闭包</p></li><li><p>闭包表达式是一个轻量级语法所写的可 <code>以补获其上下文中常量和变量值</code> 的没有名字的闭包</p></li></ul></li></ul><h2 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h2><ul><li>闭包表达式是一种在简短行内就能写完闭包的语法</li></ul><h2 id="闭包表达式从-sorted-函数说起"><a href="#闭包表达式从-sorted-函数说起" class="headerlink" title="闭包表达式从 sorted 函数说起"></a>闭包表达式从 sorted 函数说起</h2><ul><li>swift标准库提供了一个叫做 <code>sorted(by:)</code> 的方法，会根据你提供的 排序闭包 将已经数组排序，返回一个已排好序的新数组，原数组不会被 <code>sorted(by:)</code> 方法修改</li></ul><p><strong>正序排列</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var newname = name.sorted()</span><br></pre></td></tr></table></figure></div><p><strong>逆序排列</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]</span><br><span class="line">func backward(_ s1:String,_ s2:String) -&gt; Bool &#123;</span><br><span class="line">    return s1 &gt; s2</span><br><span class="line">&#125;</span><br><span class="line">var newname = name.sorted(by: backward)</span><br><span class="line">print(&quot;\(name) , \(newname)&quot;)</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">[&quot;a&quot;, &quot;bb&quot;, &quot;c&quot;, &quot;ddd&quot;] , [&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure></div><h2 id="闭包表达式语法"><a href="#闭包表达式语法" class="headerlink" title="闭包表达式语法"></a>闭包表达式语法</h2><ul><li><p>闭包表达式语法能够使用 <code>常量形式参数、变量形式参数和输入输出形式参数</code>，但不能提供默认值。</p></li><li><p>可变形式参数也能使用，需要在形式参数列表的最后面使用</p></li><li><p>元组也可被用来作为形式参数和返回类型</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; (return type) in</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>将之前 <code>backward(::)</code> 函数改为闭包表达式</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]</span><br><span class="line">var newname = name.sorted(by: &#123; (s1: String,s2: String) -&gt; Bool in</span><br><span class="line">    return s1 &gt; s2</span><br><span class="line">&#125;)</span><br><span class="line">print(&quot;\(name) , \(newname)&quot;)</span><br><span class="line"></span><br><span class="line">===========</span><br><span class="line">[&quot;a&quot;, &quot;bb&quot;, &quot;c&quot;, &quot;ddd&quot;] , [&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure></div><h2 id="从语境中推断类型"><a href="#从语境中推断类型" class="headerlink" title="从语境中推断类型"></a>从语境中推断类型</h2><ul><li><p>排序闭包为实际参数来传递给函数，swift能推断它的形式参数类型和返回类型</p></li><li><p>可以省略 形式参数、括号、返回箭头</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]</span><br><span class="line">var newname = name.sorted(by: &#123; s1,s2 in return s1 &gt; s2 &#125;)</span><br><span class="line">print(&quot;\(newname)&quot;)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">[&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure></div><h2 id="但表达式闭包隐士返回"><a href="#但表达式闭包隐士返回" class="headerlink" title="但表达式闭包隐士返回"></a>但表达式闭包隐士返回</h2><ul><li>但表达式闭包能够通过从它们声明中删掉 <code>return</code> 关键字来隐士返回它们单个表达式的结果</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]</span><br><span class="line">var newname = name.sorted(by: &#123; s1,s2 in s1 &gt; s2 &#125;)</span><br><span class="line">print(&quot;\(newname)&quot;)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">[&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure></div><h2 id="简写实际参数名"><a href="#简写实际参数名" class="headerlink" title="简写实际参数名"></a>简写实际参数名</h2><ul><li><code>swift</code> 自动对行内闭包提供简写实际参数，可以通过 <code>$0,$1,$2</code> 等名字来引用闭包的 <code>实际参数</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]</span><br><span class="line">var newname = name.sorted(by: &#123; $0 &gt; $1 &#125;)</span><br><span class="line">print(&quot;\(newname)&quot;)</span><br><span class="line"></span><br><span class="line">==========</span><br><span class="line">[&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure></div><h2 id="运算符函数"><a href="#运算符函数" class="headerlink" title="运算符函数"></a>运算符函数</h2><ul><li>swift 的 <code>string</code> 类型定义了关于大于号 <code>&gt;</code> 的特定类型字符串实现，让其作为一个有两个 <code>string</code> 类型形式参数的函数并返回一个 <code>bool</code> 类型的值。正好 <code>soreted(by:)</code> 方法的形式参数需要的函数相匹配。因此你可以简单的传入一个 <code>&gt;</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]</span><br><span class="line">var newname = name.sorted(by: &gt;)</span><br><span class="line">print(&quot;\(newname)&quot;)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">[&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure></div><h2 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h2><ul><li><p>如果你需要一个 <code>很长的闭包表达式</code> 作为 <code>函数最后一个实际参数</code> 传递给函数，使用尾随闭包将增强函数的可读性。</p></li><li><p><code>尾随闭包</code> 是一个被 <code>写在函数形式参数的括号后面</code> 的闭包表达式</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name = [&quot;a&quot;,&quot;bb&quot;,&quot;c&quot;,&quot;ddd&quot;]</span><br><span class="line">var newname = name.sorted&#123; $0 &gt; $1&#125;</span><br><span class="line">print(&quot;\(newname)&quot;)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">[&quot;ddd&quot;, &quot;c&quot;, &quot;bb&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure></div><h1 id="闭包捕获值"><a href="#闭包捕获值" class="headerlink" title="闭包捕获值"></a>闭包捕获值</h1><h2 id="捕获值"><a href="#捕获值" class="headerlink" title="捕获值"></a>捕获值</h2><ul><li>一个闭包能够 <code>从上下文捕获已被定义的常量和变量</code>。即使定义这些常量和变量的原作用域已经不存在，闭包仍能在其函数体内引用和修改这些值</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int &#123;</span><br><span class="line">    var runningTotal = 0</span><br><span class="line">    func incrementor() -&gt; Int &#123;</span><br><span class="line">        runningTotal += amount</span><br><span class="line">        return runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    return incrementor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>作为一种优化，如果一个值没有改变或在闭包外面，swift可能会使用这个值的 <code>拷贝</code> 而 <code>不是捕获</code></li></ul><p>如果 <code>runningTotal</code> 没有在闭包里使用或改变，则是 拷贝</p><ul><li>swift也处理了变量的内存管理操作，当变量不再需要时会被释放</li></ul><h2 id="闭包是引用类型"><a href="#闭包是引用类型" class="headerlink" title="闭包是引用类型"></a>闭包是引用类型</h2><ul><li><p>在swift中，<code>函数和闭包都是引用类型</code></p></li><li><p>无论是什么时候赋值给 <code>函数或闭包</code> 一个 <code>常量或变量</code>，实际上都是将常量和变量设置为对函数和闭包的 <code>引用</code></p></li><li><p>如果你分配了一个闭包给类实例的属性，并且闭包通过引用该实例或者它的成员来捕获实例，你将在闭包和实例间会产生 <code>循环引用</code></p></li></ul><h2 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h2><ul><li><p>当闭包作为一个实际参数传递给一个函数时，它会在 <code>函数返回之后调用</code>，我们就说这个 <code>闭包逃逸了</code>。当你声明一个接收闭包作为形式参数的函数时， 你可以在形式参数前加 <code>@escaping</code> 来明确闭包是允许逃逸的</p></li><li><p>闭包可以逃逸的一种方法是 <code>被存储在定义函数外的变量里</code>。比如说，很多函数接收闭包实际参数来作为启动异步任务的回调。函数在启动任务后返回，但是闭包要直到任务完成—闭包需要逃逸，以便稍后调用。一般是网络请求成功或失败使用 <code>逃逸闭包</code></p></li><li><p>让闭包 <code>@escaping</code> 你必须在闭包中显示的使用 <code>self</code></p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303051414381.png"                                     ></p><h2 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h2><ul><li><p>通过 <code>@autoclosure</code> 标志标记它的形式是使用了自动闭包。现在你调用函数就像它接受了一个 <code>String</code> 类型的实际参数而不是闭包。实际参数自动地转换为闭包。</p></li><li><p>可以将一个 <code>表达式 </code>直接传递给 <code>@autoclosure自动闭包</code></p></li><li><p>自动闭包是一种自动创建的用来把作为实际参数传递给函数的表达式的闭包。它不接受任何实际参数，并且当它被调用时，它会返回内部打包的表达式的值。这个语法的好处在于通过写普通表达式代替显示闭包而使你 <code>省略</code> 包围 <code>函数形式参数</code> 的括号<code>()</code></p></li><li><p>自动闭包允许你 <code>延迟执行</code>，因此闭包内部的代码直到你调用时才会运行。对于有副作用或者占用资源的代码来说很有用，因为它可以允许你控制代码何时才进行求值</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 自动闭包</span><br><span class="line">var custom = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;];</span><br><span class="line">print(custom.count)</span><br><span class="line"></span><br><span class="line">let customPro = &#123; custom.remove(at: 0)&#125;</span><br><span class="line">print(custom.count)</span><br><span class="line"></span><br><span class="line">// 调用才求值</span><br><span class="line">print(&quot;new \(customPro())&quot;)</span><br><span class="line">print(custom.count)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">new a</span><br><span class="line">3</span><br></pre></td></tr></table></figure></div><h2 id="自动-逃逸"><a href="#自动-逃逸" class="headerlink" title="自动 + 逃逸"></a>自动 + 逃逸</h2><ul><li>如果你想要自动闭包允许逃逸，就同时使用 <code>@autoclosure</code> 和 <code>@escaping</code> 标志</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 自动+逃逸</span><br><span class="line">var names = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]</span><br><span class="line">var providers:[() -&gt; String] = []</span><br><span class="line">func collectCustomsProviders(provider: @escaping () -&gt; String) &#123;</span><br><span class="line">    providers.append(provider )</span><br><span class="line">&#125;</span><br><span class="line">// 表达式 name.remove(at:0) String</span><br><span class="line">collectCustomsProviders(provider:names.remove(at: 0))</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">报错</span><br></pre></td></tr></table></figure></div><p>不能直接给 <code>闭包</code> 传递表达式，需要添加 <code>@autoclosure</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303051423190.png"                                     ></p><p>正确的写法</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 自动+逃逸</span><br><span class="line">var names = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]</span><br><span class="line">var providers:[() -&gt; String] = []</span><br><span class="line">func collectCustomsProviders(provider: @autoclosure @escaping () -&gt; String) &#123;</span><br><span class="line">    providers.append(provider )</span><br><span class="line">&#125;</span><br><span class="line">// 表达式 name.remove(at:0) String</span><br><span class="line">collectCustomsProviders(provider:names.remove(at: 0))</span><br><span class="line">collectCustomsProviders(provider:names.remove(at: 0))</span><br><span class="line">// 实际上逃逸闭包</span><br><span class="line">print(names.count)</span><br><span class="line"></span><br><span class="line">for provide in providers &#123;</span><br><span class="line">    print(provide())</span><br><span class="line">&#125;</span><br><span class="line">print(names.count)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习33：函数</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A033%EF%BC%9A%E5%87%BD%E6%95%B0/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A033%EF%BC%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Swift中如何定义和使用函数"><a href="#Swift中如何定义和使用函数" class="headerlink" title="Swift中如何定义和使用函数"></a>Swift中如何定义和使用函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p><code>函数是一个独立的代码块，用来执行特定的任务</code>。通过给函数一个名字来定义它的功能，并且在需要的时候，通过这个名字来 <code>调用</code> 函数执行它的任务</p></li><li><p><code>Swift统一的函数语法十分灵活</code>。可以从简单的无形式参数到复杂的每个形式参数都带有局部和外部形式参数名。形式参数提供一个默认值来简化函数的调用，可被当做输入输出形式参数被传递，在函数执行完成时修改传递进来的变量。</p></li><li><p><code>Swift中每一个函数都有类型，由函数的形式参数类型和返回类型组成</code> 。可以像swift中其它类型来使用它。可以将函数当一个形式参数传递到另外一个函数中。也可以在一个函数中返回另一个函数。同时也可以写在其他函数内部在内嵌范围封装有用的功能。</p></li><li><p>函数是 <code>引用类型</code> 的，不是值类型的</p></li></ul><h2 id="定义和调用函数"><a href="#定义和调用函数" class="headerlink" title="定义和调用函数"></a>定义和调用函数</h2><ul><li><p>当你定义一个函数时，可以 选择定义一个或多个形式参数类型，也可以定义返回类型</p></li><li><p>每个函数都有函数名，藐视执行的任务。</p></li><li><p>使用函数可通过 <code>函数名</code> 并且 <code>传入</code> 函数的 <code>实际参数</code> （即形式参数类型的输入值 ）来 <code>调用函数</code>。</p></li><li><p>实际参数顺序必须符合形式参数的列表顺序</p></li></ul><h2 id="无形式参数的函数"><a href="#无形式参数的函数" class="headerlink" title="无形式参数的函数"></a>无形式参数的函数</h2><ul><li><p>函数不要求必须传入一个参数，可以没有形式参数</p></li><li><p>函数定义需要在名字的后面加一个圆括号，即使没有形式参数也得加</p></li><li><p>调用函数的时候也要在函数的名字后面加一个圆括号</p></li></ul><h2 id="多形式参数的函数"><a href="#多形式参数的函数" class="headerlink" title="多形式参数的函数"></a>多形式参数的函数</h2><ul><li>函数可以输入多个形式参数，写在圆括号内，用逗号分割</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func manyPara(a:Int,b:Int) &#123;</span><br><span class="line">    pring(&quot;\(a) \(b)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="无返回值的函数"><a href="#无返回值的函数" class="headerlink" title="无返回值的函数"></a>无返回值的函数</h2><ul><li><p>函数定义可以没有返回类型，即没有返回箭头 -&gt; 或返回类型</p></li><li><p>严格上，函数还是有一个返回类型的，尽管没有定义返回值，实际上返回一个特殊的类型 <code>void</code>。它是一个空的元组，作用相当于没有元素的元组，写作()</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func manyTuple() -&gt; void &#123;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="多返回值的函数"><a href="#多返回值的函数" class="headerlink" title="多返回值的函数"></a>多返回值的函数</h2><ul><li>可以让函数返回多个值作为一个复合的返回值，你可以使用元组类型作为返回类型</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func manyTuple() -&gt; (a:Int,b:String) &#123;</span><br><span class="line">    return (1,&quot;aaa&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="可选元组返回类型"><a href="#可选元组返回类型" class="headerlink" title="可选元组返回类型"></a>可选元组返回类型</h2><ul><li><p>如果在函数返回类型中元组可能 <code>没有值</code>，可以用可选元组说明元组可能是 <code>nil</code></p></li><li><p>写法是可选元组圆括号后面加一个问号 <code>？</code>，例如 (Int,Int)? 或 (String,Int,Bool)?</p></li></ul><p>示例：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 返回元组</span><br><span class="line">func minMax(arr: [Int]) -&gt; (min:Int,max:Int)? &#123;</span><br><span class="line">    if arr.isEmpty &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    var minValue = arr[0]</span><br><span class="line">    var maxValue = arr[0]</span><br><span class="line">    for value in arr &#123;</span><br><span class="line">        if value &lt; minValue &#123;</span><br><span class="line">            minValue = value</span><br><span class="line">        &#125;</span><br><span class="line">        if value &gt; maxValue &#123;</span><br><span class="line">            maxValue = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (minValue,maxValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 绑定</span><br><span class="line">if let minMaxValue = minMax(arr: [1,3,4,2,5]) &#123;</span><br><span class="line">    print(&quot;min is \(minMaxValue.min),max is \(minMaxValue.max)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>编译运行，查看打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min is 1,max is 5</span><br></pre></td></tr></table></figure></div><h2 id="隐士返回函数"><a href="#隐士返回函数" class="headerlink" title="隐士返回函数"></a>隐士返回函数</h2><ul><li>如果整个函数体是一个单一的表达式，那么函数隐士返回这个表达式</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func greet(person: String) -&gt; String&#123;</span><br><span class="line">    &quot;Hello,&quot; + person + &quot;!&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;\(greet(person: &quot;World&quot;))&quot;)</span><br></pre></td></tr></table></figure></div><p>打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello,World!</span><br></pre></td></tr></table></figure></div><h1 id="Swift形式参数和返回值"><a href="#Swift形式参数和返回值" class="headerlink" title="Swift形式参数和返回值"></a>Swift形式参数和返回值</h1><h2 id="实参标签和形参名"><a href="#实参标签和形参名" class="headerlink" title="实参标签和形参名"></a>实参标签和形参名</h2><ul><li><p>每一个函数的形式参数都包含实际参数标签和形式参数名。</p></li><li><p>形式参数必须有唯一的名字，有助于代码易读</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func someFunc(firstParamName:Int,secondParamName:Int)&#123;</span><br><span class="line">    // 形式参数 firstParamName secondParamName</span><br><span class="line">&#125;</span><br><span class="line">someFunc(firstParamName: 1, secondParamName: 2)</span><br></pre></td></tr></table></figure></div><h2 id="指定实际参数标签"><a href="#指定实际参数标签" class="headerlink" title="指定实际参数标签"></a>指定实际参数标签</h2><ul><li><p>形式参数名之前写实际参数标签，用 <code>空格</code> 分割</p></li><li><p>如果你为 <code>形式参数</code> 定义了 <code>实际参数标签</code>，那么在调用函数的时候必须使用 <code>实际参数标签</code></p></li><li><p>实际参数标签能够让函数的调用更加明确，更像自然语言，更可读，更清晰表达你的意图</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 实际参数标签 home</span><br><span class="line">func greet(person: String, from home: String) -&gt; String &#123;</span><br><span class="line">    return &quot;Hello \(person)! my home is \(home)&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(greet(person: &quot;ZJ&quot;,from: &quot;BeiJing&quot;))</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello ZJ! my home is BeiJing</span><br></pre></td></tr></table></figure></div><h2 id="省略实际参数标签"><a href="#省略实际参数标签" class="headerlink" title="省略实际参数标签"></a>省略实际参数标签</h2><ul><li>可以利用下划线 <code>_</code> 替代显示的实际参数标签</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func greet(_ person: String, _ home: String) -&gt; String &#123;</span><br><span class="line">    return &quot;Hello \(person)! my home is \(home)&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(greet(person: &quot;ZJ&quot;,from: &quot;BeiJing&quot;))</span><br></pre></td></tr></table></figure></div><h2 id="默认形式参数值"><a href="#默认形式参数值" class="headerlink" title="默认形式参数值"></a>默认形式参数值</h2><ul><li><p>可以在形式参数类型后，给类型定义一个默认值</p></li><li><p>如果定义了默认值，你就可以在调用的时候省略这个形式参数</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func someFunc(paramDefault: Int = 10) &#123;</span><br><span class="line">    print(&quot;\(paramDefault)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">someFunc(paramDefault: 6)</span><br><span class="line">someFunc()</span><br><span class="line"></span><br><span class="line">===========</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure></div><h2 id="可变形式参数"><a href="#可变形式参数" class="headerlink" title="可变形式参数"></a>可变形式参数</h2><ul><li><p>一个可变的形式参数可以接受零或多个特定类型的值。</p></li><li><p>通过在形式参数类型名后插入三个点符号 <code>...</code> 来书写可变形式参数。</p></li><li><p>传入到可变参数中的值在函数的主体中被当做是对应类型的 <code>数组</code>。</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func changeFunc(_ numbers: Double...) -&gt; Double &#123;</span><br><span class="line">    var total: Double = 0</span><br><span class="line">    for number in numbers &#123;</span><br><span class="line">        total += number</span><br><span class="line">    &#125;</span><br><span class="line">    return total / Double(numbers.count)</span><br><span class="line">&#125;</span><br><span class="line">changeFunc(1,2,3,4,5)</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line">3</span><br></pre></td></tr></table></figure></div><h2 id="输入输出形式参数"><a href="#输入输出形式参数" class="headerlink" title="输入输出形式参数"></a>输入输出形式参数</h2><ul><li><p>可变形式参数只能在函数的内部做改变。如果你想函数能修改一个形式参数的值，而且这些改变在函数结束之后依然生效，那么就需要将形式参数定义为输入输出形式参数</p></li><li><p>输入输出形式参数：在形式参数前边加 <code>inout</code> 关键字。</p></li><li><p>只能把 <code>变量</code> 作为输入输出形式参数的 <code>实际参数</code>，在将变量作为实际参数传入给输入输出形式参数时，在它前边添加一个符号 <code>&amp;</code> 来明确可以被函数修改</p></li><li><p>输入输出形式参数不能有默认值，可变形式参数不能被标记为 <code>inout</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 输入输出形式参数</span><br><span class="line">func swapTwoInt(_ a: inout Int, _ b: inout Int) &#123;</span><br><span class="line">    let temp = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temp</span><br><span class="line">&#125;</span><br><span class="line">var one = 10</span><br><span class="line">var two = 20</span><br><span class="line">swapTwoInt(&amp;one,&amp;two)</span><br><span class="line">print(&quot;\(one) \(two)&quot;)</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">20 10</span><br></pre></td></tr></table></figure></div><h1 id="函数类型和内嵌函数"><a href="#函数类型和内嵌函数" class="headerlink" title="函数类型和内嵌函数"></a>函数类型和内嵌函数</h1><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><ul><li>每一个函数都有一个特定的函数类型，它由形式参数类型，返回类型组成</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func addTwo(_ a:Int,_ b:Int) -&gt; Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line">let c = addTwo(1,2)</span><br><span class="line">print(&quot;\(c)&quot;)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">3</span><br></pre></td></tr></table></figure></div><p>和 (Int,Int) -&gt; Int 相关</p><h2 id="使用函数类型"><a href="#使用函数类型" class="headerlink" title="使用函数类型"></a>使用函数类型</h2><ul><li>你可以像使用Swift中的其他类型一样使用函数类型。例如：你可一个常量或变量定义一个函数类型，并且未变量指定一个相应的函数</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func addTwo(_ a:inout Int,_ b:inout Int) -&gt; Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line">var mathFunc:(inout Int,inout Int) -&gt; Int = addTwo</span><br><span class="line">print(mathFunc(2,3))</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">5</span><br></pre></td></tr></table></figure></div><h2 id="函数类型作为形式参数类型"><a href="#函数类型作为形式参数类型" class="headerlink" title="函数类型作为形式参数类型"></a>函数类型作为形式参数类型</h2><ul><li>你可以将 <code>函数</code> 作为 <code>其他函数的形式参数</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func addTwo(_ a:Int,_ b:Int) -&gt; Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line">func printResult(_ mathFunc:(Int,Int) -&gt; Int,_ a:Int,_ b:Int) &#123;</span><br><span class="line">    print(&quot;Result:\(mathFunc(a,b))&quot;)</span><br><span class="line">&#125;</span><br><span class="line">printResult(addTwo,2,3)</span><br><span class="line"></span><br><span class="line">==========</span><br><span class="line">5</span><br></pre></td></tr></table></figure></div><h2 id="函数类型作为返回类型"><a href="#函数类型作为返回类型" class="headerlink" title="函数类型作为返回类型"></a>函数类型作为返回类型</h2><ul><li>可以利用函数的类型作为另一个函数的返回类型。写法在函数的返回箭头后写一个完整的函数类型</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func backF(_ input:Int) -&gt; Int&#123;</span><br><span class="line">    return input - 1</span><br><span class="line">&#125;</span><br><span class="line">func chooseFunc(back: Bool) -&gt; (Int) -&gt; Int &#123;</span><br><span class="line">    return backF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="内嵌函数"><a href="#内嵌函数" class="headerlink" title="内嵌函数"></a>内嵌函数</h1><ul><li><p>可以在函数内定义另外一个函数。这就是内嵌函数</p></li><li><p>内嵌函数默认是被隐藏起来的，但仍然可以通过包裹他们的函数来调用他们。</p></li><li><p>包裹的函数也可以返回它内部的一个内嵌函数来在另外的返回里使用</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func chooseFunc(back: Bool) -&gt; (Int) -&gt; Int &#123;</span><br><span class="line">    func stepForward(step:Int) -&gt; Int &#123; return step + 1&#125;</span><br><span class="line">    func stepBackward(step:Int) -&gt; Int &#123; return step - 1&#125;</span><br><span class="line">    return back ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br><span class="line">var current = -4</span><br><span class="line">let stepFunc = chooseFunc(back: current &gt; 0)</span><br><span class="line">while current != 0 &#123;</span><br><span class="line">    current = stepFunc(current)</span><br><span class="line">&#125;</span><br><span class="line">print(current)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">0</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习32：Dictionary字典底层实现探索</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A032%EF%BC%9ADictionary%E5%AD%97%E5%85%B8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A032%EF%BC%9ADictionary%E5%AD%97%E5%85%B8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习32：Dictionary字典</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A032%EF%BC%9ADictionary%E5%AD%97%E5%85%B8/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A032%EF%BC%9ADictionary%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习31：Set底层实现探究</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A031%EF%BC%9ASet%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%A9%B6/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A031%EF%BC%9ASet%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习30：Set集合</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A030%EF%BC%9ASet%E9%9B%86%E5%90%88/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A030%EF%BC%9ASet%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习29：如何用数组来实现栈和队列</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A029%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A029%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习28：数组的底层实现</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A028%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A028%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习27：访问和操作数组</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A027%EF%BC%9A%E8%AE%BF%E9%97%AE%E5%92%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A027%EF%BC%9A%E8%AE%BF%E9%97%AE%E5%92%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习26：创建数组的几种方式</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A026%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A026%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OC三方框架01：bugly搜集Crash</title>
      <link href="/BboyZJ.github.io/2023/03/03/OC%E4%B8%89%E6%96%B9%E5%BA%93/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B601%EF%BC%9Abugly%E6%90%9C%E9%9B%86Crash/"/>
      <url>/BboyZJ.github.io/2023/03/03/OC%E4%B8%89%E6%96%B9%E5%BA%93/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B601%EF%BC%9Abugly%E6%90%9C%E9%9B%86Crash/</url>
      
        <content type="html"><![CDATA[<h1 id="Bugly-介绍"><a href="#Bugly-介绍" class="headerlink" title="Bugly 介绍"></a>Bugly 介绍</h1><p>为了能够快速并准确的定位用户 <code>App</code> 发生 <code>Crash</code> 的代码位置，<code>Bugly</code> 使用 <code>符号表文件</code> 对发生 <code>Crash</code> 的程序 <code>堆栈</code> 进行 <code>解析和还原</code></p><p>举例：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031701073.png"                                     ></p><h1 id="Bugly-上传方式"><a href="#Bugly-上传方式" class="headerlink" title="Bugly 上传方式"></a>Bugly 上传方式</h1><ul><li><p><code>Bugly</code> 已不再支持直接上传dSYM文件，需要 <code>下载工具包手动上传</code></p></li><li><p>本文主要介绍 <code>下载工具包手动上传</code></p></li></ul><h1 id="安装java运行环境"><a href="#安装java运行环境" class="headerlink" title="安装java运行环境"></a>安装java运行环境</h1><ul><li>终端查看是否已安装</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhangjian@zhangjiandeMBP ~ % java -version</span><br><span class="line">java version &quot;1.8.0_291&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_291-b10)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.291-b10, mixed mode)</span><br></pre></td></tr></table></figure></div><p>上面的显示表示已安装</p><ul><li>未安装的情况如下：</li></ul><p>到 <a class="link"   href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" >Java官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 下载 <code>jdk</code>，如下图：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031621953.png"                                     ></p><p>下载完成之后打开 <code>dmg</code>，安装、一路下一步即可安装成功。</p><p>在终端输入 <code>java -version</code> 可以查看 <code>java</code> 版本，如果输出信息和上面类似，表示安装成功</p><h1 id="获取-dSYM-文件"><a href="#获取-dSYM-文件" class="headerlink" title="获取 dSYM 文件"></a>获取 <code>dSYM</code> 文件</h1><ul><li><p>什么是 <code>dSYM</code> 文件？</p><ul><li><p>在 <code>iOS</code> 平台中，dSYM文件是指 <code>具有调试信息的目标文件</code>，文件名通常为 <code>xxx.app.dSYM</code></p></li><li><p>【注】：为了方便找回 <code>Crash</code> 对应的 <code>dSYM文件</code> 和 <code>还原堆栈</code>，建议每次 <code>构建或发布App版本</code> 时，备份好 <code>dSYM文件</code></p></li></ul></li><li><p>获取 <code>dSYM</code> 方式</p></li></ul><p>我们可以配置 <code>Edit Scheme -&gt; Archives</code> 打包 <code>Debug</code> 和 <code>Release</code> 两种环境，去获取 <code>dSYM文件</code>，本文以 <code>Release</code> 发布环境为例</p><ul><li>配置打包环境 <code>Release</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031812947.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031812648.png"                                     ></p><ul><li>Show in Finder -&gt; 显示包内容，找到 <code>dSYM文件</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16778361825767.jpg"                                     ></p><ul><li>最后，在桌面或任意位置，新建一个文件夹如 <code>appdSYM</code> ，将 <code>xxx.app.dSYM</code> 拷贝进来</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031739055.png"                                     ></p><p>至此，获取 <code>dSYM文件</code> 完成</p><h1 id="工具手动上传符号表"><a href="#工具手动上传符号表" class="headerlink" title="工具手动上传符号表"></a>工具手动上传符号表</h1><ul><li>下载 <code>Bugly</code>  iOS <a class="link"   href="https://bugly.qq.com/v2/downloads" >符号表 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 上传工具，如下图：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031923224.png"                                     ></p><ul><li>我们需要用到的是 <code>buglySymboliOS.jar</code> 文件，单独放在一个新建的空文件夹如 <code>buglySymboliOS</code> 里面</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031813454.png"                                     ></p><ul><li>下载后得到 <code>buglyqq-upload-symbol</code> 文件，解压里面 <code>jar包</code>，得到 <code>buglySymboliOS.jar 包</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16778418003131.jpg"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16778418971136.jpg"                                     ></p><ul><li>通过终端命令行上传</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar buglyqq-upload-symbol.jar -appid c4f4e4dc67 -appkey cb791b15-dbe1-44d9-bd33-b3fe558b773b -bundleid cn.epod.srsf -version 1.6.2 -platform IOS -inputSymbol /Users/mac/Desktop/appdSYM/中图云书房.app.dSYM</span><br></pre></td></tr></table></figure></div><p>【参数说明】：</p><p>-addid ：在 bugly 上对应的 appid     c4f4e4dc67<br>-appkey ：在 bugly 上对应的 appkey<br>-bundleid ： iOS平台的 bundle id    cn.epod.srsf<br>-version ：版本号  1.6.2<br>-platform ：平台（注意大小写）IOS Android<br>-inputSymbol ：dSYM调试文件 &#x2F;Users&#x2F;mac&#x2F;Desktop&#x2F;appdSYM&#x2F;中图云书房.app.dSYM</p><h1 id="项目中使用"><a href="#项目中使用" class="headerlink" title="项目中使用"></a>项目中使用</h1><ul><li>项目需要集成cocoapods三方依赖管理工具，用cocoapods集成 <code>Bugly</code> SDK</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#x27;9.0&#x27;</span><br><span class="line"></span><br><span class="line"># 忽略所有警告</span><br><span class="line">inhibit_all_warnings!</span><br><span class="line"></span><br><span class="line">target &#x27;SRSF&#x27; do</span><br><span class="line">  # Comment the next line if you don&#x27;t want to use dynamic frameworks</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  # Pods for SRSF</span><br><span class="line">  # 官方提示：三方动态库最好最多是6个</span><br><span class="line">  </span><br><span class="line">  # Bugly</span><br><span class="line">  pod &#x27;Bugly&#x27;</span><br><span class="line">  </span><br><span class="line">  target &#x27;SRSFTests&#x27; do</span><br><span class="line">    inherit! :search_paths</span><br><span class="line">    # Pods for testing</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  target &#x27;SRSFUITests&#x27; do</span><br><span class="line">    # Pods for testing</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></div><ul><li>使用</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -Bugly</span><br><span class="line">- (void)startBugly&#123;</span><br><span class="line">    BuglyConfig * config = [[BuglyConfig alloc] init];</span><br><span class="line">    config.debugMode = YES; // Debug信息开关</span><br><span class="line">    config.reportLogLevel = BuglyLogLevelWarn; // 设置为BuglyLogLevelWarn，则在崩溃时会上报Warn、Error接口打印的日志</span><br><span class="line">    [Bugly startWithAppId:@&quot;AppId&quot; config:config];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-三方框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能优化02：卡顿检测</title>
      <link href="/BboyZJ.github.io/2023/03/02/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602%EF%BC%9A%E5%8D%A1%E9%A1%BF%E6%A3%80%E6%B5%8B/"/>
      <url>/BboyZJ.github.io/2023/03/02/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602%EF%BC%9A%E5%8D%A1%E9%A1%BF%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>性能优化01：内存泄漏检测</title>
      <link href="/BboyZJ.github.io/2023/03/02/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B/"/>
      <url>/BboyZJ.github.io/2023/03/02/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OC学习03：内存管理</title>
      <link href="/BboyZJ.github.io/2023/03/02/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A003%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/BboyZJ.github.io/2023/03/02/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A003%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要介绍 <code>内存的五大区</code> 、<code>函数栈</code> 和 <code>内存管理</code></p><h1 id="内存五大区"><a href="#内存五大区" class="headerlink" title="内存五大区"></a>内存五大区</h1><p>在iOS中，内存主要分为 <code>栈区、堆区、全局区、常量区、代码区</code> 五个区域，如下图所示：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021853105.png"                                     ></p><h2 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h2><p><strong>定义</strong></p><ul><li><p>栈是 <code>系统数据结构</code>，其对应的 <code>进程或者线程是唯一的</code></p></li><li><p>栈是 <code>向低地址扩展</code> 的数据结构</p></li><li><p>栈是一块 <code>连续的内存区域</code>，遵循 <code>先进后出（FILO）</code> 原则</p></li><li><p>栈区一般在 <code>运行时</code> 分配</p></li></ul><p><strong>存储</strong></p><p>栈区是由 <code>编译器自动分配并释放</code>的，主要用来存储</p><ul><li><p><code>局部变量</code></p></li><li><p><code>函数的参数</code>，例如函数的隐藏参数（id self, SEL _cmd）</p></li></ul><p><strong>优缺点</strong></p><ul><li><p>优点：因为栈是由 <code>编译器自动分配并释放</code> 的，不会产生内存碎片，所以 <code>快速高效</code></p></li><li><p>确定：栈的 <code>内存大小有限制，数据不灵活</code></p><ul><li><code>iOS主线程大小是1MB</code></li><li>其他线程是 <code>512KB</code></li><li><code>MAC</code> 只有 <code>8MB</code></li></ul></li></ul><p>以上内存大小的说明，在<a class="link"   href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW7" >Threading Programming Guide <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中有相关说明，如下图：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021857274.png"                                     ></p><h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><p><strong>定义</strong></p><ul><li><p>堆是 <code>向高地址扩展</code> 的数据结构</p></li><li><p>堆是 <code>不连续的内存区域</code>，类似于 <code>链表结构</code>（便于增删，不便于查询），遵循 <code>先进先出（FIFO）</code>原则</p></li><li><p>堆的 <code>地址空间</code> 在iOS中是是动态的</p></li><li><p>堆区的分配一般是以在 <code>运行时分配</code></p></li></ul><p><strong>存储</strong></p><p>堆区是 <code>由程序员动态分配和释放</code> 的，如果程序员不释放，程序结束后，可能由操作系统回收，主要用于存放：</p><ul><li><p><code>OC</code> 中使用 <code>alloc</code> 、 <code>new</code> 开辟空间创建 <code>对象</code> ，或者 <code>block经过copy后</code> </p></li><li><p><code>C</code> 语言中使用 <code>malloc、calloc、realloc</code> 分配的空间，需要 <code>free</code> 释放</p></li><li><p>一般一个 <code>new/alloc</code> 就要对应一个 <code>release</code>，在 <code>ARC</code> 下编译器会自动在合适位置为 <code>OC</code> 对象添加 <code>release</code> 操作，会在当前 <code>线程Runloop退出或休眠时销毁这些对象</code>。<code>MRC</code> 则需程序员手动释放。</p></li></ul><p><strong>优缺点</strong></p><ul><li><p>优点：灵活方便，数据适应面广泛</p></li><li><p>缺点：需 <code>手动管理、速度慢</code>，容易产生内存碎片</p></li></ul><p>当需要访问堆中数据时，一般需要 <code>先通过对象读取到栈区的指针地址</code>，然后通过 <code>指针地址访问堆区</code></p><h2 id="全局区（静态区，即-bss-amp-data）"><a href="#全局区（静态区，即-bss-amp-data）" class="headerlink" title="全局区（静态区，即.bss &amp; .data）"></a>全局区（静态区，即.bss &amp; .data）</h2><p>全局区是 <code>编译时分配</code> 的内存空间，在程序运行过程中，此内存中的数据一直存在，<code>程序结束后由系统释放</code>，主要存放：</p><ul><li><p><code>未初始化的全局变量和静态变量</code>，即BSS区（.bss）</p></li><li><p><code>已初始化的全局变量和静态变量</code>，即DATA区（.data）</p></li></ul><p>其中，<code>全局变量</code> 是指变量值可以在 <code>运行时被动态修改</code>，而 <code>静态变量</code> 是 <code>static</code> 修饰的变量，包含 <code>静态局部变量</code> 和 <code>静态全局变量</code></p><h2 id="常量区（即-rodata）"><a href="#常量区（即-rodata）" class="headerlink" title="常量区（即.rodata）"></a>常量区（即.rodata）</h2><p>常量区是 <code>编译时分配</code> 的内存空间，在 <code>程序结束后由系统释放</code>，主要存放：</p><ul><li>已经使用了的，且没有指向的 <code>字符串常量</code></li></ul><p>字符串常量因为可能在程序中被多次使用，所以在程序运行之前就会提前分配内存</p><h2 id="代码区（即-text）"><a href="#代码区（即-text）" class="headerlink" title="代码区（即.text）"></a>代码区（即.text）</h2><p>代码区是 <code>由编译时分配</code>，主要用于存放 <code>程序运行时的代码</code>，代码会被编译成 <code>二进制存进内存</code> 的</p><h2 id="内存五大区验证"><a href="#内存五大区验证" class="headerlink" title="内存五大区验证"></a>内存五大区验证</h2><p>运行下面的一段代码，看看变量在内存中是如何分配的：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a = 10; // 全局区（已初始化的全局变量）</span><br><span class="line">char * b; // 全局区(未初始化的全局变量)</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    NSInteger i = 123; // 栈区（局部变量）</span><br><span class="line">    NSLog(@&quot;i的内存地址：%p&quot;, &amp;i);</span><br><span class="line">    </span><br><span class="line">    NSString *string = @&quot;ZJ&quot;; // 常量区（字符串常量）</span><br><span class="line">    NSLog(@&quot;string的内存地址：%p&quot;, string);</span><br><span class="line">    NSLog(@&quot;&amp;string的内存地址：%p&quot;, &amp;string);</span><br><span class="line">    </span><br><span class="line">    NSObject *obj = [[NSObject alloc] init]; // 堆区（alloc对象）</span><br><span class="line">    NSLog(@&quot;obj的内存地址：%p&quot;, obj);</span><br><span class="line">    NSLog(@&quot;&amp;obj的内存地址：%p&quot;, &amp;obj);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2022-03-11 14:34:25.438913+0800 内存五大区[70321:4340509] i的内存地址：0x16f6f5a18</span><br><span class="line">2022-03-11 14:34:25.438976+0800 内存五大区[70321:4340509] string的内存地址：0x100710098</span><br><span class="line">2022-03-11 14:34:25.438997+0800 内存五大区[70321:4340509] &amp;string的内存地址：0x16f6f5a10</span><br><span class="line">2022-03-11 14:34:25.439014+0800 内存五大区[70321:4340509] obj的内存地址：0x280fa0bc0</span><br><span class="line">2022-03-11 14:34:25.439031+0800 内存五大区[70321:4340509] &amp;obj的内存地址：0x16f6f5a08</span><br></pre></td></tr></table></figure></div><ul><li><p>对于 <code>局部变量i</code>， 存放在栈区</p></li><li><p>对于 <code>字符串对象string</code>，分别打印了 <code>string得对象地址</code> 和 <code>string对象的指针地址</code></p><ul><li>string的 <code>对象地址</code> 是是存放在 <code>常量区</code></li><li>string <code>对象的指针地址</code>，是存放在 <code>栈区</code></li></ul></li><li><p>对于 <code>alloc创建的对象obj</code>，分别打印了 <code>obj得对象地址</code> 和 <code>obj对象的指针地址</code></p><ul><li>obj的 <code>对象地址</code> 是存放在 <code>堆区</code> </li><li>obj <code>对象的指针地址</code> 是存放在 <code>栈区</code></li></ul></li></ul><h1 id="函数栈"><a href="#函数栈" class="headerlink" title="函数栈"></a>函数栈</h1><ul><li><p><code>函数栈</code> 又称为 <code>栈区</code>，在内存中从高地址往低地址分配，与堆区相对，具体图示请看上面</p></li><li><p><code>栈帧</code> 是指 <code>函数（运行中且未完成）占用的一块独立的连续内存区域</code></p></li><li><p>应用中新创建的 <code>每个线程都有专用的栈空间</code>，栈可以在线程期间自由使用，而线程中有千千万万的函数调用，这些函数 <code>共享</code> 进程的这个 <code>栈空间</code>。<code>每个函数所使用的栈空间是一个栈帧，所有栈帧就组成了这个线程完成的栈</code></p></li><li><p><code>函数调用是发生在栈上</code> 的，每个 <code>函数的相关信息</code>（例如局部变量、调用记录等）都 <code>存储在一个栈帧</code> 中，每执行一次 <code>函数调用</code>，就会生成一个与其相关的栈帧，然后将其 <code>栈帧压入函数栈</code>，而当函数 <code>执行结束</code>，则将此函数对应的 <code>栈帧出栈并释放掉</code></p></li></ul><p>如下图所示，是经典图- <code>ARM的栈帧布局方式</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021911717.png"                                     ></p><ul><li><p>其中 <code>main stack frame</code> 为调用函数的栈帧</p></li><li><p><code>func1 stack frame</code> 为当前 <code>当前函数（被调用者）的栈帧</code></p></li><li><p><code>栈底</code> 在 <code>高</code> 地址，栈向下增长</p></li><li><p><code>FP</code> 就是 <code>栈基址</code>，它指向函数的 <code>栈帧起始地址</code></p></li><li><p><code>SP</code> 则是函数的 <code>栈指针</code>，它指向 <code>栈顶</code> 的位置</p></li><li><p><code>ARM压栈</code> 的 <code>顺序</code> 很是规则（也比较容易被黑客攻破），依次为 <code>当前函数指针PC</code>、<code>返回指针LR</code>、<code>栈指针SP</code>、<code>栈基址FP</code>、<code>传入参数个数及指针</code>、<code>本地变量</code> 和 <code>临时变量</code>。如果函数准备调用另一个函数，跳转之前临时变量区先要保存另一个函数的参数</p></li><li><p><code>ARM</code> 也可以 <code>用栈基址和栈指针明确标示栈帧的位置</code>，栈指针SP一直移动，ARM的特点是，<code>两个栈空间内的地址（SP+FP）前面，必然有两个代码地址（PC+LP）明确标示着调用函数位置内的某个地址</code></p></li></ul><h2 id="堆栈溢出"><a href="#堆栈溢出" class="headerlink" title="堆栈溢出"></a>堆栈溢出</h2><p>一般情况下应用程序是不需要考虑堆和栈的大小的，但是事实上堆和栈不是无上限的，<code>过多的递归会导致栈溢出</code>，<code>过多的alloc变量会导致堆溢出</code></p><p>所以 <code>预防堆栈溢出</code> 的方法：</p><ul><li><p><code>避免层次过深</code> 的 <code>递归</code> 调用</p></li><li><p><code>不要使用过多的局部变量</code>，控制局部变量的大小</p></li><li><p><code>避免分配</code> 占用空间 <code>太大的对象</code>，并 <code>及时释放</code></p></li><li><p>实在不行，适当的情景下 <code>调用系统API修改线程的堆栈大小</code></p></li></ul><h2 id="栈帧示例"><a href="#栈帧示例" class="headerlink" title="栈帧示例"></a>栈帧示例</h2><p>描述下面代码的栈帧变化</p><p>栈帧程序示例</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int Add(int x,int y) &#123;</span><br><span class="line">    int z = 0;</span><br><span class="line">    z = x + y;</span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    int ret = Add(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序执行时，栈区中栈帧的变化如下图所示：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021912743.png"                                     ></p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>在iOS中开发中，我们或多或少都听说过内存管理。iOS的内存管理一般指的是OC对象的内存管理，因为OC对象分配在堆内存，堆内存需要程序员自己去动态分配和回收；基础数据类型(非OC对象)则分配在栈内存中，超过作用域就会由系统检测回收。如果我们在开发过程中，对内存管理得不到位，就有可能造成内存泄露。</p></li><li><p>我们通常讲的内存管理，实际上从发展的角度来说，分为两个阶段：<code>MRC和ARC</code>。</p><ul><li><p>MRC指的是 <code>手动内存管理</code>，在开发过程中需要开发者手动去编写内存管理的代码；</p></li><li><p>ARC指的是 <code>自动内存管理</code>，在此内存管理模式下由LLVM编译器和OC运行时库生成相应内存管理的代码。</p></li></ul></li></ul><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><ul><li><p>在 <code>OC</code> 中，使用 <code>引用计数</code> 来 <code>进行内存管理</code>。</p></li><li><p>每个对象都有一个与其相对应的引用计数器，当持有一个对象，这个对象的引用计数就会递增；当这个对象的某个持有被释放，这个对象的引用计数就会递减。当这个对象的引用计数变为0，那么这个对象就会被系统回收。</p></li><li><p>当一个对象使用完没有释放，此时其引用计数永远大于1。该对象就会一直占用其分配在堆内存的空间，就会导致内存泄露。内存泄露到一定程度有可能导致内存溢出，进而导致程序崩溃。</p></li></ul><h2 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h2><ol><li>简介</li></ol><p>全称 Manual Reference Counting，管理通过使用 <code>retain, release</code>, 以及 <code>autorelease</code> 的消息发送来实现。</p><ul><li>retain: 持有（拥有）对象，对象引用数加 1</li><li>release: 释放对象，对象引用数减 1</li><li>autorelease: 通知系统，在 <code>@autoreleasepool</code> 代码块结束时，对对象调用 <code>release</code></li></ul><ol start="2"><li>管理原则</li></ol><ul><li>自己创建的对象，自己获得拥有权</li></ul><p>在苹果规定中，使用 <code>alloc/new/copy/mutableCopy</code> 创建返回的对象归调用者所有，例如以下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* NSMutableArray类对象A */</span><br><span class="line">NSMutableArray *array = [[NSMutableArray alloc] init];    </span><br><span class="line">NSLog(@&quot;%p&quot;, array);</span><br><span class="line">[array release]; // 释放</span><br></pre></td></tr></table></figure></div><p>由于对象 <code>A</code> 由 <code>alloc</code> 生成，符合苹果规定，<code>指针变量array指向并持有对象A</code>，引用计数器会加 1。另外，array在使用完对象A后需要对其进行释放。当调用release后，释放了其对对象A的引用，计数器减1。对象A此时引用计数值为零，所以对象A被回收。不能访问已经被回收的对象，会发生崩溃。</p><ul><li>别人创建的对象，可以通过 <code>retain</code> 来获得拥有权</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 例如已有 fooArray, 通过 array 方法获得其引用</span><br><span class="line">NSArray *bar = [fooArray array];</span><br><span class="line"></span><br><span class="line">// 不可以直接调用 release，因为没有拥有权</span><br><span class="line">// [bar release];</span><br><span class="line"></span><br><span class="line">// 需要先 retain 来获得拥有权，然后才能释放</span><br><span class="line">[bar retain];</span><br><span class="line">[bar release];</span><br></pre></td></tr></table></figure></div><ul><li><p>你所拥有的对象不再需要使用时，必须将其释放</p></li><li><p>不能释放你不拥有的对象</p></li></ul><ol start="3"><li>retain</li></ol><ul><li>retain和属性</li></ul><p>我们可以通过属性来保存对象，如果一个属性为强引用，我们就可以通过属性的实例变量和存取方法来对某个对象进行操作，例如某个属性的setter方法如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)setPerson:(Person *)person &#123;</span><br><span class="line"></span><br><span class="line">    [person retain];</span><br><span class="line">    </span><br><span class="line">    [_person release];</span><br><span class="line">    </span><br><span class="line">    _person = person;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>我们通过 <code>retain新值</code>，<code>release旧值</code>，再给实例变量更新值。</p><p>需要注意的一点是：需要先retain新值，再release旧值。因为如果新旧值是同一个对象的话，先release就有可能导致该对象被系统回收，再去retain就没有任何意义了。例如下面这个例子：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong)Person *person;</span><br><span class="line">@end</span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">  </span><br><span class="line">    // 实例变量持有Person类对象(P对象)。这样赋值不会调用set方法</span><br><span class="line">    _person = [[Person alloc] init];</span><br><span class="line">    </span><br><span class="line">    // 调用set方法</span><br><span class="line">    self.person = _person;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setPerson:(Person *)person &#123;</span><br><span class="line">    // release释放对P对象的引用，P对象引用计数值变为零，则P对象被系统回收</span><br><span class="line">    [_person release];</span><br><span class="line"></span><br><span class="line">    // 由于P对象已经被回收，再去retain就容易出问题</span><br><span class="line">    [person retain];</span><br><span class="line">    </span><br><span class="line">    _person = person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>由于P对象被回收，对应其所分配的内存被置于 <code>可用内存池</code> 中。如果该内存未被覆写，那么P对象依然有效；如果内存被覆写，那么实例变量_person就会指向一个被覆写的未知对象的指针，那么实例变量就变成一个 <code>悬挂指针</code>。</p><ul><li>retain和数组</li></ul><p>如果我们把一个对象加入到一个数组中，那么该数组的addObject方法会对该对象调用retain方法。例如以下代码：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// person获得并持有P对象，P对象引用计数为1</span><br><span class="line">Person *person = [[Person alloc] init]; // Person类对象生成的P对象</span><br><span class="line">    </span><br><span class="line">NSMutableArray *array = [NSMutableArray array];</span><br><span class="line">    </span><br><span class="line">// person被加入到数组，对象P引用计数值为2</span><br><span class="line">[array addObject:person];</span><br><span class="line">    </span><br></pre></td></tr></table></figure></div><p>此时，对象P被person和array两个变量同时持有。</p><ol start="4"><li>release</li></ol><ul><li>自己持有的对象自己释放</li></ul><p>当我们持有一个对象，如果在不需要继续使用该对象，我们需要对其进行释放(release)。例如以下代码：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// array获得并持有NSArray类对象</span><br><span class="line">NSArray *array = [[NSArray alloc] init];</span><br><span class="line">    </span><br><span class="line">// 当不再需要使用该对象时，需要释放</span><br><span class="line">[array release];</span><br><span class="line">    </span><br><span class="line">// obj获得但不持有该对象</span><br><span class="line">id obj = [NSArray array];</span><br></pre></td></tr></table></figure></div><ul><li>非自己持有的对象不要释放</li></ul><p>当我们不持有某个对象，却对该对象进行释放，应用程序就会崩溃。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获得并持有A对象</span><br><span class="line">Person *p = [[Person alloc] init]; // Person类对象A</span><br><span class="line">    </span><br><span class="line">// 对象A引用计数为零，所以对象A被回收</span><br><span class="line">[p release];</span><br><span class="line"></span><br><span class="line">// 释放非自己持有的对象</span><br><span class="line">[p release];</span><br></pre></td></tr></table></figure></div><p>另外，我们也不能访问某个已经被释放的对象，该对象所占的堆空间如果被覆写就会发生崩溃的情况。</p><ol start="5"><li>autorelease</li></ol><p><code>autorelease</code> 指的是自动释放，当一个对象收到 <code>autorelease</code> 的时候，该 <code>对象就会被注册到当前处于栈顶的自动释放池（autorelease pool）</code>。如果没有主动生成自动释放池，则当前自动释放池对应的是主运行循环的自动释放池。在当前线程的RunLoop进入休眠前，就会对被注册到该自动释放池的所有对象进行一次release操作。</p><p>autorelease和release的区别是：</p><ul><li><p>release：是马上释放对某个对象的强引用；</p></li><li><p>autorelease：是延迟释放某个对象的生命周期。</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 外部调用</span><br><span class="line">    Person *p = [Person person];</span><br><span class="line">    NSLog(@&quot;%p&quot;, p); //使用无须retain</span><br><span class="line"></span><br><span class="line">    // 持有则需要retain</span><br><span class="line">    [p retain];</span><br><span class="line">    _person = p;</span><br><span class="line">    [_person release];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Person类内部定义</span><br><span class="line">+ (id)person &#123;</span><br><span class="line"></span><br><span class="line">    //创建的Person类对象由person获得并持有</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">   </span><br><span class="line">    // [person release];</span><br><span class="line"></span><br><span class="line">    // 将 person 对象放入自动释放池</span><br><span class="line">    [person autorelease];</span><br><span class="line">    </span><br><span class="line">    return person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在外部调用，从方法名person知道，创建的对象由p指针变量获得但不持有。在函数内部，person获得并持有了Person类对象，所返回的person对象的引用计数加1。换句话说，调用者需要额外处理这多出来的一个持有操作。另外，我们不能在函数内部调用release，不然对象还没返回就已经被系统回收。这时候使用autorelease就能很好地解决这个问题。</p><p>只要把要返回的对象调用autorelease方法，注册到自动释放池就能延长person对象的生命周期，使其在 autorelease pool销毁(drain)前依然能够存活。</p><p>另外，person对象在返回时调用了 <code>autorelease方法</code>。该对象已经在自动释放池中，我们可以直接使用对象p，无须再通过[p retain]访问；不过，如果要用实例变量持有该对象，则需要对变量p进行一次retain操作，实例变量使用完该对象需要释放该对象。</p><ol start="6"><li>autorelease pool</li></ol><ul><li><code>autorelease pool</code> 和 <code>RunLoop(运行循环)</code></li></ul><p>当应用程序启动，系统默认会 <code>开启一条线程</code>，该线程就是 <code>主线程</code>。主线程也有一个与之对应的自动释放池。</p><p><code>每条线程都包含一个与其对应的自动释放池</code>，当某条线程被终止的时候，对应该线程的自动释放池会被销毁。同时，处于该自动释放池的对象将会进行一次 <code>release</code> 操作。</p><p>，例如我们常见的 <code>ARC</code> 下的 <code>main.h</code> 文件：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>该自动释放池用来释放在主线程下注册到该自动释放池的对象。</p><p>需要注意的是，当我们 <code>开启一条子线程</code>，并且在该线程 <code>开启RunLoop</code> 的时候，需要为其增加一个<code>autorelease pool</code>，这样有助于保证内存的安全。</p><ul><li>autorelease pool和降低内存峰值</li></ul><p>当我们执行一些复杂的操作，特别是如果这些复杂的操作要被循环执行，那么中间会免不了会产生一些临时变量。当被加到主线程自动释放池的对象越来越来多，却没有得到及时释放，就会导致内存溢出。这个时候，我们可以手动添加自动释放池来解决这个问题。如以下例子所示：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; largeNumber; i++) &#123;</span><br><span class="line">        </span><br><span class="line">    // 创建自动释放池</span><br><span class="line">    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">    </span><br><span class="line">    // 产生许多被注册到自动释放池的临时对象</span><br><span class="line">    id obj = [Person personWithComplexOperation];</span><br><span class="line">    </span><br><span class="line">    // 释放池中对象</span><br><span class="line">    [pool drain];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如上述例子所示，我们执行的循环次数是一个非常大的数字。并且调用personWithComplexOperation方法的过程中会产生许多临时对象，所产生的临时对象有可能会被注册到自动释放池中。我们通过手动生成一个自动释放池，并且在每次循环结束前把该自动释放池的对象执行release操作释放掉，这样就能有效地降低内存的峰值了。</p><h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><ol><li>概述</li></ol><ul><li><p>Automatic Reference Counting，<code>自动引用计数</code>，即 <code>ARC</code>，<code>WWDC2011</code> 和 <code>iOS5</code> 所引入的最大的变革和最激动人心的变化。ARC是新的LLVM 3.0编译器的一项特性，使用ARC，可以说举解决了广大iOS开发者所憎恨的手动内存管理的麻烦。</p></li><li><p>此处的 <code>A</code> 就是 <code>automatic</code>。其实 <code>ARC</code> 只是比 <code>MRC</code> 多了一步，就是在 <code>编译时编译器自动帮开发者添加 retain, release 以及 autorelease 的调用</code>，底层的内存管理机制还是和 <code>MRC</code> 一样。</p></li><li><p>在 <code>ARC</code> 模式下，我们通常在对象变量的声明里用 <code>属性标记符</code> 来指引 <code>ARC</code> 机制来管理我们的对象变量，它们是：<code>strong, retain, weak, copy, assign</code>。默认标记是 <code>strong</code></p></li></ul><ol start="2"><li>标记符的区别</li></ol><ul><li>strong: 顾名思义，就是 <code>强引用</code>，对应 <code>MRC</code> 下的 <code>retain</code>，即引用数加 1</li><li>retain: 同 <code>strong</code></li><li>weak: 弱引用，不增加引用数，引用的对象被释放后变为 <code>nil</code></li><li>copy: 对对象进行 <code>copy</code> 后再赋值，因此对象必须遵循 <code>NSCopying</code> 协议。如：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property(copy)Foo *foo;</span><br><span class="line">...</span><br><span class="line">self.foo = bar;  // 相当于 self.foo = [bar copy];</span><br></pre></td></tr></table></figure></div><ul><li>assign: 一般用于原始数据类型（primitive type）的赋值。可以用于对象，效果相当于 weak，可是有一个坑是当对象被释放后，assign 属性的变量不会变成 nil，而是成为 <code>野指针</code>（dangling pointer），因此不建议使用在对象上。</li></ul><p>借助以上的属性标记符，我们可以在对象声明的时候集中制定它们的内存管理策略，清晰明了。</p><ol start="3"><li>ARC的判断原则</li></ol><p>ARC判断一个对象是否需要释放不是通过引用计数来进行判断的，而是通过强指针来进行判断的。那么什么是强指针?</p><ul><li><p>强指针</p><ul><li>默认所有对象的指针变量都是强指针</li><li>被__strong修饰的指针</li></ul></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *p1 = [[Person alloc] init];</span><br><span class="line">__strong  Person *p2 = [[Person alloc] init];</span><br></pre></td></tr></table></figure></div><ul><li><p>弱指针</p><ul><li>被 <code>__weak</code> 修饰的指针</li></ul></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak  Person *p = [[Person alloc] init];</span><br></pre></td></tr></table></figure></div><p><strong>ARC如何通过强指针来判断？</strong></p><ul><li>只要还有一个强指针变量指向对象，对象就会保持在内存中</li></ul><ol start="4"><li>ARC的使用</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // 不用写release, main函数执行完毕后p会被自动释放</span><br><span class="line">    Person *p = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="5"><li>ARC的注意点</li></ol><ul><li>不允许调用对象的 <code>release方法</code></li><li>不允许调用 <code>autorelease方法</code></li><li>重写父类的dealloc方法时，不能再调用 <code>[super dealloc]</code>;</li></ul><ol start="6"><li>ARC下单对象内存管理</li></ol><ul><li>局部变量释放对象随之被释放</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">    &#125; // 执行到这一行局部变量p释放</span><br><span class="line">    // 由于没有强指针指向对象, 所以对象也释放</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>清空指针对象随之被释放</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">        p = nil; // 执行到这一行, 由于没有强指针指向对象, 所以对象被释放</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>默认清空所有指针都是强指针</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">        // p1和p2都是强指针</span><br><span class="line">        Person *p1 = [[Person alloc] init];</span><br><span class="line">        __strong Person *p2 = [[Person alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li><p>弱指针需要明确说明</p><ul><li>注意: 千万不要使用弱指针保存新创建的对象</li></ul></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">        // p是弱指针, 对象会被立即释放</span><br><span class="line">        __weak Person *p1 = [[Person alloc] init];</span><br><span class="line">        NSLog(@&quot;%@&quot;,p);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-07-31 18:02:51.021697+0800 iOS-OC之ARC[2134:984503] (null)</span><br></pre></td></tr></table></figure></div><ol start="7"><li>ARC下多对象内存管理</li></ol><p>ARC和MRC一样, 想拥有某个对象必须用强指针保存对象, 但是不需要在dealloc方法中release</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">// MRC写法</span><br><span class="line">//@property (nonatomic, retain) Dog *dog;</span><br><span class="line"></span><br><span class="line">// ARC写法</span><br><span class="line">@property (nonatomic, strong) Dog *dog;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><h2 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h2><ol><li>概述</li></ol><ul><li><p><code>AutoreleasePool</code>（自动释放池）是 <code>OC</code> 中的一种 <code>内存自动回收机制</code>。</p></li><li><p>当向一个对象发送 <code>autorelease</code> 消息时，会将对象加入到自动释放池，这个对象不会立即释放，而是等到 <code>runloop休眠或超出autoreleasepool作用域</code> 之后进行 <code>释放</code>。</p></li></ul><ol start="2"><li>MRC 下使用自动释放池</li></ol><p>在MRC环境中使用自动释放池需要用到 <code>NSAutoreleasePool</code> 对象，其生命周期就相当于C语言变量的作用域。对于所有调用过 autorelease方法的对象，在废弃NSAutoreleasePool对象时，都将调用release实例方法。用源代码表示如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// MRC环境下的测试：</span><br><span class="line">// 第一步：生成并持有释放池NSAutoreleasePool对象;</span><br><span class="line">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line"></span><br><span class="line">// 第二步：调用对象的autorelease实例方法;</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line"></span><br><span class="line">// 第三步：废弃NSAutoreleasePool对象;</span><br><span class="line">[pool drain];   // 向pool管理的所有对象发送消息，相当于[obj release]</span><br><span class="line"></span><br><span class="line">// obj已经释放，再次调用会崩溃(Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT))</span><br><span class="line">NSLog(@&quot;打印obj：%@&quot;, obj); </span><br></pre></td></tr></table></figure></div><ol start="3"><li><code>ARC</code> 下使用自动释放池</li></ol><p>ARC环境不能使用NSAutoreleasePool类也不能调用autorelease方法，代替它们实现对象自动释放的是 <code>@autoreleasepool块</code>。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ARC环境下的测试：</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">    id obj = [[NSObject alloc] init];</span><br><span class="line">    NSLog(@&quot;打印obj：%@&quot;, obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="ARC-下-AutoReleasePool-内部实现"><a href="#ARC-下-AutoReleasePool-内部实现" class="headerlink" title="ARC 下 AutoReleasePool 内部实现"></a>ARC 下 AutoReleasePool 内部实现</h2><h3 id="使用-autoreleasepool"><a href="#使用-autoreleasepool" class="headerlink" title="使用@autoreleasepool{}"></a>使用@autoreleasepool{}</h3><p>我们在main函数中写入自动释放池相关的测试代码如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>为了探究释放池的底层实现，我们在终端使用 clang -rewrite-objc + 文件名命令将上述OC代码转化为 <code>C++</code> 源码：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */</span><br><span class="line">    &#123;</span><br><span class="line">        __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_d37e0d_mi_0);</span><br><span class="line">     &#125; // 大括号对应释放池的作用域</span><br><span class="line">     </span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在经过编译器 <code>clang</code> 命令转化后，我们看到的所谓的 <code>@autoreleasePool块</code>，其实对应着<br><code>__AtAutoreleasePool的结构体</code>。</p><h3 id="分析结构体-AtAutoreleasePool-的具体实现"><a href="#分析结构体-AtAutoreleasePool-的具体实现" class="headerlink" title="分析结构体 __AtAutoreleasePool 的具体实现"></a>分析结构体 <code>__AtAutoreleasePool</code> 的具体实现</h3><p>在源码中找到 <code>__AtAutoreleasePool结构体</code> 的实现代码，具体如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);</span><br><span class="line"></span><br><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>__AtAutoreleasePool结构体包含了：<code>构造函数、析构函数和一个对象</code>；</p><p>构造函数内部调用：<code>objc_autoreleasePoolPush()</code> 方法，返回对象<code>atautoreleasepoolobj</code></p><p>析构函数内部调用：<code>objc_autoreleasePoolPop()</code> 方法，传入对象<code>atautoreleasepoolobj</code></p><ul><li>分析main函数中 __autoreleasepool结构体实例的生命周期是这样的：</li></ul><p>__autoreleasepool是一个自动变量，其构造函数是在程序执行到声明这个对象的位置时调用的，而其析构函数则是在程序执行到离开这个对象的作用域时调用。所以，我们可以将上面main函数的代码简化如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123;</span><br><span class="line">        void *atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kb_06b822gn59df4d1zt99361xw0000gn_T_main_d39a79_mi_0);</span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><code>objc_autoreleasePoolPush</code> 与 <code>objc_autoreleasePoolPop</code><br>进一步观察自动释放池构造函数与析构函数的实现，其实它们都只是对<br><code>AutoreleasePoolPage</code> 对应静态方法 <code>push</code> 和 <code>pop</code> 的封装：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void *objc_autoreleasePoolPush(void) &#123;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void objc_autoreleasePoolPop(void *ctxt) &#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="理解-AutoreleasePoolPage"><a href="#理解-AutoreleasePoolPage" class="headerlink" title="理解 AutoreleasePoolPage"></a>理解 <code>AutoreleasePoolPage</code></h3><p><code>AutoreleasePoolPage</code> 是一个 <code>C++</code> 中的类，打开Runtime的源码工程，在NSObject.mm文件中可以找到它的定义，摘取其中的关键代码如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage &#123;</span><br><span class="line">#   define EMPTY_POOL_PLACEHOLDER ((id*)1)  // 空池占位</span><br><span class="line">#   define POOL_BOUNDARY nil                // 即哨兵对象</span><br><span class="line">    static pthread_key_t const key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    static uint8_t const SCRIBBLE = 0xA3;  // 0xA3A3A3A3 after releasing</span><br><span class="line">    static size_t const SIZE = </span><br><span class="line">#if PROTECT_AUTORELEASEPOOL</span><br><span class="line">        PAGE_MAX_SIZE;  // must be multiple of vm page size</span><br><span class="line">#else</span><br><span class="line">        PAGE_MAX_SIZE;  // size and alignment, power of 2</span><br><span class="line">#endif</span><br><span class="line">    static size_t const COUNT = SIZE / sizeof(id);</span><br><span class="line">    magic_t const magic;                  // 校验AutoreleasePagePoolPage结构是否完整</span><br><span class="line">    id *next;                             // 指向新加入的autorelease对象的下一个位置，初始化时指向begin()</span><br><span class="line">    pthread_t const thread;               // 当前所在线程，AutoreleasePool是和线程一一对应的</span><br><span class="line">    AutoreleasePoolPage * const parent;   // 指向父节点page，第一个结点的parent值为nil</span><br><span class="line">    AutoreleasePoolPage *child;           // 指向子节点page，最后一个结点的child值为nil</span><br><span class="line">    uint32_t const depth;                 // 链表深度，节点个数</span><br><span class="line">    uint32_t hiwat;                       // 数据容纳的一个上限</span><br><span class="line">    //......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p><code>AutoreleasePoolPage</code> 中拥有 <code>parent 和 child 指针</code>，分别指向上一个和下一个 <code>page</code>；当前一个page的空间被占满(每个AutorelePoolPage的大小为4096字节)时，就会新建一个AutorelePoolPage对象并连接到链表中，后来的Autorelease对象也会添加到新的page中；<br>另外，当next&#x3D;&#x3D; begin()时，表示AutoreleasePoolPage为空；当next &#x3D;&#x3D; end()，表示AutoreleasePoolPage已满。</p><ul><li>理解 <code>哨兵对象(POOL_BOUNDARY)的作用</code>，而它的作用事实上也就是为了 <code>起到一个标识的作用</code>。</li></ul><p>每当自动释放池初始化调用 <code>objc_autoreleasePoolPush</code> 方法时，总会通过 <code>AutoreleasePoolPage</code> 的 <code>push</code> 方法，将 <code>POOL_BOUNDARY</code> 放到当前 <code>page</code> 的栈顶，并且返回这个对象 <code>atautoreleasepoolobj</code>；</p><p>而在自动释放池释放调用 <code>objc_autoreleasePoolPop</code> 方法时，又会将 <code>atautoreleasepoolobj对象</code> 以参数传入，这样自动释放池就会向释放池中对象发送release消息，直至找到第一个边界对象为止。</p><h3 id="理解-objc-autoreleasePoolPush-方法"><a href="#理解-objc-autoreleasePoolPush-方法" class="headerlink" title="理解 objc_autoreleasePoolPush 方法"></a>理解 <code>objc_autoreleasePoolPush</code> 方法</h3><p>经过前面的分析，<code>objc_autoreleasePoolPush</code> 最终调用的是 <code>AutoreleasePoolPage</code> 的 <code>push</code> 方法，该方法的具体实现如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static inline void *push() &#123;</span><br><span class="line">   return autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line">&#123;</span><br><span class="line">   AutoreleasePoolPage *page = hotPage();</span><br><span class="line">   if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">       return page-&gt;add(obj);</span><br><span class="line">   &#125; else if (page) &#123;</span><br><span class="line">       return autoreleaseFullPage(obj, page);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">1.        return autoreleaseNoPage(obj);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 压栈操作：将对象加入AutoreleaseNoPage并移动栈顶的指针</span><br><span class="line">id *add(id obj) &#123;</span><br><span class="line">    id *ret = next;</span><br><span class="line">    *next = obj;</span><br><span class="line">    next++;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当前hotPage已满时调用</span><br><span class="line">static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        if (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        else page = new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; while (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当前hotpage不存在时调用</span><br><span class="line">static id *autoreleaseNoPage(id obj) &#123;</span><br><span class="line">    AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line"></span><br><span class="line">    if (obj != POOL_SENTINEL) &#123;</span><br><span class="line">        page-&gt;add(POOL_SENTINEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>观察上述代码，每次调用 <code>push</code> 其实就是 <code>创建一个新的AutoreleasePoolPage</code>，在对应的AutoreleasePoolPage中插入一个 <code>POOL_BOUNDARY</code> ，并且返回插入的 <code>POOL_BOUNDARY</code> 的内存地址。自动释放池最终都会通过 <code>page-&gt;add(obj)</code> 方法 <code>将对象添加到page中</code>，而这一过程被分为三种情况：</p><pre><code>* 当前page存在且不满，调用 `page-&gt;add(obj)` 方法将 `对象` 添加至page的栈中，即next指向的位置* 当前page存在但是已满，调用 autoreleaseFullPage 初始化一个新的 page，调用page-&gt;add(obj)方法将对象添加至page的栈中* 当前page不存在时，调用 autoreleaseNoPage 创建一个 hotPage，再调用page-&gt;add(obj) 方法将对象添加至page的栈中</code></pre><h3 id="理解-objc-autoreleasePoolPop-方法"><a href="#理解-objc-autoreleasePoolPop-方法" class="headerlink" title="理解 objc_autoreleasePoolPop 方法"></a>理解 <code>objc_autoreleasePoolPop</code> 方法</h3><ul><li><p><code>AutoreleasePool</code> 的释放调用的是 <code>objc_autoreleasePoolPop</code> 方法，此时需要传入  <code>atautoreleasepoolobj</code> 对象作为参数。</p></li><li><p>同理，我们找到 <code>objc_autoreleasePoolPop</code> 最终调用的方法，即 <code>AutoreleasePoolPage</code> 的pop方法，该方法的具体实现如下</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static inline void pop(void *token)   // POOL_BOUNDARY的地址</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line"></span><br><span class="line">    page = pageForPointer(token);   // 通过POOL_BOUNDARY找到对应的page</span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    if (DebugPoolAllocation  &amp;&amp;  *stop != POOL_SENTINEL) &#123;</span><br><span class="line">        // This check is not valid with DebugPoolAllocation off</span><br><span class="line">        // after an autorelease with a pool page but no pool in place.</span><br><span class="line">        _objc_fatal(&quot;invalid or prematurely-freed autorelease pool %p; &quot;, </span><br><span class="line">                    token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (PrintPoolHiwat) printHiwat();   // 记录最高水位标记</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);   // 向栈中的对象发送release消息，直到遇到第一个哨兵对象</span><br><span class="line"></span><br><span class="line">    // memory: delete empty children</span><br><span class="line">    // 删除空掉的节点</span><br><span class="line">    if (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        // special case: delete everything during page-per-pool debugging</span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125; else if (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        // special case: delete everything for pop(top) </span><br><span class="line">        // when debugging missing autorelease pools</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125; </span><br><span class="line">    else if (page-&gt;child) &#123;</span><br><span class="line">        // hysteresis: keep one empty child if page is more than half full</span><br><span class="line">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="【总结】"><a href="#【总结】" class="headerlink" title="【总结】"></a><strong>【总结】</strong></h3><p>【结构】：</p><ul><li><p>自动释放池的压栈和出栈，通过结构体的构造函数和析构函数实现：</p><ul><li><p>压栈：调用 <code>objc_autoreleasePoolPush()</code> 函数，内部调用的是 <code>AutoreleasePoolPage</code> 的 <code>push()</code> 方法，返回 <code>atautoreleasepoolobj</code> 对象</p></li><li><p>出栈：调用  <code>objc_autoreleasePololPop()</code> 函数，内部调用的是 <code>AutoreleasePoolPage</code> 的 <code>pop()</code> 方法，传入 <code>atautoreleasepoolobj</code> 对象</p></li></ul></li></ul><p>【容量】：</p><ul><li>池页大小为4096字节，每一页都包含56字节的成员变量，但一个自动释放池中，只会压栈一个哨兵对象，占8字节</li></ul><p>【原理】：</p><ul><li><p>自动释放池的本质是 <code>__AtAutoreleasePool</code> 结构体，包含构造函数和析构函数</p></li><li><p>结构体声明，触发构造函数，调用 <code>objc_autoreleasePoolPush()</code> 函数，对象压栈</p><ul><li><p>如果存在page，并且没有存满，调用add函数</p><ul><li>将对象压栈</li></ul></li><li><p>如果存在page，但存储已满，调用autoreleaseFullPage函数</p><ul><li>遍历链表，找到最后一个空白的子页面</li><li>对其进行创建新页</li><li>设置为热页面</li><li>添加对象</li></ul></li><li><p>否则，不存在page，调用autoreleaseNoPage函数</p><ul><li>通过父类AutoreleasePoolPageData进行初始化</li><li>begin：获取对象压栈的起始位置</li><li>objc_thread_self：通过tls获取当前线程</li><li>链接双向链表</li><li>设置为热页面</li><li>pushExtraBoundary为YES，哨兵对象压栈</li><li>对象压栈</li></ul></li></ul></li><li><p>结构体出作用域，触发析构函数，调用 <code>objc_autoreleasePoolPop()</code> 函数，对象出栈</p><ul><li>调用popPage函数，传入stop为哨兵对象的位置</li><li>当前页中对象出栈，到stop位置停止</li><li>调用kill函数，销毁当前页面</li></ul></li></ul><h1 id="AutoreleasePool在主线程上的释放时机"><a href="#AutoreleasePool在主线程上的释放时机" class="headerlink" title="AutoreleasePool在主线程上的释放时机"></a>AutoreleasePool在主线程上的释放时机</h1><ul><li>分析主线程RunLoop管理自动释放池并释放对象的详细过程，我们在如下Demo中的主线程中设置断点，并执行lldb命令：po [NSRunLoop currentRunLoop]，具体效果如下：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/89028090-42d71580-d35e-11ea-8578-2bdf6240de0a.png"                                     ></p><p>我们看到主线程RunLoop中有两个与自动释放池相关的Observer,对应CFRunLoopActivity的类型如下:</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),          //0x1，启动Runloop循环</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),            </span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),        </span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),  //0xa0，即将进入休眠     </span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),   </span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),           //0xa0，退出RunLoop循环  </span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></div><p>结合RunLoop监听的事件类型，分析主线程上自动释放池的使用过程如下：</p><ul><li><p>App启动后，苹果在主线程RunLoop里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler();</p></li><li><p>第一个Observer监视的事件</p><ul><li><code>Entry(即将进入Loop)</code>，其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。</li></ul></li><li><p>第二个Observer监视了两个事件 :</p><ul><li><p><code>BeforeWaiting(准备进入休眠)</code> 时调用 <code>_objc_autoreleasePoolPop()</code> 和<code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池；</p></li><li><p>Exit(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。</p></li></ul></li><li><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄漏，开发者也不必显示创建AutoreleasePool了;</p></li><li><p>之后的时机</p><ul><li><p>程序启动到加载完成后，主线程对应的RunLoop会停下来等待用户交互</p></li><li><p>用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</p></li><li><p>RunLoop检测到事件后，就会创建自动释放池;</p></li><li><p>所有的延迟释放对象都会被添加到这个池子中;</p></li><li><p>在一次完整的运行循环结束之前，会向池中所有对象发送release消息，然后自动释放池被销毁;</p></li></ul></li></ul><h1 id="AutoreleasePool子线程上的释放时机"><a href="#AutoreleasePool子线程上的释放时机" class="headerlink" title="AutoreleasePool子线程上的释放时机"></a>AutoreleasePool子线程上的释放时机</h1><p>子线程默认不开启RunLoop，那么其中的延时对象该如何释放呢？其实这依然要从Thread和AutoreleasePool的关系来考虑：</p><ul><li><p>就是说，每一个线程都会维护自己的 <code>Autoreleasepool栈</code>，所以子线程虽然默认没有开启RunLoop，但是依然存在AutoreleasePool，在 <code>子线程退出</code> 的时候会去释放autorelease对象。</p></li><li><p>前面讲到过，ARC会根据一些情况进行优化，添加__autoreleasing修饰符，其实这就相当于对需要延时释放的对象调用了autorelease方法。从源码分析的角度来看，如果子线程中没有创建AutoreleasePool ，而一旦产生了Autorelease对象，就会调用autoreleaseNoPage方法自动创建hotpage，并将对象加入到其栈中。所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。</p></li></ul><h1 id="AutoreleasePool需要手动添加的情况"><a href="#AutoreleasePool需要手动添加的情况" class="headerlink" title="AutoreleasePool需要手动添加的情况"></a>AutoreleasePool需要手动添加的情况</h1><ul><li><p>尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建 <code>AutoreleasePool</code>，而其中的延时对象将在当前释放池的作用域结束时释放。苹果文档中说明了三种情况，我们可能会需要手动添加自动释放池：</p><ul><li>编写的不是基于UI框架的程序，例如命令行工具；</li><li>通过循环方式创建大量临时对象；</li><li>使用非Cocoa程序创建的子线程；</li></ul></li></ul><p>而在ARC环境下的实际开发中，我们最常遇到的也是第二种情况，以下面的代码为例：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    for (int i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">        NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">        NSLog(@&quot;打印obj：%@&quot;, obj);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><p>上述代码中，obj因为离开作用域所以会被加入最近一次创建的自动释放池中，而这个释放池就是主线程上的RunLoop管理的；因为for循环在当前线程没有执行完毕，Runloop也就没有完成当前这一次的迭代，所以导致大量对象被延时释放。释放池中的对象将会在viewDidAppear方法执行前就被销毁。在此情况下，我们就有必要通过手动干预的方式及时释放不需要的对象，减少内存消耗；优化的代码如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    for (int i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">        @autoreleasepool&#123;</span><br><span class="line">             NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">             NSLog(@&quot;打印obj：%@&quot;, obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习02：文件导入#include,#import,@class区别</title>
      <link href="/BboyZJ.github.io/2023/03/02/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A002%EF%BC%9A%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5#include,#import,@class%E5%8C%BA%E5%88%AB/"/>
      <url>/BboyZJ.github.io/2023/03/02/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A002%EF%BC%9A%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5#include,#import,@class%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p><code>#include</code> 、 <code>#import</code> 和 <code>@class</code> 都是用来 <code>包含头文件</code></p></li><li><p><code>C/C++</code> 只能用 <code>#include</code> 包含头文件，没有 <code>#import</code> 和 <code>@class</code></p></li><li><p><code>OC</code> 中 <code>#include</code> 、 <code>#import</code> 和 <code>@class</code> 都可以用</p></li></ul><p>那么问题来了，三种包含头文件方式在 <code>OC</code> 中有什么区别呢？</p><h1 id="include、import"><a href="#include、import" class="headerlink" title="include、import"></a>include、import</h1><ul><li><p>#include 会重复导入头文件，重复导入会报重复定义的错误；#import 不会重复导入头文件，允许交叉编译</p></li><li><p>#include &lt;xxx.h&gt; 或 #import &lt;xxx.h&gt; ：用于导入 <code>系统自带文件</code>，在 <code>系统文件目录下查找</code></p></li><li><p>#include “xxx.h” 或 #import “xxx.h” ：用于导入 <code>用户自定义的文件</code>，查找顺序：<code>用户文件目录 -&gt; 安装文件目录 -&gt; 系统文件目录</code>，所以 “xxx.h” 一般用来导入用户自定义的文件</p></li></ul><h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><ul><li>@class XXXClassName ： 用于声明一个类，用于解决互相引用的问题（A引用B，B引用A）</li></ul><h1 id="include-示例"><a href="#include-示例" class="headerlink" title="include 示例"></a>include 示例</h1><ul><li><code>A文件导入两次B文件</code>：报重复定义错误</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">// include 不允许重复导入两次</span><br><span class="line">#include &quot;VB.h&quot;</span><br><span class="line">#include &quot;VB.h&quot;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface VA : UIView</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p>command + b 编译报错：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021812383.png"                                     ></p><ul><li>A引用B，B引用C，A再引用C：同样 <code>报重复定义错误</code>，相当于A引用了两次C</li></ul><h1 id="import-示例"><a href="#import-示例" class="headerlink" title="import 示例"></a>import 示例</h1><ul><li>导入两次A文件，不报错</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 导入两次A文件</span><br><span class="line">#import &quot;A.h&quot;</span><br><span class="line">#import &quot;A.h&quot;</span><br></pre></td></tr></table></figure></div><h1 id="class-使用场景"><a href="#class-使用场景" class="headerlink" title="class 使用场景"></a>class 使用场景</h1><ul><li>A类引用B类，B类引用A：互相引用报错</li></ul><p>A.h文件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;B.h&quot;</span><br><span class="line">@interface A : UIView</span><br><span class="line">@property (nonatomic,strong)B * b;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p>B.h文件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;A.h&quot;</span><br><span class="line">@interface B : UIView</span><br><span class="line">@property (nonatomic,strong)A * a;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021813725.png"                                     ></p><ul><li>可以用 <code>@class</code> 方式进行引用，一个用@class或者两个都用 @class</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//#import &quot;A.h&quot;</span><br><span class="line"></span><br><span class="line">// class声明A</span><br><span class="line">@class A;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog-05：Picgo+Gitee图床</title>
      <link href="/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-05%EF%BC%9APicgo-Gitee%E5%9B%BE%E5%BA%8A/"/>
      <url>/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-05%EF%BC%9APicgo-Gitee%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近发现上传到 GitHub 上的图片大部分不能使用了，然后上网查了一下，应该是 DNS 的问题，网上也有很多解决方案，有兴趣的可以去网上找找，本文主要介绍 <code>Picgo + Gitee</code> 做图床。</p><h1 id="Picgo-介绍"><a href="#Picgo-介绍" class="headerlink" title="Picgo 介绍"></a>Picgo 介绍</h1><p><code>picgo</code> 是一款功能实用、操作简捷的图床工具，图床工具简单来说就是本地图片上传自动转换成链接的一款工具。</p><p>picgo 本体支持如下图床：</p><ul><li>七牛图床 v1.0</li><li>腾讯云 COS v4\v5 版本 v1.1 &amp; v1.5.0</li><li>又拍云 v1.2.0</li><li>GitHub v1.5.0</li><li>SM.MS V2 v2.3.0-beta.0</li><li>阿里云 OSS v1.6.0</li><li>Imgur v1.6.0</li></ul><p>Tips: 本体不再增加默认的图床支持。你可以自行开发第三方图床插件。</p><h1 id="特色功能"><a href="#特色功能" class="headerlink" title="特色功能"></a>特色功能</h1><ul><li>支持拖拽图片上传</li><li>支持快捷键上传剪贴板里第一张图片</li><li>Windows 和 macOS 支持右键图片文件通过菜单上传 (v2.1.0+)</li><li>上传图片后自动复制链接到剪贴板</li><li>支持自定义复制到剪贴板的链接格式</li><li>支持修改快捷键，默认快速上传快捷键：command+shift+p（macOS） | control+shift+p（Windows\Linux）</li><li>支持插件系统，已有插件支持 <code>Gitee、青云等第三方图床</code></li></ul><p>Tips:</p><ul><li>请确保你安装了 <code>Node.js</code>， 并且版本 &gt;&#x3D; 8。</li><li>默认上传图床为 <code>SM.MS</code>。<code>picgo</code> 上传之后，会自动将上传成功的 URL复制到你的剪贴板，支持5种复制格式。</li><li>Mini窗口只支持Windows（圆形）和Linux（方形），macOS可以使用顶部栏图标。（因为Windows和Linux的任务栏不支持拖拽事件）</li></ul><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li><code>nodejs</code> 环境</li><li><code>picgo</code> 客户端</li><li><code>picgo</code> 的 <code>Gitee</code> 上传插件</li><li><code>git、Gitee</code> 账号和一个公开仓库</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li><a class="link"   href="https://nodejs.org/zh-cn/download/" >nodejs官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 安装</li></ul><p>点击链接下载安装 nodejs，安装完成后，查看版本</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % node -v</span><br><span class="line">v18.14.2</span><br><span class="line">mac@bogon ~ % npm -v</span><br><span class="line">mac@bogon ~ % npm -v</span><br><span class="line">9.5.0</span><br></pre></td></tr></table></figure></div><ul><li>安装 <code>picgo</code> 客户端</li></ul><p><a class="link"   href="https://github.com/Molunerfinn/picgo/releases" >picgo安装链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>如果电脑是 <code>Intel</code> 就选 <code>x64</code>，如果电脑是 <code>M1</code> 就选 <code>arm64</code></p><ul><li>安装 git</li></ul><p>Mac 默认是已经安装好了 git</p><h1 id="注册-x2F-登录-Gitee-账号"><a href="#注册-x2F-登录-Gitee-账号" class="headerlink" title="注册&#x2F;登录 Gitee 账号"></a>注册&#x2F;登录 Gitee 账号</h1><ul><li><p><a class="link"   href="https://gitee.com/" >Gitee <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 首页按要求自行注册&#x2F;登录即可</p></li><li><p>新建一个 <code>Gitee</code> 仓库</p></li></ul><p>仓库名：随意，如 Picgo<br>私有<br>创建</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012136074.png"                                     ></p><ul><li>将仓库 <code>开源</code></li></ul><p>由于创建仓库的时候只能 <code>私有</code>，所以此步配置 <code>开源</code> 操作如下：</p><p>进入仓库 -&gt; 管理 -&gt; 基本信息 -&gt; 开源（空仓库不允许） -&gt; 保存</p><ul><li>生成 Token</li></ul><p><code>Token</code> 用于 <code>picgo</code> 操作 Gitee repository：</p><p>点击头像 -&gt; 设置 -&gt; 私人令牌 -&gt; 生成新令牌 -&gt; 提交</p><p>复制你生成的令牌，只显示一次，再次刷新则看不见了，因此你要保存好</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16776726761906.jpg"                                     ></p><h1 id="配置-picgo"><a href="#配置-picgo" class="headerlink" title="配置 picgo"></a>配置 picgo</h1><ul><li>启动 picgo -&gt; 插件设置 -&gt; 搜索 Gitee -&gt; 点击插件图标 <code>安装</code> 即可，本文使用 <code>gitee 2.0.5</code> 插件来进行演示</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012133116.jpg"                                     ></p><p>Tips： 插件装完后，重启生效</p><h1 id="配置-Gitee-插件"><a href="#配置-Gitee-插件" class="headerlink" title="配置 Gitee 插件"></a>配置 Gitee 插件</h1><p>进入 <code>图床设置</code> -&gt; gitee， 依次填入相关配置如下所示，填写如下：</p><ul><li><p>repo： 用户名&#x2F;仓库名（必填）， <code>bboy-zhang-jian/picgo</code></p></li><li><p>path: 上传路径，仓库里的图片保存路径（非必填）</p></li><li><p>token: 私人令牌（必填），刚才保存的 <code>token</code></p></li><li><p>message: 提交消息（非必填）</p></li><li><p>path: 上传路径，仓库里的图片保存路径（非必填）</p></li><li><p>customPath: 定制路径（非必填）</p></li><li><p>customUrl: 图片定制URL（非必填）</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012137612.png"                                     ></p><h1 id="将仓库开源"><a href="#将仓库开源" class="headerlink" title="将仓库开源"></a>将仓库开源</h1><p>头像 -&gt; 仓库 -&gt; 管理 -&gt; 公开 -&gt; 仓库公开须知全部 <code>勾选</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012138939.png"                                     ></p><h1 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h1><ul><li>将图片拖动到 <code>上传区</code> 里</li><li>快捷键 <code>Ctrl + shift + p</code></li></ul><h1 id="ERROR-Plugin-load-failed-hexo-renderer-scss"><a href="#ERROR-Plugin-load-failed-hexo-renderer-scss" class="headerlink" title="ERROR Plugin load failed: hexo-renderer-scss"></a>ERROR Plugin load failed: hexo-renderer-scss</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % npm install hexo-renderer-scss</span><br></pre></td></tr></table></figure></div><h1 id="出现-Error-Cannot-find-module-‘node-sass’"><a href="#出现-Error-Cannot-find-module-‘node-sass’" class="headerlink" title="出现 Error: Cannot find module ‘node-sass’"></a>出现 Error: Cannot find module ‘node-sass’</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % npm install node-sass</span><br></pre></td></tr></table></figure></div><p>不用管了，版本不一致导致的</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习01：事件传递链和响应链</title>
      <link href="/BboyZJ.github.io/2023/03/01/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/"/>
      <url>/BboyZJ.github.io/2023/03/01/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <code>iOS</code> 中只有继承 <code>UIResponder</code> 的 <code>对象</code> 才能够接收并处理事件，<code>UIResponder</code> 是所有响应对象的 <code>基类</code>。继承关系如下：</p><ul><li>UIApplication -&gt; UIResponder -&gt; NSObject</li><li>UIViewController -&gt; UIResponder -&gt; NSObject</li><li>UIWindow -&gt; UIViww -&gt; UIResponder -&gt; NSObject</li><li>UIButton -&gt; UIControl -&gt; UIView -&gt; UIResponder -&gt; NSObject</li><li>UIView -&gt; UIResponder -&gt; NSObject</li></ul><h1 id="事件链"><a href="#事件链" class="headerlink" title="事件链"></a>事件链</h1><ul><li><p><code>传递链</code>：由系统向离用户最近的view传递。<br>顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; RootViewController -&gt; subViews</p></li><li><p><code>响应链</code>：由离用户最近的view向系统传递。<br>顺序： superViews –&gt; RootViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate</p></li></ul><h1 id="传递链"><a href="#传递链" class="headerlink" title="传递链"></a>传递链</h1><ul><li>事件传递的两个核心方法</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 返回哪个视图进行事件响应</span><br><span class="line">- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;  </span><br><span class="line">// 判断某一个点击的位置是否在视图范围内</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;</span><br></pre></td></tr></table></figure></div><ul><li><p>其中 <code>UIView</code> 不接受事件处理的情况有</p></li><li><p>hidden &#x3D; YES 视图被隐藏</p></li><li><p>userInteractionEnabled &#x3D; NO 不接受响应事件</p></li><li><p>alpha &lt;&#x3D; 0.01,透明视图不接收响应事件</p></li><li><p>子视图超出父视图范围</p></li><li><p>需响应视图被其他视图盖住</p></li><li><p>是否重写了其父视图以及自身的hitTest方法</p></li><li><p>是否重写了其父视图以及自身的pointInside方法</p></li><li><p>流程描述</p><ul><li>当iOS程序发生触摸事件后，系统会利用 <code>Runloop</code> 将事件加入到 <code>UIApplication</code> 的任务队列中</li><li><code>UIApplication</code> 分发触摸事件到 <code>UIWindow</code></li><li>然后 <code>UIWindow</code> 依次向下分发给 <code>UIView</code></li><li><code>UIView</code> 调用 <code>hitTest:withEvent:</code> 方法返回一个最终响应的视图</li><li>在 <code>hitTest:withEvent:</code> 方法中就会去调用 <code>pointInside: withEvent:</code> 去判断当前点击的 <code>point</code> 是否在 <code>UIView</code> 范围内，如果是的话，就会去 <code>逆序遍历</code> 它的子视图来查找最终响应的 <code>子视图</code></li><li>遍历的方式是使用 <code>倒序</code> 的方式来遍历子视图，也就是说最后添加的子视图会最先遍历，在每一个视图中都会去调用它的 <code>hitTest:withEvent:</code> 方法，可以理解为是一个 <code>递归调用</code></li><li>最终会返回一个响应视图，如果返回视图有值，那么这个视图就作为最终响应视图，结束整个事件传递；如果没有值，那么就会将UIView作为响应者</li></ul></li></ul><h1 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h1><p>响应者链的事件传递过程</p><ul><li>如果 <code>view</code> 的控制器存在，就传递给控制器处理；如果控制器不存在，则传递给它的 <code>父视图</code></li><li>在视图层次结构的最顶层，如果也不能处理收到的事件，则将事件传递给 <code>UIWindow</code> 对象进行处理</li><li>如果 <code>UIWindow</code> 对象也不处理，则将事件传递给 <code>UIApplication</code> 对象</li><li>如果 <code>UIApplication</code> 也不能处理该事件，则将该事件丢弃</li></ul><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ul><li>实现一个按钮的点击范围扩大效果</li></ul><p>思路：自定义一个按钮，重写 <code>poinstInSide</code> 方法，增大内边距，返回一个新的bounds</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJBtn.h&quot;</span><br><span class="line">@implementation ZJBtn</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 当前btn大小</span><br><span class="line">    CGRect btnBounds = self.bounds;</span><br><span class="line">    // 扩大按钮的点击范围，增大内边距</span><br><span class="line">    btnBounds = CGRectInset(btnBounds, -50, -50);</span><br><span class="line">    // 若点击的点在新的bounds里，返回YES</span><br><span class="line">    return CGRectContainsPoint(btnBounds, point);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>子视图超过父视图部分仍然能响应</li></ul><p>思路：正常情况下子视图超出部分是不能响应事件的，需重写 <code>hitTest:withEvent</code> 方法，指定 <code>子视图</code> 可点击</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;VA.h&quot;</span><br><span class="line"></span><br><span class="line">@interface VA ()</span><br><span class="line">@property (nonatomic,strong)UIButton * btn;</span><br><span class="line">@end</span><br><span class="line">@implementation VA</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame&#123;</span><br><span class="line">    self = [super initWithFrame:frame];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        [self addSubview:self.btn];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)clickBtn&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIButton *)btn&#123;</span><br><span class="line">    if (!_btn) &#123;</span><br><span class="line">        _btn = [[UIButton alloc] initWithFrame:CGRectMake(-50, 20, self.frame.size.width + 100, 100)];</span><br><span class="line">        _btn.backgroundColor = [UIColor blueColor];</span><br><span class="line">        [_btn addTarget:self action:@selector(clickBtn) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    &#125;</span><br><span class="line">    return _btn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 子视图超过父视图部分，需要点击超出范围的部分也有相应</span><br><span class="line"> */</span><br><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 判断btn能否接收事件</span><br><span class="line">    if (self.btn.userInteractionEnabled == NO || self.btn.hidden == YES || self.btn.alpha &lt;= 0.01) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 把当前点转换成btn坐标系上的点</span><br><span class="line">    CGPoint btnP = [self convertPoint:point toView:self.btn];</span><br><span class="line">    // 当触摸点在btn上时，才让按钮相应事件</span><br><span class="line">    if ([self.btn pointInside:btnP withEvent:event]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,NSStringFromCGPoint(btnP));</span><br><span class="line">        return self.btn;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;父视图相应&quot;);</span><br><span class="line">    return [super hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS面试题：Swift</title>
      <link href="/BboyZJ.github.io/2023/03/01/%E9%9D%A2%E8%AF%95%E9%A2%98/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASwift/"/>
      <url>/BboyZJ.github.io/2023/03/01/%E9%9D%A2%E8%AF%95%E9%A2%98/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASwift/</url>
      
        <content type="html"><![CDATA[<h1 id="swift-和-oc-的区别？"><a href="#swift-和-oc-的区别？" class="headerlink" title="swift 和 oc 的区别？"></a>swift 和 oc 的区别？</h1><ul><li><code>swift</code> 是静态语言，有类型判断。<code>OC</code> 是动态语言。</li><li><code>swift</code> 可以面向 <code>函数、协议、对象</code> 编程；oc以面向 <code>对象</code> 编程为主，可以引入 <code>Reactive Cocoa类库</code> 来进行函数式编程</li><li><code>Swift</code> 是 <code>类型安全</code> 的语言。<code>OC</code> 不是类型安全的语言。</li><li><code>Swift</code> 大部分都是 <code>值类型</code>，少部分是 <code>引用类型</code>。OC 有的是 <code>值类型</code>，有的是 <code>指针类型</code>。</li></ul><h1 id="swift类型？Swiift-值类型-和-引用类型的区别？特点？"><a href="#swift类型？Swiift-值类型-和-引用类型的区别？特点？" class="headerlink" title="swift类型？Swiift 值类型 和 引用类型的区别？特点？"></a>swift类型？Swiift 值类型 和 引用类型的区别？特点？</h1><ul><li><p>swift的类型分为 <code>值类型</code> 和 <code>引用类型</code>。</p><ul><li><p>值类型：在swift中定义的很多类型都是值类型：如 <code>struct、enum、Int、Float、Bool、String、Array、Dictionary、String</code> 等都是 <code>值类型</code>。</p></li><li><p>引用类型： <code>class类型、closure闭包、函数</code> 为引用类型</p></li></ul></li><li><p>区别</p><ul><li><p>值类型：<code>传递和赋值</code> 时是一个 <code>副本</code>，使用过程中不会影响 <code>源数据</code></p></li><li><p>引用类型：<code>传递和赋值</code> 是 <code>本身（内存地址）</code>，使用过程中会影响源数据</p></li></ul></li></ul><h1 id="常用的关键字"><a href="#常用的关键字" class="headerlink" title="常用的关键字"></a>常用的关键字</h1><ul><li><p>final：</p><ul><li>只能用于 <code>类</code> 中，修饰的 <code>方法、属性</code>，不能被重写</li><li><code>final</code> 修饰的类，不能被继承</li></ul></li><li><p>inout：输入输出形式参数</p><ul><li><code>将函数的参数由 值类型 转为 引用类型</code></li></ul></li><li><p>mutating：异变方法</p><ul><li>默认情况下结构体和枚举，不允许修改属性，可以在 <code>func</code> 前加 <code>mutating</code> 指定可以修改属性</li></ul></li><li><p>#available</p><ul><li>用来判断平台和操作系统</li></ul></li><li><p>@available</p><ul><li>用于修饰 方法、属性、协议、扩展，用来表达它的可用性</li></ul></li></ul><h1 id="闭包是什么？闭包作用？"><a href="#闭包是什么？闭包作用？" class="headerlink" title="闭包是什么？闭包作用？"></a>闭包是什么？闭包作用？</h1><ul><li><p>可以传递和引用的代码块</p></li><li><p>可以捕获和存储上下文的常量和变量</p></li><li><p>全局函数和内嵌函数时 <code>特殊的闭包</code></p></li></ul><h1 id="闭包的类型"><a href="#闭包的类型" class="headerlink" title="闭包的类型"></a>闭包的类型</h1><p>函数和闭包都是 <code>引用类型</code></p><ul><li><p>尾随闭包：闭包作为函数最后一个参数</p></li><li><p>逃逸闭包：函数返回之后调用 @escaping</p></li><li><p>自动闭包：延迟执行 @autoclosure</p></li></ul><h1 id="属性观察者"><a href="#属性观察者" class="headerlink" title="属性观察者"></a>属性观察者</h1><ul><li><p>willSet：会在该值被存储之前被调用，newValue</p></li><li><p>didSet：会在一个新值被存储之后被调用，oldValue</p></li></ul><h1 id="什么是扩展？作用？"><a href="#什么是扩展？作用？" class="headerlink" title="什么是扩展？作用？"></a>什么是扩展？作用？</h1><ul><li>扩展就是向一个 <code>已有类、结构体或枚举</code> 添加新功能</li><li>扩展可以向一个 <code>类型</code> 添加新的功能，不能重写已有的功能</li><li>添加 <code>属性（存储、计算），方法（实例方法、类方法），构造器，下标脚本，嵌套类型，协议</code>等。</li></ul><h1 id="什么是协议？作用？"><a href="#什么是协议？作用？" class="headerlink" title="什么是协议？作用？"></a>什么是协议？作用？</h1><ul><li>协议规定了 <code>用来实现某一特定功能所必须的方法和属性</code></li><li><code>类、结构体、枚举</code> 都可以遵循协议，提供具体的实现来完成协议定义的方法和功能</li><li>协议用于指定特定的 <code>实例属性或类属性</code>，而不用指定是 <code>存储属性或计算属性</code>，必须指定是只读还是可读可写</li></ul><h1 id="常用的三方框架"><a href="#常用的三方框架" class="headerlink" title="常用的三方框架"></a>常用的三方框架</h1><ul><li>Alamofire：网络加载</li><li>SwiftyJSON：JSON解析</li><li>R.swift：使用资源文件</li><li>Snapkit：自动布局</li><li>MonkeyKing：将内容分享到社交平台</li><li>Kingfisher：网络图片加载和缓存</li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS面试题：OC</title>
      <link href="/BboyZJ.github.io/2023/03/01/%E9%9D%A2%E8%AF%95%E9%A2%98/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AOC/"/>
      <url>/BboyZJ.github.io/2023/03/01/%E9%9D%A2%E8%AF%95%E9%A2%98/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AOC/</url>
      
        <content type="html"><![CDATA[<h1 id="OC算法"><a href="#OC算法" class="headerlink" title="OC算法"></a>OC算法</h1><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><p>1）依次比较相邻两个元素，顺序错误则交换位置；需要两层循环，外层循环控制趟数，内层循环控制比较次数</p><p>2）例子：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;5&quot;,@&quot;4&quot;]];</span><br><span class="line">    // 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">    for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序</span><br><span class="line">        for (int j = 0; j &lt; arr.count - i - 1; j++) &#123;</span><br><span class="line">            // 相邻元素比较，若逆序则交换</span><br><span class="line">            if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123;</span><br><span class="line">                [arr exchangeObjectAtIndex:j withObjectAtIndex:j + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h2><p>1）从第一个元素与其他元素比较找到最小值，重复操作，直到最后一位结束；需要两层循环，外层循环趟数，里层循环比较次数</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithObjects:@&quot;2&quot;,@&quot;1&quot;,@&quot;5&quot;,@&quot;3&quot;, nil];</span><br><span class="line">// 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">    // 里循环获比较换位</span><br><span class="line">    for (int j = i + 1; j &lt; arr.count; j ++) &#123;</span><br><span class="line">        if ([arr[i] intValue] &gt; [arr[j] intValue]) &#123;</span><br><span class="line">            [arr exchangeObjectAtIndex:i withObjectAtIndex:j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;arr:%@&quot;,arr);</span><br></pre></td></tr></table></figure></div><h2 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3. 直接插入排序"></a>3. 直接插入排序</h2><p>1） 始终定义第一个元素为 <code>已排序</code> 的，将剩余元素定义为 <code>未排序</code> 逐个插入到 <code>已排序</code> 的排列中；不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = @[@2,@1,@3,@5,@4].mutableCopy;</span><br><span class="line">// 插入排序的原理：始终定义第一个元素为有序的，将元素逐个插入到有序的排列中</span><br><span class="line">// 其特点是：不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去</span><br><span class="line">for(int i = 0;i &lt; arr.count;i++)&#123;</span><br><span class="line">    // 待排序值</span><br><span class="line">    NSNumber * temp = arr[i];</span><br><span class="line">    // 已排序下标</span><br><span class="line">    int j = i - 1;</span><br><span class="line">    // 待排序与已排序比较，从后向前比较</span><br><span class="line">    while (j &gt;= 0 &amp;&amp; [arr[j] integerValue] &gt; [temp integerValue]) &#123;</span><br><span class="line">        // 如果已排序的 &gt; 待排序的 往后移动一个位置</span><br><span class="line">        [arr replaceObjectAtIndex:(j + 1) withObject:arr[j]];</span><br><span class="line">        j --;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 空出来的位置插入新元素</span><br><span class="line">    [arr replaceObjectAtIndex:(j + 1) withObject:temp];</span><br><span class="line">    NSLog(@&quot;arr:%@&quot;,arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:26:19.242271+0800 插入排序[4184:77845] arr:(</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><p>1）希尔排序相当于 <code>直接插入排序加强版</code>，引入了 <code>增量</code> 的概念；直到增量为 <code>1</code> 时，再进行直接插入排序</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = @[@7,@3,@8,@5,@2,@6,@1,@4].mutableCopy;</span><br><span class="line">// 其实间隔值设值为总数的一半</span><br><span class="line">int gap = arr.count/2;</span><br><span class="line">// 直到间隔小于1时结束</span><br><span class="line">while (gap &gt;= 1) &#123;</span><br><span class="line">    // i 待排元素，以 步距 gap 从后向前扫描</span><br><span class="line">    for(int i = 0;i &lt; arr.count;i++)&#123;</span><br><span class="line">        // 待排元素</span><br><span class="line">        NSNumber * temp = arr[i];</span><br><span class="line">        // 当前位置</span><br><span class="line">        int j = i;</span><br><span class="line">        // 跳跃式比较</span><br><span class="line">        while (j &gt;= gap &amp;&amp; [arr[j - gap] integerValue] &gt; [temp integerValue] ) &#123;</span><br><span class="line">            [arr replaceObjectAtIndex:j withObject:arr[j - gap]];</span><br><span class="line">            j -= gap;</span><br><span class="line">        &#125;</span><br><span class="line">        // 空出来位置，插入待排序</span><br><span class="line">        [arr replaceObjectAtIndex:j withObject:temp];</span><br><span class="line">    &#125;</span><br><span class="line">    // 改变步长</span><br><span class="line">    gap = gap/2;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;arr:%@&quot;,arr);</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:22:41.910840+0800 插入排序[4124:74568] arr:(</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5,</span><br><span class="line">    6,</span><br><span class="line">    7,</span><br><span class="line">    8</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h2 id="5-斐波那契数列"><a href="#5-斐波那契数列" class="headerlink" title="5. 斐波那契数列"></a>5. 斐波那契数列</h2><p>1）也就是 <code>兔子数列</code>，当前数是前两个数列之和</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    NSInteger num = 10;</span><br><span class="line">    NSInteger total = [self getTotalNum:num];</span><br><span class="line">    NSLog(@&quot;total:%ld&quot;,total);</span><br><span class="line">&#125;</span><br><span class="line">- (NSInteger)getTotalNum:(NSInteger)num&#123;</span><br><span class="line">    if(num == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(num == 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return [self getTotalNum:num-2] + [self getTotalNum:num-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:28:32.672554+0800 斐波那契数列[4285:80606] total:89</span><br></pre></td></tr></table></figure></div><h2 id="6-二分查找"><a href="#6-二分查找" class="headerlink" title="6. 二分查找"></a>6. 二分查找</h2><p>1）<code>有序的数组</code>，将数组分割成两份，利用查找的值跟中间值进行比较，如果查找的值大于中间值，就在数组的右边进行查找；如果查找的值小于中间值，就在数组的左边进行查找。如此循环的执行下去，最终找到符合的值。</p><p>2）例子</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NSArray * arr = @[@(1),@(3),@(5),@(6),@(8),@(10)];</span><br><span class="line">int key = [@(5) intValue];</span><br><span class="line">int min = 0;</span><br><span class="line">int max = arr.count - 1;</span><br><span class="line">int mid;</span><br><span class="line">while (min &lt;= max) &#123;</span><br><span class="line">    // 计算中间下标</span><br><span class="line">    mid = (min + max) / 2;</span><br><span class="line">    // 如果目标值 &gt; 中间下标的中间值</span><br><span class="line">    if (key &gt; [arr[mid] intValue]) &#123;</span><br><span class="line">        //最小变为中间下标+1</span><br><span class="line">        min = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果目标值 &lt; 中间下标的中间值</span><br><span class="line">    else if (key &lt; [arr[mid] intValue])&#123;</span><br><span class="line">        //最大变为中间下标-1</span><br><span class="line">        max = max - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 否则，正好</span><br><span class="line">    else &#123;</span><br><span class="line">        NSLog(@&quot;key:%d&quot;,mid);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:33:18.661324+0800 二分查找[4607:86953] key:2</span><br></pre></td></tr></table></figure></div><h2 id="7-递归算法"><a href="#7-递归算法" class="headerlink" title="7. 递归算法"></a>7. 递归算法</h2><p>递归求和1+2+..+n?</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    int sum = [self sum:4];</span><br><span class="line">    NSLog(@&quot;sum:%d&quot;,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)sum:(int)n&#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return [self sum:n-1] + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><a href="http://www.bboyzj.cn/2020/08/09/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8E%A2%E7%B4%A2/">OC数据结构01：链表的探索</a></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p><a href="http://www.bboyzj.cn/2020/08/26/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%A2%E7%B4%A2/">OC数据结构02：二叉树探索</a></p><h1 id="OC常见的面试题"><a href="#OC常见的面试题" class="headerlink" title="OC常见的面试题"></a>OC常见的面试题</h1><h2 id="什么是野指针？"><a href="#什么是野指针？" class="headerlink" title="什么是野指针？"></a>什么是野指针？</h2><p>是一个没有指向 <code>任何内存</code> 的 <code>指针</code>，尝试使用它会导致 <code>应用程序崩溃</code></p><h2 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h2><p>一个 <code>对象</code> 没有被释放，会 <code>内存泄漏</code>，内存泄漏会导致应用程序占用的内存会越来越大，直到应用程序无内存可用时，会导致 <code>应用程序崩溃</code></p><h2 id="iOS-关键词有哪些？各有什么作用？-重点"><a href="#iOS-关键词有哪些？各有什么作用？-重点" class="headerlink" title="iOS 关键词有哪些？各有什么作用？ 重点"></a>iOS 关键词有哪些？各有什么作用？ <strong>重点</strong></h2><ul><li>readwrite</li></ul><p><code>可读可写</code> 特性，同时生成get方法和set方法的声明和实现</p><ul><li>readonly</li></ul><p><code>只读</code> 特性，只会生成get方法的声明和实现，不希望属性在类外改变</p><ul><li>retain</li></ul><p><code>持有</code> 特性，retaincount 会 +1,用于 <code>MRC</code></p><ul><li>nonatomic</li></ul><p><code>非原子</code> 特性</p><ul><li>atomic</li></ul><p><code>原子</code> 特性，默认属性</p><p>atomic不是绝对线程安全的，只是对 <code>setter/getter</code> 方法使用了 <code>自旋锁(spinlock_t)</code>，内部使用 <code>互斥锁(os_unfair_lock)</code>，保证了 <code>读/写</code> 安全。</p><p>atomic并不能保证 <code>整个对象</code> 是线程安全的，需要对 <code>整个对象</code> 进行 <code>加锁</code> 来保证线程安全：</p><pre><code>*  NSLock（互斥锁）*  dispathch_semaphore（信号量）*  @synchronized（互斥递归锁）</code></pre><ul><li>assign</li></ul><p>可以修饰 <code>基本数据类型和对象</code>。</p><p>通常用于修饰 <code>基本数据类型</code>，如Int、CGFloat、Double等，这是因为 <code>基本数据类型放在栈区</code>，栈由编译器自动分配和释放内存，栈先进后出，基本数据类型出栈后，assign修饰的基本数据类型就不存在了，不会出现 <code>野指针</code></p><p>修饰对象，如NSString、实例对象等，引用计数不会增加，但 <code>assign</code> 修饰对象释放后，<code>指针</code> 不会被系统置为nil，会产生 <code>野指针</code> 或 <code>EXC_BAD_ACCESS</code> 错误。</p><ul><li>strong</li></ul><p>强引用，<code>只修饰对象</code>，属性默认修饰符</p><p><code>指向并持有该对象</code>，其修饰的对象引用计数会 <code>+1</code>，引用计数不为 <code>0</code> 则不会被销毁，需要将其置为 <code>nil</code> 可以销毁。否则会出现 <code>内存泄漏</code>。</p><ul><li>weak</li></ul><p>弱引用，<code>只修饰对象</code>。</p><p><code>指向但并不拥有该对象</code>，引用计数不增加。该对象自动在内存中销毁。</p><ul><li>copy</li></ul><p>用于修饰 <code>不可变的对象</code>。</p><p>比如NSString、NSDictionary、NSArray等。</p><h2 id="浅拷贝和深拷贝-重点"><a href="#浅拷贝和深拷贝-重点" class="headerlink" title="浅拷贝和深拷贝 重点"></a>浅拷贝和深拷贝 <strong>重点</strong></h2><ul><li>浅拷贝</li></ul><p>浅拷贝，拷贝了一个新的指针，与原对象指针指向同一块内存，<code>引用计数 + 1</code>；(A,CopyA &#x3D; [A copy]，A 变化，CopyA 的值也变化)</p><ul><li>深拷贝</li></ul><p>深拷贝，拷贝了一个新的对象，指向新的内存，新对象的 <code>引用计数为 1</code>，源对象引用计数不变；(A,MutableA &#x3D; [A mutbleCopy]，A 变化，MutableA 的值不变)。</p><h2 id="NSString-x2F-NSArray-x2F-NSDictionary和NSMutableString-x2F-NSMutableArray-x2F-NSMutableDictionary-进行copy和mutableCopy区别？重点"><a href="#NSString-x2F-NSArray-x2F-NSDictionary和NSMutableString-x2F-NSMutableArray-x2F-NSMutableDictionary-进行copy和mutableCopy区别？重点" class="headerlink" title="NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？重点"></a>NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？<strong>重点</strong></h2><ul><li><p>对于不可变NSString&#x2F;NSArray&#x2F;NSDictionary，copy浅拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝)</p></li><li><p>对于可变NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary，copy深拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝)</p></li></ul><h2 id="自定义对象的copy和mutableCopy？-重点"><a href="#自定义对象的copy和mutableCopy？-重点" class="headerlink" title="自定义对象的copy和mutableCopy？ 重点"></a>自定义对象的copy和mutableCopy？ <strong>重点</strong></h2><ul><li>copy和mutableCopy都是深拷贝(属性：浅拷贝）</li></ul><h1 id="属性用copy还是strong？-重点"><a href="#属性用copy还是strong？-重点" class="headerlink" title="属性用copy还是strong？ 重点"></a>属性用copy还是strong？ <strong>重点</strong></h1><ul><li><p>对于不可变属性，推荐用copy，目的是为了 <code>让本属性不受外界影响</code>，无论给我传入可变还是不可变对象，我本身持有的就是一个不可变的副本，被set时，改变的是这个副本。</p></li><li><p>对于可变属性，推荐用strong，因为copy修饰后，会变成不可变对象，再调用可变对象函数时会 crash</p></li></ul><h2 id="一个APP是如何唤醒另一个APP的？-重点"><a href="#一个APP是如何唤醒另一个APP的？-重点" class="headerlink" title="一个APP是如何唤醒另一个APP的？ 重点"></a>一个APP是如何唤醒另一个APP的？ <strong>重点</strong></h2><p>URL Scheme：iOS有一个特性就是将 <code>自身绑定</code> 到一个自定义的 <code>URL Scheme</code> 上，该 <code>scheme</code> 用于从 <code>浏览器或其他应用中启动本应用</code>。</p><h2 id="单例的写法和作用？-重点"><a href="#单例的写法和作用？-重点" class="headerlink" title="单例的写法和作用？ 重点"></a>单例的写法和作用？ <strong>重点</strong></h2><p>单例模式的作用：可以保证程序运行过程中，一个类只返回一个实例，供外界访问；static保证类只分配一次内存；dispatch_once方法保证调用一次，并自动加锁，线程安全</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static id _instance = nil; // 定义static全局变量，保证只分配一次内存</span><br><span class="line">+ (id)shareInstance&#123;</span><br><span class="line">    return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">+ (id)copyWithZone:(struct _NSZone *)zone&#123;</span><br><span class="line">    static dispatch_once_t onceToken; // 声明一个静态的GcD单次任务</span><br><span class="line">    // 保证只执行一次</span><br><span class="line">    dispatch_once(&amp;onceToken,^&#123; // </span><br><span class="line">        _instance = [super allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这么写可以保证下面两种方式返回同一个实例：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Single * p1 = [Single shareInstance];</span><br><span class="line">Single * p2 = [[Single alloc] init];</span><br><span class="line">NSLog(@&quot;%d&quot;,p1==p2); // 1</span><br></pre></td></tr></table></figure></div><h2 id="HTTPS和HTTP的区别？-重点"><a href="#HTTPS和HTTP的区别？-重点" class="headerlink" title="HTTPS和HTTP的区别？ 重点"></a>HTTPS和HTTP的区别？ <strong>重点</strong></h2><ul><li><p>HTTP：超文本传输协议，信息明文传输；端口号80；响应速度快（使用TCP三次握手，客户端和服务端需要交换3个包）；</p></li><li><p>HTTPS：是由 HTTP+SSL&#x2F;TLS 加密传输；端口号443；响应速度慢（除了使用TCP三个包，还要加上SSL握手的9个包）；需要到CA申请证书</p></li></ul><h2 id="TCP-和-UDP-区别-重点"><a href="#TCP-和-UDP-区别-重点" class="headerlink" title="TCP 和 UDP 区别? 重点"></a>TCP 和 UDP 区别? <strong>重点</strong></h2><ul><li><p>都是 <code>传输层</code> 协议</p></li><li><p>TCP协议是 <code>面向连接的可靠的传输层协议</code>。UDP协议是 <code>面向非连接的传输层协议</code></p></li><li><p>TCP需要 <code>建立连接和断开连接</code>。UDP不需要连接。</p></li><li><p>TCP传 <code>输数据没有大小限制</code>。UDP <code>传输数据有大小限制</code>。</p></li><li><p>TCP会 <code>处理数据丢包重发</code>。UDP不会处理。</p></li></ul><h1 id="HTTP和socket区别？-重点"><a href="#HTTP和socket区别？-重点" class="headerlink" title="HTTP和socket区别？ 重点"></a>HTTP和socket区别？ <strong>重点</strong></h1><ul><li><code>HTTP</code> 应用层协议；<code>socket</code> 不属于协议范畴，而是一个接口（API），是对TCP&#x2F;IP协议的封装</li><li><code>HTTP</code> 是基于 <code>请求-响应</code> 形式 <code>短连接</code>，即客户端发送一次请求，服务端响应后立即 <code>断开连接</code>；socket 是基于TCP协议的 <code>长链接</code>，理论上 客户端和服务端一旦建立连接将不会主动断开</li><li>HTTP 传输慢，数据量大，安全差；socket 数据可自定义，数据量小，安全性高，适合信息实时交互（推送、聊天等）</li></ul><h2 id="staitc-和-const-的区别？-重点"><a href="#staitc-和-const-的区别？-重点" class="headerlink" title="staitc 和 const 的区别？ 重点"></a>staitc 和 const 的区别？ <strong>重点</strong></h2><ul><li><p>const：表示 <code>只读</code> 的意思</p><ul><li><p><code>const</code> 放在 <code>类型</code> 前：可以改变指针的指向，可以改变指针指向的内容</p></li><li><p><code>const</code> 放在 <code>变量</code> 前：不可以改变指针的指向，不可以改变指针指向的内容</p></li></ul></li><li><p>static： <code>静态变量</code>，可修饰 <code>局部变量和全局变量</code>，可修饰方法</p><ul><li><p><code>static</code> 可修饰 <code>局部/全局变量</code>，称为 <code>局部静态变量和全局静态变量</code>，只初始化一次，只分配一次内存，生命周期被改变，不再是作用域内</p></li><li><p><code>static</code> 修饰的 <code>方法</code>，可以在不同文件下重名，互不影响运行</p></li></ul></li></ul><h2 id="通用链接（Universal-Links）重点"><a href="#通用链接（Universal-Links）重点" class="headerlink" title="通用链接（Universal Links）重点"></a>通用链接（Universal Links）<strong>重点</strong></h2><ul><li><p>服务端配置 <code>HTTPS</code> 证书 和添加 <code>apple-app-site-association</code> 地址关联文件</p></li><li><p>移动端在plist添加 <code>Associated Domains</code> 关联域权限</p></li></ul><h2 id="简述GET和POST请求的区别？-重点"><a href="#简述GET和POST请求的区别？-重点" class="headerlink" title="简述GET和POST请求的区别？ 重点"></a>简述GET和POST请求的区别？ <strong>重点</strong></h2><ul><li><p>GET 传输数据 <code>有缓存</code>；POST 传输数据 <code>没有缓存</code></p></li><li><p>GET的 <code>参数</code> 放在 <code>URL</code> 的后面，并且第一个参数用 <code>?</code> 号拼接，后面的从第二个参数开始，直到最后一个，用 <code>&amp;</code> 分割；POST的 <code>参数</code> 放在 <code>请求体</code> 里面，并且第一个参数用 <code>,</code> 号拼接，后面从第二开始，直到最后用 <code>&amp;</code> 分割;</p></li><li><p>GET一般用于 <code>获取数据</code>；POST一般用于 <code>向服务器提交数据</code></p></li><li><p><code>GET</code> 的参数是暴漏在 <code>地址栏</code> 的，不安全；<code>POST</code> 的参数隐藏在 <code>请求体</code> 里面，相对安全一点;</p></li><li><p>GET请求提交数据受浏览器限制 <code>1k</code>，POST请求理论上无限制。</p></li></ul><h2 id="iOS中几种常见的设计模式？-重点"><a href="#iOS中几种常见的设计模式？-重点" class="headerlink" title="iOS中几种常见的设计模式？  重点"></a>iOS中几种常见的设计模式？  <strong>重点</strong></h2><ul><li><code>代理模式</code></li></ul><p>一对一的依赖关系，当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。</p><ul><li><code>观察者模式</code></li></ul><p>KVO机制 和 Notification通知机制</p><ul><li><code>单例模式</code></li></ul><p>保证程序运行过程中，一个类只返回一个实例，供外界访问</p><ul><li><code>工厂模式</code></li></ul><p>通过一个类方法，<code>根据已有模板批量生产对象</code>。</p><ul><li><code>MVC模式</code></li></ul><p>Model即数据模型</p><p>view即视图</p><p>controller即控制器</p><h2 id="RunLoop是什么？-重点"><a href="#RunLoop是什么？-重点" class="headerlink" title="RunLoop是什么？ 重点"></a>RunLoop是什么？ <strong>重点</strong></h2><ul><li>概念</li></ul><p><code>RunLoop</code> 又叫 <code>运行循环</code>，内部就是一个 <code>do-while循环</code>，在这个循环内部不断 <code>处理各种任务，保证程序持续运行</code>。</p><ul><li>目的</li></ul><p>RunLoop存在的目的： 就是当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，<code>提高程序性能，节省CPU资源</code>，该做事的时候做事，该休息的时候休息</p><h2 id="RunLoop的作用？-重点"><a href="#RunLoop的作用？-重点" class="headerlink" title="RunLoop的作用？ 重点"></a>RunLoop的作用？ <strong>重点</strong></h2><ul><li><p><code>保持程序持续运行</code>。<br> App一启动就会开启主线程，主线程在开启的时候就会开启主线程对应的RunLoop，RunLoop能保证线程不被销毁，主线程不销毁，程序就会持续运行。</p></li><li><p><code>处理App中各类事件</code>。<br> 事件响应、手势识别、界面刷新、AutoreleasePool自动释放池、NSTimer等事件处理。</p></li><li><p><code>节省CPU资源，提高程序性能</code>。<br> 如概述所述，当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，提高程序性能，节省资源，该做事的时候做事，该休息的时候休息。</p></li></ul><h2 id="可以用Runloop实现什么功能？-重点"><a href="#可以用Runloop实现什么功能？-重点" class="headerlink" title="可以用Runloop实现什么功能？ 重点"></a>可以用Runloop实现什么功能？ <strong>重点</strong></h2><ul><li>tableView 滚动时图片不加载</li></ul><p>SDWebImage + Runloop，图片延迟加载，滑动不加载图片</p><ul><li>线程保活</li></ul><p>往 <code>runloop</code> 中添加 <code>[[NSPort alloc] init]</code> 事件，</p><ul><li>解决NSTimer在滑动时停止工作的问题</li></ul><p><code>default</code> 模式改为 <code>common</code> 模式</p><ul><li>检测卡顿</li></ul><p><code>displaylink + runloop 进行卡顿检测，将数值和页面绑定上传到服务器</code></p><h2 id="RunLoop接收几种输入源，系统默认定义了几种模式？-重点"><a href="#RunLoop接收几种输入源，系统默认定义了几种模式？-重点" class="headerlink" title="RunLoop接收几种输入源，系统默认定义了几种模式？ 重点"></a>RunLoop接收几种输入源，系统默认定义了几种模式？ <strong>重点</strong></h2><ul><li><p>输入源有两种<br>基于 <code>端口</code> 的输入源（port）<br><code>自定义</code> 的输入源（custom）</p></li><li><p>系统定义的RunLoop模式有五种，最常用的有三种，如下所示：<br>NSDefaultRunLoopMode<br>默认模式，主线程中默认是NSDefaultRunLoopMode<br>UITrackingRunLoopMode<br>视图滚动模式，RunLoop会处于该模式下<br>NSRunLoopCommonModes<br>并不是真正意义上的Mode，是一个占位用的“Mode”，默认包含了NSDefaultRunLoopMode和UITrackingRunLoopMode两种模式</p></li></ul><h2 id="RunLoop和线程有什么关系？Runloop的mode-Runloop的作用？-重点"><a href="#RunLoop和线程有什么关系？Runloop的mode-Runloop的作用？-重点" class="headerlink" title="RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？ 重点"></a>RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？ <strong>重点</strong></h2><ul><li>每一个线程都有一个runloop，主线程的runloop默认启动。子线程的runloop默认不启动</li><li>mode：主要用来指定事件在运行时循环的优先级</li><li>作用：保持程序的持续运行、随时处理各种事件、节省cpu资源(没事件休息释放资源)，提高程序的性能。</li></ul><h2 id="怎么理解Objective-C是动态运行时语言。-重点"><a href="#怎么理解Objective-C是动态运行时语言。-重点" class="headerlink" title="怎么理解Objective-C是动态运行时语言。 重点"></a>怎么理解Objective-C是动态运行时语言。 <strong>重点</strong></h2><p>主要是 <code>将数据类型的确定和函数的调用由编译时推迟到了运行时</code>。这个问题其实浅涉及到两个概念，<code>运行时和多态</code>。</p><ul><li><p>运行时：简单来说，运行时机制使我们 <code>直到运行时才去确定数据类型和要调用的函数</code>。</p></li><li><p>多态：<code>不同对象以自己的方式响应相同的消息的能力</code> 叫做多态。</p></li></ul><h2 id="runtime项目中具体应用？-重点"><a href="#runtime项目中具体应用？-重点" class="headerlink" title="runtime项目中具体应用？ 重点"></a>runtime项目中具体应用？ <strong>重点</strong></h2><ul><li><code>方法交换</code>。</li><li>给 <code>分类添加属性</code>。 </li><li>动态添加方法。</li><li>字典转模型。</li><li>数组越界。</li><li>动态获取成员属性、成员变量、实例方法</li></ul><h2 id="KVC是什么？重点"><a href="#KVC是什么？重点" class="headerlink" title="KVC是什么？重点"></a>KVC是什么？<strong>重点</strong></h2><p><code>KVC</code> 全程 <code>Key Value Coding</code>，中文 <code>键值编码</code>，是由 <code>NSKeyValueCoding</code> 非正式协议启动的一种机制，<code>对象</code> 采用该协议来 <code>间接访问对象的属性</code>。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKey:(NSString *)key;     </span><br><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath; </span><br><span class="line"></span><br><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; </span><br></pre></td></tr></table></figure></div><p><a href="http://www.bboyzj.cn/2021/01/17/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8622%EF%BC%9AKVC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">KVC底层原理：</a></p><h2 id="KVO是什么？重点"><a href="#KVO是什么？重点" class="headerlink" title="KVO是什么？重点"></a>KVO是什么？<strong>重点</strong></h2><p><code>KVO</code> 全程 <code>Key Value Observing</code>，中文 <code>键值观察</code>，它 <code>用于监听实例对象属性的变化</code>。</p><h2 id="KVO的实现原理？-KVO的本质是什么？-重点"><a href="#KVO的实现原理？-KVO的本质是什么？-重点" class="headerlink" title="KVO的实现原理？(KVO的本质是什么？) 重点"></a>KVO的实现原理？(KVO的本质是什么？) <strong>重点</strong></h2><p>当一个 <code>实例对象</code> 的 <code>属性注册了KVO</code>，实例对象 <code>isa指针</code> 的指向在注册KVO观察者之后，由 <code>原有类</code> 改为 <code>中间类(NSKVONotifing_类名)</code>；<code>中间类</code> 重写了 <code>属性setter方法、class、dealloc、_isKVOA</code> 方法；<code>dealloc</code> 方法中，移除 <code>KVO</code> 观察者之后，实例对象isa 指向由 <code>中间类</code> 更改为 <code>原有类</code>;中间类 从创建后就 <code>一直存在内存中</code>，不会被销毁。</p><h2 id="KVO实际应用-重点"><a href="#KVO实际应用-重点" class="headerlink" title="KVO实际应用 重点"></a>KVO实际应用 <strong>重点</strong></h2><ul><li><p>观察 <code>实例对象</code> 的 <code>属性</code> 变化</p></li><li><p>观察 <code>实例对象</code> 的 <code>容器</code> 变化</p><p> 观察容器用： <code>mutableArrayValueForKey</code></p></li></ul><p><a href="http://www.bboyzj.cn/2021/01/25/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8623%EF%BC%9AKVO%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">KVO底层原理：</a> </p><h2 id="category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？重点"><a href="#category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？重点" class="headerlink" title="category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？重点"></a>category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？<strong>重点</strong></h2><ul><li><p><code>category</code> 原则上它 <code>只能增加方法</code>，<code>不能增加成员（实例）变量</code>。可以添加属性，但是不会自动生成实例变量_name和setter和getter方法。可以添加方法</p></li><li><p><code>扩展</code> 主要用来为一个类添加额外的原来没有的 <code>实例变量、方法和属性</code>。extension常用的形式并不是以一个单独的.h文件存在，而是寄生在类的.m文件中。</p></li></ul><p>类扩展中：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface Person ()&#123;</span><br><span class="line">    int age; //实例变量</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic,copy)NSString * name;//属性</span><br><span class="line">- (void)run;//方法</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><h2 id="iOS开发中有多少类型的线程？-重点"><a href="#iOS开发中有多少类型的线程？-重点" class="headerlink" title="iOS开发中有多少类型的线程？  重点"></a>iOS开发中有多少类型的线程？  <strong>重点</strong></h2><ul><li>pthread</li></ul><p>一套用于 <code>C</code> 的多线程 <code>API</code>、适用于 <code>Unix / Linux / Windows</code> 等系统、跨平台、可移植、使用难度大</p><ul><li>NSThread</li></ul><p>使用更加面向对象、简单易用，可直接操作线程对象</p><ul><li>GCD</li></ul><p>旨在替代NSThread等线程技术、充分利用设备的 <code>多核</code>、基于 <code>C</code> 的底层的 API</p><ul><li>NSOperation</li></ul><p><code>NSOperation</code> 是基于 <code>GCD</code> 之上的更高一层的封装， <code>NSOpetation</code> 需要配合 <code>NSOpetationQueue</code> 来实现多线程</p><h2 id="根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？-重点"><a href="#根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？-重点" class="headerlink" title="根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？  重点"></a>根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？  <strong>重点</strong></h2><p>dispatch_group_t + dispatch_group_enter + dispatch_group_leave + dispatch_group_notify</p><h2 id="10个网络请求顺序回调-GCD如何实现？重点"><a href="#10个网络请求顺序回调-GCD如何实现？重点" class="headerlink" title="10个网络请求顺序回调? GCD如何实现？重点"></a>10个网络请求顺序回调? GCD如何实现？<strong>重点</strong></h2><p>dispatch_group_t + dispatch_semaphore_t：信号量（dispatch_semaphore_wait + dispatch_group_leave）</p><h2 id="GCD和NSOperation的区别？-重点"><a href="#GCD和NSOperation的区别？-重点" class="headerlink" title="GCD和NSOperation的区别？ 重点"></a>GCD和NSOperation的区别？ <strong>重点</strong></h2><ul><li><code>GCD执行效率更高</code>，而且由于队列中执行的是由block构成的任务，这是一个轻量级的数据结构，写起来更方便</li><li>GCD只支持FIFO的队列，而 <code>NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序</code></li><li>NSOperationQueue甚至可以跨队列设置依赖关系，但是GCD只能通过设置串行队列，或者在队列内添加barrier(dispatch_barrier_async)任务，才能控制执行顺序,较为复杂</li><li><code>NSOperationQueue因为面向对象</code>，所以 <code>支持KVO</code>，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished）、是否取消（isCanceld）</li></ul><p>具体的底层看 <a href="http://www.bboyzj.cn/2021/03/23/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8627%EF%BC%9AGCD%E4%B9%8B%2520NSThread%2520&%2520GCD%2520&%2520NSOperation/">OC底层原理27：GCD之 NSThread &amp; GCD &amp; NSOperation</a></p><h2 id="什么是Block？-重点"><a href="#什么是Block？-重点" class="headerlink" title="什么是Block？ 重点"></a>什么是Block？ <strong>重点</strong></h2><p><code>Block</code> 是将 <code>函数及其上下文封装起来的对象</code></p><h2 id="Block的本质-重点"><a href="#Block的本质-重点" class="headerlink" title="Block的本质 重点"></a>Block的本质 <strong>重点</strong></h2><ul><li>block 的 <code>本质</code> 是 <code>对象、函数、结构</code>体，由于block函数没有名称，也被称为 <code>匿名函数</code></li></ul><h2 id="Block的分类？-重点"><a href="#Block的分类？-重点" class="headerlink" title="Block的分类？ 重点"></a>Block的分类？ <strong>重点</strong></h2><ul><li><p>分为 <code>全局Block(_NSConcreteGlobalBlock)、栈Block(_NSConcreteStackBlock)、堆Block(_NSConcreteMallocBlock)</code> 三种形式。</p></li><li><p>其中 <code>栈Block存储在栈(stack)区</code>，<code>堆Block存储在堆(heap)区</code>，<code>全局Block存储在已初始化数据(.data)区</code>。</p><ul><li>堆：动态分配内存，需要程序员自己申请，程序员自己管理</li><li>栈：自动分配内存，自动销毁，先入后出，栈上的内容存在自动销毁的情况</li></ul></li></ul><p>具体看底层原理 <a href="http://www.bboyzj.cn/2021/04/22/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8630%EF%BC%9ABlock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">OC底层原理30：Block底层原理</a></p><h1 id="循环引用的几种情况和解决方式？-重点"><a href="#循环引用的几种情况和解决方式？-重点" class="headerlink" title="循环引用的几种情况和解决方式？ 重点"></a>循环引用的几种情况和解决方式？ <strong>重点</strong></h1><ul><li>Block</li></ul><p>原因： <code>self</code> 强引用了 <code>block</code>，而 <code>block</code> 内部又调用了 <code>self</code><br>解决： 使用 <code>Weak-Strong Dance</code></p><ul><li>Delegate</li></ul><p>原因：委托者和被委托人之间的相互强引用问题 <code>strong</code><br>解决：用 <code>weak</code> 进行弱引用 <code>或者</code> 通过中间对象(代理对象)的方式来解决(效率更加高的中间对象NSProxy：不需要进行发送消息和动态解析，直接进行消息转发)</p><ul><li>NSTimer</li></ul><p>原因：self → timer → self(target) 的循环持有链<br>解决：在适当的时机销毁 </p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[_timer invalidate];</span><br><span class="line">_timer = nil;</span><br></pre></td></tr></table></figure></div><h1 id="OC-如何进行内存管理的？-重点"><a href="#OC-如何进行内存管理的？-重点" class="headerlink" title="OC 如何进行内存管理的？ 重点"></a>OC 如何进行内存管理的？ <strong>重点</strong></h1><ul><li><p>手动内存管理 MRC</p></li><li><p>自动内存管理 ARC</p><p>  LLVM + Runtime 会为我们代码自动插入 retain 和 release 以及 autorelease等代码,不需要我们手动管理</p></li><li><p>自动释放池</p></li></ul><h1 id="自动释放池原理-重点"><a href="#自动释放池原理-重点" class="headerlink" title="自动释放池原理 重点"></a>自动释放池原理 <strong>重点</strong></h1><ul><li><p>自动释放池的本质是 <code>__AtAutoreleasePool</code> 结构体，包含构造函数和析构函数</p></li><li><p>结构体声明，触发构造函数，调用 <code>objc_autoreleasePoolPush()</code> 函数，对象压栈</p></li><li><p>结构体出作用域，触发析构函数，调用 <code>objc_autoreleasePoolPop()</code> 函数，对象出栈</p></li></ul><h1 id="内存优化-重点"><a href="#内存优化-重点" class="headerlink" title="内存优化 重点"></a>内存优化 <strong>重点</strong></h1><ul><li>cell复用</li><li>绘制的话：用CAShaperLayer，渲染快，内存使用高效</li><li>按需加载：懒加载</li><li>合理利用缓存：比如三方图片压缩缓存</li><li>尽量使用透明View：控件有背景色增大内存消耗</li></ul><h1 id="启动优化-重点"><a href="#启动优化-重点" class="headerlink" title="启动优化 重点"></a>启动优化 <strong>重点</strong></h1><ul><li><p>pre-main 阶段：<code>二进制重排</code></p><ul><li><p>尽量 <code>少用外部动态库</code>，苹果官方建议自定义的动态库最好 <code>不要超过6个</code>，如果超过6个，需要 <code>合并</code> 动态库</p></li><li><p>减少 <code>OC</code> 类，因为类越多，越耗时</p></li><li><p>将不必须在 <code>+load</code> 方法中做的事情延迟到 <code>+initialize</code> 中，尽量不要用 <code>C++</code> 虚函数</p></li></ul></li><li><p>main 阶段：mian -&gt; didFinishLaunching</p><ul><li><p>减少启动初始化的流程，<code>能懒加载的懒加载，能延迟的延迟，能放后台初始化的放后台</code>，尽量少占用主线程的启动时间</p></li><li><p>优化代码逻辑，去除非必须的代码逻辑，减少每个流程的消耗时间</p></li><li><p>启动阶段能 <code>使用多线程</code> 来初始化的，就使用多线程</p></li><li><p>尽量 <code>使用纯代码</code> 来进行UI框架的搭建，尤其是主UI框架，例如 UITabBarController，尽量避免使用Xib或者SB，相比纯代码而言，这种更耗时</p></li><li><p>删除废弃类、方法</p></li></ul></li></ul><h2 id="卡顿监听-重点"><a href="#卡顿监听-重点" class="headerlink" title="卡顿监听 重点"></a>卡顿监听 <strong>重点</strong></h2><p><strong>主要是用 displayLink + Runloop 进行FPS监测</strong></p><p>主要从减轻 <code>CPU</code> 和 <code>GPU</code> 消耗入手，保证写一个 <code>VSync</code> 到来时，<code>CPU</code> 和 <code>GPU</code> 能够写作完成下一帧的渲染并缓存到帧缓冲区</p><ul><li>卡顿优化在 <code>CPU</code> 层面：</li></ul><p>1）尽量用轻量级的对象，比如 <code>用不到事件处理</code> 的地方，可以考虑使用 <code>CALayer</code> 取代 <code>UIView</code><br>2）不要频繁地调用 <code>UIView</code> 的相关属性，比如 <code>frame、bounds、transform</code> 等属性，尽量减少不必要的修改<br>3）尽量 <code>提前计算好布局</code>，在有需要时一次性调整对应的属性，不要多次修改属性<br>4）图片的 <code>size</code> 最好刚好跟 <code>UIImageView</code> 的 <code>size</code> 保持一致<br>5）<code>控制</code>一下线程的最大并发数量<br>6）尽量把 <code>耗时的操作放到子线程</code>：如text宽高获取等</p><ul><li>卡顿优化在 GPU层面：</li></ul><p>1）GPU能处理的 <code>最大纹理</code> 尺寸是 <code>4096x4096</code>，一旦超过这个尺寸，就会占用 <code>CPU</code> 资源进行处理，所以纹理尽量不要超过这个尺寸<br>2）尽量 <code>减少视图数量和层次</code><br>3）<code>减少透明的视图</code>（alpha&lt;1），不透明的就设置 <code>opaque</code> 为 <code>YES</code><br>4）尽量 <code>避免出现离屏渲染</code>：圆角、阴影、遮罩等</p><h2 id="tableView卡顿优化-重点"><a href="#tableView卡顿优化-重点" class="headerlink" title="tableView卡顿优化 重点"></a>tableView卡顿优化 <strong>重点</strong></h2><ul><li><p>最常用的就是<code>cell的复用</code>， 注册复用标识符</p></li><li><p><code>避免cell的重新布局</code>，初始化时就布局好</p></li><li><p><code>提前计算并缓存cell的高度</code></p></li><li><p><code>减少cell中控件的数量</code>，少动态添加 view</p></li><li><p><code>避免背景透明</code></p></li><li><p>能<code>使用局部更新</code> 的就使用 <code>局部更新</code></p></li><li><p>加载网络数据，<code>下载图片，使用异步加载</code>，并缓存</p></li><li><p><code>按需加载cell</code>：cell滚动很快时，只加载范围内的cell</p></li><li><p><code>不要实现无用的代理方法</code>，tableView只遵守两个协议</p></li></ul><h1 id="网络优化-重点"><a href="#网络优化-重点" class="headerlink" title="网络优化 重点"></a>网络优化 <strong>重点</strong></h1><ul><li>DNS优化：即域名解析优化，缓存 <code>ip</code></li><li>资源优化：<ul><li>图片webp，比png&#x2F;jpg小</li><li>数据传输用ProtocolBuffer代替json，数据小，序列化和反序列化也简单</li></ul></li><li>请求压缩、请求合并</li><li>数据缓存</li><li>网络环境监测<ul><li>针对性请求重试</li></ul></li></ul><h2 id="TCP三次握手，四次挥手过程？重点"><a href="#TCP三次握手，四次挥手过程？重点" class="headerlink" title="TCP三次握手，四次挥手过程？重点"></a>TCP三次握手，四次挥手过程？<strong>重点</strong></h2><ol><li>为什么是三次握手，而不是二次握手？</li></ol><p>三次握手是为了建立一个可靠的数据传输通道：</p><ul><li><p>刚开始客户端和服务端处于关闭状态，而且服务端B一直处于监听状态，时刻监听是否有建立连接的请求</p></li><li><p>当客户端需要建立连接的时候就会发送一个 <code>请求连接</code> 的报文，此报文是 <code>同步报文SYN=1</code>，并且会生成一个 <code>随机的序号seq=x</code>，这是第一次握手</p></li><li><p>当服务端接收到请求连接报文时，会发送一个 <code>确认连接</code> 的报文，此报文是 <code>同步报文SYN=1</code>，并且 <code>确认报文ACK=1</code>，同时服务端也会生成一个 <code>随机的序号seq=y</code>，并且将 <code>确认报文确认号ack=x+1</code>，回传给客户端，这是第二次握手</p></li><li><p>当客户端接收到服务端的 <code>ACK确认报文后</code>，会回复一个 <code>ACK确认报文</code>，用于确认确认报文已经收到，此报文 <code>ACK=1，seq=x+1，ack=y+1</code>，这是第三次握手</p></li></ul><ol start="2"><li>四次挥手</li></ol><p>四次挥手则是为了保证数据传输完成接收再关闭连接。</p><ul><li><p>客户端断开连接时会发送一个 <code>请求断开连接</code> 的报文，此报文是 <code>FIN=1</code>，并且会生成一个 <code>随机的序号seq=u</code>，发送给服务端，这是第一次挥手</p></li><li><p>服务端接收到请求断开连接 <code>FIN报文</code> 后，回复一个 <code>确认断开连接</code> 报文 <code>ACK=1,seq=v,ack=u+1</code>，这是第二次挥手</p></li><li><p>当服务端数据发送完后，再发送一个FIN报文给客户端，通知客户端，服务端准备关闭连接，此报文 <code>FIN=1,ACK=1,ack=u+1,seq=w</code>，这是第三次挥手</p></li><li><p>当客户端收到 <code>FIN确认报文</code>，再发送一个FIN确认报文 <code>ACK=1,seq=u+1,ack=w+1</code>，并进入<code> TIME-WAIT</code> 等待，等待 <code>2MSL</code> 后关闭连接，这是第四次挥手</p></li></ul><h1 id="事件链-重点"><a href="#事件链-重点" class="headerlink" title="事件链 重点"></a>事件链 <strong>重点</strong></h1><p><a href="https://www.bboyzj.cn/2023/03/01/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/">OC学习01：事件传递链和响应链</a></p><ul><li><p>传递链：由系统向离用户最近的view传递。<br>顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; ViewController -&gt; subViews</p></li><li><p>响应链：由离用户最近的view向系统传递。<br>顺序： superViews –&gt; ViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate</p></li></ul><h1 id="事件传递的两个核心方法？-重点"><a href="#事件传递的两个核心方法？-重点" class="headerlink" title="事件传递的两个核心方法？ 重点"></a>事件传递的两个核心方法？ <strong>重点</strong></h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 返回最适合处理事件的视图</span><br><span class="line">- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;  </span><br><span class="line">// 判断点是否在这个View内部</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;</span><br></pre></td></tr></table></figure></div><ul><li>第一个方法返回的是一个 <code>UIView</code>，是用来寻找最终哪一个视图来响应这个事件</li><li>第二个方法是用来判断某一个点击的位置是否在视图范围内，如果在就返回YES</li></ul><h1 id="实现一个按钮的点击范围扩大效果-重点"><a href="#实现一个按钮的点击范围扩大效果-重点" class="headerlink" title="实现一个按钮的点击范围扩大效果 重点"></a>实现一个按钮的点击范围扩大效果 <strong>重点</strong></h1><p>自定义一个按钮，继承UIButton，重写 <code>pointInside:withEvent:</code> 方法，</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 当前btn大小</span><br><span class="line">    CGRect btnBounds = self.bounds;</span><br><span class="line">    // 扩大按钮的点击范围，增大内边距</span><br><span class="line">    btnBounds = CGRectInset(btnBounds, -10, -10);</span><br><span class="line">    // 若点击的点在新的bounds里，返回YES</span><br><span class="line">    return CGRectContainsPoint(btnBounds, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="子视图超过父视图部分仍然能响应-重点"><a href="#子视图超过父视图部分仍然能响应-重点" class="headerlink" title="子视图超过父视图部分仍然能响应 重点"></a>子视图超过父视图部分仍然能响应 <strong>重点</strong></h1><p>重写 <code>hitTest:withEvent</code> 方法，让 <code>子视图</code> 去相应事件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 判断btn能否接收事件</span><br><span class="line">    if (self.btn.userInteractionEnabled == NO || self.btn.hidden == YES || self.btn.alpha &lt;= 0.01) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 把当前点转换成btn坐标系上的点</span><br><span class="line">    CGPoint btnP = [self convertPoint:point toView:self.btn];</span><br><span class="line">    // 当触摸点在btn上时，才让按钮相应事件</span><br><span class="line">    if ([self.btn pointInside:btnP withEvent:event]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,NSStringFromCGPoint(btnP));</span><br><span class="line">        return self.btn;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;父视图相应&quot;);</span><br><span class="line">    return [super hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="面试官问还有什么想问的？-重点"><a href="#面试官问还有什么想问的？-重点" class="headerlink" title="面试官问还有什么想问的？ 重点"></a>面试官问还有什么想问的？ <strong>重点</strong></h1><p>技术面不问薪资待遇，人事面问薪资待遇</p><ul><li>问岗位：</li></ul><ol><li>在这个岗位上，会直接 <code>接触到哪些类型的项目？</code></li><li>这个岗位的主要职责是什么？主要的KPI是什么？</li><li>这个岗位如何评估绩效，试用期需要达到什么指标？</li><li>这个岗位的最大挑战是什么？</li></ol><ul><li>问团队：</li></ul><ol><li><code>团队的基本情况？</code></li><li>这个团队在公司的角色是什么？</li><li>可以跟我介绍一下我的领导吗？</li></ol><ul><li>问公司</li></ul><ol><li><code>公司的文化氛围是什么样的？</code></li><li>员工的晋升机制是什么样的？我这个岗位的晋升机会如何？</li><li>这个岗位所在的团队如何支持公司目标的实现？</li></ol>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog-04：主题完善</title>
      <link href="/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-04%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/"/>
      <url>/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-04%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们以 <a class="link"   href="https://github.com/shenliyang/hexo-theme-snippet" >Snippet <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 主题问例</p><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ git clone git://github.com/shenliyang/hexo-theme-snippet.git themes/hexo-theme-snippet</span><br></pre></td></tr></table></figure></div><h1 id="安装主题插件"><a href="#安装主题插件" class="headerlink" title="安装主题插件"></a>安装主题插件</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S</span><br></pre></td></tr></table></figure></div><h1 id="部署主题"><a href="#部署主题" class="headerlink" title="部署主题"></a>部署主题</h1><p>具体部署看下面的链接：1、2、3步骤可省略</p><p><a class="link"   href="https://github.com/shenliyang/hexo-theme-snippet" >Snippet <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog-03：Github域名绑定阿里云域名</title>
      <link href="/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-03%EF%BC%9AGithub%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/"/>
      <url>/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-03%EF%BC%9AGithub%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="注册域名"><a href="#注册域名" class="headerlink" title="注册域名"></a>注册域名</h1><p>去 <a class="link"   href="https://dc.console.aliyun.com/" >阿里云 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 注册账号、并购买域名，具体流程这里就不一一介绍了</p><h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><ul><li>在终端 <code>ping</code> 一下之前配置的静态页面地址,可以获取到对应的ip地址:</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % ping BboyZJ.github.io</span><br><span class="line">PING bboyzj.github.io (185.199.109.153): 56 data bytes</span><br><span class="line">64 bytes from 185.199.109.153: icmp_seq=0 ttl=50 time=261.217 ms</span><br><span class="line">64 bytes from 185.199.109.153: icmp_seq=1 ttl=50 time=337.547 ms</span><br><span class="line">64 bytes from 185.199.109.153: icmp_seq=2 ttl=50 time=260.716 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><ul><li>@解析</li></ul><p>记录类型：A<br>主机记录：@<br>解析请求来源：默认<br>记录值：185.199.109.153<br>TTL：10分钟</p><p>点击确定</p><ul><li>www解析</li></ul><p>记录类型：CNAME<br>主机记录：www<br>解析线路来源：默认<br>记录值：BboyZJ.github.io<br>TTL：10分钟</p><p>点击确定</p><ul><li>配置项目 <code>CNAME</code></li></ul><p>在 <code>Blog/source</code> 目录下，新建 <code>CNAME</code> 文件，内容输入阿里云申请的域名 <a href="http://www.bboyzj.cn/">www.bboyzj.cn</a></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/Blog/source </span><br><span class="line">mac@bogon source % touch CNAME</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16776380930111.jpg"                      alt="16776380930111"                ></p><ul><li>配置 <code>Blog</code> 目录下 <code>_config.yml</code> 文件，<code>URL</code> 模块</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="line">url: https://www.bboyzj.cn</span><br><span class="line">root: /BboyZJ.github.io/</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></pre></td></tr></table></figure></div><ul><li>执行</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % hexo clean</span><br><span class="line">mac@bogon ~ % hexo g</span><br><span class="line">mac@bogon ~ % hexo d</span><br></pre></td></tr></table></figure></div><p>提交陈成功后，就可以在 <code>GitHub</code> 和 <a href="http://www.bboyzj.cn/">www.bboyzj.cn</a> 个人域名绑定上了</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog-02：部署博客到GitHub</title>
      <link href="/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-02%EF%BC%9A%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0GitHub/"/>
      <url>/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-02%EF%BC%9A%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0GitHub/</url>
      
        <content type="html"><![CDATA[<h1 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h1><p>前往 <a class="link"   href="https://github.com/" >Github <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 网站，注册一个新用户。用邮箱注册的一定前往邮箱去验证邮件。</p><h1 id="部署到-GitHub-上"><a href="#部署到-GitHub-上" class="headerlink" title="部署到 GitHub 上"></a>部署到 GitHub 上</h1><ul><li>新建 <code>reponsity</code> 仓库</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012145840.png"                                     ></p><p>仓库名设置成 <code>用户名.github.io</code> ，比如我的是 <code>BboyZJ.github.io</code>，选择 Public，勾选 <code>Add a README file</code> ，最后 <code>Create respository</code></p><h1 id="配置秘钥"><a href="#配置秘钥" class="headerlink" title="配置秘钥"></a>配置秘钥</h1><ul><li>查看秘钥</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">$ cat id_rsa.pub</span><br></pre></td></tr></table></figure></div><ul><li>添加SSH秘钥：头像 -&gt; Setting -&gt; SSH and GPG keys</li></ul><p><code>Title</code> 随意写，<code>Key</code> 需要填写刚才复制的 <code>秘钥</code> 文本内容</p><ul><li>添加完成，验证链接</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">Hi BboyZJ! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></div><h1 id="上传文件到-GitHub"><a href="#上传文件到-GitHub" class="headerlink" title="上传文件到 GitHub"></a>上传文件到 GitHub</h1><ul><li>配置 <code>Blog</code> 下 <code>_config.yml</code> 中的 <code>Deployment</code> 模块</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/BboyZJ/BboyZJ.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></div><ul><li>安装部署插件</li></ul><p>通过 Hexo 发布到 GitHub，需要安装部署插件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></div><ul><li>部署</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/Blog</span><br><span class="line">mac@bogon ~ % hexo g</span><br><span class="line">mac@bogon ~ % hexo d</span><br></pre></td></tr></table></figure></div><ul><li>访问</li></ul><p>这时我们的 <code>GitHub</code> 域名 <code>https://BboyZJ.github.io</code> 就可以看到 <code>Hexo</code> 网站了，如果没显示出来就 <code>刷新</code> 一下</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog-01：Hexo个人博客搭建</title>
      <link href="/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-01%EF%BC%9AHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-01%EF%BC%9AHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><ul><li>什么是Hexo？</li></ul><p>简介：<code>Hexo</code> 是一个快速、简洁且高效的博客框架。想要详细的了解 <a class="link"   href="https://hexo.io/zh-cn/docs/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，去官网学习。<code>Hexo</code> 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h1 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h1><ul><li>检查是否安装 <code>homebrew</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % brew -v</span><br><span class="line">Homebrew 3.6.21-28-ge6548a8</span><br><span class="line">Homebrew/homebrew-core (git revision 5434c8344e8; last commit 2023-02-09)</span><br><span class="line">Homebrew/homebrew-cask (git revision 15c2c1fa53; last commit 2023-02-09)</span><br><span class="line">mac@bogon ~ % </span><br></pre></td></tr></table></figure></div><p>如果顺利显示版本号，说明homebrew已经安装。否则，输入以下命令进行安装：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></div><ul><li>安装过程如果出现下面的问题</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</span><br></pre></td></tr></table></figure></div><p>解决:</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % /usr/bin/ruby -e &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)&quot;</span><br></pre></td></tr></table></figure></div><ul><li>安装 <code>Node.js</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % brew install node</span><br><span class="line">mac@bogon ~ % node -v</span><br><span class="line">v18.14.2</span><br></pre></td></tr></table></figure></div><ol start="3"><li>安装Git<br>Mac系统默认已经安装好了，所以不需要再安装</li></ol><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往安装 <code>Hexo</code> 步骤。</p><ul><li>使用npm完成 <code>hexo</code> 安装</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % npm install -g hexo-cli</span><br><span class="line">mac@bogon ~ % hexo -v</span><br><span class="line"></span><br><span class="line">hexo-cli: 4.1.0</span><br><span class="line">os: Darwin 21.6.0 darwin x64</span><br><span class="line">node: 12.16.1</span><br><span class="line">v8: 7.8.279.23-node.31</span><br><span class="line">uv: 1.34.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.7</span><br><span class="line">ares: 1.15.0</span><br><span class="line">modules: 72</span><br><span class="line">nghttp2: 1.40.0</span><br><span class="line">napi: 5</span><br><span class="line">llhttp: 2.0.4</span><br><span class="line">http_parser: 2.9.3</span><br><span class="line">openssl: 1.1.1d</span><br><span class="line">cldr: 35.1</span><br><span class="line">icu: 64.2</span><br><span class="line">tz: 2019c</span><br><span class="line">unicode: 12.1</span><br><span class="line">mac@bogon ~ % </span><br></pre></td></tr></table></figure></div><h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><ul><li>桌面新建 <code>Blog</code> 文件夹，打开终端，cd到 <code>Blog</code> 下，执行:</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/Blog </span><br><span class="line">mac@bogon Blog % hexo init</span><br><span class="line"></span><br><span class="line">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class="line">INFO  Install dependencies</span><br><span class="line">npm notice </span><br><span class="line">npm notice New major version of npm available! 7.3.0 -&gt; 9.5.1</span><br><span class="line">npm notice Changelog: https://github.com/npm/cli/releases/tag/v9.5.1</span><br><span class="line">npm notice Run npm install -g npm@9.5.1 to update!</span><br><span class="line">npm notice </span><br><span class="line">INFO  Start blogging with Hexo!</span><br><span class="line">mac@bogon Blog % </span><br></pre></td></tr></table></figure></div><p>【目录文件】：</p><p>_config.landscape.yml：网站本地配置信息<br>_config.yml：网站的配置信息，可以在此配置大部分的参数<br>source–posts：存放 <code>md</code> 文件<br>themes：主题文件夹，<a class="link"   href="https://hexo.io/themes/%20" >常用主题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 会放入这里<br>public：Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去</p><h1 id="hexo-测试"><a href="#hexo-测试" class="headerlink" title="hexo 测试"></a>hexo 测试</h1><ul><li>生成静态页面</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % hexo g</span><br></pre></td></tr></table></figure></div><p>会在根目录 <code>Blog\</code> 下生成 <code>public</code> 文件夹，里面包含相应的 <code>html</code> 页面。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012142095.png"                                     ></p><ul><li>启动服务器</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % hexo s</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012143213.png"                                     ></p><p>打开浏览器，输入网址: <a class="link"   href="http://localhost:4000/" >http://localhost:4000 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，即可看到hexo生成的静态页面。</p><ul><li>停止服务器</li></ul><p><code>Ctrl + C</code></p><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>hexo提供了很多主题可以参考，下面以 <a class="link"   href="https://github.com/littlewin-wang/hexo-theme-casual.git" >hexo-theme-casual <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 主题为例</p><ul><li>安装主题插件</li></ul><blockquote><p><a class="link"   href="https://github.com/EvanNotFound/hexo-theme-redefine" >hexo-theme-redefine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure></div><blockquote><p><a class="link"   href="https://github.com/littlewin-wang/hexo-theme-casual" >hexo-theme-casual <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ npm install --save hexo-renderer-jade hexo-renderer-scss hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-generator-search</span><br></pre></td></tr></table></figure></div><blockquote><p> <a class="link"   href="https://github.com/shenliyang/hexo-theme-snippet" >hexo-theme-snippet <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S</span><br></pre></td></tr></table></figure></div><blockquote><p><a class="link"   href="https://github.com/jerryc127/hexo-theme-butterfly" >hexo-theme-butterfly <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line">mac@bogon Blog % $ npm install hexo-renderer-pug hexo-renderer-stylus</span><br></pre></td></tr></table></figure></div><ul><li>下载主题</li></ul><p>进入主题的 <code>github</code> 下载页，点击 <code>code -&gt; clone</code>，复制 <code>https</code> 下载链接，进入 博库Blog目录，运行下面的命令：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % cd /Users/mac/Desktop/Blog </span><br><span class="line">mac@bogon Blog % cd themes </span><br><span class="line">mac@bogon themes % git clone https://github.com/littlewin-wang/hexo-theme-casual.git</span><br></pre></td></tr></table></figure></div><p>【注】：主题存放的目录是 <code>Blog/themes</code>，为了方便管理，每一个下载的主题都建一个单独的目录，我这个主题的目录是 <code>hexo-theme-casual</code>，可以下载多个主题:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303012144981.png"                                     ></p><ul><li>主题应用</li></ul><p>找到 <code>博客Blog</code> 目录下的配置文件 <code>_config.yml</code>，找到 <code>Extensions</code> 模块，修改 <code>theme</code> 字段：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: hexo-theme-casual</span><br></pre></td></tr></table></figure></div><ul><li>启动本地服务器</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % hexo s</span><br><span class="line"></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br><span class="line">[Browsersync] Access URLs:</span><br><span class="line"> ----------------------------------</span><br><span class="line">          UI: http://localhost:3001</span><br><span class="line"> ----------------------------------</span><br><span class="line"> UI External: http://localhost:3001</span><br><span class="line"> ----------------------------------</span><br></pre></td></tr></table></figure></div><ul><li>查看效果</li></ul><p>通过 <a class="link"   href="http://localhost:4000/" >http://localhost:4000/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 查看修改后的效果</p><ul><li>主题更新</li></ul><p>这一步不是必须的，如果主题有优化，我们需要在本地同步更新一下</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % /Users/mac/Desktop/Blog/themes/casual </span><br><span class="line">mac@bogon Blog % git pull</span><br></pre></td></tr></table></figure></div><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><ul><li>清除旧的内容</li></ul><p><code>hexo clean</code></p><ul><li>生成静态发布页面</li></ul><p><code>hexo g</code></p><ul><li>发布页面</li></ul><p><code>hexo d</code></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习25：Swift中的模式和模式匹配</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A025%EF%BC%9ASwift%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A025%EF%BC%9ASwift%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><ul><li><p>模式代表 <code>单个值或复合值</code> 的 <code>结构</code>，</p></li><li><p>可以用模式来匹配各种各样的值，例如：(x,y) 匹配 元组(1,2)</p></li><li><p>可以从复合值中取出部分或全部值，然后把值绑定一个常量或变量，例如：(let x,y) 提取 (1,2)</p></li></ul><h1 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h1><p><code>Swift</code> 中模式分为两类： <code>一种能成功匹配任何类型的值</code>；<code>另一种在运行时匹配某个特定值可能会失败</code></p><ul><li><p>第一种模式用于解构简单的常量、变量和可选绑定中的值</p></li><li><p>第二种模式用于全模式匹配。</p></li></ul><p>模式分类：</p><ul><li>通配符模式（Wildcard Pattern）</li><li>标识符模式（Identifier Pattern）</li><li>值绑定模式（Value-Binding Pattern）</li><li>元组模式（Tuple Pattern）</li><li>枚举用例模式（Enumeratinal Case Pattern）</li><li>可选项模式（Optional Pattern）</li><li>类型转换模式（Type-Casting Pattern）</li><li>表达式模式（Expression Pattern）</li></ul><h1 id="通配符模式（Wildcard-Pattern）"><a href="#通配符模式（Wildcard-Pattern）" class="headerlink" title="通配符模式（Wildcard Pattern）"></a>通配符模式（Wildcard Pattern）</h1><ul><li>通配符模式（Wildcard Pattern） 用一个下划线 <code>_</code> 构成，用于匹配并忽略任何职</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for _ in 1...3 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="标识符模式（Identifier-Pattern）"><a href="#标识符模式（Identifier-Pattern）" class="headerlink" title="标识符模式（Identifier Pattern）"></a>标识符模式（Identifier Pattern）</h1><ul><li>标识符模式匹配任何值，并将匹配的值和一个变量或常量绑定起来</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let someValue = 42</span><br></pre></td></tr></table></figure></div><h1 id="值绑定模式（Value-Binding-Pattern）"><a href="#值绑定模式（Value-Binding-Pattern）" class="headerlink" title="值绑定模式（Value-Binding Pattern）"></a>值绑定模式（Value-Binding Pattern）</h1><ul><li>把匹配到的值绑定给一个 <code>变量let或常量var</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let point = (2,3)</span><br><span class="line">switch point &#123;</span><br><span class="line">// 将 point 中的元素绑定到 x 和 y</span><br><span class="line">case let (x,y):</span><br><span class="line">    print(&quot;\(x),\(y)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="元组模式（Tuple-Pattern）"><a href="#元组模式（Tuple-Pattern）" class="headerlink" title="元组模式（Tuple Pattern）"></a>元组模式（Tuple Pattern）</h1><ul><li>元组模式由逗号分割，具有零个或多个模式的列表，由一对圆括号括起来。</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let points = [(0,0),(0,1),(1,1)]</span><br><span class="line">for (x,0) in points &#123;</span><br><span class="line">    print(&quot;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="枚举用例模式（Enumeratinal-Case-Pattern）"><a href="#枚举用例模式（Enumeratinal-Case-Pattern）" class="headerlink" title="枚举用例模式（Enumeratinal Case Pattern）"></a>枚举用例模式（Enumeratinal Case Pattern）</h1><ul><li>匹配现有某个枚举类型的某个用例，体现在 <code>switch</code> 中 <code>case</code> 标签中，及 <code>if、while、guard </code>和 <code>for in</code> 的 <code>case</code> 中</li></ul><h1 id="可选项模式（Optional-Pattern）"><a href="#可选项模式（Optional-Pattern）" class="headerlink" title="可选项模式（Optional Pattern）"></a>可选项模式（Optional Pattern）</h1><ul><li><p>匹配 <code>Optional&lt;Wrapped&gt;</code> 枚举在 <code>some&lt;Wrapped&gt;</code> 中包装的值</p></li><li><p>可选项模式为 <code>for in</code> 语句提供了一种迭代数组的简便方式，只为数组中的非 <code>nil</code> 元素执行循环体</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let someNum: Int? = 10</span><br><span class="line">if case .some(let x) = someNum &#123;</span><br><span class="line">    print(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if case let x? = someNum &#123;</span><br><span class="line">    print(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032228371.png"                                     ></p><h1 id="类型转换模式（Type-Casting-Pattern）"><a href="#类型转换模式（Type-Casting-Pattern）" class="headerlink" title="类型转换模式（Type-Casting Pattern）"></a>类型转换模式（Type-Casting Pattern）</h1><ul><li><p>有两种：<code>is模式</code> 和 <code>as模式</code>，<code>is</code> 模式只出现在 <code>switch</code> 语句 <code>case</code> 标签中</p><ul><li><p><code>is</code> 类型：仅当一个值类型在运行时和 <code>is模式</code> 右边指定的类型一致，或子类下，才匹配值，没有返回类型</p></li><li><p>模式 <code>as</code> 类型：仅当一个值类型在运行时和 <code>as模式</code> 右边指定的类型一致，或子类下，才匹配值，如果匹配成功，被转换成 <code>as模式右边指定的类型</code></p></li></ul></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protocol Animal &#123;</span><br><span class="line">    var name:String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Dog:Animal &#123;</span><br><span class="line">    var name:String &#123;</span><br><span class="line">        return &quot;dog&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    var runSpeed:Int</span><br><span class="line">&#125;</span><br><span class="line">struct Bird:Animal &#123;</span><br><span class="line">    var name:String&#123;</span><br><span class="line">        return &quot;bird&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    var flightHeight:Int</span><br><span class="line">&#125;</span><br><span class="line">let animals:[Any] = [Dog(runSpeed:40),Bird(flightHeight:500)]</span><br><span class="line">for animal in animals &#123;</span><br><span class="line">    switch animal&#123;</span><br><span class="line">    case let dog as Dog:</span><br><span class="line">        print(&quot;\(dog.name) run at \(dog.runSpeed)&quot;)</span><br><span class="line">    case let bird as Bird:</span><br><span class="line">        print(&quot;\(bird.name) swip at \(bird.flightHeight)&quot;)</span><br><span class="line">    default:</span><br><span class="line">         break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032230668.png"                                     ></p><h1 id="表达式模式（Expression-Pattern）"><a href="#表达式模式（Expression-Pattern）" class="headerlink" title="表达式模式（Expression Pattern）"></a>表达式模式（Expression Pattern）</h1><ul><li><p>表达式模式代表表达式的值，只出现在 <code>switch</code> 语句中的 <code>case</code> 标签中</p></li><li><p>可重载 <code>~=</code> 运算符来提供自定义的表达式匹配行为</p></li><li><p><code>自定义类或结构体类型</code> 默认也是无法进行表达式模式匹配的，也需要重载 <code>~=</code> 运算符</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Employee&#123;</span><br><span class="line">    var salary:Int</span><br><span class="line">&#125;</span><br><span class="line">func ~= (left:ClosedRange&lt;Int&gt;,right:Employee) -&gt; Bool&#123;</span><br><span class="line">    return left.contains(right.salary)</span><br><span class="line">&#125;</span><br><span class="line">var e: Employee = Employee(salary:2000)</span><br><span class="line">switch e&#123;</span><br><span class="line">case 0...1000:</span><br><span class="line">    print(&quot;吃不饱&quot;)</span><br><span class="line">case 1000...5000:</span><br><span class="line">    print(&quot;勉强度日&quot;)</span><br><span class="line">default:</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032232137.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习24：如何在Swift里面进行控制转移</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A024%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8Swift%E9%87%8C%E9%9D%A2%E8%BF%9B%E8%A1%8C%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A024%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8Swift%E9%87%8C%E9%9D%A2%E8%BF%9B%E8%A1%8C%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="控制转移"><a href="#控制转移" class="headerlink" title="控制转移"></a>控制转移</h1><ul><li><p>continue </p></li><li><p>break</p></li><li><p>fallthrough</p></li><li><p>return</p></li><li><p>throw</p></li></ul><h1 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h1><ul><li>continue 告诉我不再继续当前循环遍历了，再次从头开始下一次遍历</li></ul><h1 id="break"><a href="#break" class="headerlink" title="break"></a>break</h1><ul><li>break 会立即结束整个控制流语句，即跳出整个循环</li></ul><h1 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h1><ul><li>你确定要贯穿行为，你可以在 <code>switch</code> 每个 <code>case</code> 末尾 使用 <code>fallthrough</code> 关键字</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let num = 5</span><br><span class="line">var des = &quot;the num \(num) is&quot;</span><br><span class="line">switch num &#123;</span><br><span class="line">case 2,3,5,7:</span><br><span class="line">    des += &quot;a prime number&quot;</span><br><span class="line">    fallthrough</span><br><span class="line">default:</span><br><span class="line">    des += &quot; also a int&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(des)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032224219.png"                                     ></p><h1 id="语句标签"><a href="#语句标签" class="headerlink" title="语句标签"></a>语句标签</h1><ul><li><p>可以用 <code>k</code> 来给循环语句或条件语句做标记。</p></li><li><p>配合 <code>break</code> 或 <code>continue</code> 来结束被标记的语句</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var num = 10</span><br><span class="line">whileLoop: while num &gt; 0 &#123;</span><br><span class="line">    switch num &#123;</span><br><span class="line">    case 9:</span><br><span class="line">        print(&quot;9&quot;)</span><br><span class="line">    case 10:</span><br><span class="line">        var sum = 0</span><br><span class="line">        for i in 0...10 &#123;</span><br><span class="line">            sum += i</span><br><span class="line">            if i == 9 &#123;</span><br><span class="line">                print(sum)</span><br><span class="line">                break whileLoop</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    default:</span><br><span class="line">        print(&quot;default&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    num -= 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032225782.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习23：更加强大的switch</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A023%EF%BC%9A%E6%9B%B4%E5%8A%A0%E5%BC%BA%E5%A4%A7%E7%9A%84switch/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A023%EF%BC%9A%E6%9B%B4%E5%8A%A0%E5%BC%BA%E5%A4%A7%E7%9A%84switch/</url>
      
        <content type="html"><![CDATA[<h1 id="swift"><a href="#swift" class="headerlink" title="swift"></a>swift</h1><ul><li><p><code>switch</code> 语句会将一个值与多个可能匹配的模式匹配，然后基于第一个成功匹配的模式来执行合适的代码块</p></li><li><p><code>switch</code> 语句一定得是全面的。给定类型里的每一个值都得匹配到一个 <code>switch</code> 的 <code>case</code>。你可以定义一个默认匹配的 <code>case</code> 来匹配所有未明确的值，用关键字 <code>default</code> 标记</p></li><li><p><code>OC</code> 中 <code>switch</code> 语句不全面，仍然可以运行</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let c:Character = &quot;z&quot;</span><br><span class="line">switch c &#123;</span><br><span class="line">case &quot;a&quot;:</span><br><span class="line">    print(&quot;the first letter is alphabet&quot;)</span><br><span class="line">case &quot;z&quot;:</span><br><span class="line">    print(&quot;the last letter is alphabet&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032220631.png"                                     ></p><p>修改</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let c:Character = &quot;z&quot;</span><br><span class="line">switch c &#123;</span><br><span class="line">case &quot;a&quot;:</span><br><span class="line">    print(&quot;the first letter is alphabet&quot;)</span><br><span class="line">case &quot;z&quot;:</span><br><span class="line">    print(&quot;the last letter is alphabet&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;other&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032221557.png"                                     ></p><h1 id="没有隐私贯穿"><a href="#没有隐私贯穿" class="headerlink" title="没有隐私贯穿"></a>没有隐私贯穿</h1><ul><li><p>相比 <code>OC</code> 和 <code>C</code> ，<code>Swift</code> 里的 <code>Switch</code> 不会默认从匹配的 <code>case</code> 末尾 <code>贯穿到下一个 case</code> 里</p></li><li><p>相反，整个 <code>Switch</code> 在匹配到第一个 <code>case</code> 执行完毕之后退出，不再需要显示 <code>break</code></p></li><li><p>每一个 <code>case</code> 的函数体必须包含至少一个可执行的语句</p></li><li><p>在一个 <code>Switch</code> 的 <code>case</code> 中匹配多个值可以用 <code>逗号分割</code>，并且可以写成多行</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let c = &quot;a&quot;</span><br><span class="line">switch c &#123;</span><br><span class="line">case &quot;a&quot;,&quot;e&quot;,&quot;i&quot;:</span><br><span class="line">    print(&quot;元音字母&quot;)</span><br><span class="line">case &quot;b&quot;,&quot;c&quot;:</span><br><span class="line">    print(&quot;符印字母&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;其他字符&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032221717.png"                                     ></p><h1 id="区间匹配"><a href="#区间匹配" class="headerlink" title="区间匹配"></a>区间匹配</h1><ul><li><code>Switch</code> 的 <code>case</code> 的值可以再一个区间中匹配</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let count = 43</span><br><span class="line">switch count&#123;</span><br><span class="line">case 0:</span><br><span class="line">    print(&quot;none&quot;)</span><br><span class="line">case 1...25:</span><br><span class="line">    print(&quot;1~25&quot;)</span><br><span class="line">case 26..&lt;51:</span><br><span class="line">    print(&quot;26~50&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;other&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032222555.png"                                     ></p><h1 id="元组匹配"><a href="#元组匹配" class="headerlink" title="元组匹配"></a>元组匹配</h1><ul><li><p>你可以使用元组来在一个 <code>switch</code> 中测试有多个值</p></li><li><p>使用下划线 <code>_</code> 来表明匹配所有可能的值</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let point = (1,1)</span><br><span class="line">switch point&#123;</span><br><span class="line">case (0,0):</span><br><span class="line">    print(&quot;point at origin&quot;)</span><br><span class="line">case (_,0):</span><br><span class="line">    print(&quot;point at x&quot;)</span><br><span class="line">case (0,_):</span><br><span class="line">    print(&quot;point at y&quot;)</span><br><span class="line">case (-2...2,-2...2):</span><br><span class="line">    print(&quot;point at box&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(0,0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032223063.png"                                     ></p><h1 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h1><ul><li><p><code>switch</code> 的 <code>case</code> 可以将匹配到的值临时 <code>绑定</code> 到一个 <code>常量或变量</code>，来给 <code>case</code> 的函数体使用</p></li><li><p>如果使用 <code>var</code> 关键字，临时的变量就会以合适的值来创建并初始化。对这个变量的任何改变都只会在 <code>case</code> 的函数体内有效</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let point = (1,0)</span><br><span class="line">switch point&#123;</span><br><span class="line">case (let x,0):</span><br><span class="line">    print(&quot;x is \(x) when y is 0&quot;)</span><br><span class="line">case (0,let y):</span><br><span class="line">    print(&quot;y is \(y) when x is 0&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;other&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032223344.png"                                     ></p><h1 id="where-语句"><a href="#where-语句" class="headerlink" title="where 语句"></a>where 语句</h1><ul><li><code>switch case</code> 可以使用 <code>where</code> 语句来检查是否符合特定的约束</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let point = (1,-1)</span><br><span class="line">switch point&#123;</span><br><span class="line">case (let x,let y) where x == y:</span><br><span class="line">    print(&quot;x == y&quot;)</span><br><span class="line">case (let x,let y) where x == -y:</span><br><span class="line">    print(&quot;x == -y&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;other&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032224503.png"                                     ></p><h1 id="复合匹配"><a href="#复合匹配" class="headerlink" title="复合匹配"></a>复合匹配</h1><ul><li><code>case</code> 后可以写多个模式来复合，在每个模式间用 <code>,</code> 号分割</li></ul><h1 id="复合匹配-值绑定"><a href="#复合匹配-值绑定" class="headerlink" title="复合匹配 - 值绑定"></a>复合匹配 - 值绑定</h1><ul><li>复合匹配同样可以包含 <code>值绑定</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习22：如何在Swift里进行循环控制</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A022%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8Swift%E9%87%8C%E8%BF%9B%E8%A1%8C%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A022%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8Swift%E9%87%8C%E8%BF%9B%E8%A1%8C%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for in 循环"></a>for in 循环</h1><ul><li><p>使用 <code>for in</code> 循环来遍历序列，比如一个范围的数字，数组中元素或者字符串中的字符</p></li><li><p>如果你不需要序列的每一个值，你可以使用下划线 <code>_</code> 来取代遍历名</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 遍历</span><br><span class="line">for i in 0...3&#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历字符串</span><br><span class="line">for c in &quot;hello,world&quot; &#123;</span><br><span class="line">    print(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历数组</span><br><span class="line">let letter = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">for str in letter &#123;</span><br><span class="line">    print(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="for-in-遍历字典"><a href="#for-in-遍历字典" class="headerlink" title="for in 遍历字典"></a>for in 遍历字典</h1><ul><li>当遍历字典时，每一个元素都返回一个 <code>(key,value) 元组</code>，你可以在 <code>for in</code> 循环体中使用显示命名常量来分解 <code>(key,value)</code> 元组成员</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let nums = [&quot;age&quot;:&quot;30&quot;,&quot;sex&quot;:&quot;男&quot;]</span><br><span class="line">for (key,value) in nums &#123;</span><br><span class="line">    print(&quot;key is \(key),value is \(value)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">for t in nums &#123;</span><br><span class="line">    print(&quot;key is \(t.0),value is \(t.1)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032219719.png"                                     ></p><h1 id="for-in-分段区间"><a href="#for-in-分段区间" class="headerlink" title="for in 分段区间"></a>for in 分段区间</h1><ul><li>使用 <code>stride(from:to:by)</code> 函数来跳过不想要的标记（<code>开区间</code>）</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in stride(from: 0, to: 50, by: 10) &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032219282.png"                                     ></p><ul><li><code>闭区间</code> 也同样适用，使用 <code>stride(from:through:by:)</code> 即可</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in stride(from: 0, through: 50, by: 10) &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032219011.png"                                     ></p><h1 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h1><ul><li><code>repeat-while</code> 循环 （oc 中是 <code>do-while</code>）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习21：如何在swift中自定义运算符</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A021%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8swift%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A021%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8swift%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义运算符"><a href="#自定义运算符" class="headerlink" title="自定义运算符"></a>自定义运算符</h1><ul><li><p>除了实现标准的运算符，在 <code>swift</code> 当中还可以声明和实现自定义运算符（custom operators）</p></li><li><p>新的运算符要在全局作用域内，使用 <code>operator</code> 关键字进行声明，同时还要指定 <code>prefix、infix</code> 或者 <code>postfix</code> 限定符</p></li></ul><p>【示例1】：一元运算符</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">// 声明一元运算符</span><br><span class="line">prefix operator +++</span><br><span class="line"></span><br><span class="line">// 扩展</span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static prefix func +++ (vector: Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: vector.x + vector.x,y: vector.y + vector.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let vectorToDouble = Vector2D(x: 1.0,y: 2.0)</span><br><span class="line">let doubleVector = +++vectorToDouble</span><br><span class="line">print(&quot;\(doubleVector.x) \(doubleVector.y)&quot;)</span><br></pre></td></tr></table></figure></div><p>编译运行，查看打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.0 4.0</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032216751.png"                                     ></p><p>【示例2】：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 中缀运算符</span><br><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">infix operator +-: AdditionPrecedence</span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static func +- (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: left.x + right.x,y: left.y - right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let firstVector = Vector2D(x: 1.0,y: 3.0)</span><br><span class="line">let secondVector = Vector2D(x: 2.0,y: 5.0)</span><br><span class="line">let result = firstVector +- secondVector</span><br><span class="line">print(&quot;\(result.x) \(result.y)&quot;)</span><br></pre></td></tr></table></figure></div><p>编译运行，查看打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.0 -2.0</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032217206.png"                                     ></p><p>【示例3】：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 中缀运算符</span><br><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">infix operator *^: MultiplicationPrecedence</span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static func *^ (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: left.x * right.x,y: left.y * left.y + right.y * right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let firstVector = Vector2D(x: 1.0,y: 3.0)</span><br><span class="line">let secondVector = Vector2D(x: 2.0,y: 5.0)</span><br><span class="line">let result = firstVector *^ secondVector</span><br><span class="line">print(&quot;\(result.x) \(result.y)&quot;)</span><br></pre></td></tr></table></figure></div><p>编译运行，查看打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.0 34.0</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032217226.png"                                     ></p><h1 id="自定义中缀运算符的优先级和结合性"><a href="#自定义中缀运算符的优先级和结合性" class="headerlink" title="自定义中缀运算符的优先级和结合性"></a>自定义中缀运算符的优先级和结合性</h1><ul><li><p>自定义 <code>中缀（infix）</code> 运算符也可以指定优先级和结核性</p></li><li><p>每一个自定义的中缀运算符都属于一个 <code>优先级组</code></p></li><li><p>优先级组指定了自定义中缀运算符和其他中缀运算符的关系</p></li></ul><p>【示例】：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 优先级和结合性</span><br><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">infix operator +-: AdditionPrecedence</span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static func +- (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: left.x + right.x,y: left.y - right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">infix operator *^: MultiplicationPrecedence</span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static func *^ (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: left.x * right.x,y: left.y * left.y + right.y * right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let firstVector = Vector2D(x: 1.0,y: 2.0)</span><br><span class="line">let secondVector = Vector2D(x: 2.0,y: 3.0)</span><br><span class="line">let thirdVector = Vector2D(x: 3.0,y: 4.0)</span><br><span class="line">let result = firstVector +- secondVector *^ thirdVector</span><br><span class="line">print(&quot;\(result.x) \(result.y)&quot;)</span><br></pre></td></tr></table></figure></div><p>编译运行，查看打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7.0 -23.0</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032217682.png"                                     ></p><p>【注】：先计算 <code>*^</code> 优先级组，再计算 <code>+-</code> 优先级组</p><p>x: 2 * 3 &#x3D; 6 + 1 &#x3D; 7.0<br>y: 3 * 3 + 4 * 4 &#x3D; 2 - 25 &#x3D; -23</p><ul><li>接下来我们自己定义一个优先级组</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 自定义优先级和结合性</span><br><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">infix operator +-: AdditionPrecedence</span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static func +- (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: left.x + right.x,y: left.y - right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">infix operator *^: MyPrecedencegroup</span><br><span class="line"></span><br><span class="line">// 我的优先级组</span><br><span class="line">precedencegroup MyPrecedencegroup &#123;</span><br><span class="line">    // 结合性</span><br><span class="line">    associativity: left</span><br><span class="line">    // 优先级</span><br><span class="line">    lowerThan: AdditionPrecedence</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static func *^ (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: left.x * right.x,y: left.y * left.y + right.y * right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let firstVector = Vector2D(x: 1.0,y: 2.0)</span><br><span class="line">let secondVector = Vector2D(x: 2.0,y: 3.0)</span><br><span class="line">let thirdVector = Vector2D(x: 3.0,y: 4.0)</span><br><span class="line">let result = firstVector +- secondVector *^ thirdVector</span><br><span class="line">print</span><br></pre></td></tr></table></figure></div><p>编译运行，查看打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9.0 17.0</span><br></pre></td></tr></table></figure></div><p>【注】：先计算 <code>*^</code> 优先级组，再计算 <code>+-</code> 优先级组</p><p>x：1 + 2 &#x3D; 3 * 3 &#x3D; 9.0<br>y：2 - 3 &#x3D; -1 * -1 + 4 * 4 &#x3D; 17.0</p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习20：如何为类和结构体自定义运算符</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A020%EF%BC%9A%E5%A6%82%E4%BD%95%E4%B8%BA%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A020%EF%BC%9A%E5%A6%82%E4%BD%95%E4%B8%BA%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><ul><li><code>类和结构体</code> 可以为现有的运算符提供自定义的实现，称为 <code>运算符重载</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let vector = Vector2D(x: 1.0,y: 2.0)</span><br><span class="line">let anotherVertor = Vector2D(x: 3.0,y: 1.0)</span><br><span class="line">let thirdVertor = vector + anotherVertor</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032047651.png"                                     ></p><ul><li>运算符重载</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static func + (left:Vector2D,right:Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: left.x + right.x,y: left.y + right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let vector = Vector2D(x: 1.0,y: 2.0)</span><br><span class="line">let anotherVertor = Vector2D(x: 3.0,y: 1.0)</span><br><span class="line">let thirdVector = vector + anotherVertor</span><br><span class="line">print(&quot;x is \(thirdVector.x),y is \(thirdVector.y)&quot;)</span><br></pre></td></tr></table></figure></div><p>编译运行，查看打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x is 4.0,y is 3.0</span><br></pre></td></tr></table></figure></div><h1 id="一元运算符的重载"><a href="#一元运算符的重载" class="headerlink" title="一元运算符的重载"></a>一元运算符的重载</h1><ul><li><p><code>类和结构体</code> 也能提供 <code>标准一元运算符</code> 的实现</p></li><li><p>要实现 <code>前缀</code> 或者 <code>后缀</code> 运算符，需要在声明运算符函数的时候在 <code>func</code> 关键字之前指定 <code>prefix</code> 或者 <code>postfix</code> 限定符</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static prefix func - (vector:Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: -vector.x,y: -vector.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let vector = Vector2D(x: 1.0,y: 2.0)</span><br><span class="line">let vector2 = -vector</span><br><span class="line">print(&quot;x is \(vector2.x),y is \(vector2.y)&quot;)</span><br></pre></td></tr></table></figure></div><p>编译运行，查看打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x is -1.0,y is -2.0</span><br></pre></td></tr></table></figure></div><h1 id="组合赋值运算符重载"><a href="#组合赋值运算符重载" class="headerlink" title="组合赋值运算符重载"></a>组合赋值运算符重载</h1><ul><li><p>组合赋值运算符将赋值运算符 <code>=</code> 与其他运算符进行结合</p></li><li><p>在实现的时候，需要把运算符的左参数设置成 <code>inout</code> 类型，因为这个参数的值会在运算符函数内直接被修改</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension Vector2D &#123;</span><br><span class="line">    static func += (left: inout Vector2D,right:Vector2D) &#123;</span><br><span class="line">        left = Vector2D(x: left.x + right.x,y: left.y + right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var vector3 = Vector2D(x: 1.0, y: 2.0)</span><br><span class="line">let vector4 = Vector2D(x: 2.0,y: 3.0)</span><br><span class="line">vector3 += vector4</span><br><span class="line">print(&quot;x is \(vector3.x),y is \(vector3.y)&quot;)</span><br></pre></td></tr></table></figure></div><p>编译运行，查看打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x is 3.0,y is 5.0</span><br></pre></td></tr></table></figure></div><h1 id="等价运算符重载"><a href="#等价运算符重载" class="headerlink" title="等价运算符重载"></a>等价运算符重载</h1><ul><li><p>自定义类和结构体不接收等价运算符的默认实现，也就是所谓的 <code>等于</code> 运算符 <code>==</code> 和 <code>不等于</code> 运算符 <code>!=</code></p></li><li><p>要使用等价运算符来检查你自己类型的等价，需要和其他 <code>中缀运算符</code> 一样提供一个 <code>等于</code> 运算符重载，并且遵循标准库的 <code>Equatable</code> 协议</p></li><li><p><code>swift</code> 为一下自定义类型提供等价运算符合成实现</p><ul><li>只有遵循 <code>Equatable</code> 协议存储属性的 <code>结构体</code></li><li>只拥有遵循 <code>Equatable</code> 协议关联类型的 <code>枚举</code></li><li>没有关联类型的枚举</li></ul></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 等价运算符</span><br><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">extension Vector2D: Equatable &#123;</span><br><span class="line">    static func == (left:Vector2D,right:Vector2D) -&gt; Bool &#123;</span><br><span class="line">        return (left.x == right.x) &amp;&amp; (left.y == right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var vector1 = Vector2D(x: 1.0, y: 2.0)</span><br><span class="line">let vector2 = Vector2D(x: 2.0,y: 3.0)</span><br><span class="line">print(vector1 == vector2)</span><br></pre></td></tr></table></figure></div><p>编译运行，查看打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16778503288087.jpg"                                     ></p><h1 id="自定义中缀运算符的优先级和结合性"><a href="#自定义中缀运算符的优先级和结合性" class="headerlink" title="自定义中缀运算符的优先级和结合性"></a>自定义中缀运算符的优先级和结合性</h1><ul><li><p>自定义的中缀 <code>infix</code> 运算符也可以指定优先级和结合性</p></li><li><p>每一个自定义的中缀运算符都属于一个优先级组</p></li><li><p>优先级组指定了自定义中缀运算符和其他中缀运算符的关系</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习19：运算符优先级和结合性</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A019%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A019%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符优先级和结合性"><a href="#运算符优先级和结合性" class="headerlink" title="运算符优先级和结合性"></a>运算符优先级和结合性</h1><ul><li><p>运算符的优先级使得一些运算符优先于其他运算符，高优先级的运算符会先被计算</p></li><li><p>结合性定义了具有相同优先级的运算符是如何结合（或关联）的 一一 是左边结合为一组，还是与右边结合为一组。可以这样理解：它们是与左边的表达式结合的 或者 它们是与右边的表示式结合的</p></li></ul><p> <img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031851731.png"                                     ></p><h1 id="运算符优先级-显示括号"><a href="#运算符优先级-显示括号" class="headerlink" title="运算符优先级-显示括号"></a>运算符优先级-显示括号</h1><ul><li><p>2 + 3 % 4 * 5 等价于 2 + ((3 % 4) * 5)</p></li><li><p><code>swift</code> 语言中逻辑运算符 <code>&amp;&amp;</code> 和 <code>||</code> 是左相关的，这意味着多个逻辑运算符组合的表达式会首先计算最左边的</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16771566691861.jpg"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习18：运算符应用举例</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A018%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A018%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="两个数字交换"><a href="#两个数字交换" class="headerlink" title="两个数字交换"></a>两个数字交换</h1><ul><li>不借助临时变量，交换两个变量的值</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a  = 1</span><br><span class="line">var b = 2</span><br><span class="line">a = a ^ b</span><br><span class="line">b = a ^ b</span><br><span class="line">a = a ^ b</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031839972.png"                                     ></p><h1 id="求无符号整数二进制中-1-的个数"><a href="#求无符号整数二进制中-1-的个数" class="headerlink" title="求无符号整数二进制中 1 的个数"></a>求无符号整数二进制中 1 的个数</h1><ul><li>给定一个无符号整型 <code>UInt</code> 变量，求其二进制表中 <code>1</code> 的个数，要求算法执行效率尽可能的高</li></ul><p>思路：看一个八位整数 <code>10 100 001</code> ，先判断最后一位是否为 <code>1</code> ，而 <code>与</code> 操作可以达到目前。可以把这个 <code>八位数字</code> 与 <code>00 0000 01</code> 进行 <code>与</code> 操作，如果结果为 <code>1</code>，则表示当前八位数的最后一位为 <code>1</code>，否则为 <code>0 </code>。怎么判断第 <code>二</code> 位呢？向右移位，再延续前面的判断即可</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 有几个 1</span><br><span class="line">func countsOfOnes(num:UInt) -&gt; UInt &#123;</span><br><span class="line">    var count:UInt = 0</span><br><span class="line">    var temp = num</span><br><span class="line">    while temp != 0 &#123;</span><br><span class="line">        // 如果都是位 1 才累加</span><br><span class="line">        count += temp &amp; 1</span><br><span class="line">        // 右移</span><br><span class="line">        temp = temp &gt;&gt; 1</span><br><span class="line">    &#125;</span><br><span class="line">    return count</span><br><span class="line">&#125;</span><br><span class="line">countsOfOnes(num: 8)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031841462.png"                                     ></p><ul><li>如果整数的二进制中有较多的 <code>0</code>，那么我们每一次右移做判断会很浪费，怎么改进前面的算法呢？有没有办法让算法的复杂度只有与 <code>1</code> 的个数有关？</li></ul><p>思路：为了简化这个问题，我们考虑只有高位 <code>1</code> 的情况。例如：11 000 000，如何跳过前面低位的 <code>6</code> 个 <code>0</code> ，而直接判断第 <code>七</code> 位的 <code>1？</code>我们可以设计 <code>11 000 000</code> 和 <code>10 111 111</code>（也就是 11 000 000 - 1）做 <code>与</code> 操作，消去最低位的 <code>1</code>。如果得到的结果为 <code>0</code>，说明我们已经找到或消去里面最后一个 <code>1</code>，如果不为 <code>0</code>，那么说明我们消去了最低位的 <code>1</code>，但是二进制中还有其他的 <code>1</code>，我们的计数器需要加 <code>1</code>，然后继续上面的操作</p><p>计数器 count &#x3D; 0</p><p>步骤一：整数不为0，说明二进制里面肯定有1，count &#x3D; 1</p><p>11 000 000 &amp; 10 111 111 &#x3D; 10 000 000 (消去第7位的1)</p><p>步骤二：结果不为 0，说明二进制里还有 1，count &#x3D; 2</p><p>10 000 000 &amp; 01 111 111 &#x3D; 0（消去第8位的1）</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func countsOfOnes2(num:UInt) -&gt; UInt &#123;</span><br><span class="line">    var count:UInt = 0</span><br><span class="line">    var temp = num</span><br><span class="line">    while temp != 0 &#123;</span><br><span class="line">        count += 1</span><br><span class="line">        temp = temp &amp; (temp - 1)</span><br><span class="line">    &#125;</span><br><span class="line">    return count</span><br><span class="line">&#125;</span><br><span class="line">countsOfOnes2(num: 3)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031844480.png"                                     ></p><h1 id="引申：如果判断一个征收为2的整数次幂"><a href="#引申：如果判断一个征收为2的整数次幂" class="headerlink" title="引申：如果判断一个征收为2的整数次幂"></a>引申：如果判断一个征收为2的整数次幂</h1><ul><li><p>给定一个无符号整型 <code>UInt</code> 变量，判断是否为 <code>2</code> 的整数次幂</p></li><li><p>思路：一个整数如果是 <code>2</code> 的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位都是 <code>0</code>，根据前面的分析，把这个整数减去 <code>1</code> 后再和它自己做 <code>&amp;</code> 运算，这个整数中唯一的 <code>1</code> 就变成 <code>0</code> 了，也就是得到的结果是 <code>0</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 2的整数次幂</span><br><span class="line">func isPowerTwo(num:UInt) -&gt; Bool &#123;</span><br><span class="line">    return (num &amp; (num - 1)) == 0</span><br><span class="line">&#125;</span><br><span class="line">isPowerTwo(num: 18)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031845987.png"                                     ></p><h1 id="缺失的数字"><a href="#缺失的数字" class="headerlink" title="缺失的数字"></a>缺失的数字</h1><ul><li>很多成对出现的正整数保存在磁盘文件中，注意成对数字不一定是相邻的，如果 <code>2、3、4、3、4、2、..</code>，由于意外有一个数字消失了，如何尽快找到是哪个数字消失了？</li></ul><p>思路：考虑 <code>^</code> 异或操作的定义，当两个操作的数对应位不相同时，改数的对应位就为1。也就是说如果是相等的两个数 <code>^异或</code>，得到的结果就是 <code>0</code>，而 <code>0</code> 与任何数字 <code>^异或</code>，得到的是那个数字本身。所以我们考虑将所有的数字做 <code>^异或操作</code>，因为只有一个数字消失，那么其他俩俩出现的数字 <code>^异或后为0</code>，0与仅有的一个的数字做 <code>^异或</code>，我们就得到了消失的数字是哪个？</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 缺失的数字</span><br><span class="line">func findLostNum(nums:[UInt]) -&gt; UInt &#123;</span><br><span class="line">    var lostNum:UInt = 0</span><br><span class="line">    for num in nums &#123;</span><br><span class="line">        lostNum = lostNum ^ num</span><br><span class="line">    &#125;</span><br><span class="line">    return lostNum</span><br><span class="line">&#125;</span><br><span class="line">findLostNum(nums: [1,3,2,4,2,1,3])</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031851072.png"                                     ></p><ul><li>如果有两个数字意外丢失了（丢失的不是相等的数字），改如何找到丢失的两个数字？</li></ul><p>思路：<br>假设题目中这两个只出现1次的数字分别是A和B，如果能将A，B分开到二个数组中，那显然符合 异或 解法的关键点了，因此这个题目的关键点事将A和B分开到二个数组中。<br>由于A，B肯定是不相等的，因此在二进制上肯定有一位是不同的。根据这一位是 0 还是 1 可以将A和B分开到A组合B组。<br>而这个数组中其它数字那么就属于A组，要么就属于B组。再对A组 和 B组 分别执行 异或 解法，就可以得到A,B了。<br>而要判断A，B在哪一位上不相同，只要根据 A ^ B 的结果就可以知道了，这个结果在二进制上为 1 的位都说明 A，B在这一位上是不同的</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 丢失的两个不同数</span><br><span class="line">func findTwoLostNum(nums:[UInt]) -&gt; (UInt,UInt) &#123;</span><br><span class="line">    var lostNum1:UInt = 0</span><br><span class="line">    var lostNum2:UInt = 0</span><br><span class="line">    var temp:UInt = 0</span><br><span class="line">    // 计算两个数的异或结果</span><br><span class="line">    for num in nums &#123;</span><br><span class="line">        temp = temp ^ num</span><br><span class="line">    &#125;</span><br><span class="line">    // 找到第一个为 1 的位</span><br><span class="line">    var flag:UInt = 1</span><br><span class="line">    while ((flag &amp; temp) == 0) &#123;</span><br><span class="line">        flag = flag &lt;&lt; 1</span><br><span class="line">    &#125;</span><br><span class="line">    // 找到两个丢失的数字</span><br><span class="line">    for num in nums &#123;</span><br><span class="line">        if (num &amp; flag) == 0 &#123;</span><br><span class="line">            lostNum1 = lostNum1 ^ num</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            lostNum2 = lostNum2 ^ num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (lostNum1,lostNum2)</span><br><span class="line">&#125;</span><br><span class="line">findTwoLostNum(nums: [1,2,3,4,2,1])</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031851154.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习17：位运算符</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A017%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A017%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="位取反运算符"><a href="#位取反运算符" class="headerlink" title="位取反运算符"></a>位取反运算符</h1><ul><li>位取反运算符 <code>~</code> 是对所有位的数字进行取反操作</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031824254.png"                                     ></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let n1:UInt8 = 255</span><br><span class="line">let n2 = ~n1</span><br><span class="line">print(n2)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031825231.png"                                     ></p><h1 id="位与运算符"><a href="#位与运算符" class="headerlink" title="位与运算符"></a>位与运算符</h1><ul><li>位与运算符 <code>&amp;</code> 可以对两个数的比特位进行合并，它会返回一个新的数，只有当这两个数都是 <code>1</code> 时才能返回 <code>1</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031825798.png"                                     ></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let n1:UInt8 = 255</span><br><span class="line">let n2 = ~n1</span><br><span class="line">let n3 = n1 &amp; n2</span><br><span class="line">let n4 = n1 | n2</span><br><span class="line">print(n3)</span><br><span class="line">print(n4)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031826604.png"                                     ></p><h1 id="位或运算符"><a href="#位或运算符" class="headerlink" title="位或运算符"></a>位或运算符</h1><ul><li>位或运算符 <code>|</code> 可以对两个比特位进行比较，然后返回一个新的数，只要两个操作位任意一个为 <code>1</code> 时，那么对应的位数就为 <code>1</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031826047.png"                                     ></p><h1 id="位异或运算符"><a href="#位异或运算符" class="headerlink" title="位异或运算符"></a>位异或运算符</h1><ul><li>位异或运算符，或者说 互斥或 <code>^</code> 可以对两个数的比特位进行比较，它返回一个新的数，当两个操作数的对应位不同时，该数的对应位就为 <code>1</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031827719.png"                                     ></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let n1:UInt8 = 255</span><br><span class="line">let n2 = ~n1</span><br><span class="line">let n5 = n1 ^ n2</span><br><span class="line">print(n5)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031828749.png"                                     ></p><h1 id="位左移和右移运算符"><a href="#位左移和右移运算符" class="headerlink" title="位左移和右移运算符"></a>位左移和右移运算符</h1><ul><li><p>位左移运算符 <code>&lt;&lt;</code> 和位右移运算符 <code>&gt;&gt;</code> 可以把所有位数的数字向左或向右移动一个确定的位数</p></li><li><p>位 <code>左移和右移</code> 具有给 <code>整数乘以或除以二</code> 的效果，将一个数 <code>左移</code> 一位相当于把这个 <code>数翻</code>倍，将一个数 <code>右移</code> 相当于把这个数 <code>减半</code></p></li></ul><h1 id="无符号整数的位移操作"><a href="#无符号整数的位移操作" class="headerlink" title="无符号整数的位移操作"></a>无符号整数的位移操作</h1><ul><li><p>已经存在的比特位按指定的位数进行左移和右移</p></li><li><p>任何移动超出整型存储边界的位都会被丢弃</p></li><li><p>用 <code>0</code> 来填充向左或向右移动后产生的空白位</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031829164.png"                                     ></p><h1 id="有符号整数的位移操作"><a href="#有符号整数的位移操作" class="headerlink" title="有符号整数的位移操作"></a>有符号整数的位移操作</h1><ul><li>有符号整数使用它的第一位（所谓的符号位）来表示这个整数是正数还是负数，符号位 <code>0</code> 表示 <code>正数</code>，<code>1</code> 表示 <code>负数</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031829054.png"                                     ></p><ul><li><p>其余的位数（所谓的数值位）存储了实际的值，有符号正整数和无符号数的存储方式是一样的，都是从 <code>0</code> 开始算起</p></li><li><p>但是负数的存储方式略有不同，它存储的是 <code>2</code> 的 <code>n</code> 次方减去它的绝对值，这里的 <code>n</code> 为数值位的位数</p></li></ul><p> <img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16771506508589.jpg"                                     ></p><p>示例：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let n6: Int = 8</span><br><span class="line">print(n6 &lt;&lt; 1)</span><br><span class="line">print(n6 &gt;&gt; 1)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031831199.png"                                     ></p><h1 id="补码表示的优点"><a href="#补码表示的优点" class="headerlink" title="补码表示的优点"></a>补码表示的优点</h1><ul><li>首先，如果想给 <code>-4</code> 加个 <code>-1</code>，只需要将这两个数的全部 <code>8</code> 个比特位相加（包括符号位），并且将计算结果中超出的部分丢掉</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031832104.png"                                     ></p><ul><li>其次，使用二进制补码可以使负数位的位左移和右移操作得到根正数同样的效果，即每向左移一位就将自身的数值 <code>乘以2</code> ，每向右移一位就将自身的数值 <code>除以2</code>，要达到此目的，对 <code>有符号的整数</code> 的右移有一个额外的规则：当对整数进行位右移操作时，遵循与无符号整数相同的规则，但是对于位移产生的空白位使用符号进行填充，而不是 <code>0</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031838090.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习16：区间运算符</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A016%EF%BC%9A%E5%8C%BA%E9%97%B4%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A016%EF%BC%9A%E5%8C%BA%E9%97%B4%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="闭区间运算符"><a href="#闭区间运算符" class="headerlink" title="闭区间运算符"></a>闭区间运算符</h1><ul><li>闭区间运算符 <code>a...b</code> 定义了从 <code>a</code> 到 <code>b</code> 的一组范围，并且包含 <code>a</code> 和 <code>b</code> ，<code>a</code> 的值不能大于 <code>b</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 闭区间</span><br><span class="line">let range = 0...5</span><br><span class="line">for index in range &#123;</span><br><span class="line">    print(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="半开区间运算符"><a href="#半开区间运算符" class="headerlink" title="半开区间运算符"></a>半开区间运算符</h1><ul><li>半开区间运算符 <code>a..&lt;b</code> 定义了从 <code>a</code> 到 <code>b</code> 但不包括 <code>b</code> 的区间</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 半开半闭区间</span><br><span class="line">let range = 0..&lt;5</span><br><span class="line">for index in range &#123;</span><br><span class="line">    print(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>如同闭区间运算符，<code>a</code> 的值也不能大于 <code>b</code> ，如果 <code>a</code> 与 <code>b</code> 的值相等，那返回的区间将会是空的</li></ul><h1 id="单侧区间"><a href="#单侧区间" class="headerlink" title="单侧区间"></a>单侧区间</h1><ul><li>闭区间运算符有另外一种形式来让区间朝一个方向尽可能的远，这种区间叫做单侧区间</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 单侧闭区间</span><br><span class="line">let names = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</span><br><span class="line">for name in names[...2] &#123;</span><br><span class="line">    print(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031820388.png"                                     ></p><ul><li>半开区间运算符同样可以有单侧形式，只需要写它最终的值</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 单侧半开半闭区间</span><br><span class="line">let names = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</span><br><span class="line">for name in names[..&lt;2] &#123;</span><br><span class="line">    print(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031822902.png"                                     ></p><ul><li>比如说，一个包含数组所有元素的区间，从索引 <code>2</code> 到数组的结束，在这种情况下，你可以省略区间运算符一侧的值</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for name in names[2...] &#123;</span><br><span class="line">    print(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><p>单侧区间可以再其他上下文中使用，不仅仅是下标</p></li><li><p>不能变量省略了第一个值的单侧区间，因为遍历根本不知道该从哪里开始，你可以遍历省略了最终值的单侧区间</p></li></ul><h1 id="字符串索引区间"><a href="#字符串索引区间" class="headerlink" title="字符串索引区间"></a>字符串索引区间</h1><ul><li>字符串范围可以使用区间运算符</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 字符串索引区间</span><br><span class="line">var str = &quot;hello,world&quot;</span><br><span class="line">let range = str.startIndex...str.index(str.endIndex, offsetBy: -6)</span><br><span class="line">str.removeSubrange(range)</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031822403.png"                                     ></p><h1 id="倒叙索引"><a href="#倒叙索引" class="headerlink" title="倒叙索引"></a>倒叙索引</h1><ul><li>通过 <code>reversed()</code> 方法，我们可以将一个正序循环变成逆序循环</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 逆序</span><br><span class="line">for i in (0...4).reversed() &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031823875.png"                                     ></p><h1 id="Comparable-区别"><a href="#Comparable-区别" class="headerlink" title="Comparable 区别"></a>Comparable 区别</h1><ul><li>区间运算符可以作用在 <code>Comparable</code> 类型上，返回闭区间和半闭区间</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello,world&quot;</span><br><span class="line">let range = &quot;a&quot;...&quot;z&quot;</span><br><span class="line">for c:Character in str &#123;</span><br><span class="line">    if !range.contains(String(c)) &#123;</span><br><span class="line">        print(&quot;\(c) 不是小写字符&quot;)</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031823752.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习15：为了Optional，合并空置运算符</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A015%EF%BC%9A%E4%B8%BA%E4%BA%86Optional%EF%BC%8C%E5%90%88%E5%B9%B6%E7%A9%BA%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A015%EF%BC%9A%E4%B8%BA%E4%BA%86Optional%EF%BC%8C%E5%90%88%E5%B9%B6%E7%A9%BA%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="合并空值运算符"><a href="#合并空值运算符" class="headerlink" title="合并空值运算符"></a>合并空值运算符</h1><ul><li><p>合并空值运算符 <code>a ?? b</code> 如果可选项 <code>a</code> 有值则展开，如果没有值是 <code>nil</code>，则返回默认值 <code>b</code></p></li><li><p>表达式 <code>a</code> 必须是一个可选类型，表达式 <code>b</code> 必须与 <code>a</code> 的存储类型相同</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16776915687917.jpg"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020126317.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020126785.png"                                     ></p><ul><li><p>实际上是 <code>三元运算符</code> 作用到 <code>Optional</code> 上的缩写 <code>a != nil ? a : b</code></p></li><li><p>如果 <code>a</code> 的值是非空的，<code>b</code> 的值将不会被考虑，也就是合并空值运算符是短路的</p></li><li><p>可选值为nil时，不能强制解包</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020127661.png"                                     ></p><p>可以用 <code>if</code> 判断实现</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let a:Int? = nil</span><br><span class="line">let b = 2</span><br><span class="line">func sum(x:Int?,y:Int?) -&gt; Int&#123;</span><br><span class="line">//    return x! + y!</span><br><span class="line">    if x != nil &#123;</span><br><span class="line">        if y != nil &#123;</span><br><span class="line">            return x! + y!</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return x!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        if y != nil &#123;</span><br><span class="line">            return y!</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>也可以用 ?? 来实现</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return (a ?? 0) + b</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习14：在Swift里如何处理算术结果溢出</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A014%EF%BC%9A%E5%9C%A8Swift%E9%87%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%AE%97%E6%9C%AF%E7%BB%93%E6%9E%9C%E6%BA%A2%E5%87%BA/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A014%EF%BC%9A%E5%9C%A8Swift%E9%87%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%AE%97%E6%9C%AF%E7%BB%93%E6%9E%9C%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="溢出运算符"><a href="#溢出运算符" class="headerlink" title="溢出运算符"></a>溢出运算符</h1><ul><li><p>在默认情况下，当向一个整数赋超出它容量的值时，<code>swift</code> 会报错而不是生成一个无效的数，给我们操作过大或过小的数时提供了额外的安全性</p></li><li><p>同时提供三个算术溢出运算符来让系统支持整数溢出运算</p><ul><li>溢出加法 <code>&amp;+</code></li><li>溢出减法 <code>&amp;-</code></li><li>溢出乘法 <code>&amp;*</code></li></ul></li></ul><h1 id="值溢出"><a href="#值溢出" class="headerlink" title="值溢出"></a>值溢出</h1><ul><li>数值可以出现向上溢出或向下溢出</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020128841.png"                                     ></p><ul><li><p>溢出也会发生在有符号整型数值上</p></li><li><p>对于无符号与有符号整型数值来说，当出现溢出时，它们会从数值所能容纳的最大数变成最小的数，同样的，当发生下溢时，它们会从所能容纳的最小数变成最大的数</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020128708.png"                                     ></p><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><ul><li>上溢出</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020128353.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020128449.png"                                     ></p><ul><li>下溢出</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020129637.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020129471.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习13：赋值和算术运算符</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A013%EF%BC%9A%E8%B5%8B%E5%80%BC%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A013%EF%BC%9A%E8%B5%8B%E5%80%BC%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li><p>一元运算符对一个目标进行操作。一元前缀运算符（如!b），一元后缀运算符（b!）</p></li><li><p>二元运算符对两个目标进行操作（a+b）同时因为它们出现在两个目标之间，所以是中缀</p></li><li><p>三元运算符操作三个目标，<code>swift</code> 语言也仅有一个 <code>三元运算符</code>，三元条件运算符（a?b:c）</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020122710.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020122158.png"                                     ></p><h1 id="swift-运算符的改进"><a href="#swift-运算符的改进" class="headerlink" title="swift 运算符的改进"></a>swift 运算符的改进</h1><ul><li><p>swift在支持 <code>c</code> 中的大多数标准运算符的同时也增加了一些排除常见代码错误的能力</p></li><li><p>赋值符号 <code>=</code> 不会返回值，以防止它被无用于等于符号 <code>==</code> </p></li><li><p>算术符号 <code>+、-、*、/、%</code> 以及其他可以监测并阻止值溢出，以避免你在操作比存储类型允许的范围更大或更小的数字时得到各种奇怪的结果</p></li></ul><h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><ul><li><p>赋值运算符将一个值赋值给另外一个值</p></li><li><p>如果赋值符号右侧是拥有多个值的元组，它的元素将会一次性地拆分成常量或者变量</p></li><li><p>Swift 的赋值符号自身不会返回值</p></li></ul><h1 id="算术运算符-标准运算符"><a href="#算术运算符-标准运算符" class="headerlink" title="算术运算符-标准运算符"></a>算术运算符-标准运算符</h1><ul><li><p>标准算术运算符 <code>+ - * /</code></p></li><li><p>算术运算符同时也支持 <code>String</code> 的拼接</p></li><li><p><code>swift</code> 算术运算符默认不允许值溢出</p></li></ul><h1 id="算术运算符-余数运算符"><a href="#算术运算符-余数运算符" class="headerlink" title="算术运算符 - 余数运算符"></a>算术运算符 - 余数运算符</h1><ul><li><p>余数运算符 <code>a%b</code> 可以求出多少个 <code>b</code> 的倍数能够刚好放进 <code>a</code> 中并且返回剩下的值（就是我们所谓的余数）</p></li><li><p>当 <code>a</code> 是负数时也适用相同的方法来进行计算</p></li><li><p>当 <code>b</code> 为负数时它的正负号被忽略掉。这意味着 <code>a%b</code> 与 <code>a%-b</code> 能够获得相同的答案</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020123693.png"                                     ></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let c = 9 % 4</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">let d = 9 % -4</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">let e = -9 % 4</span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020124939.png"                                     ></p><h1 id="算术运算符-一元"><a href="#算术运算符-一元" class="headerlink" title="算术运算符 - 一元"></a>算术运算符 - 一元</h1><ul><li><p>数字值的正负号可以用前缀 <code>-</code> 来切换，我们称之为一元减号运算符</p></li><li><p>一元减号运算符 <code>-</code> 直接在要进行操作的值前边放置，不加任何空格</p></li><li><p>一元加号运算符 <code>+</code> 直接返回它操作的值，不会对其进行任何的修改</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习12：获取子串和字符串比较</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A012%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AD%90%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A012%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AD%90%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h1 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h1><ul><li><p>使用下标或者类似 <code>prefix(_:)</code> 的方法得到的子字符串是 <code>Substring</code> 类型</p></li><li><p><code>Substring</code> 拥有 <code>String</code> 的大部分方法</p></li><li><p><code>Substring</code> 可以转成 <code>String</code> 类型</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;hello,world&quot;</span><br><span class="line">let index = str.firstIndex(of: &quot;,&quot;) ?? str.endIndex</span><br><span class="line">let begin = str[..&lt;index]</span><br><span class="line">let new = String(begin)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020120015.png"                                     ></p><ul><li><p>子字符串重用一部分原字符串的内存</p></li><li><p>修改字符串或子字符串之前都不需要花费拷贝内存的代价</p></li><li><p><code>String</code> 和 <code>Substring</code> 都遵循 <code>StringProtocol</code> 协议，也就是说它基本上都能很方便的兼容所有接受 <code>StringProtocol</code> 值的字符串操作函数</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020121376.png"                                     ></p><h1 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h1><ul><li><p>字符串和字符相等性 <code>==</code> 和 <code>!=</code></p></li><li><p>前缀相等性 <code>hasPrefis(_:)</code></p></li><li><p>后缀相等性 <code>hasSubffix(_:)</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &quot;1&quot;</span><br><span class="line">var str2 = &quot;2&quot;</span><br><span class="line">print(str1 == str2)</span><br><span class="line">print(str1.hasPrefix(&quot;1&quot;))</span><br><span class="line">print(str2.hasSuffix(&quot;2&quot;))</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020121878.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习11：索引访问和修改字符串</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A011%EF%BC%9A%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A011%EF%BC%9A%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h1><ul><li><p>每一个 <code>String</code> 值都有相关的索引类型，<code>String.Index</code>，他相当于每个 <code>Character</code> 在字符串中的位置</p></li><li><p><code>startIndex</code> 属性来访问 <code>String</code> 中第一个 <code>Character</code> 的位置。<code>endIndex</code> 属性就是 <code>String</code> 中最后一个字符串的位置</p></li><li><p><code>endIndex</code> 属性并不是字符串下标脚本的合法实际参数</p></li><li><p>如果 <code>String</code> 为空，则 <code>startIndex</code> 与 <code>endIndex</code> 相等</p></li><li><p>使用 <code>index(before:)</code> 和 <code>index(after:)</code> 方法来访问给定索引的前后</p></li><li><p>要访问给定索引更远的索引，你可以使用 <code>index(_:offetBy:)</code></p></li><li><p>使用 <code>indices</code> 属性来访问字符串中每个字符的索引</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var greeting = &quot;Hello, playground&quot;</span><br><span class="line">greeting[greeting.startIndex]</span><br><span class="line">greeting[greeting.index(before: greeting.endIndex)]</span><br><span class="line">greeting[greeting.index(after: greeting.startIndex)]</span><br><span class="line">let index = greeting.index(greeting.startIndex, offsetBy: 7)</span><br><span class="line">greeting[index]</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020116804.png"                                     ></p><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><ul><li><p>插入字符，使用 <code>insert(_:at:)</code> 方法</p></li><li><p>插入到另一个字符串的内容到特定的索引，使用 <code>insert(contentsOf:at:)</code> 方法</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello&quot;</span><br><span class="line">str.insert(&quot;!&quot;, at: str.endIndex)</span><br><span class="line">str.insert(contentsOf: &quot; world&quot;, at: str.firstIndex(of: &quot;!&quot;)!)</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020117964.png"                                     ></p><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><ul><li>移除字符，使用 <code>remove(at:)</code> 方法</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello&quot;</span><br><span class="line">str.remove(at: str.index(before: str.endIndex))</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020117857.png"                                     ></p><ul><li>移除一小段特定范围的字符串，使用 <code>removeSubrange(_:)</code> 方法</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello&quot;</span><br><span class="line">let range = str.index(str.endIndex, offsetBy: -str.count)..&lt;str.endIndex</span><br><span class="line">str.removeSubrange(range)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020117645.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习10：字符串常见操作</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A010%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A010%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串的可变性"><a href="#字符串的可变性" class="headerlink" title="字符串的可变性"></a>字符串的可变性</h1><ul><li><code>var</code> 指定的可以修改</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020114183.png"                                     ></p><ul><li><code>let</code> 指定的不可修改</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020106762.png"                                     ></p><ul><li>对比 Object-C (NSString 和 NSMutableString)</li></ul><h1 id="字符串是-值类型"><a href="#字符串是-值类型" class="headerlink" title="字符串是 值类型"></a>字符串是 值类型</h1><ul><li><p><code>String</code> 值在传递给方法或函数的时候会被复制过去</p></li><li><p>赋值给常量或变量的时候也是一样</p></li><li><p>Swift 编译器优化了字符串使用的资源，实际上拷贝只会在确实需要的时候才进行</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &quot;hello&quot;</span><br><span class="line">var str2 = str1</span><br><span class="line">print(str1 == str2)</span><br><span class="line">str1.append(&quot;,world&quot;)</span><br><span class="line">print(str1)</span><br><span class="line">print(str2)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020109392.png"                                     ></p><h1 id="操作字符"><a href="#操作字符" class="headerlink" title="操作字符"></a>操作字符</h1><ul><li><p><code>for in</code> 循环遍历 <code>String</code> 中的每一个独立的 <code>Character</code></p></li><li><p><code>Character</code> 类型</p></li><li><p><code>String</code> 值可以通过传入 <code>Character</code> 数组来构造</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello&quot;</span><br><span class="line">for c in str&#123;</span><br><span class="line">    print(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020109024.png"                                     ></p><h1 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h1><ul><li><p>使用加运算符 <code>+</code> 创建新字符串</p></li><li><p>使用 <code>+</code> 赋值符号 <code>+=</code> 在已经存在的 <code>String</code> 值末尾追加一个 <code>String</code> 值</p></li><li><p>使用 <code>String</code> 类型的 <code>append()</code> 方法来可以给一个 <code>String</code> 变量的末尾追加 <code>Character</code> 值</p></li></ul><h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><ul><li><p>字符串插值是一种从混合常量、变量、字面量和表达式的字符串字面量构造新 <code>String</code> 值的方法</p></li><li><p>每一个你插入到字符串字面量的元素都要被一对圆括号包裹，然后使用反斜杠前缀 <code>\()</code></p></li><li><p>类似于 <code>NSString</code> 的 <code>stringWithFormat</code> 方法，但是更加简便，更强大</p></li><li><p>可以在扩展字符串分割符中创建一个包含在其他情况下会被当做字符串插值的字符</p></li><li><p>要在使用扩展分隔符的字符串中使用字符串插值，在反斜杠后使用匹配首尾井号数量的井号</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;6 * 7 = \(6 * 7)&quot;</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020110881.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020115034.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习09：字符串创建和使用</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A009%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A009%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="初始化空串"><a href="#初始化空串" class="headerlink" title="初始化空串"></a>初始化空串</h1><ul><li><p>字面量</p></li><li><p>初始化器语法</p></li><li><p><code>isEmpty</code> 检查是否为空串</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var emptyString = &quot;&quot;</span><br><span class="line">var anotherEmptyString = String()</span><br><span class="line"></span><br><span class="line">if emptyString.isEmpty &#123;</span><br><span class="line">    print(&quot;Nothing to see here&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020103809.png"                                     ></p><h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><ul><li><p>字符串字面量是被双引号 <code>“”</code> 包裹的固定顺序文本字符</p></li><li><p><code>Swift</code> 会为 <code>str</code> 常量推断类型为 <code>String</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;some string&quot;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020104645.png"                                     ></p><h1 id="多行字面量"><a href="#多行字面量" class="headerlink" title="多行字面量"></a>多行字面量</h1><ul><li><p>多行字符串字面量是用三个双引号引起来的一系列字符</p></li><li><p>多行字符串字面量把所有行包括在引号内，开始和结束默认不会有换行符</p></li><li><p>如果为了书写美观而不换行在后面加 \</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let someStr = &quot;&quot;&quot;</span><br><span class="line">1\</span><br><span class="line">2\</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">print(someStr)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020104457.png"                                     ></p><ul><li><p>要让多行字符串字面量起始或结束于换行，就在第一或最后一行写一个空行</p></li><li><p>多行字符串可以 <code>缩进</code> 以匹配周围的代码。双引号（”””）前的空格会告诉Swift其他行前应该有多少空白是需要忽略的</p></li><li><p>如果你在某行的空格超过了结束的双引号（”””），那么这些空格会被包含</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    let someStr = &quot;&quot;&quot;</span><br><span class="line">    1</span><br><span class="line">    2</span><br><span class="line">        3</span><br><span class="line">    4</span><br><span class="line">    5</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">print(someStr)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020104509.png"                                     ></p><h1 id="字符串里的特殊字符"><a href="#字符串里的特殊字符" class="headerlink" title="字符串里的特殊字符"></a>字符串里的特殊字符</h1><ul><li><p>转义特殊字符 \o（空字符）,\（反斜杠），\t（水平制表符），\n（换行符），\r（回车符），\”（双引号）以及 &#39;（单引号）</p></li><li><p>任意的 <code>Unicode</code> 标量，写作 <code>\u&#123;&#125;n</code>，里边的 <code>n</code> 是一个 <code>1-8</code> 位的16进制数字，其值是合法 <code>Unicode</code> 值</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;\u&#123;24&#125;&quot;</span><br></pre></td></tr></table></figure></div><ul><li>可以在多行字符串字面量中包含双引号（”）而不需要转义。要在多行字符串中包含文本 “”””””，转义至少一个双引号</li></ul><h1 id="扩展字符串分隔符-Raw-String"><a href="#扩展字符串分隔符-Raw-String" class="headerlink" title="扩展字符串分隔符(Raw String)"></a>扩展字符串分隔符(Raw String)</h1><ul><li><p>在字符串字面量中放置扩展分隔符来使 <code>包含特殊字符的字符串</code> 不让他们真的生效</p></li><li><p>把字符串放在双引号 (“) 内并由 (#) 包裹</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = #&quot;1\n2\n3\n&quot;#</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020105441.png"                                     ></p><ul><li>如果字符串里面有 <code>&quot;#</code> 则首尾需要两个 <code>##</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = ##&quot;1\&quot;#n2\#n3\#n&quot;##</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020105787.png"                                     ></p><ul><li>如果你需要字符串中某个特殊符号的效果，使用匹配你包裹的 <code>#</code> 号数量的 <code>#</code> 号，并在前面写转义符号 <code>\</code></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = #&quot;1\#n2\#n3\#n&quot;#</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020105373.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习08：Optional的使用Optional实现原理探索</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A008%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8Optional%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A008%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8Optional%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Optional-实现探究"><a href="#Optional-实现探究" class="headerlink" title="Optional-实现探究"></a>Optional-实现探究</h1><ul><li><p><code>Optional</code> 其实是一个标准库里的一个  <code>public 的 enum</code> 类型，而且是 <code>泛型</code> 的，泛型的类型是 <code>Wrapped</code></p></li><li><p>用标准库实现语言特性的典型</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020100711.png"                                     ></p><ul><li><p>Optional.none 就是 <code>nil</code></p></li><li><p>Optional.some 则包装了实际的值</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str:Optional&lt;String&gt; = &quot;abc&quot;</span><br><span class="line">if let actualStr = str &#123;</span><br><span class="line">    let count = actualStr.count</span><br><span class="line">    print(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020101182.png"                                     ></p><h1 id="Optional-解包实现"><a href="#Optional-解包实现" class="headerlink" title="Optional-解包实现"></a>Optional-解包实现</h1><ul><li>泛型属性 <code>unsafelyUnwrapped</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020102043.png"                                     ></p><ul><li>理论上我我们可以直接调用 <code>unsafelyUnwrapped</code> 获取可选项的值</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str:String? = &quot;abc&quot;</span><br><span class="line">let count = str.unsafelyUnwrapped.count</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020102203.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习07：Optional的使用</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A007%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A007%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要-Optional？"><a href="#为什么需要-Optional？" class="headerlink" title="为什么需要 Optional？"></a>为什么需要 Optional？</h1><ul><li>Object-C 里的 <code>nil</code> 是无类型的指针</li><li>Object-C 里面的数组、字典、集合等不允许放入 <code>nil</code></li><li>Object-C 所有 <code>对象的变量</code> 都可以为 <code>nil</code></li><li>Object-C 只能用在对象上，而在其他地方又用其他特殊值（例如NSNotFound）表示值的缺失</li></ul><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><ul><li><p>通过在 <code>变量类型</code> 后面加 <code>?</code> 表示</p><ul><li>这里有一个值，它等于 x</li></ul><p>  或者</p><ul><li>这里根本没有值</li></ul></li><li><p>你可以通过给可选变量赋值一个 <code>nil</code> 来将之设置为没有值</p><ul><li><p>在 Object-C 中 <code>nil</code> 是一个指向不存在对象的指针</p></li><li><p>在 Swift 中，<code>nil</code> 不是指针，它是 <code>值缺失的一种特殊类型</code>，任何类型的可选项都可以设置成 <code>nil</code> 而不仅仅是对象</p><ul><li>只有可选项才能设置为 nil</li></ul></li></ul></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str: String = nil</span><br><span class="line">var str1: String? = nil  </span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020049740.png"                                     ></p><h1 id="Optional-If-语句以及强制解包"><a href="#Optional-If-语句以及强制解包" class="headerlink" title="Optional-If 语句以及强制解包"></a>Optional-If 语句以及强制解包</h1><ul><li>可选项是没法直接使用的</li><li>需要用 <code>!</code> 号强制解包后才能使用（意思是我知道这个可选项里面有值，使用吧）</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str: String? = &quot;abc&quot;</span><br><span class="line">let count = str.count</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020050383.png"                                     ></p><p>需要改成如下代码，才能正确执行</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str: String? = &quot;abc&quot;</span><br><span class="line">let count = str!.count</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020050208.png"                                     ></p><p>或</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str: String? = &quot;abc&quot;</span><br><span class="line">if str != nil &#123;</span><br><span class="line">    let count = str!.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020051471.png"                                     ></p><h1 id="Optional-绑定"><a href="#Optional-绑定" class="headerlink" title="Optional-绑定"></a>Optional-绑定</h1><ul><li><p>可以使用 <code>可选绑定</code> 来判断可选项是否包含值，如果包含就把赋值给一个临时的 <code>常量或变量</code></p></li><li><p>可选绑定可以与 <code>if</code> 和 <code>while</code> 的语句使用来检查可选项内部的值，并赋值给一个变量或常量</p></li><li><p>同一个 <code>if</code> 语句中包含多可选项绑定，用逗号分割即可。如果任一可选绑定结果是 <code>nil</code> 或者 <code>布尔值</code> 为 <code>false</code> ，那么整个 <code>if</code> 判断会被看做 <code>false</code></p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str:String? = &quot;abc&quot;</span><br><span class="line">if let actualStr = str &#123;</span><br><span class="line">    let count = actualStr.count</span><br><span class="line">    print(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020052194.png"                                     ></p><h1 id="Optional-隐士解包"><a href="#Optional-隐士解包" class="headerlink" title="Optional - 隐士解包"></a>Optional - 隐士解包</h1><ul><li><p>有些可选项一旦被设定值之后，就会一直拥有值，在这种情况下，就可以去掉检查的需求，也不必每次访问的时候都进行解包</p></li><li><p>通过有声明的类型后边添加一个叹号（String!）而非问号（String?）来书写隐士解包可选项</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str:String! = &quot;abc&quot;</span><br><span class="line">let count = str.count</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020052565.png"                                     ></p><ul><li>隐士解包可选项主要被用在Swift <code>类</code> 的初始化过程中</li></ul><h1 id="Optional-可选链"><a href="#Optional-可选链" class="headerlink" title="Optional-可选链"></a>Optional-可选链</h1><ul><li><p>可选项后面加问号</p></li><li><p>如果可选项不为nil，返回一个可选项结果，否则为nil</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str:String? = &quot;abc&quot;</span><br><span class="line">let count = str?.count</span><br><span class="line">let lastIndex = count - 1</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020054934.png"                                     ></p><p>将上面的代码改为：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var str:String? = &quot;abc&quot;</span><br><span class="line">let count = str?.count</span><br><span class="line">//let lastIndex = count - 1</span><br><span class="line">if count != nil &#123;</span><br><span class="line">    let lastIndex = count! - 1</span><br><span class="line">    print(lastIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020054879.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习06：Tuple元组</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A006%EF%BC%9ATuple%E5%85%83%E7%BB%84/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A006%EF%BC%9ATuple%E5%85%83%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h1><ul><li><code>元组</code> 把多个值合并成单一的复合型的值</li><li><code>元组</code> 内的值可以是任何类型，而且可以不必是统一类型</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let error = (1,&quot;没有权限&quot;)</span><br><span class="line">print(error.0)</span><br><span class="line">print(error.1)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020044769.png"                                     ></p><h1 id="元素命名"><a href="#元素命名" class="headerlink" title="元素命名"></a>元素命名</h1><ul><li>元组中的每一个元素可以指定对应的元素名称</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let error = (errorCode:1,errorMessage:&quot;没有权限&quot;)</span><br><span class="line">print(error.errorCode)</span><br><span class="line">print(error.errorMessage)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020044807.png"                                     ></p><ul><li>如果没有指定名称的元素也可以使用下标的方式来引用</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let error = (1,&quot;没有权限&quot;)</span><br><span class="line">print(error.0)</span><br><span class="line">print(error.1)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020045931.png"                                     ></p><h1 id="Tuple-修改"><a href="#Tuple-修改" class="headerlink" title="Tuple 修改"></a>Tuple 修改</h1><ul><li>用 <code>var</code> 定义的元组就是可变元组，<code>let</code> 定义的元组就是不可变元组</li><li>不管是可变还是不可变元组，元组在创建后就不能增加和删除元素</li><li>可以对可变元组的元素进行修改，但是不能改变其类型</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var error = (errorCode:1,errorMessage:&quot;没有权限&quot;)</span><br><span class="line">error.errorCode = 2</span><br><span class="line">error.errorMessage = &quot;2&quot;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020045043.png"                                     ></p><ul><li><code>any</code> 类型可以改为任何类型</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var error: (Any,String) = (1,&quot;没有权限&quot;)</span><br><span class="line">error.0 = 2</span><br><span class="line">print(error)</span><br><span class="line">error.0 = &quot;abc&quot;</span><br><span class="line">print(error)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020046096.png"                                     ></p><h1 id="Tuple-分解"><a href="#Tuple-分解" class="headerlink" title="Tuple 分解"></a>Tuple 分解</h1><ul><li>将一个元组的内容分解成单独的常量或变量</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let error = (1,&quot;没有权限&quot;)</span><br><span class="line">let (errorCode,errorMessage) = error</span><br><span class="line">print(errorCode)</span><br><span class="line">print(errorMessage)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020047401.png"                                     ></p><ul><li>如果只需要使用其中的一部分数据，不需要的数据可以用下划线 <code>_</code> 代替</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let error = (1,&quot;没有权限&quot;)</span><br><span class="line">let (_,errorMessage) = error</span><br><span class="line">print(errorMessage)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020047151.png"                                     ></p><h1 id="作为函数返回值"><a href="#作为函数返回值" class="headerlink" title="作为函数返回值"></a>作为函数返回值</h1><ul><li>使用 <code>Tuple</code> 为函数返回多个值</li><li>返回值的 <code>Tuple</code> 可以再函数的返回类型部分被命名</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func writeToFile(content:String) -&gt; (errorCode:Int,errorMessage:String) &#123;</span><br><span class="line">    return (1,&quot;没有权限&quot;)</span><br><span class="line">&#125;</span><br><span class="line">let error = writeToFile(content: &quot;&quot;)</span><br><span class="line">print(error)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020048486.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习05：数值类型</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A005%EF%BC%9A%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A005%EF%BC%9A%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h1><ul><li><p>Swift 提供了 <code>8，16，32，64</code> 位编码的有符号和无符号整数</p></li><li><p>命名方式：例如 8位无符号整数的类型是 UInt8，32位有符号整数的类型是 Int32</p></li><li><p>通过 <code>min</code> 和 <code>max</code> 属性来访问每个整数类型的最小值和最大值</p></li><li><p>Swift 提供了一个额外的整数类型：Int，它拥有与当前平台的原生字相同的长度</p></li><li><p>同时 <code>Swift</code> 也提供 <code>UInt</code> 类型，来表示平台长度相关的无符号整型</p></li><li><p>建议在用到证书的地方都使用 Int</p></li></ul><h1 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h1><ul><li>Double：64位浮点数，至少有 15 位数字的精度</li><li>Float：32位浮点数，至少有 6 为数字的精度</li><li>在两种类型都可以的情况下，推荐使用 Double 类型</li></ul><h1 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020041147.png"                                     ></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = 8</span><br><span class="line">let b: UInt8 = 240</span><br><span class="line">print(&quot;UInt8 min \(UInt8.min),UInt8 max \(UInt8.max)&quot;)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020042980.png"                                     ></p><h1 id="Bool"><a href="#Bool" class="headerlink" title="Bool"></a>Bool</h1><ul><li>Bool：true 和 false</li><li>Swift 的类型安全机制会阻止你用一个非布尔量的值替换掉 Bool</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let i = 1</span><br><span class="line">if i &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020042119.png"                                     ></p><p>我们修改一下</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020042345.png"                                     ></p><h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><ul><li>类型别名是一个为 <code>已存在类型</code> 定义的一个 <code>可选择的名字</code></li><li>你可以用关键字 <code>typealias</code> 定义一个类型的别名</li><li>当你想通过在一个在上下文中看起来更合适可具有表达行的名字来引用一个已存在的类型时，这时别名就非常有用了</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 音频采样率</span><br><span class="line">typealias AudioSample = UInt8</span><br><span class="line">let sample:AudioSample = 32</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020043905.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习04：变量和常量</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A004%EF%BC%9A%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A004%EF%BC%9A%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="声明变量和常量"><a href="#声明变量和常量" class="headerlink" title="声明变量和常量"></a>声明变量和常量</h1><ul><li>使用关键字 <code>let</code> 声明常量</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = 1</span><br><span class="line">a = 2</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020038869.png"                                     ></p><p>由于 <code>x</code> 是常量，不能给常量赋值，会报错</p><ul><li>使用关键字 <code>var</code> 声明变量</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var b = 1</span><br><span class="line">b = 2</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020038019.png"                                     ></p><ul><li>可以在一行中声明多个变量和常量，用逗号分割</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x = 0.0,y = 1.0,z = 2.0</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020039534.png"                                     ></p><h1 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h1><ul><li><p>在声明一个变量或常量时提供类型标注，来明确变量或常量能够存储值的类型</p></li><li><p>添加 <code>类型标注</code> 的方法是在 <code>变量或常量</code> 的名字后面加一个 <code>冒号</code>，再跟一个 <code>空格</code>，最后加上使用的 <code>类型名称</code></p></li><li><p>可以在一行中定义多个相关的变量为相同的类型，用 <code>逗号</code> 分割，只要在最后的变量名字后加上类型标注</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a: String</span><br><span class="line">a = &quot;hello&quot;</span><br><span class="line">a = 10</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020039355.png"                                     ></p><h1 id="常量和变量命名"><a href="#常量和变量命名" class="headerlink" title="常量和变量命名"></a>常量和变量命名</h1><ul><li><p>常量和变量的名字几乎可以使用任何字符，甚至包括 <code>Unicode</code> 字符</p></li><li><p>常量和变量的名字不能包含 <code>空白字符、数学符号、箭头、保留的（或者无效的）Unicode码位、连线和制表符</code>。也不能以 <code>数字</code> 开头，尽管数字几乎可以使用在名字其他的任何地方</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let π = 3.1415</span><br><span class="line">let 你好 = &quot;你好世界&quot;</span><br><span class="line">let 🐶🐂 = &quot;dog,cow&quot;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020040575.png"                                     ></p><h1 id="打印常量和变量"><a href="#打印常量和变量" class="headerlink" title="打印常量和变量"></a>打印常量和变量</h1><ul><li><p>print(_:separator:teminator)</p></li><li><p>字符串插入</p></li></ul><p>用 <code>\()</code> 来插入</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let π = 3.1415</span><br><span class="line">let 你好 = &quot;你好世界&quot;</span><br><span class="line">let 🐶🐂 = &quot;dog,cow&quot;</span><br><span class="line"></span><br><span class="line">print(π)</span><br><span class="line">print(&quot;\(你好)&quot;)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020040638.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习03：Playgorund使用</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A003%EF%BC%9APlayground%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A003%EF%BC%9APlayground%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>Swift 的 <code>Playgorund</code> 是为了让人人都能愉快的学习 <code>swift</code> 编程</li><li>但发展至今，这个工具越来越强大</li></ul><h1 id="Playgorund-使用"><a href="#Playgorund-使用" class="headerlink" title="Playgorund 使用"></a>Playgorund 使用</h1><ul><li>创建一个 <code>Playgorund</code> 应用</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020034182.png"                                     ></p><ul><li>Next，默认名 <code>MyPlayground</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020035090.png"                                     ></p><ul><li>可以通过 New -&gt; Playground Page 创建多个 <code>Playground</code> 来学习</li></ul><p>注：快捷键</p><p>command + option + n 创建 Playground Page</p><p>command + shift + enter 快速运行程序</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020035896.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16776886044720.jpg"                                     ></p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><ul><li>写一个求和的函数</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 求和函数</span><br><span class="line">func sum(a:Int,b:Int) -&gt; Int &#123;</span><br><span class="line">    return a+b</span><br><span class="line">&#125;</span><br><span class="line">// 调用求和函数 赋值给 常量 c</span><br><span class="line">let c = sum(a: 1, b: 2)</span><br><span class="line">// 打印常量 c</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020037021.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习02：REPL交互式解释器</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A002%EF%BC%9AREPL%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A002%EF%BC%9AREPL%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul><li>xcode 6.1 引进了另外一种以交互式的方式来体验 <code>Swift</code> 的方法</li><li>Read Eval PrintLoop，简称REPL</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><code>REPL</code> 除了可以 <code>定义常量和变量</code> 外，还是可 <code>定义函数</code></p><ul><li>打开终端输入</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % swift</span><br><span class="line">mac@bogon ~ % swift repl</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020033029.png"                                     ></p><h1 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020032935.png"                                     ></p><h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020031861.png"                                     ></p><h1 id="REPL-其他命令"><a href="#REPL-其他命令" class="headerlink" title="REPL 其他命令"></a>REPL 其他命令</h1><ul><li>退出：:quit</li><li>帮助：:help</li><li>将光标移动到当前行的开始处：Control + A</li><li>将光标移动到当前行的结束处：Control + E</li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习01：Swift编译流程</title>
      <link href="/BboyZJ.github.io/2023/02/21/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A001%EF%BC%9ASwift%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
      <url>/BboyZJ.github.io/2023/02/21/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A001%EF%BC%9ASwift%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="编译器架构"><a href="#编译器架构" class="headerlink" title="编译器架构"></a>编译器架构</h1><p>Swift编译过程和OC基本类似，仅仅是前端编译器不一样。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020024798.png"                                     ></p><ul><li><code>OC/C</code> 前端编译器是 <code>Clang</code></li><li><code>Swift</code> 先解析成 <code>Swift AST</code>（抽象语法树），通过 <code>swiftc</code> 这个命令行参数，编译成 <code>Swift IL</code></li><li><code>OC</code> 和 <code>Swift</code> 最后均编译成 <code>LLVM IR</code> 中间层表示</li><li><code>OC</code> 和 <code>Swift</code> 最终通过 后端编译器 <code>LLVM compiler</code> ，编译成最终的在具体地址上可以执行的二进制，包括x86、arm和other</li></ul><h1 id="详细编译流程"><a href="#详细编译流程" class="headerlink" title="详细编译流程"></a>详细编译流程</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020025648.png"                                     ></p><ul><li>Swift 先解析成 <code>AST（抽象语法树）</code></li><li>经过一系列工具编程 <code>Swift</code> 的 <code>SIL(中间语言)</code></li><li>再经过 <code>分析、IR工具</code> 转成 <code>LLVM IR(中间表示层)</code>   </li><li>最终通过 后端编译器 LLVM compiler 编译成 .o 目标文件</li></ul><h1 id="命令行流程"><a href="#命令行流程" class="headerlink" title="命令行流程"></a>命令行流程</h1><p>使用终端创建一个简单的 <code>main.swift</code> 文件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd Desktop</span><br><span class="line">mac@bogon Desktop % touch main.swift</span><br></pre></td></tr></table></figure></div><p>此时你可以在桌面看到一个 <code>main.swift</code> 文件</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020026247.png"                                     ></p><p>在该文件下写下两个数相加的一个函数</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func sum(a:Int,b:Int) -&gt; Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let value = sum(a: 1, b: 2)</span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020027637.png"                                     ></p><ul><li>打开命令行工具</li></ul><p><code>mac@bogon ~ % cd Desktop</code></p><ul><li>生成 <code>AST</code> 抽象语法树</li></ul><p><code>mac@bogon ~ % swiftc main.swift -dump-ast</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020027831.png"                                     ></p><ul><li>生成 <code>SIL</code> 中间语言</li></ul><p><code>mac@bogon ~ % swiftc main.swift -emit-sil</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/20230302002831.png"                                     ></p><ul><li>生成 LLVM IR 中间表示层</li></ul><p><code>mac@bogon ~ % swiftc main.swift -emit-ir</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020029775.png"                                     ></p><ul><li>生成 Assembly Language 汇编语言</li></ul><p><code>mac@bogon ~ % swiftc main.swift -emit-assembly</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020030034.png"                                     ></p><ul><li>生成二进制文件</li></ul><p><code>mac@bogon ~ % swiftc -o main.out main.swift</code></p><p>命令行输入：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/01swift编译流程 </span><br><span class="line">mac@bogon 01swift编译流程 % swiftc -o main.out main.swift</span><br><span class="line">mac@bogon 01swift编译流程 % ./main.out</span><br><span class="line">3</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter面试题：Flutter总结</title>
      <link href="/BboyZJ.github.io/2023/02/16/%E9%9D%A2%E8%AF%95%E9%A2%98/Flutter%E9%9D%A2%E8%AF%95%E9%A2%9801%EF%BC%9AFlutter%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/BboyZJ.github.io/2023/02/16/%E9%9D%A2%E8%AF%95%E9%A2%98/Flutter%E9%9D%A2%E8%AF%95%E9%A2%9801%EF%BC%9AFlutter%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是flutter？原理是什么？"><a href="#什么是flutter？原理是什么？" class="headerlink" title="什么是flutter？原理是什么？"></a>什么是flutter？原理是什么？</h2><ol><li><p><code>flutter</code> 是 <code>google</code> 推出并 <code>开源的移动应用开发框架</code>，通过 <code>dart</code> 语言开发APP，一套代码可以同时运行在 <code>iOS</code> 和 <code>Android</code> 平台。</p></li><li><p><code>flutter</code> 底层使用 <code>skia</code> 作为 <code>2D渲染引擎</code>，通过自己的渲染引擎来 <code>绘制widget(组件)</code>，<code>dart</code> 语言借鉴了 <code>Java</code> 和 <code>JavaScript</code> 同时加入了一些 <code>现代编程语言</code> 特性。</p></li></ol><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter-面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC数据结构00：入门</title>
      <link href="/BboyZJ.github.io/2022/11/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8400%EF%BC%9A%E5%85%A5%E9%97%A8/"/>
      <url>/BboyZJ.github.io/2022/11/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8400%EF%BC%9A%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>数据结构概念：</li></ul><p>我们把现实中 大量复杂的问题 <code>以特定的数据类型和特定的存储结构保存到</code> 主存储器（内存）中，在此基础上实现某个功能（排序等）的操作叫 <code>算法</code>。</p><p>数据结构 &#x3D; 元素 + 元素关系</p><p>算法 &#x3D; 对数据结构的操作</p><ul><li>算法：解决问题的方法和步骤</li></ul><p>衡量标准：</p><p>时间复杂度：<code>算法要执行的次数</code>，非执行时间</p><p>空间复杂度：算法执行过程<code>大概要占用的最大内存</code></p><h1 id="指针定义"><a href="#指针定义" class="headerlink" title="指针定义"></a>指针定义</h1><ul><li><p>地址</p><p>  地址是 <code>内存单元的编号</code>，其编号从 0 开始的非负整数，范围：0 – 0xFFFFFFFF x64平台下最大内存地址为 2^64 - 1</p></li><li><p>指针</p><p>  <code>指针就是地址，地址就是指针</code>，<code>指针变量</code> 是存放 <code>内存单元地址</code> 的变量，它内部保存的值是对应的 <code>地址</code>，地址就是 <code>内存单元编号</code>。</p></li></ul><p>例子：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int  i = 10; // 定义一个 整形变量 i 初始值 10</span><br><span class="line"></span><br><span class="line">int *p = i; // 定义一个 整形的指针变量 p，变量 p 指向 i 的地址</span><br><span class="line"></span><br><span class="line">// 这两行等于上面两行</span><br><span class="line">int *p; </span><br><span class="line">*p = &amp;i;</span><br></pre></td></tr></table></figure></div><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体是用户根据自己的实际需要，自定义的复合数据类型</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 学生类型</span><br><span class="line">typedef struct Student &#123; // 结构体定义</span><br><span class="line">    int age;</span><br><span class="line">    char * name;</span><br><span class="line">&#125;myStudent;</span><br><span class="line"></span><br><span class="line">// 直接传递 只占用 4 byte 的指针，省时效率也高&lt;推荐用法&gt;</span><br><span class="line">void func(struct Student * p)&#123;</span><br><span class="line">    print(&quot;age = %d&quot;,p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>有两种结构体的使用方式：</p><ul><li>直接使用</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct Student stu = &#123;12,&quot;xiaojian&quot;&#125;;</span><br></pre></td></tr></table></figure></div><ul><li>通过指针使用</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct Student *p = &amp;stu;</span><br><span class="line">p -&gt; age = 31;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-数据结构探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC数据结构02：二叉树探索</title>
      <link href="/BboyZJ.github.io/2020/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h1><p>树形结构，<code>两个节点</code> 以内均称为 <code>二叉树</code>，分为 <code>左子树</code> 和 <code>右子树</code>，有顺序，不能颠倒；比如把人看做树：头是树根，左右是坐子树，右手是右子树。</p><h1 id="二叉树遍历类型"><a href="#二叉树遍历类型" class="headerlink" title="二叉树遍历类型"></a>二叉树遍历类型</h1><ol><li>深度优先遍历：<code>采用栈</code></li></ol><ul><li>先序遍历：对任一子树，先访问根，然后遍历左子树，最后遍历其右子树</li><li>中序遍历：对任一子树，先遍历左子树，然后访问根，最后遍历其右子树</li><li>后序遍历：对任一子树，先遍历其左子树，然后遍历其右子树，最后访问根</li></ul><ol start="2"><li>广度优先遍历：<code>采用队列</code></li></ol><p>层次遍历，<code>从上往下</code> 对每一层依次访问，每一层从 <code>左往右（或从右往左）访问节点</code>，访问完一层就进入下一层，直到没有节点可以访问为止。</p><ol start="3"><li>区别：</li></ol><ul><li><p>深度优先算法：不全部保留节点，占用空间小，有回溯操作，<code>运行速度慢</code>，<code>用时间换空间</code></p></li><li><p>广度优先算法：保留全部节点，占用空间大，无回溯操作，<code>运行速度快</code>，<code>用空间换时间</code></p></li></ul><h1 id="二叉排序树的好处？"><a href="#二叉排序树的好处？" class="headerlink" title="二叉排序树的好处？"></a>二叉排序树的好处？</h1><p>二叉树是一种比较折中的方案；数组的搜索比较方便，可以直接用下标，但删除或插入比较耗时；<br>链表与之相反，删除或插入很快，但查找很慢；二叉排序树既有链表的好处，也有数组的好处，在处理大批量的动态数据是比较有用的</p><h1 id="二叉排序树节点定义"><a href="#二叉排序树节点定义" class="headerlink" title="二叉排序树节点定义"></a>二叉排序树节点定义</h1><p>采用单项链表的形式，只从根节点指向孩子节点，不保存父节点。</p><p>对于二叉搜索树这种数据类型，用简单的数组来表示是不适合的。所以要建立一个模型：</p><ul><li>值：就用最简单的整数来表示，实际使用中，这个整型值也是必不可少的，可以当做key来用，这是二叉搜索树排序的凭证。</li><li>左子树：用一个同类型的指针表示</li><li>右子树：用一个同类型的指针表示</li></ul><p>以上3个是二叉搜索树必不可少的属性</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 二叉排序树节点</span><br><span class="line">@interface BinaryTreeNode : NSObject</span><br><span class="line">// 值</span><br><span class="line">@property (nonatomic, assign) NSInteger value;</span><br><span class="line">// 左节点</span><br><span class="line">@property (nonatomic, strong) BinaryTreeNode *leftNode;</span><br><span class="line">// 右节点</span><br><span class="line">@property (nonatomic, strong) BinaryTreeNode *rightNode;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><h1 id="如何验证两个二叉树是完全相等的？"><a href="#如何验证两个二叉树是完全相等的？" class="headerlink" title="如何验证两个二叉树是完全相等的？"></a>如何验证两个二叉树是完全相等的？</h1><p><code>递归</code> 去判断每个节点的 <code>值</code> 是否相等，如果均相等，则两个二叉树完全相等</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)isSameTree:(TreeNode *)root1 tree:(TreeNode *)root2&#123;</span><br><span class="line">   if (root1 == null &amp;&amp; root2 == null) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">if ((root1 == null &amp;&amp; root2 != null) || (root1 != null &amp;&amp; root2 == null))&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if (root1.val != root2.val) &#123; // 判断每个节点的值是否相等，如果去除此判断，则判断两个二叉树是否结构相等</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return [self isSameTree:root1.left tree:root2.left] &amp;&amp; [self isSameTree:root1.right tree:root2.right];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="创建二叉排序树"><a href="#创建二叉排序树" class="headerlink" title="创建二叉排序树"></a>创建二叉排序树</h1><ol><li>二叉树中左右节点值本身没有大小之分，所以如果要创建二叉树，就需要考虑如何处理某个节点是左节点还是右节点，如何终止某个子树而切换到另一个子树。 因此我选择了 <code>二叉排序树</code>，二叉排序树中对于左右节点有明确的要求，程序可以自动根据键值大小自动选择是左节点还是右节点。</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  创建二叉排序树</span><br><span class="line"> *  二叉排序树：左节点值全部小于根节点值，右节点值全部大于根节点值</span><br><span class="line"> *  @param values 数组</span><br><span class="line"> *  @return 二叉树根节点</span><br><span class="line"> */</span><br><span class="line">+ (BinaryTreeNode *)createTreeWithValues:(NSArray *)values &#123;</span><br><span class="line">    BinaryTreeNode *root = nil;</span><br><span class="line">    for (NSInteger i=0; i&lt;values.count; i++) &#123;</span><br><span class="line">        NSInteger value = [(NSNumber *)[values objectAtIndex:i] integerValue];</span><br><span class="line">        root = [BinaryTree addTreeNode:root value:value];</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  向二叉排序树节点添加一个节点</span><br><span class="line"> *</span><br><span class="line"> *  @param treeNode 根节点</span><br><span class="line"> *  @param value    值</span><br><span class="line"> *</span><br><span class="line"> *  @return 根节点</span><br><span class="line"> */</span><br><span class="line">+ (BinaryTreeNode *)addTreeNode:(BinaryTreeNode *)treeNode value:(NSInteger)value &#123;</span><br><span class="line">    //根节点不存在，创建节点</span><br><span class="line">    if (!treeNode) &#123;</span><br><span class="line">        treeNode = [BinaryTreeNode new];</span><br><span class="line">        treeNode.value = value;</span><br><span class="line">        NSLog(@&quot;node:%@&quot;, @(value));</span><br><span class="line">    &#125;</span><br><span class="line">    else if (value &lt;= treeNode.value) &#123;</span><br><span class="line">        NSLog(@&quot;to left&quot;);</span><br><span class="line">        // 值小于根节点，则插入到左子树</span><br><span class="line">        treeNode.leftNode = [BinaryTree addTreeNode:treeNode.leftNode value:value];</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        NSLog(@&quot;to right&quot;);</span><br><span class="line">        // 值大于根节点，则插入到右子树</span><br><span class="line">        treeNode.rightNode = [BinaryTree addTreeNode:treeNode.rightNode value:value];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return treeNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="2"><li>实际使用</li></ol><p>1）创建一个二叉树类BinaryTreeNode，在类中实现如下代码：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface BinaryTreeNode : NSObject</span><br><span class="line">// 值：当做key来用，是排序用的凭证</span><br><span class="line">@property (nonatomic,assign)NSInteger value;</span><br><span class="line">// 左子树</span><br><span class="line">@property (nonatomic,strong)BinaryTreeNode * leftChild;</span><br><span class="line">// 右子树</span><br><span class="line">@property (nonatomic,strong)BinaryTreeNode * rightChild;</span><br><span class="line"></span><br><span class="line">// 创建二叉排序树</span><br><span class="line">+ (BinaryTreeNode *)createBinaryTreeWithValues:(NSArray *)values;</span><br><span class="line">// 向二叉排序树中添加一个节点</span><br><span class="line">+ (BinaryTreeNode *)addNode:(BinaryTreeNode *)rootNode value:(NSInteger)value;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 创建二叉排序树</span><br><span class="line"> 二叉排序树：左节点值全部小于根节点值，右节点值全部大于根节点值</span><br><span class="line"> @param values：数组</span><br><span class="line"> @return 二叉排序树根节点</span><br><span class="line"> */</span><br><span class="line">+ (BinaryTreeNode *)createBinaryTreeWithValues:(NSArray *)values&#123;</span><br><span class="line">    BinaryTreeNode * rootNode = nil;</span><br><span class="line">    for (NSNumber * number in values) &#123;</span><br><span class="line">        NSInteger value = [number integerValue];</span><br><span class="line">        rootNode = [BinaryTreeNode addNode:rootNode value:value];</span><br><span class="line">    &#125;</span><br><span class="line">    return rootNode;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> 向二叉排序树节点添加一个节点</span><br><span class="line"> @param rootNode 根节点</span><br><span class="line"> @param value    值</span><br><span class="line"> </span><br><span class="line"> @return 根节点</span><br><span class="line"> */</span><br><span class="line">+ (BinaryTreeNode *)addNode:(BinaryTreeNode *)rootNode value:(NSInteger)value&#123;</span><br><span class="line">    // 根节点不存在，创建节点</span><br><span class="line">    if (rootNode == nil) &#123;</span><br><span class="line">        rootNode = [[BinaryTreeNode alloc] init];</span><br><span class="line">        rootNode.value = value;</span><br><span class="line">        NSLog(@&quot;node:%@&quot;,@(value));</span><br><span class="line">    &#125;else if (value &lt;= rootNode.value) &#123;</span><br><span class="line">        NSLog(@&quot;to left&quot;);</span><br><span class="line">        // 值小于根节点，则插入到左子树；这是递归，左子树将做同样的事儿</span><br><span class="line">        rootNode.leftChild = [self addNode:rootNode.leftChild value:value];</span><br><span class="line">    &#125;else if (value &gt; rootNode.value) &#123;</span><br><span class="line">        NSLog(@&quot;to right&quot;);</span><br><span class="line">        // 值大于根节点，则插入到右子树；这是递归，右子树将做同样的事儿</span><br><span class="line">        rootNode.rightChild = [self addNode:rootNode.rightChild value:value];</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        NSLog(@&quot;二叉排序树没有键值相等的节点，值%@已存在，不能插入&quot;,@(value));</span><br><span class="line">    &#125;</span><br><span class="line">    return rootNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>2）在controller中，用一个属性持有这个二叉搜索树。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">//二叉树</span><br><span class="line">#import &quot;BinaryTreeNode.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">// 二叉搜索树的根节点，代表一棵树</span><br><span class="line">@property (strong, nonatomic) BinaryTreeNode *rootNode;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p>输入用一串值，得到一颗二叉搜索树</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //创建一个二叉树</span><br><span class="line">    NSArray *values = @[@200, @23, @456, @89, @23, @670, @5674, @15];</span><br><span class="line">    self.rootNode = [BinaryTreeNode createBinaryTreeWithValues:values];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>3）用断点，查看“链式”结构，同时通过log可以看出创建过程。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061815766.png"                                     ></p><p>4）生成的二叉树图</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061815334.png"                                     ></p><h1 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h1><ol><li>先访问根，再遍历左子树，再遍历右子树。典型的递归思想。</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  先序遍历</span><br><span class="line"> *  先访问根，再遍历左子树，再遍历右子树</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *  @param handler  访问节点处理函数</span><br><span class="line"> */</span><br><span class="line">+ (void)preOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123;</span><br><span class="line">    if (rootNode) &#123; // 先根</span><br><span class="line">        if (handler) &#123;</span><br><span class="line">            handler(rootNode);</span><br><span class="line">        &#125;</span><br><span class="line">        // 再左</span><br><span class="line">        [self preOrderTraverseTree:rootNode.leftNode handler:handler];</span><br><span class="line">        // 最后右</span><br><span class="line">        [self preOrderTraverseTree:rootNode.rightNode handler:handler];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="2"><li>实际使用</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 先序遍历</span><br><span class="line">- (void)preOrderTraverse&#123;</span><br><span class="line">    NSMutableArray * preArr = [NSMutableArray array];</span><br><span class="line">    [BinaryTreeNode preOrderTraverseTree:self.rootNode handler:^(BinaryTreeNode * _Nonnull treeNode) &#123;</span><br><span class="line">        [preArr addObject:[NSNumber numberWithInteger:treeNode.value]];</span><br><span class="line">    &#125;];</span><br><span class="line">    NSLog(@&quot;先序遍历：%@&quot;, preArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>查看打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2020-08-26 22:45:09.310234+0800 OC-二叉树[50561:2829401] 先序遍历：(</span><br><span class="line">    200,</span><br><span class="line">    23,</span><br><span class="line">    15,</span><br><span class="line">    89,</span><br><span class="line">    456,</span><br><span class="line">    670,</span><br><span class="line">    5674</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><ol><li>先遍历左子树，再访问根，再遍历右子树。<br>对于二叉排序树来说，中序遍历得到的序列是一个从小到大排序好的序列。</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  中序遍历</span><br><span class="line"> *  先遍历左子树，再访问根，再遍历右子树</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *  @param handler  访问节点处理函数</span><br><span class="line"> */</span><br><span class="line">+ (void)inOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123;</span><br><span class="line">    if (rootNode) &#123;</span><br><span class="line">        [self inOrderTraverseTree:rootNode.leftNode handler:handler];</span><br><span class="line">        if (handler) &#123;</span><br><span class="line">            handler(rootNode);</span><br><span class="line">        &#125;</span><br><span class="line">        [self inOrderTraverseTree:rootNode.rightNode handler:handler];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="2"><li>实际使用</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//中序遍历</span><br><span class="line">- (void)inOrderTraverse&#123;</span><br><span class="line">    NSMutableArray * inArr = [NSMutableArray array];</span><br><span class="line">    [BinaryTreeNode inOrderTraverseTree:self.rootNode handler:^(BinaryTreeNode * _Nonnull treeNode) &#123;</span><br><span class="line">        [inArr addObject:[NSNumber numberWithInteger:treeNode.value]];</span><br><span class="line">    &#125;];</span><br><span class="line">    NSLog(@&quot;中序遍历：%@&quot;, inArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>查看打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2020-08-26 22:49:26.310344+0800 OC-二叉树[50591:2832806] 中序遍历：(</span><br><span class="line">    15,</span><br><span class="line">    23,</span><br><span class="line">    89,</span><br><span class="line">    200,</span><br><span class="line">    456,</span><br><span class="line">    670,</span><br><span class="line">    5674</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h1 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h1><ol><li>先遍历左子树，再遍历右子树，再访问根</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  后序遍历</span><br><span class="line"> *  先遍历左子树，再遍历右子树，再访问根</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *  @param handler  访问节点处理函数</span><br><span class="line"> */</span><br><span class="line">+ (void)afterOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123;</span><br><span class="line">    if (rootNode) &#123;</span><br><span class="line">        [self afterOrderTraverseTree:rootNode.leftNode handler:handler];</span><br><span class="line">        [self afterOrderTraverseTree:rootNode.rightNode handler:handler];</span><br><span class="line">        if (handler) &#123;</span><br><span class="line">            handler(rootNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="2"><li>实际使用</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//后序遍历</span><br><span class="line">- (void)afterOrderTraverse&#123;</span><br><span class="line">    NSMutableArray * afterArr = [NSMutableArray array];</span><br><span class="line">    [BinaryTreeNode afterOrderTraverseTree:self.rootNode handler:^(BinaryTreeNode * _Nonnull treeNode) &#123;</span><br><span class="line">        [afterArr addObject:[NSNumber numberWithInteger:treeNode.value]];</span><br><span class="line">    &#125;];</span><br><span class="line">    NSLog(@&quot;后序遍历：%@&quot;, afterArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>查看打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2020-08-26 22:51:50.637367+0800 OC-二叉树[50628:2835309] 后序遍历：(</span><br><span class="line">    15,</span><br><span class="line">    89,</span><br><span class="line">    23,</span><br><span class="line">    5674,</span><br><span class="line">    670,</span><br><span class="line">    456,</span><br><span class="line">    200</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><ol><li>你会翻转二叉树吗？如果不会，那对不起，我们不会录用你！</li></ol><p>翻转二叉树，又叫求二叉树的镜像，就是把二叉树的左右子树对调（当然是递归的）</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 翻转二叉树（又叫：二叉树的镜像）</span><br><span class="line"> @param rootNode 根节点</span><br><span class="line"> @return 翻转后的树根节点（其实就是原二叉树的根节点）</span><br><span class="line"> */</span><br><span class="line">// 翻转二叉树</span><br><span class="line">+ (BinaryTreeNode *)flipBinaryTree:(BinaryTreeNode *)rootNode&#123;</span><br><span class="line">    // 判空</span><br><span class="line">    if(!rootNode)&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 没有子节点</span><br><span class="line">    if(!rootNode.leftNode &amp;&amp; !rootNode.rightNode)&#123;</span><br><span class="line">        return rootNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 左右子树递归</span><br><span class="line">    [self flipBinaryTree:rootNode.leftNode];</span><br><span class="line">    [self flipBinaryTree:rootNode.rightNode];</span><br><span class="line">    </span><br><span class="line">    // 左右节点交换</span><br><span class="line">    BinaryTreeNode * tempNode = rootNode.leftNode;</span><br><span class="line">    rootNode.leftNode = rootNode.rightNode;</span><br><span class="line">    rootNode.rightNode = tempNode.leftNode;</span><br><span class="line">    </span><br><span class="line">    return rootNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ol start="2"><li>实际使用</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 翻转二叉树</span><br><span class="line">- (void)invertBinaryTree&#123;</span><br><span class="line">    self.rootNode = [BinaryTreeNode invertBinaryTree:self.rootNode];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>查看打印结果</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061815476.png"                                     ></p><p>生成二叉树的图</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061815862.png"                                     ></p><h1 id="查找二叉树中某个位置的结点"><a href="#查找二叉树中某个位置的结点" class="headerlink" title="查找二叉树中某个位置的结点"></a>查找二叉树中某个位置的结点</h1><p>类似索引操作，按 <code>层次</code> 遍历，位置从0开始算。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 查找二叉树某个位置的结点</span><br><span class="line"> @param index 按层次便利树是的位置（从0开始）</span><br><span class="line"> @param rootNode 树根结点</span><br><span class="line"> @return 结点</span><br><span class="line"> */</span><br><span class="line">// 指定位置查找节点</span><br><span class="line">+ (BinaryTreeNode *)findTreeNodeAtIndex:(int)index withRootTree:(BinaryTreeNode *)rootNode&#123;</span><br><span class="line">    // 如果节点不存在，查找位置不符合规范</span><br><span class="line">    if (!rootNode || index &lt; 0)&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray * queueArr = [NSMutableArray arrayWithCapacity:0];</span><br><span class="line">    // 压入根节点</span><br><span class="line">    [queueArr addObject:rootNode];</span><br><span class="line">    while (queueArr.count &gt; 0) &#123;</span><br><span class="line">        BinaryTreeNode * node = [queueArr firstObject];</span><br><span class="line">        // 如果是根节点，则直接返回</span><br><span class="line">        if(index == 0)&#123;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        // 仿照队列先进先出FIFO，移除最前面的节点</span><br><span class="line">        [queueArr removeObjectAtIndex:0];</span><br><span class="line">        index --;</span><br><span class="line">        </span><br><span class="line">        // 按照从左往右依次压入节点</span><br><span class="line">        if(node.leftNode)&#123;</span><br><span class="line">            [queueArr addObject:node.leftNode];</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.rightNode)&#123;</span><br><span class="line">            [queueArr addObject:node.rightNode];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 遍历完，还没有找到位置，返回nil</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在controller中调用</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 查找某个位置的节点</span><br><span class="line">- (void)searchNode&#123;</span><br><span class="line">    BinaryTreeNode * node = [BinaryTreeNode findTreeNodeAtIndex:4 withTree:self.rootNode];</span><br><span class="line">    NSLog(@&quot;node-------%@&quot;,[NSNumber numberWithInteger:node.value]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">********打印结果******</span><br><span class="line">2020-08-27 11:29:47.724120+0800 OC-二叉树[51450:2892148] node-------89</span><br></pre></td></tr></table></figure></div><h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h1><ol><li><p>按照从上到下、从左到右的次序进行遍历。先遍历完一层，再遍历下一层，因此又叫广度优先遍历。需要用到队列，在OC里可以用可变数组来实现。</p><p>根改了：NSArray *values &#x3D; @[@100, @23, @45, @89, @23, @67, @54, @15];</p></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">层次遍历（广度优先）</span><br><span class="line"></span><br><span class="line">@param rootNode 树根节点</span><br><span class="line">@param handler 访问节点处理函数</span><br><span class="line">*/</span><br><span class="line">// 层次遍历</span><br><span class="line">+ (void)levelTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *))handler&#123;</span><br><span class="line">    // 空节点</span><br><span class="line">    if(!rootNode)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 数组当成队列</span><br><span class="line">    NSMutableArray * queueArr = [NSMutableArray array];</span><br><span class="line">    // 压入根节点</span><br><span class="line">    [queueArr addObject:rootNode];</span><br><span class="line">    // 当队列有数据的时候去遍历</span><br><span class="line">    while (queueArr.count &gt; 0) &#123;</span><br><span class="line">        BinaryTreeNode * node = [queueArr firstObject];</span><br><span class="line">        if (handler)&#123;</span><br><span class="line">            handler(node);</span><br><span class="line">        &#125;</span><br><span class="line">        // 仿照队列先进先出FIFO，移除最前面的节点</span><br><span class="line">        [queueArr removeObjectAtIndex:0];</span><br><span class="line">        </span><br><span class="line">        // 按照从左往右依次压入节点</span><br><span class="line">        if(node.leftNode)&#123;</span><br><span class="line">            [queueArr addObject:node.leftNode];</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.rightNode)&#123;</span><br><span class="line">            [queueArr addObject:node.rightNode];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ol start="2"><li>在controller中调用</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//层次遍历</span><br><span class="line">- (void)levelTraverse&#123;</span><br><span class="line">    NSMutableArray * levelArr = [NSMutableArray array];</span><br><span class="line">    [BinaryTreeNode levelTraverseTree:self.rootNode handler:^(BinaryTreeNode * _Nonnull treeNode) &#123;</span><br><span class="line">        NSLog(@&quot;value:%ld&quot;,treeNode.value);</span><br><span class="line">        [levelArr addObject:treeNode];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>次遍历：查看打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2020-08-31 17:18:50.185983+0800 OC-二叉树[59736:4179500] value:100</span><br><span class="line">2020-08-31 17:18:50.186414+0800 OC-二叉树[59736:4179500] value:23</span><br><span class="line">2020-08-31 17:18:50.186896+0800 OC-二叉树[59736:4179500] value:15</span><br><span class="line">2020-08-31 17:18:50.187158+0800 OC-二叉树[59736:4179500] value:45</span><br><span class="line">2020-08-31 17:18:50.187479+0800 OC-二叉树[59736:4179500] value:89</span><br><span class="line">2020-08-31 17:18:50.187753+0800 OC-二叉树[59736:4179500] value:67</span><br><span class="line">2020-08-31 17:18:50.188040+0800 OC-二叉树[59736:4179500] value:54</span><br></pre></td></tr></table></figure></div><h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><ol><li>二叉树的深度定义为：从根节点到叶子结点依次经过的结点形成树的一条路径,最长路径的长度为树的深度。<br>1）如果根节点为空，则深度为0；<br>2）如果左右节点都是空，则深度为1；<br>3）递归思想：二叉树的深度&#x3D;max（左子树的深度，右子树的深度）+ 1</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 二叉树的深度</span><br><span class="line"> @param rootNode 二叉树根节点</span><br><span class="line"> @return 二叉树的深度</span><br><span class="line"> */</span><br><span class="line">// 二叉树的深度</span><br><span class="line">+ (NSInteger)depthOfTree:(BinaryTreeNode *)rootNode&#123;</span><br><span class="line">    if (!rootNode)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 左子树深度</span><br><span class="line">    NSInteger leftDepth = [self depthOfTree:rootNode.leftNode];</span><br><span class="line">    // 右子树深度</span><br><span class="line">    NSInteger rightDepth = [self depthOfTree:rootNode.rightNode];</span><br><span class="line">    // 二叉树深度</span><br><span class="line">    NSInteger totalDepth = MAX(leftDepth, rightDepth) + 1;</span><br><span class="line">    </span><br><span class="line">    return totalDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="2"><li>在controller中调用</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//树的深度</span><br><span class="line">- (void)depthTree&#123;</span><br><span class="line">    NSInteger depth = [BinaryTreeNode depthOfTree:self.rootNode];</span><br><span class="line">    NSLog(@&quot;depth:%ld&quot;,depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>查看结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-08-31 17:29:49.989752+0800 OC-二叉树[59816:4186549] depth:6</span><br></pre></td></tr></table></figure></div><h1 id="二叉树的宽度"><a href="#二叉树的宽度" class="headerlink" title="二叉树的宽度"></a>二叉树的宽度</h1><p>二叉树的 <code>宽度</code> 定义为各层节点数的最大值。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树的宽度</span><br><span class="line"> *  @param rootNode 二叉树根节点</span><br><span class="line"> *  @return 二叉树宽度</span><br><span class="line"> */</span><br><span class="line">+ (NSInteger)widthOfTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray * queueArray = [NSMutableArray array]; </span><br><span class="line">    [queueArray addObject:rootNode]; // 压入根节点</span><br><span class="line">    NSInteger maxWidth = 1; // 最大的宽度，初始化为1（因为已经有根节点）</span><br><span class="line">    NSInteger curWidth = 0; // 当前层的宽度</span><br><span class="line">    </span><br><span class="line">    while (queueArray.count &gt; 0) &#123;</span><br><span class="line">        curWidth = queueArray.count;</span><br><span class="line">        //依次弹出当前层的节点</span><br><span class="line">        for (NSInteger i=0; i&lt;curWidth; i++) &#123;</span><br><span class="line">            BinaryTreeNode * node = [queueArray firstObject];</span><br><span class="line">             // 弹出最前面的节点，仿照队列先进先出原则</span><br><span class="line">            [queueArray removeObjectAtIndex:0];</span><br><span class="line">            // 压入左子数</span><br><span class="line">            if (node.leftNode) &#123;</span><br><span class="line">                [queueArray addObject:node.leftNode];</span><br><span class="line">            &#125;</span><br><span class="line">            // 压入右子树</span><br><span class="line">            if (node.rightNode) &#123;</span><br><span class="line">                [queueArray addObject:node.rightNode];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 宽度 = 当前层节点数</span><br><span class="line">        maxWidth = MAX(maxWidth, queueArray.count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return maxWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>vc实现</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 二叉树宽度</span><br><span class="line">NSInteger width = [BinaryTreeNode widthOfTree:self.rootNode];</span><br><span class="line">NSLog(@&quot;width-%ld&quot;,width);</span><br></pre></td></tr></table></figure></div><p>打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-26 16:21:36.767352+0800 二叉树[4523:170689] width-2</span><br></pre></td></tr></table></figure></div><h1 id="二叉树的所有节点数"><a href="#二叉树的所有节点数" class="headerlink" title="二叉树的所有节点数"></a>二叉树的所有节点数</h1><p>递归思想：二叉树所有节点数 &#x3D; 左子树节点数 + 右子树节点数 + 1</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树的所有节点数</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 所有节点数</span><br><span class="line"> */</span><br><span class="line">// 二叉树所有节点数</span><br><span class="line">+ (NSInteger)numberOfNodesInTree:(BinaryTreeNode *)rootNode&#123;</span><br><span class="line">    if (!rootNode)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 总节点数 = 左子树节点数 + 右子树节点数 + 1</span><br><span class="line">    NSInteger totalNode = [self numberOfNodesInTree:rootNode.leftNode] + [self numberOfNodesInTree:rootNode.rightNode] + 1;</span><br><span class="line">    </span><br><span class="line">    return totalNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>vc实现</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 二叉树节点数</span><br><span class="line">NSInteger totalNode = [BinaryTreeNode numberOfNodesInTree:self.rootNode];</span><br><span class="line">NSLog(@&quot;totalNode-%ld&quot;,totalNode);</span><br></pre></td></tr></table></figure></div><p>打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-26 16:10:38.371816+0800 二叉树[4369:160462] totalNode-5</span><br></pre></td></tr></table></figure></div><h1 id="二叉树某层中的节点数"><a href="#二叉树某层中的节点数" class="headerlink" title="二叉树某层中的节点数"></a>二叉树某层中的节点数</h1><p>1）根节点为空，则节点数为0；</p><p>2）层为1，则节点数为1（即根节点）</p><p>3）递归思想：二叉树第k层节点数 &#x3D; 左子树第k-1层节点数 + 右子树第k-1层节点数</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树某层中的节点数</span><br><span class="line"> *</span><br><span class="line"> *  @param level    层</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 层中的节点数</span><br><span class="line"> */</span><br><span class="line">// 二叉树某层中的节点数</span><br><span class="line">+ (NSInteger)numberOfNodesOnLevel:(NSInteger)level inTree:(BinaryTreeNode *)rootNode&#123;</span><br><span class="line">    // 根节点不存在 或 level &lt; 0</span><br><span class="line">    if (!rootNode || level &lt; 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // level = 1，返回1（根节点）</span><br><span class="line">        if (level == 1) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 递归：level层节点数 = 左子树level-1层节点数 + 右子树level-1层节点数</span><br><span class="line">        NSInteger levelNode = [self numberOfNodesOnLevel:level-1 inTree:rootNode.leftNode] + [self numberOfNodesOnLevel:level-1 inTree:rootNode.rightNode];</span><br><span class="line">        return levelNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>vc实现</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 某层节点数</span><br><span class="line">NSInteger levelNode = [BinaryTreeNode numberOfNodesOnLevel:1 inTree:self.rootNode];</span><br><span class="line">NSLog(@&quot;levelNode-%ld&quot;,levelNode);</span><br></pre></td></tr></table></figure></div><p>打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-26 16:27:02.360866+0800 二叉树[4593:175705] levelNode-1</span><br></pre></td></tr></table></figure></div><h1 id="二叉树叶子节点数"><a href="#二叉树叶子节点数" class="headerlink" title="二叉树叶子节点数"></a>二叉树叶子节点数</h1><p>叶子节点，又叫终端节点，是左右子树都是空的节点。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树叶子节点数</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 叶子节点数</span><br><span class="line"> */</span><br><span class="line">+ (NSInteger)numberOfLeafsInTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 左子树和右子树都是空，说明是叶子节点</span><br><span class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归：叶子数 = 左子树叶子数 + 右子树叶子数</span><br><span class="line">    return [self numberOfLeafsInTree:rootNode.leftNode] + [self numberOfLeafsInTree:rootNode.rightNode];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="二叉树最大距离（二叉树的直径）"><a href="#二叉树最大距离（二叉树的直径）" class="headerlink" title="二叉树最大距离（二叉树的直径）"></a>二叉树最大距离（二叉树的直径）</h1><p>二叉树中任意两个节点都有且仅有一条路径，这个路径的长度叫这两个节点的距离。二叉树中所有节点之间的距离的最大值就是二叉树的直径。</p><p>有一种解法，把这个最大距离划分了3种情况：</p><p>1）这2个节点分别在根节点的左子树和右子树上，他们之间的路径肯定经过根节点，而且他们肯定是根节点左右子树上最远的叶子节点（他们到根节点的距离&#x3D;左右子树的深度）。</p><p>2）这2个节点都在左子树上</p><p>3）这2个节点都在右子树上</p><p>综上，只要取这3种情况中的最大值，就是二叉树的直径。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树最大距离（直径）</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 最大距离</span><br><span class="line"> */</span><br><span class="line">+ (NSInteger)maxDistanceOfTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">//    方案一：（递归次数较多，效率较低）</span><br><span class="line">    //分3种情况：</span><br><span class="line">    //1、最远距离经过根节点：距离 = 左子树深度 + 右子树深度</span><br><span class="line">    NSInteger distance = [self depthOfTree:rootNode.leftNode] + [self depthOfTree:rootNode.rightNode];</span><br><span class="line">    //2、最远距离在根节点左子树上，即计算左子树最远距离</span><br><span class="line">    NSInteger disLeft = [self maxDistanceOfTree:rootNode.leftNode];</span><br><span class="line">    //3、最远距离在根节点右子树上，即计算右子树最远距离</span><br><span class="line">    NSInteger disRight = [self maxDistanceOfTree:rootNode.rightNode];</span><br><span class="line">    </span><br><span class="line">    return MAX(MAX(disLeft, disRight), distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个方案效率较低，因为计算子树的深度和最远距离是分开递归的，存在重复递归遍历的情况。其实一次递归，就可以分别计算出深度和最远距离，于是有了第二种方案：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树最大距离（直径）</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 最大距离</span><br><span class="line"> */</span><br><span class="line">+ (NSInteger)maxDistanceOfTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">// 方案2：将计算节点深度和最大距离放到一次递归中计算，方案一是分别单独递归计算深度和最远距离</span><br><span class="line">    TreeNodeProperty *p = [self propertyOfTreeNode:rootNode];</span><br><span class="line">    return p.distance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  计算树节点的最大深度和最大距离</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return TreeNodeProperty</span><br><span class="line"> */</span><br><span class="line">+ (TreeNodeProperty *)propertyOfTreeNode:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    </span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNodeProperty *left = [self propertyOfTreeNode:rootNode.leftNode];</span><br><span class="line">    TreeNodeProperty *right = [self propertyOfTreeNode:rootNode.rightNode];</span><br><span class="line">    TreeNodeProperty *p = [TreeNodeProperty new];</span><br><span class="line">    //节点的深度depth = 左子树深度、右子树深度中最大值+1（+1是因为根节点占了1个depth）</span><br><span class="line">    p.depth = MAX(left.depth, right.depth) + 1;</span><br><span class="line">    //最远距离 = 左子树最远距离、右子树最远距离和横跨左右子树最远距离中最大值</span><br><span class="line">    p.distance = MAX(MAX(left.distance, right.distance), left.depth+right.depth);</span><br><span class="line">    </span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="二叉树中某个节点到根节点的路径"><a href="#二叉树中某个节点到根节点的路径" class="headerlink" title="二叉树中某个节点到根节点的路径"></a>二叉树中某个节点到根节点的路径</h1><p>既是寻路问题，又是查找节点问题。</p><p>定义一个存放路径的栈（不是队列了，但是还是用可变数组来实现的）</p><p>1）压入根节点，再从左子树中查找（递归进行的），如果未找到，再从右子树中查找，如果也未找到，则弹出根节点，再遍历栈中上一个节点。</p><p>2）如果找到，则栈中存放的节点就是路径所经过的节点。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树中某个节点到根节点的路径</span><br><span class="line"> *</span><br><span class="line"> *  @param treeNode 节点</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 存放路径节点的数组</span><br><span class="line"> */</span><br><span class="line">+ (NSArray *)pathOfTreeNode:(BinaryTreeNode *)treeNode inTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    NSMutableArray *pathArray = [NSMutableArray array];</span><br><span class="line">    [self isFoundTreeNode:treeNode inTree:rootNode routePath:pathArray];</span><br><span class="line">    return pathArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  查找某个节点是否在树中</span><br><span class="line"> *</span><br><span class="line"> *  @param treeNode 待查找的节点</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *  @param path  根节点到待查找节点的路径</span><br><span class="line"> *</span><br><span class="line"> *  @return YES：找到，NO：未找到</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)isFoundTreeNode:(BinaryTreeNode *)treeNode inTree:(BinaryTreeNode *)rootNode routePath:(NSMutableArray *)path &#123;</span><br><span class="line">    </span><br><span class="line">    if (!rootNode || !treeNode) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //找到节点</span><br><span class="line">    if (rootNode == treeNode) &#123;</span><br><span class="line">        [path addObject:rootNode];</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    //压入根节点，进行递归</span><br><span class="line">    [path addObject:rootNode];</span><br><span class="line">    //先从左子树中查找</span><br><span class="line">    BOOL find = [self isFoundTreeNode:treeNode inTree:rootNode.leftNode routePath:path];</span><br><span class="line">    //未找到，再从右子树查找</span><br><span class="line">    if (!find) &#123;</span><br><span class="line">        find = [self isFoundTreeNode:treeNode inTree:rootNode.rightNode routePath:path];</span><br><span class="line">    &#125;</span><br><span class="line">    //如果2边都没查找到，则弹出此根节点</span><br><span class="line">    if (!find) &#123;</span><br><span class="line">        [path removeLastObject];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return find;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="二叉树中两个节点最近的公共父节点"><a href="#二叉树中两个节点最近的公共父节点" class="headerlink" title="二叉树中两个节点最近的公共父节点"></a>二叉树中两个节点最近的公共父节点</h1><p>首先需要明白，根节点肯定是二叉树中任意两个节点的公共父节点（不一定是最近的），因此二叉树中2个节点的最近公共父节点一定在从根节点到这个节点的路径上。因此我们可以先分别找到从根节点到这2个节点的路径，再从这两个路径中找到最近的公共父节点。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树中两个节点最近的公共父节点</span><br><span class="line"> *</span><br><span class="line"> *  @param nodeA    第一个节点</span><br><span class="line"> *  @param nodeB    第二个节点</span><br><span class="line"> *  @param rootNode 二叉树根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 最近的公共父节点</span><br><span class="line"> */</span><br><span class="line">+ (BinaryTreeNode *)parentOfNode:(BinaryTreeNode *)nodeA andNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode || !nodeA || !nodeB) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nodeA == nodeB) &#123;</span><br><span class="line">        return nodeA;</span><br><span class="line">    &#125;</span><br><span class="line">    //从根节点到节点A的路径</span><br><span class="line">    NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode];</span><br><span class="line">    //从根节点到节点B的路径</span><br><span class="line">    NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode];</span><br><span class="line">    //其中一个节点不在树中，则没有公共父节点</span><br><span class="line">    if (pathA.count == 0 || pathB == 0) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //从后往前推，查找第一个出现的公共节点</span><br><span class="line">    for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123;</span><br><span class="line">        for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123;</span><br><span class="line">            if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123;</span><br><span class="line">                //找到</span><br><span class="line">                return [pathA objectAtIndex:i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="二叉树中两个节点之间的路径"><a href="#二叉树中两个节点之间的路径" class="headerlink" title="二叉树中两个节点之间的路径"></a>二叉树中两个节点之间的路径</h1><p>从查找最近公共父节点衍生出来的。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树中两个节点之间的路径</span><br><span class="line"> *</span><br><span class="line"> *  @param nodeA    第一个节点</span><br><span class="line"> *  @param nodeB    第二个节点</span><br><span class="line"> *  @param rootNode 二叉树根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 两个节点间的路径</span><br><span class="line"> */</span><br><span class="line">+ (NSArray *)pathFromNode:(BinaryTreeNode *)nodeA toNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode || !nodeA || !nodeB) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    NSMutableArray *path = [NSMutableArray array];</span><br><span class="line">    if (nodeA == nodeB) &#123;</span><br><span class="line">        [path addObject:nodeA];</span><br><span class="line">        [path addObject:nodeB];</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line">    //从根节点到节点A的路径</span><br><span class="line">    NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode];</span><br><span class="line">    //从根节点到节点B的路径</span><br><span class="line">    NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode];</span><br><span class="line">    //其中一个节点不在树中，则没有路径</span><br><span class="line">    if (pathA.count == 0 || pathB == 0) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //从后往前推，查找第一个出现的公共节点</span><br><span class="line">    for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123;</span><br><span class="line">        [path addObject:[pathA objectAtIndex:i]];</span><br><span class="line">        for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123;</span><br><span class="line">            //找到公共父节点，则将pathB中后面的节点压入path</span><br><span class="line">            if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123;</span><br><span class="line">                j++; //j++是为了避开公共父节点</span><br><span class="line">                while (j&lt;pathB.count) &#123;</span><br><span class="line">                    [path addObject:[pathB objectAtIndex:j]];</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                return path;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="二叉树两个节点之间的距离"><a href="#二叉树两个节点之间的距离" class="headerlink" title="二叉树两个节点之间的距离"></a>二叉树两个节点之间的距离</h1><p>可以从两个节点之间的路径衍生出来。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树两个节点之间的距离</span><br><span class="line"> *</span><br><span class="line"> *  @param nodeA    第一个节点</span><br><span class="line"> *  @param nodeB    第二个节点</span><br><span class="line"> *  @param rootNode 二叉树根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 两个节点间的距离（-1：表示没有找到路径）</span><br><span class="line"> */</span><br><span class="line">+ (NSInteger)distanceFromNode:(BinaryTreeNode *)nodeA toNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode || !nodeA || !nodeB) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nodeA == nodeB) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //从根节点到节点A的路径</span><br><span class="line">    NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode];</span><br><span class="line">    //从根节点到节点B的路径</span><br><span class="line">    NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode];</span><br><span class="line">    //其中一个节点不在树中，则没有路径</span><br><span class="line">    if (pathA.count == 0 || pathB == 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //从后往前推，查找第一个出现的公共节点</span><br><span class="line">    for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123;</span><br><span class="line">        for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123;</span><br><span class="line">            //找到公共父节点</span><br><span class="line">            if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123;</span><br><span class="line">                //距离=路径节点数-1 （这里要-2，因为公共父节点重复了一次）</span><br><span class="line">                return (pathA.count - i) + (pathB.count - j) - 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="判断二叉树是否完全二叉树"><a href="#判断二叉树是否完全二叉树" class="headerlink" title="判断二叉树是否完全二叉树"></a>判断二叉树是否完全二叉树</h1><p>完全二叉树定义为：若设二叉树的高度为h，除第h层外，其它各层的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布。</p><p>完全二叉树必须满足2个条件：</p><p>1）如果某个节点的右子树不为空，则它的左子树必须不为空</p><p>2）如果某个节点的右子树为空，则排在它后面的节点必须没有孩子节点</p><p>这里还需要理解“排在它后面的节点”，回头看看层次遍历算法，我们就能知道在层次遍历时，是从上到下从左到右遍历的，先将根节点弹出队列，再压入孩子节点，因此“排在它后面的节点”有2种情况：</p><p>1）同层次的后面的节点</p><p>2）同层次的前面的节点的孩子节点（因为遍历前面的节点时，会弹出节点，同时将孩子节点压入队列）</p><p>通过上面的分析，我们可以设置一个标志位flag，当子树满足完全二叉树时，设置flag&#x3D;YES。当flag&#x3D;YES而节点又破坏了完全二叉树的条件，那么它就不是完全二叉树。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  是否完全二叉树</span><br><span class="line"> *  完全二叉树：若设二叉树的高度为h，除第h层外，其它各层的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return YES：是完全二叉树，NO：不是完全二叉树</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)isCompleteBinaryTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    //左子树和右子树都是空，则是完全二叉树</span><br><span class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    //左子树是空，右子树不是空，则不是完全二叉树</span><br><span class="line">    if (!rootNode.leftNode &amp;&amp; rootNode.rightNode) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //按层次遍历节点，找到满足完全二叉树的条件：</span><br><span class="line">    //条件1：如果某个节点的右子树不为空，则它的左子树必须不为空</span><br><span class="line">    //条件2：如果某个节点的右子树为空，则排在它后面的节点必须没有孩子节点</span><br><span class="line">    //排在该节点后面的节点有2种：1）同层次的后面的节点 2）同层次的前面的节点的孩子节点（因为遍历前面的节点的时候，会将节点从队列里pop，同时把它的孩子节点push到队列里）</span><br><span class="line">    NSMutableArray *queue = [NSMutableArray array];</span><br><span class="line">    [queue addObject:rootNode];</span><br><span class="line">    BOOL isComplete = NO; //是否已经满足完全二叉树</span><br><span class="line">    while (queue.count &gt; 0) &#123;</span><br><span class="line">        BinaryTreeNode *node = [queue firstObject];</span><br><span class="line">        [queue removeObjectAtIndex:0];</span><br><span class="line">        </span><br><span class="line">        //左子树为空且右子树不为空，则不是完全二叉树</span><br><span class="line">        if (!node.leftNode &amp;&amp; node.rightNode) &#123;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">        if (isComplete &amp;&amp; (node.leftNode || node.rightNode)) &#123;</span><br><span class="line">            //前面的节点已满足完全二叉树,如果还有孩子节点，则不是完全二叉树</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //右子树为空，则已经满足完全二叉树</span><br><span class="line">        if (!node.rightNode) &#123;</span><br><span class="line">            isComplete = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //压入</span><br><span class="line">        if (node.leftNode) &#123;</span><br><span class="line">            [queue addObject:node.leftNode];</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.rightNode) &#123;</span><br><span class="line">            [queue addObject:node.rightNode];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isComplete;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="判断二叉树是否满二叉树"><a href="#判断二叉树是否满二叉树" class="headerlink" title="判断二叉树是否满二叉树"></a>判断二叉树是否满二叉树</h1><p> 满二叉树定义为：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树</p><p> 满二叉树的一个特性是：叶子数&#x3D;2^(深度-1)，因此我们可以根据这个特性来判断二叉树是否是满二叉树。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  是否满二叉树</span><br><span class="line"> *  满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return YES：满二叉树，NO：非满二叉树</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)isFullBinaryTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //二叉树深度</span><br><span class="line">    NSInteger depth = [self depthOfTree:rootNode];</span><br><span class="line">    //二叉树叶子节点数</span><br><span class="line">    NSInteger leafNum = [self numberOfLeafsInTree:rootNode];</span><br><span class="line">    </span><br><span class="line">    //满二叉树特性：叶子数=2^(深度-1)</span><br><span class="line">    if (leafNum == pow(2, (depth - 1))) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="判断二叉树是否平衡二叉树"><a href="#判断二叉树是否平衡二叉树" class="headerlink" title="判断二叉树是否平衡二叉树"></a>判断二叉树是否平衡二叉树</h1><p>平衡二叉树定义为：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树又叫AVL树。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  是否平衡二叉树</span><br><span class="line"> *  平衡二叉树：即AVL树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return YES：平衡二叉树，NO：非平衡二叉树</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)isAVLBinaryTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    static NSInteger height;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        height = 0;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</span><br><span class="line">        height = 1;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    BOOL isAVLLeft = [self isAVLBinaryTree:rootNode.leftNode];</span><br><span class="line">    NSInteger heightLeft = height;</span><br><span class="line">    BOOL isAVLRight = [self isAVLBinaryTree:rootNode.rightNode];</span><br><span class="line">    NSInteger heightRight = height;</span><br><span class="line">    </span><br><span class="line">    height = MAX(heightLeft, heightRight)+1;</span><br><span class="line">    </span><br><span class="line">    if (isAVLLeft &amp;&amp; isAVLRight &amp;&amp; ABS(heightLeft-heightRight) &lt;= 1) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 以上就是我目前整理的一些二叉树相关的算法，算法资料和思想都来源于网络，如有错误，欢迎指正！后续如果有新的算法，我也会更新进去。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-数据结构探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC算法04：二分查找探索</title>
      <link href="/BboyZJ.github.io/2020/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9504%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9504%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><ol><li>简介</li></ol><p>二分查找(也称折半查找)是很常见的一种在数组中查找数据的算法,作为一名程序员是应该必须会的。</p><ol start="2"><li>基本思想</li></ol><p>获取数组的中间值，将数组分割成两份，利用查找的值跟中间值进行比较，如果查找的值大于中间值，就在数组的右边进行查找；如果查找的值小于中间值，就在数组的左边进行查找。如此循环的执行下去，最终找到符合的值。</p><ol start="3"><li>优缺点</li></ol><p>1）优点：</p><ul><li>速度快 </li><li>比较次数少 </li><li>性能好</li></ul><p>2）缺点：</p><ul><li>必须是一个有序的数组（升序或者降序）</li><li>适用范围：适用不经常变动的数组</li></ul><ol start="4"><li>复杂度</li></ol><p>时间复杂度就变成了O(logN)</p><ol start="5"><li>具体代码</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSArray * arr = @[@1,@3,@5,@6,@8,@15,@20];</span><br><span class="line">    NSInteger result = [self binarySearchTarget:@1 inArray:arr];</span><br><span class="line">    NSLog(@&quot;%ld&quot;,(long)result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在某个数组中搜索目标</span><br><span class="line">- (NSInteger)binarySearchTarget:(NSNumber *)target inArray:(NSArray *)arr&#123;</span><br><span class="line">    //如果数组无元素，则返回</span><br><span class="line">    if (arr.count &lt; 1) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果数组有元素</span><br><span class="line">    //定义三个变量 第一个值下标、最后一个值下标、中间值下标</span><br><span class="line">    NSInteger start = 0;</span><br><span class="line">    NSInteger end = arr.count - 1;</span><br><span class="line">    NSInteger mid = 0;</span><br><span class="line">    //如果开始和结束中间还有元素，则循环</span><br><span class="line">    while (start &lt; end - 1) &#123;</span><br><span class="line">        //会有一些朋友看到有些人是( start + end ) / 2这样写的,但是这样写有一点不好,就是start+end会出现整数溢出的情况,如果存在溢出,你再除以2也是没有用的,所以不能这么写</span><br><span class="line">        mid = start + (end - start) / 2;</span><br><span class="line">        //如果中间值大于目标值</span><br><span class="line">        if ([arr[mid] intValue] &gt; [target intValue]) &#123;</span><br><span class="line">            //中间值做为最后一个值，在前半段再进行相同的搜索</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果中间值小于或等于目标值</span><br><span class="line">        else &#123;</span><br><span class="line">            start = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //考虑到边界问题，所以下面这俩个必须写</span><br><span class="line">    //如果第一个值和目标值相等则获取第一个值的下标</span><br><span class="line">    if ([arr[start] intValue] == [target intValue]) &#123;</span><br><span class="line">        return start;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果最后一个值和目标值相等则获取最后一个值的下标</span><br><span class="line">    if ([arr[end] intValue] == [target intValue]) &#123;</span><br><span class="line">        return end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>查看打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-08-26 18:06:44.754180+0800 iOS-OC之二分查找[49535:2738585] 0</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-算法探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC算法05：选择排序探索</title>
      <link href="/BboyZJ.github.io/2020/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9505%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9505%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><ol><li><p>基本思路：<code>选择排序</code>（Selection sort）是最基本的 O(n^2) 的排序算法，它的原理是每一次从待排序的数据元素中 <code>选出最小或最大</code> 的一个元素，存放在序列的起始位置，然后，再从 <code>剩余未排序的元素当中继续寻找最小或大的元素</code>， 然后放到未排序的末尾，以此类推，直到全部待排序的数据元素排完。</p></li><li><p>稳定性</p></li></ol><p>选择排序是不稳定的排序方法。</p><ol start="3"><li>主要流程：从小到大</li></ol><ul><li><p>第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换；</p></li><li><p>第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换；</p></li><li><p>以此类推，第i趟在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，使有序序列不断增长直到全部排序完毕。</p></li></ul><ol start="4"><li>具体代码</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [self selectionSortWithArr:[NSMutableArray arrayWithArray:@[@3,@1,@2,@5,@4]]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 选择排序</span><br><span class="line">- (void)selectionSortWithArr:(NSMutableArray *)arr&#123;</span><br><span class="line">    // 开始时间</span><br><span class="line">    double startTime = CFAbsoluteTimeGetCurrent();</span><br><span class="line">    // 外层遍历</span><br><span class="line">    for (int i = 0; i&lt; arr.count; i++) &#123;</span><br><span class="line">        int minIndex = i;</span><br><span class="line">        // 内层遍历</span><br><span class="line">        for (int j = i + 1; j &lt; arr.count; j++) &#123;</span><br><span class="line">            // 获取最小下标</span><br><span class="line">            if ([arr[j] intValue]&lt; [arr[minIndex] intValue]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //交换位置</span><br><span class="line">        [arr exchangeObjectAtIndex:i withObjectAtIndex:minIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    double endTime = CFAbsoluteTimeGetCurrent();</span><br><span class="line">    NSLog(@&quot;%@&quot;,arr);</span><br><span class="line">    NSLog(@&quot;选择排序用时:%f s&quot;,endTime - startTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>查看打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2020-08-26 17:11:21.653476+0800 OC-选择排序[48845:2694230] (</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5</span><br><span class="line">)</span><br><span class="line">2020-08-26 17:11:21.653672+0800 OC-选择排序[48845:2694230] 选择排序用时:0.000003 s</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-算法探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习00：简介</title>
      <link href="/BboyZJ.github.io/2020/08/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A000%EF%BC%9A%E7%AE%80%E4%BB%8B/"/>
      <url>/BboyZJ.github.io/2020/08/22/Swift%E5%AD%A6%E4%B9%A0/Swift%E5%AD%A6%E4%B9%A000%EF%BC%9A%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Swift介绍"><a href="#Swift介绍" class="headerlink" title="Swift介绍"></a>Swift介绍</h1><p>Swift是Apple在2014年6月WWDC发布的全新的编程语言。</p><p>Swift是一种高性能系统编程语言，提供了对现有C和OC代码框架的无缝访问，并且是内存安全的。</p><p>Swift语言更加简洁，是一门类型安全的语言。</p><h1 id="Swift和OC的区别"><a href="#Swift和OC的区别" class="headerlink" title="Swift和OC的区别"></a>Swift和OC的区别</h1><ol><li>编程范式</li></ol><ul><li>Swift可以 <code>面试协议编程、函数式编程和面向对象编程</code></li><li>OC以 <code>面向对象编程</code> 为主，当然你可以引入 <code>Reactive Cocoa</code> 的类库来进行函数式编程</li></ul><ol start="2"><li>类型安全</li></ol><ul><li>Swift是一门 <code>类型安全的语言</code>。鼓励程序员在代码中清楚明确值的类型。如果代码中使用一个字符串String，那么你不能错误地传递一个整型Int给它。因为Swift是类型安全的，它会在代码编译的时候做类型检查，并且把所有不匹配的类型作为一个错误标记出来。这样使得程序员在开发中尽可能早地发现和修正错误。</li><li>而OC则 <code>不是类型安全的语言</code>，你声明一个NSString变量，仍然可以传递一个NSNumber给它，尽管编译器会抱怨，但是你仍然可以作为NSNumber来使用它。</li></ul><ol start="3"><li>值类型的增强</li></ol><ul><li>在Swift中，典型的有 <code>struct、enum</code> 以及 <code>元祖tuple</code> 都是值类型。而平时使用的Int、Double、Float 、String 、Array 、Dictionary、Set其实都是用结构体实现的，也是 <code>值类型</code>。</li><li>OC中，NSNumber、NSString以及集合类对象都是指针类型。</li></ul><ol start="4"><li>枚举增强</li></ol><ul><li>Swift的枚举可以使用 <code>整型、浮点型、字符串等</code>，还能拥有 <code>属性和方法</code>，甚至支持 <code>泛型、协议、扩展等</code>。</li><li>OC里面的枚举则鸡肋很多。</li></ul><ol start="5"><li>泛型</li></ol><ul><li>Swift中 <code>支持泛型</code>，也支持泛型的类型约束等特性</li><li>苹果推出了Swift2.0版本，为了让开发者从OC更好的国度到Swift上，苹果也为OC带来了Gennerics泛型支持，不过OC的泛型约束也仅停留在编译器警告阶段。</li></ul><ol start="6"><li>协议和扩展</li></ol><ul><li>Swift对协议的支持更加丰富，配合扩展（extension）、泛型、关联类型等可以实现面向协议编程，从而大大提高代码的灵活性。同时swift中的protocol还可以用于值类型，如结构体和枚举</li><li>OC的协议却反强约束，提供optional特性往往成为很多问题得来源，而如果放弃optional又会让实现代价过大。</li></ul><ol start="7"><li>函数和闭包</li></ol><ul><li>Swift函数是一等公民，可以直接定义函数类型变量，可以作为其他函数参数传递，可以作为函数的返回值类型。</li><li>OC里面函数仍然是次等公民，需要selector封装或者使用block才能模拟Swift中类似的效果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC算法01：冒泡排序探索</title>
      <link href="/BboyZJ.github.io/2020/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9501%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9501%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><ol><li>基本思路：</li></ol><p>重复地走访要排序的元素列，<code>依次比较两个相邻的元素</code>，如果他们的 <code>顺序错误就把他们交换过来</code>。</p><ol start="2"><li>算法思想：</li></ol><p>1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>2）对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>3）针对所有的元素重复以上的步骤，除了最后一个。<br>4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><ol start="3"><li>主要流程：</li></ol><p>首先我们需要 <code>双层循环</code>，<code>外层循环控制排序趟数</code>，<code>内存循环控制每趟比较次数以及是否需要交换位置</code>，我们先不关心是否交换位置，我们内层循环每次比较都是取 <code>array[j]</code> 和 <code>array[j+1]</code> 相比较，根据比较结果来判断是否交换位置。</p><ol start="4"><li>时间复杂度</li></ol><ul><li><p>最好的情况：冒泡排序中最好的情况是数组本身就是正序排列的，并不需要交换，例如：@[1,2,3,4,5]; 当正序数组放入冒泡排序中的时候，只会进行4次比较，分别是1和2，2和3，3和4，4和5。比较完后发现没有任何数需要交换，那么说明数组已经排序正确，不要在进行最外层循环。当正序数组中有 <code>N</code> 个数的时候，那么只需要 <code>N-1</code> 次比较。 而正序数组在冒泡排序中的时间复杂度为O(n)，因为n-1中，在n的基数很大的情况，比如n为1000时，1其实可以忽略不计。所以 冒泡排序中最短的时间**复杂度为O(n)**。</p></li><li><p>冒泡排序中最坏的情况是数组本身就是逆序排列的，需要每两个数都进行交换，例如：@[5,4,3,2,1]；当逆序数组放入冒泡排序中，最外层的每一次循环都要进行n-1次比较，而逆序数组需要进行n次最外层循环才能正确排序，最终比较次数为(n-1)n&#x2F;2，所以冒泡排序中最长的时间**复杂度为(n²)**，因为当n基数很大时，(n-1)n&#x2F;2 &#x3D; (n² - n)&#x2F;2； n²与n、1&#x2F;2的差距越大，n与1&#x2F;2可以忽略不计。</p></li></ul><h1 id="冒泡排序-1"><a href="#冒泡排序-1" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>例子：元数据：@[@”1”,@”3”,@”2”,@”5”,@”4”]</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;5&quot;,@&quot;4&quot;]];</span><br><span class="line">    // 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">    for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序</span><br><span class="line">        for (int j = 0; j &lt; arr.count - i - 1; j++) &#123;</span><br><span class="line">            // 相邻元素比较，若逆序则交换</span><br><span class="line">            if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123;</span><br><span class="line">                [arr exchangeObjectAtIndex:j withObjectAtIndex:j + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2020-08-10 20:29:10.492517+0800 OC冒泡排序[27771:1528609] (</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h1 id="有序数组冒泡排序的优化"><a href="#有序数组冒泡排序的优化" class="headerlink" title="有序数组冒泡排序的优化"></a>有序数组冒泡排序的优化</h1><p>如果数据是有序的：</p><ul><li>第一种优化方式是设置一个标记位来标记是否发生了交换，如果没有发生交换就提前结束；</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;5&quot;,@&quot;4&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;1&quot;]];</span><br><span class="line">    int flag = 0;</span><br><span class="line">    // 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">    for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序</span><br><span class="line">        for (int j = 0; j &lt; arr.count - i - 1; j++) &#123;</span><br><span class="line">            //相邻元素比较，若逆序则交换</span><br><span class="line">            if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                id temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+1];</span><br><span class="line">                arr[j+1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag == 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,arr);</span><br></pre></td></tr></table></figure></div><p>打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2020-08-10 20:45:33.770139+0800 OC冒泡排序[28047:1546936] (</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h1 id="两个数组合并成一个数据，并排序"><a href="#两个数组合并成一个数据，并排序" class="headerlink" title="两个数组合并成一个数据，并排序"></a>两个数组合并成一个数据，并排序</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSArray * ary1 = @[@1,@3,@4,@5,@9];</span><br><span class="line">NSArray * ary2 = @[@2,@4,@6,@8];</span><br><span class="line">NSMutableArray * res = [NSMutableArray arrayWithCapacity:[ary1 count] + [ary2 count]];</span><br><span class="line">    </span><br><span class="line">    int i = 0, j = 0; // i 表示ary1的下标  j表示ary2的下标</span><br><span class="line">    </span><br><span class="line">    while (i &lt; ary1.count  &amp;&amp;  j &lt; ary2.count) &#123;</span><br><span class="line">        int a1 = [ary1[i] intValue];</span><br><span class="line">        int a2 = [ary2[j] intValue];</span><br><span class="line">        if (a1 &lt;= a2) &#123;</span><br><span class="line">            [res addObject:ary1[i++]];</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            [res addObject:ary2[j++]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;,res);</span><br></pre></td></tr></table></figure></div><p>打印</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2020-08-10 21:11:11.311203+0800 OC冒泡排序[28372:1568516] (</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    4,</span><br><span class="line">    5,</span><br><span class="line">    6,</span><br><span class="line">    8</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-算法探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC数据结构01：链表的探索</title>
      <link href="/BboyZJ.github.io/2020/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><ul><li>举个例子，数组：1-2-3-4-5-6-7-8-9-10，这个就是一个顺序存储结构，存储是按顺序的。</li><li>比如 <code>栈，先进后出</code>，比如 <code>hello world</code> 在栈里面是从 <code>栈底到栈顶的逻辑</code>，依次是 <code>h-e-l-l-o-w-o-r-l-d</code> 这个顺序存储</li><li>再比如 <code>队列，先进先出</code>，从头到尾 <code>h-e-l-l-o-w-o-r-l-d</code> 这个顺序排序</li></ul><h2 id="链式存储结构-链表"><a href="#链式存储结构-链表" class="headerlink" title="链式存储结构-链表"></a>链式存储结构-链表</h2><p>链表是一种 <code>物里存储单元上非连续、非顺序的存储结构</code>，数据元素的顺序是通过链表中的 <code>指针</code> 链接次序实现的。链表由 <code>一系列节点组成</code>，在 <code>运行时动态生成</code>。每个节点包括两部分：一个是 <code>数据域</code>，一个是 <code>指针域</code>。</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表的组成"><a href="#链表的组成" class="headerlink" title="链表的组成"></a>链表的组成</h2><ol><li>链表的数据元素的组成部分：<code>指针域</code> 和 <code>数据域</code></li><li><code>指针域</code> 用来存放指示数据元素之间的逻辑关系的指针。</li><li><code>数据域</code> 用来存放数据信息。</li><li>数据元素这种特殊的存储方式称之为 <code>结点（Node）</code>。</li></ol><h2 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h2><p><strong>链表分为4类：</strong></p><ul><li><p>单链表：一个数据域data、一个后继指针域next。也即：上一个节点指向下一个节点，尾节点next指向nil，首节点pre指向nil。</p></li><li><p>双向链表：一个数据域data、一个前驱指针域previous、一个后继指针域next。也即：上一个节点和下一个节点互相指向，尾节点next指向nil，首节点pre指向nil。</p></li><li><p>循环链表：一个数据域data、一个后继指针域next。也即：上一个节点指向下一个节点，尾节点next指向首节点。</p></li><li><p>双向循环链表：一个数据域data、一个前驱指针域previous、一个后继指针域next。也即：上一个节点和下一个节点互相指向，尾节点和首节点也互相指向。</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061814176.png"                                     ></p><h2 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h2><ol><li>数组：</li></ol><p>我们知道，用数组存放数据时，必须事先定义固定的长度（即元素个数）。如果事先难以确定元素个数，则必须把数组定义的足够大，以便存放，显然这样会浪费内存。</p><ol start="2"><li>而链表可根据需要开辟内存单元，不会浪费内存。</li></ol><h1 id="数组-和-链表-的区别？"><a href="#数组-和-链表-的区别？" class="headerlink" title="数组 和 链表 的区别？"></a>数组 和 链表 的区别？</h1><ul><li><p>数组：数组 <code>静态分配</code> 内存；数组元素在内存上是连续的，可以通过下标查找元素；插入、删除需要移动大量元素，比较使用元素很少变化的情况；数组插入删除操作时间复杂度是 O(n)，数组查询操作时间复杂度是 O(1)</p></li><li><p>链表：链表 <code>动态分配</code> 内存；链表元素在内存中不是顺序存储的，查找慢；插入、删除只需要对元素指针重新赋值，效率高；链表插入删除操作时间复杂度是 O(1)，链表查询操作时间复杂度是 O(n)</p></li></ul><h1 id="如何检测单链表中是否有环？"><a href="#如何检测单链表中是否有环？" class="headerlink" title="如何检测单链表中是否有环？"></a>如何检测单链表中是否有环？</h1><ul><li>穷举遍历</li></ul><p>首先从头节点开始，依次遍历每个节点，每遍历到一个新节点，就从头节点重新遍历新节点之前的所有节点，当 <code>新节点的ID</code> 和 <code>此节点之前的所有节点ID</code> 依次比较，如果发现 <code>ID相同</code>，则证明链表有环。</p><ul><li>哈希表缓存</li></ul><p>首先创建一个以 <code>节点ID为键</code> 的HashSet集合，用来存储曾经遍历过的节点。然后同样是从头节点开始，依次遍历每一个节点，当新节点和HashSet集合当中存储的节点ID相同，则说明链表右环。</p><ul><li>快慢指针</li></ul><p>首先创建两个指针，指针1和指针2，同时指向这个头节点，指针1每次向下移动一个节点，指针2向下移动2个节点，比较节点是否相同，如果相同则说明链表有环。如果不同执行下一次循环。</p><h1 id="单向链表代码实现"><a href="#单向链表代码实现" class="headerlink" title="单向链表代码实现"></a>单向链表代码实现</h1><ol><li>定义节点</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 单链表节点</span><br><span class="line">@interface SingleLinkNode : NSObject</span><br><span class="line">@property (nonatomic,strong)id data; // 数据域</span><br><span class="line">@property (nonatomic,strong,nullable)SingleLinkNode * next; // 后继指针域</span><br><span class="line">+ (instancetype)constructNodeWithData:(id)data;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface SingleLinkNode ()</span><br><span class="line">@end</span><br><span class="line">@implementation SingleLinkNode</span><br><span class="line">+ (instancetype)constructNodeWithData:(id)data&#123;</span><br><span class="line">    SingleLinkNode * node = [[SingleLinkNode alloc] init];</span><br><span class="line">    node.data = data;</span><br><span class="line">    node.next = nil;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="2"><li>构建链表</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 构建一个单链表</span><br><span class="line">SingleLinkNode * headNode = [[SingleLinkNode alloc] init];</span><br></pre></td></tr></table></figure></div><ol start="3"><li>对外接口类</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@interface LinkInterface : NSObject</span><br><span class="line">// 单链表：在头部插入节点</span><br><span class="line">+ (void)insertNewNodeToHead:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode;</span><br><span class="line">// 单链表：在尾部插入节点</span><br><span class="line">+ (void)insertNewNodeToTail:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode;</span><br><span class="line">// 单链表：在指定位置插入节点</span><br><span class="line">+ (void)insertNodeAtIndex:(int)index node:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode;</span><br><span class="line">// 单链表：删除指定位置节点</span><br><span class="line">+ (void)deleteNodeAtIndex:(int)index headNode:(SingleLinkNode *)headNode;</span><br><span class="line">// 单链表：查询指定位置节点</span><br><span class="line">+ (SingleLinkNode *)queryNodeAtIndex:(int)index headNode:(SingleLinkNode *)headNode;</span><br><span class="line">// 单链表：正序遍历链表</span><br><span class="line">+ (NSArray *)printFromHeadWithNode:(SingleLinkNode *)headNode printPrefixText:(NSString *)text;</span><br><span class="line">// 单链表：倒叙遍历链表</span><br><span class="line">+ (NSMutableArray *)printFromTailWithNode:(SingleLinkNode *)headNode;</span><br><span class="line">// 单链表：反转链表</span><br><span class="line">+ (SingleLinkNode *)reverseWithNode:(SingleLinkNode *)headNode;</span><br><span class="line">// 单链表：两个有序链表合并成一个新的有序链表</span><br><span class="line">+ (SingleLinkNode *)combineWithNode:(SingleLinkNode *)headNode otherNode:(SingleLinkNode *)otherNode;</span><br><span class="line">// 单链表：判断两个链表是否相交</span><br><span class="line">+ (BOOL)intersectWithNode:(SingleLinkNode *)headNode otherNode:(SingleLinkNode *)otherNode;</span><br><span class="line">// 单链表：判断链表是否构成环，如果成环，求出环的入口节点</span><br><span class="line">+ (SingleLinkNode *)circleWithNode:(SingleLinkNode *)headNode;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ol start="4"><li>插入节点</li></ol><ul><li>在头部插入节点</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 在头部插入节点</span><br><span class="line">+ (void)insertNewNodeToHead:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if (!headNode)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 先把新节点指向头节点的下一个节点，再让头结点指向新节点（比较常用）</span><br><span class="line">    if (headNode.next == nil) &#123;</span><br><span class="line">        headNode.next = newNode;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        // 将下一个节点赋值给新节点</span><br><span class="line">        newNode.next = headNode.next;</span><br><span class="line">        // 再将头节点指向新节点</span><br><span class="line">        headNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>vc实现：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 插入节点到头部</span><br><span class="line">SingleLinkNode * newHeadNode = [SingleLinkNode constructNodeWithData:@1];</span><br><span class="line">[LinkInterface insertNewNodeToHead:newHeadNode headNode:headNode];</span><br><span class="line">// 正序打印节点</span><br><span class="line">[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;构造单链表为：&quot;];</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-23 16:44:46.140163+0800 单链表[39792:20769651] 单链表为:1</span><br></pre></td></tr></table></figure></div><ul><li>在尾部插入节点</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 在尾部插入节点</span><br><span class="line">+ (void)insertNewNodeToTail:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果头节点就是尾节点</span><br><span class="line">    if(headNode.next == nil) &#123;</span><br><span class="line">        headNode.next = newNode;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        // 设置中间变量</span><br><span class="line">        SingleLinkNode * pNode = headNode;</span><br><span class="line">        while (pNode.next != nil) &#123; // 未遍历到尾节点</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>vc实现：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 插入节点到尾部</span><br><span class="line">SingleLinkNode * newTailNode = [SingleLinkNode constructNodeWithData:@2];</span><br><span class="line">SingleLinkNode * newTailNode1 = [SingleLinkNode constructNodeWithData:@3];</span><br><span class="line">SingleLinkNode * newTailNode2 = [SingleLinkNode constructNodeWithData:@5];</span><br><span class="line">[LinkInterface insertNewNodeToTail:newTailNode headNode:headNode];</span><br><span class="line">[LinkInterface insertNewNodeToTail:newTailNode1 headNode:headNode];</span><br><span class="line">[LinkInterface insertNewNodeToTail:newTailNode2 headNode:headNode];</span><br><span class="line">// 正序打印节点</span><br><span class="line">[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;];</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-23 16:46:42.287876+0800 单链表[39960:20772937] 单链表为:1-&gt;2-&gt;3-&gt;5</span><br></pre></td></tr></table></figure></div><ul><li>在指定位置插入</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 单链表：在指定位置插入节点</span><br><span class="line">+ (void)insertNodeAtIndex:(int)index node:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果头节点即尾节点</span><br><span class="line">    if (headNode.next == nil)&#123;</span><br><span class="line">        headNode.next = newNode;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        SingleLinkNode * pNode = headNode;</span><br><span class="line">        int i = 1;</span><br><span class="line">        while (i &lt; index &amp;&amp; pNode.next != nil) &#123;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode.next = pNode.next;</span><br><span class="line">        pNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>vc实现：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 插入指定位置节点</span><br><span class="line">SingleLinkNode * newIndexNode = [SingleLinkNode constructNodeWithData:@4];</span><br><span class="line">[LinkInterface insertNodeAtIndex:4 node:newIndexNode headNode:headNode];</span><br><span class="line">// 正序打印节点</span><br><span class="line">[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;];</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-23 16:47:38.507939+0800 单链表[40048:20774861] 构造单链表为：:1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure></div><ol start="5"><li>删除节点</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 单链表：删除指定位置节点</span><br><span class="line">+ (void)deleteNodeAtIndex:(int)index headNode:(SingleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(headNode == nil || !headNode.next || index &lt;= 0)&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;没有要删除的第%d个节点&quot;,index]);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SingleLinkNode * pNode = headNode;</span><br><span class="line">    SingleLinkNode * p = pNode; // 移动指针</span><br><span class="line">    int i = 0;</span><br><span class="line">    while (i &lt; index &amp;&amp; pNode.next != nil) &#123;</span><br><span class="line">        p = pNode;</span><br><span class="line">        pNode = pNode.next;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(pNode != nil)&#123;</span><br><span class="line">        p.next = p.next.next;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;没有要删除的第%d个节点&quot;,index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>vc实现：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 删除指定位置的节点</span><br><span class="line">[LinkInterface deleteNodeAtIndex:1 headNode:headNode];</span><br><span class="line">// 正序打印节点</span><br><span class="line">[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;];</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-23 16:50:48.638460+0800 单链表[40345:20779532] 单链表为:2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure></div><ol start="6"><li>查询节点</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 单链表：查询指定位置节点</span><br><span class="line">+ (SingleLinkNode *)queryNodeAtIndex:(int)index headNode:(SingleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if (!headNode || !headNode.next) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;没有查询到的第%d个节点&quot;,index]);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    SingleLinkNode * pNode = headNode.next;</span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i &lt; index &amp;&amp; pNode != nil) &#123;</span><br><span class="line">        pNode = pNode.next;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(pNode != nil)&#123;</span><br><span class="line">        return pNode;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;没有查询到的第%d个节点&quot;,index]);</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>vc实现：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 查询指定位置的节点</span><br><span class="line">[LinkInterface queryNodeAtIndex:3 headNode:headNode];</span><br><span class="line">// 正序打印节点</span><br><span class="line">[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;];</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-23 16:55:10.563221+0800 单链表[40694:20785389] 单链表为:2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure></div><ol start="7"><li>遍历链表</li></ol><ul><li>正向遍历</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 正序遍历链表</span><br><span class="line">+ (NSArray *)printFromHeadWithNode:(SingleLinkNode *)headNode printPrefixText:(NSString *)text&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if (!headNode || !headNode.next) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 设置偏移指针</span><br><span class="line">    SingleLinkNode * pNode = headNode.next;</span><br><span class="line">    NSMutableArray * dataArr = [NSMutableArray array];</span><br><span class="line">    while (pNode != nil) &#123;</span><br><span class="line">        [dataArr addObject:pNode.data];</span><br><span class="line">        pNode = pNode.next; // 指向下一个节点</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@:%@&quot;,text,[dataArr componentsJoinedByString:@&quot;-&gt;&quot;]);</span><br><span class="line">    return dataArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>vc实现：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 正序打印节点</span><br><span class="line">[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;];</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-23 16:55:10.563221+0800 单链表[40694:20785389] 单链表为:2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure></div><ul><li>反向遍历</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 单链表：倒叙遍历链表</span><br><span class="line">+ (NSMutableArray *)printFromTailWithNode:(SingleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode || !headNode.next)&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 遍历指针偏移，每次遍历完一次后，要记录最后一个节点，然后将遍历指针移动到开头重新开始，与记录的最后一个节点作比较</span><br><span class="line">    NSMutableArray * items = [NSMutableArray array];</span><br><span class="line">    SingleLinkNode * pNode = headNode;</span><br><span class="line">    SingleLinkNode * lastNode = nil;</span><br><span class="line">    while (pNode != nil &amp;&amp; lastNode != pNode) &#123;</span><br><span class="line">        pNode = pNode.next;</span><br><span class="line">        if (pNode.next == nil || pNode.next == lastNode) &#123;</span><br><span class="line">            lastNode = pNode;</span><br><span class="line">            pNode = headNode;</span><br><span class="line">            [items addObject:lastNode.data];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return items;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>vc实现：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 倒叙打印节点</span><br><span class="line">NSMutableArray * tailArr = [LinkInterface printFromTailWithNode:headNode];</span><br><span class="line">NSLog(@&quot;tail:%@&quot;,tailArr);</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2022-11-23 17:00:09.521947+0800 单链表[41100:20791055] tail:(</span><br><span class="line">    5,</span><br><span class="line">    4,</span><br><span class="line">    3,</span><br><span class="line">    2</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><ol start="8"><li>反转链表</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 单链表：反转链表</span><br><span class="line">+ (SingleLinkNode *)reverseWithNode:(SingleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode|| !headNode.next)&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 采用头节点插入的方式反转</span><br><span class="line">    // 定义遍历指针</span><br><span class="line">    SingleLinkNode * p = headNode.next;</span><br><span class="line">    // 定义反转后头节点</span><br><span class="line">    SingleLinkNode * newHead = [[SingleLinkNode alloc] init];</span><br><span class="line">    while (p != nil) &#123;</span><br><span class="line">        // 记录下一个节点用来往下循环</span><br><span class="line">        SingleLinkNode * temp = p.next;</span><br><span class="line">        </span><br><span class="line">        // 替换当前节点的next为新头next</span><br><span class="line">        p.next = newHead.next;</span><br><span class="line">        // 更新新头节点指向当前节点即可反转</span><br><span class="line">        newHead.next = p;</span><br><span class="line">        </span><br><span class="line">        // 移动p指针</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>vc实现：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 反转链表</span><br><span class="line">SingleLinkNode * reverseNode = [LinkInterface reverseWithNode:headNode];</span><br></pre></td></tr></table></figure></div><ol start="9"><li>合并有序链表（有问题，排序不对）</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 两个有序链表合并成一个新的有序链表</span><br><span class="line">+ (SingleLinkNode *)combineWithNode:(SingleLinkNode *)headNode otherNode:(SingleLinkNode *)otherNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode || !headNode.next)&#123;</span><br><span class="line">        return otherNode;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!otherNode || !otherNode.next)&#123;</span><br><span class="line">        return headNode;</span><br><span class="line">    &#125;</span><br><span class="line">    // 一起遍历</span><br><span class="line">    SingleLinkNode * p1 = headNode.next;</span><br><span class="line">    SingleLinkNode * p2 = otherNode.next;</span><br><span class="line">    // 定义一个新头节点</span><br><span class="line">    SingleLinkNode * newHead = [[SingleLinkNode alloc] init];</span><br><span class="line">    while (p1 != nil &amp;&amp; p2 != nil) &#123;</span><br><span class="line">        if([p1.data integerValue] &gt; [p2.data integerValue])&#123;</span><br><span class="line">            // 移动otherNode节点指向otherNode当前节点的下一个节点</span><br><span class="line">            otherNode.next = p2.next;</span><br><span class="line">            // 将当前otherNode节点链表断掉</span><br><span class="line">            p2.next = nil;</span><br><span class="line">            // 将当前otherNode节点插入到新节点newHead链表的尾部</span><br><span class="line">            [self insertNewNodeToTail:p2 headNode:newHead];</span><br><span class="line">            // 获取otherNode链表的下一个节点</span><br><span class="line">            p2 = otherNode.next;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            headNode.next = p1.next;</span><br><span class="line">            p1.next = nil;</span><br><span class="line">            [self insertNewNodeToTail:p1 headNode:newHead];</span><br><span class="line">            p1 = headNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理没扫描结束的链表</span><br><span class="line">    while (p1 != nil) &#123;</span><br><span class="line">        headNode.next = p1.next;</span><br><span class="line">        p1.next = nil;</span><br><span class="line">        [self insertNewNodeToTail:p1 headNode:newHead];</span><br><span class="line">        p1 = headNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (p2 != nil) &#123;</span><br><span class="line">        otherNode.next = p2.next;</span><br><span class="line">        p2.next = nil;</span><br><span class="line">        [self insertNewNodeToTail:p2 headNode:newHead];</span><br><span class="line">        p2 = otherNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="10"><li>判断两个链表是否相交</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 单链表：判断两个链表是否相交</span><br><span class="line">+ (BOOL)intersectWithNode:(SingleLinkNode *)headNode otherNode:(SingleLinkNode *)otherNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode || !headNode.next || !otherNode || !otherNode.next)&#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    // 思路：分别获取两个链表的长度，判断谁的链表更长，链表更长的先走完相差的步数，然后再齐步走</span><br><span class="line">    SingleLinkNode * p1 = headNode.next;</span><br><span class="line">    SingleLinkNode * p2 = otherNode.next;</span><br><span class="line">    </span><br><span class="line">    int L1 = 1;</span><br><span class="line">    int L2 = 1;</span><br><span class="line">    while (p1 != nil) &#123;</span><br><span class="line">        L1 ++;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while (p2 != nil) &#123;</span><br><span class="line">        L2 ++;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p1 = headNode.next; // 将p1遍历指针移动到首节点</span><br><span class="line">    p2 = headNode.next; // 将p2遍历指针移动到首节点</span><br><span class="line">    </span><br><span class="line">    int i = 0;</span><br><span class="line">    if (L1 &gt; L2) &#123;</span><br><span class="line">        while (i &lt; L1 - L2 &amp;&amp; p1 != nil) &#123; // p1先走</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        while (i &lt; L2 - L1 &amp;&amp; p2 != nil) &#123; // p2先走</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // p1、p2齐步走</span><br><span class="line">    if(i == ABS(L1 - L2))&#123;</span><br><span class="line">        while (p1 != nil &amp;&amp; p2 != nil) &#123;</span><br><span class="line">            if(p1.next == p2.next) return YES;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="11"><li>判断链表是否头程还，如果成环，求出环的入口节点</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 单链表：判断链表是否构成环，如果成环，求出环的入口节点</span><br><span class="line">+ (SingleLinkNode *)circleWithNode:(SingleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode || !headNode.next)&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 思路：采用快慢指针</span><br><span class="line">    // 快指针先走两步，满指针走一步，如果成环，必然重合。</span><br><span class="line">    // 走到第一次重合的地点后，重新设置一个指针p指向头节点，并与慢节点同步伐齐步走</span><br><span class="line">    // 走到第二次相遇的地方，即为构成环的节点</span><br><span class="line">    SingleLinkNode * quick = headNode.next;</span><br><span class="line">    SingleLinkNode * slow = headNode.next;</span><br><span class="line">    SingleLinkNode * p = headNode.next;</span><br><span class="line">    while (quick != nil &amp;&amp; slow != nil) &#123;</span><br><span class="line">        quick = quick.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        if (quick == slow) &#123; // 第一次重合，结束循环</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (p != nil &amp;&amp; slow != nil) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        if (p == slow) &#123; // 第二次重合，找到成环的入口节点</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>双向链表：每一个节点前后指针域都和他的上一个节点互相指向，尾节点的next指向nil，首节点的pre指向nil</p><ol><li>定义节点</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface DoubleLinkNode : NSObject</span><br><span class="line">@property (nonatomic,strong)id data; // 数据域</span><br><span class="line">@property (nonatomic,weak,nullable)DoubleLinkNode * pre; // 前驱指针域（防止循环引用）</span><br><span class="line">@property (nonatomic,strong,nullable)DoubleLinkNode * next; // 后继指针域</span><br><span class="line">+ (instancetype)constructNodeWithData:(id)data;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation DoubleLinkNode</span><br><span class="line">+ (instancetype)constructNodeWithData:(id)data&#123;</span><br><span class="line">    DoubleLinkNode * node = [[DoubleLinkNode alloc] init];</span><br><span class="line">    node.data = data;</span><br><span class="line">    node.pre = nil;</span><br><span class="line">    node.next = nil;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ol start="2"><li>构建一个双向链表</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 构造一个双向链表</span><br><span class="line">DoubleLinkNode * head = [[DoubleLinkNode alloc] init];</span><br><span class="line">DoubleLinkNode * node1 = [DoubleLinkNode constructNodeWithData:@1];</span><br><span class="line">DoubleLinkNode * node2 = [DoubleLinkNode constructNodeWithData:@2];</span><br><span class="line">head.next = node1;</span><br><span class="line">node1.pre = head;</span><br><span class="line">node1.next = node2;</span><br><span class="line">node2.pre = node1;</span><br><span class="line">[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双链表为&quot;];</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-24 13:38:50.045234+0800 单链表[50291:20937675] 双链表为:1⇄2</span><br></pre></td></tr></table></figure></div><ol start="3"><li>在头部插入节点</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 双向链表：向头部插入节点</span><br><span class="line">+ (void)insertDoubleNewNodeToHead:(DoubleLinkNode *)newNode headNode:(DoubleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果只有一个头节点</span><br><span class="line">    if(headNode.next == nil)&#123;</span><br><span class="line">        headNode.next = newNode;</span><br><span class="line">        newNode.pre = headNode;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        newNode.next = headNode.next; // 当前节点的后继指向头节点的后继</span><br><span class="line">        headNode.next.pre = newNode; // 头结点后继的前驱指向当前节点</span><br><span class="line">        </span><br><span class="line">        newNode.pre = headNode; // 当前节点的前驱指向头结点</span><br><span class="line">        headNode.next = newNode; // 头结点的后继指向当前节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>vc实现</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在头部插入节点</span><br><span class="line">DoubleLinkNode * node0 = [DoubleLinkNode constructNodeWithData:@0];</span><br><span class="line">[LinkInterface insertDoubleNewNodeToHead:node0 headNode:head];</span><br><span class="line">[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双链表为&quot;];</span><br></pre></td></tr></table></figure></div><p>打印结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-24 13:53:01.240605+0800 单链表[51484:20953802] 双链表为:0⇄1⇄2</span><br></pre></td></tr></table></figure></div><ol start="4"><li>在尾部插入节点</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 双向链表：向尾部插入节点</span><br><span class="line">+ (void)insertDoubleNewNodeToTail:(DoubleLinkNode *)newNode headNode:(DoubleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置偏移指针</span><br><span class="line">    DoubleLinkNode * pNode = headNode.next;</span><br><span class="line">    while (pNode.next != nil) &#123;</span><br><span class="line">        pNode = pNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pNode.next = newNode;</span><br><span class="line">    newNode.pre = pNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>vc实现</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在尾部插入节点</span><br><span class="line">DoubleLinkNode * node4 = [DoubleLinkNode constructNodeWithData:@4];</span><br><span class="line">[LinkInterface insertDoubleNewNodeToTail:node4 headNode:head];</span><br><span class="line">[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双向链表为&quot;];</span><br></pre></td></tr></table></figure></div><p>打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-24 13:59:04.853558+0800 单链表[52038:20962187] 双向链表为:0⇄1⇄2⇄4</span><br></pre></td></tr></table></figure></div><ol start="5"><li>在指定位置插入节点</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 双向链表：在指定位置插入节点</span><br><span class="line">+(void)insertDoubleNewNodeToIndex:(int)index newNode:(DoubleLinkNode *)newNode headNode:(DoubleLinkNode *)headNode&#123;</span><br><span class="line">    if(!headNode)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果头结点即尾节点</span><br><span class="line">    if (headNode.next == nil)&#123;</span><br><span class="line">        headNode.next = newNode;</span><br><span class="line">        newNode.pre = headNode;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    // 如果头节点即尾节点</span><br><span class="line">    if (headNode.next == nil)&#123;</span><br><span class="line">        headNode.next = newNode;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        // 设置偏移指针</span><br><span class="line">        DoubleLinkNode * pNode = headNode.next;</span><br><span class="line">        int i = 1;</span><br><span class="line">        while (i &lt; index &amp;&amp; pNode.next != nil) &#123;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode.next = pNode.next;</span><br><span class="line">        pNode.next.pre = newNode;</span><br><span class="line">        newNode.pre = pNode;</span><br><span class="line">        pNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>vc实现</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在指定位置插入节点</span><br><span class="line">DoubleLinkNode * node3 = [DoubleLinkNode constructNodeWithData:@3];</span><br><span class="line">[LinkInterface insertDoubleNewNodeToIndex:3 newNode:node3 headNode:head];</span><br><span class="line">[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双向链表为&quot;];</span><br></pre></td></tr></table></figure></div><p>打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-24 14:08:41.539116+0800 单链表[52850:20973592] 双向链表为:0⇄1⇄2⇄3⇄4</span><br></pre></td></tr></table></figure></div><ol start="6"><li>删除指定位置节点</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 双向链表：删除指定位置节点</span><br><span class="line">+ (DoubleLinkNode *)deleteDoubleNodeAtIndex:(int)index headNode:(DoubleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode)&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置偏移指针</span><br><span class="line">    DoubleLinkNode * pNode = headNode.next;</span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i &lt; index &amp;&amp; pNode.next != nil) &#123;</span><br><span class="line">        pNode = pNode.next;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i == index)&#123;</span><br><span class="line">        pNode.pre.next = pNode.next;</span><br><span class="line">        pNode.next.pre = pNode.pre;</span><br><span class="line">        return pNode;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>vc实现</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 删除指定位置节点</span><br><span class="line">[LinkInterface deleteDoubleNodeAtIndex:1 headNode:head];</span><br><span class="line">[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双向链表为&quot;];</span><br></pre></td></tr></table></figure></div><p>打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-24 14:15:01.766124+0800 单链表[53365:20980542] 双向链表为:1⇄2⇄3⇄4</span><br></pre></td></tr></table></figure></div><ol start="7"><li>遍历并打印链表</li></ol><pre><code>// 双向链表：遍历并打印链表+ (void)printDoubleFromHeadWithNode:(DoubleLinkNode *)headNode printPrefixText:(NSString *)text&#123;    if(!headNode)&#123;        return;    &#125;    DoubleLinkNode * pNode = headNode.next;    NSMutableArray * items = [NSMutableArray array];    while (pNode != nil) &#123;        [items addObject:pNode.data];        pNode = pNode.next;    &#125;    NSLog(@&quot;%@:%@&quot;,text,[items componentsJoinedByString:@&quot;⇄&quot;]);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-数据结构探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC算法03：斐波那契数列探索</title>
      <link href="/BboyZJ.github.io/2020/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9503%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9503%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>斐波那契数列</code>（Fibonacci sequence），又称黄金分割数列、因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为<code>“兔子数列”</code>，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(1)&#x3D;1，F(2)&#x3D;1, F(n)&#x3D;F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*），用文字来说，就是斐波那契数列由 0 和 1 开始，之后的斐波那契数列系数就由 之前的两数相加。</p><h1 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h1><p>问：有一段楼梯有10级台阶，规定每一步只能跨一级或两级，要登上第 10 级台阶有几种不同的走法?</p><p>分析：这就是一个斐波那契数列：登上第一级台阶有一种登法；登上两级台阶，有两种登法；登上三级台阶，有三种登法；登上四级台阶，有五种登法……<br>1，2，3，5，8，13…… 所以，登上十级，有 89 种走法。</p><p>答：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo&#123;</span><br><span class="line">    // 有10级台阶</span><br><span class="line">    NSInteger tjNum = 10;</span><br><span class="line">    </span><br><span class="line">    NSInteger total = [self getTotalNumOfMethods:tjNum];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;total:%ld&quot;,total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)getTotalNumOfMethods:(NSInteger)num&#123;</span><br><span class="line">    if (num == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (num == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (num == 2) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return [self getTotalNumOfMethods:num-1] + [self getTotalNumOfMethods:num - 2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打印结果：89</p><h1 id="兔子繁殖问题"><a href="#兔子繁殖问题" class="headerlink" title="兔子繁殖问题"></a>兔子繁殖问题</h1><p>斐波那契数列又因数学家莱昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”。</p><p>问：一般而言，兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。如果所有兔子都不死，那么一年以后可以繁殖多少对兔子？</p><p>分析：我们不妨拿新出生的一对小兔子分析一下：<br>第一个月小兔子没有繁殖能力，所以还是一对  </p><p>两个月后，生下一对小兔对数共有两对</p><p>三个月以后，老兔子又生下一对，因为小兔子还没有繁殖能力，所以一共是三对<br>－－－－－－<br>依次类推可以列出下表：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/89731933-b1625480-da7d-11ea-8248-7e864219e2dc.png"                                     ></p><p>幼仔对数&#x3D;前月成兔对数<br>成兔对数&#x3D;前月成兔对数+前月幼仔对数<br>总体对数&#x3D;本月成兔对数+本月幼仔对数<br>可以看出幼仔对数、成兔对数、总体对数都构成了一个数列。这个数列有关十分明显的特点，那是：前面相邻两项之和，构成了后一项。</p><p>答：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo1&#123;</span><br><span class="line">    NSInteger month = 12;</span><br><span class="line">    </span><br><span class="line">    NSInteger tuTotal = [self getTuTotalNum:month];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;tuTotal:%ld&quot;,tuTotal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)getTuTotalNum:(NSInteger)month&#123;</span><br><span class="line">    if (month == 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (month == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (month == 2) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return [self getTuTotalNum:month-1] + [self getTuTotalNum:month - 2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>打印结果：233</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-算法探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC算法02：插入排序探索</title>
      <link href="/BboyZJ.github.io/2020/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9502%EF%BC%9A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9502%EF%BC%9A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，直到全部对象都插入为止。即边插入边排序，保证子序列中随时都是排好序的。</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>有序插入</p><ul><li><p>在有序列序列中插入一个元素，保持序列有序，有序长度不断增加。</p></li><li><p>可以插入在中间、最前面和最后面</p></li></ul><h1 id="插入排序种类"><a href="#插入排序种类" class="headerlink" title="插入排序种类"></a>插入排序种类</h1><ol><li><p>顺序法定位插入位置 – <code>直接插入排序</code></p></li><li><p>缩小增量多遍插入排序 – <code>希尔排序</code></p></li></ol><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><ol><li><p>基本思路：每轮排序把数组分为2部分，一部分为已排序好的数组，一部分为还未排序好的数组。每次取出还未排序好的数组中首元素与已排序好的数组从右往左比较。如果发现从未排序中取出的元素比从已排序中取出的元素大，就把该未排序的元素插入到从已排序中取出元素的后面。这样每一轮就能确定一个未排序元素在已排序数组中的准确位置</p></li><li><p>算法思想</p></li></ol><ul><li><p>从第一个元素开始，该元素可以认为已经被排序</p></li><li><p>取出下一个元素，在已经排序的元素序列中从后向前扫描</p></li><li><p>如果该元素（已排序）大于新元素，将该元素移到下一位置</p></li><li><p>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</p></li><li><p>将新元素插入到下一位置中</p></li><li><p>重复步骤2~5</p></li></ul><ol start="3"><li>直接插入排序的流程演示</li></ol><p>流程举例: 红色的为已排序部分，蓝色的为未排序部分</p><p>1）原始数据：首先把原数组从下坐标1开始拆分为2部分， 已排序部分(红色)，未排序部分(蓝色)。默认原数组首元素为已排序元素。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061833441.png"                                     ></p><p>2）第一轮：接着用后面未排序部分的第一个元素与已排序部分的最后一个元素进行比较，这里发现已排序最末尾元素5小于未排序元素第一个元素9.且元素5余元素9的位置是相邻的。不发生插入。把元素9列入已排序数组中。此时已排序好的元素多了一个。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061833527.png"                                     ></p><p>3）第二轮：然后接着用后面未排序部分的第一个元素与已排序部分的最后一个元素进行比较，这里发现已排序最末尾元素9大于未排序元素第一个元素2。并且9不是已排序元素最前面一个元素，所以忽略本次操作，让元素2与已排序元素从右往左的下一个元素进行比较，此时发现已排序元素5大于元素2，但发现元素5是已排序元素中首个元素。则直接把元素2插入到元素5前面。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061833540.png"                                     ></p><p>4）第三轮排序：用后面未排序部分的第一个元素与已排序部分的最后一个元素进行比较，这里发现已排序最末尾元素9小于未排序元素第一个元素15。且两个元素相邻。不发生插入，把元素15加入已排序部分。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061833930.png"                                     ></p><p>5）第四轮排序：用后面未排序部分的第一个元素与已排序部分的最后一个元素进行比较，这里发现已排序最末尾元素15小于未排序元素第一个元素46。且两个元素相邻。不发生插入，把元素46加入已排序部分。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061835372.png"                                     ></p><p>6）最后：依次按照上面的方式递归排序。直到所有元素排序完成。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061834433.png"                                     ></p><ol start="4"><li>列子:</li></ol><p>代码实现：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@15,@2,@5,@10,@20]];</span><br><span class="line">    </span><br><span class="line">    // 插入排序的原理：始终定义第一个元素为有序的，将元素逐个插入到有序的排列中</span><br><span class="line">    // 其特点是：不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去</span><br><span class="line">    for (int i = 0 ; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        // temp为待排元素i为其位置</span><br><span class="line">        NSNumber * temp = arr[i];</span><br><span class="line">        // j为已排元素最后一个元素的位置</span><br><span class="line">        int j = i - 1;</span><br><span class="line">        // 当j&gt;=0时，i为第一个待排元素，取已排元素和待排元素比较，在已经排好序中从后向前扫描</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; [arr[j] integerValue] &gt; [temp integerValue]) &#123;</span><br><span class="line">            // 如果已经排好序的序列中元素大于新元素，则将该元素往右移动一个位置</span><br><span class="line">            [arr replaceObjectAtIndex:j+1 withObject:arr[j]];</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        // 跳出循环时，j已排元素小于或等于i的元素（待排元素）。插入新元素a[j+1] = temp，即空出来的位置插入待排序的值</span><br><span class="line">        [arr replaceObjectAtIndex:j+1 withObject:temp];</span><br><span class="line">        NSLog(@&quot;插入排序排序中:%@&quot;,[self getArrayStr:arr]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 将数组中的元素拼接成字符串 - 方便打印</span><br><span class="line">- (NSString *)getArrayStr:(NSArray *)array &#123;</span><br><span class="line">    NSMutableString *strM = [NSMutableString string];</span><br><span class="line">    for (NSNumber *num in array) &#123;</span><br><span class="line">        [strM appendString:[NSString stringWithFormat:@&quot;%@,&quot;,num]];</span><br><span class="line">    &#125;</span><br><span class="line">    return strM.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>打印结果:</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-08-07 21:30:38.316438+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:15,2,5,10,20,</span><br><span class="line">2020-08-07 21:30:38.316483+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:2,15,5,10,20,</span><br><span class="line">2020-08-07 21:30:38.316502+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:2,5,15,10,20,</span><br><span class="line">2020-08-07 21:30:38.316519+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:2,5,10,15,20,</span><br><span class="line">2020-08-07 21:30:38.316535+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:2,5,10,15,20,</span><br></pre></td></tr></table></figure></div><ol start="5"><li>算法分析</li></ol><ul><li>直接插入排序的算法性能</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://user-images.githubusercontent.com/25925248/89651355-62d67e00-d8f6-11ea-8a41-5245460356d6.png"                                     ></p><ul><li>时间复杂度</li></ul><p><strong>最好的情况（关键字在记录中<em>顺序有序</em>）：</strong></p><ol><li>当元素的初始序列为正序时，仅外循环要进行n-1趟排序且每一趟只进行一次比较，没有进入if语句不存在元素之间的交换(移动)。此时比较次数(Cmin)和移动次数(Mmin)达到最小值。 此时时间复杂度为O(n)。</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比较次数：Cmin = n-1;</span><br><span class="line">移动次数：Mmin = 0;</span><br></pre></td></tr></table></figure></div><ol start="2"><li>举例：</li></ol><p>如：1 2 3 4 5<br>比较：                         次数      移动<br>第2个元素和第一个元素比较          1        0<br>第3个元素和第二个元素比较          1        0<br>…<br>第n个元素和第n-1个元素比较         1       0<br>比较的次数：n-1<br>移动的次数：0</p><p><strong>最坏的情况（关键字在记录序列中<em>逆序有序</em>）：</strong></p><ol><li>最差就是逆序。每趟排序中待插入的元素都要和[0,i-1]中的i个元素进行比较且要将这i个元素后移，i个元素后移移动次数当然也就为i了，再加上temp &#x3D; arr[i]与arr[j+1] &#x3D; temp的两次移动，每趟移动的次数为i+2,此时比较次数(Cmin)和移动次数(Mmin)达到最小值。 此时时间复杂度为O(n2)。</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cmax = 1+2+...+(n-1) = n*(n-1)/2 = O(n2)</span><br><span class="line">Mmax = (1+2)+(2+2)+...+(n-1+2) = (n-1)*(n+4)/2 = O(n2)  (i取值范围1~n-1)</span><br></pre></td></tr></table></figure></div><ol start="2"><li>例子：</li></ol><p>如：5 4 3 2 1<br>比较：                                 次数       移动<br>第2个元素和第1个元素比较                   1        1+2<br>第3个元素和前2个元素比较                   2        2+2<br>…<br>第n个元素和前n-1个比较                    n-1      n-1+2<br>最后： 把1+2+…+n-1加起来求平均值<br>比较的次数：1+2+…+n-1 &#x3D; (n+2)(n-1)&#x2F;2<br>移动的次数：(1+2)+(2+2)+…+(n-1+2) &#x3D; (n-1)*(n+4)&#x2F;2 &#x3D; O(n2)  (i取值范围1~n-1)</p><p><strong>事件复杂度结论：原始数据越接近有序，排序速度越快</strong></p><p>1）最好的情况下（顺序有序）：O(n)<br>2）最坏的情况下（逆序有序）：O(n^2)<br>3）平均情况下，耗时差不多是最坏情况的一般：O(n^2)<br>4）要提高查找速度</p><p>减少元素的比较次数<br>减少元素的移动次数</p><ul><li>空间复杂度</li></ul><p>由直接插入排序算法可知，我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 O(1) 。</p><ul><li>算法稳定性</li></ul><p>直接插入排序的过程中，不需要改变相等数值元素的位置，所以它是稳定的算法。</p><ul><li>插入排序和选择排序的区别</li></ul><ol><li><p>插入排序和选择排序都有两层循环，外循环遍历整个数组</p></li><li><p>内循环稍有区别：</p><ul><li>选择排序的内循环是遍历一组未排过序的数组。</li><li>插入排序的内循环是遍历一组已排过序的数组。</li></ul></li></ol><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><ol><li><p>简介</p><p>希尔排序(Shell Sort)，一听这名字就知道是一个叫希尔的外国人发明的排序。没错，他就是唐纳德 <code>希尔</code>（Donald Shell），一位美国的计算机科学家，他于1959年发明的希尔排序算法。</p></li><li><p>希尔排序思路</p></li></ol><ul><li><p>希尔排序相当于 <code>直接插入排序的加强版</code>，在直接插入排序的概念之上加入了 <code>增量</code> 这个概念。</p></li><li><p>什么是增量？<br>  插入排序只能与相邻的元素进行比较，而希尔排序则是进行 <code>跳跃</code> 比较，而 <code>增量</code> 就是 跳跃的 <code>间隔数</code>。<br>  所谓增量即是把数组按照一定间隔数分组成不同的数组。例如:@{1,2,3,4,5,6,7},一共有6个元素，假设把数组按照增量3进行分组，那么就是@{1,4,7},@{2,5},@{3,6}各分为一组。因为增量是3，所以每间隔3个下坐标为一组。</p></li><li><p>按照增量分组后，把每一组的元素按照插入排序进行排序。当按照一个增量分组完成并每组数据按照插入排序完成后，将增量设为原本的二分之一，然后重复上面的步骤进行插入排序。直到增量为1，按照增量为1的最后一次进行分组插入排序。即完成了排序。</p></li></ul><ol start="3"><li>希尔排序的流程演示</li></ol><ul><li>原始数据：@[@(11),@(10),@(9),@(8),@(7),@(6),@(5),@(4),@(3),@(2),@(1)]</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061837614.png"                                     ></p><ol><li>第一次分组：</li></ol><p>第一步，数组中有11个元素，把数组除以二，得到5(11&#x2F;2实际是等于5余1，由于取正所以为5，由于有余数，所以按照增量取出来的数组的 <code>组数</code> 有 <code>增量+1</code> 即 <code>5 + 1 = 6组</code>。如果没有余数则组数就是增量数。)，以5为增量，从数组第一个元素开始，每间隔5个数取出来的所有元素分为一组，分为6组，分别是：<br>@{11,7}、@{10,4}、@{9,3}、@{8,2}、@{5,1}、@{6}</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061837549.png"                                     ></p><p>第一次排序：每种颜色为一组。接着对每组进行插入排序(具体比较过程就不说了，看过上面插入排序的应该懂)，排序结果为下图(共交换5次):<br>@{7,11}、@{4,10}、@{3,9}、@{2,8}、@{1,5}、@{6}</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061838511.png"                                     ></p><p>2)第二次分组：将增量5再次除以2，得到2(实际5&#x2F;2是等于2余1，有余数所以组数为3)。分为3组分别是:<br>@{7,2,11,8}、@{4,1,10,5}、@{3,6,9}</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16780991255622.jpg"                                     ></p><p>第二次排序：每种颜色为一组，对每组元素进行插入排序。排序结果为(共交换4次)<br>@{2,7,8,11}、@{1,4,5,10}、@{3,6,9}</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16780991388627.jpg"                                     ></p><p>3)第三次分组：将增量2再次除以1，得到1(实际2&#x2F;2等1，没有余数，所以分为1组)。分组后是<br>@{2,1,3,7,4,6,8,5,9,11,10}</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16780991560782.jpg"                                     ></p><p>第三次排序：最后对整组数组进行插入排序，排序结果为(共交换7次)：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/BboyZJ.github.io/assets/16780991704280.jpg"                                     ></p><ol start="4"><li>希尔排序的特点</li></ol><p>1）一次移动，移动位置比较大，跳跃式地接近排序后的最终位置<br>2）最后一次只需要少量移动<br>3）增量序列必须是递减的，最后一个必须是1<br>4）增量序列应该是互质的</p><ol start="5"><li>实例</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@(9),@(3),@(8),@(5),@(2),@(4),@(7),@(6),@(1)]];</span><br><span class="line">    [self shellSort:arr];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)shellSort:(NSMutableArray *)list&#123;</span><br><span class="line">    // 起始间隔值gap设置为总数的一半</span><br><span class="line">    int gap = (int)list.count / 2;</span><br><span class="line">    // 直到gap==1结束</span><br><span class="line">    while (gap &gt;= 1) &#123;</span><br><span class="line">        //i为待排元素，以步距gap从后向前扫描</span><br><span class="line">        for(int i = gap ; i &lt; [list count]; i++)&#123;</span><br><span class="line">            //temp为待排元素i为其位置</span><br><span class="line">            NSInteger temp = [[list objectAtIndex:i] intValue];</span><br><span class="line">            //获取当前位置</span><br><span class="line">            int j = i;</span><br><span class="line">            //然后将此位置之前的元素，按照增量进行跳跃式比较</span><br><span class="line">            while (j &gt;= gap &amp;&amp; temp &lt; [[list objectAtIndex:(j - gap)] intValue]) &#123;</span><br><span class="line">                [list replaceObjectAtIndex:j withObject:[list objectAtIndex:j-gap]];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            //跳出循环时，j元素小于i的元素（待排元素）。插入新元素a[j] = temp，即空出来的位置插入待排序的值</span><br><span class="line">            [list replaceObjectAtIndex:j withObject:[NSNumber numberWithInteger:temp]];</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;步长：%d --- 希尔排序:%@&quot;,gap,[self getArrayStr:list]);</span><br><span class="line">        //步长</span><br><span class="line">        gap = gap / 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将数组中的元素拼接成字符串 - 方便打印</span><br><span class="line">- (NSString *)getArrayStr:(NSArray *)array &#123;</span><br><span class="line">    NSMutableString *strM = [NSMutableString string];</span><br><span class="line">    for (NSNumber *num in array) &#123;</span><br><span class="line">        [strM appendString:[NSString stringWithFormat:@&quot;%@,&quot;,num]];</span><br><span class="line">    &#125;</span><br><span class="line">    return strM.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>打印结果</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-08-09 22:02:14.160098+0800 OC-哈希排序[23997:1116332] 步长：4 --- 希尔排序:1,3,7,5,2,4,8,6,9,</span><br><span class="line">2020-08-09 22:02:14.160373+0800 OC-哈希排序[23997:1116332] 步长：2 --- 希尔排序:1,3,2,4,7,5,8,6,9,</span><br><span class="line">2020-08-09 22:02:14.160620+0800 OC-哈希排序[23997:1116332] 步长：1 --- 希尔排序:1,2,3,4,5,6,7,8,9,</span><br></pre></td></tr></table></figure></div><ol start="6"><li>希尔排序算法分析：</li></ol><p>1）希尔排序的时间复杂度与增量的选取有关。例如，当增量为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为O(N²)，而Hibbard增量的希尔排序的时间复杂度为O(N3&#x2F;2)。<br>2）空间复杂度：<br>O(1)<br>3）是一种不稳定的排序算法：</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-算法探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
