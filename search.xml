<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OC学习21：hybrid</title>
      <link href="/BboyZJ.github.io/2023/03/16/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A021%EF%BC%9Ahybrid/"/>
      <url>/BboyZJ.github.io/2023/03/16/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A021%EF%BC%9Ahybrid/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <code>iOS</code> 开发中，<code>iOS</code> 和 <code>JS</code> 交互是每个程序猿必须掌握的技能。<code>iOS8</code> 以后，苹果推出了新框架 <code>WebKit</code>，使用 <code>WKWebView</code> 替代 <code>UIWebView</code>。</p><p>说道 <code>iOS</code> 和 <code>JS</code> 交互，就不得不提 <code>Hybrid（Hybrid Mobile App）</code>，即通过 <code>Web</code> 网络技术与 <code>Native</code> 相结合的混合移动应用开发</p><blockquote><p><code>WKWebView</code> 特性<br>1、稳定性好、占用内存少，速度更快<br>2、高达60fps的滚动刷新率以及内置手势</p></blockquote><p>本文主要介绍 <code>WKWebView</code> 与 <code>JS</code> 交互</p><h1 id="WKWebView-和-JS-交互的方法"><a href="#WKWebView-和-JS-交互的方法" class="headerlink" title="WKWebView 和 JS 交互的方法"></a>WKWebView 和 JS 交互的方法</h1><ol><li><code>WKScriptMessageHandler</code> 代理</li><li>拦截 <code>URL</code></li></ol><p>下面以实际功能为例讲解其使用</p><h1 id="WKScriptMessageHandler-代理"><a href="#WKScriptMessageHandler-代理" class="headerlink" title="WKScriptMessageHandler 代理"></a>WKScriptMessageHandler 代理</h1><ul><li><code>WKScriptMessageHandler</code> 是一个 <code>代理</code> ，代理有一个方法：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 当接收到 JS 消息 时调用，是 UserContentController 委托的代理方法</span><br><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message;</span><br></pre></td></tr></table></figure></div><blockquote><p>上面的代理回调方法是 <code>WKScriptMessageHandler</code> 的代理回到方法，当接收到 <code>JS</code> 消息时调用，是 <code>UserContentController（调度器）</code> 委托的代理方法。</p></blockquote><h1 id="WKUserContentController"><a href="#WKUserContentController" class="headerlink" title="WKUserContentController"></a>WKUserContentController</h1><blockquote><p><code>WKWebView</code> 和 <code>JS</code> 交互，那就得提到 <code>WKUserContentController</code> ，什么是 <code>WKUserContentController</code> ？ <code>WKUserContentController</code> 的作用？</p></blockquote><ul><li><code>WKUserContentController</code> 可以理解为 <code>调度器</code>，用于 <code>JS 和 OC 内容交互</code>，下面我们看一下具体有哪些方法：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface WKUserContentController : NSObject &lt;NSCoding&gt;</span><br><span class="line">// 与内容交互的脚本对象数组</span><br><span class="line">@property (nonatomic, readonly, copy) NSArray&lt;WKUserScript *&gt; *userScripts; </span><br><span class="line">// 添加一个脚本，可以理解为注入一个对象</span><br><span class="line">- (void)addUserScript:(WKUserScript *)userScript;</span><br><span class="line"></span><br><span class="line">// 移除所有脚本</span><br><span class="line">- (void)removeAllUserScripts; </span><br><span class="line"></span><br><span class="line">// 添加 JS 消息处理并设置代理</span><br><span class="line">// JS 中要添加 window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;) 方法,是 JS 与OC 之间的桥梁</span><br><span class="line">- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;</span><br><span class="line"></span><br><span class="line">// 根据 name 移除所注入的 scriptMessageHandler</span><br><span class="line">- (void)removeScriptMessageHandlerForName:(NSString *)name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><blockquote><p>这里有一个重要的方法：<code>addScriptMessageHandler</code>，添加 <code>JS</code> 消息处理并设置代理</p></blockquote><ul><li>示例：</li></ul><blockquote><p>1、<code>JS</code> 与 <code>OC</code> 约定好方法，如 <code>ShowMessageFromWKWebView:</code><br>2、<code>OC</code> 使用 <code>WKUserContentController</code> 的 <code>addScriptMessageHandler:name:</code> 方法设置代理并接收名为 <code>name</code> 的 <code>ShowMessageFromWKWebView</code> 的消息<br>3、<code>JS</code> 通过 <code>window.webkit.messageHandlers.scan.postMessage()</code> 的方式将方法 <code>scan</code> 发送消息到 <code>OC</code><br>4、<code>OC</code> 通过 <code>WKScriptMessageHandler</code> 的代理回调方法 <code>userContentController:didReceiveScriptMessage:</code> 中读取 <code>name</code> 为 <code>ShowMessageFromWKWebView</code> 的消息，消息数据在 <code>message.body</code> 中</p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupWKWebView&#123;</span><br><span class="line">    WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];</span><br><span class="line">    configuration.userContentController = [[WKUserContentController alloc] init];</span><br><span class="line">    </span><br><span class="line">    // 添加 JS 消息处理并设置代理</span><br><span class="line">    [configuration.userContentController addScriptMessageHandler:self name:@&quot;scan&quot;];</span><br><span class="line"></span><br><span class="line">    WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];</span><br><span class="line">    webView.UIDelegate = self;</span><br><span class="line">    [self.view addSubview:self.wkWebV];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>h5中要实现的代码</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function showMessageFromWKWebViewClick() &#123;</span><br><span class="line">    // JS 发送消息到 OC</span><br><span class="line">window.webkit.messageHandlers.ShowMessageFromWKWebView.postMessage(&#123;title:&#x27;WKWebView&#x27;, message:&#x27;测试WKWebView和OC交互&#x27;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>实现 <code>WKScriptMessageHandler</code> 代理方法，当接收到 <code>JS</code> 消息 <code>name</code> 为 <code>ShowMessageFromWKWebView</code> 时调用，会回调此代理方法：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - WKScriptMessageHandler</span><br><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123;</span><br><span class="line">// 从协议中我们可以看出这里使用了两个类 WKUserContentController 和 WKScriptMessage。WKUserContentController 可以理解为 调度器，WKScriptMessage 则是携带的数据。</span><br><span class="line">    </span><br><span class="line">    // OC 读取 JS 的消息数据</span><br><span class="line">    NSLog(@&quot;body:%@&quot;,message.body);</span><br><span class="line">    if ([message.name isEqualToString:@&quot;ShowMessageFromWKWebView&quot;]) &#123;</span><br><span class="line">        NSDictionary * dict = message.body;</span><br><span class="line">        NSString * messageStr = [dict objectForKey:@&quot;message&quot;];</span><br><span class="line">        NSString * titleStr = [dict objectForKey:@&quot;title&quot;];</span><br><span class="line">        NSLog(@&quot;messageStr:%@&quot;,messageStr);</span><br><span class="line">        NSLog(@&quot;titleStr:%@&quot;,titleStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="OC-调用-JS"><a href="#OC-调用-JS" class="headerlink" title="OC 调用 JS"></a>OC 调用 JS</h1><ul><li><code>OC</code> 调用 <code>JS</code> 方法用 <code>evaluateJavaScript</code>，可以 <code>传递参数</code>，将拼接字符串传递给 <code>JS</code>，拼接的字符串有格式要求：<code>方法名(&#39;参数&#39;)</code>，是 <code>WKWebView</code> 下的一个方法</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// OC传值JS的代码</span><br><span class="line">NSString * returnJSStr = [NSString stringWithFormat:@&quot;showMessageFromWKWebViewResult(&#x27;%@&#x27;)&quot;, @&quot;message传到OC成功，message传到OC成功，message传到OC成功，message传到OC成功，message传到OC成功，message传到OC成功&quot;];</span><br><span class="line">[self.wkWebV evaluateJavaScript:returnJSStr completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123;</span><br><span class="line">    NSLog(@&quot;%@,%@&quot;,result,error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></div><ul><li>JS 接收 OC 消息</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// JS 接收 OC 消息</span><br><span class="line">function showMessageFromWKWebViewResult(returnStr) &#123;</span><br><span class="line">    if (returnStr != null) &#123;</span><br><span class="line">        alert(&quot;JS已经收到OC的传值&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    document.getElementById(&quot;returnTextrea&quot;).value = returnStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="拦截-URL-实现自定义跳转功能"><a href="#拦截-URL-实现自定义跳转功能" class="headerlink" title="拦截 URL 实现自定义跳转功能"></a>拦截 URL 实现自定义跳转功能</h1><p>拦截 <code>URL</code> 是通过 <code>WKWebView</code> 的 <code>WKNavigationDelegate</code> 代理回调 <code>decidePolicyForNavigationAction</code> 方式实现的，例如：点击WebView按钮、cell等事件，去做一些功能</p><ul><li>在发送请求之前，决定是否跳转</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123;</span><br><span class="line">    // 获取当前的url</span><br><span class="line">    NSString * url = navigationAction.request.URL.absoluteString;</span><br><span class="line">    ZJLog(@&quot;url:%@&quot;,url);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>动态控制是否允许跳转和跳转到哪里</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -处理客服中心按钮的点击事件</span><br><span class="line">- (void)handleCallCenterClickActionWithUrl:(NSString *)url decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123;</span><br><span class="line">    ZJLog(@&quot;url:%@&quot;,url);</span><br><span class="line">    if ([url containsString:@&quot;cloudapp://goodsDetail?goodsId=&quot;]) &#123; // 跳转商品详情</span><br><span class="line">        // 去掉前缀</span><br><span class="line">        NSArray * arr = [url componentsSeparatedByString:@&quot;goodsId=&quot;];</span><br><span class="line">        NSString * goodsId = arr.lastObject;</span><br><span class="line">        SFGoodsDetailVC * goodsDetailVc = [SFGoodsDetailVC new];</span><br><span class="line">        goodsDetailVc.goodsId = [goodsId integerValue];</span><br><span class="line">        goodsDetailVc.enterType = GoodsDetailEnterType_Normal;</span><br><span class="line">        goodsDetailVc.souce = CommodityDetailSouce_Banner; // 首页Banner</span><br><span class="line">        [self.navigationController pushViewController:goodsDetailVc animated:YES];</span><br><span class="line">        // 拦截跳转</span><br><span class="line">        decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">    &#125; else &#123; // 其他</span><br><span class="line">        // 不拦截跳转</span><br><span class="line">        decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="KVO-监听"><a href="#KVO-监听" class="headerlink" title="KVO 监听"></a>KVO 监听</h1><ul><li>监听标题 title</li></ul><p>通过 <code>KeyPath路由</code> 监听 <code>title</code> 可以 动态修改 <code>title</code></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 监听标题</span><br><span class="line">[self.wkWebV zj_addObserver:self forKeyPath:@&quot;title&quot;];</span><br></pre></td></tr></table></figure></div><ul><li>监听进度 <code>estimatedProgress</code></li></ul><p>通过 <code>KeyPath路由</code> 监听  <code>estimatedProgress</code> 可以做 <code>进度条</code></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 添加监听</span><br><span class="line">[self.wkWebV zj_addObserver:self forKeyPath:@&quot;estimatedProgress&quot;];</span><br></pre></td></tr></table></figure></div><ul><li>监听 URL</li></ul><p>通过 <code>KeyPath路由</code> 监听 <code>URL</code>，即在跳转过程中 <code>拦截URL</code>，可以去做一些 动态跳转到 <code>OC</code> 页面</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 监听跳转</span><br><span class="line">[self.wkWebV zj_addObserver:self forKeyPath:@&quot;URL&quot;];</span><br></pre></td></tr></table></figure></div><ul><li>监听的方式代码实现</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -进度的监听</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    NSString * url = self.wkWebV.URL.absoluteString;</span><br><span class="line">    ZJLog(@&quot;url:%@&quot;,url);</span><br><span class="line">    if (object == self.wkWebV &amp;&amp; [keyPath isEqualToString:@&quot;title&quot;]) &#123; // 标题</span><br><span class="line">        if (self.wkWebV.title.length &gt; 0) &#123;</span><br><span class="line">            [self.navStatusV.titleL setTitle:self.wkWebV.title titleColor:kMainTextColor font:16 isBlod:YES];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if (object == self.wkWebV &amp;&amp; [keyPath isEqualToString:@&quot;estimatedProgress&quot;]) &#123; // 进度条</span><br><span class="line">        CGFloat newProgress = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue];</span><br><span class="line">//        ZJLog(@&quot;newProgress:%f&quot;,newProgress);</span><br><span class="line">        if (newProgress &lt;= 0.05f) &#123;</span><br><span class="line">            newProgress = 0.05f;</span><br><span class="line">        &#125;</span><br><span class="line">        [self.progressV changeProgressValue:newProgress];</span><br><span class="line">    &#125;else if (object == self.wkWebV &amp;&amp; [keyPath isEqualToString:@&quot;/cloudApp/customer/service&quot;]) &#123;</span><br><span class="line">        // 跳转到客服中心</span><br><span class="line">        ZJLog(@&quot;跳转到客服中心&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：国际化/多语言适配</title>
      <link href="/BboyZJ.github.io/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%9B%BD%E9%99%85%E5%8C%96-%E5%A4%9A%E8%AF%AD%E8%A8%80%E9%80%82%E9%85%8D/"/>
      <url>/BboyZJ.github.io/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%9B%BD%E9%99%85%E5%8C%96-%E5%A4%9A%E8%AF%AD%E8%A8%80%E9%80%82%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>项目开发中不同语言环境需要进行多语言适配，例如：中文、英语、法语、俄语、葡萄牙语等</p><ul><li>纯代码界面开发时，直接添加本地化语言文件，并针对键值对获取即可</li></ul><p>下面我们来介绍如何国际化：</p><h1 id="全局添加需要适配的多语言"><a href="#全局添加需要适配的多语言" class="headerlink" title="全局添加需要适配的多语言"></a>全局添加需要适配的多语言</h1><p>PROHECT -&gt; Info -&gt; Localizetions 下：选择 + 号添加：</p><blockquote><p>Chinese，Simplified：中文简体<br>Chinese，Traditional：中文繁体<br>English - Development Localization：英语<br>French(fr)：法语<br>Russian：俄语<br>Arabic：阿拉伯语<br>…</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150647485.png"                                     ></p><p>添加完成之后的效果：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172026085.png"                                     ></p><p>细心的朋友会发现如今 <code>English</code> 后面是 <code>1 File Localized</code>，这是因为 <code>英语</code> 是系统默认加入的，并且同一时刻为 <code>Main.storyboard</code> 和 <code>LaunchScreen.storyboard</code> 设置了多语言</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172026300.png"                                     ></p><h1 id="纯代码本地化"><a href="#纯代码本地化" class="headerlink" title="纯代码本地化"></a>纯代码本地化</h1><ol><li>创建本地化文件</li></ol><p>默认文件名为 <code>Localizable</code> ，不要去修改</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172026376.png"                                     ></p><ul><li>点击 Next，Save <code>As：Localizable</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172026092.png"                                     ></p><p><code>Localizable.strings</code> 就是你需要的本地化文化</p><ul><li>关联对应的本地化语言</li></ul><p>点击右侧的 <code>Localizable</code>，关联本地化语言</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172027552.png"                                     ></p><ul><li>勾选需要关联的本地化语言，全部勾选</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172027404.png"                                     ></p><ol start="2"><li>在本地化文件中设置 <code>Key-Value</code></li></ol><blockquote><p>注意：不要忘记行末的 <code>;</code> 号</p></blockquote><p>分别在对应的本地化语言文件中，设置不同的 <code>Key-Value</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172027768.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172027106.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172027605.png"                                     ></p><ol start="3"><li>调用本地化</li></ol><ul><li><p>使用 <code>NSLocalizedString</code> 函数来访问 <code>Localizable.strings</code> 资源文件</p></li><li><p><code>NSLocalizedString</code> 函数第一个参数为对应的 <code>键名</code>，第二个是自定义的说明，给开发或翻译人员看的。</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 调用字符串对应的本地化符号</span><br><span class="line">let title = NSLocalizedString(&quot;title&quot;, comment: &quot;title&quot;)</span><br><span class="line">MyLog(message: title)</span><br></pre></td></tr></table></figure></div><blockquote><p>这种设置完之后仅仅能让应用随系统的语言进行切换，而用户不能手进行切换</p></blockquote><h1 id="图片本地化"><a href="#图片本地化" class="headerlink" title="图片本地化"></a>图片本地化</h1><ol><li>选中需要本地化的图片，同上面一样点击 <code>Localize...</code> ，创建本地化 <code>图片资源文件</code></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172028648.png"                                     ></p><ol start="2"><li>关联你需要本地化的语言</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172028577.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172029322.png"                                     ></p><ol start="3"><li>图片 <code>Show In Finder</code>，可以看到在 中文和英文资源下都有这个图片，把需要替换的图片换掉即可</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172029513.png"                                     ></p><ol start="4"><li>图片使用和平常一样</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let img = UIImage(named: &quot;loading.png&quot;)</span><br></pre></td></tr></table></figure></div><h1 id="App-名称的-本地化"><a href="#App-名称的-本地化" class="headerlink" title="App 名称的 本地化"></a>App 名称的 本地化</h1><ol><li>要实现应用名称根据语言环境显示不一样的名称，只需要创建 <code>InfoPlist.strings</code> 文件，创建 <code>InfoPlist.strings</code> 并关联语言</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172029520.png"                                     ></p><ol start="2"><li>获取info.plist中的key</li></ol><p>点击 <code>Infoplist</code> 右键选择 <code>Open As -&gt; Source Code</code>，查看我们所要获取权限的原始key。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172029052.png"                                     ></p><p>新版Xcode获取不出来数据不用急，去代码中将info打印出来，拿到key效果一样。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let infoPlist = Bundle.main.infoDictionary</span><br><span class="line">MyLog(message: infoPlist)</span><br></pre></td></tr></table></figure></div><ol start="3"><li>本地化文件中，对key-value进行配置</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Chinese,Simplified</span><br><span class="line">&quot;CFBundleDisplayName&quot; = &quot;中图云书房&quot;</span><br><span class="line"></span><br><span class="line">// Englist</span><br><span class="line">&quot;CFBundleDisplayName&quot; = &quot;SRSF&quot;</span><br></pre></td></tr></table></figure></div><ol start="4"><li>运行App，然后切换手机语言为英文，会发现软件名称变成了英文</li></ol><h1 id="Xcode中切换语言"><a href="#Xcode中切换语言" class="headerlink" title="Xcode中切换语言"></a>Xcode中切换语言</h1><p>为了调试国际化，我们除了可以进入 <code>模拟器或真机</code> 切换系统语言，也可以在 <code>Xcode</code> 中配置相关项，使 <code>Debug</code> 环境下运行时预览不同语言和地区 <code>App的界面效果</code></p><ol><li>选择 Product -&gt; Scheme -&gt; Edit Scheme</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172030056.png"                                     ></p><ol start="2"><li>切换语言后，运行工程</li></ol><h1 id="应用内切换语言"><a href="#应用内切换语言" class="headerlink" title="应用内切换语言"></a>应用内切换语言</h1><p>纯代码本地化只能跟随系统进行切换，并不能手动进行切换，下面先介绍一下相关宏</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 尾随系统切换, 多语言文件名称必须是Localizable</span><br><span class="line">NSLocalizedString(&quot;title&quot;, nil);</span><br><span class="line"></span><br><span class="line">// 以下三个都能够手动设置多语言</span><br><span class="line">// 第一个參数:是多语言中的key</span><br><span class="line">// 第二个參数:是多语言文件的名字</span><br><span class="line">// 第三个參数:是对key的自定义的说明,一般传nil</span><br><span class="line">NSLocalizedStringFromTable(@&quot;title&quot;, @&quot;Localizable&quot;, nil);</span><br><span class="line">// 指定多语言文件名称和bundle</span><br><span class="line">NSLocalizedStringFromTableInBundle(@&quot;title&quot;, @&quot;Localizable&quot;, bundle, nil);</span><br><span class="line">// 在上面的基础上添加一个默认值的參数</span><br><span class="line">NSLocalizedStringWithDefaultValue(@&quot;title&quot;, @&quot;Localizable&quot;, bundle, @&quot;label&quot;, nil);</span><br></pre></td></tr></table></figure></div><ol><li>Resources -&gt; Show In Finder后，发现每一种语言都有对应的文件目录，后缀是 <code>.lproj</code></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172031421.png"                                     ></p><blockquote><p>总结：<br>1、因此 <code>ar.lproj、en.lproj、fr.lproj、ru.lproj、zh-Hans.lproj、zh-Hant.lproj</code> 为我们可以从本地获取到的 <code>语言资源文件</code><br>2、在 <code>App</code> 内切换语言的时候，实际上就是获取 <code>语言资源文件</code> 的 <code>Localizable.strings</code> 文件</p></blockquote><ol start="2"><li>将所有的 <code>语言文件</code> 设置成 <code>字符串类型的枚举</code> 并且有初始值 <code>rawValue</code>， 获取 <code>Localizable.strings</code></li></ol><ul><li>获取 <code>某语言</code> 文件的 <code>value值</code>，相应的想要切换语言的话，直接切换 <code>pathForResource</code> 面的 <code>参数</code> 就可以</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 本地化语言类型</span><br><span class="line">enum LocalizedType: String &#123;</span><br><span class="line">    // 字符串需要对应本地的国际化文件名 .lproj</span><br><span class="line">    case English = &quot;en&quot; // 英语</span><br><span class="line">    case ChineseHans = &quot;zh-Hans&quot; // 简体中文</span><br><span class="line">    case ChineseHant = &quot;zh-Hant&quot; // 繁体中文</span><br><span class="line">    case Russian = &quot;ru&quot; // 俄语</span><br><span class="line">    case Frcench = &quot;fr&quot; // 法语</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取语言文件路径(可以为：en/zh-Hans/zh-Hant/fr/ru 任意一个)</span><br><span class="line">let languageBundlePath = Bundle.main.path(forResource: LocalizedType.English, ofType: &quot;lproj&quot;)</span><br><span class="line">// 获取语言文件路径下对应 key 的 value</span><br><span class="line">let value = Bundle(path: languageBundlePath ?? &quot;&quot;)?.localizedString(forKey: &quot;title&quot;, value: nil, table: &quot;ZJLocalizable&quot;)</span><br><span class="line">MyLog(message: value) </span><br></pre></td></tr></table></figure></div><ol start="3"><li>根据上面的思路，我们可以用 <code>NSUserDefaults</code> 缓存当前的 <code>语言</code>，以便 <code>第一次启动程序</code> 或 <code>程序退出去后</code>，下次进入继续使用上次关闭程序的语言。</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 本地化语言类型</span><br><span class="line">enum LocalizedType: String &#123;</span><br><span class="line">    // 字符串需要对应本地的国际化文件名 .lproj</span><br><span class="line">    case English = &quot;en&quot; // 英语</span><br><span class="line">    case ChineseHans = &quot;zh-Hans&quot; // 简体中文</span><br><span class="line">    case ChineseHant = &quot;zh-Hant&quot; // 繁体中文</span><br><span class="line">    case Russian = &quot;ru&quot; // 俄语</span><br><span class="line">    case Frcench = &quot;fr&quot; // 法语</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化启动时语言</span><br><span class="line">func initLaunchLanguage() &#123;</span><br><span class="line">    // 获取上一次设置的语言</span><br><span class="line">    var languageType = kUserDefault.getInfo(key: &quot;appLanguage&quot;)</span><br><span class="line">    // 如果是第一次启动</span><br><span class="line">    if languageType == nil &#123;</span><br><span class="line">        // 获取系统第一个首选语言</span><br><span class="line">        let systemLanguage = Locale.preferredLanguages.first!</span><br><span class="line">        MyLog(message: systemLanguage)</span><br><span class="line">        if systemLanguage.hasPrefix(LocalizedType.English.rawValue) &#123;</span><br><span class="line">            // 英文</span><br><span class="line">            languageType = LocalizedType.English.rawValue</span><br><span class="line">        &#125;else if systemLanguage.hasPrefix(LocalizedType.ChineseHans.rawValue) &#123;</span><br><span class="line">            // 简体中文</span><br><span class="line">            languageType = LocalizedType.ChineseHans.rawValue</span><br><span class="line">        &#125;else if systemLanguage.hasPrefix(LocalizedType.ChineseHant.rawValue) &#123;</span><br><span class="line">            // 繁体中文</span><br><span class="line">            languageType = LocalizedType.ChineseHant.rawValue</span><br><span class="line">        &#125;else if systemLanguage.hasPrefix(LocalizedType.Frcench.rawValue) &#123;</span><br><span class="line">            // 法文</span><br><span class="line">            languageType = LocalizedType.Frcench.rawValue</span><br><span class="line">        &#125;else if systemLanguage.hasPrefix(LocalizedType.Russian.rawValue) &#123;</span><br><span class="line">            // 俄文</span><br><span class="line">            languageType = LocalizedType.Russian.rawValue</span><br><span class="line">        &#125;</span><br><span class="line">        // 赋值给上一次设置的语言类型</span><br><span class="line">        languageType = systemLanguage</span><br><span class="line">    &#125;</span><br><span class="line">    // 缓存语言</span><br><span class="line">    kUserDefault.saveInfo(value: languageType!, key: &quot;appLanguage&quot;)</span><br><span class="line">    // 设置bundle</span><br><span class="line">    setCurrentBundle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>注：<br>每次设置完语言，我们跟要更新一下 <code>bundle</code>，以便随时获取 <code>key-value</code></p></blockquote><ol start="3"><li>接下来，我们要根据缓存的语言来获取本地语言资源文件，赋值给一个全局的 <code>bundle</code>，以便随时可以通过 <code>bundle</code> 来拿到具体语言文件下的 <code>key-value</code></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 设置bundle</span><br><span class="line">func setCurrentBundle() &#123;</span><br><span class="line">    // 拿到当前语言</span><br><span class="line">    let currentLanguageType = kUserDefault.getInfo(key: &quot;appLanguage&quot;) as! String</span><br><span class="line">    // 获取本地语言资源路径</span><br><span class="line">    let languageBundlePath = Bundle.main.path(forResource: currentLanguageType, ofType: &quot;lproj&quot;)</span><br><span class="line">//        MyLog(message: languageBundlePath)</span><br><span class="line">    guard languageBundlePath != nil else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取 bundle</span><br><span class="line">    let languageBundle = Bundle(path: languageBundlePath!)</span><br><span class="line">    guard languageBundle != nil else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // 赋值给全局的 bundle</span><br><span class="line">    currentBundle = languageBundle</span><br><span class="line">//        MyLog(message: currentBundle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="4"><li>根据 <code>key</code> 获取 <code>value</code></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取要显示的文本</span><br><span class="line">func getLanguageValueWithKey(key: String) -&gt; String &#123;</span><br><span class="line">    let bundle = LocalizableManager.sharedManager.currentBundle</span><br><span class="line">    let value = bundle?.localizedString(forKey: key, value: nil, table: nil)</span><br><span class="line">    return value ?? &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ol start="5"><li>至此，我们的 <code>App内+系统</code> 切换国际化语言，大功告成！！！</li></ol>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog-06：阿里云图床</title>
      <link href="/BboyZJ.github.io/2023/03/15/Blog%E6%90%AD%E5%BB%BA/Blog-06%EF%BC%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9B%BE%E5%BA%8A/"/>
      <url>/BboyZJ.github.io/2023/03/15/Blog%E6%90%AD%E5%BB%BA/Blog-06%EF%BC%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近Gitee突然加了防盗链，导致基于Gitee的图床直接GG了！好家伙还带这样玩的，数据要是没有备份真的心惊胆跳的，不白嫖了，直接付费转战阿里云OSS去。</p><p>​分享一下搭建过程:<br>​</p><h1 id="阿里云OSS开通及配置"><a href="#阿里云OSS开通及配置" class="headerlink" title="阿里云OSS开通及配置"></a>阿里云OSS开通及配置</h1><p>​<br>​1、开通及购买服务包<br>​<br>​登录 <a href="https://www.aliyun.com/?utm_content=se_1013083955">阿里云官网</a>，开通对象存储OSS，开通对象存储OSS不用扣费，只有使用OSS才需要扣费。<br>​​<br>​​<br>​​<img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150611729.png"></p><p>2、OSS有两种扣费方式（产品计费详细介绍）：</p><ul><li><p><a href="https://help.aliyun.com/document_detail/450471.html">按量付费</a></p></li><li><p><a href="https://help.aliyun.com/document_detail/48291.html">资源包</a></p></li></ul><p>根据需要按需购买对应的 <code>资源包</code> 即可，作为一个只是搭建个人向图床的我，只需要购买一个 <code>40GB</code> 的《标准(LRS)存储包》即可，半年只要4.98，四舍五入相当于白嫖……</p><p>我每个月也用不了多少流量，《下行流量包》先暂时不购买，要是后续那天顶不住后再考虑购买即可。</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610052.png"></p><ul><li>根据需求选择 <code>购买时长</code>，最后支付</li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610166.png"></p><blockquote><p>注意事项：<br>记得给阿里云账户充值！！！别到时候欠费停用了</p></blockquote><p>3、基础配置</p><ul><li>创建 Bucket</li></ul><p>打开 <a href="https://oss.console.aliyun.com/bucket">OSS管理控制台Bucket页面</a>，按需创建一个Bucket。</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610062.png"></p><blockquote><p>Bucket 名称：bboy-blog（自定义）<br>地域：华北2（选择最近）<br>存储类型：标准存储<br>读写权限：公共读<br>其他：默认不改动</p></blockquote><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610598.png"></p><p>创建完成你的 <code>Bucket</code> 就在列表显示了</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150610981.png"></p><ul><li>找到你的地域节点</li></ul><p>点击你的 <code>bucket</code>，然后点击 <code>bucket</code> 下的 <code>概览</code>，在 <code>访问域名</code> 一栏找你的 <code>地域节点</code>，后面会用到</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150609099.png"></p><ul><li>找到你的 key</li></ul><p>右上角找到头像，在弹出框里选择 <code>AccessKey</code> 管理，在弹出框选择 <code>继续使用</code></p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150609401.png"></p><p>进入后，创建一个新的 <code>AccessKey</code>，在弹出框里，复制你的 <code>AccessKeyId和AccessKeySecret</code>，保存好，以便后续使用</p><h1 id="配置-picgo"><a href="#配置-picgo" class="headerlink" title="配置 picgo"></a>配置 picgo</h1><p>1、打开picgo，在图床设置里选择 <code>阿里云OSS</code>，一招以下步骤填写信息</p><blockquote><p>设定Keyld：必填，填写刚刚获得的AccessKeyID<br>设定KeySecret：必填，填写AccessKeyIDSecret<br>设定Bucket：必填 bboy-blog，填写bucket名称（这里填写的是bucket名称，不是浏览器里的域名）<br>确认存储区域：必填 oss-cn-beijing，填写你的地域节点，注意复制的格式<br>设定存储路径：选填，其实就是自定义一个文件夹的名字，以&#x2F;结尾，它会自动在你的bucket里面创建一个文件夹，并把图片上传进去<br>指定自定义域名：选填</p></blockquote><p>2、配置完成之后，<code>确定</code>，并点击 <code>设置为默认图床</code></p><p>3、PicGo设置</p><p>打开 <code>时间戳重命名</code> 和 <code>上传后自动赋值URL</code> 选项</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150608665.png"></p><p>4、至此，你已经配置成功了，可以随意用 <code>PicGo</code> 上传图片了</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：自定义Log</title>
      <link href="/BboyZJ.github.io/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89Log/"/>
      <url>/BboyZJ.github.io/2023/03/15/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89Log/</url>
      
        <content type="html"><![CDATA[<h1 id="打印文件名、方法、行数"><a href="#打印文件名、方法、行数" class="headerlink" title="打印文件名、方法、行数"></a>打印文件名、方法、行数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1.获取打印所在的文件</span><br><span class="line">let file = (#file as NSString).lastPathComponent;</span><br><span class="line">print(file);</span><br><span class="line"></span><br><span class="line">// 2.获取打印所在的方法</span><br><span class="line">let function = #function</span><br><span class="line">print(function);</span><br><span class="line"></span><br><span class="line">// 3.获取打印所在的行号</span><br><span class="line">let line = #line;</span><br><span class="line">print(line)</span><br></pre></td></tr></table></figure><h1 id="全局化"><a href="#全局化" class="headerlink" title="全局化"></a>全局化</h1><p><code>swift</code> 中的 全局函数：写在单独的一个 <code>.swift</code> 文件下即可，比如：Common.swift</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func ZNLog&lt;T&gt;(message:T, file:String = #file, funcName:String = #function, lineNum:Int = #line) &#123;</span><br><span class="line"></span><br><span class="line">     let fileName = (file as NSString).lastPathComponent;</span><br><span class="line"></span><br><span class="line">     print(&quot;[文件名:\(fileName)]:[函数名:\(funcName)]:[行数:\(lineNum)]-打印内容:\n\(message)&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置DeBug下打印，Release-下不打印"><a href="#配置DeBug下打印，Release-下不打印" class="headerlink" title="配置DeBug下打印，Release 下不打印"></a>配置DeBug下打印，Release 下不打印</h1><p>swift 没有宏定义，只能通过添加配置字段</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303150447405.png"></p><h1 id="最终写法"><a href="#最终写法" class="headerlink" title="最终写法"></a>最终写法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 自定义Log</span><br><span class="line">func MyLog&lt;T&gt;(message: T,file: String = #file, funcName: String = #function, lineNum: Int = #line) &#123;</span><br><span class="line">#if DEBUG</span><br><span class="line">    let fileName = (file as NSString).lastPathComponent</span><br><span class="line">    print(&quot;[文件名:\(fileName)]:[函数名:\(funcName)]:[行数:\(lineNum)]-打印内容:\n\(message)&quot;);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习49：Any</title>
      <link href="/BboyZJ.github.io/2023/03/14/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A049%EF%BC%9AAny/"/>
      <url>/BboyZJ.github.io/2023/03/14/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A049%EF%BC%9AAny/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Swift中，Objective-C中的 <code>id</code> 类型现在映射成了Swift中的 <code>Any</code> 类型，它可以代表任何类型的值，无论是类、枚举、结构体还是任何其他Swift类型。这种变化使得Swift中的Objective-C API更加灵活，因为Swift定义的值类型可以传递给Objective-C API并作为Swift中的类型获取，从而无需手动“框选”类型（本人理解为转换、解包）。</p><h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><p>对于Swift中哈希类的集合，例如Dictionary和Set，有一个新类型 <code>AnyHashable</code>，可以保存任何遵守Swift中 <code>Hashable</code> 协议的类型的值。。<code>Array</code> 对应 <code>Any</code> </p><h1 id="非集合类型"><a href="#非集合类型" class="headerlink" title="非集合类型"></a>非集合类型</h1><ul><li><p>属性列表，JSON和用户信息字典在Cocoa框架中很常见，Cocoa框架将这些表示为非类型化集合。</p></li><li><p>Swift可以导入 <code>Cocoa API</code> 接受 <code>Any或AnyHashable</code> 类型的集合，所以我们可以用[AnyHashable：Any]</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Swift 3</span><br><span class="line">struct State &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var abbreviation: String</span><br><span class="line">    var population: Int</span><br><span class="line"></span><br><span class="line">    // Change the dictionary type to [AnyHashable: Any] here...</span><br><span class="line">    var asPropertyList: [AnyHashable: Any] &#123;</span><br><span class="line">        var result: [AnyHashable: Any] = [:]</span><br><span class="line">        // No implicit conversions necessary, since String and Int are subtypes</span><br><span class="line">        // of Any and AnyHashable</span><br><span class="line">        result[&quot;name&quot;] = self.name</span><br><span class="line">        result[&quot;abbreviation&quot;] = self.abbreviation</span><br><span class="line">        result[&quot;population&quot;] = self.population</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let california = State(name: &quot;California&quot;,</span><br><span class="line">                       abbreviation: &quot;CA&quot;,</span><br><span class="line">                       population: 39_000_000)</span><br><span class="line">// ...and you can still use it with Cocoa API here</span><br><span class="line">Notification(name: &quot;foo&quot;, object: nil,</span><br><span class="line">             userInfo: california.asPropertyList)</span><br></pre></td></tr></table></figure><h1 id="未链接上下文的显式转换"><a href="#未链接上下文的显式转换" class="headerlink" title="未链接上下文的显式转换"></a>未链接上下文的显式转换</h1><p>在某些确定的情况下，Swift不能自动桥接C和Objective-C。 例如，一些C和Cocoa API使用id *指针作为“out”或“in-out”参数，并且由于Swift不能静态地确定指针的使用方式，因此它不能对内存中的值自动执行桥接转换 。 在这种情况下，指针仍将显示为UnsafePointer <AnyObject>。 如果您需要使用到这些不能自动桥接转换的API，您可以使用显式桥接转换，在代码中使用 <code>as Type</code> 或 <code>as AnyObject</code> 显式转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ObjC</span><br><span class="line">@interface Foo</span><br><span class="line">- (void)updateString:(NSString **)string;</span><br><span class="line">- (void)updateObject:(id *)obj;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Swift</span><br><span class="line">func interactWith(foo: Foo) -&gt; (String, Any) &#123;</span><br><span class="line">    var string = &quot;string&quot; as NSString // explicit conversion</span><br><span class="line">    foo.updateString(&amp;string) // parameter imports as UnsafeMutablePointer&lt;NSString&gt;</span><br><span class="line">    let finishedString = string as String</span><br><span class="line"></span><br><span class="line">    var object = &quot;string&quot; as AnyObject</span><br><span class="line">    foo.updateObject(&amp;object) // parameter imports as UnsafeMutablePointer&lt;AnyObject&gt;</span><br><span class="line">    let finishedObject = object as Any</span><br><span class="line"></span><br><span class="line">    return (finishedString, finishedObject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，Objective-C中的协议在Swift中仍然是类约束（及只有类才可以遵守协议），所以你不能让Swift中的结构体或枚举直接遵守Objective-C中的协议或者是使用轻量级的泛型类。 当您需要使用到这些协议和API时应该像这样 <code>String as NSString</code>、<code>Array as NSArray</code> 进行显式转换。</p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习48：ARC</title>
      <link href="/BboyZJ.github.io/2023/03/13/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A048%EF%BC%9AARC/"/>
      <url>/BboyZJ.github.io/2023/03/13/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A048%EF%BC%9AARC/</url>
      
        <content type="html"><![CDATA[<h1 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h1><ul><li><p>swift 使用 <code>自动引用计数（ARC）</code> 来跟踪并管理应用使用的 <code>内存</code>。</p></li><li><p><code>引用计数</code> 只应用在 <code>类</code> 的实例。</p></li><li><p><code>结构体和枚举</code> 都是 <code>值类型</code>，并非引用类型，不是以引用的方式来 <code>存储和传递</code> 的</p></li></ul><h1 id="ARC-如何工作"><a href="#ARC-如何工作" class="headerlink" title="ARC 如何工作"></a>ARC 如何工作</h1><ul><li><p>每次创建一个类的实例，<code>ARC</code> 就会分配一个内存块，用来存储这个实例的相关信息。这个内存块保存着实例的类型，以及这个实例相关的属性的值</p></li><li><p>当实例不再被使用时，ARC 是否这个实例使用的内存，使这块内存可做它用。保证了实例不再被使用时，不会占用内存空间</p></li><li><p>但是，如果 <code>ARC</code> 释放了仍在使用的实例，那么你就不能再访问这个实例的苏醒或者调用它的方法。如果你仍然视图访问这个实例，应用极有可能会崩溃</p></li><li><p>为了保证不会发生上述的情况， <code>ARC</code> 跟踪类实例的相关属性、常量及变量的数量。只要有一个有效的引用，<code>ARC</code> 都不会释放这个实例</p></li><li><p>为了让这个变成现实，只要你将一个类的实例赋值给一个属性或常量或变量，这个属性、常量、变量就是这个实例的 <code>强引用（strong reference）</code>。之所以称之为 <code>强引用</code>，是因为它持有这实例，并且只要这个强引用还存在，就不能销毁实例</p></li></ul><h1 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h1><ul><li><p>在两个类实例彼此保持对方的强应用，使得每个实例都使对方保持有效时会发生这种情况。我们称之为强引用环</p></li><li><p>通过用 <code>弱引用或者无主引用</code> 来 <code>取代强引用</code>，我们可以 <code>解决强引用环问题</code></p></li></ul><h1 id="解决循环引用"><a href="#解决循环引用" class="headerlink" title="解决循环引用"></a>解决循环引用</h1><ul><li><p><code>弱引用和无主引用</code> 允许引用环中的一个实例引用另外一个实例，但 <code>不是强引用</code>。因此实例可以互相引用但是不会产生强引用</p><ul><li><p><code>弱引用不会增加实例的引用计数</code>，因此不会阻止ARC销毁被引用的实例。这种特性使得引用不会编程强引用环。声明属性或者变量的时候，关键字 <code>weak</code> 表明引用为弱引用。</p></li><li><p><code>弱引用只能声明为变量类型</code>，因为运行时它的值可能会变。弱引用绝对不能声明为常量</p></li><li><p>因为弱引用可以没有值，所以声明弱引用的时候 <code>必须是可选类型</code> 的。在swift语言中，推荐使用可选类型作为可能没有值的引用类型</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person: Person?</span><br><span class="line"></span><br><span class="line">weak var student: Student?    </span><br></pre></td></tr></table></figure><ul><li><p>对于生命周期中引用会变nil的实例，使用弱引用；对于初始化时赋值之后引用再也不会赋值为nil的实例，使用无主引用</p><ul><li><p>和弱引用相似，<code>无主引用</code> 也不强持有实例。但是和弱引用不同的是，<code>无主引用默认始终有值</code>。因此，无主引用只能定义为非可选类型。在属性、变量前添加 <code>unowned</code> 关键字，可以声明一个无主引用</p></li><li><p>因为是 <code>可选类型</code>，因此当使用无主引用时，不需要展开，可直接访问。不过非可选类型变量不能赋值为 <code>nil</code>，因此当实例被销毁的时候，ARC无法将引用赋值为 <code>nil</code></p></li><li><p>当实例被销毁后，试图访问该实例的无主引用会触发运行时错误。使用无主引用时请确保引用始终指向一个未销毁的实例</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class City &#123;</span><br><span class="line">    // 无主引用</span><br><span class="line">    unowned let country: Country</span><br><span class="line">    init(country: Country) &#123;</span><br><span class="line">        self.country = country</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Country &#123;</span><br><span class="line">    var capitaCity: City!</span><br><span class="line">    init(capitaCity: City) &#123;</span><br><span class="line">        self.capitaCity = capitaCity</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="闭包引用循环"><a href="#闭包引用循环" class="headerlink" title="闭包引用循环"></a>闭包引用循环</h1><p>将一个闭包赋值给类实例的某个属性，并且这个闭包使用了实例，这样也会产生强引用环。这个闭包可能反问了实例的某个属性，如果 <code>self.someProperty</code>，或者调用了实例的某个方法 <code>self.someMethod</code>。这两种情况都导致了闭包使用 <code>self</code>，从而产生了循环引用</p><p>解决：</p><ul><li><p>定义占有列表-占有列表中的每个元素都是由 <code>weak</code> 或者 <code>unowend</code> 关键字和实例的引用（如 <code>self</code> 或 <code>someInstance</code>）组成。每一对都在括号中，通过逗号分开</p></li><li><p>当闭包和占有的实例总是互相引用时并且总是同时销毁时，将闭包内的占有定义为无主引用</p></li><li><p>相反的，当占有引用有时可能会是 <code>nil</code> 时，将闭包内的占有定义为 弱引用</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lazy var someClosure = &#123;</span><br><span class="line">    [unowned self, weak delete = self.delete]</span><br><span class="line">    (index: Int,stringToProcess: String) -&gt; String in</span><br><span class="line">    </span><br><span class="line">    // closure body goes here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习47:多线程</title>
      <link href="/BboyZJ.github.io/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A047%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/BboyZJ.github.io/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A047%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为什么几乎所有的GUI框架都是单线程的？：处理问题代价大于收益</p><h1 id="多线程可以做什么"><a href="#多线程可以做什么" class="headerlink" title="多线程可以做什么"></a>多线程可以做什么</h1><ul><li>网络请求</li><li>IO：读写文件</li><li>计算</li><li>数据模型转换</li><li>….</li></ul><h1 id="多线程编程的方式"><a href="#多线程编程的方式" class="headerlink" title="多线程编程的方式"></a>多线程编程的方式</h1><ul><li>Thread</li><li>Operation 和 OperationQueue</li><li>GCD</li></ul><h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><ul><li>三种中最轻量级的，自己管理线程的生命周期和线程同步</li><li>线程同步对数据加锁有一定的系统开销</li></ul><p>1、快捷方式创建</p><ul><li>detachNewThread(_ block: @escaping @Sendable () -&gt; Void)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">// 不希望程代码在主线完成后退出，因为很多线程需要异步操作</span><br><span class="line">PlaygroundPage.current.needsIndefiniteExecution = true</span><br><span class="line"></span><br><span class="line">for i in 0...10 &#123;</span><br><span class="line">    Thread.detachNewThread &#123;</span><br><span class="line">        print(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>detachNewThreadSelector(_ selector: Selector, toTarget target: Any, with argument: Any?)</li></ul><p>2、初始化器</p><ul><li>Thread(target:  selector: , object: )</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">// 不希望程代码在主线完成后退出，因为很多线程需要异步操作</span><br><span class="line">PlaygroundPage.current.needsIndefiniteExecution = true</span><br><span class="line"></span><br><span class="line">class ObjectThread &#123;</span><br><span class="line">    func threadTest() &#123;</span><br><span class="line">        let thread = Thread(target: self, selector: #selector(threadMethod), object: nil)</span><br><span class="line">        // 手动开启</span><br><span class="line">        thread.start()</span><br><span class="line">    &#125;</span><br><span class="line">    @objc func threadMethod() &#123;</span><br><span class="line">        print(&quot;threadMethod&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 实例</span><br><span class="line">let obj = ObjectThread()</span><br><span class="line">obj.threadTest()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Operation-和-OperationQueue-概述"><a href="#Operation-和-OperationQueue-概述" class="headerlink" title="Operation 和 OperationQueue 概述"></a>Operation 和 OperationQueue 概述</h1><ul><li>面向对象</li><li>Operation + OperationQueue</li><li>取消、依赖、任务优先级、复杂逻辑、保存业务状态、子类化</li></ul><h1 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h1><ul><li>Operation：抽象类，任务</li><li>BlockOperation</li></ul><p>1、状态：</p><ul><li>isReady：准备好了，可以执行了</li><li>isExecuting：执行中</li><li>isFinished：执行完成</li><li>isCancelled：取消执行</li></ul><p>2、同步、异步</p><ul><li>sync</li><li>async</li></ul><p>3、添加依赖</p><h1 id="OperationQueue"><a href="#OperationQueue" class="headerlink" title="OperationQueue"></a>OperationQueue</h1><ul><li><code>OperationQueue</code> 队列，可以加入很多 <code>Operation</code>，</li><li>底层使用 <code>GCD</code></li><li><code>maxConcurrentOperationCount</code>：可以设置最大并发数</li><li><code>defaultMaxConcurrentOperationCount</code>：根据当前系统条件动态确定的最大并发数，建议使用这个</li><li>可以取消所有的 <code>Operation</code>，但是当前正在执行的不会取消</li><li>所有 <code>Operation</code> 执行完毕后退出销毁</li></ul><h1 id="BlockOperation"><a href="#BlockOperation" class="headerlink" title="BlockOperation"></a>BlockOperation</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ObjectOperation &#123;</span><br><span class="line">    func test() &#123;</span><br><span class="line">        let operation = BlockOperation&#123; [weak self] in</span><br><span class="line">            self?.threadMethod()</span><br><span class="line">        &#125;</span><br><span class="line">        let queue = OperationQueue()</span><br><span class="line">        queue.addOperation(operation)</span><br><span class="line">    &#125;</span><br><span class="line">    @objc func threadMethod() &#123;</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;threadMethod&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let op = ObjectOperation()</span><br><span class="line">op.test()</span><br><span class="line">print(&quot;after invoke test&quot;)</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">after invoke test</span><br><span class="line">threadMethod</span><br></pre></td></tr></table></figure><p>由打印结果可知，异步执行了</p><h1 id="继承-Operation"><a href="#继承-Operation" class="headerlink" title="继承 Operation"></a>继承 Operation</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class ObjectOperation &#123;</span><br><span class="line">    func test() &#123;</span><br><span class="line">        let operation = MyOpetation()</span><br><span class="line">        let queue = OperationQueue()</span><br><span class="line">        queue.addOperation(operation)</span><br><span class="line">    &#125;</span><br><span class="line">    @objc func threadMethod() &#123;</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;threadMethod&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyOpetation: Operation &#123;</span><br><span class="line">    override func main() &#123;</span><br><span class="line">        sleep(1)</span><br><span class="line">        print(&quot;myOperation main&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let op = ObjectOperation()</span><br><span class="line">op.test()</span><br><span class="line">print(&quot;after invoke test&quot;)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">after invoke test</span><br><span class="line">myOperation main</span><br></pre></td></tr></table></figure><h1 id="Operation-完成的回调"><a href="#Operation-完成的回调" class="headerlink" title="Operation 完成的回调"></a>Operation 完成的回调</h1><ul><li>completionBlock</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">operation.completionBlock = &#123; () -&gt; Void in</span><br><span class="line">    print(&quot;completionBlock&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">after invoke test</span><br><span class="line">myOperation main</span><br><span class="line">completionBlock</span><br></pre></td></tr></table></figure><h1 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h1><ul><li>任务 + 队列</li><li>易用</li><li>效率</li><li>性能</li></ul><h1 id="GCD功能"><a href="#GCD功能" class="headerlink" title="GCD功能"></a>GCD功能</h1><ul><li>创建管理Queue</li><li>提交Job</li><li>Dispatch Group</li><li>管理Dispatch Object</li><li>信号量Semaphore</li><li>队里屏障Barrier</li><li>Dispatch Source</li><li>Queue Context数据</li><li>Dispatch I&#x2F;O Channel</li><li>Dispatch Data 对象</li></ul><h1 id="GCD队列"><a href="#GCD队列" class="headerlink" title="GCD队列"></a>GCD队列</h1><ul><li>主队列：任务在主线程执行</li><li>并行队列：任务会以先进先出的顺序入列和出列，但是因为多个任务可以并行执行，所以顺序是不一定的</li><li>串行队列：任务会以先进先出的顺序入列和出列，但是同一时刻只会执行一个任务</li></ul><h1 id="GCD-队列API"><a href="#GCD-队列API" class="headerlink" title="GCD-队列API"></a>GCD-队列API</h1><ul><li>Dispatch.main</li><li>Dispatch.global</li><li>DispatchQueue</li><li>queue.label</li><li>setTarget</li></ul><h1 id="GCD-基本操作"><a href="#GCD-基本操作" class="headerlink" title="GCD 基本操作"></a>GCD 基本操作</h1><ul><li>sync</li></ul><p>提交任务到当前队列里，并且直接任务执行完成，当前队列才会返回</p><ul><li>async</li></ul><p>调用一个任务去立即执行，但是不用等任务执行完当前队列就会返回</p><ul><li>asyncAfter</li></ul><p>调度一个任务多久之后去执行，但是不用等任务执行完当前队列就会返回</p><h1 id="GCD-串行-amp-并行"><a href="#GCD-串行-amp-并行" class="headerlink" title="GCD 串行 &amp; 并行"></a>GCD 串行 &amp; 并行</h1><ul><li>串行和并行描述的是任务之间如何运行</li><li>串行任务每一个仅执行一个</li><li>并行任务可以多个同时执行</li></ul><h1 id="GCD-同步-amp-异步"><a href="#GCD-同步-amp-异步" class="headerlink" title="GCD 同步 &amp; 异步"></a>GCD 同步 &amp; 异步</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303131515216.png"> </p><h1 id="GCD-使用"><a href="#GCD-使用" class="headerlink" title="GCD 使用"></a>GCD 使用</h1><ul><li>同步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let queue = DispatchQueue(label: &quot;myQueue&quot;,qos: DispatchQoS.default,attributes: DispatchQueue.Attributes.concurrent,autoreleaseFrequency: DispatchQueue.AutoreleaseFrequency.inherit,target: nil)</span><br><span class="line">queue.sync &#123; // 同步</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;in queue sync&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;after invoke queue method&quot;)</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">in queue sync</span><br><span class="line">after invoke queue method</span><br></pre></td></tr></table></figure><ul><li>异步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">queue.async &#123; // 异步</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;in queue async&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;after invoke queue method&quot;)</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">after invoke queue method</span><br><span class="line">in queue async</span><br></pre></td></tr></table></figure><ul><li>asyncAfter</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">queue.asyncAfter(deadline: .now() + 1) &#123;</span><br><span class="line">    print(&quot;in asyncAfter&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;after invoke queue method&quot;)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">after invoke queue method</span><br><span class="line">in asyncAfter</span><br></pre></td></tr></table></figure><h1 id="GCD-源码剖析"><a href="#GCD-源码剖析" class="headerlink" title="GCD 源码剖析"></a>GCD 源码剖析</h1><ul><li><p>dispatch_sync</p><ul><li><p>线程A在串行队里dq中执行task1的过程中，如果再向dq中投递串行任务task2，同时还要求必须阻塞当前线程，等待task2结束(sync投递task2)，那么这时候会发生死锁</p></li><li><p>因为这时候task1还没有结束，串行队列不会去执行task2，而我们又要在当前线程等待task2的结束才肯继续执行task1，即task1在等待task2，而task2也在等待task1，循环等待，形成死锁</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 串行队列</span><br><span class="line">let queue = DispatchQueue(label: &quot;label&quot;)</span><br><span class="line">queue.async &#123; // 异步</span><br><span class="line">    print(&quot;in queue async&quot;) // 串行队列执行task1</span><br><span class="line">    queue.sync &#123;</span><br><span class="line">        print(&quot;in queue sync&quot;) // 串行队列加入task2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 死锁</span><br></pre></td></tr></table></figure><h1 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h1><p>一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码</p><h1 id="竟态条件"><a href="#竟态条件" class="headerlink" title="竟态条件"></a>竟态条件</h1><ul><li>两个或多个线程读写某些数据，而最后的结果取决于线程运行的精确时序</li></ul><h1 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303131739456.png"></p><h1 id="SpinLock"><a href="#SpinLock" class="headerlink" title="SpinLock"></a>SpinLock</h1><ul><li><p>线程通过busy-wait-loop方式来获取锁，任何时刻只有一个线程能够获取锁，其他线程忙等待知道获取锁</p></li><li><p>临界区尽量简短，控制在100行代码以内，不要有限时或隐士的系统调用，调用的函数也尽量简短</p></li><li><p>保证访问锁的线程全部都处于同一优先级</p></li></ul><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func synchronized(_ obj: Any, closure: ()-&gt;()) &#123;</span><br><span class="line">    objc_sync_enter(obj)</span><br><span class="line">    closure()</span><br><span class="line">    objc_sync_exit(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只有传同样的对象给synchronized，才能起到加锁的作用</li><li>如果传nil，无法起到加锁的作用</li><li>可以重入</li><li>synchronized不会持有传给它的对象</li></ul><h1 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h1><ul><li><p>一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面</p></li><li><p>实现一个多线程安全的Array的读和写</p></li><li><p>编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度</p></li><li><p>需要在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件</p></li></ul><h1 id="【场景一】：一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面"><a href="#【场景一】：一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面" class="headerlink" title="【场景一】：一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面"></a>【场景一】：一个页面有三个网络请求，需要在三个网络请求都返回的时候刷新页面</h1><h1 id="【场景二】：实现一个多线程安全的Array的读和写"><a href="#【场景二】：实现一个多线程安全的Array的读和写" class="headerlink" title="【场景二】：实现一个多线程安全的Array的读和写"></a>【场景二】：实现一个多线程安全的Array的读和写</h1><p>一个队列加方法方法</p><ul><li>1、首先是 <code>并行队列</code>，我们需要保持多线程并行操作</li><li>2、 <code>sync</code> 方法，<code>封装读操作</code>，读操作在调用读方法时能直接拿到返回值，而不是异步获取</li><li>3、<code>async</code> 方法使用 <code>barrier flag</code>，<code>封装写操作</code>，起到一个栅栏的作用，等待所有的 <code>barrier flag</code> 函数前操作执行完成后， <code>barrier flag</code> 函数之后的所有操作才执行</li></ul><h1 id="【场景三】：编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度"><a href="#【场景三】：编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度" class="headerlink" title="【场景三】：编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度"></a>【场景三】：编写一个多线程下载器，可以执行多个下载任务，每个任务可以保存当前下载字节数，总字节数，可以设置回调得到当前下载进度</h1><h1 id="【场景四】：需要-在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件"><a href="#【场景四】：需要-在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件" class="headerlink" title="【场景四】：需要 在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件"></a>【场景四】：需要 在主线程等待一个异步任务返回，才继续执行下面的逻辑，但是又不希望堵塞用户事件</h1><h1 id="Promise-多线程编程模式"><a href="#Promise-多线程编程模式" class="headerlink" title="Promise 多线程编程模式"></a>Promise 多线程编程模式</h1><ul><li><p>所谓的 <code>Promise</code>，就是一个对象，<code>用来传递异步操作的消息</code>。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 <code>API</code>，可供进一步处理</p></li><li><p>对象的状态不受外界影响。<code>Promise</code> 对象代表一个异步操作，有三种状态：<code>Pending</code>（进行中）、<code>Resolved</code>（已完成）、<code>Rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 <code>Promise</code> 这个名字的由来，它的英文意思就是 <code>承诺</code>，表示其他手段无法改变</p></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code> 对象的状态改变，只有两种可能：从 <code>Pending</code> 变为 <code>Resolved</code> 变为 <code>Rejected</code>，只要这两种情况发送，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发送了，你再对 <code>Resolved</code> 对象添加回调函数，也会立即得到这个结果。这与事件 Event 完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的</p></li></ul><h1 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h1><ul><li><p>将一个任务分解为若干个阶段（State），前阶段的输出作为下阶段的输入，各个阶段由不同的工作者线程负责执行</p></li><li><p>各个任务的各个阶段是并行（Parallel）处理的</p></li><li><p>具体任务的处理是串行的，即完成一个任务要一次执行各个阶段，但从整体任务上看，不同任务的各个阶段的执行时并行的</p></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303131740513.png"></p><h1 id="Master-x2F-Slave"><a href="#Master-x2F-Slave" class="headerlink" title="Master&#x2F;Slave"></a>Master&#x2F;Slave</h1><p>将一个任务分解为若干个语义等同的子任务，并由专门的工作者线程来并行执行这些子任务，既提高计算效率，又实现了信息隐藏</p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习50：多态和类型转换</title>
      <link href="/BboyZJ.github.io/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A050%EF%BC%9A%E5%A4%9A%E6%80%81%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/BboyZJ.github.io/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A050%EF%BC%9A%E5%A4%9A%E6%80%81%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="向下类型转换"><a href="#向下类型转换" class="headerlink" title="向下类型转换"></a>向下类型转换</h1><ul><li><p>类型的常量或变量实际上是子类的实例，你可以用 <code>as?</code> 或 <code>as!</code> 向下类型转换至子类类型</p></li><li><p>向下类型转换可能失败，<code>as？</code> 返回的值是 <code>可选类型</code>，<code>as！</code> 返回的是 <code>强制类型</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 基类</span><br><span class="line">class MediaItem &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子类</span><br><span class="line">class Movie: MediaItem &#123;</span><br><span class="line">    var director: String</span><br><span class="line">    init(name: String, director: String) &#123;</span><br><span class="line">        // 安全检查</span><br><span class="line">        self.director = director</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子类</span><br><span class="line">class Song: MediaItem &#123;</span><br><span class="line">    var artist: String</span><br><span class="line">    init(name: String,artist: String) &#123;</span><br><span class="line">        self.artist = artist</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [Movie(name: &quot;1&quot;, director: &quot;2&quot;),</span><br><span class="line">           Song(name: &quot;3&quot;, artist: &quot;4&quot;),</span><br><span class="line">           Movie(name: &quot;5&quot;, director: &quot;6&quot;)]</span><br><span class="line">print(type(of: arr))</span><br><span class="line">for item in arr &#123;</span><br><span class="line">    // 向下类型转换</span><br><span class="line">    if let realItem = item as? Movie &#123;</span><br><span class="line">        print(realItem.director)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Any-和-AnyObject"><a href="#Any-和-AnyObject" class="headerlink" title="Any 和 AnyObject"></a>Any 和 AnyObject</h1><p>swift 为不确定的类型提供了两种特殊的类型别名：</p><ul><li><p>AnyObject：表示任何类类型</p></li><li><p>Any：表示任何类型，包括函数类型</p></li></ul><h1 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h1><ul><li><p>swift 中 <code>类、结构体、枚举</code> 可以进行嵌套</p></li><li><p>嵌套类型能够访问它外部的成员</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习42：初始化器</title>
      <link href="/BboyZJ.github.io/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A042%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8/"/>
      <url>/BboyZJ.github.io/2023/03/12/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A042%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p><code>类、枚举、结构体</code> 可以引入 <code>初始化器</code>。初始化器使用 <code>关键字init来声明</code></p></li><li><p><code>结构体、枚举、类</code> 可以有任意数量的初始化器，但是 <code>类</code> 的初始化器不同 <code>于结构体和枚举</code>，<code>类有两种初始化器，即指定初始化器和便捷初始化器。</code></p></li></ul><h1 id="存储属性的初始赋值"><a href="#存储属性的初始赋值" class="headerlink" title="存储属性的初始赋值"></a>存储属性的初始赋值</h1><ul><li><p><code>类</code> 的 <code>存储属性需要有默认值</code>，而 <code>结构体、枚举不需要</code></p></li><li><p>类设置默认值方式也有两种：一种是 <code>定义存储属性时设置默认值（Optional）</code>，另一种是通过 <code>初始化器为存储属性设置默认值</code> </p></li><li><p>类的初始化器有两种，一种 <code>指定初始化器</code>，另一种 <code>便捷初始化器</code></p></li><li><p>指定初始化器又分为两种：一种 <code>初始化器</code> 不带参数，另一种 <code>自定义初始化器</code> 带参数</p></li></ul><h1 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h1><blockquote><p><code>可选类型</code> 的存储属性，不需要设置默认值，因为它本身 <code>可能有值</code> 或 <code>可能没有值</code>，编译器会自动设置默认的初始化器</p></blockquote><ul><li>直接设置默认值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    // 1、声明一个 Optional 默认值</span><br><span class="line">    var name: String?</span><br><span class="line">    // 2、直接设置默认值</span><br><span class="line">    var name: String = &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以通过 <code>闭包</code> 设置默认值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var name: String &#123;</span><br><span class="line">        // 在这个闭包中给 name 创建一个默认值</span><br><span class="line">        return &quot;ZJ&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指定初始化器为存储属性设置默认值"><a href="#指定初始化器为存储属性设置默认值" class="headerlink" title="指定初始化器为存储属性设置默认值"></a>指定初始化器为存储属性设置默认值</h1><blockquote><p> 初始化器创建实例时被调用，最简答的形式是不带任何参数的实例方法，已关键字 <code>init</code> 命名，即 <code>指定初始化器</code></p></blockquote><ul><li>可选类型的存储属性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clas Person &#123;</span><br><span class="line">    var name: String？</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义初始化器设置默认值，带参数</li></ul><p>可以通过 <code>输入参数</code> 来自定义初始化器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    // 0.不带参数</span><br><span class="line">    init() &#123;</span><br><span class="line">        self.name = &quot;ZJ&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    // 1.实际参数和形式参数相同</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.实际参数 和 形式参数 不同</span><br><span class="line">    init(to name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.通配符实际参数</span><br><span class="line">    init(_ name: String) &#123;</span><br><span class="line">        self.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = Person(name: &quot;ZJ&quot;)</span><br><span class="line">let p1 = Person(to: &quot;ZJ&quot;)</span><br><span class="line">let p2 = Person(&quot;ZJ&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>注：指定初始化器分为两种：一种是不带参数，一种是带参数<br>初始化器可以有任意数量</p></blockquote><h1 id="类的继承和构造"><a href="#类的继承和构造" class="headerlink" title="类的继承和构造"></a>类的继承和构造</h1><p>类中的所有存储属性-&gt;包括继承父类的所有存储属性：都必须在构造过程中 <code>设置默认值</code></p><p>1、<code>swift</code> 中为类提供了两种初始化器：<code>指定初始化器</code> 和 <code>便捷初始化器</code></p><ul><li>指定初始化器</li></ul><p>类中主要的初始化器，设置类中所有属性默认值，并往上调用父类的初始化器设置所有属性的默认值</p><ul><li>便捷初始化器</li></ul><p>类中次要的、辅助型的初始化器，可以调用类中的指定初始化器，并提供默认值</p><p>2、指定初始化器和便捷初始化器语法</p><ul><li>指定初始化器和简单初始化器一样</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>便捷初始化器，需要在 <code>init</code> 前放置 <code>convenience</code> 关键字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    // 未设置默认值的存储属性</span><br><span class="line">    var name: String</span><br><span class="line">    // 指定初始化器 用来给存储属性设置默认值</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    // 便捷初始化器</span><br><span class="line">    convenience init() &#123;</span><br><span class="line">        // 横向代理：必须调用一个指定的初始化器</span><br><span class="line">        self.init(name: &quot;ZJ&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = Person()</span><br><span class="line">print(p.name)</span><br></pre></td></tr></table></figure><blockquote><p>类的初始化器代理规则<br>1、指定初始化器必须调用其直接父类的指定初始化器<br>2、便捷初始化器必须调从同类调用一个指定初始化器<br>3、便捷初始化器最终必须调用一个指定初始化器</p><p>更方便的记忆方法<br>1、指定初始化器必须总是向上代理<br>2、便捷初始化器必须是横向代理</p></blockquote><p>3、初始化器继承和重写</p><ul><li>子类默认是 <code>不继承</code> 父类的初始化器，实际上是通过 <code>重写</code> 父类的初始化器，切需要带上 <code>override</code> 关键字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 继承和重写</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name:String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student: Person &#123;</span><br><span class="line">    // 重写父类的初始化器</span><br><span class="line">    override init(name: String) &#123;</span><br><span class="line">        var newName = &quot;my name is \(name)&quot;</span><br><span class="line">        super .init(name: newName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let s = Student(name: &quot;ZJ&quot;)</span><br><span class="line">print(s.name)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">my name is ZJ</span><br></pre></td></tr></table></figure><ul><li>初始化器的自动继承</li></ul><blockquote><p>1、如果子类没有定义任何初始化器，它将自动继承父类的所有指定初始化器<br>2、如果子类实现了继承自父类的指定初始化器，那么它将自动继承父类的便捷初始化器</p></blockquote><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name:String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    convenience init() &#123;</span><br><span class="line">        self.init(name: &quot;ZJ&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = Person()</span><br><span class="line">print(p.name)</span><br><span class="line">// 打印结果 ZJ</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">class Student: Person &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">    // 本类的指定初始化器</span><br><span class="line">    init(name: String,age: Int) &#123;</span><br><span class="line">        self.age = age</span><br><span class="line">        // 实现父类的指定初始化器</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    convenience override init(name: String) &#123;</span><br><span class="line">        self.init(name: name, age: 32)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let s = Student()</span><br><span class="line">let s1 = Student(name: &quot;ZJ&quot;)</span><br><span class="line">let s2 = Student(name: &quot;ZJ&quot;, age: 32)</span><br><span class="line">print(s.age)</span><br><span class="line">// 打印结果 32</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="安全检查"><a href="#安全检查" class="headerlink" title="安全检查"></a>安全检查</h1><ul><li>子类指定初始化器向上委托父类初始化器前，子类的所有属性都要完成初始化</li><li>之类指定初始化器必须先向上委托父类初始化器，才能修改父类的所有属性</li><li>便捷初始化器必须先委托同类初始化器，才能为任意属性赋值</li><li>方法的调用在所有指定初始化器之后。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 安全检查</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">    // 指定初始化器</span><br><span class="line">    init(name: String, age: Int) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    convenience init()&#123;</span><br><span class="line">        self.init(name: &quot;[Unnamed]&quot;, age: 0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Teacher: Person &#123;</span><br><span class="line">    // 工资</span><br><span class="line">    var salary: Int</span><br><span class="line">    // 自己的指定初始化器</span><br><span class="line">    init(name: String, age: Int, salary: Int) &#123;</span><br><span class="line">        // 1.先赋值自己的所有属性</span><br><span class="line">        self.salary = salary</span><br><span class="line">        // 2.调用父类的指定初始化器</span><br><span class="line">        super.init(name: name, age: age)</span><br><span class="line">        // 3.修改父类的所有属性</span><br><span class="line">        self.name = name + &quot;老师&quot;</span><br><span class="line">        // 6.调用方法</span><br><span class="line">        test()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func test() &#123;</span><br><span class="line">        print(&quot;test&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    convenience init(salary: Int) &#123;</span><br><span class="line">        // 4.必须调用本类的指定初始化器</span><br><span class="line">        self.init(name: &quot;ZJ&quot;, age: 32, salary: salary)</span><br><span class="line">        // 5.调用本类的指定初始化器后，才能赋值本类的所有属性</span><br><span class="line">        self.salary = self.salary + 1000</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="失败初始化器"><a href="#失败初始化器" class="headerlink" title="失败初始化器"></a>失败初始化器</h1><p>如果在构造过程有可能失败，则需要定义一个可失败的初始化器，在 <code>init</code> 关键字 <code>后面</code> 添加 <code>?</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">    init?(age: Int) &#123;</span><br><span class="line">        if age &gt; 200 &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = Person(age: 300)</span><br><span class="line">print(p)</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">nil</span><br></pre></td></tr></table></figure><h1 id="反初始化器"><a href="#反初始化器" class="headerlink" title="反初始化器"></a>反初始化器</h1><ul><li><p>类实例 <code>被释放时</code>，反初始化器立即被调用。用 <code>deinit</code> 关键字写反初始化器。</p></li><li><p>反初始化器在 <code>实例释放前自动被调用</code>。不能自己调用。可以被子类继承。先子类 -&gt; 父类</p></li><li><p>每个类只能有一个</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line">    // perform the deinitialization</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="必要初始化器"><a href="#必要初始化器" class="headerlink" title="必要初始化器"></a>必要初始化器</h1><ul><li>在类的初始化器前加 <code>required</code> 修饰符表明所有该子类必须实现该初始化器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 必要初始化器</span><br><span class="line">class SomeClass &#123;</span><br><span class="line">    required init()&#123;</span><br><span class="line">        // 初始化器的实现代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子类重写父类的必要初始化器时，子类的初始化器前也添加 <code>required</code> 关键字，表明可继承</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 必要初始化器</span><br><span class="line">class SomeSubClass: SomeClass &#123;</span><br><span class="line">    required init()&#123;</span><br><span class="line">        // 初始化器的实现代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习41：泛型</title>
      <link href="/BboyZJ.github.io/2023/03/11/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A041%EF%BC%9A%E6%B3%9B%E5%9E%8B/"/>
      <url>/BboyZJ.github.io/2023/03/11/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A041%EF%BC%9A%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul><li><p>泛型代码能根据所定义的要求写出可以用于任何类型的灵活的、可复用的函数。可以编写出可复用、意图表达清晰、抽象的代码。</p></li><li><p><code>泛型 </code>是Swift最强大的特性之一，<code>很多Swift标准库</code> 是基于 <code>泛型</code> 代码构建的。如，Swift 的 <code>Array和Dictionary类型都是泛型集合</code>；你也可以创建一个容纳 <code>Int</code> 值的数组，或者容纳 <code>String</code> 值的数组，甚至容纳任何 <code>Swift</code> 可以创建的其他类型的数组。同样，可以创建一个存储任何指定类型值的字典，而且类型没有限制。</p></li><li><p>泛型所解决的问题：<code>代码的复用性和抽象能力</code>。比如，交换两个值，这里的值可以是Int、Double、String。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//经典例子swap，使用泛型，可以满足不同类型参数的调用</span><br><span class="line">func swap&lt;T&gt;(_ a: inout T, _ b: inout T)&#123;</span><br><span class="line">    let tmp = a</span><br><span class="line">    a = b</span><br><span class="line">    b = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><p>主要讲3点：<code>类型约束、关联类型、Where语句</code></p><ul><li>类型约束</li></ul><p>在一个 <code>类型参数后面放置协议或者是类</code>，例如下面的例子，要求类型参数T遵循 <code>Equatable</code> 协议。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func test&lt;T:Equatable&gt;(_ a: T, _ b: T) -&gt; Bool &#123;</span><br><span class="line">    return a == b</span><br><span class="line">&#125;</span><br><span class="line">test(1, 2)</span><br><span class="line">// 打印结果 false</span><br><span class="line">test(&quot;A&quot;, &quot;a&quot;)</span><br><span class="line">// 打印结果 false</span><br></pre></td></tr></table></figure><blockquote><p>Equatable协议：可以比较值相等的协议，即可以使用 <code>==</code> 比较</p></blockquote><ul><li>关联类型</li></ul><blockquote><p>在定义协议时，使用 <code>关联类型</code> 给 <code>协议</code> 中用到的 <code>类型</code> 起一个 <code>占位符名称</code>。关联类型 <code>只能用于协议</code>，并且是通过关键字 <code>associatedtype</code> 指定。</p></blockquote><p>下面这个示例，仿写的一个栈的结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Stack &#123;</span><br><span class="line">    var items = [Int]()</span><br><span class="line">    // 入栈</span><br><span class="line">    mutating func push(_ item: Int) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    // 出栈</span><br><span class="line">    mutating func pop() -&gt; Int?&#123;</span><br><span class="line">        if items.isEmpty &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该结构体中有个成员 <code>item</code>，是个只能存储 <code>Int</code> 类型的数组，如果想使用其他类型呢？ 可以通过协议来实现 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protocol StackProtocol &#123;</span><br><span class="line">    // 协议中使用类型的占位符</span><br><span class="line">    associatedtype Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Stack: StackProtocol&#123;</span><br><span class="line">    // 在使用时，需要指定具体的类型</span><br><span class="line">    typealias Item = Int</span><br><span class="line">    </span><br><span class="line">    var items = [Item]()</span><br><span class="line">    // 入栈</span><br><span class="line">    mutating func push(_ item: Int) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    // 出栈</span><br><span class="line">    mutating func pop() -&gt; Int?&#123;</span><br><span class="line">        if items.isEmpty &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在尝试用 <code>泛型</code> 实现上面的功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 泛型实现</span><br><span class="line">struct Stack&lt;T&gt; &#123;</span><br><span class="line">    var items = [T]()</span><br><span class="line">    // 入栈</span><br><span class="line">    mutating func push(_ item: T) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    // 出栈</span><br><span class="line">    mutating func pop() -&gt; T?&#123;</span><br><span class="line">        if items.isEmpty &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型的优势和强大，暴露无疑</p><ul><li>where</li></ul><p><code>where语句</code> 主要用于 <code>表明泛型需要满足的条件</code>，即 <code>限制形式参数的要求</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// where</span><br><span class="line">protocol StackProtocol &#123;</span><br><span class="line">    // 协议中使用类型的占位符</span><br><span class="line">    associatedtype Item</span><br><span class="line">    // 实例属性</span><br><span class="line">    var itemCount: Int &#123; get &#125;</span><br><span class="line">    // 出栈</span><br><span class="line">    mutating func pop() -&gt; Item?</span><br><span class="line">    // 下标获取</span><br><span class="line">    func index(of index: Int) -&gt; Item</span><br><span class="line">&#125;</span><br><span class="line">struct Stack: StackProtocol &#123;</span><br><span class="line">    // 在使用时，需要指定具体的类型</span><br><span class="line">    typealias Item = Int</span><br><span class="line">    // 存储属性</span><br><span class="line">    var items = [Item]()</span><br><span class="line">    // 计算属性</span><br><span class="line">    var itemCount: Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return items.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 入栈</span><br><span class="line">    mutating func push(_ item: Item)&#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    // 出栈</span><br><span class="line">    mutating func pop() -&gt; Item?&#123;</span><br><span class="line">        if items.isEmpty &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    // 下标获取</span><br><span class="line">    func index(of index: Int) -&gt; Item&#123;</span><br><span class="line">        return items[index]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> whrer语句</span><br><span class="line"> T1.Item == T2.Item 表示 T1和T2中的类型必须相等</span><br><span class="line"> T1.Item: Equatable 表示 T1的类型必须遵循Equatable协议，意味着T2也要尊徐Equatable协议</span><br><span class="line"> */</span><br><span class="line">func compare&lt;T1: StackProtocol, T2: StackProtocol&gt;(_ stack1: T1,_ stack2: T2) -&gt; Bool where T1.Item == T2.Item, T1.Item: Equatable &#123;</span><br><span class="line">    // 如果数量相等，则遍历</span><br><span class="line">    guard stack1.itemCount == stack2.itemCount else &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    // 遍历</span><br><span class="line">    for i in 0..&lt;stack1.itemCount &#123;</span><br><span class="line">        if stack1.index(of: i) != stack2.index(of: i) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 扩展协议中的 Iem 遵循 Equatable</span><br><span class="line">extension StackProtocol where Item: Equatable &#123;&#125;</span><br></pre></td></tr></table></figure><p>当希望 <code>泛型指定类型</code> 拥有特定功能，可以这么写，在上述写法的基础上 <code>增加extension：</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 扩展协议中 Item 指定具体类型</span><br><span class="line">extension StackProtocol where Item == Int &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 简单的泛型函数</span><br><span class="line">func testGen&lt;T&gt;(_ value: T) -&gt; T &#123;</span><br><span class="line">    let tmp = value</span><br><span class="line">    return tmp</span><br><span class="line">&#125;</span><br><span class="line">class Teacher &#123;</span><br><span class="line">    var age: Int = 18</span><br><span class="line">    var name: String = &quot;ZJ&quot;</span><br><span class="line">&#125;</span><br><span class="line">// 传入Int类型</span><br><span class="line">testGen(10)</span><br><span class="line">// 传入元组</span><br><span class="line">testGen((1,2))</span><br><span class="line">// 传入实例对象</span><br><span class="line">testGen(Teacher())</span><br></pre></td></tr></table></figure><p>从以上代码可以看出，泛型函数 <code>可以接受任何类型</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>泛型主要用于解决代码的 <code>抽象能力</code>，以及提升代码的 <code>复用性</code></li><li>如果一个泛型 <code>遵循了某个协议</code>，则在使用时，要求具体的类型也是必须遵循某个协议的；</li><li>在定义协议时，可以使用 <code>关联类型</code> 给协议中用到的 <code>类型</code> 起一个 <code>占位符名称</code>；</li><li><code>where语句</code> 主要用于表明泛型需要满足的条件，即 <code>限制形式参数的要求</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习20：UIViewController生命周期</title>
      <link href="/BboyZJ.github.io/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A020%EF%BC%9AUIViewController%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/BboyZJ.github.io/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A020%EF%BC%9AUIViewController%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="UIViewController生命周期相关方法"><a href="#UIViewController生命周期相关方法" class="headerlink" title="UIViewController生命周期相关方法"></a>UIViewController生命周期相关方法</h1><ul><li><ul><li>(instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil;</li></ul></li></ul><p>非storyBoard(xib或非xib)都走这个方法</p><ul><li><ul><li>(instancetype)initWithCoder:(NSCoder *)aDecoder;</li></ul></li></ul><p>如果连接了串联图storyBoard 走这个方法</p><ul><li><ul><li>(void)awakeFromNib;</li></ul></li></ul><p>xib 加载 完成</p><ul><li>+(void)load</li></ul><p>load 在代码加载的时候，对象还没有被初始化的时候就已经调⽤了，可以⽤<br>来做⼀些全局的swizzle,只调⽤⼀次</p><ul><li>+(void)initialize</li></ul><p>类的初始化方法</p><ul><li>-(instancetype)init</li></ul><p>对象初始化方法</p><ul><li>-(void)loadView</li></ul><p>加载视图:当访问UIViewController的view属性时，view如果此时是nil，那么VC会自动调用loadView方法来初始化一个UIView并赋值给view属性。此方法用在初始化关键view，需要注意的是，在view初始化之前，不能先调用view的getter方法，否则将导致死循环（除非先调用了[super loadView];）如果没有重载loadView方法，则UIViewController会从nib或StoryBoard中查找默认的loadView，默认的loadView会返回一个空白的UIView对象。</p><ul><li>-(void)viewDidLoad</li></ul><p>视图加载完成</p><ul><li>-(void)viewWillAppear:(BOOL)animated</li></ul><p>将要展示:在view即将添加到视图层级中（显示给用户）且任意显示动画切换之前调用,此时self.view.superview为nil.这个方法中完成任何与试图显示相关的任务，例如改变视图方向、状态栏方向、视图显示样式等。</p><ul><li>-(void)viewWillLayoutSubviews</li></ul><p>将要布局子视图,self.view.superview为_UIParallaxDimmingView</p><ul><li>-(void)viewDidLayoutSubviews</li></ul><p>已经布局子视图</p><ul><li>-(void)viewDidAppear:(BOOL)animated</li></ul><p>已经展示:在view被添加到视图层级中，显示动画切换之后调用（这时view已经添加到supperView中）。在这个方法中执行视图显示相关附件任务，如果重载了这个方法，必须在方法中调用[supper viewDidAppear];,此时self.view.superview为UIViewControllerWrapperView。</p><ul><li>-(void)viewWillDisappear:(BOOL)animated</li></ul><p>将要消失:view即将从supperView中移除，移除动画切换之后调用，此时已调用removeFromSuperview。此时self.view.superview还是superview为UIViewControllerWrapperView.</p><ul><li>-(void)viewDidDisappear:(BOOL)animated</li></ul><p>已经消失:view从superView中移除，移除动画切换之后调用，此时已调用removeFromSuperview。此时self.view.superview还是superview为nil.</p><ul><li>-(void)dideMemoryWarning</li></ul><p>内存警告</p><ul><li>-(void)dealloc</li></ul><p>销毁释放</p><h1 id="声明周期"><a href="#声明周期" class="headerlink" title="声明周期"></a>声明周期</h1><blockquote><p>-[ViewController initWithCoder:]<br>-[ViewController awakeFromNib]<br>-[ViewController loadView]<br>-[ViewController viewDidLoad]<br>-[ViewController viewWillAppear:]<br>-[ViewController viewWillLayoutSubviews]<br>-[ViewController viewDidLayoutSubviews]<br>-[ViewController viewDidAppear:]<br>-[ViewController viewWillDisappear:]<br>-[ViewController viewDidDisappear:]<br>-[ViewController dealloc]<br>-[ViewController didReceiveMemoryWarning]</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习19：UIView的生命周期</title>
      <link href="/BboyZJ.github.io/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A019%EF%BC%9AUIView%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/BboyZJ.github.io/2023/03/10/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A019%EF%BC%9AUIView%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="UIView生命周期相关函数"><a href="#UIView生命周期相关函数" class="headerlink" title="UIView生命周期相关函数"></a>UIView生命周期相关函数</h1><ul><li><ul><li>(instancetype)initWithFrame:(CGRect)frame;</li></ul></li></ul><p>构造方法,初始化时调用,不会调用init方法</p><ul><li>-(instancetype)init</li></ul><p>构造方法,内部会调用initWithFrame方法</p><ul><li><ul><li>(instancetype)initWithCoder:(NSCoder *)aDecoder;</li></ul></li></ul><p>xib归档初始化视图后调用,如果xib中添加了子控件会在didAddSubview方法调用后调用</p><ul><li><ul><li>(void)awakeFromNib;</li></ul></li></ul><p>唤醒xib,可以布局子控件</p><ul><li>-(void)willMoveToSuperview:(UIView *)newSuperview</li></ul><p>父视图将要更改为指定的父视图,当前视图被添加到父视图时调用</p><ul><li>-(void)didMoveToSuperview</li></ul><p>父视图已更改时调用</p><ul><li>-(void)willMoveToWindow:(UIWindow *)newWindow</li></ul><p>其窗口对象将要更改时调用</p><ul><li>-(void)didMoveToWindow</li></ul><p>窗口对象已经更改时调用</p><ul><li>-(void)layoutSubviews</li></ul><p>布局子控件</p><ul><li>-(void)drawRect:(CGRect)rect</li></ul><p>绘制视图</p><ul><li>-(void)dealloc</li></ul><p>销毁</p><ul><li><ul><li>(void)didAddSubview:(UIView *)subview;</li></ul></li></ul><p>添加子控件时调用</p><ul><li><ul><li>(void)willRemoveSubview:(UIView *)subview;</li></ul></li></ul><p>将要移除子控件</p><h1 id="init方式创建视图-并添加到父视图中展示-不添加子控件-其生命周期调用顺序为"><a href="#init方式创建视图-并添加到父视图中展示-不添加子控件-其生命周期调用顺序为" class="headerlink" title="init方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为:"></a>init方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为:</h1><blockquote><p>[NoXibView initWithFrame:]<br>[NoXibView init]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView layoutSubviews]</p></blockquote><h1 id="initWithFrame方式创建视图-并添加到父视图中展示-不添加子控件-其生命周期调用顺序为"><a href="#initWithFrame方式创建视图-并添加到父视图中展示-不添加子控件-其生命周期调用顺序为" class="headerlink" title="initWithFrame方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为:"></a>initWithFrame方式创建视图,并添加到父视图中展示,不添加子控件,其生命周期调用顺序为:</h1><blockquote><p>[NoXibView initWithFrame:]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView layoutSubviews]<br>[NoXibView drawRect:]</p></blockquote><h1 id="移除销毁是调用顺序"><a href="#移除销毁是调用顺序" class="headerlink" title="移除销毁是调用顺序:"></a>移除销毁是调用顺序:</h1><blockquote><p>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView removeFromSuperview]<br>[NoXibView dealloc]</p></blockquote><h1 id="添加子控件展示时调用顺序"><a href="#添加子控件展示时调用顺序" class="headerlink" title="添加子控件展示时调用顺序:"></a>添加子控件展示时调用顺序:</h1><blockquote><p>[NoXibView initWithFrame:]<br>[NoXibView didAddSubview:]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView layoutSubviews]<br>[NoXibView drawRect:]</p></blockquote><h1 id="添加子控件移除销毁时调用顺序"><a href="#添加子控件移除销毁时调用顺序" class="headerlink" title="添加子控件移除销毁时调用顺序:"></a>添加子控件移除销毁时调用顺序:</h1><blockquote><p>[NoXibView willMoveToWindow:]<br>[NoXibView didMoveToWindow]<br>[NoXibView willMoveToSuperview:]<br>[NoXibView didMoveToSuperview]<br>[NoXibView removeFromSuperview]<br>[NoXibView dealloc]<br>[NoXibView willRemoveSubview:]</p></blockquote><h1 id="xib创建初始化视图-xib中不添加子控件时调用顺序"><a href="#xib创建初始化视图-xib中不添加子控件时调用顺序" class="headerlink" title="xib创建初始化视图, xib中不添加子控件时调用顺序:"></a>xib创建初始化视图, xib中不添加子控件时调用顺序:</h1><blockquote><p>[XibView initWithCoder:]<br>[XibView awakeFromNib]<br>[XibView willMoveToSuperview:]<br>[XibView didMoveToSuperview]<br>[XibView willMoveToWindow:]<br>[XibView didMoveToWindow]<br>[XibView layoutSubviews]<br>[XibView layoutSubviews]<br>[XibView drawRect:]</p></blockquote><h1 id="xib创建初始化视图-xib中添加子控件时调用顺序"><a href="#xib创建初始化视图-xib中添加子控件时调用顺序" class="headerlink" title="xib创建初始化视图, xib中添加子控件时调用顺序:"></a>xib创建初始化视图, xib中添加子控件时调用顺序:</h1><blockquote><p>[XibView didAddSubview:]<br>[XibView initWithCoder:]<br>[XibView awakeFromNib]<br>[XibView willMoveToSuperview:]<br>[XibView didMoveToSuperview]<br>[XibView willMoveToWindow:]<br>[XibView didMoveToWindow]<br>[XibView layoutSubviews]<br>[XibView layoutSubviews]<br>[XibView drawRect:]</p></blockquote><h1 id="移除销毁时调用顺序-有子控件"><a href="#移除销毁时调用顺序-有子控件" class="headerlink" title="移除销毁时调用顺序,有子控件:"></a>移除销毁时调用顺序,有子控件:</h1><blockquote><p>[XibView willMoveToWindow:]<br>[XibView didMoveToWindow]<br>[XibView willMoveToSuperview:]<br>[XibView didMoveToSuperview]<br>[XibView removeFromSuperview]<br>[NoXibView dealloc]<br>[NoXibView willRemoveSubview:]</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC面试题：Block</title>
      <link href="/BboyZJ.github.io/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ABlock/"/>
      <url>/BboyZJ.github.io/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ABlock/</url>
      
        <content type="html"><![CDATA[<h1 id="Block的本质"><a href="#Block的本质" class="headerlink" title="Block的本质"></a>Block的本质</h1><ul><li>block 的 <code>本质</code> 是 <code>对象、函数、结构</code>体，由于block函数没有名称，也被称为 <code>匿名函数</code></li></ul><h1 id="Block的分类？"><a href="#Block的分类？" class="headerlink" title="Block的分类？"></a>Block的分类？</h1><ul><li><p>分为 <code>全局Block(_NSConcreteGlobalBlock)、栈Block(_NSConcreteStackBlock)、堆Block(_NSConcreteMallocBlock)</code> 三种形式。</p></li><li><p>其中 <code>栈Block存储在栈(stack)区</code>，<code>堆Block存储在堆(heap)区</code>，<code>全局Block存储在已初始化数据(.data)区</code>。</p><ul><li>堆：动态分配内存，需要程序员自己申请，程序员自己管理</li><li>栈：自动分配内存，自动销毁，先入后出，栈上的内容存在自动销毁的情况</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC面试题：Runtime</title>
      <link href="/BboyZJ.github.io/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARuntime/"/>
      <url>/BboyZJ.github.io/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARuntime/</url>
      
        <content type="html"><![CDATA[<h1 id="runtime如何通过selector找到对应的IMP地址？"><a href="#runtime如何通过selector找到对应的IMP地址？" class="headerlink" title="runtime如何通过selector找到对应的IMP地址？"></a>runtime如何通过selector找到对应的IMP地址？</h1><ul><li><p>class_getMethodImplementation(Class cls, SEL name);</p></li><li><p>method_getImplementation(Method m)</p></li></ul><h1 id="Runtime-如何实现-weak-属性"><a href="#Runtime-如何实现-weak-属性" class="headerlink" title="Runtime 如何实现 weak 属性?"></a>Runtime 如何实现 weak 属性?</h1><p><code>Runtime</code> 对 <code>注册的类</code>，会进行 <code>布局</code>，会将 <code>weak</code> 对象放入一个 <code>hash</code> 表中。 用 <code>weak</code> 指向的 <code>对象内存地址</code> 作为 <code>key</code>，当此对象的引用计数为0的时候会调用对象的 <code>dealloc</code> 方法， 假设 <code>weak</code> 指向的对象内存地址是a，那么就会以a为key，在这个 <code>weak</code> hash表中搜索，找到所有以a为key的 <code>weak</code> 对象，从而设置为 <code>nil</code>。</p>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC面试题：Runloop</title>
      <link href="/BboyZJ.github.io/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARunloop/"/>
      <url>/BboyZJ.github.io/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARunloop/</url>
      
        <content type="html"><![CDATA[<h1 id="PerformSelector和runloop的关系？"><a href="#PerformSelector和runloop的关系？" class="headerlink" title="PerformSelector和runloop的关系？"></a>PerformSelector和runloop的关系？</h1><ul><li>基础用法：默认在主线程的runloop，会执行，因为此方法是发送消息，objc_msgSend</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelector:@selector(name:) withObject:@“张建&quot;];</span><br></pre></td></tr></table></figure><ul><li>performSelector 在子线程默认不执行，需要加入到 runloop 中并开启</li></ul>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC面试题：算法</title>
      <link href="/BboyZJ.github.io/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%97%E6%B3%95/"/>
      <url>/BboyZJ.github.io/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>1）依次比较相邻两个元素，顺序错误则交换位置；需要两层循环，外层循环控制趟数，内层循环控制比较次数</p><p>2）例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;5&quot;,@&quot;4&quot;]];</span><br><span class="line">    // 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">    for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序</span><br><span class="line">        for (int j = 0; j &lt; arr.count - i - 1; j++) &#123;</span><br><span class="line">            // 相邻元素比较，若逆序则交换</span><br><span class="line">            if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123;</span><br><span class="line">                [arr exchangeObjectAtIndex:j withObjectAtIndex:j + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>1）从第一个元素与其他元素比较找到最小值，重复操作，直到最后一位结束；需要两层循环，外层循环趟数，里层循环比较次数</p><p>2）例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithObjects:@&quot;2&quot;,@&quot;1&quot;,@&quot;5&quot;,@&quot;3&quot;, nil];</span><br><span class="line">// 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">    // 里循环获比较换位</span><br><span class="line">    for (int j = i + 1; j &lt; arr.count; j ++) &#123;</span><br><span class="line">        if ([arr[i] intValue] &gt; [arr[j] intValue]) &#123;</span><br><span class="line">            [arr exchangeObjectAtIndex:i withObjectAtIndex:j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;arr:%@&quot;,arr);</span><br></pre></td></tr></table></figure><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p>1） 始终定义第一个元素为 <code>已排序</code> 的，将剩余元素定义为 <code>未排序</code> 逐个插入到 <code>已排序</code> 的排列中；不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去</p><p>2）例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = @[@2,@1,@3,@5,@4].mutableCopy;</span><br><span class="line">// 插入排序的原理：始终定义第一个元素为有序的，将元素逐个插入到有序的排列中</span><br><span class="line">// 其特点是：不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去</span><br><span class="line">for(int i = 0;i &lt; arr.count;i++)&#123;</span><br><span class="line">    // 待排序值</span><br><span class="line">    NSNumber * temp = arr[i];</span><br><span class="line">    // 已排序下标</span><br><span class="line">    int j = i - 1;</span><br><span class="line">    // 待排序与已排序比较，从后向前比较</span><br><span class="line">    while (j &gt;= 0 &amp;&amp; [arr[j] integerValue] &gt; [temp integerValue]) &#123;</span><br><span class="line">        // 如果已排序的 &gt; 待排序的 往后移动一个位置</span><br><span class="line">        [arr replaceObjectAtIndex:(j + 1) withObject:arr[j]];</span><br><span class="line">        j --;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 空出来的位置插入新元素</span><br><span class="line">    [arr replaceObjectAtIndex:(j + 1) withObject:temp];</span><br><span class="line">    NSLog(@&quot;arr:%@&quot;,arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:26:19.242271+0800 插入排序[4184:77845] arr:(</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>1）希尔排序相当于 <code>直接插入排序加强版</code>，引入了 <code>增量</code> 的概念；直到增量为 <code>1</code> 时，再进行直接插入排序</p><p>2）例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = @[@7,@3,@8,@5,@2,@6,@1,@4].mutableCopy;</span><br><span class="line">// 其实间隔值设值为总数的一半</span><br><span class="line">int gap = arr.count/2;</span><br><span class="line">// 直到间隔小于1时结束</span><br><span class="line">while (gap &gt;= 1) &#123;</span><br><span class="line">    // i 待排元素，以 步距 gap 从后向前扫描</span><br><span class="line">    for(int i = 0;i &lt; arr.count;i++)&#123;</span><br><span class="line">        // 待排元素</span><br><span class="line">        NSNumber * temp = arr[i];</span><br><span class="line">        // 当前位置</span><br><span class="line">        int j = i;</span><br><span class="line">        // 跳跃式比较</span><br><span class="line">        while (j &gt;= gap &amp;&amp; [arr[j - gap] integerValue] &gt; [temp integerValue] ) &#123;</span><br><span class="line">            [arr replaceObjectAtIndex:j withObject:arr[j - gap]];</span><br><span class="line">            j -= gap;</span><br><span class="line">        &#125;</span><br><span class="line">        // 空出来位置，插入待排序</span><br><span class="line">        [arr replaceObjectAtIndex:j withObject:temp];</span><br><span class="line">    &#125;</span><br><span class="line">    // 改变步长</span><br><span class="line">    gap = gap/2;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;arr:%@&quot;,arr);</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:22:41.910840+0800 插入排序[4124:74568] arr:(</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5,</span><br><span class="line">    6,</span><br><span class="line">    7,</span><br><span class="line">    8</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>1）也就是 <code>兔子数列</code>，当前数是前两个数列之和</p><p>2）例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    NSInteger num = 10;</span><br><span class="line">    NSInteger total = [self getTotalNum:num];</span><br><span class="line">    NSLog(@&quot;total:%ld&quot;,total);</span><br><span class="line">&#125;</span><br><span class="line">- (NSInteger)getTotalNum:(NSInteger)num&#123;</span><br><span class="line">    if(num == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(num == 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return [self getTotalNum:num-2] + [self getTotalNum:num-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:28:32.672554+0800 斐波那契数列[4285:80606] total:89</span><br></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>1）<code>有序的数组</code>，将数组分割成两份，利用查找的值跟中间值进行比较，如果查找的值大于中间值，就在数组的右边进行查找；如果查找的值小于中间值，就在数组的左边进行查找。如此循环的执行下去，最终找到符合的值。</p><p>2）例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NSArray * arr = @[@(1),@(3),@(5),@(6),@(8),@(10)];</span><br><span class="line">int key = [@(5) intValue];</span><br><span class="line">int min = 0;</span><br><span class="line">int max = arr.count - 1;</span><br><span class="line">int mid;</span><br><span class="line">while (min &lt;= max) &#123;</span><br><span class="line">    // 计算中间下标</span><br><span class="line">    mid = (min + max) / 2;</span><br><span class="line">    // 如果目标值 &gt; 中间下标的中间值</span><br><span class="line">    if (key &gt; [arr[mid] intValue]) &#123;</span><br><span class="line">        //最小变为中间下标+1</span><br><span class="line">        min = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果目标值 &lt; 中间下标的中间值</span><br><span class="line">    else if (key &lt; [arr[mid] intValue])&#123;</span><br><span class="line">        //最大变为中间下标-1</span><br><span class="line">        max = max - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 否则，正好</span><br><span class="line">    else &#123;</span><br><span class="line">        NSLog(@&quot;key:%d&quot;,mid);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-12-13 10:33:18.661324+0800 二分查找[4607:86953] key:2</span><br></pre></td></tr></table></figure><h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><p>递归求和1+2+..+n?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    int sum = [self sum:4];</span><br><span class="line">    NSLog(@&quot;sum:%d&quot;,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)sum:(int)n&#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return [self sum:n-1] + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC面试题：多线程</title>
      <link href="/BboyZJ.github.io/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/BboyZJ.github.io/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="你了解线程么？谈谈你对进程和线程的理解？"><a href="#你了解线程么？谈谈你对进程和线程的理解？" class="headerlink" title="你了解线程么？谈谈你对进程和线程的理解？"></a>你了解线程么？谈谈你对进程和线程的理解？</h1><ul><li><p>进程是 <code>系统进行资源分配和调度的基本单位</code>，是操作系统结构的基础，进程是程序的实体。</p></li><li><p>线程是 <code>独立调度和分派的基本单位</code>，一条线程是进程中一个单一顺序的控制流。</p></li><li><p>同一进程中多条线程共享进程中的全部系统资源，一个进程有很多线程，一个进程可以并发多个线程。</p></li></ul><h1 id="iOS中，有哪些实现多线程的方式？"><a href="#iOS中，有哪些实现多线程的方式？" class="headerlink" title="iOS中，有哪些实现多线程的方式？"></a>iOS中，有哪些实现多线程的方式？</h1><blockquote><p>Pthread<br>   特点：C语言。跨平台，可移植，使用难度大。生命周期：自己管理。<br>NSThread<br>  特点：OC语言。面向对象，简单易用，可直接操作线程。生命周期：自己管理。<br>GCD<br>  特点：替代 NSThread，充分利用多核的技术。生命周期：系统管理。<br>NSOperaton<br>  特点：基于GCD的封装。比GCD多了一些简单实用的功能。生命周期：系统管理。</p></blockquote><h1 id="请说一下多线程中-GCD-和-NSOperation-的区别？"><a href="#请说一下多线程中-GCD-和-NSOperation-的区别？" class="headerlink" title="请说一下多线程中 GCD 和 NSOperation 的区别？"></a>请说一下多线程中 GCD 和 NSOperation 的区别？</h1><p><strong>GCD：</strong></p><ul><li><p><code>提供了一次性执行的代码 dispatch_once</code> ，也就是说保证了一段代码在程序执行的过程中只被执行一次，并且是线程安全的！，实现的单例。</p></li><li><p>提供了 <code>延迟执行</code> 的简便方法 <code>dispatch_after</code>。</p></li><li><p>提供了 <code>调度组</code> 的使用，监听一些列异步方法之行结束之后，我们得到统一的通知</p><ul><li>dispatch_group</li><li>dispatch_group_async</li><li>dispatch_group_notify</li><li>dispatch_group_enter&#x2F;dispatch_group_leave</li></ul></li><li><p>提供了 <code>快速迭代的方式dispatch_apply</code>。按照指定的次序将制定的任务追加到指定的队列中，并等待全部队列执行结束！</p></li><li><p>提供了信号量 <code>dispatch_semaphore_t</code>，使用信号量可以实现安全的多线程！（加锁的一种方式）</p><ul><li>dispatch_semaphore_wait：信号量减1，阻塞当前线程</li><li>dispatch_semaphore_signal：信号量加1，释放当前线程</li></ul></li><li><p>提供了栅栏函数 <code>dispatch_barrier_async</code>，使用栅栏函数 <code>可以实现线程的多读单写</code>！</p></li></ul><p><strong>​​​​​​NSOpearion：</strong></p><ul><li><p>NSOperatoin是对GCD更高层次的封装</p></li><li><p>NSOperation可以设置两个操作之间的依赖关系。</p></li><li><p>NSOperation是个抽象类，开发中使用它的两个子类，NSBlockOperation&#x2F;NSInvocationOperation。</p></li><li><p>使用KVO，观察NSOperation的各种状态（isExecuted是否正在执行，isFinished是否结束，isCancled是否取消）。无法判断GCD的状态。</p></li><li><p>NSOperation可以设置操作的优先级。</p></li><li><p>NSoperation可以方便的取消一个操作的执行</p></li><li><p>可以重写NSOperation的main和start函数。</p></li></ul><h1 id="dispatch-once-是怎么保证线程安全的？"><a href="#dispatch-once-是怎么保证线程安全的？" class="headerlink" title="dispatch_once 是怎么保证线程安全的？"></a>dispatch_once 是怎么保证线程安全的？</h1><p>定义一个dispatch_once_t的静态变量，标识下面的diapatch_once的block是否执行过了，static修饰会默认将 <code>onceToken其初始化为0</code>，当值为0时才会 <code>执行block代码块</code> 里面的内容，此时onceToken不为0，当block执行完成，<code>底层会将oneceToken设置为-1</code>，以后再调用的话不会再走block代码块。</p><h1 id="dispatch-after延迟执行，执行时间是准确的吗？"><a href="#dispatch-after延迟执行，执行时间是准确的吗？" class="headerlink" title="dispatch_after延迟执行，执行时间是准确的吗？"></a>dispatch_after延迟执行，执行时间是准确的吗？</h1><p>dispatch_after的延迟执行时间不是准确的，因为dispatch_after是在指定时间之后将任务添加到主队列，并不是在指定时间之后开始执行处理！</p><h1 id="说说你对-dispatch-apply-的理解？"><a href="#说说你对-dispatch-apply-的理解？" class="headerlink" title="说说你对 dispatch_apply 的理解？"></a>说说你对 dispatch_apply 的理解？</h1><ul><li><p><code>dispatch_apply</code> 是GCD提供的一种 <code>快速迭代的函数</code>，按照指定的次数将指定的任务追加到指定的队列中，并等待全部任务结束。</p></li><li><p>如果用在串行队列，就和for循环一样，按顺序同步执行。</p></li><li><p>如果用在并发队列，追加到队列的任务会异步执行，并且等待全部任务结束！</p></li></ul><h1 id="说说你对dispatch-group的理解？"><a href="#说说你对dispatch-group的理解？" class="headerlink" title="说说你对dispatch_group的理解？"></a>说说你对dispatch_group的理解？</h1><ul><li><p>GCD提供的队列组，有两种使用方式 <code>dispatch_group_async</code> 和 <code>dispatch_group_enter/dispatch_group_leave</code>，使用过程中要根据任务类型选择使用哪种方式。</p></li><li><p>如果任务类型是同步任务：使用 <code>dispatch_group_async</code> 和 <code>dispatch_group_enter/dispatch_group_leave</code> 是同样的，可以实现相同的功能。</p></li><li><p>如果任务类型是异步任务：比如（AF）网络请求，使用dispatch_group_async不能等到所有异步任务执行完成，就会去执行dispatch_group_notify中的代码，使用dispatch_group_enter&#x2F;dispatch_group_leave可以实现执行完添加的异步任务，最后执行dispatch_group_notify中的代码</p></li><li><p>如果你要实现这样一个功能，请求网络A和B,然后根据A&#x2F;B返回的内容去刷新页面，如果使用dispatch_group，那么只能使用 <code>dispatch_grouo_enter/dispatch_grouo_leave</code>！！！使用dispatch_group_async是不能实现这个功能的！</p></li></ul><h1 id="说说你项目中的哪些功能使用了dispatch-semaphore-t，解决了什么问题？"><a href="#说说你项目中的哪些功能使用了dispatch-semaphore-t，解决了什么问题？" class="headerlink" title="说说你项目中的哪些功能使用了dispatch_semaphore_t，解决了什么问题？"></a>说说你项目中的哪些功能使用了dispatch_semaphore_t，解决了什么问题？</h1><p>使用信号量 <code>dispatch_semaphore_t</code> 可以实现 <code>异步任务的顺序执行</code>（也就是 <code>将异步任务转换为同步任务执行</code>）不要阻塞主线程！。也是多线程加锁的一种实现方式，保证线程安全。</p><ul><li><p>dispatch_semaphore_create(intptr_t value) 创建一个队列组，传入得值&gt;&#x3D;0，传入的值控制控制并发线程的数量！！！，如果我们传入2，那么就表示当前最多有两个线程同时执行。</p></li><li><p>dispatch_semaphore_signal(dispatch_semaphore_t dsema) 增加信号量，使信号量的值加1！</p></li><li><p>dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout) 等待当前线程，直到某个时间释放！！！</p></li></ul><h1 id="说说你对NSOperation-x2F-NSOperationQueue的使用和理解？"><a href="#说说你对NSOperation-x2F-NSOperationQueue的使用和理解？" class="headerlink" title="说说你对NSOperation&#x2F;NSOperationQueue的使用和理解？"></a>说说你对NSOperation&#x2F;NSOperationQueue的使用和理解？</h1><ol><li><p>NSOperation&#x2F;NSOperationQueue 是系统提供的一套多线程实现方案。实际上NSOperation&#x2F;NSOperationQueue是基于GCD更高层次的封装，完全面向对象，比GCD简单易用，代码可读性更高。</p></li><li><p>使用步骤：</p></li></ol><ul><li><p>创建操作，将操作封装到NSOperation对象中,执行的顺序取决于操作之间的相对优先级，操作执行结束的顺序，取决于操作本身！</p></li><li><p>创建队列 NSOperationQueue，将操作添加到队列中，一个队列中同时能并发执行的最大操作数由maxConcurrentOperationCount 决定，也就是一个操作队列中的操作是串行还是并发执行，由maxConcurrentOperationCount它决定！</p><ul><li>maxConcurrentOperationCount &#x3D; -1，默认，并发执行</li><li>maxConcurrentOperationCount &#x3D; 1，串行执行</li><li>maxConcurrentOperationCount &#x3D; 3，并发执行</li></ul></li><li><p>系统会将队列中的操作取出，在新线程中执行操作。</p></li><li><p>操作有几种状态</p><ul><li>op1.isReady; 是否准备就绪</li><li>op1.isExecuting; 是否正在执行</li><li>op1.isCancelled; 是否已经取消</li><li>op1.isFinished; 是否执行完成</li></ul></li><li><p>取消操作和队列</p><ul><li>[op1 cancel]; 取消操作，实际上是标记isCancelled状态</li><li>[queue cancelAllOperations]; 取消队列</li></ul></li></ul><h1 id="你是否在定义过NSOperation"><a href="#你是否在定义过NSOperation" class="headerlink" title="你是否在定义过NSOperation?"></a>你是否在定义过NSOperation?</h1><p>自定义NSOperation可以通过重写main或者start方法。重写main方法，不需要管理操作的状态属性isExecuting和isFinished。重写start方法需要管理操作的状态属性。</p><h1 id="【面试题】：如果在工作中有这样一个需求，使用AFNetworking请求A接口拿到A接口返回的id-a，用id-a作为参数去请求B接口，拿到B网络返回的name-b去查数据库，然后刷新页面。该怎么实现呢？"><a href="#【面试题】：如果在工作中有这样一个需求，使用AFNetworking请求A接口拿到A接口返回的id-a，用id-a作为参数去请求B接口，拿到B网络返回的name-b去查数据库，然后刷新页面。该怎么实现呢？" class="headerlink" title="【面试题】：如果在工作中有这样一个需求，使用AFNetworking请求A接口拿到A接口返回的id_a，用id_a作为参数去请求B接口，拿到B网络返回的name_b去查数据库，然后刷新页面。该怎么实现呢？"></a>【面试题】：如果在工作中有这样一个需求，使用AFNetworking请求A接口拿到A接口返回的id_a，用id_a作为参数去请求B接口，拿到B网络返回的name_b去查数据库，然后刷新页面。该怎么实现呢？</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) dispatch_semaphore_t semaphore;</span><br><span class="line">@property (nonatomic, assign) dispatch_queue_t queue;</span><br><span class="line"> </span><br><span class="line">- (void)viewDidLoad&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //：测试</span><br><span class="line">    [self semaphoreSync];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)semaphoreSync&#123;</span><br><span class="line">    // 创建信号量，传入参数0</span><br><span class="line">    self.semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    // 创建队列，这里串行和并发并无区别</span><br><span class="line">    self.queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    // 开启一个新线程，</span><br><span class="line">    // 这里之所以要创建一个新线程，而不是在当前（主线程）执行，是因为，AF的网络请求返回默认是在主线程中执行，如果我们在当前线程执行一下操作，会发生线程死锁的现象，</span><br><span class="line">    dispatch_async(self.queue, ^&#123;</span><br><span class="line">        // 任务A</span><br><span class="line">        int ida = [self requestA];</span><br><span class="line">        // 任务B</span><br><span class="line">        NSString *name = [self requestB:ida];</span><br><span class="line">        // 任务C</span><br><span class="line">        NSDictionary *res = [self queryDB:name];</span><br><span class="line">        NSLog(@&quot;%@&quot;, res);</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            // 刷新页面</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (int)requestA&#123;</span><br><span class="line">    __block int ida = 0;</span><br><span class="line">    // AF</span><br><span class="line">    NSArray *paths = @[@(self.currentPage), @(pageNum), @(100)];</span><br><span class="line">    [[ZJNetWorkManager shareManager] GetWithUrlString:TC_API(GetCourseList) paths:paths successedBlock:^(BOOL successed, id  _Nonnull jsonObject) &#123;</span><br><span class="line">        ida = 1;</span><br><span class="line">        // 释放信号量，信号量加1，释放当前线程，然后执行return操作</span><br><span class="line">        dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">    &#125; failedBlock:^(NSError * _Nonnull error) &#123;</span><br><span class="line">        dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line">    // 信号量减1，阻塞当前线程</span><br><span class="line">    dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"> </span><br><span class="line">    return ida;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (NSString *)requestB:(int)ida&#123;</span><br><span class="line">    __block NSString *name;</span><br><span class="line">    NSArray *paths = @[@(self.currentPage), @(pageNum), @(100), @(ida)];</span><br><span class="line">    [[ZJNetWorkManager shareManager] GetWithUrlString:TC_API(GetCourseList) paths:paths successedBlock:^(BOOL successed, id  _Nonnull jsonObject) &#123;</span><br><span class="line">        name = @&quot;你好👋&quot;;</span><br><span class="line">        dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">    &#125; failedBlock:^(NSError * _Nonnull error) &#123;</span><br><span class="line">        dispatch_semaphore_signal(self.semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line">        </span><br><span class="line">    dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"> </span><br><span class="line">    return name;</span><br><span class="line">&#125; </span><br><span class="line">- (NSDictionary *)queryDB:(NSString *)name&#123;</span><br><span class="line">    //查询数据库，返回结果</span><br><span class="line">    return @&#123;@&quot;name&quot;:@&quot;name&quot;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="【面试题】多个网络请求异步完成-执行最后一个？"><a href="#【面试题】多个网络请求异步完成-执行最后一个？" class="headerlink" title="【面试题】多个网络请求异步完成-执行最后一个？"></a>【面试题】多个网络请求异步完成-执行最后一个？</h1><ul><li>dispatch_group_t + dispatch_group_enter() + dispatch_group_leave() + dispatch_group_notify</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//资源</span><br><span class="line">NSString *str = @&quot;http://www.jianshu.com/p/6930f335adba&quot;;</span><br><span class="line">NSURL *url = [NSURL URLWithString:str];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">    </span><br><span class="line">// 1.GCD线程组</span><br><span class="line">dispatch_group_t downloadGroup = dispatch_group_create();</span><br><span class="line">for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">    dispatch_group_enter(downloadGroup);</span><br><span class="line">    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;%d---%d&quot;,i,i);</span><br><span class="line">        dispatch_group_leave(downloadGroup);</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">023-03-18 00:00:29.418934+0800 线程等待[9494:456991] 1---1</span><br><span class="line">2023-03-18 00:00:29.434940+0800 线程等待[9494:456990] 7---7</span><br><span class="line">2023-03-18 00:00:29.435649+0800 线程等待[9494:456989] 8---8</span><br><span class="line">2023-03-18 00:00:29.437444+0800 线程等待[9494:456988] 5---5</span><br><span class="line">2023-03-18 00:00:29.437915+0800 线程等待[9494:456988] 9---9</span><br><span class="line">2023-03-18 00:00:29.439086+0800 线程等待[9494:456988] 2---2</span><br><span class="line">2023-03-18 00:00:29.439832+0800 线程等待[9494:456988] 3---3</span><br><span class="line">2023-03-18 00:00:29.447357+0800 线程等待[9494:457208] 4---4</span><br><span class="line">2023-03-18 00:00:29.449366+0800 线程等待[9494:457208] 0---0</span><br><span class="line">2023-03-18 00:00:29.454452+0800 线程等待[9494:456988] 6---6</span><br><span class="line">2023-03-18 00:00:29.454704+0800 线程等待[9494:456826] end</span><br></pre></td></tr></table></figure></div><h1 id="【面试题】多个网络请求同步步完成-执行最后一个？"><a href="#【面试题】多个网络请求同步步完成-执行最后一个？" class="headerlink" title="【面试题】多个网络请求同步步完成-执行最后一个？"></a>【面试题】多个网络请求同步步完成-执行最后一个？</h1><ul><li>dispatch_semphore_t + dispatch_semphore_signal(semphore) + dispatch_semphore_wait(semphore)</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> NSString *str = @&quot;http://www.jianshu.com/p/6930f335adba&quot;;</span><br><span class="line">NSURL *url = [NSURL URLWithString:str];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">    </span><br><span class="line">// 信号量 &lt; 0 阻塞</span><br><span class="line">dispatch_semaphore_t sem = dispatch_semaphore_create(0);</span><br><span class="line">for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;%d---%d&quot;,i,i);</span><br><span class="line">        // 信号量 +1</span><br><span class="line">        dispatch_semaphore_signal(sem);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [task resume];</span><br><span class="line">    // 信号量 -1</span><br><span class="line">    dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><h1 id="【面试题】请实现一个多读单写的功能？"><a href="#【面试题】请实现一个多读单写的功能？" class="headerlink" title="【面试题】请实现一个多读单写的功能？"></a>【面试题】请实现一个多读单写的功能？</h1><p>我们可以用 <code>dispatch_barrier_async</code> 实现</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@interface TKReadWhiteSafeDic() &#123;</span><br><span class="line">    // 定义一个并发队列</span><br><span class="line">    dispatch_queue_t concurrent_queue;</span><br><span class="line">    </span><br><span class="line">    // 用户数据中心, 可能多个线程需要数据访问</span><br><span class="line">    NSMutableDictionary *userCenterDic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 多读单写模型</span><br><span class="line">@implementation TKReadWhiteSafeDic</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        // 通过宏定义 DISPATCH_QUEUE_CONCURRENT 创建一个并发队列</span><br><span class="line">        concurrent_queue = dispatch_queue_create(&quot;read_write_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">        // 创建数据容器</span><br><span class="line">        userCenterDic = [NSMutableDictionary dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)objectForKey:(NSString *)key &#123;</span><br><span class="line">    __block id obj;</span><br><span class="line">    // 同步读取指定数据</span><br><span class="line">    dispatch_sync(concurrent_queue, ^&#123;</span><br><span class="line">        obj = [userCenterDic objectForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setObject:(id)obj forKey:(NSString *)key &#123;</span><br><span class="line">    // 异步栅栏调用设置数据</span><br><span class="line">    dispatch_barrier_async(concurrent_queue, ^&#123;</span><br><span class="line">        [userCenterDic setObject:obj forKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li><p>读操作为啥同步 dispatch_sync</p><blockquote><p>读的话通常都是直接想要结果，需要同步返回结果，如果是异步获取的话就根网络请求一样了。</p></blockquote></li><li><p>写操作为啥异步dispatch_barrier_async</p><blockquote><p>写操作是因为不需要等待写操作完成，所以用异步。</p></blockquote></li></ul><h1 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h1><ol><li>同步主线程死锁</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1.同步-主线程会造成死锁 ：输出结果只有1</span><br><span class="line">dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;a&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><blockquote><p>造成 <code>死锁</code></p></blockquote><ol start="2"><li>异步主线程不死锁</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 2.异步-主线程不会造成死锁：</span><br><span class="line">NSLog(@&quot;1&quot;);</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;4&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;5&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;3&quot;);</span><br></pre></td></tr></table></figure></div><blockquote><p>结论：1、3、2、4、5 或 1、2、3、4、5<br>分析：1、3在主线程先打印；异步开启 <code>子线程</code>，2 打印；同步不开启 子线程，先打印 4，在打印 5</p></blockquote><ul><li>换一种写法</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;1&quot;);</span><br><span class="line">dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;4&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;5&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;3&quot;);</span><br></pre></td></tr></table></figure></div><blockquote><p>结论：1、2、5、3、4<br>分析：1 在主线程先打印；同步不开启 <code>子线程</code>，2、5 先打印；异步开启 子线程，打印 3，在打印   4</p></blockquote><ol start="3"><li>串行队列-同步主线程-死锁</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 3.主线程死锁</span><br><span class="line">// 创建一个串行队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.demo.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">NSLog(@&quot;1&quot;); // 任务1</span><br><span class="line">dispatch_async(queue, ^&#123; //block1</span><br><span class="line">    NSLog(@&quot;2&quot;); // 任务2</span><br><span class="line">    dispatch_sync(queue, ^&#123;   //block2</span><br><span class="line">        NSLog(@&quot;3&quot;); // 任务3</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;4&quot;); // 任务4</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;5&quot;); // 任务5</span><br></pre></td></tr></table></figure></div><blockquote><p>结论：1、5、2<br>分析：1、5先打印，异步开启子线程 2 打印，之后由于串行队列 3 与 4 相互等待造成 死锁</p></blockquote><ol start="4"><li>串行-同步-死锁</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 4.主线程死锁</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.demo.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">NSLog(@&quot;1&quot;); // 任务1</span><br><span class="line">dispatch_async(queue, ^&#123; //block1</span><br><span class="line">    NSLog(@&quot;2&quot;); // 任务2</span><br><span class="line">    dispatch_async(queue, ^&#123;   //block2</span><br><span class="line">        NSLog(@&quot;3&quot;); // 任务3</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;   //block3</span><br><span class="line">        NSLog(@&quot;4&quot;); // 任务3</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;5&quot;); // 任务4</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;6&quot;); // 任务5</span><br></pre></td></tr></table></figure></div><blockquote><p>结论：1、6、2<br>分析：1、6先打印，异步开启子线程 2 打印，又开启子线程由于串行队列 4 与 5 相互等待造成 死锁</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习43：继承</title>
      <link href="/BboyZJ.github.io/2023/03/09/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A043%EF%BC%9A%E7%BB%A7%E6%89%BF/"/>
      <url>/BboyZJ.github.io/2023/03/09/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A043%EF%BC%9A%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>swift中，<code>只有类支持继承</code></li><li>swift中 <code>类没有统一的基类</code>。</li><li>没有继承任何父类的类是基类，但其实它是有一个父类的，叫 <code>_SwiftObject</code></li><li>被 <code>final</code> 修饰的 <code>属性、方法、下标</code> 禁止被 <code>重写</code>，禁止被 <code>继承</code></li></ul><h1 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h1><ul><li><p>不继承任何类的类是 <code>基类</code></p></li><li><p>没有指定特定的父类的类都以基类的形式创建</p></li></ul><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 基类</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String = &quot;ZJ&quot;</span><br><span class="line">    func test() &#123;</span><br><span class="line">        print(&quot;hello&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h1><ul><li><p><code>子类</code> 是基于 <code>父类</code> 创建的新类</p></li><li><p>子类写在父类前面，用 <code>:</code> 分割</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Teacher: Person &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h1><ul><li>子类可以定义自己的 <code>属性、方法、下标</code> 及其他的特征，可一级从 <code>父类继承</code>，就是所谓的 <code>重写</code></li><li>子类可以 <code>继承</code> 父类的 <code>属性、方法、下标</code>，前面加 <code>override</code> 关键字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 基类</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String = &quot;ZJ&quot;</span><br><span class="line">    var desc: String&#123;</span><br><span class="line">        return name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子类</span><br><span class="line">class Student: Person &#123;</span><br><span class="line">    // 重写</span><br><span class="line">    override var desc: String&#123;</span><br><span class="line">        return super.desc + &quot;hello&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let s = Student()</span><br><span class="line">print(s.desc)</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">ZJ hello</span><br></pre></td></tr></table></figure><h1 id="访问父类的-属性、方法、下标"><a href="#访问父类的-属性、方法、下标" class="headerlink" title="访问父类的 属性、方法、下标"></a>访问父类的 属性、方法、下标</h1><ul><li>通过使用 <code>super</code> 前缀访问父类的、<code>属性、方法、下标脚本</code></li></ul><blockquote><p>super.someMethod() 重写父类的方法<br>super.someProperty 重写父类的属性<br>super[someIndex] 重写父类的下标脚本</p></blockquote><h1 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">class Person &#123;</span><br><span class="line">    // 实例方法</span><br><span class="line">    func test() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子类 Teacher 继承 Person 父类</span><br><span class="line">class Teacher: Person &#123;</span><br><span class="line">    // 子类重写父类的 test() 方法，用 override 关键字</span><br><span class="line">    override func test() &#123;</span><br><span class="line">        print(&quot;呜呼！&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let t = Teacher()</span><br><span class="line">t.test()</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">呜呼！</span><br></pre></td></tr></table></figure><h1 id="重写属性的getter和setter方法"><a href="#重写属性的getter和setter方法" class="headerlink" title="重写属性的getter和setter方法"></a>重写属性的getter和setter方法</h1><p>可以自定义一个gett或setter来重写父类继承的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var desc: String = &quot;ZJ&quot;</span><br><span class="line">&#125;</span><br><span class="line">class Teacher: Person &#123;</span><br><span class="line">    var age: Int = 0</span><br><span class="line">    override var desc: String &#123;</span><br><span class="line">        return super.desc + &quot;is \(age)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let t = Teacher()</span><br><span class="line">age = 32</span><br><span class="line">print(t.desc)</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">ZJ is 32</span><br></pre></td></tr></table></figure><h1 id="重写属性观察器"><a href="#重写属性观察器" class="headerlink" title="重写属性观察器"></a>重写属性观察器</h1><ul><li><p>可以为继承的属性添加属性观察器</p></li><li><p>不可以为继承的 <code>常量存储属性</code> 或 <code>只读的计算属性</code> 添加属性观察器</p></li><li><p>不能为同一个属性同时提供重写 <code>setter和属性观察器</code></p></li></ul><h1 id="禁止重写"><a href="#禁止重写" class="headerlink" title="禁止重写"></a>禁止重写</h1><ul><li>可以用 <code>final</code> 关键字禁止被 <code>继承</code></li><li>禁止继承属性： final var（变量属性）、final let（常量属性）</li><li>禁止继承方法：final func（实例方法）、final class（类方法）、</li><li>禁止继承下标：final subscribe（下标）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：swift中方法的调用</title>
      <link href="/BboyZJ.github.io/2023/03/09/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/03/09/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>性能优化03：Crash检测和优化方案</title>
      <link href="/BboyZJ.github.io/2023/03/09/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603%EF%BC%9ACrash%E6%A3%80%E6%B5%8B%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
      <url>/BboyZJ.github.io/2023/03/09/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603%EF%BC%9ACrash%E6%A3%80%E6%B5%8B%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="Crash原因"><a href="#Crash原因" class="headerlink" title="Crash原因"></a>Crash原因</h1><h1 id="Crash原因和解决"><a href="#Crash原因和解决" class="headerlink" title="Crash原因和解决"></a>Crash原因和解决</h1><ol><li>找不到方法的实现 unrecognized selector sent to instance</li></ol><ul><li><p>原因：找不到方法iOS系统抛出异常崩溃</p></li><li><p>解决方案：给NSObject添加一个分类，实现消息转发的几个方法</p></li></ul><ol start="2"><li>KVC造成的crash</li></ol><ul><li><p>原因：给不存在的key（包括key为nil）设置value</p></li><li><p>解决方法：</p></li><li><p>如果属性存在，利用iOS的反射机制来规避，NSStringFromSelector(@selector())将SEL反射为字符串作为key。这样在@selector()中传入方法名的过程中，编译器会有合法性检查，如果方法不存在或未实现会报黄色警告。</p></li><li><p>重写类的setValue:forUndefinedKey:和valueForUndefinedKey:</p></li></ul><ol start="3"><li>KVO引起的崩溃</li></ol><ul><li><p>原因：添加了观察者，没有在正确的时机移除</p></li><li><p>解决方案：addObserver和removeObserver一定要成对出现</p></li></ul><ol start="4"><li>集合类相关崩溃</li></ol><ul><li><p>原因：越界、添加nil、越界、添加nil</p></li><li><p>解决方案：</p></li></ul><p>给集合类添加category重写原来的方法，在内部做判段<br>使用Runtime把原来的方法替换成自定义的安全方法</p><ol start="5"><li>多线程中的崩溃</li></ol><p>原因:子线程中更新UI</p><p>解决方案：主线程更新UI</p><h1 id="Crash收集"><a href="#Crash收集" class="headerlink" title="Crash收集"></a>Crash收集</h1><h1 id="检测方式"><a href="#检测方式" class="headerlink" title="检测方式"></a>检测方式</h1><ol><li><p>第三方框架：Bugly</p></li><li><p>iTunes Store收集：上传App Store的app，苹果有帮我们收集，Xcode-&gt;Windows-&gt;Organizer</p></li><li><p>NSSetUncaughtExceptionHandler：iOS SDK 中提供了一个现成的函数</p></li></ol><h1 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h1>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习13：上传App Store所需各图标和图片尺寸</title>
      <link href="/BboyZJ.github.io/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A013%EF%BC%9A%E4%B8%8A%E4%BC%A0App-Store%E6%89%80%E9%9C%80%E5%90%84%E5%9B%BE%E6%A0%87%E5%92%8C%E5%9B%BE%E7%89%87%E5%B0%BA%E5%AF%B8/"/>
      <url>/BboyZJ.github.io/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A013%EF%BC%9A%E4%B8%8A%E4%BC%A0App-Store%E6%89%80%E9%9C%80%E5%90%84%E5%9B%BE%E6%A0%87%E5%92%8C%E5%9B%BE%E7%89%87%E5%B0%BA%E5%AF%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="App-Icon-图标尺寸"><a href="#App-Icon-图标尺寸" class="headerlink" title="App Icon 图标尺寸"></a>App Icon 图标尺寸</h1><table><thead><tr><th align="center">型号</th><th align="center">分辨率（pt）</th><th align="center">像素（px）</th><th align="center">图片后缀</th></tr></thead><tbody><tr><td align="center">iPhone</td><td align="center">20</td><td align="center">40x40</td><td align="center">2x</td></tr><tr><td align="center">iPhone</td><td align="center">20</td><td align="center">60x60</td><td align="center">3x</td></tr><tr><td align="center">iPhone</td><td align="center">29</td><td align="center">58x58</td><td align="center">2x</td></tr><tr><td align="center">iPhone</td><td align="center">29</td><td align="center">87x87</td><td align="center">3x</td></tr><tr><td align="center">iPhone</td><td align="center">40</td><td align="center">80x80</td><td align="center">2x</td></tr><tr><td align="center">iPhone</td><td align="center">40</td><td align="center">120x120</td><td align="center">3x</td></tr><tr><td align="center">iPhone</td><td align="center">60</td><td align="center">120x120</td><td align="center">2x</td></tr><tr><td align="center">iPhone</td><td align="center">60</td><td align="center">180x180</td><td align="center">2x</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">iPad</td><td align="center">20</td><td align="center">20x20</td><td align="center">1x</td></tr><tr><td align="center">iPad</td><td align="center">20</td><td align="center">40x40</td><td align="center">2x</td></tr><tr><td align="center">iPad</td><td align="center">29</td><td align="center">29x29</td><td align="center">1x</td></tr><tr><td align="center">iPad</td><td align="center">29</td><td align="center">58x58</td><td align="center">2x</td></tr><tr><td align="center">iPad</td><td align="center">40</td><td align="center">40x40</td><td align="center">1x</td></tr><tr><td align="center">iPad</td><td align="center">40</td><td align="center">80x80</td><td align="center">2x</td></tr><tr><td align="center">iPad</td><td align="center">76</td><td align="center">76x76</td><td align="center">1x</td></tr><tr><td align="center">iPad</td><td align="center">76</td><td align="center">152x152</td><td align="center">2x</td></tr><tr><td align="center">iPad</td><td align="center">83.5</td><td align="center">167x167</td><td align="center">2x</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">App Store</td><td align="center">1024</td><td align="center">1024x1024</td><td align="center">1x</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="App-Store-引导页图片尺寸"><a href="#App-Store-引导页图片尺寸" class="headerlink" title="App Store 引导页图片尺寸"></a>App Store 引导页图片尺寸</h1><table><thead><tr><th align="center">屏幕大小（英寸）</th><th align="center">像素（px）</th></tr></thead><tbody><tr><td align="center">5.5</td><td align="center">886x1920</td></tr><tr><td align="center">6.5</td><td align="center">1080x1920</td></tr><tr><td align="center">12.9</td><td align="center">1200x1600</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习12：HTTP状态码大全</title>
      <link href="/BboyZJ.github.io/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A012%EF%BC%9AHTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
      <url>/BboyZJ.github.io/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A012%EF%BC%9AHTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HTTP状态码（HTTP Status Code）是用来表示网页服务器HTTP响应状态的3位数字代码。</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>所有状态码的第一个数字代表了响应的五种状态之一，其分类如下：</p><table><thead><tr><th align="center">状态码</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1xx</td><td align="center">信息，表示临时响应并需要请求者继续执行操作</td></tr><tr><td align="center">2xx</td><td align="center">成功，操作被成功接收并处理</td></tr><tr><td align="center">3xx</td><td align="center">表示要完成请求，需要进一步操作。通常这些代码用来重定向</td></tr><tr><td align="center">4xx</td><td align="center">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="center">5xx</td><td align="center">这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错</td></tr></tbody></table><h1 id="状态码详解"><a href="#状态码详解" class="headerlink" title="状态码详解"></a>状态码详解</h1><ul><li>1xx：</li></ul><blockquote><p>100：（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</p><p>101：（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</p><p>102：由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</p></blockquote><ul><li>2xx：</li></ul><blockquote><p>200：（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</p><p>201：（已创建） 请求成功并且服务器创建了新的资源。</p><p>202：（已接受） 服务器已接受请求，但尚未处理。</p><p>203：（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</p><p>204：（无内容） 服务器成功处理了请求，但没有返回任何内容。</p><p>205：（重置内容） 服务器成功处理了请求，但没有返回任何内容。</p><p>206：（部分内容） 服务器成功处理了部分 GET 请求。</p><p>208：（已经报告）一个DAV的绑定成员被前一个请求枚举，并且没有被再一次包括。</p><p>226：（IM Used）服务器已经满足了请求所要的资源，并且响应是一个或者多个实例操作应用于当前实</p></blockquote><ul><li>3xx：</li></ul><blockquote><p>300：（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p><p>301：（永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</p><p>302：（临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>303：（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</p><p>304：（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</p><p>305：（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</p><p>307：（临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p></blockquote><ul><li>4xx：</li></ul><blockquote><p>400:（错误请求) 服务器不理解请求的语法。</p><p>401：(未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</p><p>402：该状态码是为了将来可能的需求而预留的。</p><p>403：（禁止) 服务器拒绝请求。</p><p>404：（未找到) 服务器找不到请求的网页。</p><p>405：（方法禁用) 禁用请求中指定的方法。</p><p>406：（不接受) 无法使用请求的内容特性响应请求的网页。</p><p>407：（需要代理授权) 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</p><p>408：（请求超时) 服务器等候请求时发生超时。</p><p>409：（冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</p><p>410：（已删除) 如果请求的资源已永久删除，服务器就会返回此响应。</p><p>411：（需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。</p><p>412：（未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。</p><p>413：（请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</p><p>414：（请求的 URI 过长) 请求的 URI（通常为网址）过长，服务器无法处理。</p><p>415：（不支持的媒体类型) 请求的格式不受请求页面的支持。</p><p>416：（请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。</p><p>417：（未满足期望值) 服务器未满足”期望”请求标头字段的要求。</p><p>418：（我是一个茶壶）这个代码是在1998年作为传统的IETF April Fools‘ jokes被定义的在RFC2324，超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现。RFC指定了这个代码应该是由茶罐返回给速溶咖啡。</p><p>419：（认证超时）并不是HTTP标注的一部分，419认证超时表示以前的有效证明已经失效了。同时也被用于401未认证的替代选择为了从其它被拒绝访问的已认证客户端中指定服务器的资源。</p><p>420：（方法失效）不是HTTP的标准，但是被Spring定义在HTTP状态类中当方法失时使用。这个状态码已经不推荐在Spring中使用。</p><p>420：（提高你的耐心）也不是HTTP标准的一部分，但是被版本1的Twitter搜索和趋势APi返回当客户端的速率被限制的时候。其它的服务提供商可能会使用429太多的请求响应码来代替。</p><p>421：从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</p><p>422：请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked</p><p>当前资源被锁定。（RFC 4918 WebDAV）</p><p>424：由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</p><p>425：在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</p><p>426：客户端应当切换到TLS&#x2F;1.0。（RFC 2817）</p><p>428：(需要前置条件)原始服务器需要有条件的请求。当客户端GET一个资源的状态的时候，同时又PUT回给服务器，与此同时第三方修改状态到服务器上的时候，为了避免丢失更新的问题发生将会导致冲突。</p><p>429：（过多请求）用户已经发送了太多的请求在指定的时间里。用于限制速率。</p><p>431：（请求头部字段太大）服务器由于一个单独的请求头部字段或者是全部的字段太大而不愿意处理请求。</p><p>440：（登陆超时（微软））一个微软的扩展，意味着你的会话已经超时。</p><p>444：（无响应）被使用在Nginx的日志中表明服务器没有返回信息给客户端并且关闭了连接（在威慑恶意软件的时候比较有用）。</p><p>449：（重试（微软））一个微软的扩展。请求应该在执行适当的动作之后被重试。</p><p>450：（被Windows家长控制阻塞（微软））一个微软的扩展。这个错误是当Windows家长控制打开并且阻塞指定网页的访问的时候被指定。</p><p>451：（由于法律原因而无效（因特网草稿））被定义在因特网草稿“一个新的HTTP状态码用于法律限制的资源”。被用于当资源的访问由于法律原因被禁止的时候。例如检查制度或者是政府强制要求禁止访问。一个例子是1953年dystopian的小说Fahrenheit 451就是一个非法的资源。</p><p>451：（重定向（微软））被用在Exchange ActiveSync中如果一个更有效的服务器能够被使用或者是服务器不能访问用户的邮箱。客户端会假定重新执行HTTP自动发现协议去寻找更适合的服务器。</p><p>494：（请求头太大（Nginx））Nginx内置代码和431类似，但是是被更早地引入在版本0.9.4（在2011年1月21日）。</p><p>495：（证书错误（Nginx））Nginx内置的代码，当使用SSL客户端证书的时候错误会出现为了在日志错误中区分它和4XX和一个错误页面的重定向。。</p><p>496：（没有证书（Nginx））Nginx内置的代码，当客户端不能提供证书在日志中分辨4XX和一个错误页面的重定向。</p><p>497：（HTTP到HTTPS（Nginx））Nginx内置的代码，被用于原始的HTTP的请求发送给HTTPS端口去分辨4XX在日志中和一个错误页面的重定向。</p><p>498：（令牌超时或失效（Esri））由ArcGIS for Server返回。这个代码意味着令牌的超时或者是失效。</p><p>499：（客户端关闭请求（Nginx））被用在Nginx日志去表明一个连接已经被客户端关闭当服务器仍然正在处理它的请求，是的服务器无法返货状态码。</p><p>499：（需要令牌（Esri））由ArcGIS for Server返回。意味着需要一个令牌（如果没有令牌被提交）。</p></blockquote><ul><li>5xx：</li></ul><blockquote><p>500：（服务器内部错误） 服务器遇到错误，无法完成请求。</p><p>501：（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</p><p>502：（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</p><p>503：（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</p><p>504：（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p><p>505：（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p><p>506：由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</p><p>507：服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</p><p>508：（发现环路）服务器发现了一个无限的循环档处理请求的时候。</p><p>509：服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</p><p>510：获取资源所需要的策略并没有没满足。（RFC 2774）。</p><p>511：（需要网络授权）客户端需要授权去火的网络的访问权限。一般用于代理交互中被用来进行网络的访问控制。</p><p>520：（未知错误）这个状态码也没有被指定在任何RFC中，并且只会被一些服务器返回，例如微软的Azure和CloudFlare服务器:”520错误。本质上是一个捕获全部的响应当原始服务器返回一些未知的或者一些不能被忍受或者被解释的(协议违反或者空响应)”。</p><p>598：（网络读取超时异常(未知)）这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络读取超时在一个客户端之前的代理的后面。</p><p>599：（网络连接超时异常(未知)）这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络连接超时在一个客户端之前的代理的后面。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习11：Xcode 常用的快捷键大全</title>
      <link href="/BboyZJ.github.io/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A011%EF%BC%9AXcode-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/"/>
      <url>/BboyZJ.github.io/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A011%EF%BC%9AXcode-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="通用快捷键"><a href="#通用快捷键" class="headerlink" title="通用快捷键"></a>通用快捷键</h1><blockquote><p>Command + A ：全选<br>Command + C ：复制<br>Command + V ：粘贴<br>Command + X ：剪切<br>Command + Z ：撤销<br>Command + Shift + Z ： 撤销刚才的撤销</p></blockquote><h1 id="文件快捷键"><a href="#文件快捷键" class="headerlink" title="文件快捷键"></a>文件快捷键</h1><blockquote><p>Command + S ：保存<br>Command + Shift + S ：另存为</p></blockquote><h1 id="项目快捷键"><a href="#项目快捷键" class="headerlink" title="项目快捷键"></a>项目快捷键</h1><blockquote><p>Command + Shift + N ：新建项目<br>Command + N ：新建文件<br>Command + O ：打开文件<br>Command + D ：快速复制一段代码<br>Optional + 单击 ：显示描述文件<br>Command +  单击：跳转函数<br>Command + Optional + 上&#x2F;下箭头 ：快速切换.h和.m文件</p><p>Command + 0 ：显示&#x2F;隐藏导航器面板<br>Command + Optional + 0 ：显示&#x2F;隐藏工具面板<br>Command + Shift + o ：快速搜索</p></blockquote><h1 id="注释快捷键"><a href="#注释快捷键" class="headerlink" title="注释快捷键"></a>注释快捷键</h1><blockquote><p>Command + Optional + &#x2F; ：快速注释<br>Command + &#x2F; ：单行注释</p></blockquote><h1 id="折叠-x2F-展开快捷键"><a href="#折叠-x2F-展开快捷键" class="headerlink" title="折叠&#x2F;展开快捷键"></a>折叠&#x2F;展开快捷键</h1><blockquote><p>Command + Optional + 左箭头 ：折叠代码<br>Command + Optional + 右箭头 ：展开代码</p></blockquote><h1 id="文字快捷键"><a href="#文字快捷键" class="headerlink" title="文字快捷键"></a>文字快捷键</h1><blockquote><p>Command + - ：缩小文字<br>Command + + ：放大文字</p></blockquote><h1 id="调试运行、停止"><a href="#调试运行、停止" class="headerlink" title="调试运行、停止"></a>调试运行、停止</h1><blockquote><p>Command + B ：编译<br>Command + R ：运行<br>Command + . ：停止<br>Command + Shift + K ：清理</p></blockquote><h1 id="移动代码块"><a href="#移动代码块" class="headerlink" title="移动代码块"></a>移动代码块</h1><blockquote><p>Command + [ ：左移代码块<br>Command + ] ：右移代码块</p></blockquote><blockquote><p>Command + Optional + [ ：上移代码块<br>Command + Optional + ] ：下移代码块</p></blockquote><h1 id="移动光标快捷键"><a href="#移动光标快捷键" class="headerlink" title="移动光标快捷键"></a>移动光标快捷键</h1><blockquote><p>Command + 左&#x2F;右箭头 ：将光标移动至行首&#x2F;尾<br>Command + 上&#x2F;下箭头 ：将光标移动至文档行首&#x2F;尾</p></blockquote><blockquote><p>Command + Shift + 左&#x2F;右箭头 ：向左&#x2F;右选择一个单词</p></blockquote><blockquote><p>Command + Shift + 左&#x2F;右箭头 ：选择到行首&#x2F;尾</p></blockquote><h1 id="调试快捷键"><a href="#调试快捷键" class="headerlink" title="调试快捷键"></a>调试快捷键</h1><blockquote><p>Command + \ ：设置&#x2F;取消断点</p></blockquote><h1 id="窗口快捷键"><a href="#窗口快捷键" class="headerlink" title="窗口快捷键"></a>窗口快捷键</h1><blockquote><p>Command + H ：隐藏<br>Command + M ：最小化<br>Command + P ：打印<br>Command + Q ：退出项目<br>Command + W ：关闭当前文件</p></blockquote><h1 id="窗口切换快捷键"><a href="#窗口切换快捷键" class="headerlink" title="窗口切换快捷键"></a>窗口切换快捷键</h1><blockquote><p>Command + Tab ：程序间切换<br>Command + ~ ：窗口间切换</p></blockquote><h1 id="屏幕快捷键"><a href="#屏幕快捷键" class="headerlink" title="屏幕快捷键"></a>屏幕快捷键</h1><blockquote><p>Command + Shift + F3 ：截图整个屏幕<br>Command + Shift + F4 ：截取指定区域</p></blockquote><h1 id="系统快捷键"><a href="#系统快捷键" class="headerlink" title="系统快捷键"></a>系统快捷键</h1><blockquote><p>Command + Optional + ESC ：强制退出程序<br>Command + Space ：切换语言<br>Command + Shift + ？：帮助 </p></blockquote><h1 id="编辑快捷键"><a href="#编辑快捷键" class="headerlink" title="编辑快捷键"></a>编辑快捷键</h1><blockquote><p>Command + Delete ：删除<br>Command + Shift + Delete ：清空垃圾桶<br>Command + Shift + A ：打开应用程序目录<br>Command + Shift + C ：打开 Computer 目录<br>Command + Shift + H ：打开 Home 目录</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习10：iPhone各系列尺寸大全</title>
      <link href="/BboyZJ.github.io/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A010%EF%BC%9AiPhone%E5%90%84%E7%B3%BB%E5%88%97%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%85%A8/"/>
      <url>/BboyZJ.github.io/2023/03/09/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A010%EF%BC%9AiPhone%E5%90%84%E7%B3%BB%E5%88%97%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="iPhone手机尺寸大全"><a href="#iPhone手机尺寸大全" class="headerlink" title="iPhone手机尺寸大全"></a>iPhone手机尺寸大全</h1><table><thead><tr><th align="center">机型</th><th align="center">屏幕尺寸 （英寸）</th><th align="center">分辨率（pt）</th><th align="center">像素（px）</th><th align="center">图片后缀</th><th align="center">安全区域（上&#x2F;下）</th></tr></thead><tbody><tr><td align="center">iPhone4&#x2F;4s</td><td align="center">3.5</td><td align="center">320x480</td><td align="center">640x960</td><td align="center">@2x</td><td align="center"></td></tr><tr><td align="center">iPhone5&#x2F;5c&#x2F;5s&#x2F;SE</td><td align="center">4</td><td align="center">320x568</td><td align="center">640x1136</td><td align="center">@2x</td><td align="center"></td></tr><tr><td align="center">iPhone6&#x2F;6s&#x2F;7&#x2F;8</td><td align="center">4.7</td><td align="center">375x667</td><td align="center">750x1334</td><td align="center">@2x</td><td align="center"></td></tr><tr><td align="center">iPhone6&#x2F;6s&#x2F;7&#x2F;8 Plus</td><td align="center">5.5</td><td align="center">414x736</td><td align="center">1080x1920</td><td align="center">@3x</td><td align="center"></td></tr><tr><td align="center">iPhoneX&#x2F;iPhoneXS&#x2F;11Pro</td><td align="center">5.8</td><td align="center">375x812</td><td align="center">1125x2436</td><td align="center">@3x</td><td align="center">44&#x2F;34</td></tr><tr><td align="center">iPhoneXR&#x2F;11</td><td align="center">6.1</td><td align="center">414x896</td><td align="center">828x1792</td><td align="center">@2x</td><td align="center">48&#x2F;34</td></tr><tr><td align="center">iPhoneXSMax&#x2F;11ProMax</td><td align="center">6.5</td><td align="center">414x896</td><td align="center">1242x2688</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone12mini（&gt;&#x3D;iOS14） iPhone13mini（&gt;&#x3D;iOS15）</td><td align="center">5.4</td><td align="center">360x780</td><td align="center">1080x2340</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone12&#x2F;12Pro iPhone13&#x2F;13Pro</td><td align="center">6.1</td><td align="center">390x844</td><td align="center">1170x2532</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone12&#x2F;13ProMax</td><td align="center">6.7</td><td align="center">428x926</td><td align="center">1284x2778</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone14 （&gt;&#x3D;iOS16）</td><td align="center">6.1</td><td align="center">390x844</td><td align="center">1170x2532</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone14 Plus</td><td align="center">6.7</td><td align="center">428x926</td><td align="center">1284x2778</td><td align="center">@3x</td><td align="center">47&#x2F;34</td></tr><tr><td align="center">iPhone14 Pro</td><td align="center">6.1</td><td align="center">393x852</td><td align="center">1179x2556</td><td align="center">@3x</td><td align="center">59&#x2F;34</td></tr><tr><td align="center">iPhone14 Pro Max</td><td align="center">6.7</td><td align="center">430x932</td><td align="center">1290x2796</td><td align="center">@3x</td><td align="center">59&#x2F;34</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习12：修改项目名称</title>
      <link href="/BboyZJ.github.io/2023/03/08/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A008%EF%BC%9A%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
      <url>/BboyZJ.github.io/2023/03/08/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A008%EF%BC%9A%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>如果我们在项目中集成三方库 <code>SDwebImage</code> 时，报错 <code>Framework not found Pods_________</code>，说明 <code>工程名称用汉字了</code>，这个时候就需要更改项目名</p></li><li><p>在开发过程中需求想更改项目名</p></li></ul><h1 id="修改名称"><a href="#修改名称" class="headerlink" title="修改名称"></a>修改名称</h1><p>Xcode 修改 工程名</p><ul><li>打开 <code>Xcode</code> 的 <code>Show the File Inspector</code>，修改 <code>Name</code> 为 <code>FirstFrameDemo</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172101620.png"                                     ></p><ul><li>修改成 <code>FirstFrameDemo</code> 之后，回车， 这里 <code>Xcode</code> 列举了可以为我们做的更改的名称</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172101564.png"                                     ></p><ul><li><p>点击 <code>Rename -&gt; OK</code>，<code>Xcode</code> 为我们重命名了一部分。</p></li><li><p>关闭项目工程，修改项目文件夹名称（由原工程名 -&gt; 修改成新的工程名）</p></li></ul><p>修改前：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172102344.png"                                     ></p><p>修改后：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172102033.png"                                     ></p><ul><li>修改项目文件名（右击选择包内容）</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172103616.png"                                     ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172103324.png"                                     ></p><ul><li>点击 <code>project.phxproj</code> 文件，将 <code>获取视频的第一帧</code> 替换成 <code>FirstFrameDemo</code> ，全部替换 <code>All -&gt; Done</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172103306.png"                                     ></p><ul><li>打开项目 <code>FirstFrameDemo.xcworkspace</code> ，项目内全局替换 <code>获取视频的第一帧 -&gt; FirstFrameDemo</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172103753.png"                                     ></p><ul><li>修改 <code>Podfile</code> 文件中项目名称</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172103096.png"                                     ></p><ul><li>打开终端，切换到当前项目目录下，执行 <code>pos intall</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172104884.png"                                     ></p><ul><li>删除旧的 <code>workspace</code> 文件</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172104199.png"                                     ></p><ul><li>至此项目名已经完全修改完成了</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172104822.png"                                     ></p>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习11：Pch文件</title>
      <link href="/BboyZJ.github.io/2023/03/08/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A009%EF%BC%9APch%E6%96%87%E4%BB%B6/"/>
      <url>/BboyZJ.github.io/2023/03/08/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A009%EF%BC%9APch%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习10：UITableViw点击事件和页面上的手势冲突怎么解决？</title>
      <link href="/BboyZJ.github.io/2023/03/07/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A007%EF%BC%9AUITableViw%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%92%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/"/>
      <url>/BboyZJ.github.io/2023/03/07/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A007%EF%BC%9AUITableViw%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%92%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E6%89%8B%E5%8A%BF%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h1><p>下面以一个例子讲解</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172335348.png"                                     ></p><p>图中 <code>superView</code> 有两个 <code>subView</code>，分别是 <code>testView</code> 和 <code>testBtn</code>。我们在 <code>superView</code> 和 <code>testView</code> 都重载 <code>touchsBegan:withEvent、touchsEnded:withEvent、 touchsMoved:withEvent、touchsCancelled:withEvent方法</code>，并且在 <code>superView</code> 上添加单击手势 <code>UITapGestureRecognizer</code>，action名为tapAction，给testBtn绑定action名为testBtnClicked。</p><p>主要代码如下：</p><ul><li>SuperView</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)initUI&#123;</span><br><span class="line">    UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapAction)];</span><br><span class="line">    [self addGestureRecognizer:tap];</span><br><span class="line">    </span><br><span class="line">    [self addSubview:self.testView];</span><br><span class="line">    [self addSubview:self.testBtn];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;=========&gt; superView touchs Began&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">     NSLog(@&quot;=========&gt; superView touchs Moved&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">     NSLog(@&quot;=========&gt; superView touchs Ended&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">     NSLog(@&quot;=========&gt; superView touchs Cancelled&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)tapAction &#123;</span><br><span class="line">     NSLog(@&quot;=========&gt; single Tapped&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)clickBtn &#123;</span><br><span class="line">     NSLog(@&quot;=========&gt; click btn&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>textView</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//testView</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;=========&gt; testView touchs Began&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;=========&gt; testView touchs Moved&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;=========&gt; testView touchs Ended&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;=========&gt; testView touchs Cancelled&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>情景O：注释 手势 ，分别点击 <code>superView</code> 和 <code>testView</code>：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2023-03-08 17:58:44.408166+0800 手势冲突[20427:1092257] =========&gt; superView touchs Began</span><br><span class="line">2023-03-08 17:58:44.544181+0800 手势冲突[20427:1092257] =========&gt; superView touchs Ended</span><br><span class="line"></span><br><span class="line">2023-03-08 17:58:54.666862+0800 手势冲突[20427:1092257] =========&gt; testView touchs Began</span><br><span class="line">2023-03-08 17:58:54.825938+0800 手势冲突[20427:1092257] =========&gt; testView touchs Ended</span><br></pre></td></tr></table></figure></div><ul><li>情景A：单击 superView ，输出结果：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2023-03-08 17:32:44.983101+0800 手势冲突[20227:1064772] =========&gt; superView touchs Began</span><br><span class="line">2023-03-08 17:32:45.043310+0800 手势冲突[20227:1064772] =========&gt; single Tapped</span><br><span class="line">2023-03-08 17:32:45.043538+0800 手势冲突[20227:1064772] =========&gt; superView touchs Cancelled</span><br></pre></td></tr></table></figure></div><ul><li>情景B：单击 testView，输出结果：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2023-03-08 17:43:16.370199+0800 手势冲突[20326:1077469] =========&gt; testView touchs Began</span><br><span class="line">2023-03-08 17:43:16.430723+0800 手势冲突[20326:1077469] =========&gt; single Tapped</span><br><span class="line">2023-03-08 17:43:16.430939+0800 手势冲突[20326:1077469] =========&gt; testView touchs Cancelled</span><br></pre></td></tr></table></figure></div><ul><li>情景C：单击 testBtn，输出结果：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023-03-08 17:43:40.690096+0800 手势冲突[20326:1077469] =========&gt; click btn</span><br></pre></td></tr></table></figure></div><ul><li>情景D：按住 testView，过3秒后或更久释放，输出结果：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2023-03-08 17:43:50.678603+0800 手势冲突[20326:1077469] =========&gt; testView touchs Began</span><br><span class="line">2023-03-08 17:43:53.499119+0800 手势冲突[20326:1077469] =========&gt; testView touchs Ended</span><br></pre></td></tr></table></figure></div><h2 id="情景-O、A、B-分析"><a href="#情景-O、A、B-分析" class="headerlink" title="情景 O、A、B 分析"></a>情景 <code>O、A、B</code> 分析</h2><p>开发文档可知：</p><blockquote><p>Gesture Recognizers Get the First Opportunity to Recognize a Touch.</p><p>A window delays the delivery of touch objects to the view so that the gesture recognizer can analyze the touch first. During the delay, if the gesture recognizer recognizes a touch gesture, then the window never delivers the touch object to the view, and also cancels any touch objects it previously sent to the view that were part of that recognized sequence.</p></blockquote><p>Google翻译：</p><blockquote><p>手势识别器获得识别触摸的第一个机会。</p><p>一个窗口延迟将触摸对象传递到视图，使得手势识别器可以首先分析触摸。 在延迟期间，如果手势识别<br>器识别出触摸手势，则窗口不会将触摸对象传递到视图，并且还将先前发送到作为识别的序列的一部分的视图的任何触摸对象取消。</p></blockquote><ul><li><code>触摸事件首先传递到手势上，如果手势识别成功了，就会取消事件的继续传递</code>，否则，事件还是会被响应链处理。系统维持了与响应链关联的所有手势，事件首先传递给手势，然后才传递给响应链。这样我们就解释A和B的场景了</li></ul><h2 id="情景-C-分析："><a href="#情景-C-分析：" class="headerlink" title="情景 C 分析："></a>情景 <code>C</code> 分析：</h2><p>iOS 开发文档里这样说：</p><blockquote><p>In iOS 6.0 and later, default control actions prevent overlapping gesture recognizer behavior. For example, the default action for a button is a single tap. If you have a single tap gesture recognizer attached to a button’s parent view, and the user taps the button, then the button’s action method receives the touch event instead of the gesture recognizer. This applies only to gesture recognition that overlaps the default action for a control, which includes:</p><p>A single finger single tap on a UIButton, UISwitch, UISegmentedControl, UIStepper,and UIPageControl.A single finger swipe on the knob of a UISlider, in a direction parallel to the slider.A single finger pan gesture on the knob of a UISwitch, in a direction parallel to the switch.</p></blockquote><p>Google 翻译为：</p><blockquote><p>在iOS 6.0及更高版本中，默认控制操作可防止重叠的手势识别器行为。 例如，按钮的默认操作是单击。 如果您有一个单击手势识别器附加到按钮的父视图，并且用户点击按钮，则按钮的动作方法接收触摸事件而不是手势识别器。 这仅适用于与控件的默认操作重叠的手势识别，其中包括：</p><p>单个手指单击UIButton，UISwitch，UISegmentedControl，UIStepper和UIPageControl.<br>单个手指在UISlider的旋钮上滑动，在平行于滑块的方向上。在UISwitch的旋钮上的单个手指平移手势 与开关平行的方向。</p></blockquote><ul><li>因此，在情景C，点击testBtn的action，按钮获取了事件响应，不会把事件响应传递给父视图的supView</li></ul><h2 id="情景-C-分析：-1"><a href="#情景-C-分析：-1" class="headerlink" title="情景 C 分析："></a>情景 <code>C</code> 分析：</h2><ul><li>长按testView已经不是单击事件了，tap手势就不会识别</li></ul><h1 id="实际开发中遇到的问题"><a href="#实际开发中遇到的问题" class="headerlink" title="实际开发中遇到的问题"></a>实际开发中遇到的问题</h1><ul><li><p>父视图上先后添加了一个 <code>UIGestureRecognizer</code> 和一个 <code>UITableView</code></p></li><li><p>我们发现在点击 <code>UITableView</code> 的 <code>cell</code> 的时候，并没有触发 <code>-(void)tableView:(UITableView*)tableView didSelectRowAtIndexPath:(NSIndexPath*)indexPath;</code> 方法。</p></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于 cell 继承 cell -&gt; UIView -&gt; UIResponder，是可以接收和处理事件的，但是添加了 <code>tap</code> 后会导致 <code>cell</code> 响应链无法正常响应，导致 <code>手势冲突</code></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在我们点击 <code>cell</code> 的时候，不让父视图的 <code>手势</code> 干扰子视图cell的点击事件或者说响应链正常传递，一般会重写 <code>UIGestureRecognizerDelegate</code> 中的<code> - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch</code><br>方法。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch&#123;</span><br><span class="line">    // 如果是UITableViewCell类或子类响应事件</span><br><span class="line">    if ([touch.view isKindOfClass:[UITableViewCell class]]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    //默认都需要响应</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">2023-03-08 18:19:39.851593+0800 手势冲突[20552:1111844] -[ParentV tableView:didSelectRowAtIndexPath:]</span><br><span class="line">2023-03-08 18:19:40.583123+0800 手势冲突[20552:1111844] -[ParentV tableView:didSelectRowAtIndexPath:]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习06：截取视频文件第一帧的方法有哪些？</title>
      <link href="/BboyZJ.github.io/2023/03/07/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A006%EF%BC%9A%E6%88%AA%E5%8F%96%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E7%AC%AC%E4%B8%80%E5%B8%A7%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
      <url>/BboyZJ.github.io/2023/03/07/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A006%EF%BC%9A%E6%88%AA%E5%8F%96%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E7%AC%AC%E4%B8%80%E5%B8%A7%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>iOS 中获取视频第一帧有两种方式</p><h1 id="第一种：使用AVFoundation获取"><a href="#第一种：使用AVFoundation获取" class="headerlink" title="第一种：使用AVFoundation获取"></a>第一种：使用AVFoundation获取</h1><p>将耗时的操作放在异步执行队列 <code>dispatch_async</code>，防止造成线程堵塞，刷新UI放在 <code>主线程</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)getFirstFrameFromVideoWithUrl:(NSURL *)url&#123;</span><br><span class="line">    AVURLAsset *asset = [[AVURLAsset alloc] initWithURL:url options:nil];</span><br><span class="line">    AVAssetImageGenerator *assetGennerator = [[AVAssetImageGenerator alloc] initWithAsset:asset];</span><br><span class="line">    assetGennerator.appliesPreferredTrackTransform = YES;</span><br><span class="line">    CMTime time = CMTimeMakeWithSeconds(0.0, 600);</span><br><span class="line">    CMTime actualTime;</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    CGImageRef image = [assetGennerator copyCGImageAtTime:time actualTime:&amp;actualTime error:&amp;error];</span><br><span class="line">    UIImage *videoImg = [[UIImage alloc] initWithCGImage:image];</span><br><span class="line">    CGImageRelease(image);</span><br><span class="line">    return videoImg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第二种方式：使用SDWebImage获取，并缓存图片"><a href="#第二种方式：使用SDWebImage获取，并缓存图片" class="headerlink" title="第二种方式：使用SDWebImage获取，并缓存图片"></a>第二种方式：使用SDWebImage获取，并缓存图片</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (void)method2&#123;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:@&quot;https://klxxcdn.oss-cn-hangzhou.aliyuncs.com/histudy/hrm/media/bg1.mp4&quot;];</span><br><span class="line">    NSString *urlKey = url.absoluteString;</span><br><span class="line">    // 先从缓存中查找是否有图片</span><br><span class="line">    SDImageCache *imgCache = [SDImageCache sharedImageCache];</span><br><span class="line">    UIImage *memoryImg = [imgCache imageFromCacheForKey:urlKey];</span><br><span class="line">    if (memoryImg) &#123;</span><br><span class="line">        self.imgV.image = memoryImg;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        // 从磁盘中查找是否有图片</span><br><span class="line">        UIImage *diskImg = [imgCache imageFromDiskCacheForKey:urlKey];</span><br><span class="line">        if (diskImg) &#123;</span><br><span class="line">            self.imgV.image = diskImg;</span><br><span class="line">        &#125;else &#123; // 如果都不存在</span><br><span class="line">            // 开启异步线程下载图片</span><br><span class="line">            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">                AVURLAsset *asset = [[AVURLAsset alloc] initWithURL:url options:nil];</span><br><span class="line">                NSParameterAssert(asset);</span><br><span class="line">                AVAssetImageGenerator *assetGenerator = [[AVAssetImageGenerator alloc] initWithAsset:asset];</span><br><span class="line">                assetGenerator.appliesPreferredTrackTransform = YES;</span><br><span class="line">                assetGenerator.apertureMode = AVAssetImageGeneratorApertureModeEncodedPixels;</span><br><span class="line">                CGImageRef thumbImgRef = NULL;</span><br><span class="line">                CFTimeInterval thumbImgTime = 1;</span><br><span class="line">                NSError *thumbImgError = nil;</span><br><span class="line">                thumbImgRef = [assetGenerator copyCGImageAtTime:CMTimeMake(thumbImgTime, 60) actualTime:NULL error:&amp;thumbImgError];</span><br><span class="line">                if (!thumbImgRef)&#123;</span><br><span class="line">                    NSLog(@&quot;thumbImgError:%@&quot;,thumbImgError);</span><br><span class="line">                &#125;</span><br><span class="line">                UIImage *thumbImg = thumbImgRef ? [[UIImage alloc] initWithCGImage:thumbImgRef] : nil;</span><br><span class="line">                // 主线程显示UI</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    SDImageCache *imgCache = [SDImageCache sharedImageCache];</span><br><span class="line">                    [imgCache storeImage:thumbImg forKey:urlKey completion:^&#123;</span><br><span class="line">                        NSLog(@&quot;store Image success&quot;);</span><br><span class="line">                    &#125;];</span><br><span class="line">                    self.imgV.image = thumbImg;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习05：分类和扩展</title>
      <link href="/BboyZJ.github.io/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A005%EF%BC%9A%E5%88%86%E7%B1%BB%E5%92%8C%E6%89%A9%E5%B1%95/"/>
      <url>/BboyZJ.github.io/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A005%EF%BC%9A%E5%88%86%E7%B1%BB%E5%92%8C%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="分类-Category"><a href="#分类-Category" class="headerlink" title="分类 Category"></a>分类 Category</h1><ul><li><p>Category 的主要作用是为 <code>已经存在的类添加(扩展)方法</code></p></li><li><p>已存在的类可以是 <code>系统的类</code> 或 <code>自定义的类</code> </p></li><li><p>不能定义 <code>变量（成员变量或实例变量）</code></p></li><li><p>一般情况下也可以定义 <code>属性</code>，但是 <code>不会实现</code> 它的 <code>set</code> 和 <code>get</code> 方法，需要利用 <code>runtime</code> 机制去实现它的 <code>set</code> 和 <code>get</code> 方法。</p></li><li><p>分类文件有 <code>.h</code> 和 <code>.m</code> 两个文件，文件名 <code>@interface 类名 (分类名)</code></p></li></ul><h2 id="创建-系统-分类"><a href="#创建-系统-分类" class="headerlink" title="创建 系统 分类"></a>创建 系统 分类</h2><ul><li><code>command + n</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090249910.png"></p><ul><li>点击 <code>Objective-C File</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090249569.png"></p><ul><li>创建完成后会生成 <code>系统文件名+Category.h</code> 和 <code>系统文件名+Category.m</code> 两个文件</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090250512.png"></p><ul><li>在分类中可以添加 <code>实例方法和类方法</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface UIViewController (Cate)</span><br><span class="line">- (void)sayHello;</span><br><span class="line">+ (void)sayBye;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">==============</span><br><span class="line"></span><br><span class="line">@implementation UIViewController (Cate)</span><br><span class="line">- (void)sayHello&#123;</span><br><span class="line">    NSLog(@&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)sayBye&#123;</span><br><span class="line">    NSLog(@&quot;bye&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>在本类中调用，需要引入头文件  <code>文件名+Category.h</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> // 分类</span><br><span class="line">[self sayHello];</span><br><span class="line">[ViewController sayBye];</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">Category[30386:1690552] bye</span><br><span class="line">2023-03-06 22:06:37.369596+0800 Category[30386:1690552] hello</span><br><span class="line">2023-03-06 22:06:37.369794+0800 Category[30386:1690552] bye</span><br></pre></td></tr></table></figure><h2 id="自定义的类-添加-分类"><a href="#自定义的类-添加-分类" class="headerlink" title="自定义的类 添加 分类"></a>自定义的类 添加 分类</h2><ul><li>创建方式类似</li></ul><p>与系统类类似，在 <code>class</code> 中选择自定义的类 <code>Person</code></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090250135.png"></p><h2 id="可以在-分类中声明并实现-两个方法，在本类中调用"><a href="#可以在-分类中声明并实现-两个方法，在本类中调用" class="headerlink" title="可以在 分类中声明并实现 两个方法，在本类中调用"></a>可以在 <code>分类中声明并实现</code> 两个方法，在本类中调用</h2><ul><li>分类中声明并实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface Person (Category)</span><br><span class="line">- (void)sayHello;</span><br><span class="line">+ (void)sayBye;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line"></span><br><span class="line">@implementation Person (Category)</span><br><span class="line">- (void)sayHello&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)sayBye&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>本类中调用，编译运行，查看打印结果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        // 本类中调用分类添加的方法</span><br><span class="line">        [self sayHello];</span><br><span class="line">        [Person sayBye];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">2023-03-07 08:14:34.439456+0800 Category[3555:114948] -[Person(Category) sayHello]</span><br><span class="line">2023-03-07 08:14:34.439626+0800 Category[3555:114948] +[Person(Category) sayBye]</span><br></pre></td></tr></table></figure><p>那么问题来了，既然本类中可以调用，那么在其他类中是否也可以调用呢？</p><h2 id="其他类中调用-分类-方法"><a href="#其他类中调用-分类-方法" class="headerlink" title="其他类中调用 分类 方法"></a>其他类中调用 分类 方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 自定义的类</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">#import &quot;Person+Category.h&quot;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 自定义的类</span><br><span class="line">    Person * p = [[Person alloc] init];</span><br><span class="line">    [p sayHello];</span><br><span class="line">    [Person sayBye];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">2023-03-07 08:19:57.913133+0800 Category[3631:119871] -[Person(Category) sayHello]</span><br><span class="line">2023-03-07 08:19:57.913667+0800 Category[3631:119871] +[Person(Category) sayBye]</span><br></pre></td></tr></table></figure><p>由打印结果可知，在VC中时可以调用的</p><p>那么问题又来了，如果本类中和分类中均实现了 <code>同样的方法</code> 会调用哪个？</p><h2 id="分类和本类实现了同样的方法"><a href="#分类和本类实现了同样的方法" class="headerlink" title="分类和本类实现了同样的方法"></a>分类和本类实现了同样的方法</h2><ul><li>在 <code>Person</code> 类中实现一个 <code>sayHello</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)sayHello&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 VC 中调用 sayHello</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 自定义的类</span><br><span class="line">Person * p = [[Person alloc] init];</span><br><span class="line">[p sayHello];</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">2023-03-07 08:24:09.821814+0800 Category[3670:122944] -[Person(Category) sayHello]</span><br></pre></td></tr></table></figure><p>由打印结果可知，调用的是 <code>分类</code> 的方法，由此我们可以推断，<code>本类的方法被分类替代了</code></p><h1 id="扩展-Extension"><a href="#扩展-Extension" class="headerlink" title="扩展 Extension"></a>扩展 Extension</h1><ul><li>是类的一部分，在编译器和头文件里的@interface一级实现文件里的@implement一起形成一个完整的类，它伴随着类的产生而产生，亦随之一起消亡</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>声明 <code>私有属性、私有方法、私有成员变量</code>，想要被访问 <code>@public</code></li><li>扩展不能为系统类添加扩展（必须有一个类的源码才能添加一个类的Extension），所以你无法为系统的类添加Extension</li><li>成员变量和实例变量是 <code>私有的</code>，不能被外界访问，</li><li>属性可以被外界访问，由于没有实现调用会 <code>carsh</code></li><li>方法可以被外界访问，由于没有实现set和get方法，访问会 <code>carsh</code></li><li>扩展只有一个 <code>.h</code> 文件，因此 所有的都是没办法调用</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>创建 <code>Extension</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090251689.png"></p><ul><li>自定义类中的代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">#import &quot;Person+Extension.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (void)sayHello&#123;</span><br><span class="line">    NSLog(@&quot;%s hello&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>在 <code>#import &quot;Person+Ext.h&quot;</code> 中实现如下代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface UIViewController ()</span><br><span class="line">&#123;</span><br><span class="line">    NSString * name;</span><br><span class="line">    @public int age;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic,copy)NSString * sex;</span><br><span class="line">- (void)sayHello;</span><br><span class="line">+ (void)sayBye;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>在 <code>VC</code> 中调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Person * p = [Person new];</span><br><span class="line">    // 调用报错或崩溃</span><br><span class="line">//    p-&gt;age = 30;</span><br><span class="line">//    p-&gt;name = &quot;ZJ&quot;;</span><br><span class="line">//    p.sex = @&quot;男&quot;;</span><br><span class="line">//    [Person sayBye];</span><br><span class="line"></span><br><span class="line">    [p sayHello];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">2023-03-06 22:35:02.277867+0800 Extension[30580:1704777] -[Person sayHello] hello</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果只有声明没有实现，则调用会 <code>Crash</code></p><h1 id="分类-和-扩展的区别"><a href="#分类-和-扩展的区别" class="headerlink" title="分类 和 扩展的区别"></a>分类 和 扩展的区别</h1><ul><li><p>category 在运行时决议。extension 在编译时决议。所以扩展中的方法没有被实现编译器会报警告，分类中没有被实现编译器不会警告</p></li><li><p>分类原则上只能添加方法，不能添加属性（因为没有实现属性的seter和getter方法，可以通过runtime添加）。扩展能添加方法、实例变量，默认是@private类型的，且只能作用于自身类</p></li><li><p>分类有自己的实现部分。扩展没有实现部分，只能依托对应的类的实现部分。</p></li><li><p>分类可以为系统添加分类。扩展不能为系统添加分类。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习04：JSON和XML数据解析</title>
      <link href="/BboyZJ.github.io/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A004%EF%BC%9AJSON%E5%92%8CXML%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
      <url>/BboyZJ.github.io/2023/03/06/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A004%EF%BC%9AJSON%E5%92%8CXML%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>在 <code>iOS</code> 开发中，常见的数据传输格式有两种：<code>JSON和XML</code>。</p></li><li><p>服务器返回客户端的数据，一般都是 <code>JSON格式或XML格式（文件下载除外）</code></p></li><li><p><code>JSON</code> 由于 <code>体积小、传输快速 </code>等优点，逐渐成为了 <code>主流的数据传输格式</code>。</p></li></ul><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>在 iOS 中，常见解析方案有以下几种：</p><ul><li><p>第三方框架：JSONKit、SBJson、TouchJSON（性能从左到右，越来越差）</p></li><li><p>性能最好的是使用 <code>苹果原生的框架</code>： <code>NSJSONSerialization</code></p></li><li><p>JSON格式很像OC中的数组和字典，key必须用双引号</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:22&#125;、[&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:22&#125;,&#123;&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:22&#125;]</span><br></pre></td></tr></table></figure><h2 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h2><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061810849.png"></p><h2 id="JSON-转-OC"><a href="#JSON-转-OC" class="headerlink" title="JSON 转 OC"></a>JSON 转 OC</h2><ul><li>第一个参数：要解析的JSON数据，是NSData类型也就是二进制数据</li><li>第二个参数：解析JSON的可选配置参数<ul><li>NSJSONReadingMutableContainers 解析出来的字典和数组是可变的</li><li>NSJSONReadingFragmentsAllowed 解析出来的对象中的字符串是可变的</li><li>NSJSONReadingMutableLeaves 被解析的数据如果既不是字典也不是数组，那么就使用这个</li></ul></li><li>第三个参数：错误信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary * dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&amp;error];</span><br></pre></td></tr></table></figure><h2 id="OC-转-JSON"><a href="#OC-转-JSON" class="headerlink" title="OC 转 JSON"></a>OC 转 JSON</h2><ul><li>第一个参数：要转换成JSON数据的OC对象，这里是一个字典</li><li>第二个参数：NSJSONWritingPrettyPrinted 对转换之后的JSON对象进行排版，无意义</li><li>第三个参数：错误信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSData *data = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;error];</span><br></pre></td></tr></table></figure><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><ul><li>XML 可扩展标记语言，是一种数据交互格式，也叫XML文档</li><li>XML 被设计用来传输和存储数据</li></ul><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>常见的XML文档由三部分组成</p><ul><li>文档声明</li></ul><p>在XML文档最前面，必须编写一个文档声明，用来声明XML文档的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 最简单的声明</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line"></span><br><span class="line">// 用encoding属性说明文档的字符编码</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br></pre></td></tr></table></figure><ul><li><p>元素</p><ul><li>一个元素包括了 <code>开始标签和结束标签</code>，</li><li>有内容的元素 <code>&lt;name&gt;Tom&lt;/name&gt;</code>；没内容的元素 <code>&lt;from&gt;&lt;/from&gt;</code>，可简写成 <code>&lt;from/&gt;</code></li><li>元素可嵌套其他元素，不可出现交叉嵌套</li></ul></li><li><p>属性</p></li></ul><p>一个元素最多可以拥有多个属性，属性值必须用双引号 <code>&quot; &quot;</code> 或 单引号 <code>&#39; &#39;</code> 括住</p><ul><li>示例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line">    &lt;person id=&quot;p1&quot;&gt;</span><br><span class="line">        &lt;name&gt;Tom&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;24&lt;/age&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><h2 id="XML-解析的方法"><a href="#XML-解析的方法" class="headerlink" title="XML 解析的方法"></a>XML 解析的方法</h2><p>要想从XML中提取信息，就得解析XML，目前针对XML的解析有两种方式：</p><ul><li>SAX：从根元素开始，按照顺序一个元素一个元素的往下解析，可用于解析大、小文件</li><li>DOM：一次性将整个XML文档加载到内存中，适合较小的文件</li></ul><p><code>iOS</code> 中解析 <code>XML</code> 有两种：</p><ul><li><p>苹果原生：使用 <code>NSXMLParse</code>，SAX方式解析，使用简答</p></li><li><p>第三方框架：<code>libxml2、GDataXML</code></p><ul><li><code>libxml2</code> 纯 c 语音，默认包含在iOS SDK中，同时支持DOM和SAX方式解析</li><li><code>GDataXMLDOM</code> 解析，由 <code>google</code> 基于 <code>libxml2</code> 开发</li></ul></li></ul><p>解析XML大文件建议用：<code>NSXMLParse、libxml2</code><br>解析XML小文件上述三种都可以</p><h2 id="NSXMLParse-使用"><a href="#NSXMLParse-使用" class="headerlink" title="NSXMLParse 使用"></a>NSXMLParse 使用</h2><ul><li><p>添加NSXMLParserDelegate协议</p></li><li><p>获取XML文件，初始化NSXMLParser，并开启解析</p></li><li><p>实现协议中的方法</p></li></ul><p><strong>XMLElement 文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@interface XMLElement : NSObject</span><br><span class="line">// 元素名称</span><br><span class="line">@property (nonatomic,strong)NSString *name;</span><br><span class="line">//元素节点文本</span><br><span class="line">@property (nonatomic,strong)NSMutableString *text;</span><br><span class="line">@property (nonatomic,strong)NSDictionary *attribute;</span><br><span class="line">@property (nonatomic,strong)XMLElement *parent;</span><br><span class="line">@property (nonatomic,strong)NSMutableArray&lt;XMLElement *&gt; *childElement;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">🔽</span><br><span class="line"></span><br><span class="line">#import &quot;XMLElement.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation XMLElement</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _text=[[NSMutableString alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (NSMutableArray&lt;XMLElement *&gt; *)childElement&#123;</span><br><span class="line">    if (!_childElement) &#123;</span><br><span class="line">        _childElement = [[NSMutableArray alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    return _childElement;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)description&#123;</span><br><span class="line">    NSDictionary *dic = [self convertToDic];</span><br><span class="line">    if ([NSJSONSerialization isValidJSONObject:dic]) &#123;</span><br><span class="line">        NSError *error;</span><br><span class="line">        NSData *jsonData=[NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;error];</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            return @&quot;&#123;&#125;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (jsonData) &#123;</span><br><span class="line">            @try &#123;</span><br><span class="line">                NSString *jsonStr = [[NSString alloc]initWithData:jsonData encoding:NSUTF8StringEncoding];</span><br><span class="line">                return jsonStr;</span><br><span class="line">            &#125; @catch (NSException *exception) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return @&quot;&#123;&#125;&quot;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">- (NSDictionary *)convertToDic&#123;</span><br><span class="line">    NSMutableDictionary *dic = [[NSMutableDictionary alloc] init];</span><br><span class="line">    if (self.name) &#123;</span><br><span class="line">        dic[self.name]=self.text;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.attribute &amp;&amp; self.attribute.count &gt; 0) &#123;</span><br><span class="line">        [dic addEntriesFromDictionary:self.attribute];</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.childElement &amp;&amp; self.childElement.count &gt; 0) &#123;</span><br><span class="line">        NSMutableArray *child=[[NSMutableArray alloc]init];</span><br><span class="line">        for (XMLElement *element in self.childElement) &#123;</span><br><span class="line">            NSDictionary *childDic = [element convertToDic];</span><br><span class="line">            if (element.childElement &amp;&amp; element.childElement.count &gt; 0) &#123;</span><br><span class="line">                [child addObject:childDic];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                [dic addEntriesFromDictionary:childDic];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (child.count &gt; 0) &#123;</span><br><span class="line">            dic[@&quot;child&quot;]=child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dic;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong>XMLParserManager 文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;XMLElement.h&quot;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">typedef void(^ParserXMLCompletion) (BOOL success, XMLElement * _Nullable data,NSError * _Nullable error);</span><br><span class="line">@interface XMLParserManager : NSObject</span><br><span class="line">@property(nonatomic,copy)ParserXMLCompletion completion;</span><br><span class="line">- (void)parserXMLWithUrl:(NSURL *)url completion:(ParserXMLCompletion)completion;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">🔽</span><br><span class="line"></span><br><span class="line">#import &quot;XMLParserManager.h&quot;</span><br><span class="line"></span><br><span class="line">@interface XMLParserManager()&lt;NSXMLParserDelegate&gt;</span><br><span class="line">@property (nonatomic,strong)NSXMLParser *parser;</span><br><span class="line">@property (nonatomic,strong)XMLElement *rootElement;</span><br><span class="line">@property (nonatomic,strong)XMLElement *currentElement;</span><br><span class="line">@end</span><br><span class="line">@implementation XMLParserManager</span><br><span class="line">- (void)parserXMLWithUrl:(NSURL *)url completion:(ParserXMLCompletion)completion&#123;</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        self.completion = completion;</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        NSInputStream *fileInput=[[NSInputStream alloc] initWithURL:url];</span><br><span class="line">        // 创建一个解析器</span><br><span class="line">        _parser = [[NSXMLParser alloc] initWithStream:fileInput];</span><br><span class="line">        // 设置代理</span><br><span class="line">        _parser.delegate = self;</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^&#123;</span><br><span class="line">            __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">            // 开始解析</span><br><span class="line">            [strongSelf.parser parse];</span><br><span class="line">            // 解析错误</span><br><span class="line">            if (weakSelf.parser.parserError) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    if (completion) &#123;</span><br><span class="line">                        completion(NO,nil,strongSelf.parser.parserError);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 文档开始</span><br><span class="line">-(void)parserDidStartDocument:(NSXMLParser *)parser&#123;</span><br><span class="line">    self.rootElement = nil;</span><br><span class="line">    self.currentElement = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 开始解析某个节点</span><br><span class="line"> parser xml对象</span><br><span class="line"> elementName 标签</span><br><span class="line"> namespaceURI 命名控件指向的链接</span><br><span class="line"> qName 命名控件名称</span><br><span class="line"> attributeDict 节点的所有属性</span><br><span class="line"> */</span><br><span class="line">-(void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary&lt;NSString *,NSString *&gt; *)attributeDict&#123;</span><br><span class="line"></span><br><span class="line">    if (!self.rootElement) &#123;</span><br><span class="line">        self.rootElement = [[XMLElement alloc]init];</span><br><span class="line">        self.currentElement = self.rootElement;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        XMLElement *element = [[XMLElement alloc]init];</span><br><span class="line">        // 父节点</span><br><span class="line">        element.parent = self.currentElement;</span><br><span class="line">        // 当前元素的子节点</span><br><span class="line">        [self.currentElement.childElement addObject:element];</span><br><span class="line">        element.name = elementName;</span><br><span class="line">        // 更换当前元素</span><br><span class="line">        self.currentElement = element;</span><br><span class="line">    &#125;</span><br><span class="line">    // 元素名和属性</span><br><span class="line">    self.currentElement.name = elementName;</span><br><span class="line">    self.currentElement.attribute = attributeDict;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当解析器找到开始标记和结束标记之间的字符时，调用这个方法解析当前节点的所有字符</span><br><span class="line">- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string&#123;</span><br><span class="line">    // 获取当前元素的内容</span><br><span class="line">    [self.currentElement.text appendString:string];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结束解析</span><br><span class="line">-(void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName&#123;</span><br><span class="line">    self.currentElement = self.currentElement.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文档结束</span><br><span class="line">-(void)parserDidEndDocument:(NSXMLParser *)parser&#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    if (self &amp;&amp; self.completion) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">            strongSelf.completion(YES, strongSelf.rootElement, nil);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解析失败</span><br><span class="line">- (void)parser:(NSXMLParser *)parser validationErrorOccurred:(NSError *)validationError&#123;</span><br><span class="line">    if (self.completion) &#123;</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">            strongSelf.completion(NO, nil,validationError);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong>VC 调用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;XMLParserManager.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,strong)XMLParserManager *manager;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    [self parserXML];</span><br><span class="line">&#125;</span><br><span class="line">-(void)parserXML&#123;</span><br><span class="line">    NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;xmlText&quot; ofType:@&quot;xml&quot;];</span><br><span class="line">    NSURL *url = [NSURL fileURLWithPath:path];</span><br><span class="line">    _manager=[[XMLParserManager alloc]init];</span><br><span class="line">    [_manager parserXMLWithUrl:url completion:^(BOOL success, XMLElement * _Nullable data, NSError * _Nullable error) &#123;</span><br><span class="line">            if (success) &#123;</span><br><span class="line">                NSLog(@&quot;%@&quot;,data);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                NSLog(@&quot;error = %@&quot;,error);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    NSLog(@&quot;start == &quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="GDataXML-使用"><a href="#GDataXML-使用" class="headerlink" title="GDataXML 使用"></a>GDataXML 使用</h2><ul><li>GDataXMLDocument：xml解析入口</li><li>GdataXMLElement：保存查找的数据</li><li>GdataXMLNode：保存解析的数据</li></ul><p><strong>第一步：集成 GDataXML-HTML</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target &#x27;XML文件解析&#x27; do</span><br><span class="line">  # Comment the next line if you don&#x27;t want to use dynamic frameworks</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  pod &#x27;GDataXML-HTML&#x27;, &#x27;~&gt; 1.4.1&#x27;</span><br><span class="line"></span><br><span class="line">  # Pods for XML文件解析</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>第二步：项目中配置</strong></p><ul><li><p>pod 安装 GDataXML</p></li><li><p>选中target -&gt; Build Settings -&gt; Link Binary With Libraried，搜索添加 <code>libxml2</code></p></li><li><p>Header Search Paths 添加 <code>/usr/include/libxml2</code> </p></li><li><p>Other Linker Flags 添加 <code>-lxml2</code></p></li><li><p>引入头文件使用</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)GDataParserXML&#123;</span><br><span class="line">    // 加载xmlwen文件</span><br><span class="line">    NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;xmlText&quot; ofType:@&quot;xml&quot;];</span><br><span class="line">    NSURL *url = [NSURL fileURLWithPath:path];</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfURL:url];</span><br><span class="line">    NSError *error= nil;</span><br><span class="line">    GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithData:data error:&amp;error];</span><br><span class="line">    // 拿到根元素，得到根元素下所有子孙元素</span><br><span class="line">    NSArray * elementList =[doc.rootElement elementsForName:@&quot;book&quot;];</span><br><span class="line">    for (GDataXMLElement *element in elementList) &#123;</span><br><span class="line">        NSString *title=((GDataXMLElement *)[[element elementsForName:@&quot;title&quot;] firstObject]).stringValue;</span><br><span class="line">        NSString *author=((GDataXMLElement *)[[element elementsForName:@&quot;author&quot;] firstObject]).stringValue;</span><br><span class="line">        NSString *year=((GDataXMLElement *)[[element elementsForName:@&quot;year&quot;] firstObject]).stringValue;</span><br><span class="line">        NSString *price=((GDataXMLElement *)[[element elementsForName:@&quot;price&quot;] firstObject]).stringValue;</span><br><span class="line">        NSLog(@&quot;title = %@  author = %@  year = %@ price = %@&quot;,title,author,year,price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习45：扩展</title>
      <link href="/BboyZJ.github.io/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A045%EF%BC%9A%E6%89%A9%E5%B1%95/"/>
      <url>/BboyZJ.github.io/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A045%EF%BC%9A%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇将详细总结介绍Swift扩展的用法：</p><ul><li><p>扩展就是<code> 为现有的类、结构体、枚举类型或者协议类型添加新功能</code></p></li><li><p>扩展和 <code>Objective-C</code> 中的 <code>category</code> 类似，与 <code>Objective-C</code> 不同的是扩展 <code>没有名字</code></p></li></ul><h1 id="extension-的能力"><a href="#extension-的能力" class="headerlink" title="extension 的能力"></a>extension 的能力</h1><ul><li>可以添加 <code>计算型实例属性</code> 和 <code>计算型类型属性</code>。</li><li>可以添加 <code>实例方法和类型方法</code></li><li>可以添加 <code>新的初始化器</code></li><li>可以添加 <code>下标脚本</code> </li><li>可以使现有的 <code>类型遵循某协议</code></li><li>定义和使用 <code>新内嵌类型</code></li><li>扩展 <code>可以向一个类型添加新的方法</code>，但是<code>不能重写已有的方法</code></li></ul><blockquote><p>使用注意：</p></blockquote><ul><li>不可以添加 <code>存储属性</code>，也不可以为已有属性添加属性观察器</li><li>扩展中不能为 <code>类</code> 添加 <code>新的构造器</code>，因为 <code>新的构造器和结构器</code> 必须由原始的类来实现</li></ul><h1 id="添加计算属性"><a href="#添加计算属性" class="headerlink" title="添加计算属性"></a>添加计算属性</h1><ul><li>扩展 <code>不可以添加存储型属性，也不可以为已有属性添加属性观察器</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extension Double&#123;</span><br><span class="line">    // 注意：扩展不能扩展存储型属性</span><br><span class="line">    // var km: Double = 0.0 //报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/BboyZJ.github.io/assets/16783717667666.jpg"></p><ul><li>扩展可以添加新的计算型属性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extension Double &#123;</span><br><span class="line">    // 注意：扩展不能添加存储属性</span><br><span class="line">    //    var km: Double = 0.0</span><br><span class="line">    // 计算属性</span><br><span class="line">    var km: Double &#123; return self * 1_000.0&#125;</span><br><span class="line">    var m: Double &#123; return self &#125;</span><br><span class="line">    var cm: Double &#123; return self / 100.0 &#125;</span><br><span class="line">    var mm: Double &#123; return self / 1_000.0 &#125;</span><br><span class="line">    var ft: Double &#123; return self / 3.28084 &#125;</span><br><span class="line">&#125;</span><br><span class="line">let oneInch = 25.4</span><br><span class="line">print(&quot;one inch is \(oneInch) meters&quot;)</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">one inch is 25.4 meters</span><br></pre></td></tr></table></figure><h1 id="添加初始化器"><a href="#添加初始化器" class="headerlink" title="添加初始化器"></a>添加初始化器</h1><ul><li><p>扩展能为 <code>已有的类型添加新的初始化器</code></p></li><li><p>扩展能为 <code>类添加新的便捷初始化器</code>，不能为类添加 <code>指定初始化器或反初始化器</code>，指定初始化器或反初始化器 <code>必须由原来的类实现提供</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct Size &#123;</span><br><span class="line">    var width = 0.0, height = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Rect &#123;</span><br><span class="line">    var origin = Point()</span><br><span class="line">    var size = Size()</span><br><span class="line">&#125;</span><br><span class="line">extension Rect&#123;</span><br><span class="line">    // 新的初始化器</span><br><span class="line">    init(center:Point, size:Size) &#123;</span><br><span class="line">        let origin_x = center.x - size.width/2</span><br><span class="line">        let origin_y = center.y - size.height/2</span><br><span class="line">        // 新的初始化器必须调用指定初始化器</span><br><span class="line">        self.init(origin:Point(x: origin_x, y: origin_y),size:size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let rect3 = Rect(center: Point(x:200, y:200), size: Size(width: 100, height: 100))</span><br></pre></td></tr></table></figure><h1 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h1><ul><li>扩展可以为 <code>已有的类型</code> 添加新的 <code>实例方法和类方法</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 添加方法</span><br><span class="line">extension Int &#123;</span><br><span class="line">    // 实例方法</span><br><span class="line">    func repetions(task: () -&gt; Void) &#123;</span><br><span class="line">        for _ in 0..&lt;self &#123;</span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3.repetions &#123;</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="添加异变方法"><a href="#添加异变方法" class="headerlink" title="添加异变方法"></a>添加异变方法</h1><ul><li><p>通过 <code>mutationg</code> 关键字，可以 <code>修改(或异变)实例方法本身</code></p></li><li><p><code>struct</code> 和 <code>enum</code> 在修改self或本身属性时必须标记实例方法为 <code>mutating</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension Int &#123;</span><br><span class="line">    mutating func square() &#123;</span><br><span class="line">        self = self * self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var someInt = 3</span><br><span class="line">someInt.square()</span><br><span class="line">print(someInt)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h1 id="添加下标"><a href="#添加下标" class="headerlink" title="添加下标"></a>添加下标</h1><ul><li>扩展可以为已有类型添加新下标脚本。</li></ul><blockquote><p>被除数 ➗ 除数 &#x3D; 商 …. 余数<br>示例：获取 12345 的第 3 位数<br>推导过程：被除数 ➗ 10^位数次方 &#x3D; 商（前面的几位数）… 余数（剩下的几位数），如 12345 ➗ 10^3 &#x3D; 123 …. 45<br>被除数 ➗ 10 &#x3D; 第 3 位数，123 ➗ 10 &#x3D; 12 …. 3 余数是3 </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">extension Int &#123;</span><br><span class="line">    subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        var base = 1</span><br><span class="line">        for i in 0..&lt;index &#123;</span><br><span class="line">            base *= 10</span><br><span class="line">        &#125;</span><br><span class="line">        return (self / base) % 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(746381295[0])</span><br><span class="line">print(746381295[1])</span><br><span class="line">print(746381295[2])</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line">5</span><br><span class="line">9</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h1 id="添加内嵌类型"><a href="#添加内嵌类型" class="headerlink" title="添加内嵌类型"></a>添加内嵌类型</h1><ul><li>扩展可以为已有的 <code>类、结构体和枚举添加新的内嵌类型</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 添加内嵌类型</span><br><span class="line">extension Int &#123;</span><br><span class="line">    enum Kind &#123;</span><br><span class="line">        // 负数 0 正数</span><br><span class="line">        case neg,zero,pos</span><br><span class="line">    &#125;</span><br><span class="line">    var kind: Kind &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            return .zero</span><br><span class="line">        case let x where x &gt; 0:</span><br><span class="line">            return .pos</span><br><span class="line">        default:</span><br><span class="line">            return .neg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(8.kind)</span><br><span class="line">print(0.kind)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">pos</span><br><span class="line">zero</span><br></pre></td></tr></table></figure><h1 id="通过扩展集合类型Collection给的元素添加限制"><a href="#通过扩展集合类型Collection给的元素添加限制" class="headerlink" title="通过扩展集合类型Collection给的元素添加限制"></a>通过扩展集合类型Collection给的元素添加限制</h1><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 协议扩展添加约束条件</span><br><span class="line">extension Collection where Element: Equatable &#123;</span><br><span class="line">    func allEqual() -&gt; Bool &#123;</span><br><span class="line">        for element in self &#123;</span><br><span class="line">            if element != self.first &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let equalNumbers = [100, 100, 100, 100, 100]</span><br><span class="line">let differentNumbers = [100, 100, 200, 100, 200]</span><br><span class="line"></span><br><span class="line">print(equalNumbers.allEqual())</span><br><span class="line">print(differentNumbers.allEqual())</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习46：协议和扩展</title>
      <link href="/BboyZJ.github.io/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A046%EF%BC%9A%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%89%A9%E5%B1%95/"/>
      <url>/BboyZJ.github.io/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A046%EF%BC%9A%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="在扩展里添加协议遵循"><a href="#在扩展里添加协议遵循" class="headerlink" title="在扩展里添加协议遵循"></a>在扩展里添加协议遵循</h1><ul><li><p>你可以扩展一个 <code>已存在的类</code> 来遵循一个新的协议</p></li><li><p>扩展可以添加新的 <code>属性、方法和下标</code> 到已存在的类型，并且允许你添加协议的任何需要</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protocol TextRepresentable &#123;</span><br><span class="line">    var textDesc: String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 扩展已存在类遵循新协议</span><br><span class="line">extension Dice: TextRepresentable &#123;</span><br><span class="line">    var textDesc: String &#123;</span><br><span class="line">        return &quot;zhangjian&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有条件的遵循协议"><a href="#有条件的遵循协议" class="headerlink" title="有条件的遵循协议"></a>有条件的遵循协议</h1><ul><li><p><code>泛型</code> 可能只在某些情况下满足一个 <code>协议</code> 的要求</p></li><li><p>当 <code>类</code> 的 <code>泛型形式参数</code> 遵循协议时。你可以通过 <code>扩展</code> 列出限制 <code>泛型</code> 有条件的遵循某协议。在协议名字后面写泛型 <code>where</code> 关键字</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="使用扩展声明协议"><a href="#使用扩展声明协议" class="headerlink" title="使用扩展声明协议"></a>使用扩展声明协议</h1><ul><li>如果一个 <code>类型（类、结构体、枚举）</code> 已经遵循了协议的所有需求，但还没有 声明它采纳这个协议，你可以通过 <code>扩展来让它声明并采纳</code> 这个协议</li></ul><blockquote><p>定义协议：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 定义协议</span><br><span class="line">protocol TextRepresentable &#123;</span><br><span class="line">    var textDesc: String &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义结构体类型：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Hamster &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    // 实现了 遵循协议的所有要求</span><br><span class="line">    var textDesc: String &#123;</span><br><span class="line">        return &quot;a hamster named \(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以通过 扩展 来让 Hamster 遵循 协议：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension Hamster: TextRepresentable &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="协议本身扩展"><a href="#协议本身扩展" class="headerlink" title="协议本身扩展"></a>协议本身扩展</h1><ul><li>协议可以通过 <code>扩展</code> 来提供 <code>属性、方法</code>，即 协议本身支持扩展</li></ul><p>示例：</p><p>【第一步】：定义一个随机数协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 定义协议</span><br><span class="line">protocol RandomNumberGenerator &#123;</span><br><span class="line">    func random() -&gt; Double</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【第二步】：生成随机数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 生成随机数</span><br><span class="line">class LinearCongruentialGenerator: RandomNumberGenerator &#123;</span><br><span class="line">    var lastRandom = 42.0</span><br><span class="line">    let m = 139968.0</span><br><span class="line">    let a = 3877.0</span><br><span class="line">    let c = 29573.0</span><br><span class="line">    func random() -&gt; Double &#123;</span><br><span class="line">        lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m))</span><br><span class="line">        return lastRandom / m</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【第三步】：让协议本身扩展</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 协议本身支持扩展</span><br><span class="line">extension RandomNumberGenerator &#123;</span><br><span class="line">    func randomBool() -&gt; Bool &#123;</span><br><span class="line">        return random() &gt; 0.5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【最后】：调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let generator = LinearCongruentialGenerator()</span><br><span class="line">print(&quot;here is random number \(generator.random())&quot;)</span><br><span class="line">print(&quot;and here is random bool \(generator.randomBool())&quot;)</span><br><span class="line"></span><br><span class="line">==========</span><br><span class="line">here is random number 0.3746499199817101</span><br><span class="line">and here is random bool true</span><br></pre></td></tr></table></figure><h1 id="提供默认实现"><a href="#提供默认实现" class="headerlink" title="提供默认实现"></a>提供默认实现</h1><ul><li><p>可以使用 <code>协议扩展</code> 给协议的 <code>属性或方法</code> 提供默认实现。</p></li><li><p>如果遵循协议的 <code>类型</code> 提供了自己的实现，会 <code>替代协议扩展中的实现</code></p></li></ul><h1 id="给集合类和其中的元素添加-协议扩展"><a href="#给集合类和其中的元素添加-协议扩展" class="headerlink" title="给集合类和其中的元素添加 协议扩展"></a>给集合类和其中的元素添加 协议扩展</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 有条件的遵循协议</span><br><span class="line">protocol TextRepresentable &#123;</span><br><span class="line">    var textDesc: String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 定义一个结构体 Person</span><br><span class="line">struct Person &#123;</span><br><span class="line">    var name:String = &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">// 扩展 Person 遵循协议</span><br><span class="line">extension Person: TextRepresentable&#123;</span><br><span class="line">    var textDesc: String &#123;</span><br><span class="line">        return &quot;name \(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 扩展数组元素都遵循协议</span><br><span class="line">extension Array: TextRepresentable where Element: TextRepresentable &#123;</span><br><span class="line">    var textDesc: String &#123;</span><br><span class="line">        let items = self.map &#123; $0.textDesc &#125;</span><br><span class="line">        return items.joined(separator: &quot;,&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let array = [Person(name: &quot;zj&quot;),Person(name: &quot;wxy&quot;)]</span><br><span class="line">print(array.textDesc)</span><br><span class="line"></span><br><span class="line">==========</span><br><span class="line">name zj,name wxy</span><br></pre></td></tr></table></figure><h1 id="给-协议扩展-添加限制"><a href="#给-协议扩展-添加限制" class="headerlink" title="给 协议扩展 添加限制"></a>给 协议扩展 添加限制</h1><ul><li>在 <code>扩展协议后</code> 面用 <code>where</code> 来写这些限制</li></ul><p>将上面的 <code>Array</code> 改成 <code>Collection协议</code>，查看打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 扩展数组元素都遵循协议</span><br><span class="line">extension Collection where Iterator.Element: TextRepresentable &#123;</span><br><span class="line">    var textDesc: String &#123;</span><br><span class="line">        let items = self.map &#123; $0.textDesc &#125;</span><br><span class="line">        return items.joined(separator: &quot;,&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==========</span><br><span class="line">name zj,name wxy</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>除了可以给具体的 <code>类、结构体</code> 扩展以外，还可以 <code>扩展协议本身</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习44：协议</title>
      <link href="/BboyZJ.github.io/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A044%EF%BC%9A%E5%8D%8F%E8%AE%AE/"/>
      <url>/BboyZJ.github.io/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A044%EF%BC%9A%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>熟悉Objective-C语言的同学们肯定对协议都不陌生，在Swift中苹果将 <code>protocol</code> 这种语法发扬的更加深入和彻底。Swift中的 <code>protocol</code> 不仅能定义方法还能定义属性，配合 <code>extension</code> 扩展的使用还能提供一些方法的默认实现，而且不仅类可以遵循协议，现在的 <code>枚举和结构体</code> 也能遵循协议了。基于此本文从:</p><p>1、协议中定义属性和方法<br>2、协议的继承、组合、关联类型，<br>3、协议的扩展，<br>4、Swift标准库中常见的协议<br>5、为什么要使用协议</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul><li><p>协议 <code>规定了用来实现某一特定功能所必须的属性和方法</code>，这个属性指 <code>实例属性或类型属性</code>，而不用指定是 <code>存储属性或计算属性</code></p></li><li><p><code>类、结构体、枚举</code> 都可以遵循协议，<code>提供具体的实现</code> 来完成协议定义的 <code>属性和方法</code></p></li></ul><h1 id="协议的语法"><a href="#协议的语法" class="headerlink" title="协议的语法"></a>协议的语法</h1><ul><li><p>自定义类声明协议时，协议名放在类名的冒号 <code>:</code> 之后，多个协议用逗号分开</p></li><li><p>若是一个类拥有父类，应该将父类名放在遵循的协议名之前，以逗号分隔。</p></li></ul><p>定义协议：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 单个协议</span><br><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    // dosomething</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遵守协议：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 多个协议</span><br><span class="line">protocol SomeStruct: FirstProtocol,AnotherProtocol &#123;</span><br><span class="line">    // structure definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个类既有父类，有遵守其他协议时，将父类名写在遵守协议的前面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 继承父类</span><br><span class="line">class SomeClass: SomeSuperClass,FirstProtocol,AnotherProtocol &#123;</span><br><span class="line">    // class definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h1><p>协议可以要求遵循协议的类型提供特定名称和类型的 <code>实例属性或类型属性</code>。协议不具体说明属性是存储属性还是计算属性，它只具体要求 <code>属性有特定的名称和类型</code>。</p><ul><li><p>协议同时要求一个 <code>属性</code> 必须 <code>明确</code> 是 <code>可读的/可读可写</code> 的，类型声明后加上 <code>&#123; set get &#125;</code> 来表示属性是 <code>可读可写</code> 的；</p></li><li><p>协议要求 <code>属性</code> 为 <code>变量类型</code> ，用 <code>var</code> 修饰，而不是let</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    var mustBeSettable: Int &#123; get set &#125;          // 可读可写</span><br><span class="line">    var doesNotNeedToBeSettable: Int &#123; get &#125;     // 可读</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>协议定义 <code>类型属性</code> 时，前面添加 <code>static</code> 关键字。当类的实现使用 <code>class</code> 或 <code>static</code> 关键字声明属性时，这个规则仍适用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol AnotherProtocol &#123;</span><br><span class="line">    static var someTypeProperty: Int &#123; get set &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protocol Student &#123;</span><br><span class="line">    // 定义一个可读可写的 name 属性</span><br><span class="line">    var name: String &#123; get set &#125;</span><br><span class="line">    // 定义一个可读的 birthPlace 属性</span><br><span class="line">    var birthPlace: String &#123; get &#125;</span><br><span class="line">    // 定义一个类属性 record</span><br><span class="line">    static var qualification: String &#123;get&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和定义方法一样，我们只需要确定该属性具体是什么类型并且添加对应的关键字，不需要具体的实现，更不能为他们赋上初始值（类似于计算属性）。定义好属性之后，我们就可以利用属性来做点事情了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Puple: Student &#123;</span><br><span class="line">    static var qualification: String = &quot;小学&quot;</span><br><span class="line">    var name: String</span><br><span class="line">    var birthPlace: String = &quot;北京&quot;</span><br><span class="line">&#125;</span><br><span class="line">var p1 = Puple(name: &quot;小明&quot;, birthPlace: &quot;上海&quot;)</span><br></pre></td></tr></table></figure><p>定义一个 <code>Puple</code> 结构体遵循 <code>Student</code> 协议，该结构体中必须存在协议要求声明的三个属性 <code>matrikelnummer、name、birthPlace</code>, <code>static</code> 修饰的 <code>类型属性</code> 必须被有初始值或者存在 <code>get、set</code> 方法。对于普通的实例属性协议并不关心是计算型属性还是存储型属性。实例中的属性同样可以被修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p1 = Puple(name: &quot;小明&quot;, birthPlace: &quot;上海&quot;)</span><br><span class="line">Puple.qualification = &quot;中学&quot;</span><br></pre></td></tr></table></figure><p>看到这里有的同学可能有些疑问，<code>birthPlace、qualification</code> 明明只有 <code>get</code> 方法为什么却可以修改赋值呢？其实协议中的“只读”属性修饰的是协议这种“类型”的实例，例如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s1: Student = p1</span><br><span class="line">s1.birthPlace = &quot;广州&quot;</span><br></pre></td></tr></table></figure><p>虽然我们并不能像创建类的实例那样直接创建协议的实例，但是我们可以通过“赋值”得到一个协议的实例。将 <code>p1</code> 的值赋值给 <code>Student</code> 类型的变量 <code>s1</code>,修改 <code>s1</code> 的 <code>birthPlace</code> 属性时编译器就会报错：<code>birthPlace</code> 是一个只读的属性，不能被修改。如果 <code>Puple</code> 中还存在 <code>Student</code> 没有的属性，那么在赋值过程中 <code>s1</code> 将不会存在这样的属性，尽管这样做的意义并不大，但是我们从中知道了协议中 <code>get、set</code> 的具体含义。</p><h1 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h1><ul><li>协议可以定义 <code>实例方法和类方法</code>，书写方式与正常的 <code>实例方法和类方法相同</code>。协议定义 <code>类方法</code> 时，添加 <code>static</code> 关键字，当类的实现使用 <code>class</code> 或 <code>static</code> 关键字声明属性时，这个规则仍适用。方法的参数 <code>不能有默认值</code>（Swift认为默认值也是一种变相的实现），在遵守该协议的类型中具体实现方法的细节，通过类或实例调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    static func someTypeMethod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protocol Student &#123;</span><br><span class="line">    //类方法</span><br><span class="line">    static func study()</span><br><span class="line">    //实例方法</span><br><span class="line">    func changeName()</span><br><span class="line">&#125;</span><br><span class="line">struct CollageStudent: Student &#123;</span><br><span class="line">    //类方法实现</span><br><span class="line">    static func study() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    //实例方法实现</span><br><span class="line">    func changeName() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//方法的调用</span><br><span class="line">CollageStudent.study()</span><br><span class="line">var c1 = CollageStudent()</span><br><span class="line">c1.changeName()</span><br></pre></td></tr></table></figure><p>注意：当我们在结构体中的方法修改到属性的时候需要在方法前面加上关键字 <code>mutating</code> 表示该属性能够被修改（如果是类不需要添加mutating 关键字）,这样的方法叫做：<code>异变方法</code>，和 “在实例方法中修改值类型” 的处理是一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protocol Student &#123;</span><br><span class="line">    mutating func changeName()</span><br><span class="line">&#125;</span><br><span class="line">struct CollageStudent: Student &#123;</span><br><span class="line">    mutating func changeName() &#123;</span><br><span class="line">        self.name = &quot;小明&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var c1 = CollageStudent()</span><br><span class="line">c1.changeName()</span><br></pre></td></tr></table></figure><h1 id="定义-mutating-异变方法"><a href="#定义-mutating-异变方法" class="headerlink" title="定义 mutating 异变方法"></a>定义 mutating 异变方法</h1><ul><li>在协议中，可变实例方法使用关键字 <code>mutating</code> 作前缀。在类中实现该方法时不需要写 <code>mutating</code> 关键字。mutating关键字仅供 <code>结构体和枚举使用</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// mutating</span><br><span class="line">protocol Togglable &#123;</span><br><span class="line">    mutating func toggle()</span><br><span class="line">&#125;</span><br><span class="line">enum OnOffSwitch: Togglable &#123;</span><br><span class="line">    case off,on</span><br><span class="line">    mutating func toggle() &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .on:</span><br><span class="line">            self = .on</span><br><span class="line">        default:</span><br><span class="line">            self = .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var lightSwitch = OnOffSwitch.off</span><br><span class="line">lightSwitch.toggle()</span><br><span class="line">print(lightSwitch)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">off</span><br></pre></td></tr></table></figure><h1 id="定义初始化"><a href="#定义初始化" class="headerlink" title="定义初始化"></a>定义初始化</h1><ul><li>协议允许定义 <code>指定的初始化器</code>，和一般初始化器一样，只是不用写大括号也就是初始化器的实体</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    init(someParameter: Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>你可以通过实现 <code>指定的初始化器或便捷初始化器</code> 来使遵循该协议的 <code>类</code> 满足协议的初始化器要求。</p></li><li><p>在这两种情况下，你必须使用 <code>required</code> 关键字修饰初始化器的实现</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protocol Pet &#123;</span><br><span class="line">    init(name: String)</span><br><span class="line">&#125;</span><br><span class="line">class Cat: Pet &#123;</span><br><span class="line">    var name: String = &quot;Cat&quot;</span><br><span class="line">    required init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Cat</code> 由于遵循了 <code>Pet</code> 协议，应该用 <code>required</code> 关键字修饰初始化器的具体实现。<br>如果一个 <code>类</code> 既继承了某个类，而且遵循了一个或多个协议，我们应该将父类放在最前面，然后依次用逗号排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass: OneProtocol, TwoProtocol &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为Swift中类的继承是单一的，但是类可以遵守多个协议，因此为了突出其单一父类的特殊性，我们应该将继承的父类放在最前面，将遵守的协议依次放在后面。</p><blockquote><p>注意：在使用 <code>final关键字修饰的类</code>，不需要使用 <code>required关键字</code> 标记协议构造器的实现。</p></blockquote><ul><li>如果 <code>子类重写了父类的一个指定初始化器</code>，并且 <code>遵循协议</code> 实现了初始化器要求，那么就要为这个初始化器的实现添加 <code>required</code> 和 <code>override</code> 两个修饰符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 协议</span><br><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    init()</span><br><span class="line">&#125;</span><br><span class="line">// 父类</span><br><span class="line">class SomeSuperClass &#123;</span><br><span class="line">    init() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子类</span><br><span class="line">class SomeClass: SomeSuperClass,SomeProtocol &#123;</span><br><span class="line">    init() &#123;</span><br><span class="line">      //   </span><br><span class="line">    &#125;</span><br><span class="line">    required override init() &#123;</span><br><span class="line">        // initializer ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多个协议重名方法调用冲突</li></ul><p>由于在Swift中并没有规定不同的协议内方法不能重名（这样的规定也是不合理的）。因此我们在自定义多个协议中方法重名的情况是可能出现的，比如存在TextOne、TextTwo两个协议，定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protocol TextOne &#123;</span><br><span class="line">    func text() -&gt; Int</span><br><span class="line">&#125;</span><br><span class="line">protocol TextTwo &#123;  </span><br><span class="line">    func text() -&gt; String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个协议中的 <code>text()</code> 方法名相同返回值不同，如果存在一个类型 <code>Person</code> 同时遵守了 <code>TextOne</code> 和 <code>TextTwo</code>，在Person实例调用方法的时候就会出现歧义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Person: TextOne, TextTwo &#123;</span><br><span class="line">    func text() -&gt; Int &#123;</span><br><span class="line">        return 10</span><br><span class="line">    &#125;</span><br><span class="line">    func text() -&gt; String &#123; </span><br><span class="line">        return &quot;hello&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1 = Person()</span><br><span class="line">// 尝试调用返回值为Int的方法</span><br><span class="line">let num = p1.text()</span><br><span class="line">// 尝试调用返回值为String的方法</span><br><span class="line">let string = p1.text()</span><br></pre></td></tr></table></figure><p>上面的调用肯定是无法通过的，因为编译器无法知道同名 <code>text()</code> 方法到底是哪个协议中的方法，那么出现这种情况的根本原因在于调用哪个协议的 <code>text()</code> 不确定，因此我们需要指定调用特定协议的<code>text()</code> 方法，改进后的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 尝试调用返回值为Int的方法</span><br><span class="line">let num = (p1 as TextOne).text()</span><br><span class="line">// 尝试调用返回值为String的方法</span><br><span class="line">let string = (p1 as TextTwo).text()</span><br></pre></td></tr></table></figure><p>也可以理解为在进行调用前将 <code>p1</code> 常量进行 <code>类型转换</code>。</p><h1 id="将协议作为类型"><a href="#将协议作为类型" class="headerlink" title="将协议作为类型"></a>将协议作为类型</h1><ul><li>作为 <code>函数、方法或者初始化器的形式参数类型或返回类型</code></li><li>作为 <code>常量、变量或者属性的类型</code></li><li>作为 <code>数组、字典或者其他存储器的元素的类型</code></li></ul><p>首先，以下代码，通过继承基类实现的方式，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Shape&#123;</span><br><span class="line">    // 计算属性</span><br><span class="line">    var area: Double&#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Circle: Shape&#123;</span><br><span class="line">    // 半径</span><br><span class="line">    var radius: Double</span><br><span class="line">   </span><br><span class="line">    // 构造器</span><br><span class="line">    init(_ radius: Double) &#123;</span><br><span class="line">        self.radius = radius</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 重写父类的属性</span><br><span class="line">    override var area: Double&#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            return radius * radius * 3.14</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Rectangle: Shape&#123;</span><br><span class="line">    var width, height: Double</span><br><span class="line">    init(_ width: Double, _ height: Double) &#123;</span><br><span class="line">        self.width = width</span><br><span class="line">        self.height = height</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override var area: Double&#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            return width * height</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var circle: Shape = Circle.init(10.0)</span><br><span class="line">var rectangle: Shape = Rectangle.init(10.0, 20.0)</span><br><span class="line"></span><br><span class="line">var shapes: [Shape] = [circle, rectangle]</span><br><span class="line">for shape in shapes&#123;</span><br><span class="line">    print(shape.area)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">314.0</span><br><span class="line">200.0</span><br></pre></td></tr></table></figure><p>改为协议的方式实现，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1. 将Shape改为protocol类型</span><br><span class="line">// 2. 删除实现该协议的类的协议方法前缀override</span><br><span class="line">protocol Shape &#123;</span><br><span class="line">    var area: Double &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="协议继承"><a href="#协议继承" class="headerlink" title="协议继承"></a>协议继承</h1><p>官方文档说明：</p><blockquote><p>协议可以继承一个或者多个其他协议并且可以在它继承的基础之上添加更多要求。协议继承的语法与类继承的语法相似，选择列出多个继承的协议，使用逗号分隔。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protocol OneProtocol &#123;  </span><br><span class="line">&#125;</span><br><span class="line">protocol TwoProtocol &#123;</span><br><span class="line">&#125;</span><br><span class="line">// 定义一个继承子OneProtocol 和 TwoProtocol协议的新的协议: ThreeProtocol</span><br><span class="line">protocol ThreeProtocol: OneProtocol, TwoProtocol &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，任何遵守了 <code>ThreeProtocol</code> 协议的类型都应该同时实现 <code>OneProtocol</code> 和 <code>TwoProtocol</code> 的要求 <code>必须实现的方法或属性</code>。</p><h1 id="类专属的协议"><a href="#类专属的协议" class="headerlink" title="类专属的协议"></a>类专属的协议</h1><ul><li>通过添加 <code>AnyObject</code> 关键字到协议的继承列表，你就可以 <code>限制协议只能被类类型采用</code>（并且不是结构体或枚举）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeClassOnlyProtocol: AnyObject,SomeProtocol &#123;</span><br><span class="line">    // structure definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="协议组合"><a href="#协议组合" class="headerlink" title="协议组合"></a>协议组合</h1><p>日常开发中要求一个类型同时遵守多个协议是很常见的，除了使用协议的继承外我们还可以使用形如 <code>OneProtocol &amp; TwoProtocol</code> 的形式实现 <code>协议聚合（组合）</code> 复合多个协议到一个要求里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 协议聚合成临时的类型</span><br><span class="line">typealias Three = TwoProtocol &amp; OneProtocol</span><br><span class="line">// 协议聚合成为参数的类型</span><br><span class="line">func text(paramter: OneProtocol &amp; TwoProtocol) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 协议组合</span><br><span class="line">protocol Named &#123;</span><br><span class="line">    var name: String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line">protocol Aged &#123;</span><br><span class="line">    var age: Int &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct Person: Named,Aged &#123;</span><br><span class="line">    // 如果这个地方不定义属性会报错</span><br><span class="line">    // name属性是可读可写的，满足协议可读的要求</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = Person(name: &quot;ZJ&quot;, age: 30)</span><br><span class="line"></span><br><span class="line">// 满足了两个协议的要求，才能传递 参数</span><br><span class="line">func wish(to: Named &amp; Aged) &#123;</span><br><span class="line">    print(&quot;name \(to.name) age \(to.age)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wish(to: p)</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">name ZJ age 30</span><br></pre></td></tr></table></figure><p><strong>继承和聚合在使用上的区别：</strong></p><p>善于思考的同学可以发现，要实现上面的 “paramter参数的类型是遵守OneProtocol 和 TwoProtoco” 的效果，完全可以使用协议的继承，新定义一个协议ThreeProtocol继承自OneProtocol 和TwoProtocol，然后指定paramter参数的类型是ThreeProtocol类型。那么这两种方法有何区别呢？</p><p>首先协议的继承是定义了一个全新的协议，我们是希望它能够“大展拳脚”得到普遍使用。而协议的聚合不一样，它并没有定义新的固定协议类型，相反，它只是定义一个临时的拥有所有聚合中协议要求组成的局部协议，很可能是“一次性需求”，使用协议的聚合保持了代码的简洁性、易读性，同时去除了定义不必要的新类型的繁琐，并且定义和使用的地方如此接近，见明知意，也被称为匿名协议聚合。但是使用了匿名协议聚合能够表达的信息就少了一些，所以需要开发者斟酌使用。</p><h1 id="可选协议要求"><a href="#可选协议要求" class="headerlink" title="可选协议要求"></a>可选协议要求</h1><ul><li>当协议中 <code>某些方法或属性不需要遵守协议</code> 的类型实现时，使用关键字 <code>optional</code> 来指明；</li><li>协议和可选需求都必须用 <code>@objc</code> 属性标记；</li><li><code>@objc</code> 协议只能被继承自 <code>Objective-C</code> 类或其他 <code>@objc</code> 类使用，不能被结构体或枚举采纳</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 可选</span><br><span class="line">@objc protocol CounterDataSource &#123;</span><br><span class="line">    // 可选方法</span><br><span class="line">    @objc optional func increment(forCount count: Int) -&gt; Int</span><br><span class="line">    // 可选属性</span><br><span class="line">    @objc optional var fixedIncrement: Int &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 继承自NSObject类使用</span><br><span class="line">class ThreeSource: NSObject, CounterDataSource &#123;</span><br><span class="line">    // 可选属性</span><br><span class="line">    let fixedIncrement = 3</span><br><span class="line">&#125;</span><br><span class="line">class TowardsZeroSource: NSObject, CounterDataSource &#123;</span><br><span class="line">    // 可选方法</span><br><span class="line">    func increment(_ count: Int) -&gt; Int &#123;</span><br><span class="line">        if count &gt; 0 &#123;</span><br><span class="line">            return count</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var threeSource = ThreeSource()</span><br><span class="line">print(threeSource.fixedIncrement)</span><br><span class="line">var towardsSource = TowardsZeroSource()</span><br><span class="line">print(towardsSource.increment(5))</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h1 id="检查协议一致性"><a href="#检查协议一致性" class="headerlink" title="检查协议一致性"></a>检查协议一致性</h1><ul><li>可以使用 <code>is</code> 和 <code>as</code> 操作符来检查协议的一致性，并强制转换到特定的协议。如果一个实例符合协议，则 <code>is</code> 操作符返回 <code>true</code>，否则返回 <code>false</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Person: OneProtocol &#123;</span><br><span class="line">&#125;</span><br><span class="line">let p1 = Person()</span><br><span class="line">if (p1 is OneProtocol)&#123; // 可以理解为：p1 是一个遵守了OneProtocol协议类型的实例</span><br><span class="line">    print(&quot;yes&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何让定义的协议只能被 <code>类</code> 遵守？：使用关键字 <code>class</code>，该关键字修饰之后表示协议只能被 <code>类</code> 遵守，如果有枚举或结构体尝试遵守会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 只能被类遵守的协议</span><br><span class="line">protocol FourProtocol: class ,ThreeProtocol &#123;</span><br><span class="line">&#125;</span><br><span class="line">// 此处报错</span><br><span class="line">struct Person: FourProtocol &#123;</span><br><span class="line">&#125;</span><br><span class="line">class Perple: FourProtocol &#123;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li><code>as?</code> 操作符返回协议类型的可选值，如果实例不符合该协议，则该值为nil。</li><li><code>as!</code> 操作符将强制转换为协议类型，并在转换失败时触发运行时错误。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protocol HasArea &#123;</span><br><span class="line">    var area: Double &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Circle: HasArea &#123;</span><br><span class="line">    let pi = 3.1415927</span><br><span class="line">    var radius: Double</span><br><span class="line">    var area: Double &#123; return pi * radius * radius &#125;</span><br><span class="line">    init(radius: Double) &#123; self.radius = radius &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Country: HasArea &#123;</span><br><span class="line">    var area: Double</span><br><span class="line">    init(area: Double) &#123; self.area = area &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">    var legs: Int</span><br><span class="line">    init(legs: Int) &#123; self.legs = legs &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let objects: [AnyObject] = [</span><br><span class="line">    Circle(radius: 2.0),</span><br><span class="line">    Country(area: 243_610),</span><br><span class="line">    Animal(legs: 4)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">for object in objects &#123;</span><br><span class="line">    if let objectWithArea = object as? HasArea &#123;</span><br><span class="line">        print(&quot;Area is \(objectWithArea.area)&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        print(&quot;Something that doesn&#x27;t have an area&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==============</span><br><span class="line">Area is 12.5663708</span><br><span class="line">Area is 243610.0</span><br><span class="line">Something that doesn&#x27;t have an area</span><br></pre></td></tr></table></figure><h1 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h1><p>协议的关联类型指的是根据使用场景的变化，如果协议中某些属性存在 “逻辑相同的而类型不同” 的情况，可以使用关键字 <code>associatedtype</code> 来为这些属性的类型声明“关联类型”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protocol WeightCalculable &#123;</span><br><span class="line">    // 为weight 属性定义的类型别名</span><br><span class="line">    associatedtype WeightType</span><br><span class="line">    var weight: WeightType &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WeightCalculable</code> 是一个“可称重”协议，<code>weight</code> 属性返回遵守该协议具体类型的实例的重量。这里我们使用 <code>associatedtype</code> 为该属性的类型定义了一个别名 <code>WeightType</code>，换言之在<code>WeightCalculable</code> 中并不关心 <code>weight</code> 的类型是 <code>Int</code> 还是 <code>Double</code> 或者是其他类型,他只是简单的告诉我们返回的类型是 <code>WeightType</code>，至于 <code>WeightType</code> 到底是什么类型由遵守该协议的类中自己去定义。那么这样做的好处是什么呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 定义手机结构体</span><br><span class="line">struct MobilePhone: WeightCalculable &#123;</span><br><span class="line">    typealias WeightType = Double</span><br><span class="line">    var weight: WeightType</span><br><span class="line">&#125;</span><br><span class="line">let iPhone7 = MobilePhone(weight: 0.138)</span><br><span class="line">// 定义汽车结构体</span><br><span class="line">struct Car: WeightCalculable &#123;</span><br><span class="line">    typealias WeightType = Int</span><br><span class="line">    var weight: WeightType</span><br><span class="line">&#125;</span><br><span class="line">let truck = Car(weight: 3000_000)</span><br></pre></td></tr></table></figure><p>如上所示：<code>MobilePhone、Car</code> 类型都遵守了 <code>WeightCalculable</code> 协议，都能被称重，但是手机由于结构精密、体型小巧，小数点后面的数字对于称重来说是必不可少的，所以使用了 <code>Double</code> 类型，返回 <code>0.138千克</code> 即 <code>138克</code>，但是对于汽车这样的庞然大物在称重时如果还计较小数点后面的数字就显得没有意义了，所以使用 <code>Int</code> 类型，表示 <code>3000</code> 千克也就是 <code>3吨</code>。</p><p>从上面的例子可以很好的看出由于 <code>MobilePhone、Car</code> 称重时逻辑是一样的，但是对于 <code>weight</code> 属性的返回值要求不一样，如果仅仅因为返回值类型的不同定义两个类似的协议一个是 <code>Int</code> 类型另外一个是 <code>Double</code> 类型，这样做显然是重复的、不合适的。所以 <code>associatedtype</code> 在这种情况下就发挥出作用了，他让开发者在遵守协议时根据需求去定义返回值的类型，而不是在协议中写死。唯一要注意的是：一定要在遵守该协议的类型中使用 <code>typealias</code> 规定具体的类型。不然编译器就报错了。</p><h1 id="协议的扩展"><a href="#协议的扩展" class="headerlink" title="协议的扩展"></a>协议的扩展</h1><p>协议的扩展是协议中很重要的一部分内容，主要体现在以下两个方面：</p><ul><li>扩展协议的属性和方法</li></ul><p>我们通过一个常见的例子说明一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protocol Score &#123;</span><br><span class="line">    var math: Int &#123; get set&#125;</span><br><span class="line">    var english: Int &#123;get set&#125;</span><br><span class="line">    func mathPercent() -&gt; Double</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义一个 <code>Score</code> 协议，里面有两个 <code>Int</code> 类型的属性 <code>math、english</code> 和一个计算数学所占分数的比例的方法 <code>mathPercent</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Puple: Score &#123;</span><br><span class="line">    var math: Int</span><br><span class="line">    var english: Int</span><br><span class="line">    func mathPercent() -&gt; Double &#123;</span><br><span class="line">        return Double(math) / Double(math + english)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 <code>Puple</code> 遵守该协议，实现了必要的属性和方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let p1 = Puple(math: 90, english: 80)</span><br><span class="line">s1.mathPercent()</span><br></pre></td></tr></table></figure><p>通过上面的代码可以计算出 <code>s1</code> 中数学所占的比例，但是设想一下如果还有很多个类似 <code>Puple</code> 结构体的类型都需要遵守该协议，都需要默认实现 <code>mathPercent</code> 方法计算出自己的数学分数所占的比例，还是按照上面的写法代码量就很大而且很冗杂了。问题的关键在于：任何遵守 <code>Score</code> 协议类型的<code>mathPercent</code> 计算逻辑是不变的，而且需要默认实现。那么我们如何轻松的实现这样的效果呢，答案是：为 <code>Score</code> 添加方法的扩展。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension Score &#123;</span><br><span class="line">    func mathPercent() -&gt; Double &#123;</span><br><span class="line">        return Double(math) / Double(math + english)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>mathPercent</code> 的具体实现写在协议的扩展里面，就能为所有的遵守 <code>Score</code> 的类型提供<code>mathPercent</code> 默认的实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct CollageStudent: Score &#123;</span><br><span class="line">    var math: Int</span><br><span class="line">    var english: Int</span><br><span class="line">&#125;</span><br><span class="line">let c1 = CollageStudent(math: 80, english: 80)</span><br><span class="line">c1.mathPercent()</span><br></pre></td></tr></table></figure><p>如此就能起到 <code>不实现mathPercent方法也能计算出数学所占分数的比例</code> 的效果了。此语法在Swift中有一个专业术语叫做：<code>default implementation</code> 即 <code>默认实现</code>。包括 <code>计算属性和方法</code> 的默认实现，但是 <code>不支持存储属性</code>，如果遵循类型给这个协议的要求提供了它自己的实现，那么它就会替代扩展中提供的默认实现。<br>通过这样的语法，我们不仅能为自定义的协议提供扩展，还能为系统提供的协议添加扩展，例如，为 <code>CustomStringConvertible</code> 添加一个计算属性默认实现的扩展：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension CustomStringConvertible &#123;</span><br><span class="line">    var customDescription: String &#123;</span><br><span class="line">        return &quot;ZJ&quot; + description</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为存在的类型添加协议遵守</li></ul><p>官方文档说明：</p><blockquote><p>扩展一个已经存在的类型来采纳和遵循一个新的协议，无需访问现有类型的源代码。扩展可以添加新的属性、方法和下标到已经存在的类型，并且因此允许你添加协议需要的任何需要。</p></blockquote><p>简单的来说我们可以对存在的类型（尤其是系统的类型）添加协议遵守。尽管这更像是对“类型的扩展”，但是官方文档将这部分放在了协议的扩展中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extension Double : CustomStringConvertible &#123;</span><br><span class="line">    /// A textual representation of the value.</span><br><span class="line">    public var description: String &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是 <code>Swift</code> 标准库中对于 <code>Double</code> 类型添加的一个协议遵守。除了添加系统协议的遵守，我们还可以添加自定义的协议的遵守，其方法都是一样的，这里就不太赘述了。</p><ul><li>总结</li></ul><p>通过 <code>协议的扩展</code> 提供协议中某些属性和方法的默认实现，将公共的代码和属性统一起来极大的增加了代码的复用，同时也增加了协议的灵活性和使用范围，这样的协议不仅仅是一系列接口的规范，还能提供相应的逻辑，是面向协议编程的基础。</p><h1 id="Swift标准库中常见的协议"><a href="#Swift标准库中常见的协议" class="headerlink" title="Swift标准库中常见的协议"></a>Swift标准库中常见的协议</h1><p>学习完协议的基础语法，我们大致熟悉一下Swift标准库中提供的协议。</p><p>Swift标准库为我们提供了55种协议，他们的命名很有特点，基本是以”Type”、“able”、“Convertible” 结尾，分别表示该协议“可以被当做XX类型”、“具备某种能力或特性”、“能够进行改变或变换”。因此在自定义协议时应该尽可能遵守苹果的命名规则，便于开发人员之间的高效合作。下面介绍一下常见的几种协议：</p><ul><li>Equatable</li></ul><p><code>Equatable</code> 是和比较相关的协议，遵守该协议表示实例能够用于相等的比较，需要重载 <code>==</code> 运算符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Student: Equatable &#123;</span><br><span class="line">    var math: Int</span><br><span class="line">    var english: Int</span><br><span class="line">&#125;</span><br><span class="line">// 重载 == 运算符</span><br><span class="line">func == (s1: Student, s2: Student) -&gt; Bool &#123;</span><br><span class="line">    return s1.math == s2.math &amp;&amp; s1.english == s2.english</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student遵守 <code>Equatable</code> 并且重载了 <code>==</code> 运算符后就能直接比较两个学生的成绩是否相等了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s1 = Student(math: 80, english: 60)</span><br><span class="line">let s2 = Student(math: 70, english: 90)</span><br><span class="line">s1 == s2 //false</span><br></pre></td></tr></table></figure><p>值得注意的是，由于重载 <code>==</code> 运算符是遵守 <code>Equatable</code> 协议后要求我们实现的，因此重载方法应该紧跟在遵守该协议的类型定义后，中间不能有其他的代码，否则就报错了。</p><ul><li>Comparable</li></ul><p><code>Comparable</code> 是和比较相关的第二个协议，遵守该协议表示实例能够进行比较，需要重载 <code>&lt;</code> 运算符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Student: Comparable&#123;</span><br><span class="line">    var math: Int</span><br><span class="line">    var english: Int</span><br><span class="line">&#125;</span><br><span class="line">// 重载 &lt; 运算符</span><br><span class="line">func &lt; (s1: Student, s2: Student) -&gt; Bool &#123;</span><br><span class="line">    return (s1.math + s1.english) &lt; (s2.math + s2.english)</span><br><span class="line">&#125;</span><br><span class="line">let s1 = Student(math: 80, english: 60)</span><br><span class="line">let s2 = Student(math: 70, english: 90)</span><br><span class="line">s1 &lt; s2 //true</span><br></pre></td></tr></table></figure><ul><li>CustomStringConvertible</li></ul><p><code>CustomStringConvertible</code> 提供了一种用文本表示一个对象或者结构的方式,可以在任何遵守该协议的类型中自定义表示结构的文本，需要覆盖 <code>description</code> 属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Student: CustomStringConvertible&#123;</span><br><span class="line">    var math: Int</span><br><span class="line">    var english: Int</span><br><span class="line">    var description: String &#123;</span><br><span class="line">        return &quot;Your math:&quot; + String(math) + &quot;, english:&quot; + String(english)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let s1 = Student(math: 80, english: 60)</span><br><span class="line">print(s1) // Your math:80, english:60</span><br></pre></td></tr></table></figure><ul><li>ExpressibleByArrayLiteral</li></ul><p><code>ExpressibleByArrayLiteral</code> 提供了使用数组文本初始化的类型的能力，具体来说使用逗号分隔的值、实例、字面值列表，方括号以创建数组文本。遵守该协议需要实现 <code>init(arrayLiteral elements: Person.Element...)</code> 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Person: ExpressibleByArrayLiteral &#123;</span><br><span class="line">    var name: String = &quot;&quot;</span><br><span class="line">    var job: String = &quot;&quot;</span><br><span class="line">    typealias Element = String</span><br><span class="line">    init(arrayLiteral elements: Person.Element...) &#123;  </span><br><span class="line">        if elements.count == 2 &#123;</span><br><span class="line">            name = elements[0]</span><br><span class="line">            job = elements[1]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p1: Person = [&quot;jack&quot;, &quot;teacher&quot;]</span><br><span class="line">print(p1.name) //jack</span><br><span class="line">print(p1.job) //teacher</span><br></pre></td></tr></table></figure><p>上面的代码用到了之前关联类型，通过遵守 <code>ExpressibleByArrayLiteral</code>，现在的 <code>Person</code> 就可以使用数组直接创建实例了。</p><p>类似的协议还有：<br> <code>ExpressibleByDictionaryLiteral、ExpressibleByStringLiteral、ExpressibleByBooleanLiteral 、ExpressibleByIntegerLiteral</code> 等等，相信大家通过名称就能大概猜出具体作用，由于篇幅有限这里就不再赘述了。</p><h1 id="为什么要使用协议"><a href="#为什么要使用协议" class="headerlink" title="为什么要使用协议"></a>为什么要使用协议</h1><ul><li>协议可以作为类型使用</li></ul><p>协议作为一种类型是苹果在Swift中提出的，并且在官方文档中还为我们具体指出了可以将协议当做类型使用的场景：</p><blockquote><p>1，在函数、方法或者初始化器里作为形式参数类型或者返回类型；<br>2，作为常量、变量或者属性的类型；<br>3，作为数组、字典或者其他存储器的元素的类型。</p></blockquote><ul><li>协议可以解决面向对象中一些棘手的问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习38：类</title>
      <link href="/BboyZJ.github.io/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A038%EF%BC%9A%E7%B1%BB/"/>
      <url>/BboyZJ.github.io/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A038%EF%BC%9A%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ul><li><p>Swift <code>类</code> 是构建代码的 <code>一种</code> 通用的 <code>构造体</code></p></li><li><p>swift 也是一种 <code>面向对象（OOP）</code> 的编程语言</p></li><li><p>swift中 <code>类</code> 可以定义 <code>属性(常量、变量)和方法</code></p></li><li><p>Swift 中 <code>类</code> 是 <code>引用类型</code> 的，存储在 <code>堆区</code></p></li></ul><h1 id="类和结构体对比"><a href="#类和结构体对比" class="headerlink" title="类和结构体对比"></a>类和结构体对比</h1><p>Swift 中类和结构体有很多共同点：</p><ul><li>定义 <code>属性</code> 用于 <code>存储值</code></li><li>定义 <code>方法</code> 用于 <code>提供功能</code></li><li>定义 <code>下标脚本</code> 用于访问值</li><li>定义 <code>初始化器</code> 用于 <code>生成初始化值</code></li><li>通过 <code>扩展</code> 以 <code>增加默认实现的功能</code></li><li>符合 <code>协议</code> 以 <code>对某类提供标准功能</code></li></ul><p>与结构体相对，类还有如下的 <code>附加</code> 功能：</p><ul><li>class 定义 <code>属性</code>，必须赋值或包装成Optional。struct 定义属性不需要要赋值</li><li>class 是 <code>引用类型</code>，浅拷贝。struct 是 <code>值类型</code>，深拷贝。</li><li>class <code>可以继承</code>。struct <code>不能继承</code>。</li><li>class 有 <code>引用计数</code>，可以 <code>多次引用</code>。struct 没有引用计数</li><li>class 有 <code>类型转换</code>，允许在 <code>运行时检查和解释一个类实例的类型</code>。struct 没有</li><li>class 有 <code>解构器</code> 允许一个 <code>类实例释放任何其所被分配的资源</code></li><li>struct 分配在 <code>栈</code> 中，系统分配是否内存。class 分配在 <code>堆</code> 中，动态分配释放内存</li><li>struct 比 class 更轻量级，<code>栈</code> 只访问一次拿到数据，<code>堆</code> 访问两次拿到数据（第一次获取指针，第二次获取数据）</li></ul><h1 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h1><ul><li><p><code>存储属性</code>：存储实例的常量和变量</p></li><li><p><code>计算属性</code>：通过某种方式计算出来的属性 { set {} get{} }</p></li><li><p><code>类型属性</code>：与整个自身相关的属性，用 <code>static</code> 关键字修饰</p></li></ul><h1 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h1><p>我们使用 <code>class</code> 关键字在 <code>swift</code> 中创建一个类。例如：</p><ul><li>没有父类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名 &#123;</span><br><span class="line">    // 定义属性和方法等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有父类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名 : SuperClass&#123;</span><br><span class="line">    // 定义属性和方法等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：<br>定义的类，可以没有父类，也可以有父类<br>通常情况下，定义类时，继承自 <code>_SwiftObject</code></p></blockquote><h1 id="定义存储属性"><a href="#定义存储属性" class="headerlink" title="定义存储属性"></a>定义存储属性</h1><ul><li><p><code>存储属性</code> 要么是 <code>变量存储属性</code>（由 <code>var</code> 关键字引入），要么是 <code>常量存储属性</code>（由 <code>let</code> 关键字引入）</p></li><li><p>定义 <code>属性</code> 必须 <code>赋值或包装成Optional</code></p></li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 存储属性</span><br><span class="line">class Person &#123;</span><br><span class="line">    // 定义属性时，需要赋值或包装Optional，否则报错</span><br><span class="line">    let age: Int = 30</span><br><span class="line">    var name: String?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实例化类"><a href="#实例化类" class="headerlink" title="实例化类"></a>实例化类</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 实例化</span><br><span class="line">let p = Person()</span><br><span class="line">p.age = 32 // Cannot assign to property: &#x27;age&#x27; is a &#x27;let&#x27; constant</span><br><span class="line">p.name = &quot;ZJ&quot;</span><br><span class="line">print(p.age)</span><br><span class="line">print(p.name!)</span><br></pre></td></tr></table></figure><blockquote><p>注：常量存储属性不能修改</p></blockquote><p><img src="/BboyZJ.github.io/assets/16784615070488.jpg"></p><p>修改后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    // 定义属性时，需要赋值或包装Optional，否则报错</span><br><span class="line">    let age: Int = 30</span><br><span class="line">    var name: String?</span><br><span class="line">&#125;</span><br><span class="line">// 实例化</span><br><span class="line">let p = Person()</span><br><span class="line">//p.age = 32</span><br><span class="line">p.name = &quot;ZJ&quot;</span><br><span class="line">print(p.age)</span><br><span class="line">print(p.name!)</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">30</span><br><span class="line">ZJ</span><br></pre></td></tr></table></figure><h1 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h1><p><code>延迟属性</code>，即，使用 <code>lazy修饰</code> 的存储属性。特点：</p><ul><li><p><code>第一次访问的时候才被赋值</code>。</p></li><li><p><code>不能保证线程安全</code></p></li><li><p><code>lazy</code> 修饰的属性，必须要初始化，不能包装Optiaonal</p></li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Manager &#123;</span><br><span class="line">    // lazy</span><br><span class="line">    lazy var name:String?</span><br><span class="line">&#125;</span><br><span class="line">let m = Manager()</span><br><span class="line">print(m.name)</span><br></pre></td></tr></table></figure><p><strong>编译运行，报错</strong></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303110157366.png"></p><p><strong>修改成：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// lazy</span><br><span class="line">lazy var name:String = &quot;ZJ&quot;</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">ZJ</span><br></pre></td></tr></table></figure><h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><ul><li><p>除了 <code>存储属性</code>，<code>类</code> 还能定义 <code>计算属性</code>，而它实际 <code>并不是存储值</code>。</p></li><li><p>相反，它提供一个 <code>读取器</code> 和一个 <code>可选的设置器</code> 来间接得到和设置其它的 <code>属性和值</code>。类似于 <code>OC</code> 的 <code>set/get</code> 方法去设值和取值</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 定义计算属性</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Size &#123;</span><br><span class="line">    var width = 0.0,height = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Rect &#123;</span><br><span class="line">    // 存储属性</span><br><span class="line">    var origin = Point()</span><br><span class="line">    var size = Size()</span><br><span class="line">    // 计算属性：可以通过origin 和 size 计算出来</span><br><span class="line">    var center: Point &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            let centerX = origin.x + size.width/2.0</span><br><span class="line">            let centerY = origin.y + size.height/2.0</span><br><span class="line">            return Point(x:centerX, y:centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        set(newCenter) &#123;</span><br><span class="line">            origin.x = newCenter.x - size.width/2.0</span><br><span class="line">            origin.y = newCenter.y - size.height/2.0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let rect = Rect(origin: Point(x: 0,y: 0),size: Size(width: 100,height: 100))</span><br><span class="line">print(rect.center)</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line">Point(x: 50.0, y: 50.0)</span><br></pre></td></tr></table></figure><h1 id="简写-setter"><a href="#简写-setter" class="headerlink" title="简写 setter"></a>简写 setter</h1><ul><li>如果一个 <code>计算属性</code> 的 <code>设置器</code> 没有为将要被设置的值定义一个名字，那么它将被默认命名为 <code>newValue</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set &#123;</span><br><span class="line">    origin.x = newCenter.x - size.width/2.0</span><br><span class="line">    origin.y = newCenter.y - size.height/2.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简写-getter"><a href="#简写-getter" class="headerlink" title="简写 getter"></a>简写 getter</h1><ul><li>如果整个 <code>getter</code> 的函数体是一个 <code>单一的表达式</code>，那么 <code>getter</code> 隐士返回这个表达式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 简写 get</span><br><span class="line">get &#123;</span><br><span class="line">    CGPoint(x: p.x + s.w/2.0, y: p.y + s.h/2.0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h1><ul><li><p>一个 <code>有读取器</code> 但是 <code>没有设置器</code> 的 <code>计算属性</code> 就是所谓的 <code>只读计算属性</code>。只读计算属性返回一个值，也可以通过 <code>点语法</code> 访问，但是不能被修改为另一个值</p></li><li><p>你必须用 <code>var关键字</code> 定义计算属性（包括只读计算属性）为变量属性，因为它的 <code>值不是固定的</code>。<code>let关键字</code> 只能用于常量属性，用于明确哪些值一旦作为实例初始化就不能更改</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 只读计算属性</span><br><span class="line">class Rect &#123;</span><br><span class="line">    var p = Point()</span><br><span class="line">    var s = Size()</span><br><span class="line">    // 计算属性</span><br><span class="line">    var center: CGPoint &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return CGPoint(x: p.x + s.w/2.0, y: p.y + s.h/2.0)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="属性观察者"><a href="#属性观察者" class="headerlink" title="属性观察者"></a>属性观察者</h1><ul><li><p><code>willSet</code> 会在 <code>该值被存储之前被调用</code></p></li><li><p><code>didSet</code> 会在 <code>一个新值被存储之后被调用</code></p></li><li><p>如果你实现了一个 <code>willSet</code> 观察者，新的属性值会以常量形式参数传递。你可以再你的 <code>willSet</code> 实现中为这个参数定义名字。如果你没有为它命名，那么它会使用默认值的名字 <code>newValue</code></p></li><li><p>如果你实现了一个 <code>didSet</code> 观察者，一个包含旧属性值的常量形式参数将会被传递。你可以为它命名，也可以使用默认值的形式参数名 <code>oldValue</code>。如果你在属性自己的 <code>disSet</code> 观察者里给自己赋值，你赋值的新值就会取代刚刚设置的值。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 属性观察器</span><br><span class="line">class StepCount &#123;</span><br><span class="line">    var totalStep: Int = 0 &#123;</span><br><span class="line">        // 值被存储前调用</span><br><span class="line">        willSet(newValue) &#123;</span><br><span class="line">            print(newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        // 值被存储后调用</span><br><span class="line">        didSet(oldValue) &#123;</span><br><span class="line">            // 如果 存储后的值 &gt; 存储前的值</span><br><span class="line">            if totalStep &gt; oldValue &#123;</span><br><span class="line">                print(&quot;步数增加： \(totalStep - oldValue)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let step = StepCount()</span><br><span class="line">step.totalStep = 100</span><br><span class="line">step.totalStep = 200</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">100</span><br><span class="line">步数增加： 100</span><br><span class="line">200</span><br><span class="line">步数增加： 100</span><br></pre></td></tr></table></figure><h1 id="全局和局部变量"><a href="#全局和局部变量" class="headerlink" title="全局和局部变量"></a>全局和局部变量</h1><ul><li><code>观察属性的能力同样对全局变量和局部变量有效</code>。<code>全局变量</code> 是定义在 <code>任何函数、方法、闭包或者类之外的变量</code>。<code>局部变量</code> 是定义在 <code>函数、方法或闭包环境之中的变量</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 全局变量</span><br><span class="line">class Sum &#123;</span><br><span class="line">    var count: Int = 0 &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;count : \(newValue)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;did change count from \(oldValue) to \(count)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let sum = Sum()</span><br><span class="line">sum.count = 10 // 全局变量</span><br><span class="line">print(sum.count)</span><br><span class="line"></span><br><span class="line">==============</span><br><span class="line">count : 10</span><br><span class="line">did change count from 0 to 10</span><br></pre></td></tr></table></figure><h1 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h1><ul><li>使用 <code>static</code> 关键字来定义 <code>类型属性</code>。</li><li></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 类型属性</span><br><span class="line">class SuperClass &#123;</span><br><span class="line">    // 类型属性</span><br><span class="line">    static var name: String = &quot;ZJ&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(SuperClass.name)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">ZJ</span><br></pre></td></tr></table></figure><ul><li>你也可以使用 <code>class</code> 关键字来定义 <code>类型属性</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 重写父类的实现</span><br><span class="line">class SubClass: SuperClass &#123;</span><br><span class="line">    // 类型属性</span><br><span class="line">    class var newName: String &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return &quot;New ZJ&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(SubClass.newName)</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">New ZJ</span><br></pre></td></tr></table></figure><h1 id="定义实例方法"><a href="#定义实例方法" class="headerlink" title="定义实例方法"></a>定义实例方法</h1><ul><li><p><code>实例方法</code> 是属于 <code>特定类实例、结构体实例或枚举实例的函数</code>，提供 <code>访问和修改实例属性的方法</code></p></li><li><p><code>每一个类的实例都隐含一个叫做 </code>self<code> 的属性</code>，它完全与实例本身相等。你可以用 <code>self</code> 属性在当前实例中调用自身的方法</p></li><li><p>实际上，你不需要经常在代码中写 <code>self</code>。如果你没有显示地写出 <code>self</code>，<code>swift</code> 会在你方法中使用已知属性或方法的时候假定你调用了当前实例中的属性或者方法</p></li><li><p>例外就是当一个实例方法的形式参数名与实例中某个属性拥有相同的名字的时候。在这种情况下，形式参数名具有优先权，并且调用属性的时候使用更加严谨的方式就很有必要了。你可以使用 <code>self</code> 属性来 <code>区分形式参数名和属性名</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 定义方法</span><br><span class="line">class PrintInfo &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    // 实例方法</span><br><span class="line">    func printInfo() &#123;</span><br><span class="line">        print(&quot;x is \(x),y is \(y)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var printInfo = PrintInfo()</span><br><span class="line">printInfo.x = 10</span><br><span class="line">printInfo.y = 20</span><br><span class="line">printInfo.printInfo()</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">x is 10.0,y is 20.0</span><br></pre></td></tr></table></figure><h1 id="实例方法-self"><a href="#实例方法-self" class="headerlink" title="实例方法 self"></a>实例方法 self</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// self</span><br><span class="line">class SomePoint &#123;</span><br><span class="line">    var x = 0.0</span><br><span class="line">    // 实例方法 self</span><br><span class="line">    func isToTheRightOf(x: Double) -&gt; Bool &#123;</span><br><span class="line">        // self 访问 属性</span><br><span class="line">        return self.x &gt; x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let somePoint = SomePoint()</span><br><span class="line">somePoint.x = 4</span><br><span class="line">if somePoint.isToTheRightOf(x: 1.0) &#123;</span><br><span class="line">    print(&quot;the point is x \(somePoint.x)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">the point is x 4.0</span><br></pre></td></tr></table></figure><h1 id="在实例方法中修改属性"><a href="#在实例方法中修改属性" class="headerlink" title="在实例方法中修改属性"></a>在实例方法中修改属性</h1><p><code>类</code> 是 <code>引用类型的</code>，允许修改属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 修改属性</span><br><span class="line">class ChangeName &#123;</span><br><span class="line">    var name: String = &quot;ZZ&quot;</span><br><span class="line">    func change() &#123;</span><br><span class="line">        name = &quot;ZJ&quot;</span><br><span class="line">        print(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let name = ChangeName()</span><br><span class="line">name.change()</span><br><span class="line"></span><br><span class="line">===========</span><br><span class="line">ZJ</span><br></pre></td></tr></table></figure><h1 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h1><ul><li><code>类</code> 通过在 <code>func</code> 关键字前用 <code>class</code> 关键字来明确一个 <code>类型方法</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 类型方法</span><br><span class="line">class PointClass &#123;</span><br><span class="line">    // 类型方法</span><br><span class="line">    static func pringInfo(newX: Double) &#123;</span><br><span class="line">        print(&quot;x is \(newX)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var pc = PointClass()</span><br><span class="line">// 类型方法用 类 调用</span><br><span class="line">PointClass.pringInfo(newX: 10)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">x is 10</span><br></pre></td></tr></table></figure><h1 id="定义初始化器"><a href="#定义初始化器" class="headerlink" title="定义初始化器"></a>定义初始化器</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 定义初始化器</span><br><span class="line">class Name &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        // 初始化值</span><br><span class="line">        self.name = &quot;my name is \(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let name = Name(name: &quot;ZJ&quot;)</span><br><span class="line">print(name.name)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">my name is ZJ</span><br></pre></td></tr></table></figure><h1 id="定义下标脚本"><a href="#定义下标脚本" class="headerlink" title="定义下标脚本"></a>定义下标脚本</h1><ul><li><p><code>类、结构体和枚举</code> 可以定义 <code>下标</code>，它可以作为访问集合、列表或序列号成员元素的快捷方式。你可以使用下标通过索引值来设置或检索值而不需要为设置和检索分别使用实例方法</p></li><li><p>你可以为一个类型 <code>定义多个下标</code>，并且下标会基于传入的索引值的类型选择合适的下标重载使用。下标没有限制单个维度，你可以使用多个输入形参来定义下标以满足自定义类型的需求</p></li><li><p><code>下标脚本</code> 允许你通过在实例名后面的方括号内写一个或多个值对该类的实例进行查询。它的语法类似于实例方法和计算属性。使用关键字 <code>subscript</code> 来定义下标，并且指定一个或多个输入形式参数和返回类型，与实例方法一样。与实例方法不同的是，下标可以是读写也可以是只读的</p></li><li><p>下标脚本的访问用 <code>[]</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 定义下标脚本</span><br><span class="line">class Grade &#123;</span><br><span class="line">    subscript(num: Int) -&gt;String &#123;</span><br><span class="line">        if num &lt; 60 &#123;</span><br><span class="line">            return &quot;不及格&quot;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;及格&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let grade = Grade()</span><br><span class="line">print(grade[99])</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">及格</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习39：结构体</title>
      <link href="/BboyZJ.github.io/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A039%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/BboyZJ.github.io/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A039%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><ul><li><p>Swift <code>结构体</code> 是 <code>构建代码</code> 所用的 <code>一种 </code>通用且灵活的 <code>构造体</code></p></li><li><p>Swift <code>结构体</code> 是 <code>值类型</code>，通过 <code>复制</code> 的方式在代码中 <code>传递</code>，因此它的值是不可修改的</p></li></ul><h1 id="类和结构体对比"><a href="#类和结构体对比" class="headerlink" title="类和结构体对比"></a>类和结构体对比</h1><p>Swift 中类和结构体有很多共同点：</p><ul><li>定义 <code>属性</code> 用于 <code>存储值</code></li><li>定义 <code>方法</code> 用于 <code>提供功能</code></li><li>定义 <code>下标脚本</code> 用于访问值</li><li>定义 <code>初始化器</code> 用于 <code>生成初始化值</code></li><li>通过 <code>扩展</code> 以 <code>增加默认实现的功能</code></li><li>符合 <code>协议</code> 以 <code>对某类提供标准功能</code></li></ul><p>与结构体相对，类还有如下的 <code>附加</code> 功能：</p><ul><li>class 定义 <code>属性</code>，必须赋值或包装成Optional。struct 定义属性不需要要赋值</li><li>class 是 <code>引用类型</code>，浅拷贝。struct 是 <code>值类型</code>，深拷贝。</li><li>class <code>可以继承</code>。struct <code>不能继承</code>。</li><li>class 有 <code>引用计数</code>，可以 <code>多次引用</code>。struct 没有引用计数</li><li>class 有 <code>类型转换</code>，允许在 <code>运行时检查和解释一个类实例的类型</code>。struct 没有</li><li>class 有 <code>解构器</code> 允许一个 <code>类实例释放任何其所被分配的资源</code></li><li>struct 分配在 <code>栈</code> 中，系统分配是否内存。class 分配在 <code>堆</code> 中，动态分配释放内存</li><li>struct 比 class 更轻量级，<code>栈</code> 只访问一次拿到数据，<code>堆</code> 访问两次拿到数据（第一次获取指针，第二次获取数据）</li></ul><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>结构体可以 <code>定义属性(常量let、变量var）</code> 和 <code>添加方法</code>，从而 <code>扩展结构体的功能</code></p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>通过关键字 <code>struct</code> 来定义结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体名 &#123;</span><br><span class="line">    // 定义 属性和方法等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义存储属性"><a href="#定义存储属性" class="headerlink" title="定义存储属性"></a>定义存储属性</h1><p>struct 定义存储属性，<code>允许不设置默认值</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    // 存储属性</span><br><span class="line">    let age: Int</span><br><span class="line">    var name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 实例化</span><br><span class="line">let p = Person(age: 32, name: &quot;ZJ&quot;)</span><br><span class="line">print(p.age)</span><br><span class="line">print(p.name)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">32</span><br><span class="line">ZJ</span><br></pre></td></tr></table></figure><h1 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h1><ul><li><p><code>延迟存储属性的初始值在第一次使用时才进行计算</code>。</p></li><li><p>声明前面标注 <code>lazy</code> 关键字来表示一个 <code>延迟存储属性</code></p></li><li><p><code>lazy</code> 修饰的属性，必须要初始化</p></li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 延迟存储属性</span><br><span class="line">struct Manager &#123;</span><br><span class="line">    // lazy 必须被初始化</span><br><span class="line">    lazy var name:String = &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">var m = Manager(name: &quot;ZJ&quot;)</span><br><span class="line">print(m.name)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">ZJ</span><br></pre></td></tr></table></figure><h1 id="定义计算属性"><a href="#定义计算属性" class="headerlink" title="定义计算属性"></a>定义计算属性</h1><ul><li><p>除了 <code>存储属性</code>，<code>类</code> 还能定义 <code>计算属性</code>，而它实际 <code>并不是存储值</code>。</p></li><li><p>相反，它提供一个 <code>读取器</code> 和一个 <code>可选的设置器</code> 来间接得到和设置其它的 <code>属性和值</code>。类似于 <code>OC</code> 的 <code>set/get</code> 方法去设值和取值</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 计算属性</span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Size &#123;</span><br><span class="line">    var width = 0.0,height = 0.0</span><br><span class="line">&#125;</span><br><span class="line">struct Rect &#123;</span><br><span class="line">    // 存储属性</span><br><span class="line">    var origin = Point()</span><br><span class="line">    var size = Size()</span><br><span class="line">    // 计算属性：可以通过origin 和 size 计算出来</span><br><span class="line">    var center: Point &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            let centerX = origin.x + size.width/2.0</span><br><span class="line">            let centerY = origin.y + size.height/2.0</span><br><span class="line">            return Point(x:centerX, y:centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        set(newCenter) &#123;</span><br><span class="line">            origin.x = newCenter.x - size.width/2.0</span><br><span class="line">            origin.y = newCenter.y - size.height/2.0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line">Point(x: 50.0, y: 50.0)</span><br></pre></td></tr></table></figure><h1 id="简写-setter"><a href="#简写-setter" class="headerlink" title="简写 setter"></a>简写 setter</h1><ul><li>如果一个 <code>计算属性</code> 的 <code>设置器</code> 没有为将要被设置的值定义一个名字，那么它将被默认命名为 <code>newValue</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set &#123;</span><br><span class="line">    origin.x = newCenter.x - size.width/2.0</span><br><span class="line">    origin.y = newCenter.y - size.height/2.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简写-getter"><a href="#简写-getter" class="headerlink" title="简写 getter"></a>简写 getter</h1><ul><li>如果整个 <code>getter</code> 的函数体是一个 <code>单一的表达式</code>，那么 <code>getter</code> 隐士返回这个表达式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 简写 get</span><br><span class="line">get &#123;</span><br><span class="line">    Point(x:origin.x + size.width/2.0, y:origin.y + size.height/2.0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h1><ul><li><p>一个 <code>有读取器</code> 但是 <code>没有设置器</code> 的 <code>计算属性</code> 就是所谓的 <code>只读计算属性</code>。只读计算属性返回一个值，也可以通过 <code>点语法</code> 访问，但是不能被修改为另一个值</p></li><li><p>你必须用 <code>var关键字</code> 定义计算属性（包括只读计算属性）为变量属性，因为它的 <code>值不是固定的</code>。<code>let关键字</code> 只能用于常量属性，用于明确哪些值一旦作为实例初始化就不能更改</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 只读计算属性</span><br><span class="line">struct Rect &#123;</span><br><span class="line">    // 存储属性</span><br><span class="line">    var origin = Point()</span><br><span class="line">    var size = Size()</span><br><span class="line">    // 计算属性：可以通过origin 和 size 计算出来</span><br><span class="line">    var center: Point &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            let centerX = origin.x + size.width/2.0</span><br><span class="line">            let centerY = origin.y + size.height/2.0</span><br><span class="line">            return Point(x:centerX, y:centerY)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="属性观察者"><a href="#属性观察者" class="headerlink" title="属性观察者"></a>属性观察者</h1><ul><li><p><code>willSet</code> 会在 <code>该值被存储之前被调用</code></p></li><li><p><code>didSet</code> 会在 <code>一个新值被存储之后被调用</code></p></li><li><p>如果你实现了一个 <code>willSet</code> 观察者，新的属性值会以常量形式参数传递。你可以再你的 <code>willSet</code> 实现中为这个参数定义名字。如果你没有为它命名，那么它会使用默认值的名字 <code>newValue</code></p></li><li><p>如果你实现了一个 <code>didSet</code> 观察者，一个包含旧属性值的常量形式参数将会被传递。你可以为它命名，也可以使用默认值的形式参数名 <code>oldValue</code>。如果你在属性自己的 <code>disSet</code> 观察者里给自己赋值，你赋值的新值就会取代刚刚设置的值。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 属性观察器</span><br><span class="line">struct StepCount &#123;</span><br><span class="line">    var totalStep: Int = 0 &#123;</span><br><span class="line">        // 值被存储前调用</span><br><span class="line">        willSet(newValue) &#123;</span><br><span class="line">            print(newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        // 值被存储后调用</span><br><span class="line">        didSet(oldValue) &#123;</span><br><span class="line">            // 如果 存储后的值 &gt; 存储前的值</span><br><span class="line">            if totalStep &gt; oldValue &#123;</span><br><span class="line">                print(&quot;步数增加： \(totalStep - oldValue)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var step = StepCount()</span><br><span class="line">step.totalStep = 100</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">100</span><br><span class="line">步数增加： 100</span><br></pre></td></tr></table></figure><h1 id="全局和局部变量"><a href="#全局和局部变量" class="headerlink" title="全局和局部变量"></a>全局和局部变量</h1><ul><li><code>观察属性的能力同样对全局变量和局部变量有效</code>。<code>全局变量</code> 是定义在 <code>任何函数、方法、闭包或者类之外的变量</code>。<code>局部变量</code> 是定义在 <code>函数、方法或闭包环境之中的变量</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 全局变量</span><br><span class="line">struct Sum &#123;</span><br><span class="line">    var count: Int = 0 &#123;</span><br><span class="line">        willSet &#123;</span><br><span class="line">            print(&quot;count : \(newValue)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            print(&quot;did change count from \(oldValue) to \(count)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var sum = Sum()</span><br><span class="line">sum.count = 10 // 全局变量</span><br><span class="line">print(sum.count)</span><br><span class="line"></span><br><span class="line">==============</span><br><span class="line">count : 10</span><br><span class="line">did change count from 0 to 10</span><br></pre></td></tr></table></figure><h1 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h1><ul><li><code>struct、enum</code> 中使用 <code>static</code> 关键字来定义 <code>类型属性</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 类型属性</span><br><span class="line">class SuperClass &#123;</span><br><span class="line">    // 类型属性</span><br><span class="line">    static var name: String = &quot;ZJ&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(SuperClass.name)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">ZJ</span><br></pre></td></tr></table></figure><ul><li><code>struct、enum</code> 中 <code>不允许</code> 使用 <code>class</code> 关键字来定义 <code>类型属性</code></li></ul><h1 id="定义实例方法"><a href="#定义实例方法" class="headerlink" title="定义实例方法"></a>定义实例方法</h1><ul><li><p><code>实例方法</code> 是属于 <code>特定类实例、结构体实例或枚举实例的函数</code>，提供 <code>访问和修改实例属性的方法</code></p></li><li><p><code>每一个类的实例都隐含一个叫做 </code>self<code> 的属性</code>，它完全与实例本身相等。你可以用 <code>self</code> 属性在当前实例中调用自身的方法</p></li><li><p>实际上，你不需要经常在代码中写 <code>self</code>。如果你没有显示地写出 <code>self</code>，<code>swift</code> 会在你方法中使用已知属性或方法的时候假定你调用了当前实例中的属性或者方法</p></li><li><p>例外就是当一个实例方法的形式参数名与实例中某个属性拥有相同的名字的时候。在这种情况下，形式参数名具有优先权，并且调用属性的时候使用更加严谨的方式就很有必要了。你可以使用 <code>self</code> 属性来 <code>区分形式参数名和属性名</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 定义方法</span><br><span class="line">struct PrintInfo &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    // 实例方法</span><br><span class="line">    func printInfo() &#123;</span><br><span class="line">        print(&quot;x is \(x),y is \(y)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var printInfo = PrintInfo()</span><br><span class="line">printInfo.x = 10</span><br><span class="line">printInfo.y = 20</span><br><span class="line">printInfo.printInfo()</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">x is 10.0,y is 20.0</span><br></pre></td></tr></table></figure><h1 id="实例方法-self"><a href="#实例方法-self" class="headerlink" title="实例方法 self"></a>实例方法 self</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// self</span><br><span class="line">struct SomePoint &#123;</span><br><span class="line">    var x = 0.0</span><br><span class="line">    // 实例方法 self</span><br><span class="line">    func isToTheRightOf(x: Double) -&gt; Bool &#123;</span><br><span class="line">        // self 访问 属性</span><br><span class="line">        return self.x &gt; x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var somePoint = SomePoint()</span><br><span class="line">somePoint.x = 4</span><br><span class="line">if somePoint.isToTheRightOf(x: 1.0) &#123;</span><br><span class="line">    print(&quot;the point is x \(somePoint.x)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">the point is x 4.0</span><br></pre></td></tr></table></figure><h1 id="在实例方法中修改属性"><a href="#在实例方法中修改属性" class="headerlink" title="在实例方法中修改属性"></a>在实例方法中修改属性</h1><ul><li><p><code>struct、enum</code> 是 <code>值类型的</code>，默认情况下，<code>值类型属性不能被修改</code></p></li><li><p>你可以选择在 <code>func</code> 关键字前放一个 <code>mutating(异变方法)</code> 关键字来 <code>指定可以修改属性</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 修改属性</span><br><span class="line">struct ChangeName &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    // struct 中 使用 mutating 修改属性</span><br><span class="line">    mutating func change() &#123;</span><br><span class="line">        name = &quot;ZJ&quot;</span><br><span class="line">        print(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var name = ChangeName(name: &quot;&quot;)</span><br><span class="line">name.change()</span><br><span class="line"></span><br><span class="line">===========</span><br><span class="line">ZJ</span><br></pre></td></tr></table></figure><h1 id="在-mutating-方法中赋值给-self"><a href="#在-mutating-方法中赋值给-self" class="headerlink" title="在 mutating 方法中赋值给 self"></a>在 mutating 方法中赋值给 self</h1><ul><li><code>mutating</code> 方法可以指定整个实例给隐含的 <code>self</code> 属性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// self</span><br><span class="line">struct SomePoint &#123;</span><br><span class="line">    var x = 0.0</span><br><span class="line">    // 实例方法 self</span><br><span class="line">    func isToTheRightOf(x: Double) -&gt; Bool &#123;</span><br><span class="line">        // self 访问 属性</span><br><span class="line">        return self.x &gt; x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var somePoint = SomePoint()</span><br><span class="line">somePoint.x = 4</span><br><span class="line">if somePoint.isToTheRightOf(x: 1.0) &#123;</span><br><span class="line">    print(&quot;the point is x \(somePoint.x)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">the point is x 4.0</span><br></pre></td></tr></table></figure><h1 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h1><ul><li><code>struct、enum</code> 通过在 <code>func</code> 关键字前用 <code>static</code> 关键字来明确一个 <code>类型方法</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 类型方法</span><br><span class="line">struct PointClass &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    // 类型方法</span><br><span class="line">    static func pringInfo() &#123;</span><br><span class="line">        print(&quot;pringInfo&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 类型方法用 类 调用</span><br><span class="line">PointClass.pringInfo()</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">pringInfo</span><br></pre></td></tr></table></figure><ul><li><code>struct、enum</code> 不允许既有 <code>static</code> 又有 <code>mutating</code></li></ul><h1 id="定义初始化器"><a href="#定义初始化器" class="headerlink" title="定义初始化器"></a>定义初始化器</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 定义初始化器</span><br><span class="line">struct Name &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        // 初始化值</span><br><span class="line">        self.name = &quot;my name is \(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let name = Name(name: &quot;ZJ&quot;)</span><br><span class="line">print(name.name)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">my name is ZJ</span><br></pre></td></tr></table></figure><h1 id="成员初始化器"><a href="#成员初始化器" class="headerlink" title="成员初始化器"></a>成员初始化器</h1><p>如果结构体中没有定义任何初始化器，它会自动获得一个 <code>成员初始化器</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Size &#123;</span><br><span class="line">    var width = 0.0, height = 0.0</span><br><span class="line">&#125;</span><br><span class="line">let s = Size(width: 2.0,height: 2.0)</span><br></pre></td></tr></table></figure><h1 id="初始化器委托"><a href="#初始化器委托" class="headerlink" title="初始化器委托"></a>初始化器委托</h1><p>初始化器可以调用其他初始化器，避免了多个初始化器里冗余代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Name &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        // 初始化值</span><br><span class="line">        self.name = &quot;my name is \(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    init(age: String,name: String) &#123;</span><br><span class="line">        let newName = name + age</span><br><span class="line">        self.init(name:newName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义下标脚本"><a href="#定义下标脚本" class="headerlink" title="定义下标脚本"></a>定义下标脚本</h1><ul><li><p><code>类、结构体和枚举</code> 可以定义 <code>下标</code>，它可以作为访问集合、列表或序列号成员元素的快捷方式。你可以使用下标通过索引值来设置或检索值而不需要为设置和检索分别使用实例方法</p></li><li><p>你可以为一个类型 <code>定义多个下标</code>，并且下标会基于传入的索引值的类型选择合适的下标重载使用。下标没有限制单个维度，你可以使用多个输入形参来定义下标以满足自定义类型的需求</p></li><li><p><code>下标脚本</code> 允许你通过在实例名后面的方括号内写一个或多个值对该类的实例进行查询。它的语法类似于实例方法和计算属性。使用关键字 <code>subscript</code> 来定义下标，并且指定一个或多个输入形式参数和返回类型，与实例方法一样。与实例方法不同的是，下标可以是读写也可以是只读的</p></li><li><p>下标脚本的访问用 <code>[]</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 定义下标脚本</span><br><span class="line">struct Grade &#123;</span><br><span class="line">    subscript(num: Int) -&gt;String &#123;</span><br><span class="line">        if num &lt; 60 &#123;</span><br><span class="line">            return &quot;不及格&quot;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;及格&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let grade = Grade()</span><br><span class="line">print(grade[99])</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">及格</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习40：枚举</title>
      <link href="/BboyZJ.github.io/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A040%EF%BC%9A%E6%9E%9A%E4%B8%BE/"/>
      <url>/BboyZJ.github.io/2023/03/05/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A040%EF%BC%9A%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><ul><li><p><code>枚举</code> 是一种 <code>数据类型</code>，只包含自定义的特定数据</p></li><li><p>枚举 <code>是一组有共同特性的数据集合</code>，使你可以在你的代码中以 <code>类型安全</code> 的方式来使用这些值。</p></li></ul><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>在 <code>OC</code> 相比，枚举只支持 <code>整数型</code>；而在 <code>Swift</code> 中枚举有很多功能：</p><ul><li><p>可以定义 <code>成员类型</code>，支持 <code>Int、Double、String等基础类型</code>，也有 <code>默认枚举值</code></p></li><li><p>可以 <code>定义构造函数</code>（initializers）来提供一个初始成员值，可以在原始的实现基础上扩展他们的功能</p></li><li><p>可以 <code>关联枚举值</code></p></li><li><p><code>可以遵守协议（protocol）</code> 来 <code>提供标准化功能</code>。</p></li><li><p>可以 <code>嵌套枚举</code></p></li></ul><h1 id="枚举的语法"><a href="#枚举的语法" class="headerlink" title="枚举的语法"></a>枚举的语法</h1><ul><li><p>用 <code>enum</code> 关键字来定义一个枚举，然后将其所有的定义内容放在一个大括号 <code>&#123;&#125;</code> 中</p></li><li><p>多个成员值可以出现在同一行中，用逗号隔开</p></li><li><p>每个枚举都定义了一个全新的类型。正如swift中其它类型那样，它的名称（例如： ComP）需要首字母大写。给枚举类型起一个单数的而不是复数的名字，从而使得他们能够顾名思义</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">// 不需要逗号隔开</span><br><span class="line">enum ComP &#123;</span><br><span class="line">    case east</span><br><span class="line">    case south</span><br><span class="line">    case west</span><br><span class="line">    case north</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">// 也可以直接一个case，然后逗号隔开</span><br><span class="line">enum ComP2 &#123;</span><br><span class="line">    case east, south, west, north</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个枚举变量</span><br><span class="line">var comp = ComP.east</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">String类型的enum</span><br><span class="line">- =左边的值是枚举值，例如 MON</span><br><span class="line">- =右边的值在swift中称为 RawValue（原始值），例如 &quot;MON&quot;</span><br><span class="line">- 两者的关系为：case 枚举值 = rawValue原始值</span><br><span class="line">*/</span><br><span class="line">enum Week: String &#123;</span><br><span class="line">    case MON = &quot;MON&quot;</span><br><span class="line">    case TUE = &quot;TUE&quot;</span><br><span class="line">    case WED = &quot;WED&quot;</span><br><span class="line">    case THU = &quot;THU&quot;</span><br><span class="line">    case FRI = &quot;FRI&quot;</span><br><span class="line">    case SAT = &quot;SAT&quot;</span><br><span class="line">    case SUN = &quot;SUN&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不想写枚举后的字符串，也可以使用 <code>隐士RawValue</code> 分配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Week: String&#123;</span><br><span class="line">    case MON, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;</span><br><span class="line">var w = Week.MON.rawValue</span><br><span class="line">print(w)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">MON</span><br></pre></td></tr></table></figure><h1 id="使用-Switch-语句来匹配枚举值"><a href="#使用-Switch-语句来匹配枚举值" class="headerlink" title="使用 Switch 语句来匹配枚举值"></a>使用 Switch 语句来匹配枚举值</h1><ul><li>你可以用 <code>switch</code> 语句来匹配每一个单独的枚举值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// switch 访问枚举</span><br><span class="line">let week = Week.MON</span><br><span class="line">switch week &#123;</span><br><span class="line">case .TUE:</span><br><span class="line">    print(&quot;TUE&quot;)</span><br><span class="line">case .WED:</span><br><span class="line">    print(&quot;WED&quot;)</span><br><span class="line">case .THU:</span><br><span class="line">    print(&quot;TUE&quot;)</span><br><span class="line">case .FRI:</span><br><span class="line">    print(&quot;FRI&quot;)</span><br><span class="line">case .SAT:</span><br><span class="line">    print(&quot;SAT&quot;)</span><br><span class="line">case .SUN:</span><br><span class="line">    print(&quot;SUN&quot;)</span><br><span class="line">case .MON:</span><br><span class="line">    print(&quot;MON&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">MON</span><br></pre></td></tr></table></figure><ul><li><code>CaseIterable协议</code> 通常用于没有关联值的枚举，只需要遵守 <code>CaseIterable</code> 协议来 <code>允许枚举被遍历</code>，写法：在枚举名后面写 <code>:CaseIterable</code>，然后通过 <code>allCases</code> 获取所有枚举值，如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 遍历枚举</span><br><span class="line">enum Direction : CaseIterable&#123;</span><br><span class="line">    case east</span><br><span class="line">    case south</span><br><span class="line">    case west</span><br><span class="line">    case north</span><br><span class="line">&#125;</span><br><span class="line">for direction in Direction.allCases &#123;</span><br><span class="line">    print(direction)</span><br><span class="line">&#125;</span><br><span class="line">或 高阶函数</span><br><span class="line">Direction.allCases.map &#123; print($0) &#125;</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">east</span><br><span class="line">south</span><br><span class="line">west</span><br><span class="line">north</span><br></pre></td></tr></table></figure><p><strong>string 类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// string 类型</span><br><span class="line">enum Direction2: String &#123;</span><br><span class="line">    case east, south, west, north</span><br><span class="line">&#125;</span><br><span class="line">extension Direction2: CaseIterable &#123;&#125;</span><br><span class="line">Direction2.allCases.map&#123; print( $0 ) &#125;</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">east</span><br><span class="line">south</span><br><span class="line">west</span><br><span class="line">north</span><br></pre></td></tr></table></figure><h1 id="枚举-关联值-和-枚举值"><a href="#枚举-关联值-和-枚举值" class="headerlink" title="枚举 关联值 和 枚举值"></a>枚举 关联值 和 枚举值</h1><p>枚举中有两个很容易混淆的概念：<code>原始值(raw value)</code>、<code>关联值(associated value)</code>，两个词听起来比较模糊，下面简单介绍一下：</p><ul><li>原始值(raw value)</li></ul><p>枚举成员可以用相同类型的默认值预先填充，这样的值我们称为 <code>原始值(raw value)</code></p><p>下面的 <code>StudentType</code> 中三个成员分别被 <code>Int</code> 类型的 <code>10 、15、 20</code> 填充表示不同阶段学生的年龄。注意：<code>Int</code> 修饰的是 <code>StudentType</code> 成员原始值的类型而不是 <code>StudentType</code> 的类型，StudentType类型从定义开始就是一个全新的枚举类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum StudentType: Int&#123;</span><br><span class="line">      case pupil = 10</span><br><span class="line">      case middleSchoolStudent = 15</span><br><span class="line">      case collegeStudents = 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好StudentType成员的原始值之后，我们可以使用枚举成员的 <code>rawValue</code> 属性来访问成员的原始值，或者是使用原始值初始化器来尝试创建一个枚举的新实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//  常量student1值是 10</span><br><span class="line">let student1 = StudentType.pupil.rawValue</span><br><span class="line">//  变量student2值是 15</span><br><span class="line">var student2 = StudentType.middleSchoolStudent.rawValue</span><br><span class="line">//  使用成员rawValue属性创建一个`StudentType`枚举的新实例</span><br><span class="line">let student3 = StudentType.init(rawValue: 15)</span><br><span class="line">//  student3的值是 Optional&lt;Senson&gt;.Type</span><br><span class="line">type(of: student3)</span><br><span class="line">//  student4的值是nil，因为并不能通过整数30得到一个StudentType实例的值</span><br><span class="line">let student4 = StudentType.init(rawValue: 30)</span><br></pre></td></tr></table></figure><p>使用原始值初始化器这种方式初始化创建得到 <code>StudentType</code> 的实例 <code>student4</code> 是一个<code>StudentType</code> 的可选类型，因为并不是给定一个年龄就能找到对应的学生类型，比如在<code>StudentType</code> 中给定年龄为30就找不到对应的学生类型（很可能30岁的人已经是博士了）。所以原始值初始化器是一个可失败初始化器。</p><p>总结一句：原始值是为枚举的成员们绑定了一组类型必须相同值不同的固定的值（可能是整型，浮点型，字符类型等等）。这样很好解释为什么提供原始值的时候用的是等号。</p><ul><li><p>枚举的关联值(associated value)</p><ul><li>如果希望用枚举表示复杂的含义，关联更多的信息，就需要使用关联值了。</li><li>他与普通类型的枚举不同：<code>没有rawValue，没有rawValue的getter方法；没有初始化init方法</code>。</li><li>关联值更像是为枚举的成员们绑定了一组类型，不同的成员可以是不同的类型(提供关联值时用的是括号)。例如下面的代码：</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 关联值</span><br><span class="line">// 注：当使用了关联值后，就没有RawValue了</span><br><span class="line">// 因为：case可以用一组值来表示，而rawValue是单个的值</span><br><span class="line">// 定义一个表示学生类型的枚举类型 StudentType，他有三个成员分别是pupil、middleSchoolStudent、collegeStudents</span><br><span class="line">enum StudentType &#123;</span><br><span class="line">    case pupil(String)</span><br><span class="line">    case middleSchoolStudent(Int, String)</span><br><span class="line">    case collegeStudents(Int, String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们并没有为 <code>StudentType</code> 的成员提供具体的值，而是为他们绑定了不同的类型，分别是<code>pupil</code> 绑定 <code>String</code> 类型，<code>middleSchoolStudent </code>和 <code>collegeStudents</code> 绑定 <code>（Int， String）</code> 元祖类型。接下来就可以创建不同 <code>StudentType</code> 枚举实例并为对应的成员赋值了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// student1 是一个StudentType类型的常量，其值为pupil（小学生），特征是&quot;have fun&quot;（总是在玩耍）</span><br><span class="line">let student1 = StudentType.pupil(&quot;have fun&quot;)</span><br><span class="line">// student2 是一个StudentType类型的常量，其值为middleSchoolStudent（中学生），特征是 7, &quot;always study&quot;（一周7天总是在学习）</span><br><span class="line">let student2 = StudentType.middleSchoolStudent(7, &quot;always study&quot;)</span><br><span class="line">// student3 是一个StudentType类型的常量，其值为collegeStudent（大学生），特征是 7, &quot;always LOL&quot;（一周7天总是在撸啊撸）</span><br><span class="line">let student3 = StudentType.middleSchoolStudent(7, &quot;always LOL&quot;)</span><br></pre></td></tr></table></figure><p>这个时候如果需要判断某个 <code>StudentType</code> 实例的具体的值就需要这样做了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch student3 &#123;</span><br><span class="line">      case .pupil(let things):</span><br><span class="line">          print(&quot;is a pupil and \(things)&quot;)</span><br><span class="line">      case .middleSchoolStudent(let day, let things):</span><br><span class="line">          print(&quot;is a middleSchoolStudent and \(day) days \(things)&quot;)</span><br><span class="line">      case .collegeStudent(let day, let things):</span><br><span class="line">          print(&quot;is a collegeStudent and \(day) days \(things)&quot;)</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><p>控制台输出：<code>is a collegeStudent and 7 days always LOL</code>，看到这你可能会想，是否可以为一个枚举成员提供原始值并且绑定类型呢，答案是不能的！因为首先给成员提供了固定的原始值，那他以后就不能改变了；而为成员提供关联值(绑定类型)就是为了创建枚举实例的时候赋值。这不是互相矛盾吗。</p><h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><p><code>enum</code> 中的模式匹配其实就是 <code>匹配case枚举值</code>，根据枚举类型，分为2种：</p><p>1、<code>简单类型</code> 的枚举的模式匹配；<br>2、<code>自定义类型</code> 的枚举（关联值）的模式匹配。</p><ul><li>简单enum的模式匹配</li></ul><blockquote><p>注：swift中的enum <code>模式匹配需要将所有情况都列举</code>，或者使用 <code>default</code> 表示默认情况，否则会报错</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 模式匹配</span><br><span class="line">enum Week: String&#123;</span><br><span class="line">    case MON, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;</span><br><span class="line">var current: Week?</span><br><span class="line">switch current &#123;</span><br><span class="line">    case .MON: print(Week.MON.rawValue)</span><br><span class="line">    case .TUE: print(Week.TUE.rawValue)</span><br><span class="line">    default: print(&quot;unknow day&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">======</span><br><span class="line">unknow day</span><br></pre></td></tr></table></figure><ul><li>关联值类型的模式匹配</li></ul><p>关联值类型的模式匹配有两种方式：</p><p>1、<code>switch - case</code>， 匹配所有case；<br>2、<code>if - case</code>， 匹配单个case</p><p><strong>switch - case</strong></p><p>定义关联值枚举：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Shape&#123;</span><br><span class="line">    case circle(radius: Double)</span><br><span class="line">    case rectangle(width: Int, height: Int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以 <code>let、var</code> 修饰关联值的入参：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/ 定义关联值枚举</span><br><span class="line">enum Shape&#123;</span><br><span class="line">    // case枚举值后括号内的就是关联值，如 radius</span><br><span class="line">    case circle(radius: Double)</span><br><span class="line">    case rectangle(width: Int,height: Int)</span><br><span class="line">&#125;</span><br><span class="line">// 定义枚举变量</span><br><span class="line">let shape = Shape.circle(radius: 10.0)</span><br><span class="line">switch shape &#123;</span><br><span class="line">    // 关联外部</span><br><span class="line">    case let .circle(radius):</span><br><span class="line">        print(&quot;circle radius: \(radius)&quot;)</span><br><span class="line">    // 关联内部</span><br><span class="line">    case .rectangle(let width,var height):</span><br><span class="line">        height += 1</span><br><span class="line">        print(&quot;rectangle width: \(width) height: \(height)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">let shape2 = Shape.rectangle(width: 1, height: 2)</span><br><span class="line">switch shape2 &#123;</span><br><span class="line">    case let .circle(radius):</span><br><span class="line">        print(&quot;circle radius: \(radius)&quot;)</span><br><span class="line">    case .rectangle(let width,var height):</span><br><span class="line">        height += 10</span><br><span class="line">    print(&quot;rectangle width: \(width) height: \(height)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">circle radius: 10.0</span><br><span class="line">rectangle width: 1 height: 12</span><br></pre></td></tr></table></figure><p>通过 <code>if-case</code> 匹配单个case，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 单个匹配</span><br><span class="line">let circle = Shape.circle(radius: 5.0)</span><br><span class="line">if case let Shape.circle(radius) = circle &#123;</span><br><span class="line">    print(&quot;circle radius: \(radius)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">circle radius: 5.0</span><br></pre></td></tr></table></figure><ul><li>如果我们只关心 <code>不同case的相同关联值(即关心不同case的某一个值)</code>，需要使用 <code>同一个参数</code>。<br>例如，案例中的x，如果分别使用x、y, 编译器会报错：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum Shape&#123;</span><br><span class="line">    case circle(radius: Double)</span><br><span class="line">    case rectangle(width: Double, height: Double)</span><br><span class="line">    case square(width: Double, height: Double)</span><br><span class="line">&#125;</span><br><span class="line">let shape = Shape.circle(radius: 10)</span><br><span class="line">switch shape&#123;</span><br><span class="line">    case let .circle(x), let .square(20, x):</span><br><span class="line">        print(x)</span><br><span class="line">    default:</span><br><span class="line">        break</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">====</span><br><span class="line">10.0</span><br></pre></td></tr></table></figure><p>也可以使用 <code>通配符_（表示匹配一切）</code> 的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum Shape&#123;</span><br><span class="line">    case circle(radius: Double)</span><br><span class="line">    case rectangle(width: Double, height: Double)</span><br><span class="line">    case square(width: Double, height: Double)</span><br><span class="line">&#125;</span><br><span class="line">let shape = Shape.rectangle(width: 2.0, height: 2.0)</span><br><span class="line">switch shape &#123;</span><br><span class="line">case let .rectangle(x, _), let .square(_,x):</span><br><span class="line">    print(&quot;square：\(x * x)&quot;)</span><br><span class="line">default:</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">square：4.0</span><br></pre></td></tr></table></figure><p>注：枚举使用过程中 <code>不关心某一个关联值</code>，可以使用 <code>通配符_</code> 表示。OC 只能调用 swift 中 <code>Int类型</code> 的枚举。</p><h1 id="属性-amp-函数"><a href="#属性-amp-函数" class="headerlink" title="属性 &amp; 函数"></a>属性 &amp; 函数</h1><ul><li><code>enum</code> 中可以包含 <code>成员类型、计算属性、类型属性</code>，不能包含 <code>存储属性</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">enum Direct: Int &#123;</span><br><span class="line">    // 成员类型</span><br><span class="line">    case up</span><br><span class="line">    case down</span><br><span class="line">    case left</span><br><span class="line">    case right</span><br><span class="line">    </span><br><span class="line">    // 计算属性</span><br><span class="line">    var desc: String &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .up:</span><br><span class="line">            return &quot;up&quot;</span><br><span class="line">        case .down:</span><br><span class="line">            return &quot;down&quot;</span><br><span class="line">        default:</span><br><span class="line">            return &quot;这是self&quot;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 存储属性：编译器报错，Enums must not contain stored properties</span><br><span class="line">    // var radius: Double</span><br><span class="line">    </span><br><span class="line">    // 类型属性</span><br><span class="line">    static let height = 20.0</span><br><span class="line">    </span><br><span class="line">    // 函数</span><br><span class="line">    func printSelf() &#123;</span><br><span class="line">        print(desc)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 异变函数</span><br><span class="line">    mutating func nextDay() &#123;</span><br><span class="line">        if self == .up &#123;</span><br><span class="line">            self = Direct(rawValue: 1)!</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            self = Direct(rawValue: self.rawValue+1)!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Direct.down.printSelf()</span><br><span class="line">// 打印结果：down</span><br><span class="line"></span><br><span class="line">var direct = Direct.left</span><br><span class="line">direct.nextDay()</span><br><span class="line">// 打印结果是 right</span><br><span class="line">direct.printSelf()</span><br><span class="line">// 打印结果是 right</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>为什么 <code>struct</code> 或 <code>class</code> 中可以放 <code>存储属性</code>，而 <code>enum</code> 不可以？<br><code>struct</code> 中可以包含存储属性，是因为其大小就是 <code>存储属性的大小</code>。而 <code>enum</code> 是不一样的（请查阅后文的enum大小讲解），<code>enum枚举的大小是取决于case的个数的</code>，如果没有超过255，enum的大小就是1字节（8位）</p></blockquote><ul><li>可以在 <code>enum</code> 中定义 <code>实例方法、static修饰的方法</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">enum Week: Int &#123;</span><br><span class="line">    case MON, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">    </span><br><span class="line">    // 实例方法</span><br><span class="line">    mutating func nextDay() &#123;</span><br><span class="line">        if self == .SUN &#123;</span><br><span class="line">            self = Week(rawValue: 0)!</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            self = Week(rawValue: self.rawValue+1)!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 使用</span><br><span class="line">var w = Week.MON</span><br><span class="line">w.nextDay()</span><br><span class="line">print(w)</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">TUE</span><br></pre></td></tr></table></figure><ul><li>可以在 <code>enum</code> 中定义 <code>下标脚本</code>，用于获取值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定义下标脚本</span><br><span class="line">enum Direct &#123;</span><br><span class="line">    case east, south, west, north</span><br><span class="line">    // 下标</span><br><span class="line">    subscript(index: Int) -&gt; Int&#123;</span><br><span class="line">        return index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var direct = Direct.east</span><br><span class="line">print(direct[4])</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>定义 <code>构造器</code> 用于 <code>初始化值</code></li></ul><p>枚举与结构体和类的构造方法最大的不同在于，枚举的构造方法需要将隐式的 <code>self</code> 属性设置为正确的 <code>case</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 定义初始化器</span><br><span class="line">enum Num&#123;</span><br><span class="line">    // 成员类型</span><br><span class="line">    case Small, Medium, Big, Huge</span><br><span class="line">    // 定义初始化器</span><br><span class="line">    init(number n: Int) &#123;</span><br><span class="line">        if n &lt; 10 &#123; self = .Small &#125;</span><br><span class="line">        else if n &lt; 20 &amp;&amp; n &gt;= 10 &#123; self = .Medium &#125;</span><br><span class="line">        else if n &lt; 30 &amp;&amp; n &gt;= 20 &#123; self = .Big &#125;</span><br><span class="line">        else &#123; self = .Huge &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let num = Num(number: 30)</span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure><h1 id="枚举的嵌套"><a href="#枚举的嵌套" class="headerlink" title="枚举的嵌套"></a>枚举的嵌套</h1><p>枚举的嵌套主要用于以下场景：<br>1、<code>枚举嵌套枚举</code>：一个复杂枚举是由一个或多个枚举组成；<br>2、<code>结构体嵌套枚举</code>：enum是不对外公开的，即是 <code>私有</code> 的。</p><ul><li>enum 嵌套 enum</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum CombineDirect &#123;</span><br><span class="line">    // 枚举中嵌套枚举</span><br><span class="line">    enum BaseDirect &#123;</span><br><span class="line">        case up,down,lett,right</span><br><span class="line">    &#125;</span><br><span class="line">    // 通过内部枚举组合的枚举值</span><br><span class="line">    case leftUp(baseDirect1: BaseDirect,baseDirect2: BaseDirect)</span><br><span class="line">    case leftDown(baseDirect1: BaseDirect,baseDirect2: BaseDirect)</span><br><span class="line">    case rightUp(baseDirect1: BaseDirect,baseDirect2: BaseDirect)</span><br><span class="line">    case rightDown(baseDirect1: BaseDirect,baseDirect2: BaseDirect)</span><br><span class="line">&#125;</span><br><span class="line">// 使用</span><br><span class="line">let direct = CombineDirect.leftUp(baseDirect1: CombineDirect.BaseDirect.lett, baseDirect2: CombineDirect.BaseDirect.up)</span><br><span class="line">print(direct)</span><br></pre></td></tr></table></figure><ul><li>结构体 嵌套 enum</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct Skill &#123;</span><br><span class="line">    // 结构体嵌套枚举</span><br><span class="line">    enum KeyType &#123;</span><br><span class="line">        case up,down,lett,right</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 存储属性</span><br><span class="line">    let key: KeyType</span><br><span class="line">    </span><br><span class="line">    // 函数</span><br><span class="line">    func launchSkill() &#123;</span><br><span class="line">        switch key &#123;</span><br><span class="line">        case .lett, .right:</span><br><span class="line">            print(&quot;left,right&quot;)</span><br><span class="line">        case .up, .down:</span><br><span class="line">            print(&quot;up,down&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举的递归"><a href="#枚举的递归" class="headerlink" title="枚举的递归"></a>枚举的递归</h1><ul><li>枚举的递归：<code>indirect</code></li></ul><p><code>递归枚举</code> 是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。你可以在枚举成员前加上 <code>indirect</code> 来表示该成员可递归。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 一、用枚举表示链表结构</span><br><span class="line">enum List&lt;T&gt; &#123;</span><br><span class="line">    case end</span><br><span class="line">    // 表示case是用引用来存储</span><br><span class="line">    indirect case node(T,next: List&lt;T&gt;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 二、也可以将indirect放在enum前</span><br><span class="line">// 表示整个enum是用引用来存储</span><br><span class="line">indirect enum List&lt;T&gt;&#123;</span><br><span class="line">    case end</span><br><span class="line">    case node(T, next: List&lt;T&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种写法，如果没有关键字 <code>indirect</code>，编译报错。原因是使用该枚举时，<code>enum的大小需要case来确定</code>，而case的大小又需要使用到enum大小。所以无法计算enmu的大小，于是报错！<br>根据编译器提示，需要使用 <code>关键字indirect</code>，意思就是将该枚举标记位递归，同时也支持标记单个case。</p><p><code>indirect关键字</code> 其实就是通知编译器，我当前的enum是递归的，大小是不确定的，需要 <code>分配一块堆区的内存空间</code>，用来存放enum。</p><h1 id="swift-和-oc-混编-enum"><a href="#swift-和-oc-混编-enum" class="headerlink" title="swift 和 oc 混编 enum"></a>swift 和 oc 混编 enum</h1><p>在 <code>Swift</code> 中 <code>enum</code> 非常强大，而在 <code>OC</code> 中，<code>enum</code> 仅仅只是一个 <code>整数型</code>。<br>因此，OC调用Swift枚举，必须具备2个条件：①、<code>用@objc关键字标记enum</code>；②、<code>当前enum应该是Int类型。</code></p><ul><li><code>OC</code> 中使用 <code>Swift</code> 枚举</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 枚举</span><br><span class="line">@objc enum Weak: Int &#123;</span><br><span class="line">    case MON, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// OC 使用</span><br><span class="line">// 1. 用@objc关键字标记enum,当前enum应该是Int类型。</span><br><span class="line">// 2. 导入头文件 xxx-Swift.h</span><br><span class="line">- (void)testEnum&#123;</span><br><span class="line">    Weak mon = WeakMON;</span><br><span class="line">    NSLog(@&quot;mon:%ld&quot;,(long)mon);</span><br><span class="line">    // 打印结果 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Swift 使用 <code>OC</code> 枚举，OC 中的枚举会自动转换成 <code>swift中的enum</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// OC定义1：NS_ENUM</span><br><span class="line">NS_ENUM(NSInteger,ENUM_OC_TYPE)&#123;</span><br><span class="line">    Value1,</span><br><span class="line">    Value2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// OC定义2：typedef enum</span><br><span class="line">typedef enum&#123;</span><br><span class="line">    Num1,</span><br><span class="line">    num2</span><br><span class="line">&#125;OCEnumType;</span><br><span class="line"></span><br><span class="line">// Swift 中使用 OC 枚举</span><br><span class="line">// 1. 将OC头文件导入桥接文件 xxx-Bridging-Header.h</span><br><span class="line">#import &quot;xxx.h&quot;</span><br><span class="line">// 2. 使用</span><br><span class="line">let ocEnum1 = ENUM_OC_TYPE.Value1.rawValue;</span><br><span class="line">let ocEnum2 = OCEnumType.init(rawValue: 0)</span><br><span class="line">print(&quot;\(ocEnum1)\n\(ocEnum2.rawValue)&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC组件化06：Github-Desktop管理工具使用</title>
      <link href="/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9606%EF%BC%9AGithub-Desktop%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9606%EF%BC%9AGithub-Desktop%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>GitHub Desktop 简单说就是 <code>图形界面</code> 版的 <code>Git</code>，不需要命令行的操作</p><p>通过 <a href="https://desktop.github.com/">GitHub官网</a> 可以下载、安装使用</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li><p>注册你的 <code>GitHub</code> 账号，已注册 <code>GitHub</code> 账号的，跳过</p></li><li><p>在 <code>GitHub Desktop</code> 登录你的账号</p></li></ul><h1 id="创建仓库：File-gt-new-repository"><a href="#创建仓库：File-gt-new-repository" class="headerlink" title="创建仓库：File -&gt; new repository"></a>创建仓库：File -&gt; new repository</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042347662.png"></p><h1 id="创建分支：branch-gt-new-branch"><a href="#创建分支：branch-gt-new-branch" class="headerlink" title="创建分支：branch -&gt; new branch"></a>创建分支：branch -&gt; new branch</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042347152.png"></p><ul><li>创建一个开发的分支 <code>zj_feature</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042348162.png"></p><h1 id="克隆仓库到-GitHub-Desktop"><a href="#克隆仓库到-GitHub-Desktop" class="headerlink" title="克隆仓库到 GitHub Desktop"></a>克隆仓库到 GitHub Desktop</h1><ul><li>File -&gt; Clone Repository</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042348676.png"></p><ul><li>切换分支</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042348034.png"></p><h1 id="修改工程代码，将-0-2-0-版本代码完成，并提交到新分支-zj-feature"><a href="#修改工程代码，将-0-2-0-版本代码完成，并提交到新分支-zj-feature" class="headerlink" title="修改工程代码，将 0.2.0 版本代码完成，并提交到新分支 zj_feature"></a>修改工程代码，将 0.2.0 版本代码完成，并提交到新分支 zj_feature</h1><ul><li><p>Summary：必填 0.2.0</p></li><li><p>Description：描述 0.2.0 版本的内容</p></li><li><p>Commit to zj_feature</p></li><li><p>push origin</p></li></ul><h1 id="合并分支："><a href="#合并分支：" class="headerlink" title="合并分支："></a>合并分支：</h1><ul><li>先切换到 <code>main</code> 主分支</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042348854.png"></p><ul><li>合并分支：branch菜单 -&gt; merge into current branch</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042348376.png"></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042349579.png"></p><h1 id="提交-main-分支"><a href="#提交-main-分支" class="headerlink" title="提交 main 分支"></a>提交 main 分支</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042349550.png"></p><h1 id="删除分支：菜单branch-gt-delete-删除分支"><a href="#删除分支：菜单branch-gt-delete-删除分支" class="headerlink" title="删除分支：菜单branch -&gt; delete 删除分支"></a>删除分支：菜单branch -&gt; delete 删除分支</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042349616.png"></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042350674.png"></p><h1 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h1><ul><li><p>还未提交代码：文件右键 -&gt; <code>Discard Changes</code> 放弃更改</p></li><li><p>已经提交代码：文件右键选择 -&gt; <code>Revert This Commit</code> 恢复到当前提交</p></li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>打开项目代码：Show in Finder</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042351545.png"></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042351468.png"></p><ul><li>所有 <code>新增代码</code> 可以在工程项目中实时修改，并可以运行查看效果</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042351431.png"></p><ul><li>在 GitHub Desktop 上可以看到实时的修改</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042352356.png"></p><ul><li>修改完记得修改一下版本号</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042353544.png"></p><ul><li>提交代码到 <code>本地mian</code> 分支</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042353044.png"></p><ul><li>提交代码到 <code>远程main</code> 分支</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042354437.png"></p><h1 id="终端搜索-ZJWeakProxy-库"><a href="#终端搜索-ZJWeakProxy-库" class="headerlink" title="终端搜索 ZJWeakProxy 库"></a>终端搜索 ZJWeakProxy 库</h1><p><code>mac@bogon ~ % pod search ZJWeakProxy</code></p><p>【问题：】未搜索到自己创建的组件库</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042353662.png"></p><p>解决方法：更新本地Pod的索引文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % rm ~/Library/Caches/CocoaPods/search_index.json</span><br><span class="line">mac@bogon ~ % pod repo update</span><br></pre></td></tr></table></figure><p>如果还是搜索不到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % sudo gem install -n /usr/local/bin cocoapods --pre </span><br><span class="line">mac@bogon ~ % pod setup</span><br></pre></td></tr></table></figure><ul><li>再次搜索</li></ul>]]></content>
      
      
      <categories>
          
          <category> Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC组件化05：【方案二】cocoapods组件化</title>
      <link href="/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9605%EF%BC%9A%E3%80%90%E6%96%B9%E6%A1%88%E4%BA%8C%E3%80%91cocoapods%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
      <url>/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9605%EF%BC%9A%E3%80%90%E6%96%B9%E6%A1%88%E4%BA%8C%E3%80%91cocoapods%E7%BB%84%E4%BB%B6%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul><li>随着公司业务的不断发展，应用的代码体积将会越来越大，业务代码耦合也越来越多，代码量也是急剧增加</li><li>如果仅仅完成代码拆分还不足以解决业务之间的代码耦合，而组件化是一种能够解决代码耦合、业务工程能够独立运行的技术</li><li>这篇文章主要介绍远程私有库的创建和管理以及本地索引库的使用</li></ul><p>本文以创建 <code>公有库</code> 为例</p><h1 id="查看本地索引库"><a href="#查看本地索引库" class="headerlink" title="查看本地索引库"></a>查看本地索引库</h1><ul><li>我们用 <code>cocoaPods</code> 的时候，默认使用的是cocoaPods自带的索引库<br>终端中使用命令 <code>$ pod repo</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cocoapods</span><br><span class="line">- Type: git (remotes/origin/master)</span><br><span class="line">- URL:  https://github.com/CocoaPods/Specs.git</span><br><span class="line">- Path: /Users/mac/.cocoapods/repos/cocoapods</span><br><span class="line"></span><br><span class="line">trunk</span><br><span class="line">- Type: CDN</span><br><span class="line">- URL:  https://cdn.cocoapods.org/</span><br><span class="line">- Path: /Users/mac/.cocoapods/repos/trunk</span><br><span class="line"></span><br><span class="line">2 repos</span><br></pre></td></tr></table></figure><h1 id="组件化分类"><a href="#组件化分类" class="headerlink" title="组件化分类"></a>组件化分类</h1><ul><li><p>公有库：所有人都能使用</p></li><li><p>私有库：公司内部拥有特殊权限才能使用</p></li><li><p>framework：公私都有，动态库静态库。只能看到.h文件。</p></li></ul><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li><p><code>GitHub</code> 账号一个：上传组件工程用</p></li><li><p>安装 <code>CocoaPods</code>：创建并验证 <code>pod</code> 用</p></li><li><p>安装 <code>Git</code> 命令行 ：首次上传组件工程用</p></li><li><p>安装 <code>Github Desktop</code> 或者 <code>SourceTree</code>：后续更新组件用的，Git命令使用熟练者忽略此项</p></li></ul><h1 id="创建公有库"><a href="#创建公有库" class="headerlink" title="创建公有库"></a>创建公有库</h1><ul><li>首先在 <code>Github</code> 创建一个新的 <code>Repository</code>，你的 <code>pods</code> 最终要托管在 <code>Github</code> 平台上的，所以在 <code>Github</code> 上创建一个空的 <code>Repository</code></li></ul><p>注意：<code>库名 = 项目前缀 + 组件名称 </code> ，如 ZJWeakProxy &#x3D; 解决循环引用组件库</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042335079.png"></p><ul><li>创建完成后的信息如下：</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042335792.png"></p><h1 id="注册-cocoapods-账户"><a href="#注册-cocoapods-账户" class="headerlink" title="注册 cocoapods 账户"></a>注册 cocoapods 账户</h1><ul><li><p>先安装 <code>cocoapods</code>，这个很简单，可以百度搜索自行安装</p></li><li><p>想要创建一个开源 <code>pod</code> 库，首先我们需要注册 <code>cocoapods账户</code>，基于 <code>cocoapods</code> 已经安装好的前提下，这里直接使用 <code>trunk</code> 去注册 <code>cocopods账户</code>，在终端执行：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod trunk register 邮箱地址 &#x27;用户名&#x27; --verbose</span><br><span class="line">mac@bogon ~ % pod trunk register 13718004742@163.com &#x27;BboyZJ&#x27; --verbose</span><br></pre></td></tr></table></figure><p>邮箱地址：一般会使用 GitHub邮箱<br>用户名：随便</p><ul><li>注册之后，在邮箱会受到确认邮件</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042335229.png"></p><ul><li>注册成功之后可以在终端 <code>验证是否注册成功</code>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 验证是否注册成功</span><br><span class="line">mac@bogon ~ % pod trunk me</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>查看注册信息，以后可以使用该开源pod库发布工具，也可以通过此方式查看已经发布过的pods：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % pod trunk me</span><br><span class="line">  - Name:     BboyZJ</span><br><span class="line">  - Email:    13718004742@163.com</span><br><span class="line">  - Since:    October 20th, 2021 19:20</span><br><span class="line">  - Pods:</span><br><span class="line">    - ZJSDKDemo</span><br><span class="line">    - ZJSDK_iOS</span><br><span class="line">  - Sessions:</span><br><span class="line">    - October 20th, 2021 19:20 - March 31st, 2022 04:01. IP: 114.253.15.66 </span><br><span class="line">    Description: imac</span><br><span class="line">    - February 27th, 02:33     -        July 5th, 02:37. IP:</span><br><span class="line">    114.252.233.188</span><br></pre></td></tr></table></figure><h1 id="在本地创建pod库"><a href="#在本地创建pod库" class="headerlink" title="在本地创建pod库"></a>在本地创建pod库</h1><ul><li>利用pod命令创建名为 <code>ZJWeakProxy</code> 的 <code>pod</code> 库</li></ul><p>注：这个名字要和 <code>GitHub</code> 创建的 <code>Repository</code> 名一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cd 到桌面文件夹(组件文件夹)ZJComponent目录下，这个不强制随意</span><br><span class="line">mac@bogon ~ % cd ZJComponent </span><br><span class="line"># 执行 pod lib create ZJWeakProxy</span><br><span class="line">mac@bogon ~ % pod lib create ZJWeakProxy</span><br></pre></td></tr></table></figure><ul><li>出现 fatal: unable to access ‘<a href="https://github.com/CocoaPods/pod-template.git/">https://github.com/CocoaPods/pod-template.git/</a>‘: HTTP&#x2F;2 stream 1 was not closed cleanly before end of the underlying stream 报错</li></ul><p>原因分析：一般这是因为服务器的 <code>SSL</code> 证书没有经过第三方机构的签署，所以才报错</p><p>解决办法：解除 <code>SSL</code> 验证，再次执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ZJComponent % git config --global http.sslVerify false</span><br></pre></td></tr></table></figure><ul><li>执行完上述命令后，会问你几个问题，按需求填写即可</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 你想使用哪个平台？</span><br><span class="line">1、What platform do you want to use?? [ iOS / macOS ]</span><br><span class="line">iOS</span><br><span class="line"># 库语言选择？</span><br><span class="line">2、What language do you want to use?? [ Swift / ObjC ]</span><br><span class="line">ObjC</span><br><span class="line"># 是否需要一个demo工程，用于调试Pod？</span><br><span class="line">3、Would you like include a demo application with your library? [ Yes / No ]</span><br><span class="line">Yes</span><br><span class="line"># 你要使用哪个测试框架？</span><br><span class="line">4、Which testing frameworks will you use? [ Specta / Kiwi / None ]</span><br><span class="line">None</span><br><span class="line"># 是否要UI测试？</span><br><span class="line">5、Would you like to do view based testing? [ Yes / No ]</span><br><span class="line">NO</span><br><span class="line"># 类名前缀？</span><br><span class="line">6、What is your class prefix?</span><br><span class="line">ZJ</span><br></pre></td></tr></table></figure><ul><li>到这里 <code>pod</code> 库就创建完成了，它会自己打开刚才创建的pod库</li></ul><h1 id="工程目录介绍"><a href="#工程目录介绍" class="headerlink" title="工程目录介绍"></a>工程目录介绍</h1><ul><li>目录结构如下：</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042336465.png"></p><p>【第1部分】：主要是用来编辑pod相关配置元数据区<br>【第2部分】：主要是用来验证pod效果区<br>【第3部分】：主要是用来 提供给别人使用暴露出来的pod，ReplaceMe空的可以删除，是提示我们可以添加自己的类</p><ul><li>配置 <code>podspec</code> 本地索引文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  # 库名称</span><br><span class="line">  s.name             = &#x27;ZJWeakProxy&#x27;</span><br><span class="line">  # 版本号</span><br><span class="line">  s.version          = &#x27;0.1.0&#x27;</span><br><span class="line">  # 库简短介绍</span><br><span class="line">  s.summary          = &#x27;A short description of ZJWeakProxy.&#x27;</span><br><span class="line"></span><br><span class="line"># This description is used to generate tags and improve search results.</span><br><span class="line">#   * Think: What does it do? Why did you write it? What is the focus?</span><br><span class="line">#   * Try to keep it short, snappy and to the point.</span><br><span class="line">#   * Write the description between the DESC delimiters below.</span><br><span class="line">#   * Finally, don&#x27;t worry about the indent, CocoaPods strips it!</span><br><span class="line"></span><br><span class="line">  # 开源库描述</span><br><span class="line">  s.description      = &lt;&lt;-DESC</span><br><span class="line">TODO: Add long description of the pod here.</span><br><span class="line">                       DESC</span><br><span class="line">  # 开源库地址，或者是博客、社交地址等</span><br><span class="line">  s.homepage         = &#x27;https://github.com/BboyZJ/ZJWeakProxy&#x27;</span><br><span class="line">  # s.screenshots     = &#x27;www.example.com/screenshots_1&#x27;, &#x27;www.example.com/screenshots_2&#x27;</span><br><span class="line">  # 开源协议</span><br><span class="line">  s.license          = &#123; :type =&gt; &#x27;MIT&#x27;, :file =&gt; &#x27;LICENSE&#x27; &#125;</span><br><span class="line">  # 开源库作者</span><br><span class="line">  s.author           = &#123; &#x27;BboyZJ&#x27; =&gt; &#x27;13718004742@163.com&#x27; &#125;</span><br><span class="line">  # 开源库资源文件</span><br><span class="line">  s.source           = &#123; :git =&gt; &#x27;https://github.com/BBoyZJ/ZJWeakProxy.git&#x27;, :tag =&gt; s.version.to_s &#125;</span><br><span class="line">  # 社交网址</span><br><span class="line">  # s.social_media_url = &#x27;https://twitter.com/&lt;TWITTER_USERNAME&gt;&#x27;</span><br><span class="line">  # 开源库最低支持</span><br><span class="line">  s.ios.deployment_target = &#x27;10.0&#x27;</span><br><span class="line">  # 开源库源文件</span><br><span class="line">  s.source_files = &#x27;ZJWeakProxy/Classes/**/*&#x27;</span><br><span class="line">  # 添加图片等资源文件</span><br><span class="line">  # s.resource_bundles = &#123;</span><br><span class="line">  #   &#x27;ZJWeakProxy&#x27; =&gt; [&#x27;ZJWeakProxy/Assets/*.png&#x27;]</span><br><span class="line">  # &#125;</span><br><span class="line">  </span><br><span class="line">  # s.public_header_files = &#x27;Pod/Classes/**/*.h&#x27;</span><br><span class="line">  # 依赖系统库 多个用逗号隔开</span><br><span class="line">  # s.frameworks = &#x27;UIKit&#x27;, &#x27;MapKit&#x27;</span><br><span class="line">  # 引入第三方依赖库</span><br><span class="line">  # s.dependency &#x27;AFNetworking&#x27;, &#x27;~&gt; 2.3&#x27;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>【s.dependency】：设置依赖三方库或其他组件，多个库可以分开写多次</p><ul><li>需要注意如图：</li></ul><p><img src="/BboyZJ.github.io/assets/16779442070174.jpg"></p><ul><li><code>Readme</code> 主要是介绍这个组件的用途和使用，可以随时编辑。目前就确认一下自己的名字和邮箱就可以了</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042336844.png"></p><ul><li>协议文件，也是确认一下自己的名字和邮箱就可以了</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042337356.png"></p><h1 id="添加自己的类"><a href="#添加自己的类" class="headerlink" title="添加自己的类"></a>添加自己的类</h1><ul><li>打开pod库目录，删除ReplaceMe</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042337055.png"></p><ul><li>创建 <code>ZJWeakProxy</code> 简单类，声明一个打印函数，方便后续测试</li></ul><p><strong>注：创建类文件一定要放到 Classes 目录下</strong></p><p>.h 文件下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJWeakProxy.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ZJWeakProxy : NSProxy</span><br><span class="line">- (void)printZJWeakProxy;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>.m 文件下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJWeakProxy.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZJWeakProxy</span><br><span class="line">- (void)printZJWeakProxy&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042338285.png"></p><ul><li>此时 <code>cd</code> 到 <code>Example</code> 路径下执行 <code>pod install</code> 命令，看看是否能将刚刚添加的库文件引入到工程中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/ZJComponent/ZJWeakProxy/Example </span><br><span class="line">mac@bogon Example % pod install</span><br></pre></td></tr></table></figure><p>如果成功会在Pods中看到：</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042338860.png"></p><ul><li>可以到项目中导入头文件简单使用一下</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042343398.png"></p><p>证明是可用的</p><p>【注】：<code>CocoaPods</code> 工具的另外一个优点就是，多个组件依赖同一个组件时，它会自动帮你检测安装，而 <code>不会重复导入</code>。</p><h1 id="项目上传与发布"><a href="#项目上传与发布" class="headerlink" title="项目上传与发布"></a>项目上传与发布</h1><ul><li>cd到你的项目路径下，将项目上传到GitHub中（即刚刚创建的ZJWeakProxy公有库中），依次使用下列命令行，不要遗漏</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># cd 到 组件ZJWeakProxy路径下</span><br><span class="line">mac@bogon Example % cd /Users/mac/Desktop/ZJComponent/ZJWeakProxy</span><br><span class="line"># 添加github项目路径</span><br><span class="line">mac@bogon ZJWeakProxy % git remote add origin https://github.com/BboyZ/ZJWeakProxy.git</span><br><span class="line"># 添加文件</span><br><span class="line">mac@bogon ZJWeakProxy % git add .</span><br><span class="line"># 将暂存区里的改动提交到本地的版本库</span><br><span class="line">mac@bogon ZJWeakProxy % git commit -m &quot;first commit&quot;</span><br><span class="line"># 创建分支main</span><br><span class="line">mac@bogon ZJWeakProxy % git branch -M main</span><br><span class="line"># 提交版本号并push到main分支</span><br><span class="line">mac@bogon ZJWeakProxy % git push -u origin main</span><br></pre></td></tr></table></figure><ul><li>在执行 <code>git push -u origin main</code> 时，如果遇到需要输入用户名和密码：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Username for &#x27;https://github.com&#x27;: BboyZJ</span><br><span class="line">Password for &#x27;https://BboyZJ@github.com&#x27;:</span><br></pre></td></tr></table></figure><p><strong>【注意】</strong>：这个 <code>密码</code> 不是你 <code>GitHub</code> 的登录密码，而是需要生成一个 <code>access tokens</code></p><ul><li>生成 <code>access token</code></li></ul><p>需要在 <code>GitHub</code> 个人设置页 -&gt; Settings -&gt; Developer Settings -&gt; Personal access tokens 中创建一个 <code>token</code></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042343972.png"></p><ul><li><p>Generate new token 生成新的 <code>token</code></p><ul><li>设置 <code>token</code> 的有效期 按需设置，访问权限等</li></ul><p>  <img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042344432.png"></p><ul><li><p>选择要授予令牌token的范围或权限</p></li><li><p>要使用token从命令行访问仓库，请选择repo</p></li></ul><p>  <img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042344063.png"></p><ul><li>要使用token从命令行删除仓库，请选择delete_repo</li></ul><p> <img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042344513.png"></p><ul><li>其他根据需要进行勾选</li></ul></li><li><p>点击 <code>Generate token</code> 生成 <code>token</code></p></li></ul><p><code>ghp_VcqgAmF...ZPJ2IGxu0</code></p><p>【注】：记得把这个 <code>token</code> 保存下来，因为下次再刷新这个页面的时候，你会看不到了</p><ul><li>在命令行输入完 <code>token</code> 密码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Username for &#x27;https://github.com&#x27;: BboyZJ</span><br><span class="line">Password for &#x27;https://BboyZJ@github.com&#x27;: </span><br><span class="line">Enumerating objects: 91, done.</span><br><span class="line">Counting objects: 100% (91/91), done.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (83/83), done.</span><br><span class="line">Writing objects: 100% (91/91), 29.35 KiB | 2.45 MiB/s, done.</span><br><span class="line">Total 91 (delta 23), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (23/23), done.</span><br><span class="line">To https://github.com/BboyZJ/ZJWeakProxy.git</span><br><span class="line"> * [new branch]      main -&gt; main</span><br><span class="line">branch &#x27;main&#x27; set up to track &#x27;origin/main&#x27;.</span><br></pre></td></tr></table></figure><p>由上面看代表上传成功了</p><ul><li>打开浏览器 <a href="https://github.com/BboyZJ/ZJWeakProxy">https://github.com/BboyZJ/ZJWeakProxy</a> ，就可以看到你的pod库已经push上去了</li></ul><h1 id="打-tag-并发布到-Cocoapods"><a href="#打-tag-并发布到-Cocoapods" class="headerlink" title="打 tag 并发布到 Cocoapods"></a>打 tag 并发布到 Cocoapods</h1><p>至此，我们已经成功将本地的仓库关联并推送到远程仓库，现在我们需要发布一个可用的组件</p><ul><li>首先我们要给当前项目打一个 tag 版本号，在 podspec 中：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.version           = &#x27;0.1.0&#x27;</span><br></pre></td></tr></table></figure><p>指定的版本号是 0.1.0 ，那么我们就同样打个 0.1.0 的 tag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 打 tag </span><br><span class="line">mac@bogon ZJWeakProxy % git tag 0.1.0</span><br><span class="line">// 推送到远程</span><br><span class="line">mac@bogon ZJWeakProxy % git push --tags</span><br></pre></td></tr></table></figure><p>打 <code>tag</code> 默认在当前分支上，这里只有 <code>master</code> ，所以不用切换分支</p><h1 id="发布到-cocoapods"><a href="#发布到-cocoapods" class="headerlink" title="发布到 cocoapods"></a>发布到 cocoapods</h1><ul><li>我们创建的项目以及标签版本号都是沿用了 <code>podspec</code> 文件中的信息，因此可以直接验证 <code>podspec</code> 文件信息是否可以通过验证，<code>podspec</code> 文件的版本号一定要和 <code>tag</code> 保持一致</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ZJWeakProxy % pod spec link</span><br></pre></td></tr></table></figure><p>如果通过验证，那么你会看到类似下面的提示，绿色的 <code>passed validation</code></p><ul><li>首先要通过 <code>trunk</code> 注册生成一条会话：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// pod trunk register 邮箱 用户名 描述</span><br><span class="line">mac@bogon ZJWeakProxy % pod trunk register 13718004742@163.com BboyZJ --description=ZJWeakProxy组件 </span><br></pre></td></tr></table></figure><p>然后去邮箱进行验证，验证成功会出现下面页面：</p><ul><li>现在，就可以将 podspec 提交给 CocoaPods 了。这个文件将是别人搜索你的组件的索引。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ZJWeakProxy % pod trunk push ZJWeakProxy.podspec --allow-warnings</span><br></pre></td></tr></table></figure><ul><li>pod search 组件名</li></ul><p>上传完成之后，接可以通过 pod search ZJWeakProxy 搜索到自己的组件了，如果搜索不到，删除本地的搜索文件，命令 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ZJWeakProxy % rm ~/Library/Caches/CocoaPods/search_index.json</span><br></pre></td></tr></table></figure><p>重新 <code>search</code> 产生新的搜索文件，发布新版本则需要打新的 <code>tag</code>，重新编辑 <code>podspec</code> 文件，然后再次提交给 <code>CocoaPods</code>。</p><h1 id="集成到宿主工程"><a href="#集成到宿主工程" class="headerlink" title="集成到宿主工程"></a>集成到宿主工程</h1><p>经过上面的操作我们已经完成了组件的创建和发布，也支持了 Cocoapods 的集成。现在我们需要将该组件集成到宿主工程中去，使用方式和集成三方库是一样的。</p><ul><li>新建个带 <code>pod</code> 的项目 <code>Demo</code>，把我们做好的 <code>ZJWeakProxy</code> 加入 <code>podfile</code> 文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Uncomment the next line to define a global platform for your project</span><br><span class="line">platform :ios, &#x27;10.0&#x27;</span><br><span class="line"></span><br><span class="line">target &#x27;ZJWeakProxy-Demo&#x27; do</span><br><span class="line">  # Comment the next line if you don&#x27;t want to use dynamic frameworks</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  # ZJWeakProxy</span><br><span class="line">  pod &#x27;ZJWeakProxy&#x27;,:git =&gt;&quot;https://github.com/BboyZJ/ZJWeakProxy.git&quot;</span><br><span class="line">  </span><br><span class="line">  # Pods for ZJWeakProxy-Demo</span><br><span class="line"></span><br><span class="line">end </span><br></pre></td></tr></table></figure><ul><li>执行 pod install</li></ul><p><code>mac@bogon ZJWeakProxy-Demo % pod install</code></p><p>【问题1】安装报错：[!] Unable to find a specification for <code>ZJWeakProxy</code></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042344858.png"></p><p>解决办法：</p><p><code>mac@bogon ZJWeakProxy-Demo % pod repo update --verbose</code></p><p>【问题2】：HTTP&#x2F;2 stream 1 was not closed cleanly before end of the underlying stream</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042345578.png"></p><p>解决办法：更改默认通信协议</p><p><code>mac@bogon ZJWeakProxy-Demo % git config --global http.version HTTP/1.1</code></p><ul><li>引入头文件并打印结果</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042345740.png"></p><h1 id="版本更新与维护"><a href="#版本更新与维护" class="headerlink" title="版本更新与维护"></a>版本更新与维护</h1><ul><li><p>现在的 <code>ZJWeakProxy</code> 库已经在GitHub上托管了，以后维护这个项目就可以了（开始本地创建的ZJWeakProxy项目就可以删除了），管理GitHub仓库，有两种方案：</p><ul><li><p>可以使用命令行 git clone <a href="https://github.com/BboyZJ/ZJWeakProxy">https://github.com/BboyZJ/ZJWeakProxy</a></p></li><li><p>也可以使用 GitHub Desktop</p><ul><li>下载 <a href="https://desktop.github.com/">GitHub Desktop</a> 登录你的用户名和密码，<code>File -&gt; Responsitory</code></li></ul></li></ul></li><li><p>其实 <code>GitHub Desktop</code> 更加可视化一些，上面History就是刚才git命令行的记录</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>终于写完了，哇哦😮！</p>]]></content>
      
      
      <categories>
          
          <category> Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC组件化04：【方案一】本地组件化</title>
      <link href="/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9604%EF%BC%9A%E3%80%90%E6%96%B9%E6%A1%88%E4%B8%80%E3%80%91%E6%9C%AC%E5%9C%B0%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
      <url>/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9604%EF%BC%9A%E3%80%90%E6%96%B9%E6%A1%88%E4%B8%80%E3%80%91%E6%9C%AC%E5%9C%B0%E7%BB%84%E4%BB%B6%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><code>本地组件化</code>：主要是通过在 <code>工程中创建library</code>，利用 <code>cocoapods</code> 的 <code>workspec</code> 进行本地管理，不需要将项目上传git，而是直接在本项目中以 <code>framework</code> 的方法进行调用</li></ul><h1 id="创建主工程"><a href="#创建主工程" class="headerlink" title="创建主工程"></a>创建主工程</h1><ul><li>首先创建一个名为 <code>Modularization</code> 的工程</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162391343-e72a3235-b07f-41da-9fbf-cca1a55c4e8b.jpg"></p><ul><li>集成 cocoapods，进行本地管理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhangjian@zhangjiandeMBP ~ % cd /Users/zhangjian/Desktop/Modularization </span><br><span class="line">zhangjian@zhangjiandeMBP Modularization % pod init</span><br><span class="line">Ignoring ffi-1.13.1 because its extensions are not built. Try: gem pristine ffi --version 1.13.1</span><br><span class="line">zhangjian@zhangjiandeMBP Modularization % pod install</span><br></pre></td></tr></table></figure><h1 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h1><p>假设有以下几个模块</p><ul><li><p><code>主工程</code>：承载主要的表层业务代码</p></li><li><p><code>Core</code>：独立存在，应用加密、接口请求等敏感代码</p></li><li><p><code>Base</code>：基类封装，拓展，基本的数据处理</p></li><li><p><code>Service</code>：服务层，封装业务工具类，例如网络层服务、持久化服务等</p></li><li><p><code>Pods</code>：三方依赖</p></li></ul><p>其中，各个模块间的关系如下图</p><p><img src="https://user-images.githubusercontent.com/25925248/162391360-04089910-c38d-4859-b4f2-dfc4de229332.jpg"></p><p>下面，我们来进行模块的创建，以 <code>Core</code> 模块为例：</p><ul><li>选择  <code>File -&gt; new -&gt; project -&gt; iOS -&gt; Framework</code>，新建一个 <code>ZJCore</code> 模块</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162391370-c14294a9-e941-4a20-ad6d-edaa12a76afc.jpg"></p><p><img src="https://user-images.githubusercontent.com/25925248/162391384-d4ee6235-4b4c-49fb-b448-2416822359df.jpg"></p><ul><li>选择正确的 <code>Group</code> 和 <code>WorkSpace</code>（这里注意：创建的 <code>library</code> 最好放在 <code>主工程根目录下</code>，否则后续的 <code>podfile</code> 执行 <code>pod install</code> 会报错）</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162391398-93ed8a4d-7f60-48c5-af68-8db35d74d8c0.jpg"></p><p>创建成功后，看到的结果如下：</p><p><img src="https://user-images.githubusercontent.com/25925248/162392357-ddca5e46-b788-4d08-9af5-7e48c475bd1f.jpg"></p><p><img src="https://user-images.githubusercontent.com/25925248/162391438-632eac8a-b78a-4901-995f-f997caeea671.jpg"></p><ul><li>将创建的 <code>library</code> 的 <code>Build Settings -&gt; Mach-O Type</code> 修改为静态库 <code>Static Library</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162391454-6eb6908f-7e29-4e00-afb5-cad186bcc1c0.jpg"></p><h1 id="主工程调用Library"><a href="#主工程调用Library" class="headerlink" title="主工程调用Library"></a>主工程调用Library</h1><ul><li>在 <code>ZJCore</code> 中新建一个文件，并添加如下代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJCoreSetting : NSObject</span><br><span class="line">// 声明属性</span><br><span class="line">@property (nonatomic,copy)NSString * name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ZJCoreSetting</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>在 <code>Build Phases -&gt; Headers -&gt; Public</code> 中将新建的文件拖拽到 <code>Puclic</code> 中，这样主工程才能访问该文件</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162391477-33f10151-72cd-48ae-9b9c-0ef6e22a1e4f.jpg"></p><ul><li>在ZJCore文件中添加引用</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162392415-896bf8dd-d51d-4d63-b548-babfc3101fc8.jpg"></p><ul><li>在主工程中，选择 <code>target -&gt; Frameworks,Libraries,and Embedded Content -&gt; + 号 -&gt; 添加 ZJCore</code>，只需要build主工程，library能够自动联编</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162392476-8813bdd9-e9e9-4508-80e5-40b5bd8101be.jpg"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>首先 <code>#import &lt;ZJCore/ZJCoreSetting.h&gt;</code>，然后使用</p><p><img src="https://user-images.githubusercontent.com/25925248/162392563-05712fc4-c7b3-4fde-ae68-05291475888b.jpg"></p><p>这里需要注意的是，子library之间的互相调用，与主工程调用library类似，主需要添加依赖、暴露header即可</p>]]></content>
      
      
      <categories>
          
          <category> Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC组件化03：面向协议Protocol Class的使用</title>
      <link href="/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AEProtocol-Class%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AEProtocol-Class%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="面向协议-Protocol-Class"><a href="#面向协议-Protocol-Class" class="headerlink" title="面向协议 Protocol Class"></a>面向协议 Protocol Class</h1><ul><li><p>在 <code>URL Scheme路由</code> 和 <code>target-action</code> 方案中，都存在 硬编码、参数不明确问题：URL 、Target_ 、 Action_ 的硬编码，参数都是通过字典的形式传递，类型不明确。</p></li><li><p><code>面向接口</code> 的方式能够很好的解决这两个问题。</p></li></ul><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><ul><li><p>中间件先注册 <code>Protocol</code> 和 <code>Class</code> 对应关系，将 <code>protocol</code> 和 <code>对应的类</code> 进行 <code>字典</code> 匹配</p></li><li><p>中间件返回 <code>Protocol</code> 对应的 <code>Class</code>，然后动态创建实例</p></li></ul><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>面向协议编程</li><li>安全性高</li><li>模块解耦</li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>无法多端通用</li><li>需要进行协议的注册</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ul><li>创建 <code>ZJProtocol.h</code> 协议类文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 将各个模块的协议统一放在一个文件中 ，在各个模块中依赖这个文件，实现其协议</span><br><span class="line">@protocol OneMoudleProtocol &lt;NSObject&gt;</span><br><span class="line">@required // 返回模块one</span><br><span class="line">+ (UIViewController *)oneMoudleVC;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol OneDetailMoudleProtocol &lt;NSObject&gt;</span><br><span class="line">@required</span><br><span class="line">+ (UIViewController *)oneDetailMoudleVCWithParas:(NSDictionary *)paras;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>创建 <code>ZJMediator</code> 协议管理类</li></ul><p>ZJMediator.h 文件下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJMediator : NSObject</span><br><span class="line">// 单例</span><br><span class="line">+ (instancetype)shareManager;</span><br><span class="line">// 注册绑定</span><br><span class="line">- (void)registerProtocol:(Protocol *)protocol class:(Class)cls;</span><br><span class="line">// 获取类</span><br><span class="line">- (Class)classFromProtocol:(Protocol *)protocol;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>ZJMediator.m 文件下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJMediator.h&quot;</span><br><span class="line">@interface ZJMediator ()</span><br><span class="line">@property (nonatomic,strong)NSMutableDictionary * protocolCache;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJMediator</span><br><span class="line">+ (instancetype)shareManager&#123;</span><br><span class="line">    static ZJMediator * mediator;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        mediator = [[ZJMediator alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return mediator;</span><br><span class="line">&#125;</span><br><span class="line">// 注册绑定</span><br><span class="line">- (void)registerProtocol:(Protocol *)protocol class:(Class)cls&#123;</span><br><span class="line">    if (protocol &amp;&amp; cls) &#123;</span><br><span class="line">        [self.protocolCache setObject:cls forKey:NSStringFromProtocol(protocol)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 获取类</span><br><span class="line">- (Class)classFromProtocol:(Protocol *)protocol&#123;</span><br><span class="line">    return  [self.protocolCache objectForKey:NSStringFromProtocol(protocol)];</span><br><span class="line">&#125;</span><br><span class="line">// 懒加载</span><br><span class="line">- (NSMutableDictionary *)protocolCache&#123;</span><br><span class="line">    if (!_protocolCache) &#123;</span><br><span class="line">        _protocolCache = @&#123;&#125;.mutableCopy;</span><br><span class="line">    &#125;</span><br><span class="line">    return _protocolCache;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>创建 <code>OneDetailMoudleEntry</code> 模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;OneDetailMoudleEntry.h&quot;</span><br><span class="line">#import &quot;ZJOneDetailViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface OneDetailMoudleEntry ()&lt;OneDetailMoudleProtocol&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation OneDetailMoudleEntry</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    [[ZJMediator shareManager] registerProtocol:@protocol(OneDetailMoudleProtocol) class:[self class]];</span><br><span class="line">&#125;</span><br><span class="line">// 继承</span><br><span class="line">+ (UIViewController *)WithParas:(NSDictionary *)paras&#123;</span><br><span class="line">    ZJOneDetailViewController * detailVC = [[ZJOneDetailViewController alloc] init];</span><br><span class="line">    detailVC.name = paras[@&quot;name&quot;];</span><br><span class="line">    detailVC.age = params[@&quot;age&quot;];</span><br><span class="line">    return detailVC;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>在任何地方调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//下一页的点击事件</span><br><span class="line">- (void)next:(UIButton *)sender&#123;</span><br><span class="line">    </span><br><span class="line">    Class cls = [[ZJMediator shareManager] classFromProtocol:@protocol(OneDetailMoudleProtocol)];</span><br><span class="line">    UIViewController * detailVC = [cls oneDetailMoudleVCWithParas:@&#123;@&quot;name&quot;:@&quot;ZJ&quot;,@&quot;age&quot;:30&#125;];</span><br><span class="line">    [self.navigationController pushViewController:detailVC animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC组件化03：基于RuntTime的target-action的使用</title>
      <link href="/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E5%9F%BA%E4%BA%8ERuntTime%E7%9A%84target-action%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9603%EF%BC%9A%E5%9F%BA%E4%BA%8ERuntTime%E7%9A%84target-action%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>target action 是利用 <code>Runtime</code> 的 <code>performSelector:withObject:</code> 方法调用，无需注册</p><h1 id="优缺"><a href="#优缺" class="headerlink" title="优缺"></a>优缺</h1><ul><li>优点：<code>无需注册路由</code>，避免了load里注册影响启动速度</li><li>不用维护全局路由表，避免了查找对应路由</li><li>统一了路由入口</li><li>进行了一定的安全处理</li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>缺点：不能多端使用同一套路由H5，Android</li><li>增加了文件，同时在获取target，sel时存在一定的硬编码</li></ul><h1 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h1>]]></content>
      
      
      <categories>
          
          <category> Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC组件化02：基于URL Scheme的使用</title>
      <link href="/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9602%EF%BC%9A%E5%9F%BA%E4%BA%8EURL-Scheme%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9602%EF%BC%9A%E5%9F%BA%E4%BA%8EURL-Scheme%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="URL-Scheme-路由"><a href="#URL-Scheme-路由" class="headerlink" title="URL Scheme 路由"></a>URL Scheme 路由</h1><ul><li>使 <code>URL Scheme</code> 处理本地的跳转</li><li>通过中间层进行注册 <code>&amp;</code> 调用（load方法里面把被调用者注册到中间层）</li></ul><h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//协议://主机名[:端口]/路径/[?参数]#fragment</span><br><span class="line">@&quot;lstest://lsapp:11111/china/ls.com?a=1&amp;b=2&quot;</span><br></pre></td></tr></table></figure><ul><li>lstest：协议名</li><li>lsapp：主机名，为了区分 不同的app</li><li>端口号：可以将端口号作为 模块ID</li><li>china&#x2F;ls.com：路径，可以是跳转到模块的 指定页面</li><li>a&#x3D;1&amp;b&#x3D;2：参数，跳转的参数</li></ul><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303042254171.png"></p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><ul><li><p>优点：实现简单</p></li><li><p>缺点：存在硬编码问题，参数都是通过字典的形式传递，类型不明确</p></li></ul><h1 id="URL-Scheme-路由示例"><a href="#URL-Scheme-路由示例" class="headerlink" title="URL Scheme 路由示例"></a>URL Scheme 路由示例</h1><p>思路：B组件使用URL将Block注册给路由，路由以URL为key，将Block存储起来。<br>     A组件通过URL调用路由的方法，找到对应的Block，完成对A的调用</p><ul><li>创建路由</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJRouter.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ZJRouter ()</span><br><span class="line">@property (strong,nonatomic)NSMutableDictionary * blockDic;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJRouter</span><br><span class="line">// 参数 @&#123;@&quot;&quot;:...&#125;</span><br><span class="line">+ (instancetype)shareInstance&#123;</span><br><span class="line">    static ZJRouter * router = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        router = [[self alloc] init];</span><br><span class="line">        router.blockDic = @&#123;&#125;.mutableCopy;</span><br><span class="line">    &#125;);</span><br><span class="line">    return router;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注册</span><br><span class="line">- (void)registerUrl:(NSString *)url block:(ZJRouterBlock)block&#123;</span><br><span class="line">    if (!url || !block) return;</span><br><span class="line">    if (block) &#123;</span><br><span class="line">        self.blockDic[url] = [block copy];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 执行</span><br><span class="line">- (void)excuteBlockWithUrl:(NSString *)key params:(NSDictionary *)params&#123;</span><br><span class="line">    if (!key) return;</span><br><span class="line">    ZJRouterBlock block = self.blockDic[key];</span><br><span class="line">    if (!block) return;</span><br><span class="line">    block(params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>B 组件中注册</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    [[ZJRouter shareInstance] registerUrl:@&quot;A:aTestAction&quot; block:^(NSDictionary * _Nonnull dic) &#123;</span><br><span class="line">        NSLog(@&quot;dic:%@&quot;,dic);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A 组件中调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ZJRouter shareInstance] excuteBlockWithUrl:@&quot;A:aTestAction&quot; params:@&#123;@&quot;text&quot;:@&quot;文字&quot;&#125;];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC组件化01：组件化介绍</title>
      <link href="/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9601%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%E4%BB%8B%E7%BB%8D/"/>
      <url>/BboyZJ.github.io/2023/03/04/OC%E7%BB%84%E4%BB%B6%E5%8C%96/OC%E7%BB%84%E4%BB%B6%E5%8C%9601%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="什么组件化"><a href="#什么组件化" class="headerlink" title="什么组件化"></a>什么组件化</h1><ul><li><p>组件化其实就是 <code>将模块单独抽离、分层</code>，并指定模块间的 <code>通讯</code> 方式，从而实现 <code>解耦</code> 的一种方式，主要运用与团队开发</p></li><li><p>组件化开发就是将一个臃肿的、单一的项目，根据 <code>功能/业务/技术</code> 等进行拆分，形成一个个独立的功能组件，然后借助 <code>Cocoapods</code> 管理工具将其任意组合，集成一个完整的项目。</p></li><li><p>你可以将 <code>AFNetworking、SDWebImage、Bugly、MLeaksFinder</code> 等三方库理解为工程的一部分，属于 <code>基础组件模块</code>，我们要做的就是将项目划分多个独立功能模块，再集成一个完整的项目。</p></li></ul><h1 id="为什么要组件化？"><a href="#为什么要组件化？" class="headerlink" title="为什么要组件化？"></a>为什么要组件化？</h1><p>主要有以下四个原因</p><ul><li><p>模块间解耦</p></li><li><p>模块重用</p></li><li><p>提高团队协作开发效率</p></li><li><p>单元测试</p></li></ul><p>当项目因为各种需求，模块越来越多时，如果此时的各个模块之间是互相调用的，即 <code>你中有我，我中有你</code> 这种情况时，会造成 <code>高耦合</code> 的情况，一旦我们需要对某一模块代码进行 <code>修改</code> 时，就会 <code>牵一发而动全身</code>，导致项目难以维护</p><p><strong>其问题主要体现在以下几个方面：</strong></p><ul><li><p>修改某个功能时，同时需要修改其他模块的代码，因为在其他模块中有该模块的引用，可以理解为 <code>高耦合导致代码修改困难</code></p></li><li><p>模块对外接口不明确，甚至暴露了本不该暴露的私有接口，修改时费时费力。可以理解为 <code>接口不固定导致的接口混乱</code></p></li><li><p>高耦合代码产生的后果就是会影响团队其他成员的开发，产生 <code>代码冲突</code></p></li><li><p>当模块需要重用到其他项目时，<code>难以单独抽离</code></p></li><li><p>模块间耦合的忌口导致接口和依赖关系混乱，<code>无法进行单元测试</code></p></li></ul><p>所以为了解决以上问题，我们需要采用更规范的方式来 <code>降低模块</code> 间的 <code>耦合度</code>，这就是 <code>组件化</code>，也可以理解为 <code>模块化</code></p><p>但是，这里还需要说明一点，因为组件化也是需要一定成本的，需要花费时间设计接口、分离代码等，所以并不是所有的项目都需要组件化。如果你的项目有以下这些特征就 <code>不需要组件化</code>：</p><ul><li><p>项目较小，模块间交互简单，耦合少</p></li><li><p>项目没有被多个外部模块引用，只是一个单独的小模块</p></li><li><p>模块不需要重用，代码也很少被修改</p></li><li><p>团队规模很小</p></li><li><p>不需要编写单元测试</p></li></ul><p>如果你的有以下特性，说明你就必须要 <code>考虑进行组件化</code> 了：</p><ul><li><p>模块逻辑复杂，多个模块之间频繁互相引用</p></li><li><p>项目规模逐渐变大，修改代码变的越来越困难（这里可以理解为：修改一处代码，需要同时修改其他多个地方）</p></li><li><p>团队人数变多，提交代码经常和其他成员冲突</p></li><li><p>项目编译耗时较大</p></li><li><p>模块的单元测试经常由于其他模块的修改而失败</p></li></ul><h1 id="组件化方案"><a href="#组件化方案" class="headerlink" title="组件化方案"></a>组件化方案</h1><p>组件化方案的8条指标：</p><p>一个项目经过组件化后如何来评判，主要有以下几个 <code>标准</code>：</p><ul><li><p>模块之间没有耦合，模块内部的修改不会影响其他模块</p></li><li><p>模块可以单独编译</p></li><li><p>模块间数据传递明确</p></li><li><p>模块对外接口清晰且易维护</p></li><li><p>当模块接口改变时，此模块的外部代码能够被高效重构</p></li><li><p>尽量用最少的修改和代码，让现有项目实现模块化</p></li><li><p>支持OC和Swift，以及混编</p></li></ul><p>前4条主要用于 <code>衡量一个模块是否真正解耦</code>，后4条主要用于衡量在项目中 <code>实践中的易用程序</code></p><p><strong>组件化原则</strong></p><p>一个项目主要分为3层：<code>业务层、通用层</code> 以及 <code>基础层</code>，在进行组件化时，有以下几点说明</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/20230304232513.png"></p><ul><li><p>只能上层对下层依赖，不能下层对上层依赖，因为下层是对上层的抽象</p></li><li><p>项目公共代码资源下沉</p></li><li><p>横向的依赖尽量减少，最好下层至通用模块，或者基础模块</p></li></ul><h1 id="组件化和非组件化区别"><a href="#组件化和非组件化区别" class="headerlink" title="组件化和非组件化区别"></a>组件化和非组件化区别</h1><p>组件化能够帮助我们将大部分项目拆解成数个小组件，开发者只需要关注组件所依赖的其他组件，而无需关心完整项目的其他部分，每个组件可以自己采取所习惯的架构模式：MVC、MVVM等，就行开发一款个人独立的App那样自由</p><p>非组件化：</p><ul><li>代码高耦合度、高依赖</li><li>项目复杂、臃肿、编译时间过长（影响调试）</li><li>难以融合、集成其他产品</li><li>…</li></ul><p>组件化：</p><ul><li>代码复用性提高，可方便集成到其他项目</li><li>项目可配置，方便集成和功能回退</li><li>方便组件并行开发</li><li>可方便单元测试</li><li>…</li></ul><h1 id="组件化分层"><a href="#组件化分层" class="headerlink" title="组件化分层"></a>组件化分层</h1><p>项目组件化，最难的就是 <code>粒度</code> 问题，需要开发者根据自己的经验把控。这里给出个人认为的层次划分：</p><p>【基础组件】：宏定义&#x2F;常量&#x2F;自定义工具类，如常用的自定义分类<br>【功能组件】：项目中常用的功能，如地图&#x2F;消息推送&#x2F;分享&#x2F;登录等<br>【业务组件】：项目中的模块&#x2F;业务，如文章详情&#x2F;个人中心等<br>【中间组件】：负责项目中的路由&#x2F;消息通知&#x2F;传参&#x2F;回调等<br>【宿主工程】：项目容器，用来集成组件，调整各个组件之间的消息传递容器</p><h1 id="中间层几种方案"><a href="#中间层几种方案" class="headerlink" title="中间层几种方案"></a>中间层几种方案</h1><p>在组件化中，中间层是各个组件的通信桥梁，中间层在组件化过程中扮演着非常重要的角色。</p><p>中间层的三种方式：</p><ul><li><p>基于 <code>URL Scheme</code> 的 <code>路由</code></p></li><li><p>基于 <code>Runtime</code> 的 <code>target-action</code></p></li><li><p>面向接口 的 <code>Protocol - Class</code></p></li></ul><h1 id="基于-URL-Scheme-的三方库"><a href="#基于-URL-Scheme-的三方库" class="headerlink" title="基于 URL Scheme 的三方库"></a>基于 URL Scheme 的三方库</h1><p><code>iOS</code> 中支持的 <code>URL Scheme</code> 让我们能够在 <code>应用之间、应用内部传递消息</code>。</p><ul><li><p><a href="https://github.com/joeldev/JLRoutes">JLRoutes</a></p></li><li><p><a href="https://github.com/clayallsopp/routable-ios">routable-ios</a></p></li><li><p><a href="https://github.com/lightory/HHRouter">HHRouter</a></p></li></ul><p>具体怎么使用，可以自行去探索</p><h1 id="基于-Runtime-的-target-action"><a href="#基于-Runtime-的-target-action" class="headerlink" title="基于 Runtime 的 target-action"></a>基于 <code>Runtime</code> 的 <code>target-action</code></h1><p>相比 <code>url scheme</code> 的提前注册、实现服务，<code>CTMediator</code> 借助 <code>OC</code> 运行时的特性，现实组件之间服务的自动发现，无需提前注册即可实现组件间的调用，因此，这种方案的可维护性、可读性、扩展性相对较高。</p><ul><li><a href="https://github.com/casatwy/CTMediator">CTMediator</a></li></ul><h1 id="面向接口-Protocol-Class"><a href="#面向接口-Protocol-Class" class="headerlink" title="面向接口 Protocol - Class"></a>面向接口 <code>Protocol - Class</code></h1><ul><li><code>Protocol - Class</code></li></ul><p>面向接口的方案通常由两部分组成，一个是用来管理接口协议的类（ProtocolManager），一个是具体的接口协议（ComponentProtocol）</p><h1 id="组件化的核心工具"><a href="#组件化的核心工具" class="headerlink" title="组件化的核心工具"></a>组件化的核心工具</h1><ul><li><p>组件化工程，需要一个宿主工程，负责集成所有的组件。每个组件都是一个单独的工程，通过 <code>Git</code> 私有仓库来管理。</p></li><li><p>所有组件都上传到 <code>Git</code> 仓库并支持 <code>cocoapods</code> 集成。主工程通过配置 <code>Podfile</code> 文件，然后一键 <code>pod update</code> 即可。使用 <code>Cocoapods</code> 来管理组件主要因为其本身功能强大，方便的集成整个项目，解放对依赖库的管理。使用组件化的集成方式，可以很好的避免传统项目中的代码冲突问题。</p></li><li><p>组件化的核心工具就是 <code>CocoaPods</code> ，我们要做的就是将组件项目上传到 <code>Gitee码云</code> 或者 <code>Gitlab极狐</code>，编写项目的 <code>podSpec</code> 文件让组件支持 <code>CocoaPods</code> 集成即可。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习37：对象</title>
      <link href="/BboyZJ.github.io/2023/03/04/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A037%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/BboyZJ.github.io/2023/03/04/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A037%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="swift面向对象概述"><a href="#swift面向对象概述" class="headerlink" title="swift面向对象概述"></a>swift面向对象概述</h1><h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><ul><li><p>继承</p></li><li><p>封装</p></li><li><p>多态</p></li></ul><h2 id="基本单元"><a href="#基本单元" class="headerlink" title="基本单元"></a>基本单元</h2><ul><li><p>枚举</p></li><li><p>结构体</p></li><li><p>类 </p></li><li><p>协议</p></li><li><p>扩展</p></li></ul><h2 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h2><ul><li><p>从整体功能上看 <code>swift</code> 的枚举、结构体、类三者具有完全平等的地位</p></li><li><p>swift 的类、结构体、枚举中都可以定义（属性、方法、下标、构造体、嵌套类型）</p></li><li><p>在swift中，<code>枚举和结构体</code> 是 <code>值类型</code>，<code>类</code> 是 <code>引用类型</code></p></li></ul><h2 id="类和结构体的相似点"><a href="#类和结构体的相似点" class="headerlink" title="类和结构体的相似点"></a>类和结构体的相似点</h2><ul><li><p><code>定义属性用来存储值</code></p></li><li><p><code>定义方法用来提供功能</code></p></li><li><p><code>定义下标脚本用来允许使用下标语法访问值</code></p></li><li><p>定义初始化器用来初始化状态</p></li><li><p>可以被扩展来默认所没有的功能</p></li><li><p>遵循协议来针对特定类型提供标准功能</p></li></ul><h2 id="类和结构体不同点"><a href="#类和结构体不同点" class="headerlink" title="类和结构体不同点"></a>类和结构体不同点</h2><ul><li><p>继承允许一个类继承另一个类的特性</p></li><li><p>类型转换允许你再运行检查和解释一个类实例的类型</p></li><li><p>反初始化器允许一个类实例释放任何其被分配的资源</p></li><li><p>引用计数器允许不止一个类对实例的引用</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习36：函数式编程</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A036%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A036%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="范式转换-函数式"><a href="#范式转换-函数式" class="headerlink" title="范式转换-函数式"></a>范式转换-函数式</h1><p>读入一个文本，确定所有单词的使用频率并从高到低排序，打印出所有单词及其频率的排序列表</p><ul><li><code>命令式编程</code> 风格尝尝迫使我们出于性能考虑，把不同的任务交织起来，以便能够用一次循环来完成多个任务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">let words = &quot;&quot;&quot;</span><br><span class="line">This rectangle defines the size and position of the view in its superview’s coordinate system.</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">let NON_WORDS = [&quot;e&quot;,&quot;of&quot;,&quot;end&quot;,&quot;on&quot;]</span><br><span class="line"></span><br><span class="line">func wordFrep(words: String) -&gt; [String:Int] &#123;</span><br><span class="line">    var wordDict: [String:Int] = [:]</span><br><span class="line">    // 分割成一个数组</span><br><span class="line">    let wordList = words.split(separator: &quot; &quot;)</span><br><span class="line">    // 遍历数组</span><br><span class="line">    for word in wordList &#123;</span><br><span class="line">        // 数组每个元素转小写</span><br><span class="line">        let lowercaseWord = word.lowercased()</span><br><span class="line">        // 不包含元素</span><br><span class="line">        if !NON_WORDS.contains(lowercaseWord) &#123;</span><br><span class="line">            // 有count</span><br><span class="line">            if let count = wordDict[lowercaseWord] &#123;</span><br><span class="line">                wordDict[lowercaseWord] = count + 1</span><br><span class="line">            &#125;else &#123; // 无count</span><br><span class="line">                wordDict[lowercaseWord] = 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return wordDict</span><br><span class="line">&#125;</span><br><span class="line">print(wordFrep(words:words))</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">[&quot;and&quot;: 1, &quot;superview’s&quot;: 1, &quot;system.&quot;: 1, &quot;view&quot;: 1, &quot;defines&quot;: 1, &quot;its&quot;: 1, &quot;coordinate&quot;: 1, &quot;in&quot;: 1, &quot;the&quot;: 2, &quot;rectangle&quot;: 1, &quot;this&quot;: 1, &quot;size&quot;: 1, &quot;position&quot;: 1]</span><br></pre></td></tr></table></figure><ul><li>而 <code>函数式编程</code> 用 <code>map()、filter()</code> 这些高级函数把我们解法出来，让我们站在更高的抽象层次上去考虑问题，把问题看的更清楚</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 函数式写法</span><br><span class="line">func wordFrep2(words: String) -&gt; [String:Int] &#123;</span><br><span class="line">    var wordDict: [String:Int] = [:]</span><br><span class="line">    // 分割成一个数组</span><br><span class="line">    let wordList = words.split(separator: &quot; &quot;)</span><br><span class="line">    // map：尾随闭包的方式</span><br><span class="line">    wordList.map &#123; $0.lowercased() &#125;</span><br><span class="line">        .filter &#123; !NON_WORDS.contains( $0 ) &#125;</span><br><span class="line">        .forEach &#123; wordDict[$0] = (wordDict[$0] ?? 0) + 1 &#125;</span><br><span class="line"></span><br><span class="line">    return wordDict</span><br><span class="line">&#125;</span><br><span class="line">print(wordFrep2(words:words))</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line">[&quot;view&quot;: 1, &quot;its&quot;: 1, &quot;and&quot;: 1, &quot;defines&quot;: 1, &quot;in&quot;: 1, &quot;the&quot;: 2, &quot;size&quot;: 1, &quot;this&quot;: 1, &quot;position&quot;: 1, &quot;coordinate&quot;: 1, &quot;superview’s&quot;: 1, &quot;system.&quot;: 1, &quot;rectangle&quot;: 1]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="函数式编程-简洁"><a href="#函数式编程-简洁" class="headerlink" title="函数式编程-简洁"></a>函数式编程-简洁</h1><ul><li><p>函数式编程简洁，<code>面向对象编程</code> 通过 <code>封装不确定因素</code> 来使代码能够被人理解，<code>函数式编程</code> 通过 <code>尽量减少少不确定因素</code> 来使代码能够被人理解</p></li><li><p>在面向对象的命令式编程语言里，重用的单元是类和类之间沟通用的消息</p></li><li><p>函数式编程语言实现重用的思路很不一样。函数式语言提倡在有限的几种关键数据结果（如：list、set、map）上运用针对这些数据结构高度优化过的操作，以此构建成基本的运转机构。开发者再根据具体用途，插入自己的数据结构和高阶函数去调整机构的运转方式</p></li><li><p>比起以为创建新的类结构体系，把封装的元素降低到函数级别，更有利达到细粒度的、基础层面的重用</p></li><li><p>函数式程序员喜欢用少数几个核心数据结构，围绕它们去建立一套充分优化的运转机构。<br>面向对象程序员喜欢不断的创建新的数据结构和附属的操作，因为压倒一切的面向对象编程范式就是建立新的类和类间的消息。<br>把所有的数据结构封装成类，一方面压制了方法层面的重用，另一方面鼓励了大粒度的框架式重用。<br>函数式编程的程序结构方便我们在比较细小的层面上重用代码</p></li></ul><h1 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h1><ul><li>假设我们有一个名字列表，其中一些条目由单个字符组成。现在的任务是，将除去单字符条目之外的列表内容，放在一个逗号分割的字符串里返回，且每个名字的首字母都要大写</li></ul><h1 id="命令式解法"><a href="#命令式解法" class="headerlink" title="命令式解法"></a>命令式解法</h1><ul><li>命令式编程是按照 <code>程序是一系列改变状态的命名</code> 来建模的一种编程风格。传统的 for 循环是命令式风格的句号例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let names = [&quot;neal&quot;,&quot;s&quot;,&quot;stu&quot;,&quot;h&quot;,&quot;rich&quot;]</span><br><span class="line">func cleanNames(names: Array&lt;String&gt;) -&gt; String &#123;</span><br><span class="line">    var cleanedNames = &quot;&quot;</span><br><span class="line">    for name in names &#123;</span><br><span class="line">        if name.count &gt; 1 &#123;</span><br><span class="line">            cleanedNames += name.capitalized + &quot;,&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 去掉最后一个,</span><br><span class="line">    cleanedNames.remove(at: cleanedNames.index(before: cleanedNames.endIndex))</span><br><span class="line">    return cleanedNames</span><br><span class="line">&#125;</span><br><span class="line">print(cleanNames(names: names))</span><br><span class="line"></span><br><span class="line">==========</span><br><span class="line">Neal,Stu,Rich</span><br></pre></td></tr></table></figure><h1 id="函数式解法"><a href="#函数式解法" class="headerlink" title="函数式解法"></a>函数式解法</h1><ul><li>函数式编程将程序描述为 <code>表达式和变换</code>，以数学方程的形式建立模型，并且尽量避免可变的状态。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 函数式解法</span><br><span class="line">let names = [&quot;neal&quot;,&quot;s&quot;,&quot;stu&quot;,&quot;h&quot;,&quot;rich&quot;]</span><br><span class="line">// 过滤</span><br><span class="line">let cleanedNames = names.filter &#123; $0.count &gt; 1 &#125;</span><br><span class="line">print(cleanedNames)</span><br><span class="line">// 首字母大写</span><br><span class="line">let cleanedNames2 = cleanedNames.map &#123; $0.capitalized &#125;</span><br><span class="line">print(cleanedNames2)</span><br><span class="line">// 拼接</span><br><span class="line">let cleanedNames3 = cleanedNames2.joined(separator: &quot;,&quot;)</span><br><span class="line">print(cleanedNames3)</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">[&quot;neal&quot;, &quot;stu&quot;, &quot;rich&quot;]</span><br><span class="line">[&quot;Neal&quot;, &quot;Stu&quot;, &quot;Rich&quot;]</span><br><span class="line">Neal,Stu,Rich</span><br></pre></td></tr></table></figure><p>上面的方式还可以简写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 简写</span><br><span class="line">let cleanedName = names.filter &#123; $0.count &gt; 1 &#125;</span><br><span class="line">    .map &#123; $0.capitalized &#125;</span><br><span class="line">    .joined(separator: &quot;,&quot;)</span><br><span class="line">print(cleanedName)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">Neal,Stu,Rich</span><br></pre></td></tr></table></figure><h1 id="具有普遍意义的基本构造单元"><a href="#具有普遍意义的基本构造单元" class="headerlink" title="具有普遍意义的基本构造单元"></a>具有普遍意义的基本构造单元</h1><ul><li><p>筛选：<code>filter</code></p></li><li><p>映射：<code>map</code> </p></li><li><p>折叠&#x2F;化约：<code>foldLeft/reduce</code> 等</p></li></ul><h1 id="swift-的劣势-并行"><a href="#swift-的劣势-并行" class="headerlink" title="swift 的劣势-并行"></a>swift 的劣势-并行</h1><ul><li>不是线程安全的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 函数式</span><br><span class="line">let names = [&quot;neal&quot;,&quot;s&quot;,&quot;stu&quot;,&quot;h&quot;,&quot;rich&quot;,&quot;ff&quot;,&quot;sag&quot;]</span><br><span class="line">let cleanedName = names.filter &#123; $0.count &gt; 1 &#125;</span><br><span class="line">    .map &#123; $0.capitalized &#125;</span><br><span class="line">    .joined(separator: &quot;,&quot;)</span><br><span class="line">print(cleanedName)</span><br><span class="line"></span><br><span class="line">// 数组的扩展</span><br><span class="line">extension Array where Element : Any &#123;</span><br><span class="line">    // 函数</span><br><span class="line">    public func currentMap&lt;T&gt;(_ transform: (Element) -&gt; T)  -&gt; [T] &#123;</span><br><span class="line">        let n = self.count</span><br><span class="line">        if n == 0 &#123; return [] &#125;</span><br><span class="line">        var result = Array&lt;T&gt;() // 初始化一个数组</span><br><span class="line">        result.reserveCapacity(n)</span><br><span class="line">        DispatchQueue.concurrentPerform(iterations: n) &#123; i in</span><br><span class="line">            result.append(transform(self[i]))</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 并行写法</span><br><span class="line">let cleanedName2 = names.filter &#123; $0.count &gt; 1 &#125;</span><br><span class="line">    .currentMap &#123; $0.capitalized &#125;</span><br><span class="line">    .joined(separator: &quot;,&quot;)</span><br><span class="line">print(cleanedName2)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">Neal,Stu,Rich,Ff,Sag</span><br><span class="line">Stu,Neal,Rich,Ff,Sag</span><br></pre></td></tr></table></figure><p>有结果可知：打印的顺序不同，或者会少，说明线程不安全</p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习34：闭包</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A034%EF%BC%9A%E9%97%AD%E5%8C%85/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A034%EF%BC%9A%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h1><ul><li><p>闭包是 <code>可以在你的代码中被传递和引用的功能性独立代码块</code></p></li><li><p>闭包能够 <code>补获和存储上下文的常量和变量</code>。这就是所谓的闭合并包裹哪些常量和变量，因此称为 <code>闭包</code>，Swift能够为你处理所有关于补获的内存管理操作</p></li><li><p><code>全局和内嵌函数</code>，实际上是 <code>特殊的闭包</code>。闭包符合以下三种形式的一种</p><ul><li><p>全局函数：是一个 <code>有名字但不会补获任何值</code> 的 <code>闭包</code></p></li><li><p>内嵌函数：是一个 <code>有名字且能从其上下层函数补获值</code> 的 <code>闭包</code></p></li><li><p>闭包表达式：是一个轻量级语法所写的 <code>可以补获其上下文中常量和变量值的没有名字的闭包</code></p></li></ul></li></ul><h1 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h1><ul><li><p>闭包可以作为函数的 <code>参数</code> 也可以作为函数的 <code>返回值</code></p></li><li><p>闭包可以像 <code>oc</code> 中用于 <code>回调和反向传值</code></p></li></ul><h1 id="设置属性默认值"><a href="#设置属性默认值" class="headerlink" title="设置属性默认值"></a>设置属性默认值</h1><ul><li><code>闭包</code> 可以为 <code>存储属性</code> 设置默认值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 通过闭包设置默认值</span><br><span class="line">class Person &#123;</span><br><span class="line">    var name: String &#123;</span><br><span class="line">        return &quot;ZJ&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = Person()</span><br><span class="line">print(p.name)</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">ZJ</span><br></pre></td></tr></table></figure><h1 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h1><ul><li>全局函数： 是一种特殊的闭包，定义一个全局函数，只是当前的全局函数并不捕获值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 有名字但不会补获值的闭包</span><br><span class="line">func test()&#123;</span><br><span class="line">    print(&quot;test&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内嵌函数："><a href="#内嵌函数：" class="headerlink" title="内嵌函数："></a>内嵌函数：</h1><ul><li>全局函数： 是一种特殊的闭包，可以捕获值的闭包。函数中的 <code>incrementer</code> 是一个 <code>内嵌函数</code>，可以从 <code>makeIncrementer</code> 中捕获变量 <code>runningTotal</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func makeIncrementer() -&gt; () -&gt; Int&#123;</span><br><span class="line">    var runningTotal = 10</span><br><span class="line">    // 内嵌函数，有名字会从上下层函数补获值的闭包</span><br><span class="line">    func incrementer() -&gt; Int&#123;</span><br><span class="line">        runningTotal += 1</span><br><span class="line">        return runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    return incrementer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let incre = makeIncrementer()</span><br><span class="line">print(incre()</span><br></pre></td></tr></table></figure><h1 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h1><ul><li>闭包表达式 &#x2F; 匿名函数：下面是一个 <code>闭包表达式</code>，即一个 <code>匿名函数</code>，而且可以 <code>从上下文中捕获变量和常量</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 闭包表达式：没有名字能从上下文补获值的闭包</span><br><span class="line">&#123; (参数列表) -&gt; 返回值类型 in</span><br><span class="line">    // 主体内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数可以有多个，用 , 号隔开</li><li>参数的 () 可以省略</li><li>返回值类型也可以省略</li><li>当没有参数时 in 可以省略</li><li>in 可以看做是一个分隔符，将主体内容和前面的参数、返回值分割开</li></ul><blockquote><p>闭包表达式特点：是一个 <code>匿名函数</code>，所有代码都在花括号 <code>&#123;&#125;</code> 内，<code>参数和返回值类型</code> 在 <code>in关键字</code> 之前，<code>in关键字</code> 之后是 <code>主体内容(类似方法体)</code>。</p></blockquote><p>1、有参数、有返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个闭包 赋值 给常量 test</span><br><span class="line">let test: (String,String) -&gt; String = &#123; (str1,str2) -&gt; String in</span><br><span class="line">    return str1 + str2</span><br><span class="line">&#125;</span><br><span class="line">print(test(&quot;Z&quot;,&quot;J&quot;))</span><br><span class="line">// 打印结果 ZJ</span><br></pre></td></tr></table></figure><p>: 的右边是闭包的类型，&#x3D; 右边就是一个闭包表达式，也可以理解为一个闭包<br>&#x3D; 右边是严格按照了闭包表达式来写的，有参数，有括号，有返回值。<br>下面看一下闭包表达式的简写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 简写</span><br><span class="line">let test = &#123; str1,str2 -&gt; String in</span><br><span class="line">    return str1 + str2</span><br><span class="line">&#125;</span><br><span class="line">print(test(&quot;Z&quot;,&quot;J&quot;))</span><br></pre></td></tr></table></figure><p>实际上和上面是等价的，闭包表达式省去了参数的括号。<br>：右边的闭包类型省去了是因为swift编译器能自动根据 &#x3D; 右边去判断类型</p><p>2、无参无返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 无参无返回值</span><br><span class="line">let test: () -&gt; Void = &#123; () -&gt; Void in</span><br><span class="line">    print(&quot;ZJ&quot;)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line">// 打印结果 ZJ</span><br></pre></td></tr></table></figure><p>因为无返回值，我们可以直接调用查看打印结果<br>下面看一下闭包表达式简写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 简写</span><br><span class="line">let test = &#123;</span><br><span class="line">    print(&quot;ZJ&quot;)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>因为没有参数也没有返回值都可以省略</p><h1 id="闭包是引用类型"><a href="#闭包是引用类型" class="headerlink" title="闭包是引用类型"></a>闭包是引用类型</h1><ul><li><p>在swift中，<code>函数和闭包都是引用类型</code></p></li><li><p>无论是什么时候赋值给 <code>函数或闭包</code> 一个 <code>常量或变量</code>，实际上都是将常量和变量设置为对函数和闭包的 <code>引用</code></p></li><li><p>如果类实例的 <code>属性</code> 是一个 <code>闭包</code>，并且闭包通过引用该实例或者它的成员来捕获实例，你将在闭包和实例间会产生 <code>循环引用</code></p></li></ul><h1 id="闭包作为函数的参数"><a href="#闭包作为函数的参数" class="headerlink" title="闭包作为函数的参数"></a>闭包作为函数的参数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func exec(fn: (Int,Int) -&gt; Int, v1: Int, v2: Int) &#123;</span><br><span class="line">    /*</span><br><span class="line">     fn: (Int,Int) -&gt; Int = &#123;a,b -&gt; Int in return a + b&#125;</span><br><span class="line">     print(fn(1,2))</span><br><span class="line">     */</span><br><span class="line">    print(fn(v1,v2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有 3 个参数：第一个参数是个闭包<br>下面是exec函数的调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func exec(fn: (Int,Int) -&gt; Int, v1: Int, v2: Int) &#123;</span><br><span class="line">    /*</span><br><span class="line">     fn: (Int,Int) -&gt; Int = &#123;a,b -&gt; Int in return a + b&#125;</span><br><span class="line">     print(fn(1,2))</span><br><span class="line">     */</span><br><span class="line">    print(fn(v1,v2)) // 打印结果 2</span><br><span class="line">&#125;</span><br><span class="line">exec(fn: &#123; a, b in</span><br><span class="line">    return a + b</span><br><span class="line">&#125;, v1: 1, v2: 2)</span><br></pre></td></tr></table></figure><p>exec函数调用时，{} 里就是一个闭包表达式，可以看做是函数第一个参数的实现<br>这样的函数调用形式看起来很不友好，如果闭包表达式有很多行的话，会更加不友好，不利于代码的阅读。swift提供了一个 <code>尾随闭包</code> 的概念</p><h1 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h1><ul><li>当函数的最后一个参数是函数时，在函数调用时可以把闭包表达式写在 <code>()</code> 外面</li><li>尾随闭包是一个书写在函数 <code>()</code> 之后的闭包表达式</li><li>如果将一个很长的闭包表达式作为函数的最后一个实参，使用闭包可以增强函数的可读性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func exec(v1: Int, v2: Int, fn: (Int, Int) -&gt; Int) &#123;</span><br><span class="line">    print(fn(v1,v2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次把exec函数的第一个参数fn放到了最后，下面可以看下调用方式和上次的有什么不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec(v1: 1, v2: 2) &#123; a, b in</span><br><span class="line">    return 1 + 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根上一次的函数对比，这次是把闭包写在了函数 <code>()</code> 之后，增强了代码的可读性，这就是 <code>尾随闭包</code></p><ul><li>可以使用 <code>高阶函数</code> 简化参数名，如 $0,$1(从0开始，表示第i个参数…)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec(v1: 1, v2: 2) &#123;</span><br><span class="line">    return $0 + $1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有很多简写方式就不一一举例了，太简写也不利于代码阅读</p><ul><li>如果闭包表达式是函数的唯一实参，而且使用了尾随闭包的语法，可以将函数名后边的 () 省略</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 只有一个闭包为实参</span><br><span class="line">func exec(fn: (Int,Int) -&gt; Int) &#123;</span><br><span class="line">    print(fn(1,2))</span><br><span class="line">&#125;</span><br><span class="line">exec &#123; a, b in</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>array.sorted</code> 就是一个尾随闭包，且这个函数就 <code>只有一个参数</code>，如下所示：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// array.sorted就是一个尾随闭包</span><br><span class="line">var arr = [1,2,3]</span><br><span class="line">// 1.完整写法</span><br><span class="line">arr.sorted &#123; (item1: Int,item2: Int) -&gt; Bool in</span><br><span class="line">    return item1 &gt; item2</span><br><span class="line">&#125;</span><br><span class="line">// 2.省略参数类型：通过arr中的参数推断类型</span><br><span class="line">arr.sort &#123; (item1,item2) -&gt; Bool in</span><br><span class="line">    return item1 &gt; item2</span><br><span class="line">&#125;</span><br><span class="line">// 3.省略参数类型 + 返回值类型：通过return推断返回值类型</span><br><span class="line">arr.sorted &#123; (item1,item2) in</span><br><span class="line">    return item1 &gt; item2</span><br><span class="line">&#125;</span><br><span class="line">// 4.省略参数类型 + 返回值类型 + return关键字：单表达式可以隐士表达，即省略return关键字</span><br><span class="line">arr.sorted &#123; (item1, item2) in</span><br><span class="line">    item1 &lt; item2</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">// 5.参数名称简写</span><br><span class="line">arr.sorted &#123; return $0 &lt; $1 &#125;</span><br><span class="line">// 6.参数名称简写 + 省略return关键字</span><br><span class="line">arr.sorted &#123; $0 &lt; $1 &#125;</span><br><span class="line">// 7.最简：直接传比较符号</span><br><span class="line">arr.sorted (by: &lt;)</span><br></pre></td></tr></table></figure><blockquote><p>闭包的优点：<br>1、利用上下文推断参数和返回类型；<br>2、单表达式可以隐式返回，省略return关键字；<br>3、参数名称可以直接使用简写(如$0,$1,元组的$0.0)；<br>4、尾随闭包可以更简洁的表达。</p></blockquote><h1 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h1><ul><li><p>如果一个闭包作为一个函数的参数，并且在函数执行完之后才被执行，那么这种情况下的闭包就是 <code>逃逸闭包</code></p></li><li><p>在参数名 <code>:</code> 号后面加 <code>@escaping</code> 修饰符说明 <code>逃逸闭包</code></p></li></ul><p>逃逸闭包的使用场景，①异步线程网络请求，延迟方法，②作为属性存储，在后面进行调用。</p><p>1、在 <code>延迟方法</code> 中调用逃逸闭包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 闭包作为属性</span><br><span class="line">class Animal &#123;</span><br><span class="line">    // 函数参数使用@escaping修饰，表示允许函数返回之后调用</span><br><span class="line">    func getData(amount: Int,handler: @escaping (String) -&gt; Void) &#123;</span><br><span class="line">        // 延迟5s</span><br><span class="line">        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 5) &#123;</span><br><span class="line">            // 假设是请求得到的数据</span><br><span class="line">            var str: String = &quot;my is data&quot;</span><br><span class="line">            // 5s后调用</span><br><span class="line">            handler(&quot;\(str) : \(amount)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        print(&quot;函数执行完了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 返回数据</span><br><span class="line">    func backData(success: @escaping (String) -&gt; Void) &#123;</span><br><span class="line">        // 请求数据</span><br><span class="line">        getData(amount: 10) &#123; data in</span><br><span class="line">            // 拿到数据</span><br><span class="line">            success(&quot;success：\(data)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;Animal deinit&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var t = Animal()</span><br><span class="line">// 拿到数据</span><br><span class="line">t.backData &#123; data in</span><br><span class="line">    print(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">函数执行完了</span><br><span class="line">success：my is data : 10</span><br></pre></td></tr></table></figure><p>当前方法执行的过程中不会等待闭包执行完成后再执行，而是直接返回，所以 <code>当前闭包的生命周期要比方法长</code>。</p><p>2、闭包作为属性：</p><blockquote><p>当闭包作为存储属性时，主要有以下几点说明：<br>1、定义一个闭包属性；<br>2、在方法中对闭包属性进行赋值；<br>3、在合适的时机调用（与业务逻辑相关）。</p></blockquote><ul><li>逃逸闭包 vs 非逃逸闭包 区别</li></ul><p>1、非逃逸闭包：一个接受 <code>闭包作为参数</code> 的函数，闭包是在这个 <code>函数结束前</code> 被调用，即可以理解为闭包是在函数作用域结束前被调用。<br>1.1<code>不会产生循环引用</code>，因为闭包的作用域在函数作用域内，在函数执行完成后，就会释放闭包捕获的所有对象；<br>1.2针对非逃逸闭包，编译器会做优化：<code>省略内存管理调用</code>；<br>1.3非逃逸闭包捕获的上下文保存在 <code>栈上</code>，而不是堆上（官方文档说明）。</p><p>2.逃逸闭包：一个接受 <code>闭包作为参数</code> 的函数，逃逸闭包可能会在 <code>函数返回之后</code> 才被调用，即闭包逃离了函数的作用域。<br>2.1可能会 <code>产生循环引用</code>，因为逃逸闭包中需要 <code>显式</code> 的引用 <code>self</code>（猜测其原因是为了提醒开发者，这里可能会出现循环引用了），而self可能是持有闭包变量的（与 <code>OC中block</code> 的的循环引用类似）；<br>2.2一般用于异步函数的返回，例如网络请求。</p><p>3.使用建议：如果没有特别需要，开发中使用非逃逸闭包是 <code>有利于内存优化的</code>，所以苹果把闭包区分为两种，特殊情况时再使用逃逸闭包。</p><p>4.总结：主要区别就是 <code>调用时机和内存管理不同</code>。</p><h1 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h1><ul><li>在参数名的 <code>:</code> 后面加 <code>@autoclosure</code> 修饰符来说明 <code>自动闭包</code></li><li>@autoclosure 只支持 <code>()-&gt; T</code> 格式的参数</li><li>@autoclosure 会自动将 10 封装成闭包 {20}</li><li>@autoclosure 并非只支持最后 1 个参数</li><li>有@autoclosure和无@autoclosure构成了函数重载</li><li>空合并运算符 <code>??</code> 使用了@autoclosure技术</li></ul><p>先分析为什么会有自动闭包，自动闭包能实现什么作用<br>先看下面的一个函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func getInt(_ a: Int, _ b: () -&gt; Int) -&gt; Int &#123;</span><br><span class="line">    return a &gt; 0 ? a : b()</span><br><span class="line">&#125;</span><br><span class="line">getInt(1) &#123;</span><br><span class="line">    return 2</span><br><span class="line">&#125;</span><br><span class="line">// 打印结果是 1</span><br></pre></td></tr></table></figure><p>getInt函数调用时使用了一个尾随闭包，当参数满足 <code>()-&gt; T</code> 这个格式时可以写成 <code>自动闭包</code>，会使代码阅读起来更直观</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func getInt(_ a: Int, _ b: @autoclosure () -&gt; Int) -&gt; Int &#123;</span><br><span class="line">    return a &gt; 0 ? a : b()</span><br><span class="line">&#125;</span><br><span class="line">getInt(1, 2)</span><br><span class="line">// 打印结果是 1</span><br></pre></td></tr></table></figure><p>需要注意的是 <code>自动闭包</code> 会有 <code>延迟执行</code> 的特点，会在函数内部调用时才会执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func getInt(_ a: Int, _ b: @autoclosure () -&gt; Int) -&gt; Int &#123;</span><br><span class="line">    return a &gt; 0 ? a : b()</span><br><span class="line">&#125;</span><br><span class="line">func exec() -&gt; Int &#123;</span><br><span class="line">    print(&quot;执行了exec&quot;)</span><br><span class="line">    return 20</span><br><span class="line">&#125;</span><br><span class="line">getInt(1, exec())</span><br><span class="line">// 打印结果是 1</span><br></pre></td></tr></table></figure><blockquote><p><code>getInt(1, exec())</code> 函数调用时，很容易误以为 <code>exec()</code> 就已经调用了函数 <code>exec</code>，其实并没有，<code>exec</code> 内部没有执行。这是因为 <code>自动闭包有延迟执行的特点</code>。<br><code>getInt(1, exec())</code> 函数内部因为 a&gt;0 返回的结果是 a 的值，并没有调用到 b()，所以 exec 函数没有执行。<br>只有当 <code>getInt(1, exec())</code> 函数内部调用到了 <code>b()</code>，<code>exec</code> 函数才会被执行</p></blockquote><h1 id="闭包对变量的捕获"><a href="#闭包对变量的捕获" class="headerlink" title="闭包对变量的捕获"></a>闭包对变量的捕获</h1><ul><li>闭包可以对外部函数的 <code>变量/常量</code> 进行捕获</li><li>闭包捕获的时机是在函数执行完，return时再去捕获</li><li>当函数里有多个闭包时，只会对 <code>变量/常量</code> 捕获一次，多个闭包对捕获的 <code>变量/常量</code> 共享</li><li>闭包不会对全局变量进行捕获</li></ul><p>下面由几份代码来说明这个结论</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 变量捕获</span><br><span class="line">// MARK:局部变量捕获</span><br><span class="line">typealias fn = (Int) -&gt; Void</span><br><span class="line">func exec() -&gt; fn &#123;</span><br><span class="line">    var num = 0</span><br><span class="line">    return &#123; a in</span><br><span class="line">        num += a</span><br><span class="line">        print(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let res = exec()</span><br><span class="line">res(1)</span><br><span class="line">res(2)</span><br><span class="line">res(3)</span><br></pre></td></tr></table></figure><p>res(1)、res(2)、res(3) 输出的结果分别是 1、3、6<br>这是一个函数中返回的闭包，在闭包里对 num 进行了累加并输出结果</p><blockquote><p>1、第一次调用res时，num为0，0加上参数1&#x3D;1<br>2、第二次调用res时，闭包里的num的值是第一次res里的累加结果1，1加上参数2&#x3D;3<br>3、第三次调用res时，闭包里num是第二次res里累加的结果3，3加上参数3&#x3D;6<br>从三次调用res来看，闭包里num都是保存了上次调用后num的值，这是因为闭包捕获了外部的num，并重新在<code> 堆</code> 上 <code>分配了内存</code>，实际上是修改 <code>堆区中的value值</code>，当执行let res &#x3D; exec()时，把闭包的内存地址给了res,所以每次调用res都是调用的同一块内存，同一个闭包，闭包里有保存中捕获后的num的内存地址，所以每次调用都是同一个num </p></blockquote><p>可以把闭包想象成是一个类的实例对象，<code>内存在堆空间</code>，捕获的 <code>局部变量/常量</code> 就是对象的成员(存储属性)，组成闭包的函数就是类内部定义的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let res1 = exec()</span><br><span class="line">res1(1)</span><br><span class="line">let res2 = exec()</span><br><span class="line">res2(1)</span><br></pre></td></tr></table></figure><p>将上面的代码稍微改一下，将exec分别赋值给res1和res2，输出的结果为1和1。这个为什么不是跟上面一样累加呢，因为exec分别赋值给了res1和res2，res1和res2指向的是两个不一样的地址，当每调用一次exec()函数，num会初始化为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typealias fn = (Int) -&gt; Void</span><br><span class="line">func exec() -&gt; fn &#123;</span><br><span class="line">    var num = 0</span><br><span class="line">    func plus(a: Int) -&gt; Void&#123;</span><br><span class="line">        num += a</span><br><span class="line">        print(num)</span><br><span class="line">    &#125;</span><br><span class="line">    num = 6</span><br><span class="line">    </span><br><span class="line">    return plus</span><br><span class="line">&#125;</span><br><span class="line">let res = exec()</span><br><span class="line">res(1)</span><br></pre></td></tr></table></figure><p>上面这份代码输出的num又是多少呢？答案是7</p><blockquote><p>这还是一个局部变量捕获的问题，闭包会在函数执行完，return的时候才会去捕获num，此时num已经由0变为6，所以执行res(1)输出结果为7</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typealias fn = (Int) -&gt; Void</span><br><span class="line">func exec() -&gt; (fn, fn) &#123;</span><br><span class="line">    var num = 0</span><br><span class="line">    func plus(a: Int) &#123;</span><br><span class="line">        num += a</span><br><span class="line">        print(&quot;plus:&quot;, num)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func minus(a: Int) &#123;</span><br><span class="line">        num -= a</span><br><span class="line">        print(&quot;minus:&quot;, num)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (plus, minus)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let (p, m) = exec()</span><br><span class="line">p(5)</span><br><span class="line">m(4)</span><br></pre></td></tr></table></figure><p>这份代码函数返回了一个元祖，元祖里是两个闭包，两个闭包里面都调用了num，输出的结果为：<br>plus: 5<br>minus: 1</p><p>因为当函数里有多个闭包时，只会对变量&#x2F;常量捕获一次，多个闭包对捕获的变量&#x2F;常量共享</p><blockquote><p>因为当函数里有多个闭包时，只会对变量&#x2F;常量捕获一次，多个闭包对捕获的变量&#x2F;常量共享。在调用m(4)时，前面已经调用过p(5)，此时num已经变为5，所以当调用m(4)，输出结果为1。</p></blockquote><h1 id="typedef-为闭包类型定义别名"><a href="#typedef-为闭包类型定义别名" class="headerlink" title="typedef 为闭包类型定义别名"></a>typedef 为闭包类型定义别名</h1><p>这里先介绍一下 <code>typealias</code> 的使用 : <code>typealias</code> 是Swift中用来为已经存在的类型重新定义名字的关键字（类似于OC语法中的 <code>typedef</code>），重新命名的新名字用来替代之前的类型，并且能够使代码变得更加清晰简单容易理解。<code>typealias</code> 的用法很简单，直接用 <code>=</code> 赋值就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typealias &lt;type name&gt; = &lt;type expression&gt;</span><br></pre></td></tr></table></figure><p>这里我们可以用 <code>typealias</code> 来为看似较为复杂的闭包类型定义别名，这样以后我们就可以用别名直接去声明这样类型的闭包了，例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 为没有参数也没有返回值的闭包类型起一个别名</span><br><span class="line">typealias Nothing = () -&gt; ()</span><br><span class="line">    </span><br><span class="line">// 如果闭包的没有参数和返回值，那么我们还可以这样写，</span><br><span class="line">typealias Anything = () -&gt; Void</span><br><span class="line">    </span><br><span class="line">// 为接受一个 Int类型的参数 不返回任何值的闭包类型 定义一个别名：PrintNumber</span><br><span class="line">typealias PrintNumber = (Int) -&gt; ()</span><br><span class="line">    </span><br><span class="line">// 为接受两个Int类型的参数并且返回一个Int类型的值的闭包类型 定义一个别名：Add</span><br><span class="line">typealias Add = (Int, Int) -&gt; (Int)</span><br></pre></td></tr></table></figure><p>闭包是否接受参数、接受几个参数、返回什么类型的值完全取决于你的需求。</p><h1 id="闭包的创建、赋值、调用"><a href="#闭包的创建、赋值、调用" class="headerlink" title="闭包的创建、赋值、调用"></a>闭包的创建、赋值、调用</h1><p>闭包表达式语法能够使用常量形式参数、变量形式参数和输入输出形式参数，但不能提供默认值。可变形式参数也能使用，但需要在形式参数列表的最后面使用。元组也可被用来作为形式参数和返回类型。在闭包的中会用到一个关键字in，in 可以看做是一个分割符，他把该闭包的类型和闭包的函数体分开，in前面是该闭包的类型，in后面是具体闭包调用时保存的需要执行的代码。表示该闭包的形式参数类型和返回类型定义已经完成，并且闭包的函数体即将开始执行。这里总结了一下可能用到的几种形式实现闭包的创建、赋值、调用的过程。例子如下:</p><p><strong>方式一：利用typealias最完整的创建</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 为(_ num1: Int, _ num2: Int) -&gt; (Int) 类型的闭包定义别名：Add</span><br><span class="line">typealias Add = (_ num1: Int, _ num2: Int) -&gt; (Int)</span><br><span class="line">// 创建一个 Add 类型的闭包常量：addCloser1</span><br><span class="line">let addCloser1: Add</span><br><span class="line">// 为已经创建好的常量 addCloser1 赋值</span><br><span class="line">addCloser1 = &#123; (_ num1: Int, _ num2: Int) -&gt; (Int) in</span><br><span class="line">    return num1 + num2</span><br><span class="line">&#125;</span><br><span class="line">// 调用闭包并接受返回值</span><br><span class="line">let result = addCloser1(20, 10)</span><br></pre></td></tr></table></figure><p><strong>形式二：闭包类型声明和变量的创建合并在一起</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 (_ num1: Int, _ num2: Int) -&gt; (Int) 类型的闭包常量：addCloser1</span><br><span class="line">let addCloser1: (_ num1: Int, _ num2: Int) -&gt; (Int)</span><br><span class="line">// 为已经创建好的常量 addCloser1 赋值</span><br><span class="line">addCloser1 = &#123; (_ num1: Int, _ num2: Int) -&gt; (Int) in</span><br><span class="line">     return num1 + num2</span><br><span class="line">&#125;</span><br><span class="line">// 调用闭包并接受返回值</span><br><span class="line">let result = addCloser1(20, 10)</span><br></pre></td></tr></table></figure><p><strong>形式三：省略闭包接收的形参、省略闭包体中返回值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 (Int, Int) -&gt; (Int) 类型的闭包常量：addCloser1</span><br><span class="line">let addCloser1: (Int, Int) -&gt; (Int)</span><br><span class="line">// 为已经创建好的常量 addCloser1 赋值</span><br><span class="line">addCloser1 = &#123; (num1, num2) in</span><br><span class="line">     return num1 + num2</span><br><span class="line">&#125;</span><br><span class="line">// 调用闭包并接受返回值</span><br><span class="line">let result = addCloser1(20, 10)</span><br></pre></td></tr></table></figure><p><strong>在形式三的基础上进一步精简</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 (Int, Int) -&gt; (Int) 类型的闭包常量：addCloser1 并赋值</span><br><span class="line">let addCloser1: (Int, Int) -&gt; (Int) = &#123; (num1, num2) in</span><br><span class="line">   return num1 + num2</span><br><span class="line">&#125;    </span><br><span class="line">// 调用闭包并接受返回值</span><br><span class="line">let result = addCloser1(20, 10)</span><br></pre></td></tr></table></figure><p><strong>形式五：如果闭包没有接收参数省略in</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 () -&gt; (String) 类型的闭包常量：addCloser1 并赋值</span><br><span class="line">let addCloser1: () -&gt; (String) = &#123;</span><br><span class="line">    return &quot;这个闭包没有参数，但是有返回值&quot;</span><br><span class="line">&#125;</span><br><span class="line">// 调用闭包并接受返回值</span><br><span class="line">let result = addCloser1()</span><br></pre></td></tr></table></figure><p><strong>形式六：简写的实际参数名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 (String, String) -&gt; (String) 类型的闭包常量：addCloser1 并赋值</span><br><span class="line">let addCloser1: (String, String) -&gt; (String) = &#123;</span><br><span class="line">    return &quot;闭包的返回值是:\($0),\($1)&quot;</span><br><span class="line">&#125;</span><br><span class="line">// 调用闭包并接受返回值</span><br><span class="line">let result = addCloser1(&quot;Hello&quot;, &quot;Swift!&quot;)</span><br></pre></td></tr></table></figure><p>说明： 得益于Swift的 <code>类型推断机制</code>，我们在使用闭包的时候可以省略很多东西，而且Swift自动对行内闭包提供简写实际参数名，你也可以通过 <code>$0, $1, $2</code> 这样的语法来引用闭包的实际参数值。如果你在闭包表达式中使用这些简写实际参数名，那么你可以在闭包的实际参数列表中忽略对其的定义，并且简写实际参数名的数字和类型将会从期望的函数类型中推断出来。in关键字也能被省略，<code>$0</code> 和 <code>$1</code> 分别是闭包的第一个和第二个 <code>String类型的</code> 实际参数（引自文档翻译）。</p><h1 id="闭包常见的几种使用场景"><a href="#闭包常见的几种使用场景" class="headerlink" title="闭包常见的几种使用场景"></a>闭包常见的几种使用场景</h1><p><strong>场景一：利用闭包传值</strong></p><p>开发过程中常常会有这样的需求：一个页面的得到的数据需要传递给前一个页面使用。这时候使用闭包可以很简单的实现两个页面之间传值。</p><p>场景再现：<br>第一个界面中有一个用来显示文字的UILabel和一个点击进入到第二个界面的UIButton,第二个界面中有一个文本框UITextField和一个点击返回到上一个界面的UIButton,现在的需求是在第二个界面的UITextField中输入完文字后，点击返回按钮返回到第一个界面并且将输入的文字显示在第一个界面（当前页面）的UILabel中。</p><p>实现代码:<br>首先在第二个界面的控制器中定义一个 <code>(String) -&gt; ()</code> 可选类型的闭包常量 <code>closer</code> 作为SecondViewController的属性。closer接收一个String类型的参数（就是输入的文字）并且没有返回值。然后在返回按钮的点击事件中传递参数执行闭包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">class SecondViewController: UIViewController &#123;</span><br><span class="line">    // 输入文本框</span><br><span class="line">    @IBOutlet weak var textField: UITextField!</span><br><span class="line">    // 为创建一个(String) -&gt; () 的可选类型的闭包变量作为控制器的属性</span><br><span class="line">    var closer: ((String) -&gt; ())?</span><br><span class="line">    // 返回按钮的点击事件</span><br><span class="line">    @IBAction func backButtonDidClick(_ sender: AnyObject) &#123;</span><br><span class="line">        // 首先判断closer闭包是否已经被赋值，如果已经有值，直接调用该闭包，并将输入的文字传进去。</span><br><span class="line">        if closer != nil &#123;</span><br><span class="line">            closer!(textField.text!)</span><br><span class="line">        &#125;</span><br><span class="line">        navigationController?.popViewController(animated: true)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个注意点：我们在为 <code>SecondViewController</code> 定义变量闭包属性的时候需要将类型声明为可选类型，闭包可选类型应该是<code> ((String) -&gt; ())?</code> 而不是 <code>(String) -&gt; ()?</code> 的，后者指的是闭包的返回值是可选类型。<br>回到第一个界面的控制器中，我们需要拿到UILabel的控件，然后重写 <code>prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; &#125;</code> 方法，在这个跳转方法中拿到跳转的目标控制器<code>SecondVC</code> 并为他的闭包属性赋值，当然如果你的跳转按钮的点击事件是自己处理的，直接在按钮的点击事件中这样做就OK了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">class FirstViewController: UIViewController &#123;</span><br><span class="line">    // 显示文字的label</span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">    // 重写这个方法</span><br><span class="line">    override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123;</span><br><span class="line">        // 拿到跳转的目标控制器</span><br><span class="line">        let secondVC = segue.destination as! SecondViewController</span><br><span class="line">        // 为目标控制器的闭包属性赋值</span><br><span class="line">        secondVC.closer = &#123;</span><br><span class="line">            // 将闭包的参数(输入的文本内容)显示在label上</span><br><span class="line">            self.label.text = $0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面的处理，我们就可以实现两个页面之间的传值了（是不是很简单呢），当然在具体的开发中很可能不是传递文本内容这么简单，当需要传递更复杂的值时，我们可以将传递的值包装成一个模型，直接用闭包传递模型就好了。</p><p><strong>场景二：闭包作为函数的参数</strong></p><p>在OC语法中block可以作为函数的参数进行传递，在Swift中同样可以用闭包作为函数的参数，还记得上面利用 <code>typealias</code> 关键字定义别名吗，定义完的别名就是一个闭包类型，可以用它申明一个闭包常量或变量当做参数进行传递。一个最简单的闭包作为函数参数例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 为接受一个Int类型的参数并且返回一个Int类型的值的闭包类型定义一个别名：Number</span><br><span class="line">typealias Number = (num1: Int) -&gt; (Int)</span><br><span class="line">// 定义一个接收Number类型的参数没有返回值的方法</span><br><span class="line">func Text(num: Number) &#123;</span><br><span class="line">  // code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包在作为函数的参数进行传递的时候根据函数接收参数的情况有很多种不同的写法。这里我们主要介绍一下尾随闭包的概念。<br>首先看一下一般形式的闭包作为函数的参数传递：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 拼接两个字符串和一个整数</span><br><span class="line">func combine(handle:(String, String) -&gt; (Void), num: Int) &#123;</span><br><span class="line">        handle(&quot;hello&quot;, &quot;world \(num)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 方法调用</span><br><span class="line">combine(handle: &#123; (text, text1) -&gt; (Void) in</span><br><span class="line">        print(&quot;\(text) \(text1)&quot;)</span><br><span class="line">&#125;, num: 2016)</span><br></pre></td></tr></table></figure><p>可以看到上面的combine方法在主动调用的时候依旧是按照 <code>func(形参: 实参)</code> 这样的格式。当我们把闭包作为函数的最后一个参数的时候就引出了尾随闭包的概念。</p><p>一，尾随闭包</p><p>尾随闭包是指当需要将一个很长的闭包表达式作为函数最后一个实际参数传递给函数时，一个书写在函数形式参数的括号外面（后面）的闭包表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func combine1(num:Int, handle:(String, String)-&gt;(Void)) &#123;</span><br><span class="line">  handle(&quot;hello&quot;, &quot;world \(num)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">combine1(num: 2016) &#123; (text, text1) -&gt; (Void) in</span><br><span class="line">  print(&quot;\(text) \(text1)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步：如果闭包表达式被用作函数唯一的实际参数并且你把闭包表达式用作尾随闭包，那么调用这个函数的时候函数名字的（）都可以省略：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func combine2(handle:(String, String)-&gt;(Void)) &#123;</span><br><span class="line">     handle(&quot;hello&quot;, &quot;world&quot;)</span><br><span class="line">&#125;</span><br><span class="line">combine2 &#123; (text, text1) -&gt; (Void) in</span><br><span class="line">     print(&quot;\(text) \(text1)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二，逃逸闭包<br>如果一个闭包被作为一个参数传递给一个函数，并且在函数return之后才被唤起执行，那么我们称这个闭包的参数是“逃出”这个函数体外，这个闭包就是逃逸闭包。此时可以在形式参数前写 <code>@escaping</code> 来明确闭包是允许逃逸的。<br>闭包可以逃逸的一种方法是被储存在定义于函数外的变量里。比如说，很多函数接收闭包实际参数来作为启动异步任务的回调。函数在启动任务后返回，但是闭包要直到任务完成——闭包需要逃逸，以便于稍后调用。用我们最常用的网络请求举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func request(methodType:RequestMethodType, urlString: String, parameters: [String : AnyObject], completed: @escaping (AnyObject?, NSError?) -&gt; ()) &#123;</span><br><span class="line">        // 1.封装成功的回调</span><br><span class="line">        let successCallBack = &#123; (task : URLSessionDataTask?, result : Any?) -&gt; Void in</span><br><span class="line">            completed(result as AnyObject?, nil)</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.封装失败的回调</span><br><span class="line">        let failureCallBack = &#123; (task : URLSessionDataTask?, error : Error?) -&gt; Void in</span><br><span class="line">            completed(nil, error as NSError?)</span><br><span class="line">        &#125;</span><br><span class="line">        // 判断是哪种请求方式</span><br><span class="line">        if methodType == .get &#123;</span><br><span class="line">            get(urlString, parameters: parameters, success: successCallBack, failure: failureCallBack)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            post(urlString, parameters: parameters, success: successCallBack, failure: failureCallBack)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="使用闭包可能引起的循环强引用"><a href="#使用闭包可能引起的循环强引用" class="headerlink" title="使用闭包可能引起的循环强引用"></a>使用闭包可能引起的循环强引用</h1><p>Swift中不当的使用闭包可能会引起循环强引用，之所以称之为“强”引用，是因为它会将实例保持住，只要强引用还在，实例是不允许被销毁的。循环强引用会一直阻止类实例的释放，这就在你的应用程序中造成了内存泄漏。<br>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">class ThirdViewController: UIViewController &#123;</span><br><span class="line">    var callBack: ((String) -&gt; ())?</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        printString &#123; (text) in</span><br><span class="line">            print(text)</span><br><span class="line">            // 闭包中捕获了self</span><br><span class="line">            self.view.backgroundColor = UIColor.red</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    func printString(callBack:@escaping (String) -&gt; ()) &#123;</span><br><span class="line">        callBack(&quot;这个闭包返回一段文字&quot;)</span><br><span class="line">        // 控制器强引用于着callBack</span><br><span class="line">        self.callBack = callBack</span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;ThirdViewController---释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你在定义printString这个方法时执行 <code>self.callBack = callBack</code> 代码实际上是self对callBack闭包进行了强引用，到这里其实并没有产生循环引用，但是当你在调用printString方法的闭包里面又访问了self.view.backgroundColor属性，此时强引用就发生了，即self引用了callBack,而callBack内部又引用着self,谁都不愿意松手，我们就说这两者之间产生了循环强引用。</p><p>使用闭包何时会出现循环强引用 ：<br>当你把一个闭包分配给类实例属性的时候，并且这个闭包中又捕获了这个实例。捕获可能发生于这个闭包函数体中访问了实例的某个属性，比如 <code>self.someProperty</code> ，或者这个闭包调用了一个实例的方法，例如 <code>self.someMethod()</code> 。这两种情况都导致了闭包捕获了 <code>self</code> ，从而产生了循环强引用。</p><p>闭包循环引用的本质是：<br>闭包中循环强引用的产生，是因为闭包和类相似（还有一种两个类实例之间的循环强引用），都是引用类型。当你把闭包赋值给了一个属性，你实际上是把一个引用赋值给了这个闭包。两个强引用让彼此一直有效。</p><p>如何解决闭包的循环强引用：</p><ul><li>方式一：类似于Objective-C中使用 <code>__weak</code> 解决block的循环引用，Swift中支持使用 <code>weak</code> 关键字将类实例声明为弱引用类型（注意，弱引用类型总是 <code>可选类型</code>），打破类实例对闭包的强引用，当对象销毁之后会自动置为 <code>nil</code>，对 <code>nil</code> 进行任何操作不会有反应。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">class ThirdViewController: UIViewController &#123;</span><br><span class="line">    var callBack: ((String) -&gt; ())?</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        // 将self声明明为弱引用类型，打破循环引用</span><br><span class="line">        weak var weakSelf = self</span><br><span class="line">        printString &#123; (text) in</span><br><span class="line">            print(text)</span><br><span class="line">            // 闭包中铺捕获了self</span><br><span class="line">            weakSelf?.view.backgroundColor = UIColor.red</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    func printString(callBack:@escaping (String) -&gt; ()) &#123;</span><br><span class="line">        callBack(&quot;这个闭包返回一段文字&quot;)</span><br><span class="line">        // 控制器强引用于着callBack</span><br><span class="line">        self.callBack = callBack</span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;ThirdViewController---释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式二：作为第一种方式的简化操作，我们可以在闭包的第一个大括号后面紧接着插入这段代码 <code>[weak self]</code> ，后面的代码直接使用 <code>self？</code> 也能解决循环引用的问题。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">class ThirdViewController: UIViewController &#123;</span><br><span class="line">    var callBack: ((String) -&gt; ())?</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        printString &#123; [weak self] (text) in</span><br><span class="line">            print(text)</span><br><span class="line">            self?.view.backgroundColor = UIColor.red</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    func printString(callBack: @escaping (String) -&gt; ()) &#123;</span><br><span class="line">        callBack(&quot;这个闭包返回一段文字&quot;)</span><br><span class="line">        // 控制器强引用于着callBack</span><br><span class="line">        self.callBack = callBack</span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;ThirdViewController---释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式三：在闭包和捕获的实例总是互相引用并且总是同时释放时，可以将闭包内的捕获定义为 <code>无主引用unowned</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">class ThirdViewController: UIViewController &#123;</span><br><span class="line">    var callBack: ((String) -&gt; ())?</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        printString &#123; [unowned self]  (text) in</span><br><span class="line">            print(text)</span><br><span class="line">            self?.view.backgroundColor = UIColor.red</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    func printString(callBack:@escaping (String) -&gt; ()) &#123;</span><br><span class="line">        callBack(&quot;这个闭包返回一段文字&quot;)</span><br><span class="line">        // 控制器强引用于着callBack</span><br><span class="line">        self.callBack = callBack</span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;ThirdViewController---释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>unowned</code> 是Swift中另外一种解决循环引用的申明无主引用类型的关键字，类似于Objective-C中的 <code>__unsafe_unretained</code>；大家都知道 <code>__weak</code> 和 <code>__unsafe_unretained</code> 的相同点是可以将该关键字修饰的对象变成弱引用解决可能存在的循环引用。不同点在于前者修饰的对象如果发现被销毁，那么指向该对象的指针会立即指向nil，而<code>__unsafe_unretained</code> 修饰的对象如果发现被销毁，指向该对象的指针依然指向原来的内存地址，如果此时继续访问该对象 <code>很容易产生坏内存访问/野指针/僵尸对象访问</code>。</p><p>说明：同样的道理Swift中也是一样的。和弱引用类似，无主引用不会牢牢保持住引用的实例。但是不像弱引用，总之，<code>无主引用假定是永远有值的</code>。因此，<code>无主引用总是被定义为非可选类型</code>。你可以在声明属性或者变量时，在前面加上关键字 <code>unowned</code> 表示这是一个无主引用。由于无主引用是非可选类型，你不需要在使用它的时候将它展开。无主引用总是可以直接访问。不过 <code>ARC</code> 无法在实例被释放后将无主引用设为 <code>nil</code> ，因为非可选类型的变量不允许被赋值为 <code>nil</code> 。如果此时继续访问已经被释放实例很容易产生坏内存访问&#x2F;野指针&#x2F;僵尸对象访问。所以Swift建议我们如果被捕获的引用永远不为 <code>nil</code> ，应该用 <code>unowned</code> 而不是 <code>weak</code>，相反，如果你不确定闭包中捕获的引用是不是存在为<code>nil</code> 的可能，你应该使用 <code>weak</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习33：函数</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A033%EF%BC%9A%E5%87%BD%E6%95%B0/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A033%EF%BC%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Swift中如何定义和使用函数"><a href="#Swift中如何定义和使用函数" class="headerlink" title="Swift中如何定义和使用函数"></a>Swift中如何定义和使用函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p><code>函数是一个独立的代码块，用来执行特定的任务</code>。通过给函数一个 <code>名字</code> 来定义它的功能，并且在需要的时候，通过这个名字来 <code>调用</code> 函数执行它的任务</p></li><li><p><code>Swift统一的函数语法十分灵活</code>。可以从简单的无形式参数到复杂的每个形式参数都带有局部和外部形式参数名。形式参数提供一个默认值来简化函数的调用，可被当做输入输出形式参数被传递，在函数执行完成时修改传递进来的变量。</p></li><li><p><code>Swift中每一个函数都有类型，由函数的形式参数类型和返回类型组成</code> 。可以像swift中其它类型来使用它。可以将函数当一个形式参数传递到另外一个函数中。也可以在一个函数中返回另一个函数。同时也可以写在其他函数内部在内嵌范围封装有用的功能。</p></li><li><p>函数是 <code>引用类型</code> 的，不是值类型的</p></li></ul><h2 id="定义和调用函数"><a href="#定义和调用函数" class="headerlink" title="定义和调用函数"></a>定义和调用函数</h2><ul><li><p>当你定义一个函数时，可以选择定义一个或多个形式参数类型，也可以定义返回类型</p></li><li><p>每个函数都有函数名，描述执行的任务。</p></li><li><p>使用函数可通过 <code>函数名</code> 并且 <code>传入</code> 函数的 <code>实际参数</code> （即形式参数类型的输入值 ）来 <code>调用函数</code>。</p></li><li><p>实际参数顺序必须符合形式参数的列表顺序</p></li></ul><h2 id="无形式参数的函数"><a href="#无形式参数的函数" class="headerlink" title="无形式参数的函数"></a>无形式参数的函数</h2><ul><li><p>函数不要求必须传入一个参数，可以没有形式参数</p></li><li><p>函数定义需要在名字的后面加一个圆括号，即使没有形式参数也得加</p></li><li><p>调用函数的时候也要在函数的名字后面加一个圆括号</p></li></ul><h2 id="多形式参数的函数"><a href="#多形式参数的函数" class="headerlink" title="多形式参数的函数"></a>多形式参数的函数</h2><ul><li>函数可以输入多个形式参数，写在圆括号内，用逗号分割</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func manyPara(a:Int,b:Int) &#123;</span><br><span class="line">    pring(&quot;\(a) \(b)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无返回值的函数"><a href="#无返回值的函数" class="headerlink" title="无返回值的函数"></a>无返回值的函数</h2><ul><li><p>函数定义可以没有返回类型，即没有返回箭头 -&gt; 或返回类型</p></li><li><p>严格上，函数还是有一个返回类型的，尽管没有定义返回值，实际上返回一个特殊的类型 <code>void</code>。它是一个空的元组，作用相当于没有元素的元组，写作()</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func manyTuple() -&gt; void &#123;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多返回值的函数"><a href="#多返回值的函数" class="headerlink" title="多返回值的函数"></a>多返回值的函数</h2><ul><li>可以让函数返回多个值作为一个复合的返回值，你可以使用元组类型作为返回类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func manyTuple() -&gt; (a:Int,b:String) &#123;</span><br><span class="line">    return (1,&quot;aaa&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可选元组返回类型"><a href="#可选元组返回类型" class="headerlink" title="可选元组返回类型"></a>可选元组返回类型</h2><ul><li><p>如果在函数返回类型中元组可能 <code>没有值</code>，可以用可选元组说明元组可能是 <code>nil</code></p></li><li><p>写法是可选元组圆括号后面加一个问号 <code>？</code>，例如 (Int,Int)? 或 (String,Int,Bool)?</p></li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 返回元组</span><br><span class="line">func minMax(arr: [Int]) -&gt; (min:Int,max:Int)? &#123;</span><br><span class="line">    if arr.isEmpty &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    var minValue = arr[0]</span><br><span class="line">    var maxValue = arr[0]</span><br><span class="line">    for value in arr &#123;</span><br><span class="line">        if value &lt; minValue &#123;</span><br><span class="line">            minValue = value</span><br><span class="line">        &#125;</span><br><span class="line">        if value &gt; maxValue &#123;</span><br><span class="line">            maxValue = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (minValue,maxValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 绑定</span><br><span class="line">if let minMaxValue = minMax(arr: [1,3,4,2,5]) &#123;</span><br><span class="line">    print(&quot;min is \(minMaxValue.min),max is \(minMaxValue.max)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译运行，查看打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min is 1,max is 5</span><br></pre></td></tr></table></figure><h2 id="隐士返回函数"><a href="#隐士返回函数" class="headerlink" title="隐士返回函数"></a>隐士返回函数</h2><ul><li>如果整个函数体是一个单一的表达式，那么函数隐士返回这个表达式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func greet(person: String) -&gt; String&#123;</span><br><span class="line">    &quot;Hello,&quot; + person + &quot;!&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;\(greet(person: &quot;World&quot;))&quot;)</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello,World!</span><br></pre></td></tr></table></figure><h1 id="Swift形式参数和返回值"><a href="#Swift形式参数和返回值" class="headerlink" title="Swift形式参数和返回值"></a>Swift形式参数和返回值</h1><h2 id="实参标签和形参名"><a href="#实参标签和形参名" class="headerlink" title="实参标签和形参名"></a>实参标签和形参名</h2><ul><li><p>每一个函数的形式参数都包含实际参数标签和形式参数名。</p></li><li><p>形式参数必须有唯一的名字，有助于代码易读</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func someFunc(firstParamName:Int,secondParamName:Int)&#123;</span><br><span class="line">    // 形式参数 firstParamName secondParamName</span><br><span class="line">&#125;</span><br><span class="line">someFunc(firstParamName: 1, secondParamName: 2)</span><br></pre></td></tr></table></figure><h2 id="指定实际参数标签"><a href="#指定实际参数标签" class="headerlink" title="指定实际参数标签"></a>指定实际参数标签</h2><ul><li><p>形式参数名之前写实际参数标签，用 <code>空格</code> 分割</p></li><li><p>如果你为 <code>形式参数</code> 定义了 <code>实际参数标签</code>，那么在调用函数的时候必须使用 <code>实际参数标签</code></p></li><li><p>实际参数标签能够让函数的调用更加明确，更像自然语言，更可读，更清晰表达你的意图</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 实际参数标签 home</span><br><span class="line">func greet(person: String, from home: String) -&gt; String &#123;</span><br><span class="line">    return &quot;Hello \(person)! my home is \(home)&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(greet(person: &quot;ZJ&quot;,from: &quot;BeiJing&quot;))</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello ZJ! my home is BeiJing</span><br></pre></td></tr></table></figure><h2 id="省略实际参数标签"><a href="#省略实际参数标签" class="headerlink" title="省略实际参数标签"></a>省略实际参数标签</h2><ul><li>可以利用下划线 <code>_</code> 替代显示的实际参数标签</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func greet(_ person: String, _ home: String) -&gt; String &#123;</span><br><span class="line">    return &quot;Hello \(person)! my home is \(home)&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(greet(person: &quot;ZJ&quot;,from: &quot;BeiJing&quot;))</span><br></pre></td></tr></table></figure><h2 id="默认形式参数值"><a href="#默认形式参数值" class="headerlink" title="默认形式参数值"></a>默认形式参数值</h2><ul><li><p>可以在形式参数类型后，给类型定义一个默认值</p></li><li><p>如果定义了默认值，你就可以在调用的时候省略这个形式参数</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func someFunc(paramDefault: Int = 10) &#123;</span><br><span class="line">    print(&quot;\(paramDefault)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">someFunc(paramDefault: 6)</span><br><span class="line">someFunc()</span><br><span class="line"></span><br><span class="line">===========</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="可变形式参数"><a href="#可变形式参数" class="headerlink" title="可变形式参数"></a>可变形式参数</h2><ul><li><p>一个可变的形式参数可以接受零或多个特定类型的值。</p></li><li><p>通过在形式参数类型名后插入三个点符号 <code>...</code> 来书写可变形式参数。</p></li><li><p>传入到可变参数中的值在函数的主体中被当做是对应类型的 <code>数组</code>。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func changeFunc(_ numbers: Double...) -&gt; Double &#123;</span><br><span class="line">    var total: Double = 0</span><br><span class="line">    for number in numbers &#123;</span><br><span class="line">        total += number</span><br><span class="line">    &#125;</span><br><span class="line">    return total / Double(numbers.count)</span><br><span class="line">&#125;</span><br><span class="line">changeFunc(1,2,3,4,5)</span><br><span class="line"></span><br><span class="line">=============</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="输入输出形式参数"><a href="#输入输出形式参数" class="headerlink" title="输入输出形式参数"></a>输入输出形式参数</h2><ul><li><p>可变形式参数只能在函数的内部做改变。如果你想函数能修改一个形式参数的值，而且这些改变在函数结束之后依然生效，那么就需要将形式参数定义为输入输出形式参数</p></li><li><p>输入输出形式参数：在形式参数前边加 <code>inout</code> 关键字。</p></li><li><p>只能把 <code>变量</code> 作为输入输出形式参数的 <code>实际参数</code>，在将变量作为实际参数传入给输入输出形式参数时，在它前边添加一个符号 <code>&amp;</code> 来明确可以被函数修改</p></li><li><p>输入输出形式参数不能有默认值，可变形式参数不能被标记为 <code>inout</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 输入输出形式参数</span><br><span class="line">func swapTwoInt(_ a: inout Int, _ b: inout Int) &#123;</span><br><span class="line">    let temp = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temp</span><br><span class="line">&#125;</span><br><span class="line">var one = 10</span><br><span class="line">var two = 20</span><br><span class="line">swapTwoInt(&amp;one,&amp;two)</span><br><span class="line">print(&quot;\(one) \(two)&quot;)</span><br><span class="line"></span><br><span class="line">=========</span><br><span class="line">20 10</span><br></pre></td></tr></table></figure><h1 id="函数类型和内嵌函数"><a href="#函数类型和内嵌函数" class="headerlink" title="函数类型和内嵌函数"></a>函数类型和内嵌函数</h1><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><ul><li>每一个函数都有一个特定的函数类型，它由形式参数类型，返回类型组成</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func addTwo(_ a:Int,_ b:Int) -&gt; Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line">let c = addTwo(1,2)</span><br><span class="line">print(&quot;\(c)&quot;)</span><br><span class="line"></span><br><span class="line">========</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>和 (Int,Int) -&gt; Int 相关</p><h2 id="使用函数类型"><a href="#使用函数类型" class="headerlink" title="使用函数类型"></a>使用函数类型</h2><ul><li>你可以像使用Swift中的其他类型一样使用函数类型。例如：你可一个常量或变量定义一个函数类型，并且未变量指定一个相应的函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func addTwo(_ a:inout Int,_ b:inout Int) -&gt; Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line">var mathFunc:(inout Int,inout Int) -&gt; Int = addTwo</span><br><span class="line">print(mathFunc(2,3))</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="函数类型作为形式参数类型"><a href="#函数类型作为形式参数类型" class="headerlink" title="函数类型作为形式参数类型"></a>函数类型作为形式参数类型</h2><ul><li>你可以将 <code>函数</code> 作为 <code>其他函数的形式参数</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func addTwo(_ a:Int,_ b:Int) -&gt; Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line">func printResult(_ mathFunc:(Int,Int) -&gt; Int,_ a:Int,_ b:Int) &#123;</span><br><span class="line">    print(&quot;Result:\(mathFunc(a,b))&quot;)</span><br><span class="line">&#125;</span><br><span class="line">printResult(addTwo,2,3)</span><br><span class="line"></span><br><span class="line">==========</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="函数类型作为返回类型"><a href="#函数类型作为返回类型" class="headerlink" title="函数类型作为返回类型"></a>函数类型作为返回类型</h2><ul><li>可以利用函数的类型作为另一个函数的返回类型。写法在函数的返回箭头后写一个完整的函数类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func backF(_ input:Int) -&gt; Int&#123;</span><br><span class="line">    return input - 1</span><br><span class="line">&#125;</span><br><span class="line">func chooseFunc(back: Bool) -&gt; (Int) -&gt; Int &#123;</span><br><span class="line">    return backF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内嵌函数"><a href="#内嵌函数" class="headerlink" title="内嵌函数"></a>内嵌函数</h1><ul><li><p>可以在函数内定义另外一个函数。这就是内嵌函数</p></li><li><p>内嵌函数默认是被隐藏起来的，但仍然可以通过包裹他们的函数来调用他们。</p></li><li><p>包裹的函数也可以返回它内部的一个内嵌函数来在另外的返回里使用</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func chooseFunc(back: Bool) -&gt; (Int) -&gt; Int &#123;</span><br><span class="line">    func stepForward(step:Int) -&gt; Int &#123; return step + 1&#125;</span><br><span class="line">    func stepBackward(step:Int) -&gt; Int &#123; return step - 1&#125;</span><br><span class="line">    return back ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br><span class="line">var current = -4</span><br><span class="line">let stepFunc = chooseFunc(back: current &gt; 0)</span><br><span class="line">while current != 0 &#123;</span><br><span class="line">    current = stepFunc(current)</span><br><span class="line">&#125;</span><br><span class="line">print(current)</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习32：Dictionary字典底层实现探索</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A032%EF%BC%9ADictionary%E5%AD%97%E5%85%B8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A032%EF%BC%9ADictionary%E5%AD%97%E5%85%B8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习32：Dictionary字典</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A032%EF%BC%9ADictionary%E5%AD%97%E5%85%B8/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A032%EF%BC%9ADictionary%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习31：Set底层实现探究</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A031%EF%BC%9ASet%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%A9%B6/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A031%EF%BC%9ASet%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习30：Set集合</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A030%EF%BC%9ASet%E9%9B%86%E5%90%88/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A030%EF%BC%9ASet%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习29：如何用数组来实现栈和队列</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A029%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A029%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习28：数组的底层实现</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A028%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A028%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习27：访问和操作数组</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A027%EF%BC%9A%E8%AE%BF%E9%97%AE%E5%92%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A027%EF%BC%9A%E8%AE%BF%E9%97%AE%E5%92%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习26：创建数组的几种方式</title>
      <link href="/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A026%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/BboyZJ.github.io/2023/03/03/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A026%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC三方框架01：bugly搜集Crash</title>
      <link href="/BboyZJ.github.io/2023/03/03/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603.1%EF%BC%9Abugly%E6%90%9C%E9%9B%86Crash/"/>
      <url>/BboyZJ.github.io/2023/03/03/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603.1%EF%BC%9Abugly%E6%90%9C%E9%9B%86Crash/</url>
      
        <content type="html"><![CDATA[<h1 id="Bugly-介绍"><a href="#Bugly-介绍" class="headerlink" title="Bugly 介绍"></a>Bugly 介绍</h1><p>为了能够快速并准确的定位用户 <code>App</code> 发生 <code>Crash</code> 的代码位置，<code>Bugly</code> 使用 <code>符号表文件</code> 对发生 <code>Crash</code> 的程序 <code>堆栈</code> 进行 <code>解析和还原</code></p><p>举例：</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031701073.png"></p><h1 id="Bugly-上传方式"><a href="#Bugly-上传方式" class="headerlink" title="Bugly 上传方式"></a>Bugly 上传方式</h1><ul><li><p><code>Bugly</code> 已不再支持直接上传dSYM文件，需要 <code>下载工具包手动上传</code></p></li><li><p>本文主要介绍 <code>下载工具包手动上传</code></p></li></ul><h1 id="安装java运行环境"><a href="#安装java运行环境" class="headerlink" title="安装java运行环境"></a>安装java运行环境</h1><ul><li>终端查看是否已安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhangjian@zhangjiandeMBP ~ % java -version</span><br><span class="line">java version &quot;1.8.0_291&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_291-b10)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.291-b10, mixed mode)</span><br></pre></td></tr></table></figure><p>上面的显示表示已安装</p><ul><li>未安装的情况如下：</li></ul><p>到 <a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">Java官网</a> 下载 <code>jdk</code>，如下图：</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031621953.png"></p><p>下载完成之后打开 <code>dmg</code>，安装、一路下一步即可安装成功。</p><p>在终端输入 <code>java -version</code> 可以查看 <code>java</code> 版本，如果输出信息和上面类似，表示安装成功</p><h1 id="获取-dSYM-文件"><a href="#获取-dSYM-文件" class="headerlink" title="获取 dSYM 文件"></a>获取 <code>dSYM</code> 文件</h1><ul><li><p>什么是 <code>dSYM</code> 文件？</p><ul><li><p>在 <code>iOS</code> 平台中，dSYM文件是指 <code>具有调试信息的目标文件</code>，文件名通常为 <code>xxx.app.dSYM</code></p></li><li><p>【注】：为了方便找回 <code>Crash</code> 对应的 <code>dSYM文件</code> 和 <code>还原堆栈</code>，建议每次 <code>构建或发布App版本</code> 时，备份好 <code>dSYM文件</code></p></li></ul></li><li><p>获取 <code>dSYM</code> 方式</p></li></ul><p>我们可以配置 <code>Edit Scheme -&gt; Archives</code> 打包 <code>Debug</code> 和 <code>Release</code> 两种环境，去获取 <code>dSYM文件</code>，本文以 <code>Release</code> 发布环境为例</p><ul><li>配置打包环境 <code>Release</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031812947.png"></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031812648.png"></p><ul><li>Show in Finder -&gt; 显示包内容，找到 <code>dSYM文件</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090652388.png"></p><ul><li>最后，在桌面或任意位置，新建一个文件夹如 <code>appdSYM</code> ，将 <code>xxx.app.dSYM</code> 拷贝进来</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031739055.png"></p><p>至此，获取 <code>dSYM文件</code> 完成</p><h1 id="工具手动上传符号表"><a href="#工具手动上传符号表" class="headerlink" title="工具手动上传符号表"></a>工具手动上传符号表</h1><ul><li>下载 <code>Bugly</code>  iOS <a href="https://bugly.qq.com/v2/downloads">符号表</a> 上传工具，如下图：</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031923224.png"></p><ul><li>我们需要用到的是 <code>buglySymboliOS.jar</code> 文件，单独放在一个新建的空文件夹如 <code>buglySymboliOS</code> 里面</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031813454.png"></p><ul><li>下载后得到 <code>buglyqq-upload-symbol</code> 文件，解压里面 <code>jar包</code>，得到 <code>buglySymboliOS.jar 包</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090659864.png"></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090700741.png"></p><ul><li>通过终端命令行上传</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar buglyqq-upload-symbol.jar -appid c4f4e4dc67 -appkey cb791b15-dbe1-44d9-bd33-b3fe558b773b -bundleid cn.epod.srsf -version 1.6.2 -platform IOS -inputSymbol /Users/mac/Desktop/appdSYM/中图云书房.app.dSYM</span><br></pre></td></tr></table></figure><p>【参数说明】：</p><p>-addid ：在 bugly 上对应的 appid     c4f4e4dc67<br>-appkey ：在 bugly 上对应的 appkey<br>-bundleid ： iOS平台的 bundle id    cn.epod.srsf<br>-version ：版本号  1.6.2<br>-platform ：平台（注意大小写）IOS Android<br>-inputSymbol ：dSYM调试文件 &#x2F;Users&#x2F;mac&#x2F;Desktop&#x2F;appdSYM&#x2F;中图云书房.app.dSYM</p><h1 id="项目中使用"><a href="#项目中使用" class="headerlink" title="项目中使用"></a>项目中使用</h1><ul><li>项目需要集成cocoapods三方依赖管理工具，用cocoapods集成 <code>Bugly</code> SDK</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#x27;9.0&#x27;</span><br><span class="line"></span><br><span class="line"># 忽略所有警告</span><br><span class="line">inhibit_all_warnings!</span><br><span class="line"></span><br><span class="line">target &#x27;SRSF&#x27; do</span><br><span class="line">  # Comment the next line if you don&#x27;t want to use dynamic frameworks</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  # Pods for SRSF</span><br><span class="line">  # 官方提示：三方动态库最好最多是6个</span><br><span class="line">  </span><br><span class="line">  # Bugly</span><br><span class="line">  pod &#x27;Bugly&#x27;</span><br><span class="line">  </span><br><span class="line">  target &#x27;SRSFTests&#x27; do</span><br><span class="line">    inherit! :search_paths</span><br><span class="line">    # Pods for testing</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  target &#x27;SRSFUITests&#x27; do</span><br><span class="line">    # Pods for testing</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -Bugly</span><br><span class="line">- (void)startBugly&#123;</span><br><span class="line">    BuglyConfig * config = [[BuglyConfig alloc] init];</span><br><span class="line">    config.debugMode = YES; // Debug信息开关</span><br><span class="line">    config.reportLogLevel = BuglyLogLevelWarn; // 设置为BuglyLogLevelWarn，则在崩溃时会上报Warn、Error接口打印的日志</span><br><span class="line">    [Bugly startWithAppId:@&quot;AppId&quot; config:config];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-三方框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能优化02：卡顿检测</title>
      <link href="/BboyZJ.github.io/2023/03/02/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602%EF%BC%9A%E5%8D%A1%E9%A1%BF%E6%A3%80%E6%B5%8B%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
      <url>/BboyZJ.github.io/2023/03/02/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602%EF%BC%9A%E5%8D%A1%E9%A1%BF%E6%A3%80%E6%B5%8B%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能优化01：内存泄漏检测</title>
      <link href="/BboyZJ.github.io/2023/03/02/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
      <url>/BboyZJ.github.io/2023/03/02/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习03：内存管理</title>
      <link href="/BboyZJ.github.io/2023/03/02/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A003%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/BboyZJ.github.io/2023/03/02/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A003%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要介绍 <code>内存的五大区</code> 、<code>函数栈</code> 和 <code>内存管理</code></p><h1 id="内存五大区"><a href="#内存五大区" class="headerlink" title="内存五大区"></a>内存五大区</h1><p>在iOS中，内存主要分为 <code>栈区、堆区、全局区、常量区、代码区</code> 五个区域，如下图所示：</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021853105.png"></p><h2 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h2><p><strong>定义</strong></p><ul><li><p>栈是 <code>系统数据结构</code>，其对应的 <code>进程或者线程是唯一的</code></p></li><li><p>栈是 <code>向低地址扩展</code> 的数据结构</p></li><li><p>栈是一块 <code>连续的内存区域</code>，遵循 <code>先进后出（FILO）</code> 原则</p></li><li><p>栈区一般在 <code>运行时</code> 分配</p></li></ul><p><strong>存储</strong></p><p>栈区是由 <code>编译器自动分配并释放</code>的，主要用来存储</p><ul><li><p><code>局部变量</code></p></li><li><p><code>函数的参数</code>，例如函数的隐藏参数（id self, SEL _cmd）</p></li></ul><p><strong>优缺点</strong></p><ul><li><p>优点：因为栈是由 <code>编译器自动分配并释放</code> 的，不会产生内存碎片，所以 <code>快速高效</code></p></li><li><p>确定：栈的 <code>内存大小有限制，数据不灵活</code></p><ul><li><code>iOS主线程大小是1MB</code></li><li>其他线程是 <code>512KB</code></li><li><code>MAC</code> 只有 <code>8MB</code></li></ul></li></ul><p>以上内存大小的说明，在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW7">Threading Programming Guide</a>中有相关说明，如下图：</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021857274.png"></p><h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><p><strong>定义</strong></p><ul><li><p>堆是 <code>向高地址扩展</code> 的数据结构</p></li><li><p>堆是 <code>不连续的内存区域</code>，类似于 <code>链表结构</code>（便于增删，不便于查询），遵循 <code>先进先出（FIFO）</code>原则</p></li><li><p>堆的 <code>地址空间</code> 在iOS中是是动态的</p></li><li><p>堆区的分配一般是以在 <code>运行时分配</code></p></li></ul><p><strong>存储</strong></p><p>堆区是 <code>由程序员动态分配和释放</code> 的，如果程序员不释放，程序结束后，可能由操作系统回收，主要用于存放：</p><ul><li><p><code>OC</code> 中使用 <code>alloc</code> 、 <code>new</code> 开辟空间创建 <code>对象</code> ，或者 <code>block经过copy后</code> </p></li><li><p><code>C</code> 语言中使用 <code>malloc、calloc、realloc</code> 分配的空间，需要 <code>free</code> 释放</p></li><li><p>一般一个 <code>new/alloc</code> 就要对应一个 <code>release</code>，在 <code>ARC</code> 下编译器会自动在合适位置为 <code>OC</code> 对象添加 <code>release</code> 操作，会在当前 <code>线程Runloop退出或休眠时销毁这些对象</code>。<code>MRC</code> 则需程序员手动释放。</p></li></ul><p><strong>优缺点</strong></p><ul><li><p>优点：灵活方便，数据适应面广泛</p></li><li><p>缺点：需 <code>手动管理、速度慢</code>，容易产生内存碎片</p></li></ul><p>当需要访问堆中数据时，一般需要 <code>先通过对象读取到栈区的指针地址</code>，然后通过 <code>指针地址访问堆区</code></p><h2 id="全局区（静态区，即-bss-amp-data）"><a href="#全局区（静态区，即-bss-amp-data）" class="headerlink" title="全局区（静态区，即.bss &amp; .data）"></a>全局区（静态区，即.bss &amp; .data）</h2><p>全局区是 <code>编译时分配</code> 的内存空间，在程序运行过程中，此内存中的数据一直存在，<code>程序结束后由系统释放</code>，主要存放：</p><ul><li><p><code>未初始化的全局变量和静态变量</code>，即BSS区（.bss）</p></li><li><p><code>已初始化的全局变量和静态变量</code>，即DATA区（.data）</p></li></ul><p>其中，<code>全局变量</code> 是指变量值可以在 <code>运行时被动态修改</code>，而 <code>静态变量</code> 是 <code>static</code> 修饰的变量，包含 <code>静态局部变量</code> 和 <code>静态全局变量</code></p><h2 id="常量区（即-rodata）"><a href="#常量区（即-rodata）" class="headerlink" title="常量区（即.rodata）"></a>常量区（即.rodata）</h2><p>常量区是 <code>编译时分配</code> 的内存空间，在 <code>程序结束后由系统释放</code>，主要存放：</p><ul><li>已经使用了的，且没有指向的 <code>字符串常量</code></li></ul><p>字符串常量因为可能在程序中被多次使用，所以在程序运行之前就会提前分配内存</p><h2 id="代码区（即-text）"><a href="#代码区（即-text）" class="headerlink" title="代码区（即.text）"></a>代码区（即.text）</h2><p>代码区是 <code>由编译时分配</code>，主要用于存放 <code>程序运行时的代码</code>，代码会被编译成 <code>二进制存进内存</code> 的</p><h2 id="内存五大区验证"><a href="#内存五大区验证" class="headerlink" title="内存五大区验证"></a>内存五大区验证</h2><p>运行下面的一段代码，看看变量在内存中是如何分配的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a = 10; // 全局区（已初始化的全局变量）</span><br><span class="line">char * b; // 全局区(未初始化的全局变量)</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    NSInteger i = 123; // 栈区（局部变量）</span><br><span class="line">    NSLog(@&quot;i的内存地址：%p&quot;, &amp;i);</span><br><span class="line">    </span><br><span class="line">    NSString *string = @&quot;ZJ&quot;; // 常量区（字符串常量）</span><br><span class="line">    NSLog(@&quot;string的内存地址：%p&quot;, string);</span><br><span class="line">    NSLog(@&quot;&amp;string的内存地址：%p&quot;, &amp;string);</span><br><span class="line">    </span><br><span class="line">    NSObject *obj = [[NSObject alloc] init]; // 堆区（alloc对象）</span><br><span class="line">    NSLog(@&quot;obj的内存地址：%p&quot;, obj);</span><br><span class="line">    NSLog(@&quot;&amp;obj的内存地址：%p&quot;, &amp;obj);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2022-03-11 14:34:25.438913+0800 内存五大区[70321:4340509] i的内存地址：0x16f6f5a18</span><br><span class="line">2022-03-11 14:34:25.438976+0800 内存五大区[70321:4340509] string的内存地址：0x100710098</span><br><span class="line">2022-03-11 14:34:25.438997+0800 内存五大区[70321:4340509] &amp;string的内存地址：0x16f6f5a10</span><br><span class="line">2022-03-11 14:34:25.439014+0800 内存五大区[70321:4340509] obj的内存地址：0x280fa0bc0</span><br><span class="line">2022-03-11 14:34:25.439031+0800 内存五大区[70321:4340509] &amp;obj的内存地址：0x16f6f5a08</span><br></pre></td></tr></table></figure><ul><li><p>对于 <code>局部变量i</code>， 存放在栈区</p></li><li><p>对于 <code>字符串对象string</code>，分别打印了 <code>string得对象地址</code> 和 <code>string对象的指针地址</code></p><ul><li>string的 <code>对象地址</code> 是是存放在 <code>常量区</code></li><li>string <code>对象的指针地址</code>，是存放在 <code>栈区</code></li></ul></li><li><p>对于 <code>alloc创建的对象obj</code>，分别打印了 <code>obj得对象地址</code> 和 <code>obj对象的指针地址</code></p><ul><li>obj的 <code>对象地址</code> 是存放在 <code>堆区</code> </li><li>obj <code>对象的指针地址</code> 是存放在 <code>栈区</code></li></ul></li></ul><h1 id="函数栈"><a href="#函数栈" class="headerlink" title="函数栈"></a>函数栈</h1><ul><li><p><code>函数栈</code> 又称为 <code>栈区</code>，在内存中从高地址往低地址分配，与堆区相对，具体图示请看上面</p></li><li><p><code>栈帧</code> 是指 <code>函数（运行中且未完成）占用的一块独立的连续内存区域</code></p></li><li><p>应用中新创建的 <code>每个线程都有专用的栈空间</code>，栈可以在线程期间自由使用，而线程中有千千万万的函数调用，这些函数 <code>共享</code> 进程的这个 <code>栈空间</code>。<code>每个函数所使用的栈空间是一个栈帧，所有栈帧就组成了这个线程完成的栈</code></p></li><li><p><code>函数调用是发生在栈上</code> 的，每个 <code>函数的相关信息</code>（例如局部变量、调用记录等）都 <code>存储在一个栈帧</code> 中，每执行一次 <code>函数调用</code>，就会生成一个与其相关的栈帧，然后将其 <code>栈帧压入函数栈</code>，而当函数 <code>执行结束</code>，则将此函数对应的 <code>栈帧出栈并释放掉</code></p></li></ul><p>如下图所示，是经典图- <code>ARM的栈帧布局方式</code></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021911717.png"></p><ul><li><p>其中 <code>main stack frame</code> 为调用函数的栈帧</p></li><li><p><code>func1 stack frame</code> 为当前 <code>当前函数（被调用者）的栈帧</code></p></li><li><p><code>栈底</code> 在 <code>高</code> 地址，栈向下增长</p></li><li><p><code>FP</code> 就是 <code>栈基址</code>，它指向函数的 <code>栈帧起始地址</code></p></li><li><p><code>SP</code> 则是函数的 <code>栈指针</code>，它指向 <code>栈顶</code> 的位置</p></li><li><p><code>ARM压栈</code> 的 <code>顺序</code> 很是规则（也比较容易被黑客攻破），依次为 <code>当前函数指针PC</code>、<code>返回指针LR</code>、<code>栈指针SP</code>、<code>栈基址FP</code>、<code>传入参数个数及指针</code>、<code>本地变量</code> 和 <code>临时变量</code>。如果函数准备调用另一个函数，跳转之前临时变量区先要保存另一个函数的参数</p></li><li><p><code>ARM</code> 也可以 <code>用栈基址和栈指针明确标示栈帧的位置</code>，栈指针SP一直移动，ARM的特点是，<code>两个栈空间内的地址（SP+FP）前面，必然有两个代码地址（PC+LP）明确标示着调用函数位置内的某个地址</code></p></li></ul><h2 id="堆栈溢出"><a href="#堆栈溢出" class="headerlink" title="堆栈溢出"></a>堆栈溢出</h2><p>一般情况下应用程序是不需要考虑堆和栈的大小的，但是事实上堆和栈不是无上限的，<code>过多的递归会导致栈溢出</code>，<code>过多的alloc变量会导致堆溢出</code></p><p>所以 <code>预防堆栈溢出</code> 的方法：</p><ul><li><p><code>避免层次过深</code> 的 <code>递归</code> 调用</p></li><li><p><code>不要使用过多的局部变量</code>，控制局部变量的大小</p></li><li><p><code>避免分配</code> 占用空间 <code>太大的对象</code>，并 <code>及时释放</code></p></li><li><p>实在不行，适当的情景下 <code>调用系统API修改线程的堆栈大小</code></p></li></ul><h2 id="栈帧示例"><a href="#栈帧示例" class="headerlink" title="栈帧示例"></a>栈帧示例</h2><p>描述下面代码的栈帧变化</p><p>栈帧程序示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int Add(int x,int y) &#123;</span><br><span class="line">    int z = 0;</span><br><span class="line">    z = x + y;</span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    int ret = Add(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行时，栈区中栈帧的变化如下图所示：</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021912743.png"></p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>在iOS中开发中，我们或多或少都听说过内存管理。iOS的内存管理一般指的是OC对象的内存管理，因为OC对象分配在堆内存，堆内存需要程序员自己去动态分配和回收；基础数据类型(非OC对象)则分配在栈内存中，超过作用域就会由系统检测回收。如果我们在开发过程中，对内存管理得不到位，就有可能造成内存泄露。</p></li><li><p>我们通常讲的内存管理，实际上从发展的角度来说，分为两个阶段：<code>MRC和ARC</code>。</p><ul><li><p>MRC指的是 <code>手动内存管理</code>，在开发过程中需要开发者手动去编写内存管理的代码；</p></li><li><p>ARC指的是 <code>自动内存管理</code>，在此内存管理模式下由LLVM编译器和OC运行时库生成相应内存管理的代码。</p></li></ul></li></ul><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><ul><li><p>在 <code>OC</code> 中，使用 <code>引用计数</code> 来 <code>进行内存管理</code>。</p></li><li><p>每个对象都有一个与其相对应的引用计数器，当持有一个对象，这个对象的引用计数就会递增；当这个对象的某个持有被释放，这个对象的引用计数就会递减。当这个对象的引用计数变为0，那么这个对象就会被系统回收。</p></li><li><p>当一个对象使用完没有释放，此时其引用计数永远大于1。该对象就会一直占用其分配在堆内存的空间，就会导致内存泄露。内存泄露到一定程度有可能导致内存溢出，进而导致程序崩溃。</p></li></ul><h2 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h2><ol><li>简介</li></ol><p>全称 Manual Reference Counting，管理通过使用 <code>retain, release</code>, 以及 <code>autorelease</code> 的消息发送来实现。</p><ul><li>retain: 持有（拥有）对象，对象引用数加 1</li><li>release: 释放对象，对象引用数减 1</li><li>autorelease: 通知系统，在 <code>@autoreleasepool</code> 代码块结束时，对对象调用 <code>release</code></li></ul><ol start="2"><li>管理原则</li></ol><ul><li>自己创建的对象，自己获得拥有权</li></ul><p>在苹果规定中，使用 <code>alloc/new/copy/mutableCopy</code> 创建返回的对象归调用者所有，例如以下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* NSMutableArray类对象A */</span><br><span class="line">NSMutableArray *array = [[NSMutableArray alloc] init];    </span><br><span class="line">NSLog(@&quot;%p&quot;, array);</span><br><span class="line">[array release]; // 释放</span><br></pre></td></tr></table></figure><p>由于对象 <code>A</code> 由 <code>alloc</code> 生成，符合苹果规定，<code>指针变量array指向并持有对象A</code>，引用计数器会加 1。另外，array在使用完对象A后需要对其进行释放。当调用release后，释放了其对对象A的引用，计数器减1。对象A此时引用计数值为零，所以对象A被回收。不能访问已经被回收的对象，会发生崩溃。</p><ul><li>别人创建的对象，可以通过 <code>retain</code> 来获得拥有权</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 例如已有 fooArray, 通过 array 方法获得其引用</span><br><span class="line">NSArray *bar = [fooArray array];</span><br><span class="line"></span><br><span class="line">// 不可以直接调用 release，因为没有拥有权</span><br><span class="line">// [bar release];</span><br><span class="line"></span><br><span class="line">// 需要先 retain 来获得拥有权，然后才能释放</span><br><span class="line">[bar retain];</span><br><span class="line">[bar release];</span><br></pre></td></tr></table></figure><ul><li><p>你所拥有的对象不再需要使用时，必须将其释放</p></li><li><p>不能释放你不拥有的对象</p></li></ul><ol start="3"><li>retain</li></ol><ul><li>retain和属性</li></ul><p>我们可以通过属性来保存对象，如果一个属性为强引用，我们就可以通过属性的实例变量和存取方法来对某个对象进行操作，例如某个属性的setter方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)setPerson:(Person *)person &#123;</span><br><span class="line"></span><br><span class="line">    [person retain];</span><br><span class="line">    </span><br><span class="line">    [_person release];</span><br><span class="line">    </span><br><span class="line">    _person = person;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们通过 <code>retain新值</code>，<code>release旧值</code>，再给实例变量更新值。</p><p>需要注意的一点是：需要先retain新值，再release旧值。因为如果新旧值是同一个对象的话，先release就有可能导致该对象被系统回收，再去retain就没有任何意义了。例如下面这个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong)Person *person;</span><br><span class="line">@end</span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">  </span><br><span class="line">    // 实例变量持有Person类对象(P对象)。这样赋值不会调用set方法</span><br><span class="line">    _person = [[Person alloc] init];</span><br><span class="line">    </span><br><span class="line">    // 调用set方法</span><br><span class="line">    self.person = _person;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setPerson:(Person *)person &#123;</span><br><span class="line">    // release释放对P对象的引用，P对象引用计数值变为零，则P对象被系统回收</span><br><span class="line">    [_person release];</span><br><span class="line"></span><br><span class="line">    // 由于P对象已经被回收，再去retain就容易出问题</span><br><span class="line">    [person retain];</span><br><span class="line">    </span><br><span class="line">    _person = person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于P对象被回收，对应其所分配的内存被置于 <code>可用内存池</code> 中。如果该内存未被覆写，那么P对象依然有效；如果内存被覆写，那么实例变量_person就会指向一个被覆写的未知对象的指针，那么实例变量就变成一个 <code>悬挂指针</code>。</p><ul><li>retain和数组</li></ul><p>如果我们把一个对象加入到一个数组中，那么该数组的addObject方法会对该对象调用retain方法。例如以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// person获得并持有P对象，P对象引用计数为1</span><br><span class="line">Person *person = [[Person alloc] init]; // Person类对象生成的P对象</span><br><span class="line">    </span><br><span class="line">NSMutableArray *array = [NSMutableArray array];</span><br><span class="line">    </span><br><span class="line">// person被加入到数组，对象P引用计数值为2</span><br><span class="line">[array addObject:person];</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>此时，对象P被person和array两个变量同时持有。</p><ol start="4"><li>release</li></ol><ul><li>自己持有的对象自己释放</li></ul><p>当我们持有一个对象，如果在不需要继续使用该对象，我们需要对其进行释放(release)。例如以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// array获得并持有NSArray类对象</span><br><span class="line">NSArray *array = [[NSArray alloc] init];</span><br><span class="line">    </span><br><span class="line">// 当不再需要使用该对象时，需要释放</span><br><span class="line">[array release];</span><br><span class="line">    </span><br><span class="line">// obj获得但不持有该对象</span><br><span class="line">id obj = [NSArray array];</span><br></pre></td></tr></table></figure><ul><li>非自己持有的对象不要释放</li></ul><p>当我们不持有某个对象，却对该对象进行释放，应用程序就会崩溃。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获得并持有A对象</span><br><span class="line">Person *p = [[Person alloc] init]; // Person类对象A</span><br><span class="line">    </span><br><span class="line">// 对象A引用计数为零，所以对象A被回收</span><br><span class="line">[p release];</span><br><span class="line"></span><br><span class="line">// 释放非自己持有的对象</span><br><span class="line">[p release];</span><br></pre></td></tr></table></figure><p>另外，我们也不能访问某个已经被释放的对象，该对象所占的堆空间如果被覆写就会发生崩溃的情况。</p><ol start="5"><li>autorelease</li></ol><p><code>autorelease</code> 指的是自动释放，当一个对象收到 <code>autorelease</code> 的时候，该 <code>对象就会被注册到当前处于栈顶的自动释放池（autorelease pool）</code>。如果没有主动生成自动释放池，则当前自动释放池对应的是主运行循环的自动释放池。在当前线程的RunLoop进入休眠前，就会对被注册到该自动释放池的所有对象进行一次release操作。</p><p>autorelease和release的区别是：</p><ul><li><p>release：是马上释放对某个对象的强引用；</p></li><li><p>autorelease：是延迟释放某个对象的生命周期。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 外部调用</span><br><span class="line">    Person *p = [Person person];</span><br><span class="line">    NSLog(@&quot;%p&quot;, p); //使用无须retain</span><br><span class="line"></span><br><span class="line">    // 持有则需要retain</span><br><span class="line">    [p retain];</span><br><span class="line">    _person = p;</span><br><span class="line">    [_person release];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Person类内部定义</span><br><span class="line">+ (id)person &#123;</span><br><span class="line"></span><br><span class="line">    //创建的Person类对象由person获得并持有</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">   </span><br><span class="line">    // [person release];</span><br><span class="line"></span><br><span class="line">    // 将 person 对象放入自动释放池</span><br><span class="line">    [person autorelease];</span><br><span class="line">    </span><br><span class="line">    return person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在外部调用，从方法名person知道，创建的对象由p指针变量获得但不持有。在函数内部，person获得并持有了Person类对象，所返回的person对象的引用计数加1。换句话说，调用者需要额外处理这多出来的一个持有操作。另外，我们不能在函数内部调用release，不然对象还没返回就已经被系统回收。这时候使用autorelease就能很好地解决这个问题。</p><p>只要把要返回的对象调用autorelease方法，注册到自动释放池就能延长person对象的生命周期，使其在 autorelease pool销毁(drain)前依然能够存活。</p><p>另外，person对象在返回时调用了 <code>autorelease方法</code>。该对象已经在自动释放池中，我们可以直接使用对象p，无须再通过[p retain]访问；不过，如果要用实例变量持有该对象，则需要对变量p进行一次retain操作，实例变量使用完该对象需要释放该对象。</p><ol start="6"><li>autorelease pool</li></ol><ul><li><code>autorelease pool</code> 和 <code>RunLoop(运行循环)</code></li></ul><p>当应用程序启动，系统默认会 <code>开启一条线程</code>，该线程就是 <code>主线程</code>。主线程也有一个与之对应的自动释放池。</p><p><code>每条线程都包含一个与其对应的自动释放池</code>，当某条线程被终止的时候，对应该线程的自动释放池会被销毁。同时，处于该自动释放池的对象将会进行一次 <code>release</code> 操作。</p><p>，例如我们常见的 <code>ARC</code> 下的 <code>main.h</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该自动释放池用来释放在主线程下注册到该自动释放池的对象。</p><p>需要注意的是，当我们 <code>开启一条子线程</code>，并且在该线程 <code>开启RunLoop</code> 的时候，需要为其增加一个<code>autorelease pool</code>，这样有助于保证内存的安全。</p><ul><li>autorelease pool和降低内存峰值</li></ul><p>当我们执行一些复杂的操作，特别是如果这些复杂的操作要被循环执行，那么中间会免不了会产生一些临时变量。当被加到主线程自动释放池的对象越来越来多，却没有得到及时释放，就会导致内存溢出。这个时候，我们可以手动添加自动释放池来解决这个问题。如以下例子所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; largeNumber; i++) &#123;</span><br><span class="line">        </span><br><span class="line">    // 创建自动释放池</span><br><span class="line">    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">    </span><br><span class="line">    // 产生许多被注册到自动释放池的临时对象</span><br><span class="line">    id obj = [Person personWithComplexOperation];</span><br><span class="line">    </span><br><span class="line">    // 释放池中对象</span><br><span class="line">    [pool drain];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述例子所示，我们执行的循环次数是一个非常大的数字。并且调用personWithComplexOperation方法的过程中会产生许多临时对象，所产生的临时对象有可能会被注册到自动释放池中。我们通过手动生成一个自动释放池，并且在每次循环结束前把该自动释放池的对象执行release操作释放掉，这样就能有效地降低内存的峰值了。</p><h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><ol><li>概述</li></ol><ul><li><p>Automatic Reference Counting，<code>自动引用计数</code>，即 <code>ARC</code>，<code>WWDC2011</code> 和 <code>iOS5</code> 所引入的最大的变革和最激动人心的变化。ARC是新的LLVM 3.0编译器的一项特性，使用ARC，可以说举解决了广大iOS开发者所憎恨的手动内存管理的麻烦。</p></li><li><p>此处的 <code>A</code> 就是 <code>automatic</code>。其实 <code>ARC</code> 只是比 <code>MRC</code> 多了一步，就是在 <code>编译时编译器自动帮开发者添加 retain, release 以及 autorelease 的调用</code>，底层的内存管理机制还是和 <code>MRC</code> 一样。</p></li><li><p>在 <code>ARC</code> 模式下，我们通常在对象变量的声明里用 <code>属性标记符</code> 来指引 <code>ARC</code> 机制来管理我们的对象变量，它们是：<code>strong, retain, weak, copy, assign</code>。默认标记是 <code>strong</code></p></li></ul><ol start="2"><li>标记符的区别</li></ol><ul><li>strong: 顾名思义，就是 <code>强引用</code>，对应 <code>MRC</code> 下的 <code>retain</code>，即引用数加 1</li><li>retain: 同 <code>strong</code></li><li>weak: 弱引用，不增加引用数，引用的对象被释放后变为 <code>nil</code></li><li>copy: 对对象进行 <code>copy</code> 后再赋值，因此对象必须遵循 <code>NSCopying</code> 协议。如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property(copy)Foo *foo;</span><br><span class="line">...</span><br><span class="line">self.foo = bar;  // 相当于 self.foo = [bar copy];</span><br></pre></td></tr></table></figure><ul><li>assign: 一般用于原始数据类型（primitive type）的赋值。可以用于对象，效果相当于 weak，可是有一个坑是当对象被释放后，assign 属性的变量不会变成 nil，而是成为 <code>野指针</code>（dangling pointer），因此不建议使用在对象上。</li></ul><p>借助以上的属性标记符，我们可以在对象声明的时候集中制定它们的内存管理策略，清晰明了。</p><ol start="3"><li>ARC的判断原则</li></ol><p>ARC判断一个对象是否需要释放不是通过引用计数来进行判断的，而是通过强指针来进行判断的。那么什么是强指针?</p><ul><li><p>强指针</p><ul><li>默认所有对象的指针变量都是强指针</li><li>被__strong修饰的指针</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *p1 = [[Person alloc] init];</span><br><span class="line">__strong  Person *p2 = [[Person alloc] init];</span><br></pre></td></tr></table></figure><ul><li><p>弱指针</p><ul><li>被 <code>__weak</code> 修饰的指针</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak  Person *p = [[Person alloc] init];</span><br></pre></td></tr></table></figure><p><strong>ARC如何通过强指针来判断？</strong></p><ul><li>只要还有一个强指针变量指向对象，对象就会保持在内存中</li></ul><ol start="4"><li>ARC的使用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // 不用写release, main函数执行完毕后p会被自动释放</span><br><span class="line">    Person *p = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>ARC的注意点</li></ol><ul><li>不允许调用对象的 <code>release方法</code></li><li>不允许调用 <code>autorelease方法</code></li><li>重写父类的dealloc方法时，不能再调用 <code>[super dealloc]</code>;</li></ul><ol start="6"><li>ARC下单对象内存管理</li></ol><ul><li>局部变量释放对象随之被释放</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">    &#125; // 执行到这一行局部变量p释放</span><br><span class="line">    // 由于没有强指针指向对象, 所以对象也释放</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>清空指针对象随之被释放</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">        p = nil; // 执行到这一行, 由于没有强指针指向对象, 所以对象被释放</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>默认清空所有指针都是强指针</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">        // p1和p2都是强指针</span><br><span class="line">        Person *p1 = [[Person alloc] init];</span><br><span class="line">        __strong Person *p2 = [[Person alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>弱指针需要明确说明</p><ul><li>注意: 千万不要使用弱指针保存新创建的对象</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">   @autoreleasepool &#123;</span><br><span class="line">        // p是弱指针, 对象会被立即释放</span><br><span class="line">        __weak Person *p1 = [[Person alloc] init];</span><br><span class="line">        NSLog(@&quot;%@&quot;,p);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-07-31 18:02:51.021697+0800 iOS-OC之ARC[2134:984503] (null)</span><br></pre></td></tr></table></figure><ol start="7"><li>ARC下多对象内存管理</li></ol><p>ARC和MRC一样, 想拥有某个对象必须用强指针保存对象, 但是不需要在dealloc方法中release</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">// MRC写法</span><br><span class="line">//@property (nonatomic, retain) Dog *dog;</span><br><span class="line"></span><br><span class="line">// ARC写法</span><br><span class="line">@property (nonatomic, strong) Dog *dog;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h2><ol><li>概述</li></ol><ul><li><p><code>AutoreleasePool</code>（自动释放池）是 <code>OC</code> 中的一种 <code>内存自动回收机制</code>。</p></li><li><p>当向一个对象发送 <code>autorelease</code> 消息时，会将对象加入到自动释放池，这个对象不会立即释放，而是等到 <code>runloop休眠或超出autoreleasepool作用域</code> 之后进行 <code>释放</code>。</p></li></ul><ol start="2"><li>MRC 下使用自动释放池</li></ol><p>在MRC环境中使用自动释放池需要用到 <code>NSAutoreleasePool</code> 对象，其生命周期就相当于C语言变量的作用域。对于所有调用过 autorelease方法的对象，在废弃NSAutoreleasePool对象时，都将调用release实例方法。用源代码表示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// MRC环境下的测试：</span><br><span class="line">// 第一步：生成并持有释放池NSAutoreleasePool对象;</span><br><span class="line">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line"></span><br><span class="line">// 第二步：调用对象的autorelease实例方法;</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line"></span><br><span class="line">// 第三步：废弃NSAutoreleasePool对象;</span><br><span class="line">[pool drain];   // 向pool管理的所有对象发送消息，相当于[obj release]</span><br><span class="line"></span><br><span class="line">// obj已经释放，再次调用会崩溃(Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT))</span><br><span class="line">NSLog(@&quot;打印obj：%@&quot;, obj); </span><br></pre></td></tr></table></figure><ol start="3"><li><code>ARC</code> 下使用自动释放池</li></ol><p>ARC环境不能使用NSAutoreleasePool类也不能调用autorelease方法，代替它们实现对象自动释放的是 <code>@autoreleasepool块</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ARC环境下的测试：</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">    id obj = [[NSObject alloc] init];</span><br><span class="line">    NSLog(@&quot;打印obj：%@&quot;, obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ARC-下-AutoReleasePool-内部实现"><a href="#ARC-下-AutoReleasePool-内部实现" class="headerlink" title="ARC 下 AutoReleasePool 内部实现"></a>ARC 下 AutoReleasePool 内部实现</h2><h3 id="使用-autoreleasepool"><a href="#使用-autoreleasepool" class="headerlink" title="使用@autoreleasepool{}"></a>使用@autoreleasepool{}</h3><p>我们在main函数中写入自动释放池相关的测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了探究释放池的底层实现，我们在终端使用 clang -rewrite-objc + 文件名命令将上述OC代码转化为 <code>C++</code> 源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */</span><br><span class="line">    &#123;</span><br><span class="line">        __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_d37e0d_mi_0);</span><br><span class="line">     &#125; // 大括号对应释放池的作用域</span><br><span class="line">     </span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在经过编译器 <code>clang</code> 命令转化后，我们看到的所谓的 <code>@autoreleasePool块</code>，其实对应着<br><code>__AtAutoreleasePool的结构体</code>。</p><h3 id="分析结构体-AtAutoreleasePool-的具体实现"><a href="#分析结构体-AtAutoreleasePool-的具体实现" class="headerlink" title="分析结构体 __AtAutoreleasePool 的具体实现"></a>分析结构体 <code>__AtAutoreleasePool</code> 的具体实现</h3><p>在源码中找到 <code>__AtAutoreleasePool结构体</code> 的实现代码，具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);</span><br><span class="line"></span><br><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>__AtAutoreleasePool结构体包含了：<code>构造函数、析构函数和一个对象</code>；</p><p>构造函数内部调用：<code>objc_autoreleasePoolPush()</code> 方法，返回对象<code>atautoreleasepoolobj</code></p><p>析构函数内部调用：<code>objc_autoreleasePoolPop()</code> 方法，传入对象<code>atautoreleasepoolobj</code></p><ul><li>分析main函数中 __autoreleasepool结构体实例的生命周期是这样的：</li></ul><p>__autoreleasepool是一个自动变量，其构造函数是在程序执行到声明这个对象的位置时调用的，而其析构函数则是在程序执行到离开这个对象的作用域时调用。所以，我们可以将上面main函数的代码简化如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123;</span><br><span class="line">        void *atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_kb_06b822gn59df4d1zt99361xw0000gn_T_main_d39a79_mi_0);</span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>objc_autoreleasePoolPush</code> 与 <code>objc_autoreleasePoolPop</code><br>进一步观察自动释放池构造函数与析构函数的实现，其实它们都只是对<br><code>AutoreleasePoolPage</code> 对应静态方法 <code>push</code> 和 <code>pop</code> 的封装：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void *objc_autoreleasePoolPush(void) &#123;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void objc_autoreleasePoolPop(void *ctxt) &#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="理解-AutoreleasePoolPage"><a href="#理解-AutoreleasePoolPage" class="headerlink" title="理解 AutoreleasePoolPage"></a>理解 <code>AutoreleasePoolPage</code></h3><p><code>AutoreleasePoolPage</code> 是一个 <code>C++</code> 中的类，打开Runtime的源码工程，在NSObject.mm文件中可以找到它的定义，摘取其中的关键代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage &#123;</span><br><span class="line">#   define EMPTY_POOL_PLACEHOLDER ((id*)1)  // 空池占位</span><br><span class="line">#   define POOL_BOUNDARY nil                // 即哨兵对象</span><br><span class="line">    static pthread_key_t const key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    static uint8_t const SCRIBBLE = 0xA3;  // 0xA3A3A3A3 after releasing</span><br><span class="line">    static size_t const SIZE = </span><br><span class="line">#if PROTECT_AUTORELEASEPOOL</span><br><span class="line">        PAGE_MAX_SIZE;  // must be multiple of vm page size</span><br><span class="line">#else</span><br><span class="line">        PAGE_MAX_SIZE;  // size and alignment, power of 2</span><br><span class="line">#endif</span><br><span class="line">    static size_t const COUNT = SIZE / sizeof(id);</span><br><span class="line">    magic_t const magic;                  // 校验AutoreleasePagePoolPage结构是否完整</span><br><span class="line">    id *next;                             // 指向新加入的autorelease对象的下一个位置，初始化时指向begin()</span><br><span class="line">    pthread_t const thread;               // 当前所在线程，AutoreleasePool是和线程一一对应的</span><br><span class="line">    AutoreleasePoolPage * const parent;   // 指向父节点page，第一个结点的parent值为nil</span><br><span class="line">    AutoreleasePoolPage *child;           // 指向子节点page，最后一个结点的child值为nil</span><br><span class="line">    uint32_t const depth;                 // 链表深度，节点个数</span><br><span class="line">    uint32_t hiwat;                       // 数据容纳的一个上限</span><br><span class="line">    //......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>AutoreleasePoolPage</code> 中拥有 <code>parent 和 child 指针</code>，分别指向上一个和下一个 <code>page</code>；当前一个page的空间被占满(每个AutorelePoolPage的大小为4096字节)时，就会新建一个AutorelePoolPage对象并连接到链表中，后来的Autorelease对象也会添加到新的page中；<br>另外，当next&#x3D;&#x3D; begin()时，表示AutoreleasePoolPage为空；当next &#x3D;&#x3D; end()，表示AutoreleasePoolPage已满。</p><ul><li>理解 <code>哨兵对象(POOL_BOUNDARY)的作用</code>，而它的作用事实上也就是为了 <code>起到一个标识的作用</code>。</li></ul><p>每当自动释放池初始化调用 <code>objc_autoreleasePoolPush</code> 方法时，总会通过 <code>AutoreleasePoolPage</code> 的 <code>push</code> 方法，将 <code>POOL_BOUNDARY</code> 放到当前 <code>page</code> 的栈顶，并且返回这个对象 <code>atautoreleasepoolobj</code>；</p><p>而在自动释放池释放调用 <code>objc_autoreleasePoolPop</code> 方法时，又会将 <code>atautoreleasepoolobj对象</code> 以参数传入，这样自动释放池就会向释放池中对象发送release消息，直至找到第一个边界对象为止。</p><h3 id="理解-objc-autoreleasePoolPush-方法"><a href="#理解-objc-autoreleasePoolPush-方法" class="headerlink" title="理解 objc_autoreleasePoolPush 方法"></a>理解 <code>objc_autoreleasePoolPush</code> 方法</h3><p>经过前面的分析，<code>objc_autoreleasePoolPush</code> 最终调用的是 <code>AutoreleasePoolPage</code> 的 <code>push</code> 方法，该方法的具体实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static inline void *push() &#123;</span><br><span class="line">   return autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline id *autoreleaseFast(id obj)</span><br><span class="line">&#123;</span><br><span class="line">   AutoreleasePoolPage *page = hotPage();</span><br><span class="line">   if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">       return page-&gt;add(obj);</span><br><span class="line">   &#125; else if (page) &#123;</span><br><span class="line">       return autoreleaseFullPage(obj, page);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">1.        return autoreleaseNoPage(obj);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 压栈操作：将对象加入AutoreleaseNoPage并移动栈顶的指针</span><br><span class="line">id *add(id obj) &#123;</span><br><span class="line">    id *ret = next;</span><br><span class="line">    *next = obj;</span><br><span class="line">    next++;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当前hotPage已满时调用</span><br><span class="line">static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        if (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        else page = new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; while (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当前hotpage不存在时调用</span><br><span class="line">static id *autoreleaseNoPage(id obj) &#123;</span><br><span class="line">    AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line"></span><br><span class="line">    if (obj != POOL_SENTINEL) &#123;</span><br><span class="line">        page-&gt;add(POOL_SENTINEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上述代码，每次调用 <code>push</code> 其实就是 <code>创建一个新的AutoreleasePoolPage</code>，在对应的AutoreleasePoolPage中插入一个 <code>POOL_BOUNDARY</code> ，并且返回插入的 <code>POOL_BOUNDARY</code> 的内存地址。自动释放池最终都会通过 <code>page-&gt;add(obj)</code> 方法 <code>将对象添加到page中</code>，而这一过程被分为三种情况：</p><pre><code>* 当前page存在且不满，调用 `page-&gt;add(obj)` 方法将 `对象` 添加至page的栈中，即next指向的位置* 当前page存在但是已满，调用 autoreleaseFullPage 初始化一个新的 page，调用page-&gt;add(obj)方法将对象添加至page的栈中* 当前page不存在时，调用 autoreleaseNoPage 创建一个 hotPage，再调用page-&gt;add(obj) 方法将对象添加至page的栈中</code></pre><h3 id="理解-objc-autoreleasePoolPop-方法"><a href="#理解-objc-autoreleasePoolPop-方法" class="headerlink" title="理解 objc_autoreleasePoolPop 方法"></a>理解 <code>objc_autoreleasePoolPop</code> 方法</h3><ul><li><p><code>AutoreleasePool</code> 的释放调用的是 <code>objc_autoreleasePoolPop</code> 方法，此时需要传入  <code>atautoreleasepoolobj</code> 对象作为参数。</p></li><li><p>同理，我们找到 <code>objc_autoreleasePoolPop</code> 最终调用的方法，即 <code>AutoreleasePoolPage</code> 的pop方法，该方法的具体实现如下</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static inline void pop(void *token)   // POOL_BOUNDARY的地址</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line"></span><br><span class="line">    page = pageForPointer(token);   // 通过POOL_BOUNDARY找到对应的page</span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    if (DebugPoolAllocation  &amp;&amp;  *stop != POOL_SENTINEL) &#123;</span><br><span class="line">        // This check is not valid with DebugPoolAllocation off</span><br><span class="line">        // after an autorelease with a pool page but no pool in place.</span><br><span class="line">        _objc_fatal(&quot;invalid or prematurely-freed autorelease pool %p; &quot;, </span><br><span class="line">                    token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (PrintPoolHiwat) printHiwat();   // 记录最高水位标记</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);   // 向栈中的对象发送release消息，直到遇到第一个哨兵对象</span><br><span class="line"></span><br><span class="line">    // memory: delete empty children</span><br><span class="line">    // 删除空掉的节点</span><br><span class="line">    if (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        // special case: delete everything during page-per-pool debugging</span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125; else if (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        // special case: delete everything for pop(top) </span><br><span class="line">        // when debugging missing autorelease pools</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125; </span><br><span class="line">    else if (page-&gt;child) &#123;</span><br><span class="line">        // hysteresis: keep one empty child if page is more than half full</span><br><span class="line">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【总结】"><a href="#【总结】" class="headerlink" title="【总结】"></a><strong>【总结】</strong></h3><p>【结构】：</p><ul><li><p>自动释放池的压栈和出栈，通过结构体的构造函数和析构函数实现：</p><ul><li><p>压栈：调用 <code>objc_autoreleasePoolPush()</code> 函数，内部调用的是 <code>AutoreleasePoolPage</code> 的 <code>push()</code> 方法，返回 <code>atautoreleasepoolobj</code> 对象</p></li><li><p>出栈：调用  <code>objc_autoreleasePololPop()</code> 函数，内部调用的是 <code>AutoreleasePoolPage</code> 的 <code>pop()</code> 方法，传入 <code>atautoreleasepoolobj</code> 对象</p></li></ul></li></ul><p>【容量】：</p><ul><li>池页大小为4096字节，每一页都包含56字节的成员变量，但一个自动释放池中，只会压栈一个哨兵对象，占8字节</li></ul><p>【原理】：</p><ul><li><p>自动释放池的本质是 <code>__AtAutoreleasePool</code> 结构体，包含构造函数和析构函数</p></li><li><p>结构体声明，触发构造函数，调用 <code>objc_autoreleasePoolPush()</code> 函数，对象压栈</p><ul><li><p>如果存在page，并且没有存满，调用add函数</p><ul><li>将对象压栈</li></ul></li><li><p>如果存在page，但存储已满，调用autoreleaseFullPage函数</p><ul><li>遍历链表，找到最后一个空白的子页面</li><li>对其进行创建新页</li><li>设置为热页面</li><li>添加对象</li></ul></li><li><p>否则，不存在page，调用autoreleaseNoPage函数</p><ul><li>通过父类AutoreleasePoolPageData进行初始化</li><li>begin：获取对象压栈的起始位置</li><li>objc_thread_self：通过tls获取当前线程</li><li>链接双向链表</li><li>设置为热页面</li><li>pushExtraBoundary为YES，哨兵对象压栈</li><li>对象压栈</li></ul></li></ul></li><li><p>结构体出作用域，触发析构函数，调用 <code>objc_autoreleasePoolPop()</code> 函数，对象出栈</p><ul><li>调用popPage函数，传入stop为哨兵对象的位置</li><li>当前页中对象出栈，到stop位置停止</li><li>调用kill函数，销毁当前页面</li></ul></li></ul><h1 id="AutoreleasePool在主线程上的释放时机"><a href="#AutoreleasePool在主线程上的释放时机" class="headerlink" title="AutoreleasePool在主线程上的释放时机"></a>AutoreleasePool在主线程上的释放时机</h1><ul><li>分析主线程RunLoop管理自动释放池并释放对象的详细过程，我们在如下Demo中的主线程中设置断点，并执行lldb命令：po [NSRunLoop currentRunLoop]，具体效果如下：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/89028090-42d71580-d35e-11ea-8578-2bdf6240de0a.png"></p><p>我们看到主线程RunLoop中有两个与自动释放池相关的Observer,对应CFRunLoopActivity的类型如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),          //0x1，启动Runloop循环</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),            </span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),        </span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),  //0xa0，即将进入休眠     </span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),   </span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),           //0xa0，退出RunLoop循环  </span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>结合RunLoop监听的事件类型，分析主线程上自动释放池的使用过程如下：</p><ul><li><p>App启动后，苹果在主线程RunLoop里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler();</p></li><li><p>第一个Observer监视的事件</p><ul><li><code>Entry(即将进入Loop)</code>，其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。</li></ul></li><li><p>第二个Observer监视了两个事件 :</p><ul><li><p><code>BeforeWaiting(准备进入休眠)</code> 时调用 <code>_objc_autoreleasePoolPop()</code> 和<code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池；</p></li><li><p>Exit(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。</p></li></ul></li><li><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄漏，开发者也不必显示创建AutoreleasePool了;</p></li><li><p>之后的时机</p><ul><li><p>程序启动到加载完成后，主线程对应的RunLoop会停下来等待用户交互</p></li><li><p>用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</p></li><li><p>RunLoop检测到事件后，就会创建自动释放池;</p></li><li><p>所有的延迟释放对象都会被添加到这个池子中;</p></li><li><p>在一次完整的运行循环结束之前，会向池中所有对象发送release消息，然后自动释放池被销毁;</p></li></ul></li></ul><h1 id="AutoreleasePool子线程上的释放时机"><a href="#AutoreleasePool子线程上的释放时机" class="headerlink" title="AutoreleasePool子线程上的释放时机"></a>AutoreleasePool子线程上的释放时机</h1><p>子线程默认不开启RunLoop，那么其中的延时对象该如何释放呢？其实这依然要从Thread和AutoreleasePool的关系来考虑：</p><ul><li><p>就是说，每一个线程都会维护自己的 <code>Autoreleasepool栈</code>，所以子线程虽然默认没有开启RunLoop，但是依然存在AutoreleasePool，在 <code>子线程退出</code> 的时候会去释放autorelease对象。</p></li><li><p>前面讲到过，ARC会根据一些情况进行优化，添加__autoreleasing修饰符，其实这就相当于对需要延时释放的对象调用了autorelease方法。从源码分析的角度来看，如果子线程中没有创建AutoreleasePool ，而一旦产生了Autorelease对象，就会调用autoreleaseNoPage方法自动创建hotpage，并将对象加入到其栈中。所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。</p></li></ul><h1 id="AutoreleasePool需要手动添加的情况"><a href="#AutoreleasePool需要手动添加的情况" class="headerlink" title="AutoreleasePool需要手动添加的情况"></a>AutoreleasePool需要手动添加的情况</h1><ul><li><p>尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建 <code>AutoreleasePool</code>，而其中的延时对象将在当前释放池的作用域结束时释放。苹果文档中说明了三种情况，我们可能会需要手动添加自动释放池：</p><ul><li>编写的不是基于UI框架的程序，例如命令行工具；</li><li>通过循环方式创建大量临时对象；</li><li>使用非Cocoa程序创建的子线程；</li></ul></li></ul><p>而在ARC环境下的实际开发中，我们最常遇到的也是第二种情况，以下面的代码为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    for (int i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">        NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">        NSLog(@&quot;打印obj：%@&quot;, obj);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述代码中，obj因为离开作用域所以会被加入最近一次创建的自动释放池中，而这个释放池就是主线程上的RunLoop管理的；因为for循环在当前线程没有执行完毕，Runloop也就没有完成当前这一次的迭代，所以导致大量对象被延时释放。释放池中的对象将会在viewDidAppear方法执行前就被销毁。在此情况下，我们就有必要通过手动干预的方式及时释放不需要的对象，减少内存消耗；优化的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    for (int i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">        @autoreleasepool&#123;</span><br><span class="line">             NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">             NSLog(@&quot;打印obj：%@&quot;, obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习02：文件导入#include,#import,@class区别</title>
      <link href="/BboyZJ.github.io/2023/03/02/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A002%EF%BC%9A%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5#include,#import,@class%E5%8C%BA%E5%88%AB/"/>
      <url>/BboyZJ.github.io/2023/03/02/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A002%EF%BC%9A%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5#include,#import,@class%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p><code>#include</code> 、 <code>#import</code> 和 <code>@class</code> 都是用来 <code>包含头文件</code></p></li><li><p><code>C/C++</code> 只能用 <code>#include</code> 包含头文件，没有 <code>#import</code> 和 <code>@class</code></p></li><li><p><code>OC</code> 中 <code>#include</code> 、 <code>#import</code> 和 <code>@class</code> 都可以用</p></li></ul><p>那么问题来了，三种包含头文件方式在 <code>OC</code> 中有什么区别呢？</p><h1 id="include、import"><a href="#include、import" class="headerlink" title="include、import"></a>include、import</h1><ul><li><p>#include 会重复导入头文件，重复导入会报重复定义的错误；#import 不会重复导入头文件，允许交叉编译</p></li><li><p>#include &lt;xxx.h&gt; 或 #import &lt;xxx.h&gt; ：用于导入 <code>系统自带文件</code>，在 <code>系统文件目录下查找</code></p></li><li><p>#include “xxx.h” 或 #import “xxx.h” ：用于导入 <code>用户自定义的文件</code>，查找顺序：<code>用户文件目录 -&gt; 安装文件目录 -&gt; 系统文件目录</code>，所以 “xxx.h” 一般用来导入用户自定义的文件</p></li></ul><h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><ul><li>@class XXXClassName ： 用于声明一个类，用于解决互相引用的问题（A引用B，B引用A）</li></ul><h1 id="include-示例"><a href="#include-示例" class="headerlink" title="include 示例"></a>include 示例</h1><ul><li><code>A文件导入两次B文件</code>：报重复定义错误</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">// include 不允许重复导入两次</span><br><span class="line">#include &quot;VB.h&quot;</span><br><span class="line">#include &quot;VB.h&quot;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface VA : UIView</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>command + b 编译报错：</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021812383.png"></p><ul><li>A引用B，B引用C，A再引用C：同样 <code>报重复定义错误</code>，相当于A引用了两次C</li></ul><h1 id="import-示例"><a href="#import-示例" class="headerlink" title="import 示例"></a>import 示例</h1><ul><li>导入两次A文件，不报错</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 导入两次A文件</span><br><span class="line">#import &quot;A.h&quot;</span><br><span class="line">#import &quot;A.h&quot;</span><br></pre></td></tr></table></figure><h1 id="class-使用场景"><a href="#class-使用场景" class="headerlink" title="class 使用场景"></a>class 使用场景</h1><ul><li>A类引用B类，B类引用A：互相引用报错</li></ul><p>A.h文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;B.h&quot;</span><br><span class="line">@interface A : UIView</span><br><span class="line">@property (nonatomic,strong)B * b;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>B.h文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;A.h&quot;</span><br><span class="line">@interface B : UIView</span><br><span class="line">@property (nonatomic,strong)A * a;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021813725.png"></p><ul><li>可以用 <code>@class</code> 方式进行引用，一个用@class或者两个都用 @class</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//#import &quot;A.h&quot;</span><br><span class="line"></span><br><span class="line">// class声明A</span><br><span class="line">@class A;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog-05：Picgo+Gitee图床</title>
      <link href="/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-05%EF%BC%9APicgo-Gitee%E5%9B%BE%E5%BA%8A/"/>
      <url>/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-05%EF%BC%9APicgo-Gitee%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近发现上传到 <code>GitHub</code> 上的图片大部分不能使用了，然后上网查了一下，应该是 DNS 的问题，网上也有很多解决方案，有兴趣的可以去网上找找，本文主要介绍 <code>Picgo + Gitee</code> 做图床。</p><blockquote><p>警告：Gitee 最近不让做图床了，还是赶紧改回去吧，啊啊啊啊啊啊啊！！！！！</p></blockquote><h1 id="Picgo-介绍"><a href="#Picgo-介绍" class="headerlink" title="Picgo 介绍"></a>Picgo 介绍</h1><p><code>picgo</code> 是一款功能实用、操作简捷的图床工具，图床工具简单来说就是本地图片上传自动转换成链接的一款工具。</p><p>picgo 本体支持如下图床：</p><ul><li>七牛图床 v1.0</li><li>腾讯云 COS v4\v5 版本 v1.1 &amp; v1.5.0</li><li>又拍云 v1.2.0</li><li>GitHub v1.5.0</li><li>SM.MS V2 v2.3.0-beta.0</li><li>阿里云 OSS v1.6.0</li><li>Imgur v1.6.0</li></ul><p>Tips: 本体不再增加默认的图床支持。你可以自行开发第三方图床插件。</p><h1 id="特色功能"><a href="#特色功能" class="headerlink" title="特色功能"></a>特色功能</h1><ul><li>支持拖拽图片上传</li><li>支持快捷键上传剪贴板里第一张图片</li><li>Windows 和 macOS 支持右键图片文件通过菜单上传 (v2.1.0+)</li><li>上传图片后自动复制链接到剪贴板</li><li>支持自定义复制到剪贴板的链接格式</li><li>支持修改快捷键，默认快速上传快捷键：command+shift+p（macOS） | control+shift+p（Windows\Linux）</li><li>支持插件系统，已有插件支持 <code>Gitee、青云等第三方图床</code></li></ul><p>Tips:</p><ul><li>请确保你安装了 <code>Node.js</code>， 并且版本 &gt;&#x3D; 8。</li><li>默认上传图床为 <code>SM.MS</code>。<code>picgo</code> 上传之后，会自动将上传成功的 URL复制到你的剪贴板，支持5种复制格式。</li><li>Mini窗口只支持Windows（圆形）和Linux（方形），macOS可以使用顶部栏图标。（因为Windows和Linux的任务栏不支持拖拽事件）</li></ul><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li><code>nodejs</code> 环境</li><li><code>picgo</code> 客户端</li><li><code>picgo</code> 的 <code>Gitee</code> 上传插件</li><li><code>git、Gitee</code> 账号和一个公开仓库</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li><a href="https://nodejs.org/zh-cn/download/">nodejs官网</a> 安装</li></ul><p>点击链接下载安装 nodejs，安装完成后，查看版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % node -v</span><br><span class="line">v18.14.2</span><br><span class="line">mac@bogon ~ % npm -v</span><br><span class="line">mac@bogon ~ % npm -v</span><br><span class="line">9.5.0</span><br></pre></td></tr></table></figure><ul><li>安装 <code>picgo</code> 客户端</li></ul><p><a href="https://github.com/Molunerfinn/picgo/releases">picgo安装链接</a></p><p>如果电脑是 <code>Intel</code> 就选 <code>x64</code>，如果电脑是 <code>M1</code> 就选 <code>arm64</code></p><ul><li>安装 git</li></ul><p>Mac 默认是已经安装好了 git</p><h1 id="注册-x2F-登录-Gitee-账号"><a href="#注册-x2F-登录-Gitee-账号" class="headerlink" title="注册&#x2F;登录 Gitee 账号"></a>注册&#x2F;登录 Gitee 账号</h1><ul><li><p><a href="https://gitee.com/">Gitee</a> 首页按要求自行注册&#x2F;登录即可</p></li><li><p>新建一个 <code>Gitee</code> 仓库</p></li></ul><p>仓库名：随意，如 Picgo<br>私有<br>创建</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150611747.png"></p><ul><li>将仓库 <code>开源</code></li></ul><p>由于创建仓库的时候只能 <code>私有</code>，所以此步配置 <code>开源</code> 操作如下：</p><p>进入仓库 -&gt; 管理 -&gt; 基本信息 -&gt; 开源（空仓库不允许） -&gt; 保存</p><ul><li>生成 Token</li></ul><p><code>Token</code> 用于 <code>picgo</code> 操作 Gitee repository：</p><p>点击头像 -&gt; 设置 -&gt; 私人令牌 -&gt; 生成新令牌 -&gt; 提交</p><p>复制你生成的令牌，只显示一次，再次刷新则看不见了，因此你要保存好</p><h1 id="配置-picgo"><a href="#配置-picgo" class="headerlink" title="配置 picgo"></a>配置 picgo</h1><ul><li>启动 picgo -&gt; 插件设置 -&gt; 搜索 Gitee -&gt; 点击插件图标 <code>安装</code> 即可，本文使用 <code>gitee 2.0.5</code> 插件来进行演示</li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150611845.png"></p><p>Tips： 插件装完后，重启生效</p><h1 id="配置-Gitee-插件"><a href="#配置-Gitee-插件" class="headerlink" title="配置 Gitee 插件"></a>配置 Gitee 插件</h1><p>进入 <code>图床设置</code> -&gt; gitee， 依次填入相关配置如下所示，填写如下：</p><ul><li><p>repo： 用户名&#x2F;仓库名（必填）， <code>bboy-zhang-jian/picgo</code></p></li><li><p>path: 上传路径，仓库里的图片保存路径（非必填）</p></li><li><p>token: 私人令牌（必填），刚才保存的 <code>token</code></p></li><li><p>message: 提交消息（非必填）</p></li><li><p>path: 上传路径，仓库里的图片保存路径（非必填）</p></li><li><p>customPath: 定制路径（非必填）</p></li><li><p>customUrl: 图片定制URL（非必填）</p></li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150612861.png"></p><h1 id="将仓库开源"><a href="#将仓库开源" class="headerlink" title="将仓库开源"></a>将仓库开源</h1><p>头像 -&gt; 仓库 -&gt; 管理 -&gt; 公开 -&gt; 仓库公开须知全部 <code>勾选</code></p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150612053.png"></p><h1 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h1><ul><li>将图片拖动到 <code>上传区</code> 里</li><li>快捷键 <code>Ctrl + shift + p</code></li></ul><h1 id="ERROR-Plugin-load-failed-hexo-renderer-scss"><a href="#ERROR-Plugin-load-failed-hexo-renderer-scss" class="headerlink" title="ERROR Plugin load failed: hexo-renderer-scss"></a>ERROR Plugin load failed: hexo-renderer-scss</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % npm install hexo-renderer-scss</span><br></pre></td></tr></table></figure><h1 id="出现-Error-Cannot-find-module-‘node-sass’"><a href="#出现-Error-Cannot-find-module-‘node-sass’" class="headerlink" title="出现 Error: Cannot find module ‘node-sass’"></a>出现 Error: Cannot find module ‘node-sass’</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % npm install node-sass</span><br></pre></td></tr></table></figure><p>不用管了，版本不一致导致的</p><h1 id="Github层图床"><a href="#Github层图床" class="headerlink" title="Github层图床"></a>Github层图床</h1><ul><li>解决GitHub的raw.githubusercontent.com无法连接问题</li></ul><p>今天访问 <code>http://raw.githubusercontent.com/</code> 时，提示无法访问，可能是因为某些众所周知的原因导致 <code>DNS</code> 污染，最终通过修改 <code>host</code> 解决问题。</p><ul><li>解决方案</li></ul><p>查询真实 IP，通过 [IPAddressIPAddress.comss.com) 查询<br><code>http://raw.githubusercontent.com/</code> 的真<br>实 IP，</p><ul><li><p>可知其真实 <code>IP</code> 为 <code>185.199.108.133</code></p></li><li><p>修改 hosts</p></li></ul><p>CentOS 及 macOS 直接在终端输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/hosts</span><br></pre></td></tr></table></figure><ul><li>编辑 <code>hosts</code> 文件，新增下列内容</li></ul><p>185.199.108.133 raw.githubusercontent.com</p><ul><li>保存即可</li></ul><h1 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h1><p><a href="https://gcore.jsdelivr.net/gh/GitHub%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D">https://gcore.jsdelivr.net/gh/GitHub用户名/仓库名</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>但是由于 <code>GitHub</code> 和 <code>Gitee</code> 图床要不慢，要不不污染严重，最后考虑花点小钱去 <code>阿里云OSS</code> 存储了</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习01：事件传递链和响应链</title>
      <link href="/BboyZJ.github.io/2023/03/01/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/"/>
      <url>/BboyZJ.github.io/2023/03/01/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <code>iOS</code> 中只有继承 <code>UIResponder</code> 的 <code>对象</code> 才能够 <code>接收并处理事件</code>，<code>UIResponder</code> 是所有响应对象的 <code>基类</code>。继承关系如下：</p><ul><li>UIApplication -&gt; UIResponder -&gt; NSObject</li><li>UIViewController -&gt; UIResponder -&gt; NSObject</li><li>UIView -&gt; UIResponder -&gt; NSObject</li><li>UIWindow -&gt; UIViww -&gt; UIResponder -&gt; NSObject</li><li>UIButton -&gt; UIControl -&gt; UIView -&gt; UIResponder -&gt; NSObject</li></ul><h1 id="事件链"><a href="#事件链" class="headerlink" title="事件链"></a>事件链</h1><ul><li><p><code>传递链</code>：由系统向离用户最近的view传递。<br>顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; RootViewController -&gt; subViews</p></li><li><p><code>响应链</code>：由离用户最近的view向系统传递。<br>顺序： superViews –&gt; RootViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate</p></li></ul><h1 id="传递链"><a href="#传递链" class="headerlink" title="传递链"></a>传递链</h1><ul><li>事件传递的两个核心方法</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 返回哪个视图进行事件响应</span><br><span class="line">- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;  </span><br><span class="line">// 判断某一个点击的位置是否在视图范围内</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;</span><br></pre></td></tr></table></figure></div><ul><li><p>其中 <code>UIView</code> 不接受事件处理的情况有</p></li><li><p>hidden &#x3D; YES 视图被隐藏</p></li><li><p>userInteractionEnabled &#x3D; NO 不接受响应事件</p></li><li><p>alpha &lt;&#x3D; 0.01,透明视图不接收响应事件</p></li><li><p>子视图超出父视图范围</p></li><li><p>需响应视图被其他视图盖住</p></li><li><p>是否重写了其父视图以及自身的hitTest方法</p></li><li><p>是否重写了其父视图以及自身的pointInside方法</p></li><li><p>流程描述</p><ul><li>当iOS程序发生触摸事件后，系统会利用 <code>Runloop</code> 将事件加入到 <code>UIApplication</code> 的任务队列中</li><li><code>UIApplication</code> 分发触摸事件到 <code>UIWindow</code></li><li>然后 <code>UIWindow</code> 依次向下分发给 <code>UIView</code></li><li><code>UIView</code> 调用 <code>hitTest:withEvent:</code> 方法返回一个最终响应的视图</li><li>在 <code>hitTest:withEvent:</code> 方法中就会去调用 <code>pointInside: withEvent:</code> 去判断当前点击的 <code>point</code> 是否在 <code>UIView</code> 范围内，如果是的话，就会去 <code>逆序遍历</code> 它的子视图来查找最终响应的 <code>子视图</code></li><li>遍历的方式是使用 <code>倒序</code> 的方式来遍历子视图，也就是说最后添加的子视图会最先遍历，在每一个视图中都会去调用它的 <code>hitTest:withEvent:</code> 方法，可以理解为是一个 <code>递归调用</code></li><li>最终会返回一个响应视图，如果返回视图有值，那么这个视图就作为最终响应视图，结束整个事件传递；如果没有值，那么就会将UIView作为响应者</li></ul></li></ul><h1 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h1><p>响应者链的事件传递过程</p><ul><li>如果 <code>view</code> 的控制器存在，就传递给控制器处理；如果控制器不存在，则传递给它的 <code>父视图</code></li><li>在视图层次结构的最顶层，如果也不能处理收到的事件，则将事件传递给 <code>UIWindow</code> 对象进行处理</li><li>如果 <code>UIWindow</code> 对象也不处理，则将事件传递给 <code>UIApplication</code> 对象</li><li>如果 <code>UIApplication</code> 也不能处理该事件，则将该事件丢弃</li></ul><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ul><li>实现一个按钮的点击范围扩大效果</li></ul><p>思路：自定义一个按钮，重写 <code>poinstInSide</code> 方法，增大内边距，返回一个新的bounds</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJBtn.h&quot;</span><br><span class="line">@implementation ZJBtn</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 当前btn大小</span><br><span class="line">    CGRect btnBounds = self.bounds;</span><br><span class="line">    // 扩大按钮的点击范围，增大内边距</span><br><span class="line">    btnBounds = CGRectInset(btnBounds, -50, -50);</span><br><span class="line">    // 若点击的点在新的bounds里，返回YES</span><br><span class="line">    return CGRectContainsPoint(btnBounds, point);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>子视图超过父视图部分仍然能响应</li></ul><p>思路：正常情况下子视图超出部分是不能响应事件的，需重写 <code>hitTest:withEvent</code> 方法，指定 <code>子视图</code> 可点击</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;VA.h&quot;</span><br><span class="line"></span><br><span class="line">@interface VA ()</span><br><span class="line">@property (nonatomic,strong)UIButton * btn;</span><br><span class="line">@end</span><br><span class="line">@implementation VA</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame&#123;</span><br><span class="line">    self = [super initWithFrame:frame];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        [self addSubview:self.btn];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)clickBtn&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIButton *)btn&#123;</span><br><span class="line">    if (!_btn) &#123;</span><br><span class="line">        _btn = [[UIButton alloc] initWithFrame:CGRectMake(-50, 20, self.frame.size.width + 100, 100)];</span><br><span class="line">        _btn.backgroundColor = [UIColor blueColor];</span><br><span class="line">        [_btn addTarget:self action:@selector(clickBtn) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    &#125;</span><br><span class="line">    return _btn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 子视图超过父视图部分，需要点击超出范围的部分也有相应</span><br><span class="line"> */</span><br><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 判断btn能否接收事件</span><br><span class="line">    if (self.btn.userInteractionEnabled == NO || self.btn.hidden == YES || self.btn.alpha &lt;= 0.01) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 把当前点转换成btn坐标系上的点</span><br><span class="line">    CGPoint btnP = [self convertPoint:point toView:self.btn];</span><br><span class="line">    // 当触摸点在btn上时，才让按钮相应事件</span><br><span class="line">    if ([self.btn pointInside:btnP withEvent:event]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,NSStringFromCGPoint(btnP));</span><br><span class="line">        return self.btn;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;父视图相应&quot;);</span><br><span class="line">    return [super hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS面试题：Swift</title>
      <link href="/BboyZJ.github.io/2023/03/01/%E9%9D%A2%E8%AF%95%E9%A2%98/Swift%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%80%BB%E7%BB%93/"/>
      <url>/BboyZJ.github.io/2023/03/01/%E9%9D%A2%E8%AF%95%E9%A2%98/Swift%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="swift-和-oc-的区别？"><a href="#swift-和-oc-的区别？" class="headerlink" title="swift 和 oc 的区别？"></a>swift 和 oc 的区别？</h1><ul><li><code>swift</code> 是 <code>静态语言</code>，有 <code>类型判断</code>。<code>OC</code> 是 <code>动态语言</code>。</li><li><code>swift</code> 语法简单易读、代码少，清晰、易于维护。</li><li><code>swift</code> 可以面向 <code>函数、协议、对象</code> 编程；<code>OC</code> 以面向 <code>对象</code> 编程为主。</li><li><code>Swift</code> 是 <code>类型安全</code> 的语言。<code>OC</code> 类型不安全的语言。</li><li><code>Swift</code> 大部分都是 <code>值类型</code>，少部分是 <code>引用类型</code>。OC 有的是 <code>值类型</code>，有的是 <code>指针类型</code>。</li></ul><blockquote><p>静态语言：静态类型语言，数据类型是在编译期间检查的语言<br>动态语言：动态类型语言，数据类型是在运行期间检查的语言</p></blockquote><h1 id="Optional是什么？"><a href="#Optional是什么？" class="headerlink" title="Optional是什么？"></a>Optional是什么？</h1><ul><li><p>Object-C 中用 <code>nil</code> 表示 <code>指向不存在对象的指针</code>，其他地方用 <code>NSNotFound</code> 表示 <code>值缺失</code></p></li><li><p>Swift 中用 <code>可选（Optional）类型</code> 表示 <code>值缺失</code>，只有可选类型才能设置为 <code>nil</code></p></li><li><p><code>Optional</code> 含有两种枚举，<code>None</code> 和 <code>Some(T)</code>，用来 <code>表示可能有值或可能没有值</code>。</p></li><li><p>Swift 中只有 <code>Optional</code> 才能设置为 <code>nil</code>，用 <code>?</code> 或 <code>Optional&lt;数据类型&gt;</code></p></li></ul><h1 id="如何使用-Optional？"><a href="#如何使用-Optional？" class="headerlink" title="如何使用 Optional？"></a>如何使用 Optional？</h1><ul><li><p>强制解包：<code>!</code> 或 <code>数据类型 != nil</code></p></li><li><p>可选绑定：if 赋值给常量或变量</p></li><li><p>隐士解包：直接 <code>!</code> 初始化值</p></li></ul><h1 id="swift类型？Swiift-值类型-和-引用类型的区别？特点？"><a href="#swift类型？Swiift-值类型-和-引用类型的区别？特点？" class="headerlink" title="swift类型？Swiift 值类型 和 引用类型的区别？特点？"></a>swift类型？Swiift 值类型 和 引用类型的区别？特点？</h1><ul><li><p>swift的类型分为 <code>值类型</code> 和 <code>引用类型</code>。</p><ul><li><p>值类型：如 <code>struct、enum、Int、Float、Bool、String、Array、Dictionary、String</code> 等都是 <code>值类型</code>。</p></li><li><p>引用类型： 如 <code>class类型、closure闭包、函数</code> 等为 <code>引用类型</code></p></li></ul></li><li><p>区别</p><ul><li><p>值类型：<code>传递和存储</code> 是一个 <code>副本</code>，使用过程中 <code>不会影响源数据</code>，存储在 <code>栈区</code>，访问一次拿到数据</p></li><li><p>引用类型：<code>传递和存储</code> 是 <code>本身（内存地址）</code>，使用过程中会 <code>影响源数据</code>，存储在 <code>堆区</code>，访问两次拿到数据</p></li></ul></li></ul><h1 id="什么是函数？"><a href="#什么是函数？" class="headerlink" title="什么是函数？"></a>什么是函数？</h1><ul><li><p>函数是 <code>一个独立的代码块</code>，由 <code>名字、参数、返回值</code> 组成。</p></li><li><p>函数类型由 <code>形式参数类型和返回类型</code> 决定</p></li><li><p>全局函数和内嵌函数时 <code>特殊的闭包</code></p></li><li><p>函数是 <code>引用类型</code>，存储在堆区</p></li></ul><h1 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h1><p>代码中可以 <code>被传递和引用的功能性独立的代码块</code></p><h1 id="闭包作用？"><a href="#闭包作用？" class="headerlink" title="闭包作用？"></a>闭包作用？</h1><ul><li><p><code>闭包</code> 可以 <code>捕获和存储上下文的常量和变量</code>，<code>闭包</code> 实现上是一个 <code>结构体</code></p></li><li><p><code>闭包</code> 可以作为函数 <code>参数</code>，也可以作为函数的 <code>返回值</code></p></li><li><p>闭包可以像 <code>oc</code> 中用于 <code>回调和反向传值</code></p></li></ul><h1 id="闭包的几种类型？"><a href="#闭包的几种类型？" class="headerlink" title="闭包的几种类型？"></a>闭包的几种类型？</h1><ul><li><p>尾随闭包：<code>闭包作为函数最后一个参数</code></p></li><li><p>逃逸闭包：函数返回之后调用 <code>@escaping</code></p></li><li><p>自动闭包：延迟执行 <code>@autoclosure</code></p></li></ul><h1 id="什么是枚举？oc-与-swift-枚举有啥区别？"><a href="#什么是枚举？oc-与-swift-枚举有啥区别？" class="headerlink" title="什么是枚举？oc 与 swift 枚举有啥区别？"></a>什么是枚举？oc 与 swift 枚举有啥区别？</h1><ul><li><p><code>枚举</code> 是一种 <code>数据类型</code>，只包含自定义的特定数据，<code>值类型</code>，存储在 <code>栈区</code></p></li><li><p><code>OC</code> ，枚举只支持 <code>整数型</code>，很鸡肋</p></li><li><p><code>Swift</code> 中枚举有很多功能：</p><ul><li>可以定义 <code>成员类型、计算属性、类型属性（不能定义存储属性）、方法</code></li><li>可以定义 <code>下标脚本</code> 用于 <code>获取值</code></li><li>可以定义 <code>初始化器</code> 用于 <code>生成初始化值</code></li><li>可以 <code>扩展</code> <code>增加默认实现的功能</code></li><li>可以 <code>遵守协议（protocol）</code> 来 <code>提供标准化功能</code>。</li><li>可以 <code>嵌套枚举、递归枚举</code></li></ul></li></ul><h1 id="什么是类？什么是结构体？"><a href="#什么是类？什么是结构体？" class="headerlink" title="什么是类？什么是结构体？"></a>什么是类？什么是结构体？</h1><p>struct 和 class 都是 <code>构建代码的一种通用且灵活的构造体。</code></p><h1 id="struct-和-class-区别？"><a href="#struct-和-class-区别？" class="headerlink" title="struct 和 class 区别？"></a>struct 和 class 区别？</h1><ul><li><p>struct、class 共同点：</p><ul><li>定义 <code>属性</code> 用于 <code>存储值</code></li><li>定义 <code>方法</code> 用于 <code>提供功能</code></li><li>定义 <code>下标脚本</code> 用于访问值</li><li>定义 <code>初始化器</code> 用于 <code>生成初始化值</code></li><li>通过 <code>扩展</code> 以 <code>增加默认实现的功能</code></li><li>符合 <code>协议</code> 以 <code>提供标准功能</code></li></ul></li><li><p>struct、class 不同点：</p></li><li><p>class 定义 <code>属性</code>，必须赋值或包装成Optional。struct 定义属性不需要要赋值</p></li><li><p>class 是 <code>引用类型</code>，<code>浅拷贝</code>。struct 是 <code>值类型</code>，<code>深拷贝</code>。</p></li><li><p>class <code>可以继承</code>。struct <code>不能继承</code>。</p></li><li><p>class 有 <code>引用计数</code>，可以 <code>多次引用</code>。struct 没有引用计数</p></li><li><p>class 有 <code>类型转换</code>，允许在 <code>运行时检查和解释一个类实例的类型</code>。struct 没有</p></li><li><p>class 有 <code>反初始化器 deinit</code> 用于 <code>释放资源</code> </p></li><li><p>class 分配在 <code>堆</code> 中，动态分配释放内存，struct 分配在 <code>栈</code> 中，系统分配是否内存</p></li><li><p>struct 比 class <code>更轻量级</code>，<code>栈</code> 只访问一次拿到数据，<code>堆</code> 访问两次拿到数据（第一次获取指针，第二次获取数据）</p></li></ul><h1 id="方法的调用？"><a href="#方法的调用？" class="headerlink" title="方法的调用？"></a>方法的调用？</h1><ul><li><p>struct&#x2F;enum&#x2F;extension：值类型，方法调用是 <code>静态派发</code>，直接调用 <code>地址</code></p></li><li><p>class：引用类型，方法调用是 <code>动态派发</code>，也叫 <code>函数表调度</code></p></li></ul><h1 id="什么是协议？作用？"><a href="#什么是协议？作用？" class="headerlink" title="什么是协议？作用？"></a>什么是协议？作用？</h1><ul><li>协议 <code>规定了用来实现某一特定功能所必须的属性和方法</code>，这个属性指 <code>实例属性或类属性</code>，而不用指定是 <code>存储属性或计算属性</code></li><li><code>类、结构体、枚举</code> 都可以遵循协议，<code>提供具体的实现</code> 来完成协议定义的 <code>属性和方法</code></li></ul><h1 id="swift-协议-和-oc-协议有啥区别？"><a href="#swift-协议-和-oc-协议有啥区别？" class="headerlink" title="swift 协议 和 oc 协议有啥区别？"></a>swift 协议 和 oc 协议有啥区别？</h1><p>swift 协议：</p><ul><li>协议可以定义 <code>属性和方法</code>， 定义 <code>属性</code> 必须明确是 <code>可读的/可读可写 &#123; set get &#125;</code></li><li>协议可以 <code>继承</code> 其他协议</li><li>协议可以 <code>扩展协议</code></li><li>协议可以定义 <code>指定初始化器或便捷初始化器</code></li><li>协议可以用于 <code>类、结构体、枚举</code></li></ul><p>oc 协议：</p><ul><li>受限于委托代理，多用于不同类之间的传值和回调</li></ul><h1 id="什么是扩展？作用？"><a href="#什么是扩展？作用？" class="headerlink" title="什么是扩展？作用？"></a>什么是扩展？作用？</h1><p>1、扩展可以向一个已有的 <code>类型、结构体、枚举、协议</code> 添加新的功能，</p><p>2、作用：</p><ul><li>可以添加 <code>计算型实例属性</code> 和 <code>计算型类型属性</code>。</li><li>可以添加 <code>实例方法和类型方法</code></li><li>可以添加 <code>新的初始化器</code></li><li>可以添加 <code>下标脚本</code> </li><li>可以使现有的 <code>类型遵循某协议</code></li><li>定义和使用 <code>新内嵌类型</code></li><li>扩展 <code>可以向一个类型添加新的方法</code>，但是<code>不能重写已有的方法</code></li></ul><blockquote><p>使用注意：</p></blockquote><ul><li>不可以添加 <code>存储属性</code>，也不可以为已有属性添加属性观察器</li></ul><h1 id="泛型的作用？"><a href="#泛型的作用？" class="headerlink" title="泛型的作用？"></a>泛型的作用？</h1><p><code>解决代码的复用性和抽象能力</code></p><h1 id="associatedtype-关键字作用？"><a href="#associatedtype-关键字作用？" class="headerlink" title="associatedtype 关键字作用？"></a>associatedtype 关键字作用？</h1><ul><li>关联类型：给 <code>协议</code> 中用到的 <code>某个类型</code> 起一个 <code>占位符名称</code></li></ul><h1 id="final-关键字作用？"><a href="#final-关键字作用？" class="headerlink" title="final 关键字作用？"></a>final 关键字作用？</h1><ul><li><code>final</code>：只能用于 <code>类</code> 中， <code>final</code> 声明的 <code>类</code> 不能被继承，<code>final</code> 声明的 <code>属性、方法不能被重写</code>。</li></ul><h1 id="inout-关键字作用？"><a href="#inout-关键字作用？" class="headerlink" title="inout 关键字作用？"></a>inout 关键字作用？</h1><ul><li>inout： 输入输出形式参数，用来 <code>修改形式参数的值，函数结束后仍然生效</code>，因为函数的参数是 <code>值类型</code></li></ul><h1 id="objc-关键字作用？"><a href="#objc-关键字作用？" class="headerlink" title="@objc 关键字作用？"></a>@objc 关键字作用？</h1><ul><li>@objc：用于 <code>OC</code> 访问 <code>swift</code>，<code>类</code> 需要继承 <code>NSObject</code></li></ul><h1 id="dynamic-关键字作用？"><a href="#dynamic-关键字作用？" class="headerlink" title="dynamic 关键字作用？"></a>dynamic 关键字作用？</h1><ul><li><p>dynamic ：让方法具有动态性，用于 <code>method-swizzling</code>， 需要 <code>类</code> 继承 <code>NSObject</code></p></li><li><p>@objc + dynamic ：用来实现消息发送</p></li></ul><h1 id="mutaing-关键字作用？"><a href="#mutaing-关键字作用？" class="headerlink" title="mutaing 关键字作用？"></a>mutaing 关键字作用？</h1><ul><li>mutaing：结构体内嵌函数修改存储属性，</li></ul><h1 id="Swift的静态派发和动态派发"><a href="#Swift的静态派发和动态派发" class="headerlink" title="Swift的静态派发和动态派发"></a>Swift的静态派发和动态派发</h1><ul><li><code>OC</code> 中的 <code>方法</code> 都是 <code>动态派发(方法调用)</code>，<code>wift</code> 中的 <code>方法</code> 分为 <code>静态派发和动态派发</code>。</li><li>动态派发：指的是方法在 <code>运行时才找具体实现</code>。Swift 中的动态派发和 OC 中的动态派发是一样的.</li><li>静态派发：静态派发是指在 <code>运行时调用方法不需要查表</code>，<code>直接跳转到方法的代码中执行</code></li><li>静态派发的特点:<ul><li>静态派发更 <code>高效</code>，因为静态派发免去了查表操作。</li><li>静态派发的条件是方法内部的代码必须对编译器透明，且在运行时不能被更改，这样编译器才能帮助我们.</li><li>Swift 中的 <code>值类型</code> 不能被继承，也就是说 <code>值类型的方法实现不能被修改或者被复写</code>，因此 <code>值类型的方法满足静态派发</code>.</li></ul></li></ul><h1 id="swift-是面向对象还是函数式编程？"><a href="#swift-是面向对象还是函数式编程？" class="headerlink" title="swift 是面向对象还是函数式编程？"></a>swift 是面向对象还是函数式编程？</h1><ul><li><p>swift 既是面向对象也是面向函数式编程</p></li><li><p>swift面向对象，是因为swift支持 <code>类的封装、继承、多态</code></p></li><li><p>swift面向函数式编程，是因为swift支持 <code>map、reduce、filter、flatmap</code> 这类去除中间状态、数学函数式方法，更加强调运算结果而不是中间过程。</p></li></ul><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><ul><li><p>open：修饰的属性或者方法在<code>其他作用域既可以被访问</code>，<code>也可以被继承或重载 override</code>。</p></li><li><p>public ：修饰的属性或者方法可以在 <code>其他作用域允许被访问</code> ，<code>但不能被重载</code>，也不能在继承的 <code>Extension</code> 中被访问。</p></li><li><p>internal：被修饰的属性和方法只能在 <code>模块内</code> 部可以访问，超出模块内部就不可被访问了。（默认）</p></li><li><p>fileprivate ：其修饰的属性或者方法只能在当前的 <code>源文件</code> 里可以访问。</p></li><li><p>private ：只允许在 <code>当前类</code> 中调用，<code>Extension</code> 中不能访问</p></li><li><p>从高到低排序如下：</p></li></ul><p>open &gt; public &gt; interal &gt; fileprivate &gt; private</p><h1 id="dynamic-framework-和-static-framework-的区别是什么？"><a href="#dynamic-framework-和-static-framework-的区别是什么？" class="headerlink" title="dynamic framework 和 static framework 的区别是什么？"></a>dynamic framework 和 static framework 的区别是什么？</h1><ul><li><p>静态库和动态库, 静态库是每一个程序单独打包一份, 而动态库则是多个程序之间共享.</p></li><li><p>静态库和动态库是相对编译期和运行期的：静态库在程序编译时会被链接到目标代码中，程序运行时将不再更改静态库；而动态库在程序编译时并不会被链接到目标代码中，只是在程序运行时才被载入。</p></li><li><p>静态库在链接时，会被完整的 <code>复制 </code>到可执行文件中，如果多个App都使用了同一个静态库，那么每个App都会拷贝一份，缺点是 <code>浪费内存</code>.</p></li><li><p>动态库不会复制，<code>只有一份</code>，程序运行时动态加载到内存中，系统只会加载一次，多个程序共用一份，<code>节约了内存</code>.</p></li></ul><h1 id="Swift-中的-KVC-和-KVO"><a href="#Swift-中的-KVC-和-KVO" class="headerlink" title="Swift 中的 KVC 和 KVO"></a>Swift 中的 KVC 和 KVO</h1><ul><li>KVC：要继承 <code>NSObject</code></li><li>KVO：由于 Swift 为了效率, 默认禁用了 <code>动态派发</code>, 因此 <code>Swift</code> 要实现 <code>KVO</code>, 除了要继承自 <code>NSObject</code> 外还要将观测的对象标记为 <code>dynamic</code>(让 swift 代码也能有 Objective-C 中的动态机制)</li></ul><h1 id="swift中高阶函数map、filter、reduce"><a href="#swift中高阶函数map、filter、reduce" class="headerlink" title="swift中高阶函数map、filter、reduce"></a>swift中高阶函数map、filter、reduce</h1><ul><li>map 用于映射, 可以将一个列表转换为另一个列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].map&#123;&quot;\($0)&quot;&#125;// 数字数组转换为字符串数组</span><br><span class="line">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span><br></pre></td></tr></table></figure><ul><li>filter 用于过滤, 可以筛选出想要的元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].filter&#123;$0 % 2 == 0&#125; // 筛选偶数</span><br><span class="line">// [2] </span><br></pre></td></tr></table></figure><ul><li>reduce 合并</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].reduce(&quot;&quot;)&#123;$0 + &quot;\($1)&quot;&#125;// 转换为字符串并拼接</span><br><span class="line">// &quot;123&quot;</span><br></pre></td></tr></table></figure><h1 id="map-与-flatmap-的区别？"><a href="#map-与-flatmap-的区别？" class="headerlink" title="map 与 flatmap 的区别？"></a>map 与 flatmap 的区别？</h1><ul><li><code>map</code> 可以对一个集合类型的所有元素做一个映射操作.</li><li>flatMap</li></ul><blockquote><p>第一个作用和map一样,对一个集合类型的所有元素做一个映射操作,且可以过滤为nil的情况.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let array = [1,2,5,6,7,nil]</span><br><span class="line">let array_map = array.map &#123; $0 &#125;</span><br><span class="line">//[Optional(1), Optional(2), Optional(5), Optional(6), Optional(7), nil]</span><br><span class="line">let array_flatmap = array_map.flatMap &#123; $0 &#125;</span><br><span class="line">//[1, 2, 5, 6, 7]</span><br></pre></td></tr></table></figure><blockquote><p>第二种情况可以进行 <code>降维</code> 操作</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let array = [[&quot;1&quot;, &quot;2&quot;],[&quot;3&quot;, &quot;4&quot;]]</span><br><span class="line">let array_map = array.map &#123; $0 &#125;</span><br><span class="line">//[[&quot;1&quot;, &quot;2&quot;], [&quot;3&quot;, &quot;4&quot;]]</span><br><span class="line">let array_flatmap = array_map.flatMap &#123; $0 &#125;</span><br><span class="line">//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]</span><br></pre></td></tr></table></figure><h1 id="一个函数的参数类型只要是数字（Int、Float）都可以，要怎么表示。"><a href="#一个函数的参数类型只要是数字（Int、Float）都可以，要怎么表示。" class="headerlink" title="一个函数的参数类型只要是数字（Int、Float）都可以，要怎么表示。"></a>一个函数的参数类型只要是数字（Int、Float）都可以，要怎么表示。</h1><p><code>Int、Float</code> 都有一个协议 <code>Numeric</code> ，或者 <code>ExpressibleByIntegerLiteral</code> 协议也行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func myMethod&lt;T&gt;(_ value: T) where T: Numeric &#123;</span><br><span class="line">    print(value + 1)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="常用的三方框架"><a href="#常用的三方框架" class="headerlink" title="常用的三方框架"></a>常用的三方框架</h1><ul><li>Alamofire：网络加载</li><li>HandyJson：JSON数据解析</li><li>R.swift：使用资源文件</li><li>Snapkit：自动布局</li><li>Kingfisher：网络图片加载和缓存</li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC面试题：总结</title>
      <link href="/BboyZJ.github.io/2023/03/01/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%80%BB%E7%BB%93/"/>
      <url>/BboyZJ.github.io/2023/03/01/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>👁 <a href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%97%E6%B3%95/">OC面试题：算法</a></p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>👁 <a href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/">OC面试题：多线程</a></p><h1 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h1><p>👁 <a href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARunloop/">OC面试题：Runloop</a></p><h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><p>👁 <a href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ARuntime/">OC面试题：Runtime</a></p><h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h1><p>👁 <a href="https://www.bboyzj.cn/2023/03/10/%E9%9D%A2%E8%AF%95%E9%A2%98/OC%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ABlock/">OC面试题：链表</a></p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>👁 <a href="https://www.bboyzj.cn/2020/08/09/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8E%A2%E7%B4%A2/">OC学习：链表</a></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>👁  <a href="https://www.bboyzj.cn/2020/08/26/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%A2%E7%B4%A2/">OC学习：二叉树</a></p><h1 id="什么是野指针？"><a href="#什么是野指针？" class="headerlink" title="什么是野指针？"></a>什么是野指针？</h1><p>是一个没有指向 <code>任何内存</code> 的 <code>指针</code>，尝试使用它会导致 <code>应用程序崩溃</code></p><h1 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h1><p>一个 <code>对象</code> 没有被释放，会 <code>内存泄漏</code>，内存泄漏会导致应用程序占用的内存会越来越大，直到应用程序无内存可用时，会导致 <code>应用程序崩溃</code></p><h2 id="iOS-关键词有哪些？各有什么作用？-重点"><a href="#iOS-关键词有哪些？各有什么作用？-重点" class="headerlink" title="iOS 关键词有哪些？各有什么作用？ 重点"></a>iOS 关键词有哪些？各有什么作用？ <strong>重点</strong></h2><ul><li>readwrite</li></ul><p><code>可读可写</code> 特性，同时生成get方法和set方法的声明和实现</p><ul><li>readonly</li></ul><p><code>只读</code> 特性，只会生成get方法的声明和实现，不希望属性在类外改变</p><ul><li>retain</li></ul><p><code>持有</code> 特性，retaincount 会 +1,用于 <code>MRC</code></p><ul><li>nonatomic</li></ul><p><code>非原子</code> 特性</p><ul><li>atomic</li></ul><p><code>原子</code> 特性，默认属性</p><p>atomic不是绝对线程安全的，只是对 <code>setter/getter</code> 方法使用了 <code>自旋锁(spinlock_t)</code>，内部使用 <code>互斥锁(os_unfair_lock)</code>，保证了 <code>读/写</code> 安全。</p><p>atomic并不能保证 <code>整个对象</code> 是线程安全的，需要对 <code>整个对象</code> 进行 <code>加锁</code> 来保证线程安全：</p><pre><code>*  NSLock（互斥锁）*  dispathch_semaphore（信号量）*  @synchronized（互斥递归锁）</code></pre><ul><li>assign</li></ul><p>可以修饰 <code>基本数据类型和对象</code>。</p><p>通常用于修饰 <code>基本数据类型</code>，如Int、CGFloat、Double等，这是因为 <code>基本数据类型放在栈区</code>，栈由编译器自动分配和释放内存，栈先进后出，基本数据类型出栈后，assign修饰的基本数据类型就不存在了，不会出现 <code>野指针</code></p><p>修饰对象，如NSString、实例对象等，引用计数不会增加，但 <code>assign</code> 修饰对象释放后，<code>指针</code> 不会被系统置为nil，会产生 <code>野指针</code> 或 <code>EXC_BAD_ACCESS</code> 错误。</p><ul><li>strong</li></ul><p>强引用，<code>只修饰对象</code>，属性默认修饰符</p><p><code>指向并持有该对象</code>，其修饰的对象引用计数会 <code>+1</code>，引用计数不为 <code>0</code> 则不会被销毁，需要将其置为 <code>nil</code> 可以销毁。否则会出现 <code>内存泄漏</code>。</p><ul><li>weak</li></ul><p>弱引用，<code>只修饰对象</code>。</p><p><code>指向但并不拥有该对象</code>，引用计数不增加。该对象自动在内存中销毁。</p><ul><li>copy</li></ul><p>用于修饰 <code>不可变的对象</code>。</p><p>比如NSString、NSDictionary、NSArray等。</p><h2 id="浅拷贝和深拷贝-重点"><a href="#浅拷贝和深拷贝-重点" class="headerlink" title="浅拷贝和深拷贝 重点"></a>浅拷贝和深拷贝 <strong>重点</strong></h2><ul><li>浅拷贝</li></ul><p>浅拷贝，拷贝了一个新的指针，与原对象指针指向同一块内存，<code>引用计数 + 1</code>；(A,CopyA &#x3D; [A copy]，A 变化，CopyA 的值也变化)</p><ul><li>深拷贝</li></ul><p>深拷贝，拷贝了一个新的对象，指向新的内存，新对象的 <code>引用计数为 1</code>，源对象引用计数不变；(A,MutableA &#x3D; [A mutbleCopy]，A 变化，MutableA 的值不变)。</p><h2 id="NSString-x2F-NSArray-x2F-NSDictionary和NSMutableString-x2F-NSMutableArray-x2F-NSMutableDictionary-进行copy和mutableCopy区别？重点"><a href="#NSString-x2F-NSArray-x2F-NSDictionary和NSMutableString-x2F-NSMutableArray-x2F-NSMutableDictionary-进行copy和mutableCopy区别？重点" class="headerlink" title="NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？重点"></a>NSString&#x2F;NSArray&#x2F;NSDictionary和NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary 进行copy和mutableCopy区别？<strong>重点</strong></h2><ul><li><p>对于不可变NSString&#x2F;NSArray&#x2F;NSDictionary，copy浅拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝)</p></li><li><p>对于可变NSMutableString&#x2F;NSMutableArray&#x2F;NSMutableDictionary，copy深拷贝(元素：浅拷贝)，mutableCopy深拷贝(元素：浅拷贝)</p></li></ul><h2 id="自定义对象的copy和mutableCopy？-重点"><a href="#自定义对象的copy和mutableCopy？-重点" class="headerlink" title="自定义对象的copy和mutableCopy？ 重点"></a>自定义对象的copy和mutableCopy？ <strong>重点</strong></h2><ul><li>copy和mutableCopy都是深拷贝(属性：浅拷贝）</li></ul><h1 id="属性用copy还是strong？-重点"><a href="#属性用copy还是strong？-重点" class="headerlink" title="属性用copy还是strong？ 重点"></a>属性用copy还是strong？ <strong>重点</strong></h1><ul><li><p>对于不可变属性，推荐用copy，目的是为了 <code>让本属性不受外界影响</code>，无论给我传入可变还是不可变对象，我本身持有的就是一个不可变的副本，被set时，改变的是这个副本。</p></li><li><p>对于可变属性，推荐用strong，因为copy修饰后，会变成不可变对象，再调用可变对象函数时会 crash</p></li></ul><h2 id="一个APP是如何唤醒另一个APP的？-重点"><a href="#一个APP是如何唤醒另一个APP的？-重点" class="headerlink" title="一个APP是如何唤醒另一个APP的？ 重点"></a>一个APP是如何唤醒另一个APP的？ <strong>重点</strong></h2><p>URL Scheme：iOS有一个特性就是将 <code>自身绑定</code> 到一个自定义的 <code>URL Scheme</code> 上，该 <code>scheme</code> 用于从 <code>浏览器或其他应用中启动本应用</code>。</p><h2 id="UIView和CALayer"><a href="#UIView和CALayer" class="headerlink" title="UIView和CALayer"></a>UIView和CALayer</h2><ul><li>UIView和CALayer的关系？</li></ul><p>1）UIView继承UIReponder，CALayer继承NSObject。<br>2）UIView响应事件，CALayer绘制UI。<br>3）UIView是CALayer的代理。</p><ul><li>UIWindow和UIView的关系？</li></ul><p>1）UIWindow继承自UIView。<br>2）UIWindow提供一个区域用来显示UIView。</p><h2 id="单例的写法和作用？-重点"><a href="#单例的写法和作用？-重点" class="headerlink" title="单例的写法和作用？ 重点"></a>单例的写法和作用？ <strong>重点</strong></h2><p>单例模式的作用：可以保证程序运行过程中，一个类只返回一个实例，供外界访问；static保证类只分配一次内存；dispatch_once方法保证调用一次，并自动加锁，线程安全</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static id _instance = nil; // 定义static全局变量，保证只分配一次内存</span><br><span class="line">+ (id)shareInstance&#123;</span><br><span class="line">    return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">+ (id)copyWithZone:(struct _NSZone *)zone&#123;</span><br><span class="line">    static dispatch_once_t onceToken; // 声明一个静态的GcD单次任务</span><br><span class="line">    // 保证只执行一次</span><br><span class="line">    dispatch_once(&amp;onceToken,^&#123; // </span><br><span class="line">        _instance = [super allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这么写可以保证下面两种方式返回同一个实例：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Single * p1 = [Single shareInstance];</span><br><span class="line">Single * p2 = [[Single alloc] init];</span><br><span class="line">NSLog(@&quot;%d&quot;,p1==p2); // 1</span><br></pre></td></tr></table></figure></div><h2 id="常用的数据存储方式有哪些？各自的优缺点？"><a href="#常用的数据存储方式有哪些？各自的优缺点？" class="headerlink" title="常用的数据存储方式有哪些？各自的优缺点？"></a>常用的数据存储方式有哪些？各自的优缺点？</h2><ul><li><p>plist：plist文件是将某些特定的类，通过 <code>XML文件</code> 的方式保存在目录中。</p></li><li><p>NSUserdefault：归档</p></li><li><p>数据库：适合储存数据量较大的数据,一般使用FMDB和CoreData来实现.</p></li><li><p>Keychain：用于 <code>本地重要数据的存储</code>，将数据加密后存储在本地。如：<code>密码,秘钥,序列号</code> 等,当你 <code>删除APP后Keychain存储的数据不会删除</code>，所以在重装App后，Keychain里的数据还能使用。</p></li><li><p>沙盒写入：存储非机密数据</p><ul><li>Application：存放程序源文件，上架前经过数字签名，上架后不可修改。</li><li>Documents: <code>保存应⽤运行时生成的需要持久化的数据</code>。<code>iTunes</code> 同步设备时会 <code>备份</code> 该目录。</li><li>tmp: <code>保存应⽤运行时所需的临时数据</code>，使⽤完毕后再将相应的文件从该目录删除。<code>iTunes</code> 同步设备时 <code>不会备份</code> 该目录。</li><li>Library&#x2F;Caches: <code>保存应用运行时⽣成的需要持久化的数据</code>。 <code>iTunes</code> 同步设备时 <code>不会备份</code> 该目录。</li><li>Library&#x2F;Preference: <code>保存应用的所有偏好设置</code>。<code>iTunes</code> 同步设备时会 <code>备份</code> 该目录。</li></ul></li></ul><h2 id="加密方式有哪些？各自的加密算法哪些？"><a href="#加密方式有哪些？各自的加密算法哪些？" class="headerlink" title="加密方式有哪些？各自的加密算法哪些？"></a>加密方式有哪些？各自的加密算法哪些？</h2><ul><li><p>对称加密：又称公开密钥加密，<code>加密和解密</code> 都会用到 <code>同一个密钥</code>。常见的对称加密算法有 <code>DES、3DES、AES、Blowfish、IDEA、RC5、RC6</code>。</p></li><li><p>非对称加密：非对称加密又称 <code>共享密钥加密</code>，使用 <code>一对非对称的密钥</code>，一把叫做 <code>私有密钥</code>，另一把叫做 <code>公有密钥</code>；公钥加密只能用私钥来解密，私钥加密只能用公钥来解密。常见的有：<code>RSA</code>、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法。</p></li></ul><h2 id="成员变量和实例变量区别？"><a href="#成员变量和实例变量区别？" class="headerlink" title="成员变量和实例变量区别？"></a>成员变量和实例变量区别？</h2><ul><li><p>成员变量：在文件中@interface下{}内的均统称为 <code>成员变量</code></p></li><li><p>实例变量：实例变量是 <code>类定义</code> 的变量</p></li><li><p>区别：</p><ul><li>去除基本数据类型int,float…等，其他类型的变量均叫做 <code>实例变量</code></li><li><code>成员变量 = 实例变量 + 基本数据类型</code></li></ul></li></ul><h2 id="property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的"><a href="#property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的" class="headerlink" title="@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?"></a>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的?</h2><ul><li>@property &#x3D; _ivar + getter + setter;</li></ul><p> property（属性）&#x3D; _ivar（实例变量）+ setter（存方法）+ getter（取方法） </p><ul><li><p>属性引用self.name与_name的区别？</p></li><li><p>self.name是对属性的访问，&#x3D; 左侧是调用setter方法，&#x3D; 右侧是调用getter方法，可以在类外使用，_name不能在类外使用。</p></li><li><p>_name是对 <code>局部变量</code> 的访问，直接调用变量，不通过getter方法</p></li></ul><h2 id="frame-和-bounds-区别？"><a href="#frame-和-bounds-区别？" class="headerlink" title="frame 和 bounds 区别？"></a>frame 和 bounds 区别？</h2><ul><li><p>frame：参考系是父视图坐标</p></li><li><p>bounds：参考系是自身坐标</p></li></ul><h2 id="常见的状态码？"><a href="#常见的状态码？" class="headerlink" title="常见的状态码？"></a>常见的状态码？</h2><ul><li><p>2xx <code>成功</code>：200表示请求正常。</p></li><li><p>3xx <code>重定向</code>：302是请求重定向。解决方法 NSURLConnetion 和 NSURLSession 进行拦截</p></li><li><p>4xx <code>客户端</code>错误：400客户端请求的语法错误，404Not Found 找不到&#x2F;请求失败</p></li><li><p>5xx <code>服务器</code>错误：500 Internal Server Error 服务器的内部错误</p></li></ul><h2 id="HTTPS和HTTP的区别？-重点"><a href="#HTTPS和HTTP的区别？-重点" class="headerlink" title="HTTPS和HTTP的区别？ 重点"></a>HTTPS和HTTP的区别？ <strong>重点</strong></h2><ul><li><p>HTTP：超文本传输协议，信息明文传输；端口号80；响应速度快（使用TCP三次握手，客户端和服务端需要交换3个包）；</p></li><li><p>HTTPS：是由 HTTP+SSL&#x2F;TLS 加密传输；端口号443；响应速度慢（除了使用TCP三个包，还要加上SSL握手的9个包）；需要到CA申请证书</p></li></ul><h2 id="TCP-和-UDP-区别-重点"><a href="#TCP-和-UDP-区别-重点" class="headerlink" title="TCP 和 UDP 区别? 重点"></a>TCP 和 UDP 区别? <strong>重点</strong></h2><ul><li><p>都是 <code>传输层</code> 协议</p></li><li><p>TCP协议是 <code>面向连接的可靠的传输层协议</code>。UDP协议是 <code>面向非连接的传输层协议</code></p></li><li><p>TCP需要 <code>建立连接和断开连接</code>。UDP不需要连接。</p></li><li><p>TCP传 <code>输数据没有大小限制</code>。UDP <code>传输数据有大小限制</code>。</p></li><li><p>TCP会 <code>处理数据丢包重发</code>。UDP不会处理。</p></li></ul><h1 id="HTTP和socket区别？-重点"><a href="#HTTP和socket区别？-重点" class="headerlink" title="HTTP和socket区别？ 重点"></a>HTTP和socket区别？ <strong>重点</strong></h1><ul><li><code>HTTP</code> 应用层协议；<code>socket</code> 不属于协议范畴，而是一个接口（API），是对TCP&#x2F;IP协议的封装</li><li><code>HTTP</code> 是基于 <code>请求-响应</code> 形式 <code>短连接</code>，即客户端发送一次请求，服务端响应后立即 <code>断开连接</code>；socket 是基于TCP协议的 <code>长链接</code>，理论上 客户端和服务端一旦建立连接将不会主动断开</li><li>HTTP 传输慢，数据量大，安全差；socket 数据可自定义，数据量小，安全性高，适合信息实时交互（推送、聊天等）</li></ul><h2 id="staitc-和-const-的区别？-重点"><a href="#staitc-和-const-的区别？-重点" class="headerlink" title="staitc 和 const 的区别？ 重点"></a>staitc 和 const 的区别？ <strong>重点</strong></h2><ul><li><p>const：表示 <code>只读</code> 的意思</p><ul><li><p><code>const</code> 放在 <code>类型</code> 前：可以改变指针的指向，可以改变指针指向的内容</p></li><li><p><code>const</code> 放在 <code>变量</code> 前：不可以改变指针的指向，不可以改变指针指向的内容</p></li></ul></li><li><p>static： <code>静态变量</code>，可修饰 <code>局部变量和全局变量</code>，可修饰方法</p><ul><li><p><code>static</code> 可修饰 <code>局部/全局变量</code>，称为 <code>局部静态变量和全局静态变量</code>，只初始化一次，只分配一次内存，生命周期被改变，不再是作用域内</p></li><li><p><code>static</code> 修饰的 <code>方法</code>，可以在不同文件下重名，互不影响运行</p></li></ul></li></ul><h2 id="通用链接（Universal-Links）重点"><a href="#通用链接（Universal-Links）重点" class="headerlink" title="通用链接（Universal Links）重点"></a>通用链接（Universal Links）<strong>重点</strong></h2><ul><li><p>服务端配置 <code>HTTPS</code> 证书 和添加 <code>apple-app-site-association</code> 地址关联文件</p></li><li><p>移动端在plist添加 <code>Associated Domains</code> 关联域权限</p></li></ul><h2 id="简述GET和POST请求的区别？-重点"><a href="#简述GET和POST请求的区别？-重点" class="headerlink" title="简述GET和POST请求的区别？ 重点"></a>简述GET和POST请求的区别？ <strong>重点</strong></h2><ul><li><p>GET 传输数据 <code>有缓存</code>；POST 传输数据 <code>没有缓存</code></p></li><li><p>GET的 <code>参数</code> 放在 <code>URL</code> 的后面，并且第一个参数用 <code>?</code> 号拼接，后面的从第二个参数开始，直到最后一个，用 <code>&amp;</code> 分割；POST的 <code>参数</code> 放在 <code>请求体</code> 里面，并且第一个参数用 <code>,</code> 号拼接，后面从第二开始，直到最后用 <code>&amp;</code> 分割;</p></li><li><p>GET一般用于 <code>获取数据</code>；POST一般用于 <code>向服务器提交数据</code></p></li><li><p><code>GET</code> 的参数是暴漏在 <code>地址栏</code> 的，不安全；<code>POST</code> 的参数隐藏在 <code>请求体</code> 里面，相对安全一点;</p></li></ul><h2 id="iOS中几种常见的设计模式？-重点"><a href="#iOS中几种常见的设计模式？-重点" class="headerlink" title="iOS中几种常见的设计模式？  重点"></a>iOS中几种常见的设计模式？  <strong>重点</strong></h2><ul><li><code>代理模式</code></li></ul><p>一对一的依赖关系，当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。</p><ul><li><code>观察者模式</code></li></ul><p>KVO机制 和 Notification通知机制</p><ul><li><code>单例模式</code></li></ul><p>保证程序运行过程中，一个类只返回一个实例，供外界访问</p><ul><li><code>工厂模式</code></li></ul><p>通过一个类方法，<code>根据已有模板批量生产对象</code>。</p><ul><li><code>MVC模式</code></li></ul><p>Model即数据模型</p><p>view即视图</p><p>controller即控制器</p><h2 id="RunLoop是什么？-重点"><a href="#RunLoop是什么？-重点" class="headerlink" title="RunLoop是什么？ 重点"></a>RunLoop是什么？ <strong>重点</strong></h2><ul><li>概念</li></ul><p><code>RunLoop</code> 又叫 <code>运行循环</code>，内部就是一个 <code>do-while循环</code>，在这个循环内部不断 <code>处理各种任务，保证程序持续运行</code>。</p><ul><li>目的</li></ul><p>RunLoop存在的目的： 就是当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，<code>提高程序性能，节省CPU资源</code>，该做事的时候做事，该休息的时候休息</p><h2 id="RunLoop的作用？-重点"><a href="#RunLoop的作用？-重点" class="headerlink" title="RunLoop的作用？ 重点"></a>RunLoop的作用？ <strong>重点</strong></h2><ul><li><p><code>保持程序持续运行</code>。<br> App一启动就会开启主线程，主线程在开启的时候就会开启主线程对应的RunLoop，RunLoop能保证线程不被销毁，主线程不销毁，程序就会持续运行。</p></li><li><p><code>处理App中各类事件</code>。<br> 事件响应、手势识别、界面刷新、AutoreleasePool自动释放池、NSTimer等事件处理。</p></li><li><p><code>节省CPU资源，提高程序性能</code>。<br> 如概述所述，当线程中有任务的时候，保证线程干活，当线程没有任务的时候，让线程睡眠，提高程序性能，节省资源，该做事的时候做事，该休息的时候休息。</p></li></ul><h2 id="可以用Runloop实现什么功能？-重点"><a href="#可以用Runloop实现什么功能？-重点" class="headerlink" title="可以用Runloop实现什么功能？ 重点"></a>可以用Runloop实现什么功能？ <strong>重点</strong></h2><ul><li>tableView 滚动时图片不加载</li></ul><p>SDWebImage + Runloop，图片延迟加载，滑动不加载图片</p><ul><li>线程保活</li></ul><p>往 <code>runloop</code> 中添加 <code>[[NSPort alloc] init]</code> 事件，</p><ul><li>解决NSTimer在滑动时停止工作的问题</li></ul><p><code>default</code> 模式改为 <code>common</code> 模式</p><ul><li>检测卡顿</li></ul><p><code>displaylink + runloop 进行卡顿检测，将数值和页面绑定上传到服务器</code></p><h2 id="RunLoop接收几种输入源，系统默认定义了几种模式？-重点"><a href="#RunLoop接收几种输入源，系统默认定义了几种模式？-重点" class="headerlink" title="RunLoop接收几种输入源，系统默认定义了几种模式？ 重点"></a>RunLoop接收几种输入源，系统默认定义了几种模式？ <strong>重点</strong></h2><ul><li><p>输入源有两种<br>基于 <code>端口</code> 的输入源（port）<br><code>自定义</code> 的输入源（custom）</p></li><li><p>系统定义的RunLoop模式有五种，最常用的有三种，如下所示：<br>NSDefaultRunLoopMode<br>默认模式，主线程中默认是NSDefaultRunLoopMode<br>UITrackingRunLoopMode<br>视图滚动模式，RunLoop会处于该模式下<br>NSRunLoopCommonModes<br>并不是真正意义上的Mode，是一个占位用的“Mode”，默认包含了NSDefaultRunLoopMode和UITrackingRunLoopMode两种模式</p></li></ul><h2 id="RunLoop和线程有什么关系？Runloop的mode-Runloop的作用？-重点"><a href="#RunLoop和线程有什么关系？Runloop的mode-Runloop的作用？-重点" class="headerlink" title="RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？ 重点"></a>RunLoop和线程有什么关系？Runloop的mode? Runloop的作用？ <strong>重点</strong></h2><ul><li>每一个线程都有一个runloop，主线程的runloop默认启动。子线程的runloop默认不启动</li><li>mode：主要用来指定事件在运行时循环的优先级</li><li>作用：保持程序的持续运行、随时处理各种事件、节省cpu资源(没事件休息释放资源)，提高程序的性能。</li></ul><h2 id="怎么理解Objective-C是动态运行时语言。-重点"><a href="#怎么理解Objective-C是动态运行时语言。-重点" class="headerlink" title="怎么理解Objective-C是动态运行时语言。 重点"></a>怎么理解Objective-C是动态运行时语言。 <strong>重点</strong></h2><p>主要是 <code>将数据类型的确定和函数的调用由编译时推迟到了运行时</code>。这个问题其实浅涉及到两个概念，<code>运行时和多态</code>。</p><ul><li><p>运行时：简单来说，运行时机制使我们 <code>直到运行时才去确定数据类型和要调用的函数</code>。</p></li><li><p>多态：<code>不同对象以自己的方式响应相同的消息的能力</code> 叫做多态。</p></li></ul><h2 id="runtime项目中具体应用？-重点"><a href="#runtime项目中具体应用？-重点" class="headerlink" title="runtime项目中具体应用？ 重点"></a>runtime项目中具体应用？ <strong>重点</strong></h2><ul><li><code>方法交换</code>。</li><li>给 <code>分类添加属性</code>。 </li><li>动态添加方法。</li><li>字典转模型。</li><li>数组越界。</li><li>动态获取成员属性、成员变量、实例方法</li></ul><h2 id="KVC是什么？重点"><a href="#KVC是什么？重点" class="headerlink" title="KVC是什么？重点"></a>KVC是什么？<strong>重点</strong></h2><p><code>KVC</code> 全程 <code>Key Value Coding</code>，中文 <code>键值编码</code>，是由 <code>NSKeyValueCoding</code> 非正式协议启动的一种机制，<code>对象</code> 采用该协议来 <code>间接访问对象的属性</code>。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKey:(NSString *)key;     </span><br><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath; </span><br><span class="line"></span><br><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; </span><br></pre></td></tr></table></figure></div><p><a href="http://www.bboyzj.cn/2021/01/17/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8622%EF%BC%9AKVC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">KVC底层原理：</a></p><h2 id="KVO是什么？重点"><a href="#KVO是什么？重点" class="headerlink" title="KVO是什么？重点"></a>KVO是什么？<strong>重点</strong></h2><p><code>KVO</code> 全程 <code>Key Value Observing</code>，中文 <code>键值观察</code>，它 <code>用于监听实例对象属性的变化</code>。</p><h2 id="KVO的实现原理？-KVO的本质是什么？-重点"><a href="#KVO的实现原理？-KVO的本质是什么？-重点" class="headerlink" title="KVO的实现原理？(KVO的本质是什么？) 重点"></a>KVO的实现原理？(KVO的本质是什么？) <strong>重点</strong></h2><p>当一个 <code>实例对象</code> 的 <code>属性注册了KVO</code>，实例对象 <code>isa指针</code> 的指向在注册KVO观察者之后，由 <code>原有类</code> 改为 <code>中间类(NSKVONotifing_类名)</code>；<code>中间类</code> 重写了 <code>属性setter方法、class、dealloc、_isKVOA</code> 方法；<code>dealloc</code> 方法中，移除 <code>KVO</code> 观察者之后，实例对象isa 指向由 <code>中间类</code> 更改为 <code>原有类</code>;中间类 从创建后就 <code>一直存在内存中</code>，不会被销毁。</p><h2 id="KVO实际应用-重点"><a href="#KVO实际应用-重点" class="headerlink" title="KVO实际应用 重点"></a>KVO实际应用 <strong>重点</strong></h2><ul><li><p>观察 <code>实例对象</code> 的 <code>属性</code> 变化</p></li><li><p>观察 <code>实例对象</code> 的 <code>容器</code> 变化</p><p> 观察容器用： <code>mutableArrayValueForKey</code></p></li></ul><p><a href="http://www.bboyzj.cn/2021/01/25/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8623%EF%BC%9AKVO%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">KVO底层原理：</a> </p><h2 id="category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？重点"><a href="#category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？重点" class="headerlink" title="category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？重点"></a>category和extension的作用？分两类和扩展的区别？分类的结构体里面有什么？<strong>重点</strong></h2><ul><li><p><code>category</code> 原则上它 <code>只能增加方法</code>，<code>不能增加成员（实例）变量</code>。可以添加属性，但是不会自动生成实例变量_name和setter和getter方法。可以添加方法</p></li><li><p><code>扩展</code> 主要用来为一个类添加额外的原来没有的 <code>实例变量、方法和属性</code>。extension常用的形式并不是以一个单独的.h文件存在，而是寄生在类的.m文件中。</p></li></ul><p>类扩展中：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface Person ()&#123;</span><br><span class="line">    int age; //实例变量</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic,copy)NSString * name;//属性</span><br><span class="line">- (void)run;//方法</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><h1 id="load、initialize的区别，以及它们在category重写的时候的调用的次序？"><a href="#load、initialize的区别，以及它们在category重写的时候的调用的次序？" class="headerlink" title="load、initialize的区别，以及它们在category重写的时候的调用的次序？"></a>load、initialize的区别，以及它们在category重写的时候的调用的次序？</h1><ul><li><p>区别在于 <code>调用方式和调用时刻</code></p></li><li><p>调用方式：<br>  load是根据 <code>函数地址</code> 直接调用，initialize是通过 <code>objc_msgSend</code> 调用</p></li><li><p>调用时刻：<br>  load 是 <code>runtime加载类、分类的时候调用</code><br>  initialize 是 <code>类第一次接收到消息的时候调用</code></p></li><li><p>调用顺序：<br>  父类的load &gt; 类load &gt; 分类中load(多个分类：先编译的分类优先调用load方法)。<br>  先调父类initialize -&gt; 再调子类initialize。<br>  如果有分类：父类initialize -&gt; 分类initialize，分类覆盖类的+initialize。</p></li></ul><h1 id="super的本质？"><a href="#super的本质？" class="headerlink" title="super的本质？"></a>super的本质？</h1><ul><li>[self class] : 返回实例对象的类</li><li>[self superclass] : 返回实例对象的父类</li><li>[super class] : 编译指示器(标识符)，底层会被编译成 <code>objc_msgSendSuper()</code> 方法，返回实例对象的类</li><li>[super superclass] : 返回父类</li></ul><h1 id="简述下Objective-C中调用方法的过程？"><a href="#简述下Objective-C中调用方法的过程？" class="headerlink" title="简述下Objective-C中调用方法的过程？"></a>简述下Objective-C中调用方法的过程？</h1><p>Objective-C是动态语言，每个方法在 <code>运行时</code> 会被动态转为 <code>消息发送</code>，即：<code>objc_msgSend(receiver, selector)</code>，整个过程介绍如下：<br>person实例对象发送一条test消息：</p><ul><li><code>消息发送阶段</code>：</li></ul><p>负责从 <code>类及父类的缓存列表及方法列表查找方法</code>。每当调用方法的时候，会先去cache中查找是否有缓存的方法，如果没有缓存，在去类对象方法列表中遍历查找，如果方法不在列表里面；就会通过superclass找到父类的类对象，在去父类cache中查找是否有缓存的方法，如果没有缓存，去父类对象方法列表里面遍历查找，以此类推直到找到方法之后，就会将方法直接存储在cache中，下一次在调用这个方法的时候，就会在类对象的cache里面找到这个方法，直接调用了。</p><ul><li><code>动态方法解析</code></li></ul><p>如果消息发送阶段没有找到方法，则会进入动态解析阶段，负责动态的添加方法实现。</p><p>动态解析对象方法时，会调用：<br><code>+(BOOL)resolveInstanceMethod</code></p><p>动态解析类方法时，会调用：<br><code>+(BOOL)resolveClassMethod:(SEL)sel。</code></p><ul><li><code>快速转发阶段</code></li></ul><p>如果也没有实现动态解析方法，则会进行消息转发阶段，将消息转发给可以处理消息的接受者来处理。以处理消息的接受者来处理。<br><code>- (id)forwardingTargetForSelector:</code>由上述代码可以看出，当本类没有实现方法，并且没有动态解析方法，就会调用forwardingTargetForSelector函数，<code>进行消息转发</code>，我们可以实现forwardingTargetForSelector函数，在其内部将消息转发给可以实现此方法的对象。</p><ul><li><code>慢速转发阶段</code></li></ul><p><code>方法签名</code>：返回值类型、参数类型<br><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code></p><p>如果forwardingTargetForSelector函数返回为nil或者没有实现的话，就会调用methodSignatureForSelector方法，用来返回一个方法签名，这也是我们正确跳转方法的最后机会。</p><p>NSInvocation 封装了一个方法调用，包括：方法调用者，方法，方法的参数<br><code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code></p><p>如果methodSignatureForSelector方法返回正确的方法签名就会调用forwardInvocation方法，forwardInvocation方法内提供一个NSInvocation类型的参数，NSInvocation封装了一个方法的调用，包括方法的调用者，方法名，以及方法的参数。在forwardInvocation函数内修改方法调用对象即可。<br>如果methodSignatureForSelector返回的为nil，就会来到doseNotRecognizeSelector:方法内部，程序crash提示无法识别选择器unrecognized selector sent to instance。</p><ul><li>如果消息转发也没有实现，就会报方法找不到的错误，无法识别消息，unrecognzied selector sent to instance</li></ul><h1 id="循环引用的几种情况和解决方式？-重点"><a href="#循环引用的几种情况和解决方式？-重点" class="headerlink" title="循环引用的几种情况和解决方式？ 重点"></a>循环引用的几种情况和解决方式？ <strong>重点</strong></h1><ul><li>Block</li></ul><p>原因： <code>self</code> 强引用了 <code>block</code>，而 <code>block</code> 内部又调用了 <code>self</code><br>解决： 使用 <code>Weak-Strong Dance</code></p><ul><li>Delegate</li></ul><p>原因：委托者和被委托人之间的相互强引用问题 <code>strong</code><br>解决：用 <code>weak</code> 进行弱引用 <code>或者</code> 通过中间对象(代理对象)的方式来解决(效率更加高的中间对象NSProxy：不需要进行发送消息和动态解析，直接进行消息转发)</p><ul><li>NSTimer</li></ul><p>原因：self → timer → self(target) 的循环持有链<br>解决：在适当的时机销毁 </p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[_timer invalidate];</span><br><span class="line">_timer = nil;</span><br></pre></td></tr></table></figure></div><h1 id="OC-如何进行内存管理的？-重点"><a href="#OC-如何进行内存管理的？-重点" class="headerlink" title="OC 如何进行内存管理的？ 重点"></a>OC 如何进行内存管理的？ <strong>重点</strong></h1><ul><li><p>手动内存管理 MRC</p></li><li><p>自动内存管理 ARC</p><p>  LLVM + Runtime 会为我们代码自动插入 retain 和 release 以及 autorelease等代码,不需要我们手动管理</p></li><li><p>自动释放池</p></li></ul><h1 id="自动释放池原理-重点"><a href="#自动释放池原理-重点" class="headerlink" title="自动释放池原理 重点"></a>自动释放池原理 <strong>重点</strong></h1><ul><li><p>自动释放池的本质是 <code>__AtAutoreleasePool</code> 结构体，包含构造函数和析构函数</p></li><li><p>结构体声明，触发构造函数，调用 <code>objc_autoreleasePoolPush()</code> 函数，对象压栈</p></li><li><p>结构体出作用域，触发析构函数，调用 <code>objc_autoreleasePoolPop()</code> 函数，对象出栈</p></li></ul><h1 id="内存优化-重点"><a href="#内存优化-重点" class="headerlink" title="内存优化 重点"></a>内存优化 <strong>重点</strong></h1><ul><li>cell复用</li><li>绘制的话：用CAShaperLayer，渲染快，内存使用高效</li><li>按需加载：懒加载</li><li>合理利用缓存：比如三方图片压缩缓存</li><li>尽量使用透明View：控件有背景色增大内存消耗</li></ul><h1 id="启动优化-重点"><a href="#启动优化-重点" class="headerlink" title="启动优化 重点"></a>启动优化 <strong>重点</strong></h1><ul><li><p>pre-main 阶段：<code>二进制重排</code></p><ul><li><p>尽量 <code>少用外部动态库</code>，苹果官方建议自定义的动态库最好 <code>不要超过6个</code>，如果超过6个，需要 <code>合并</code> 动态库</p></li><li><p>减少 <code>OC</code> 类，因为类越多，越耗时</p></li><li><p>将不必须在 <code>+load</code> 方法中做的事情延迟到 <code>+initialize</code> 中，尽量不要用 <code>C++</code> 虚函数</p></li></ul></li><li><p>main 阶段：mian -&gt; didFinishLaunching</p><ul><li><p>减少启动初始化的流程，<code>能懒加载的懒加载，能延迟的延迟，能放后台初始化的放后台</code>，尽量少占用主线程的启动时间</p></li><li><p>优化代码逻辑，去除非必须的代码逻辑，减少每个流程的消耗时间</p></li><li><p>启动阶段能 <code>使用多线程</code> 来初始化的，就使用多线程</p></li><li><p>尽量 <code>使用纯代码</code> 来进行UI框架的搭建，尤其是主UI框架，例如 UITabBarController，尽量避免使用Xib或者SB，相比纯代码而言，这种更耗时</p></li><li><p>删除废弃类、方法</p></li></ul></li></ul><h2 id="卡顿监听-重点"><a href="#卡顿监听-重点" class="headerlink" title="卡顿监听 重点"></a>卡顿监听 <strong>重点</strong></h2><p><strong>主要是用 displayLink + Runloop 进行FPS监测</strong></p><p>主要从减轻 <code>CPU</code> 和 <code>GPU</code> 消耗入手，保证写一个 <code>VSync</code> 到来时，<code>CPU</code> 和 <code>GPU</code> 能够写作完成下一帧的渲染并缓存到帧缓冲区</p><ul><li>卡顿优化在 <code>CPU</code> 层面：</li></ul><p>1）尽量用轻量级的对象，比如 <code>用不到事件处理</code> 的地方，可以考虑使用 <code>CALayer</code> 取代 <code>UIView</code><br>2）不要频繁地调用 <code>UIView</code> 的相关属性，比如 <code>frame、bounds、transform</code> 等属性，尽量减少不必要的修改<br>3）尽量 <code>提前计算好布局</code>，在有需要时一次性调整对应的属性，不要多次修改属性<br>4）图片的 <code>size</code> 最好刚好跟 <code>UIImageView</code> 的 <code>size</code> 保持一致<br>5）<code>控制</code>一下线程的最大并发数量<br>6）尽量把 <code>耗时的操作放到子线程</code>：如text宽高获取等</p><ul><li>卡顿优化在 GPU层面：</li></ul><p>1）GPU能处理的 <code>最大纹理</code> 尺寸是 <code>4096x4096</code>，一旦超过这个尺寸，就会占用 <code>CPU</code> 资源进行处理，所以纹理尽量不要超过这个尺寸<br>2）尽量 <code>减少视图数量和层次</code><br>3）<code>减少透明的视图</code>（alpha&lt;1），不透明的就设置 <code>opaque</code> 为 <code>YES</code><br>4）尽量 <code>避免出现离屏渲染</code>：圆角、阴影、遮罩等</p><h2 id="tableView卡顿优化-重点"><a href="#tableView卡顿优化-重点" class="headerlink" title="tableView卡顿优化 重点"></a>tableView卡顿优化 <strong>重点</strong></h2><ul><li><p>最常用的就是<code>cell的复用</code>， 注册复用标识符</p></li><li><p><code>避免cell的重新布局</code>，初始化时就布局好</p></li><li><p><code>提前计算并缓存cell的高度</code></p></li><li><p><code>减少cell中控件的数量</code>，少动态添加 view</p></li><li><p><code>避免背景透明</code></p></li><li><p>能<code>使用局部更新</code> 的就使用 <code>局部更新</code></p></li><li><p>加载网络数据，<code>下载图片，使用异步加载</code>，并缓存</p></li><li><p><code>按需加载cell</code>：cell滚动很快时，只加载范围内的cell</p></li><li><p><code>不要实现无用的代理方法</code>，tableView只遵守两个协议</p></li></ul><h1 id="网络优化-重点"><a href="#网络优化-重点" class="headerlink" title="网络优化 重点"></a>网络优化 <strong>重点</strong></h1><ul><li>DNS优化：即域名解析优化，缓存 <code>ip</code></li><li>资源优化：<ul><li>图片webp，比png&#x2F;jpg小</li><li>数据传输用ProtocolBuffer代替json，数据小，序列化和反序列化也简单</li></ul></li><li>请求压缩、请求合并</li><li>数据缓存</li><li>网络环境监测<ul><li>针对性请求重试</li></ul></li></ul><h2 id="TCP三次握手，四次挥手过程？重点"><a href="#TCP三次握手，四次挥手过程？重点" class="headerlink" title="TCP三次握手，四次挥手过程？重点"></a>TCP三次握手，四次挥手过程？<strong>重点</strong></h2><ol><li>为什么是三次握手，而不是二次握手？</li></ol><p>三次握手是为了建立一个可靠的数据传输通道：</p><ul><li><p>刚开始客户端和服务端处于关闭状态，而且服务端B一直处于监听状态，时刻监听是否有建立连接的请求</p></li><li><p>当客户端需要建立连接的时候就会发送一个 <code>请求连接</code> 的报文，此报文是 <code>同步报文SYN=1</code>，并且会生成一个 <code>随机的序号seq=x</code>，这是第一次握手</p></li><li><p>当服务端接收到请求连接报文时，会发送一个 <code>确认连接</code> 的报文，此报文是 <code>同步报文SYN=1</code>，并且 <code>确认报文ACK=1</code>，同时服务端也会生成一个 <code>随机的序号seq=y</code>，并且将 <code>确认报文确认号ack=x+1</code>，回传给客户端，这是第二次握手</p></li><li><p>当客户端接收到服务端的 <code>ACK确认报文后</code>，会回复一个 <code>ACK确认报文</code>，用于确认确认报文已经收到，此报文 <code>ACK=1，seq=x+1，ack=y+1</code>，这是第三次握手</p></li></ul><ol start="2"><li>四次挥手</li></ol><p>四次挥手则是为了保证数据传输完成接收再关闭连接。</p><ul><li><p>客户端断开连接时会发送一个 <code>请求断开连接</code> 的报文，此报文是 <code>FIN=1</code>，并且会生成一个 <code>随机的序号seq=u</code>，发送给服务端，这是第一次挥手</p></li><li><p>服务端接收到请求断开连接 <code>FIN报文</code> 后，回复一个 <code>确认断开连接</code> 报文 <code>ACK=1,seq=v,ack=u+1</code>，这是第二次挥手</p></li><li><p>当服务端数据发送完后，再发送一个FIN报文给客户端，通知客户端，服务端准备关闭连接，此报文 <code>FIN=1,ACK=1,ack=u+1,seq=w</code>，这是第三次挥手</p></li><li><p>当客户端收到 <code>FIN确认报文</code>，再发送一个FIN确认报文 <code>ACK=1,seq=u+1,ack=w+1</code>，并进入<code> TIME-WAIT</code> 等待，等待 <code>2MSL</code> 后关闭连接，这是第四次挥手</p></li></ul><h1 id="事件链-重点"><a href="#事件链-重点" class="headerlink" title="事件链 重点"></a>事件链 <strong>重点</strong></h1><p><a href="https://www.bboyzj.cn/2023/03/01/OC%E5%AD%A6%E4%B9%A001%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%93%BE%E5%92%8C%E5%93%8D%E5%BA%94%E9%93%BE/">OC学习01：事件传递链和响应链</a></p><ul><li><p>传递链：由系统向离用户最近的view传递。<br>顺序：Appdelegate -&gt; UIApplication -&gt; UIWindow -&gt; ViewController -&gt; subViews</p></li><li><p>响应链：由离用户最近的view向系统传递。<br>顺序： superViews –&gt; ViewController –&gt; UIWindow –&gt; UIApplication –&gt; AppDelegate</p></li></ul><h1 id="事件传递的两个核心方法？-重点"><a href="#事件传递的两个核心方法？-重点" class="headerlink" title="事件传递的两个核心方法？ 重点"></a>事件传递的两个核心方法？ <strong>重点</strong></h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 返回最适合处理事件的视图</span><br><span class="line">- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;  </span><br><span class="line">// 判断点是否在这个View内部</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;</span><br></pre></td></tr></table></figure></div><ul><li>第一个方法返回的是一个 <code>UIView</code>，是用来寻找最终哪一个视图来响应这个事件</li><li>第二个方法是用来判断某一个点击的位置是否在视图范围内，如果在就返回YES</li></ul><h1 id="实现一个按钮的点击范围扩大效果-重点"><a href="#实现一个按钮的点击范围扩大效果-重点" class="headerlink" title="实现一个按钮的点击范围扩大效果 重点"></a>实现一个按钮的点击范围扩大效果 <strong>重点</strong></h1><p>自定义一个按钮，继承UIButton，重写 <code>pointInside:withEvent:</code> 方法，</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 当前btn大小</span><br><span class="line">    CGRect btnBounds = self.bounds;</span><br><span class="line">    // 扩大按钮的点击范围，增大内边距</span><br><span class="line">    btnBounds = CGRectInset(btnBounds, -10, -10);</span><br><span class="line">    // 若点击的点在新的bounds里，返回YES</span><br><span class="line">    return CGRectContainsPoint(btnBounds, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="子视图超过父视图部分仍然能响应-重点"><a href="#子视图超过父视图部分仍然能响应-重点" class="headerlink" title="子视图超过父视图部分仍然能响应 重点"></a>子视图超过父视图部分仍然能响应 <strong>重点</strong></h1><p>重写 <code>hitTest:withEvent</code> 方法，让 <code>子视图</code> 去相应事件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 判断btn能否接收事件</span><br><span class="line">    if (self.btn.userInteractionEnabled == NO || self.btn.hidden == YES || self.btn.alpha &lt;= 0.01) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 把当前点转换成btn坐标系上的点</span><br><span class="line">    CGPoint btnP = [self convertPoint:point toView:self.btn];</span><br><span class="line">    // 当触摸点在btn上时，才让按钮相应事件</span><br><span class="line">    if ([self.btn pointInside:btnP withEvent:event]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,NSStringFromCGPoint(btnP));</span><br><span class="line">        return self.btn;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;父视图相应&quot;);</span><br><span class="line">    return [super hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="SDWebImage流程"><a href="#SDWebImage流程" class="headerlink" title="SDWebImage流程"></a>SDWebImage流程</h1><ol><li>入口 <code>setImageWithURL:placeholderImage:options:</code><br>会先把 <code>placeholderImage</code> 显示，然后 <code>SDWebImageManager</code> 根据 <code>URL</code> 开始处理图片。</li><li>进入 <code>SDWebImageManagerdownloadWithURL:delegate:options:userInfo:</code>，<br>交给 <code>SDImageCache</code> 从缓存查找图片是否已经下载<br><code>queryDiskCacheForKey:delegate:userInfo:</code></li><li>先从内存图片 <code>缓存查找</code> 是否有图片，如果内存中已经有图片缓存，<code>SDImageCacheDelegate</code> 会调用  <code>imageCache:didFindImage:forKey:userInfo:</code> 到 <code>SDWebImageManager</code>。</li><li><code>SDWebImageManagerDelegate</code> 会调 <code>webImageManager:didFinishWithImage:</code> 到 <code>UIImageView+WebCache</code> 等前端展示图片。</li><li>如果 <code>内存缓存中没有</code>，生成 <code>NSInvocationOperation</code> 添加到队列开始从 <code>硬盘查找</code> 图片是否已经缓存。</li><li>根据 <code>URLKey</code> 在硬盘缓存目录下尝试 <code>读取图片文件</code>，这一步是在 <code>NSOperation</code> 进行的操作，所以回主线程进行结果回调 <code>notifyDelegate</code>。</li><li>如果上一操作 <code>从硬盘读取到了图片</code>，将 <code>图片添加到内存缓存</code> 中（如果空闲内存过小，会先清空内存缓存）。<code>SDImageCacheDelegate</code> 回调<code>imageCache:didFindImage:forKey:userInfo:</code>，进而回调展示图片。</li><li>如果从 <code>硬盘缓存目录读取不到图片</code>，说明所有缓存都不存在该图片，需要 <code>下载图片</code>，<br>回调 <code>imageCache:didNotFindImageForKey:userInfo:</code>。</li><li>共享或重新生成一个下载器 <code>SDWebImageDownloader</code> 开始下载图片。</li><li>图片下载由 <code>NSURLConnection</code> 来做，实现相关 <code>delegate</code> 来判断图片下载中、下载完成和下载失败。</li><li><code>connection:didReceiveData:</code> 中利用 <code>ImageIO</code> 做了按图片下载进度加载效果。</li><li><code>connectionDidFinishLoading:</code> 数据下载完成后交给 <code>SDWebImageDecoder</code> 做图片解码处理。</li><li>图片解码处理在一个 <code>NSOperationQueue</code> 完成，不会拖慢主线程 <code>UI</code>。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。</li><li>在主线程 <code>notifyDelegateOnMainThreadWithInfo:</code> 宣告解码完成，<code>imageDecoder:didFinishDecodingImage:userInfo:</code> 回调给 <code>SDWebImageDownloader</code>。</li><li><code>imageDownloader:didFinishWithImage:</code> 回调给 <code>SDWebImageManager</code> 告知图片下载完成。</li><li>通知所有的 <code>downloadDelegates</code> 下载完成，回调给需要的地方展示图片。</li><li>将图片保存到 <code>SDImageCache</code> 中，<code>内存缓存和硬盘缓存同时保存</code>。写文件到硬盘也在以单独 <code>NSInvocationOperation</code> 完成，避免拖慢主线程。</li><li><code>SDImageCache</code> 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。<br>19）SDWebImage 也提供了 <code>UIButton+WebCache</code> 和 <code>MKAnnotationView+WebCache</code>，方便使用。<br>20）<code>SDWebImagePrefetcher</code> 可以预先下载图片，</li></ol><p><strong>缓存策略：</strong></p><ul><li><p>它的底层是用 <code>NSCache</code> 在实现的，<code>NSCache</code> 是 <code>Foundation框架</code> 提供的缓存类的实现，它是线程安全的。在内存不足时NSCache会自动释放存储的对象。key是不会重复的。</p></li><li><p>SDWebImage的缓存策略：缓存有关的一共有四个文件 <code>SDImageCacheConfig和SDImageCache，SDImageCacheConfig配置类</code>，保存一些缓存策略的信息（压缩图片-YES、iCloud备份-关闭、内存做缓存-YES、<code>最长时间默认1周</code>、缓存占用最大的空间-字节），</p></li><li><p>SDImageCache通过 <code>url作为key</code>，<code>UIImage作为value存到内存</code>。并开启异步串行队列将图片编码存储到磁盘中defalut文件下，key为url做了MD5加密并拼接defalut路径为绝对路径。</p></li></ul><h1 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h1><p>AFNetworking 底层原理分析：<br>AFNetworking主要是对 <code>NSURLSession</code> 的封装,<br>其中主要有以下类: </p><ul><li><code>AFHTTPSessionManager</code>：内部封装是 <code>NSURLSession</code>, <code>负责发送⽹络请求</code>，使<br>⽤最多的⼀个类。</li><li><code>AFNetworkReachabilityManager</code>：实时监测⽹络状态的⼯具类。当前的⽹络环<br>境发⽣改变之后,这个⼯具类就可以检测到。</li><li><code>AFSecurityPolicy</code>：⽹络安全的⼯具类, 主要是针对 <code>HTTPS</code> 服务。</li><li><code>AFURLRequestSerialization</code>：序列化⼯具类</li><li><code>AFURLResponseSerialization</code>：反序列化⼯具类</li><li><code>AFJSONResponseSerializer</code>：JSON解析器，默认的解析器.</li><li><code>AFHTTPResponseSerializer</code>：万能解析器， JSON和XML之外的数据类型，直接返<br>回⼆进制数据，对服务器返回的数据不做任何处理.</li></ul><h2 id="MJEetension"><a href="#MJEetension" class="headerlink" title="MJEetension"></a>MJEetension</h2><p>主要作用是将 <code>json -&gt; Model</code>，主要分为三步</p><ul><li>创建模型</li><li>为模型中的属性赋值</li><li>返回模型</li></ul><p>原理： </p><ul><li>使用 <code>Runtime</code> 动态获取模型的类和其所有父类的所有的 <code>属性名</code>（包括继承链的所有属性，MJExtension对模型的属性做了 <code>缓存</code>，下次转换时自己使用，空间换时间）</li><li>将服务器返回的 <code>json数据转为字典</code>，并根据属性名在数据字典中获取对应的 <code>值</code></li><li>将取出的值使用 <code>KVC</code>（setValue:forKey）设置给 <code>Model</code> 即可</li></ul><p>主要是用runtime API是实现的数据解析，将字典转模型</p><h2 id="MJRefresh"><a href="#MJRefresh" class="headerlink" title="MJRefresh"></a>MJRefresh</h2><p>下拉刷新的基本原理：<br>大部分的下拉刷新控件，都是用 <code>contentInset</code> 实现的。大部分的下拉刷新控件，都是将自己放在 <code>UIScrollView</code> 的上方，起始y设置成负数，所以平时不会显示出来，只有下拉的时候才会出现，放开又会弹回去。然后在loading的时候，临时把contentInset增大，相当于把UIScrollView往下挤，于是下拉刷新的控件就会显示出来，然后刷新完成之后，再把contentInset改回原来的值，实现回弹的效果</p><ul><li>通过 <code>UIScrollView+MJRefresh</code> 里的一个category，为UIScrollView增加了属性header和footer。</li><li>通过 <code>KVO</code> 监听UIScrollView的contentOffset和contentSize实现状态监听</li><li>下拉的时候临时增大contentInset，令header保留在屏幕上。上拉同理。</li></ul><h1 id="项目面试题"><a href="#项目面试题" class="headerlink" title="项目面试题"></a>项目面试题</h1><h2 id="直播功能怎么实现的？"><a href="#直播功能怎么实现的？" class="headerlink" title="直播功能怎么实现的？"></a>直播功能怎么实现的？</h2><p>直播间是通过集成金山云SDK实现的，分为两端 <code>主播</code> 和 <code>观众</code></p><ul><li>主播</li></ul><p>通过 <code>推流</code> 创建直播间，通过 <code>摄像头和麦克风</code> 获取 <code>音视频流</code> ，设置 <code>推流参数</code>，主要是 视频编码器和音频编码率的设置，设置完推流参数之后，将流媒体推送服务器</p><ul><li>观众</li></ul><p>进入直播间，初始化播放器，从服务器获取播放拉流的数据 </p><h2 id="直播间的聊天IM实现？"><a href="#直播间的聊天IM实现？" class="headerlink" title="直播间的聊天IM实现？"></a>直播间的聊天IM实现？</h2><ul><li><p>聊天功能是使用的融云SDK，通过加入聊天室实现的。</p></li><li><p>融云SDK实现了私聊的功能</p></li><li><p>自己写的聊天页面，通过 <code>融云接口</code> 传入参数 <code>会话类型：单聊、群组。聊天室等</code>，目标会话ID），消息数量，获取某个会话的内容。发送文本消息、图片消息，监听消息，刷新列表</p></li></ul><h1 id="面试官问还有什么想问的？-重点"><a href="#面试官问还有什么想问的？-重点" class="headerlink" title="面试官问还有什么想问的？ 重点"></a>面试官问还有什么想问的？ <strong>重点</strong></h1><p>技术面不问薪资待遇，人事面问薪资待遇</p><ul><li>问岗位：</li></ul><ol><li>在这个岗位上，会直接 <code>接触到哪些类型的项目？</code></li><li>这个岗位的主要职责是什么？主要的KPI是什么？</li><li>这个岗位如何评估绩效，试用期需要达到什么指标？</li><li>这个岗位的最大挑战是什么？</li></ol><ul><li>问团队：</li></ul><ol><li><code>团队的基本情况？</code></li><li>这个团队在公司的角色是什么？</li><li>可以跟我介绍一下我的领导吗？</li></ol><ul><li>问公司</li></ul><ol><li><code>公司的文化氛围是什么样的？</code></li><li>员工的晋升机制是什么样的？我这个岗位的晋升机会如何？</li><li>这个岗位所在的团队如何支持公司目标的实现？</li></ol>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog-04：主题完善</title>
      <link href="/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-04%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/"/>
      <url>/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-04%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们以 <a href="https://github.com/shenliyang/hexo-theme-snippet">Snippet</a> 主题问例</p><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ git clone git://github.com/shenliyang/hexo-theme-snippet.git themes/hexo-theme-snippet</span><br></pre></td></tr></table></figure><h1 id="安装主题插件"><a href="#安装主题插件" class="headerlink" title="安装主题插件"></a>安装主题插件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S</span><br></pre></td></tr></table></figure><h1 id="部署主题"><a href="#部署主题" class="headerlink" title="部署主题"></a>部署主题</h1><p>具体部署看下面的链接：1、2、3步骤可省略</p><p><a href="https://github.com/shenliyang/hexo-theme-snippet">Snippet</a> </p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog-03：Github域名绑定阿里云域名</title>
      <link href="/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-03%EF%BC%9AGithub%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/"/>
      <url>/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-03%EF%BC%9AGithub%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="注册域名"><a href="#注册域名" class="headerlink" title="注册域名"></a>注册域名</h1><p>去 <a href="https://dc.console.aliyun.com/">阿里云</a> 注册账号、并购买域名，具体流程这里就不一一介绍了</p><h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><ul><li>在终端 <code>ping</code> 一下之前配置的静态页面地址,可以获取到对应的ip地址:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % ping BboyZJ.github.io</span><br><span class="line">PING bboyzj.github.io (185.199.109.153): 56 data bytes</span><br><span class="line">64 bytes from 185.199.109.153: icmp_seq=0 ttl=50 time=261.217 ms</span><br><span class="line">64 bytes from 185.199.109.153: icmp_seq=1 ttl=50 time=337.547 ms</span><br><span class="line">64 bytes from 185.199.109.153: icmp_seq=2 ttl=50 time=260.716 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>@解析</li></ul><p>记录类型：A<br>主机记录：@<br>解析请求来源：默认<br>记录值：185.199.109.153<br>TTL：10分钟</p><p>点击确定</p><ul><li>www解析</li></ul><p>记录类型：CNAME<br>主机记录：www<br>解析线路来源：默认<br>记录值：BboyZJ.github.io<br>TTL：10分钟</p><p>点击确定</p><ul><li>配置项目 <code>CNAME</code></li></ul><p>在 <code>Blog/source</code> 目录下，新建 <code>CNAME</code> 文件，内容输入阿里云申请的域名 <a href="http://www.bboyzj.cn/">www.bboyzj.cn</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/Blog/source </span><br><span class="line">mac@bogon source % touch CNAME</span><br></pre></td></tr></table></figure><ul><li>配置 <code>Blog</code> 目录下 <code>_config.yml</code> 文件，<code>URL</code> 模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="line">url: https://www.bboyzj.cn</span><br><span class="line">root: /BboyZJ.github.io/</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></pre></td></tr></table></figure><ul><li>执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % hexo clean</span><br><span class="line">mac@bogon ~ % hexo g</span><br><span class="line">mac@bogon ~ % hexo d</span><br></pre></td></tr></table></figure><p>提交陈成功后，就可以在 <code>GitHub</code> 和 <a href="http://www.bboyzj.cn/">www.bboyzj.cn</a> 个人域名绑定上了</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog-02：部署博客到GitHub</title>
      <link href="/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-02%EF%BC%9A%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0GitHub/"/>
      <url>/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-02%EF%BC%9A%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0GitHub/</url>
      
        <content type="html"><![CDATA[<h1 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h1><p>前往 <a href="https://github.com/">Github</a> 网站，注册一个新用户。用邮箱注册的一定前往邮箱去验证邮件。</p><h1 id="部署到-GitHub-上"><a href="#部署到-GitHub-上" class="headerlink" title="部署到 GitHub 上"></a>部署到 GitHub 上</h1><ul><li>新建 <code>reponsity</code> 仓库</li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150615592.png"></p><p>仓库名设置成 <code>用户名.github.io</code> ，比如我的是 <code>BboyZJ.github.io</code>，选择 Public，勾选 <code>Add a README file</code> ，最后 <code>Create respository</code></p><h1 id="配置秘钥"><a href="#配置秘钥" class="headerlink" title="配置秘钥"></a>配置秘钥</h1><ul><li>查看秘钥</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">$ cat id_rsa.pub</span><br></pre></td></tr></table></figure><ul><li>添加SSH秘钥：头像 -&gt; Setting -&gt; SSH and GPG keys</li></ul><p><code>Title</code> 随意写，<code>Key</code> 需要填写刚才复制的 <code>秘钥</code> 文本内容</p><ul><li>添加完成，验证链接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">Hi BboyZJ! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><h1 id="上传文件到-GitHub"><a href="#上传文件到-GitHub" class="headerlink" title="上传文件到 GitHub"></a>上传文件到 GitHub</h1><ul><li>配置 <code>Blog</code> 下 <code>_config.yml</code> 中的 <code>Deployment</code> 模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/BboyZJ/BboyZJ.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><ul><li>安装部署插件</li></ul><p>通过 <code>Hexo</code> 发布到 <code>GitHub</code>，需要安装部署插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ul><li>部署</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/Blog</span><br><span class="line">mac@bogon ~ % hexo g</span><br><span class="line">mac@bogon ~ % hexo d</span><br></pre></td></tr></table></figure><ul><li>访问</li></ul><p>这时我们的 <code>GitHub</code> 域名 <code>https://BboyZJ.github.io</code> 就可以看到 <code>Hexo</code> 网站了，如果没显示出来就 <code>刷新</code> 一下</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog-01：Hexo个人博客搭建</title>
      <link href="/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-01%EF%BC%9AHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/BboyZJ.github.io/2023/03/01/Blog%E6%90%AD%E5%BB%BA/Blog-01%EF%BC%9AHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><ul><li>什么是Hexo？</li></ul><p>简介：<code>Hexo</code> 是一个快速、简洁且高效的博客框架。想要详细的了解 <a href="https://hexo.io/zh-cn/docs/">Hexo</a>，去官网学习。<code>Hexo</code> 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h1 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h1><ul><li>检查是否安装 <code>homebrew</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % brew -v</span><br><span class="line">Homebrew 3.6.21-28-ge6548a8</span><br><span class="line">Homebrew/homebrew-core (git revision 5434c8344e8; last commit 2023-02-09)</span><br><span class="line">Homebrew/homebrew-cask (git revision 15c2c1fa53; last commit 2023-02-09)</span><br><span class="line">mac@bogon ~ % </span><br></pre></td></tr></table></figure><p>如果顺利显示版本号，说明homebrew已经安装。否则，输入以下命令进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><ul><li>安装过程如果出现下面的问题</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</span><br></pre></td></tr></table></figure><p>解决:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % /usr/bin/ruby -e &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)&quot;</span><br></pre></td></tr></table></figure><ul><li>安装 <code>Node.js</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % brew install node</span><br><span class="line">mac@bogon ~ % node -v</span><br><span class="line">v18.14.2</span><br></pre></td></tr></table></figure><ol start="3"><li>安装Git<br>Mac系统默认已经安装好了，所以不需要再安装</li></ol><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往安装 <code>Hexo</code> 步骤。</p><ul><li>使用npm完成 <code>hexo</code> 安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % npm install -g hexo-cli</span><br><span class="line">mac@bogon ~ % hexo -v</span><br><span class="line"></span><br><span class="line">hexo-cli: 4.1.0</span><br><span class="line">os: Darwin 21.6.0 darwin x64</span><br><span class="line">node: 12.16.1</span><br><span class="line">v8: 7.8.279.23-node.31</span><br><span class="line">uv: 1.34.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.7</span><br><span class="line">ares: 1.15.0</span><br><span class="line">modules: 72</span><br><span class="line">nghttp2: 1.40.0</span><br><span class="line">napi: 5</span><br><span class="line">llhttp: 2.0.4</span><br><span class="line">http_parser: 2.9.3</span><br><span class="line">openssl: 1.1.1d</span><br><span class="line">cldr: 35.1</span><br><span class="line">icu: 64.2</span><br><span class="line">tz: 2019c</span><br><span class="line">unicode: 12.1</span><br><span class="line">mac@bogon ~ % </span><br></pre></td></tr></table></figure><h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><ul><li>桌面新建 <code>Blog</code> 文件夹，打开终端，cd到 <code>Blog</code> 下，执行:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/Blog </span><br><span class="line">mac@bogon Blog % hexo init</span><br><span class="line"></span><br><span class="line">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class="line">INFO  Install dependencies</span><br><span class="line">npm notice </span><br><span class="line">npm notice New major version of npm available! 7.3.0 -&gt; 9.5.1</span><br><span class="line">npm notice Changelog: https://github.com/npm/cli/releases/tag/v9.5.1</span><br><span class="line">npm notice Run npm install -g npm@9.5.1 to update!</span><br><span class="line">npm notice </span><br><span class="line">INFO  Start blogging with Hexo!</span><br><span class="line">mac@bogon Blog % </span><br></pre></td></tr></table></figure><p>【目录文件】：</p><p>_config.landscape.yml：网站本地配置信息<br>_config.yml：网站的配置信息，可以在此配置大部分的参数<br>source–posts：存放 <code>md</code> 文件<br>themes：主题文件夹，<a href="https://hexo.io/themes/%20">常用主题</a> 会放入这里<br>public：Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去</p><h1 id="hexo-测试"><a href="#hexo-测试" class="headerlink" title="hexo 测试"></a>hexo 测试</h1><ul><li>生成静态页面</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % hexo g</span><br></pre></td></tr></table></figure><p>会在根目录 <code>Blog\</code> 下生成 <code>public</code> 文件夹，里面包含相应的 <code>html</code> 页面。</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150614715.png"></p><ul><li>启动服务器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % hexo s</span><br></pre></td></tr></table></figure><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150614023.png"></p><p>打开浏览器，输入网址: <a href="http://localhost:4000/">http://localhost:4000</a> ，即可看到hexo生成的静态页面。</p><ul><li>停止服务器</li></ul><p><code>Ctrl + C</code></p><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>hexo提供了很多主题可以参考，下面以 <a href="https://github.com/littlewin-wang/hexo-theme-casual.git">hexo-theme-casual</a> 主题为例</p><ul><li>安装主题插件</li></ul><blockquote><p><a href="https://github.com/EvanNotFound/hexo-theme-redefine">hexo-theme-redefine</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/littlewin-wang/hexo-theme-casual">hexo-theme-casual</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ npm install --save hexo-renderer-jade hexo-renderer-scss hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-generator-search</span><br></pre></td></tr></table></figure><blockquote><p> <a href="https://github.com/shenliyang/hexo-theme-snippet">hexo-theme-snippet</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ npm i hexo-renderer-ejs hexo-renderer-less hexo-deployer-git -S</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/jerryc127/hexo-theme-butterfly">hexo-theme-butterfly</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % $ git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line">mac@bogon Blog % $ npm install hexo-renderer-pug hexo-renderer-stylus</span><br></pre></td></tr></table></figure><ul><li>下载主题</li></ul><p>进入主题的 <code>github</code> 下载页，点击 <code>code -&gt; clone</code>，复制 <code>https</code> 下载链接，进入 博库Blog目录，运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % cd /Users/mac/Desktop/Blog </span><br><span class="line">mac@bogon Blog % cd themes </span><br><span class="line">mac@bogon themes % git clone https://github.com/littlewin-wang/hexo-theme-casual.git</span><br></pre></td></tr></table></figure><p>【注】：主题存放的目录是 <code>Blog/themes</code>，为了方便管理，每一个下载的主题都建一个单独的目录，我这个主题的目录是 <code>hexo-theme-casual</code>，可以下载多个主题:</p><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150614295.png"></p><ul><li>主题应用</li></ul><p>找到 <code>博客Blog</code> 目录下的配置文件 <code>_config.yml</code>，找到 <code>Extensions</code> 模块，修改 <code>theme</code> 字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: hexo-theme-casual</span><br></pre></td></tr></table></figure><ul><li>启动本地服务器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % hexo s</span><br><span class="line"></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br><span class="line">[Browsersync] Access URLs:</span><br><span class="line"> ----------------------------------</span><br><span class="line">          UI: http://localhost:3001</span><br><span class="line"> ----------------------------------</span><br><span class="line"> UI External: http://localhost:3001</span><br><span class="line"> ----------------------------------</span><br></pre></td></tr></table></figure><ul><li>查看效果</li></ul><p>通过 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看修改后的效果</p><ul><li>主题更新</li></ul><p>这一步不是必须的，如果主题有优化，我们需要在本地同步更新一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon Blog % /Users/mac/Desktop/Blog/themes/casual </span><br><span class="line">mac@bogon Blog % git pull</span><br></pre></td></tr></table></figure><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><ul><li>清除旧的内容</li></ul><p><code>hexo clean</code></p><ul><li>生成静态发布页面</li></ul><p><code>hexo g</code></p><ul><li>发布页面</li></ul><p><code>hexo d</code></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC架构00：MVVM双向数据绑定</title>
      <link href="/BboyZJ.github.io/2023/02/27/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A000%EF%BC%9AMVVM%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
      <url>/BboyZJ.github.io/2023/02/27/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A000%EF%BC%9AMVVM%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="MVVM-是什么？"><a href="#MVVM-是什么？" class="headerlink" title="MVVM 是什么？"></a>MVVM 是什么？</h1><p>MVVM 包含三部分：</p><ul><li><p>Model：模型层，主要是存放数据</p></li><li><p>View：视图层，UI 绘制</p></li><li><p>ViewModel：业务逻辑处理层，将 <code>Model</code> 和 <code>View</code> 分开，可以取出 <code>Model</code> 的数据，同时处理 <code>View</code> 要展示的内容涉及的业务逻辑</p></li><li><p>MVVM 采用双向数据绑定：</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172104626.png"                                     ></p><h1 id="MVVM-优劣"><a href="#MVVM-优劣" class="headerlink" title="MVVM 优劣"></a>MVVM 优劣</h1><ul><li><p>优势</p><ul><li>代码清晰：<code>ViewModel</code> 分离大部分 <code>VC</code> 代码</li><li>方便测试：可对 <code>ViewModel</code> 构造单元测试</li><li>开发解耦：一位开发者负责逻辑实现，一位开发者负责 <code>UI</code> 实现</li></ul></li><li><p>劣势</p><ul><li>代码量多，需要对每个 <code>Controller</code> 实现绑定</li></ul></li></ul><h1 id="实战思路"><a href="#实战思路" class="headerlink" title="实战思路"></a>实战思路</h1><ul><li>VC 下代码</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJTwoViewController.h&quot;</span><br><span class="line">#import &quot;ZJTwoViewModel.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ZJTwoViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic,strong)UIButton * btn;</span><br><span class="line">@property (nonatomic,strong)ZJTwoViewModel * viewModel;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ZJTwoViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];;</span><br><span class="line"></span><br><span class="line">    // 绑定VC</span><br><span class="line">    self.viewModel = [[ZJTwoViewModel alloc] initWithVC:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>Model下代码</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJTwoModel : NSObject</span><br><span class="line">@property (nonatomic,copy)NSString * name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ZJTwoModel</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><ul><li>View 下代码</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@protocol ZJTwoViewDelegate &lt;NSObject&gt;</span><br><span class="line">- (void)doSomethings;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface ZJTwoView : UIView</span><br><span class="line">// 有用VM</span><br><span class="line">@property (nonatomic,weak)ZJTwoViewModel * viewModel;</span><br><span class="line">// 设置代理</span><br><span class="line">@property (nonatomic,weak)id&lt;ZJTwoViewDelegate&gt;delegate;</span><br><span class="line"></span><br><span class="line">// 自身控件</span><br><span class="line">@property (nonatomic,strong)UILabel * label;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div><p>.m 文件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJTwoView.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZJTwoView</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame&#123;</span><br><span class="line">    self = [super initWithFrame:frame];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        [self addSubview:self.label];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -lazy</span><br><span class="line">- (UILabel *)label&#123;</span><br><span class="line">    if (!_label) &#123;</span><br><span class="line">        _label = [[UILabel alloc] initWithFrame:CGRectMake(20, 40, self.frame.size.width - 40, self.frame.size.height - 80)];</span><br><span class="line">        _label.backgroundColor = [UIColor orangeColor];</span><br><span class="line">        _label.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">    &#125;</span><br><span class="line">    return _label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 代理</span><br><span class="line">    if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(doSomethings)]) &#123;</span><br><span class="line">        [self.delegate doSomethings];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重写 setter 方法，监听来自 viewModel 的数据</span><br><span class="line">- (void)setViewModel:(ZJTwoViewModel *)viewModel&#123;</span><br><span class="line">    // 获取数据</span><br><span class="line">    _viewModel = viewModel;</span><br><span class="line">    /*</span><br><span class="line">     实现监听</span><br><span class="line">     比如 RAC（好多公司都使用MVVM+RAC两者搭配）</span><br><span class="line">     */</span><br><span class="line">    RACSignal * signal = [viewModel rac_valuesForKeyPath:@&quot;name&quot; observer:self];</span><br><span class="line">    [signal subscribeNext:^(NSString * name) &#123;</span><br><span class="line">        NSLog(@&quot;name=%@&quot;,name);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><ul><li>ViewModel 下代码</li></ul><p>.h 文件</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface ZJTwoViewModel : NSObject</span><br><span class="line">// 入口方法</span><br><span class="line">- (instancetype)initWithVC:(UIViewController *)controller;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>.m 下代码</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJTwoViewModel.h&quot;</span><br><span class="line">#import &quot;ZJTwoView.h&quot;</span><br><span class="line">#import &quot;ZJTwoModel.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ZJTwoViewModel ()&lt;UITextFieldDelegate,ZJTwoViewDelegate&gt;</span><br><span class="line">// VC</span><br><span class="line">@property (nonatomic,weak)UIViewController * vc;</span><br><span class="line">// Model</span><br><span class="line">@property (nonatomic,strong)ZJTwoModel * model;</span><br><span class="line">// View</span><br><span class="line">@property (nonatomic,strong)ZJTwoView * view;</span><br><span class="line"></span><br><span class="line">// TF</span><br><span class="line">@property (nonatomic,strong)UITextField * tf;</span><br><span class="line">// model.name绑定的name</span><br><span class="line">@property (nonatomic,copy)NSString * name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ZJTwoViewModel</span><br><span class="line">// 入口方法：绑定一个 VC 并实现业务逻辑</span><br><span class="line">- (instancetype)initWithVC:(UIViewController *)controller&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        // 绑定控制器</span><br><span class="line">        self.vc = controller;</span><br><span class="line">        // 初始化UI</span><br><span class="line">        [self initUI];</span><br><span class="line">        // 初始化RAC</span><br><span class="line">        [self initRAC];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -initUI</span><br><span class="line">- (void)initUI&#123;</span><br><span class="line">    // 添加视图</span><br><span class="line">    [self.vc.view addSubview:self.view];</span><br><span class="line">    </span><br><span class="line">    // View和ViewModel双向绑定</span><br><span class="line">    self.view.viewModel = self;</span><br><span class="line">    // 代理</span><br><span class="line">    self.view.delegate = self;</span><br><span class="line">    </span><br><span class="line">    // 模型</span><br><span class="line">    self.model = [ZJTwoModel new];</span><br><span class="line">    self.model.name = @&quot;ZJ&quot;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 核心思想 V/M 能够拥有VC，但两者独立，互不影响</span><br><span class="line">    // 将Model绑定到VM上</span><br><span class="line">    self.name = self.model.name;</span><br><span class="line">    </span><br><span class="line">    // 验证监听：动态检测文本内容</span><br><span class="line">    [self.vc.view addSubview:self.tf];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -监听</span><br><span class="line">- (void)initRAC&#123;</span><br><span class="line">    // 监听视图出现的事件</span><br><span class="line">    [[self.vc rac_signalForSelector:@selector(viewWillAppear:)] subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;viewWillAppear&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -&lt;UITextFieldDelegate&gt;</span><br><span class="line">// 动态检测文本框内容</span><br><span class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string&#123;</span><br><span class="line">    </span><br><span class="line">    [textField addTarget:self action:@selector(textFieldDidChange:) forControlEvents:UIControlEventEditingChanged];</span><br><span class="line">    </span><br><span class="line">    return YES;;</span><br><span class="line">&#125;</span><br><span class="line">// 动态文本</span><br><span class="line">- (void)textFieldDidChange:(id)sender&#123;</span><br><span class="line">    UITextField * tf = (UITextField *)sender;</span><br><span class="line">    // 变更数据：</span><br><span class="line">//    self.name = tf.text;</span><br><span class="line">    </span><br><span class="line">    // 直接改变模型</span><br><span class="line">    self.model.name = tf.text;</span><br><span class="line">    // 更新UI</span><br><span class="line">    self.view.label.text = self.model.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -ZJTwoViewDelegate</span><br><span class="line">- (void)doSomethings&#123;</span><br><span class="line">    NSLog(@&quot;doSomethings&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -lazy</span><br><span class="line">- (ZJTwoView *)view&#123;</span><br><span class="line">    if (!_view) &#123;</span><br><span class="line">        _view = [[ZJTwoView alloc] initWithFrame:CGRectMake(30, 80, kScreenWidth - 60, 200)];</span><br><span class="line">        _view.backgroundColor = [UIColor redColor];</span><br><span class="line">    &#125;</span><br><span class="line">    return _view;</span><br><span class="line">&#125;</span><br><span class="line">- (UITextField *)tf&#123;</span><br><span class="line">    if (!_tf) &#123;</span><br><span class="line">        _tf = [[UITextField alloc] initWithFrame:CGRectMake(50, 500, kScreenWidth - 100, 50)];</span><br><span class="line">        _tf.clearButtonMode = UITextFieldViewModeWhileEditing;</span><br><span class="line">        _tf.textColor = [UIColor whiteColor];</span><br><span class="line">        _tf.placeholder = @&quot;点击更改&quot;;</span><br><span class="line">        _tf.backgroundColor = [UIColor redColor];</span><br><span class="line">        _tf.delegate = self;</span><br><span class="line">    &#125;</span><br><span class="line">    return _tf;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理15.5：dyld发展史</title>
      <link href="/BboyZJ.github.io/2023/02/26/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8615-2%EF%BC%9Adyld%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
      <url>/BboyZJ.github.io/2023/02/26/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8615-2%EF%BC%9Adyld%E5%8F%91%E5%B1%95%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="dyld简介"><a href="#dyld简介" class="headerlink" title="dyld简介"></a>dyld简介</h1><ul><li><p>dyld全名 The dynamic link editor；</p></li><li><p>是苹果的动态链接器；</p></li><li><p>是苹果操作系统的一个重要组成部分；</p></li><li><p>在应用被编译打包成可执行文件之后（即Mach-O），将其交由dyld负责链接，加载程序。</p></li><li><p>dyld贯穿了App启动的过程，包含加载依赖库、主程序，如果我们需要进行性能优化、启动优化等，不可避免的需要和dyld打交道</p></li><li><p>且dyld是开源的，我们可以在官网下载它的源码来阅读理解</p></li></ul><h1 id="dyld-1-0（1996-2004）"><a href="#dyld-1-0（1996-2004）" class="headerlink" title="dyld 1.0（1996-2004）"></a>dyld 1.0（1996-2004）</h1><ul><li><p>dyld 1包含在NeXTStep 3.3中，在此之前的NeXT使用静态二进制数据。作用并不是很大，</p></li><li><p>dyld 1是在系统广泛使用C++动态库之前编写的，由于C++有许多特性，例如其初始化器的工作，在静态环境工作良好，但是在动态环境中可能会降低性能。因此大型的C++动态库会导致dyld需要完成大量的工作，速度变慢</p></li><li><p>在发布macOS 10.0和Cheetah前，还增加了一个特性，即Prebinding预绑定。我们可以使用Prebinding技术为系统中的所有dylib和应用程序找到固定的地址。dyld将会加载这些地址的所有内容。如果加载成功，将会编辑所有dylib和程序的二进制数据，来获得所有预计算。当下次需要将所有数据放入相同地址时就不需要进行额外操作了，将大大的提高速度。但是这也意味着每次启动都需要编辑这些二进制数据，至少从安全性来说，这种方式并不友好。</p></li></ul><h1 id="dyld-2（2004-2017）"><a href="#dyld-2（2004-2017）" class="headerlink" title="dyld 2（2004-2017）"></a>dyld 2（2004-2017）</h1><ul><li>dyld 2从2004年发布至今，已经经过了多个版本迭代，我们现在常见的一些特性，例如ASLR、Code Sign、share cache等技术，都是在dyld 2中引入的</li></ul><h1 id="dyld-2-0（2004-2007）"><a href="#dyld-2-0（2004-2007）" class="headerlink" title="dyld 2.0（2004-2007）"></a>dyld 2.0（2004-2007）</h1><ul><li><p>2004年在macOS Tiger中推出了dyld 2</p></li><li><p>dyld 2是dyld 1完全重写的版本，可以正确支持C++初始化器语义，同时扩展了mach-o格式并更新dyld。从而获得了高效率C++库的支持。</p></li><li><p>dyld 2具有完成的dlopen和dlsym（主要用于动态加载库和调用函数）实现，且具有正确的语义，因此弃用了旧版的API</p><ul><li><p>dlopen：打开一个库，获取句柄</p></li><li><p>dlsym：在打开的库中查找符号的值</p></li><li><p>dlclose：关闭句柄。</p></li><li><p>dlerror：返回一个描述最后一次调用dlopen、dlsym，或 dlclose 的错误信息的字符串。</p></li></ul></li><li><p>dyld 的 <code>设计目标</code> 是 <code>提升启动速度</code>。因此仅进行有限的健全性检查。主要是因为以前的恶意程序比较少</p></li><li><p>同时dyld也有一些安全问题，因此对一些功能进行了改进，来提高dyld在平台上的安全性</p></li><li><p>由于启动速度的大幅提升，因此我们可以减少Prebinding的工作量。与编辑程序数据的区别在于，在这里我们仅编辑系统库，且可以仅在软件更新时做这些事情。因此在软件更新过程中，可能会看到“优化系统性能”类似的文字。这就是在更新时进行Prebinding。现在dyld用于所有优化，其用途就是优化。因此后面有了dyld 2</p></li></ul><h1 id="dyld-2-x（2007-2017）"><a href="#dyld-2-x（2007-2017）" class="headerlink" title="dyld 2.x（2007-2017）"></a>dyld 2.x（2007-2017）</h1><ul><li><p>在2004-20017这几年间进行了大量改进，dyld 2的性能显著提高</p></li><li><p>首先，增加了大量的基础架构和平台。</p><ul><li><p>自从dyld 2在PowerPC发布之后，增加了x86、x86_64、arm、arm64和许多的衍生平台。</p></li><li><p>还推出了iOS、tvOS和watchOS，这些都需要新的dyld功能</p></li></ul></li><li><p>通过多种方式增加安全性</p><ul><li><p>增加 codeSigning代码签名、</p></li><li><p>ASLR（Address space layout randomization）地址空间配置随机加载：每次加载库时，可能位于不同的地址</p></li><li><p>bound checking边界检查：mach-o文件中增加了Header的边界检查功能，从而避免恶意二进制数据的注入</p></li></ul></li><li><p>增强了性能</p><ul><li>可以消除Prebinding，用share cache共享代码代替</li></ul></li></ul><h1 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h1><ul><li><p>ASLR是一种防范内存损坏漏洞被利用的计算机安全技术，ASLR通过随机放置进程关键数据区域的地址空间来防止攻击者跳转到内存特定位置来利用函数</p></li><li><p>Linux已在内核版本2.6.12中添加ASLR</p></li><li><p>Apple在Mac OS X Leopard 10.5（2007年十月发行）中某些库导入了随机地址偏移，但其实现并没有提供ASLR所定义的完整保护能力。而Mac OS X Lion 10.7则对所有的应用程序均提供了ASLR支持。</p></li><li><p>Apple在iOS 4.3内导入了ASLR。</p></li></ul><h1 id="bounds-checking-边界检查"><a href="#bounds-checking-边界检查" class="headerlink" title="bounds checking 边界检查"></a>bounds checking 边界检查</h1><ul><li>对mach-o header中的许多内容添加了重要的边界检查功能，从而可以避免恶意二进制数据的注入</li></ul><h1 id="share-cache-共享代码"><a href="#share-cache-共享代码" class="headerlink" title="share cache 共享代码"></a>share cache 共享代码</h1><ul><li><p>share cache最早实在iOS3.1和macOS Snow Leopard中被引入，用于完全取代Prebinding</p></li><li><p>share cache是一个单文件，包含大多数系统dylib，由于这些dylib合并成了一个文件，所以可以进行优化。</p><ul><li><p>重新调整所有文本段（_TEXT）和数据段（_DATA），并重写整个符号表，以此来减小文件的大小，从而在每个进程中仅挂载少量的区域。允许我们打包二进制数据段，从而节省大量的RAM</p></li><li><p>本质是一个dylib预链接器，它在RAM上的节约是显著的，在普通的iOS程序中运行可以节约500-1g内存</p></li><li><p>还可以预生成数据结构，用来供dyld和Ob-C在运行时使用。从而不必在程序启动时做这些事情，这也会节约更多的RAM和时间</p></li></ul></li><li><p>share cache在macOS上本地生成，运行dyld共享代码，将大幅优化系统性能</p></li></ul><h1 id="dyld-2-工作流程"><a href="#dyld-2-工作流程" class="headerlink" title="dyld 2 工作流程"></a>dyld 2 工作流程</h1><p>dyld 2是纯粹的in-process，即在程序进程内执行的，也就意味着只有当应用程序被启动时，dyld 2才能开始执行任务</p><p>以下是dyld 2的工作流程图示</p><p><img src="/BboyZJ.github.io/assets/16773573816475.png"></p><ul><li>1、dyld的初始化，主要代码在dyldbootstrap::start，接着执行dyld::_main，dyld::_main代码较多，是dyld加载的核心部分；</li><li>2、检查并准备环境，例如获取二进制路径、检查环境配置，解析主二进制的image header等信息</li><li>3、实例化主二进制的image loader，校验主二进制和dyld的版本是否匹配</li><li>4、检查share cache是否已经map，如果没有则需要先执行map share cache操作</li><li>5、检查DYLD_INSERT_LIBRARIES，如果有则加载插入的动态库（即实例化image loader）</li><li>6、执行link操作，会先递归加载依赖的所有动态库（会对依赖库进行排序，被依赖的总是在前面），同时在这阶段将执行符号绑定，以及rebase，binding操作；</li><li>7、执行初始化方法，OC的+load和C的constructor方法都会在这个阶段执行；</li><li>8、读取Mach-o的LC_MAIN段获取程序的入口地址，调用main函数</li></ul><h1 id="简化版"><a href="#简化版" class="headerlink" title="简化版"></a>简化版</h1><ul><li><p>解析 mach-o 文件，找到其依赖的库，并且递归的找到所有依赖的库，形成一张动态库的依赖图。iOS 上的大部分 app 都依赖几百个动态链接库（大部分是系统的动态库），所以这个步骤包含了较大的工作量。</p></li><li><p>匹配 mach-o 文件到自身的地址空间</p></li><li><p>进行符号查找（perform symbol lookups）</p></li><li><p>rebase和binding：由于 app 需要让地址空间配置随机加载，所以所有的指针都需要加上一个基地址</p></li><li><p>运行初始化程序，之后运行 main() 函数</p></li></ul><h1 id="dyld-3（2017-至今）"><a href="#dyld-3（2017-至今）" class="headerlink" title="dyld 3（2017-至今）"></a>dyld 3（2017-至今）</h1><ul><li><p>dyld 3是2017年WWDC推出的全新的动态链接器，它完全改变了动态链接的概念，且将成为大多数macOS系统程序的默认设置。2017 Apple OS平台上的所有系统程序都会默认使用dyld 3.</p></li><li><p>dyld 3最早是在2017年的iOS 11中引入，主要用来优化系统库。</p></li><li><p>而在iOS 13系统中，iOS全面采用新的dyld 3来替代之前的dyld 2，因为dyld 3完全兼容dyld 2，其API接口也是一样的，所以，在大部分情况下，开发者并不需要做额外的适配就能平滑过渡。</p></li></ul><h1 id="为什么需要重新设计dyld-2，形成新的dyld-3-？"><a href="#为什么需要重新设计dyld-2，形成新的dyld-3-？" class="headerlink" title="为什么需要重新设计dyld 2，形成新的dyld 3 ？"></a>为什么需要重新设计dyld 2，形成新的dyld 3 ？</h1><p>重新设计dyld，主要从以下几方面进行考虑</p><ul><li><p>重新设计dyld，主要从以下几方面进行考虑</p></li><li><p>性能：想要尽可能的提高启动速度</p></li><li><p>安全性：在dyld 2中增加了安全特性，但是很难跟随现实情形，虽然做了很多工作，但是难以实现这个目标</p></li><li><p>可靠性和可测试性：为此Apple发布了很多不错的测试框架，例如XCTest，但是这些测试框架依赖于动态链接器的底层功能，然后将测试框架的库插入进程中，所以不能用于测试现有的dyld代码，且难以测试安全性和性能水平</p></li></ul><h1 id="如何将-dyld-2-改进和优化为-dyld-3？"><a href="#如何将-dyld-2-改进和优化为-dyld-3？" class="headerlink" title="如何将 dyld 2 改进和优化为 dyld 3？"></a>如何将 dyld 2 改进和优化为 dyld 3？</h1><p><strong>改进和优化建议</strong></p><p>从上面的dyld 2的工作流程中，我们了解了dyld 2的执行流程，可以从以下两个方面来改进和优化：</p><ul><li><p>确定安全敏感的部分</p><ul><li><p>Parse mach-o headers解析mach-o 和 Find dependencies找到依赖库，是安全敏感部分，即最大的安全隐患之一；</p></li><li><p>恶意撰改mach-o头部，可以进行某些攻击；</p></li><li><p>如果App使用了 @rpaths 即搜索路径，可以通过恶意撰改路径或者将一些库插入到特定的位置，来达到破坏程序的目的；</p></li></ul></li><li><p>确定大量占用资源的部分（即可缓存部分）</p><ul><li>Perform symbol lookups符号查找就是其中一个，因为在一个特定的库中，除非进行软件更新或者在磁盘上更改库，不然符号将始终位于库中的相同的偏移位置（即符号偏移量固定）；</li></ul></li></ul><p><strong>dyld 2 改进和优化</strong></p><p>以下是dyld 2 向 dyld 3 的一些改变，主要是将安全敏感的部分 和 占用大量资源的部分移动到上层，然后将一个closure写入磁盘进行缓存，然后我们在程序进程中使用closure。以下是图示</p><p><img src="/BboyZJ.github.io/assets/16773575713620.png"></p><p><strong>dyld 3 组成部分&#x2F;工作流程</strong></p><p>dyld 3的工作流程主要分为3部分，如下所示</p><p><img src="/BboyZJ.github.io/assets/16773575862753.png"></p><p><strong>第一部分：out-of-process ：mach-o parser</strong></p><p>进程外的mach-o分析器和编译器，是普通的后台程序，用于提高测试基础架构的性能。</p><p>第一部分主要在App进程之外做以下工作：</p><ul><li><p>解析所有搜索路径@rpath、环境变量，因为它们会影响启动速度</p></li><li><p>分析 mach-o二进制数据</p></li><li><p>执行符号查找</p></li><li><p>利用这些结果创建launch clourse</p></li></ul><p><strong>第二部分：in-process ：engine</strong></p><p>进程内的引擎，这部分常驻在内存中，且在dyld 3不再需要分析mach-o文件头或者执行符号查找就可以启动应用，因为分析mach-o和执行符号查找都是耗时操作，所以极大的提高了程序启动速度。</p><p>第二部分主要在App进程中做以下工作：</p><ul><li><p>检查launch closure是否正确</p></li><li><p>映射到dylib中，再跳转main函数</p></li></ul><p><strong>第三部分：launch closure ：cache</strong></p><p>启动闭包launch closure缓存服务。其中大多数程序启动都会使用缓存，而不需要调用进程外 mach-o分析器和编译器。且launch closure比mach-o更简单，因为launch closure是内存映射文件，不需要用复杂的方法进行分析，我们可以进行简单的校验，目的是为了提高速度</p><ul><li><p>系统应用的launch closure直接加入到共享缓存 share cache</p></li><li><p>对于第三方应用，我们将在应用安装或者更新期间构建launch closure，因为此时 system library已发生更改</p></li><li><p>默认情况下，在iOS，tvOS和watchOS上，这些操作都将在运行之前为您预先构建。</p></li><li><p>在macOS上，由于可以侧向加载应用程序(这里应该是指非App Store安装的应用)，因此如果需要，in-process engine可以在首次启动时RPC(Remote Procedure Call)到out to the daemon，然后，它就可以使用缓存的closure了。</p></li></ul><p>所以综上所述，dyld 3 把很多耗时的查找、计算和 I&#x2F;O 操作都预先处理好了，使得启动速度有了很大的提升。即dyld 3把很多耗时的操作都提前处理好了，极大提升了启动速度。</p><h1 id="启动闭包（launch-closure）"><a href="#启动闭包（launch-closure）" class="headerlink" title="启动闭包（launch closure）"></a>启动闭包（launch closure）</h1><p>这是一个新引入的概念，指的是 app 在启动期间所需要的所有信息。比如这个 app 使用了哪些动态链接库，其中各个符号的偏移量，代码签名在哪里等等。</p><h1 id="dyld-3符号缺失问题"><a href="#dyld-3符号缺失问题" class="headerlink" title="dyld 3符号缺失问题"></a>dyld 3符号缺失问题</h1><ul><li><p>dyld 2中默认采取的是lazy symbol的符号加载方式</p></li><li><p>dyld 3中，在app启动之前，符号解析的结果已经在launch closure内了，所以lazy symbol就不再需要了。</p></li><li><p>如果此时，如果有符号缺失的情况，dyld 2 和 dyld 3的表现是不同的</p><ul><li><p>dyld 2中，首次调用缺失符号时App会crash</p></li><li><p>在dyld 3中，缺失符号会导致App一启动就会crash</p></li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>dyld 2工作流程</strong></p><ul><li><p>解析mach-o头部</p></li><li><p>查找依赖库</p></li><li><p>映射mach-o文件，放入地址空间中</p></li><li><p>执行符号查找</p></li><li><p>使用ASLR进行rebase和bind绑定</p></li><li><p>运行所有初始化器</p></li><li><p>执行main函数</p></li></ul><p><strong>dyld 3工作流程</strong></p><ul><li><p>进程外：将dyld 2中的mach-o头部解析、符号查找移到了进程外执行，且将其执行结果放入启动闭包，存储到磁盘中</p></li><li><p>进程内：验证启动闭包正确性，并映射dylib，执行main函数</p></li><li><p>启动闭包缓存服务</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理14-1：objc-msgSend缓存查找(快速查找)汇编分析</title>
      <link href="/BboyZJ.github.io/2023/02/25/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8614-1%EF%BC%9Aobjc-msgSend%E7%BC%93%E5%AD%98%E6%9F%A5%E6%89%BE(%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE)%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90/"/>
      <url>/BboyZJ.github.io/2023/02/25/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8614-1%EF%BC%9Aobjc-msgSend%E7%BC%93%E5%AD%98%E6%9F%A5%E6%89%BE(%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE)%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们得出结论：消息发送objc-msgSend 内部先进行 <code>快速查找</code> 即 <code>缓存（CacheLookup）查找</code></p><p>本文主要继上一章 <code>objc_msgSend</code> 引申，<code>objc_msgSend</code> 是用汇编写的，因为性能好、速度快</p><p>汇编的特性：快 + 动态性（不确定）</p><h1 id="objc-msgSend-汇编查找流程分析"><a href="#objc-msgSend-汇编查找流程分析" class="headerlink" title="objc_msgSend 汇编查找流程分析"></a>objc_msgSend 汇编查找流程分析</h1><p>在 <code>objc4-781源码</code> 中，搜索 <code>objc_msgSend</code>，由于我们日常开发的都是架构 <code>arm64</code>，所以需要找到 <code>objc-msgSend-arm64.s</code> 文件， <code>objc_msgSend</code> 源码实现的入口是在 <code>ENTRY _objc_msgSend</code> 这个文件下，发现是 <code>汇编实现</code>。</p><p><img src="https://user-images.githubusercontent.com/25925248/160737139-a34e0ae9-0234-4702-9a76-111cf695c1de.png"></p><ul><li>objc_msgSend 汇编源码</li></ul><p><code>objc_msgSend</code> 是消息发送的源码的入口，其使用 <code>汇编</code> 实现的，<code>_objc_msgSend</code> 源码实现如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// 消息发送 -&gt; 汇编入口 -&gt; _objc_msgSend主要是拿到接收者的isa信息</span><br><span class="line">ENTRY _objc_msgSend</span><br><span class="line">   // 无窗口</span><br><span class="line">UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">   /* </span><br><span class="line">   p0和空对比，即判断receiver是否存在</span><br><span class="line">   其中p0（消息接收者）是objc_msgSend的第一个参数</span><br><span class="line">   */</span><br><span class="line">cmpp0, #0// nil check and tagged pointer check</span><br><span class="line">// 是否支持 tagged pointers 小对象类型</span><br><span class="line">#if SUPPORT_TAGGED_POINTERS</span><br><span class="line">   // le-小于， 小对象或空判断</span><br><span class="line">b.leLNilOrTagged//  (MSB tagged pointer looks negative)</span><br><span class="line">#else // 否则</span><br><span class="line">   // eq-等于，p0等于0时，直接返回空</span><br><span class="line">b.eqLReturnZero</span><br><span class="line">#endif</span><br><span class="line">   // p0即receiver肯定存在的流程</span><br><span class="line">   // 根据对象拿出isa，即从x0寄存器指向的地址 取出 isa，存入p13寄存器</span><br><span class="line">ldrp13, [x0]// p13 = isa</span><br><span class="line">   // 在ram64架构下通过 p16 = isa（p13）&amp; ISA_MASK，拿出shiftcls信息，得到class信息</span><br><span class="line">GetClassFromIsa_p16 p13// p16 = class</span><br><span class="line">// 获取isa完毕</span><br><span class="line">LGetIsaDone:</span><br><span class="line">   // calls imp or objc_msgSend_uncached</span><br><span class="line">   // 开启缓存查找流程，即快速查找流程</span><br><span class="line">CacheLookup NORMAL, _objc_msgSend</span><br><span class="line"></span><br><span class="line">#if SUPPORT_TAGGED_POINTERS</span><br><span class="line">// 小对象或者空判断</span><br><span class="line">LNilOrTagged: </span><br><span class="line">         // 直接返回空</span><br><span class="line">b.eqLReturnZero// nil check</span><br><span class="line"></span><br><span class="line">// tagged</span><br><span class="line">adrpx10, _objc_debug_taggedpointer_classes@PAGE</span><br><span class="line">addx10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</span><br><span class="line">ubfxx11, x0, #60, #4</span><br><span class="line">ldrx16, [x10, x11, LSL #3]</span><br><span class="line">adrpx10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE</span><br><span class="line">addx10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF</span><br><span class="line">cmpx10, x16</span><br><span class="line">b.neLGetIsaDone</span><br><span class="line"></span><br><span class="line">// ext tagged</span><br><span class="line">adrpx10, _objc_debug_taggedpointer_ext_classes@PAGE</span><br><span class="line">addx10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</span><br><span class="line">ubfxx11, x0, #52, #8</span><br><span class="line">ldrx16, [x10, x11, LSL #3]</span><br><span class="line">bLGetIsaDone</span><br><span class="line">// SUPPORT_TAGGED_POINTERS</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">LReturnZero:</span><br><span class="line">// x0 is already zero</span><br><span class="line">movx1, #0</span><br><span class="line">movid0, #0</span><br><span class="line">movid1, #0</span><br><span class="line">movid2, #0</span><br><span class="line">movid3, #0</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">END_ENTRY _objc_msgSend</span><br></pre></td></tr></table></figure><p><strong>主要有以下几个步：</strong></p><ul><li><p>【第一步】判断 <code>objc_msgSend</code> 方法的第一个参数 <code>receiver</code> 是否为空</p><ul><li><p>如果支持 <code>tagged pointer</code> 小对象，跳转至 <code>LNilOrTagged</code></p><ul><li>如果 <code>小对象</code> 为空，则直接返回空，即 <code>LReturnZero</code></li><li>如果 <code>小对象</code> 不为空，则处理小对象的 <code>isa</code>，走到【第二步】</li></ul></li><li><p>如果 <code>既不是小对象</code>，<code>receiver</code> 也不为空，有以下两步</p><ul><li>从 <code>receiver</code> 中取出 <code>isa</code> 存入 <code>p13</code> 寄存器</li><li>通过 <code>GetClassFromIsa_p16</code> 中，<code>arm64</code> 架构下通过 <code>isa &amp; ISA_MASK</code>  获取 <code>shiftcls</code> 位域的类信息，即 <code>class</code>，<code>GetClassFromIsa_p16</code> 的汇编实现如下，然后走到【第二步】</li></ul></li></ul></li><li><p>【第二步】如果获得 <code>isa</code> 指针</p><ul><li>如果有 <code>isa</code>，走到 <code>CacheLookup</code>，即缓存查找流程，也就是所谓的 <code>sel-imp</code> 快速查找流程</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.macro GetClassFromIsa_p16 /* src */</span><br><span class="line">// 此处用于watchOS</span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">// Indexed isa</span><br><span class="line">   // 将isa的值存入p16寄存器</span><br><span class="line">movp16, $0// optimistically set dst = src</span><br><span class="line">   // 判断是否是 non-pointer isa</span><br><span class="line">tbzp16, #ISA_INDEX_IS_NPI_BIT, 1f// done if not non-pointer isa</span><br><span class="line">// isa in p16 is indexed</span><br><span class="line">   // 将_objc_indexed_classes 所在的页的基址 读入到x10寄存器</span><br><span class="line">adrpx10, _objc_indexed_classes@PAGE</span><br><span class="line">   // x10 = x10 + _objc_indexed(page中的偏移量) -x10基址根据偏移量进行内存偏移</span><br><span class="line">addx10, x10, _objc_indexed_classes@PAGEOFF</span><br><span class="line">   // 从p16的第ISA_INDEX_SHIFT位开始，提取 ISA_INDEX_BITS位到p16寄存器，剩余的高位用0补充</span><br><span class="line">ubfxp16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS  // extract index</span><br><span class="line"></span><br><span class="line">ldrp16, [x10, p16, UXTP #PTRSHIFT]// load class from array</span><br><span class="line">1:</span><br><span class="line"></span><br><span class="line">// 用于64位系统</span><br><span class="line">#elif __LP64__</span><br><span class="line">// 64-bit packed isa</span><br><span class="line">   // p16 = class = isa &amp; ISA_MASK（位运算 &amp; 即获取isa中的shiftcls信息）</span><br><span class="line">andp16, $0, #ISA_MASK</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line">// 32-bit raw isa</span><br><span class="line">    // 用于32位系统</span><br><span class="line">movp16, $0</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><h1 id="objc-msgSend-缓存（CacheLookup）查找汇编流程"><a href="#objc-msgSend-缓存（CacheLookup）查找汇编流程" class="headerlink" title="objc_msgSend 缓存（CacheLookup）查找汇编流程"></a>objc_msgSend 缓存（CacheLookup）查找汇编流程</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">.macro CacheLookup</span><br><span class="line">//</span><br><span class="line">// Restart protocol:</span><br><span class="line">//</span><br><span class="line">//   As soon as we&#x27;re past the LLookupStart$1 label we may have loaded</span><br><span class="line">//   an invalid cache pointer or mask.</span><br><span class="line">//</span><br><span class="line">//   When task_restartable_ranges_synchronize() is called,</span><br><span class="line">//   (or when a signal hits us) before we&#x27;re past LLookupEnd$1,</span><br><span class="line">//   then our PC will be reset to LLookupRecover$1 which forcefully</span><br><span class="line">//   jumps to the cache-miss codepath which have the following</span><br><span class="line">//   requirements:</span><br><span class="line">//</span><br><span class="line">//   GETIMP:</span><br><span class="line">//     The cache-miss is just returning NULL (setting x0 to 0)</span><br><span class="line">//</span><br><span class="line">//   NORMAL and LOOKUP:</span><br><span class="line">//   - x0 contains the receiver</span><br><span class="line">//   - x1 contains the selector</span><br><span class="line">//   - x16 contains the isa</span><br><span class="line">//   - other registers are set as per calling conventions</span><br><span class="line">//</span><br><span class="line">LLookupStart$1:</span><br><span class="line"></span><br><span class="line">// p1 = SEL, p16 = isa，#define CACHE（2 * __SIZEOF_POINER__），其中__SIZEOF_POINTER__表示pointer的大小 ，即 2*8 = 16</span><br><span class="line">   // p11 = mask | buckets，从x16（即isa）中平移16字节，取出cache存入p11寄存器，isa距离cache正好16字节：isa（8字节），superClass（8字节），cache（mask高16位 + buckets低48位）</span><br><span class="line">ldrp11, [x16, #CACHE]</span><br><span class="line"></span><br><span class="line">// 64位真机</span><br><span class="line">#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16</span><br><span class="line">   // p11(cache) &amp; 0x0000ffffffffffff ，mask高16位抹零，得到buckets 存入p10寄存器，即去掉mask，留下buckets</span><br><span class="line">andp10, p11, #0x0000ffffffffffff // p10 = buckets</span><br><span class="line"></span><br><span class="line">   /*</span><br><span class="line">    1）先将p11(cache)右移48位，得到mask(即p11 存储mask)</span><br><span class="line">    2）mask &amp; p1（msgSend的第二个参数 cmd-sel），得到sel-imp的下表index(即搜索下标)</span><br><span class="line">    3）存入p12(cache insert写入时的哈希下标计算是 通过 sel &amp; mask，读取时也要用这种方式)</span><br><span class="line">   */</span><br><span class="line">andp12, p1, p11, LSR #48// x12 = _cmd &amp; mask</span><br><span class="line"></span><br><span class="line">// 非64位真机</span><br><span class="line">#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4</span><br><span class="line">andp10, p11, #~0xf// p10 = buckets</span><br><span class="line">andp11, p11, #0xf// p11 = maskShift</span><br><span class="line">movp12, #0xffff</span><br><span class="line">lsrp11, p12, p11// p11 = mask = 0xffff &gt;&gt; p11</span><br><span class="line">andp12, p1, p11// x12 = _cmd &amp; mask</span><br><span class="line">#else</span><br><span class="line">#error Unsupported cache mask storage for ARM64.</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">   /*</span><br><span class="line">     1) p12是下标，p10是buckets数组首地址，下标 * 1&lt;&lt;4(即16)得到实际内存的偏移量，通过buckets的首地址偏移，获取bucket存入p12寄存器</span><br><span class="line">     2) LSL #(1+PTRSHIFT)  实际含义就是得到一个bucket占用内存大小，相当于mask = occupied - 1，_cmd &amp; mask，取余数</span><br><span class="line">   */</span><br><span class="line">addp12, p10, p12, LSL #(1+PTRSHIFT)</span><br><span class="line">             // p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</span><br><span class="line">             </span><br><span class="line">   // 从x12（即p12）中取出bucket，分别将imp和sel存入 p17（存储imp） 和 p9（存储sel）</span><br><span class="line">ldpp17, p9, [x12]// &#123;imp, sel&#125; = *bucket</span><br><span class="line"></span><br><span class="line">// 比较 sel 和 p1（唇乳的参数cmd）</span><br><span class="line">1:cmpp9, p1// if (bucket-&gt;sel != _cmd)</span><br><span class="line">   // 如果不相等，即没有找到，请跳转至2f</span><br><span class="line">b.ne2f//     scan more</span><br><span class="line">   // 如果相等，即CacheHit 缓存命中，直接返回 imp</span><br><span class="line">CacheHit $0// call or return imp</span><br><span class="line"></span><br><span class="line">2:// not hit: p12 = not-hit bucket</span><br><span class="line">   // 如果一直都找不到，因为是normal，跳转至__objc_msgSend_uncached</span><br><span class="line">CheckMiss $0// miss if bucket-&gt;sel == 0</span><br><span class="line">   // 判断p12（下标对应的bucket）是否等于p10（buckets数组第一个元素），如果等于则跳转至3f</span><br><span class="line">cmpp12, p10// wrap if bucket == buckets</span><br><span class="line">// 定位到最后一个元素（即第一个bucket）</span><br><span class="line">b.eq3f</span><br><span class="line">   // 从x12（即p12 buckets首地址），实际需要平移的内存大小BUCKET_SIZE,得到第二个bucket元素，imp-sel分别存入p17-p9，即向前查找</span><br><span class="line">ldpp17, p9, [x12, #-BUCKET_SIZE]!// &#123;imp, sel&#125; = *--bucket</span><br><span class="line">// 挑战至第1步，继续对比 sel与cmd</span><br><span class="line">b1b// loop</span><br><span class="line"></span><br><span class="line">3:// wrap: p12 = first bucket, w11 = mask</span><br><span class="line">#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16</span><br><span class="line">   /*</span><br><span class="line">    1) 人为设值到最后一个元素</span><br><span class="line">    2) p11(mask)右移44位，相当于mask左移4位，直接定位到buckets的最后一个元素，缓存查找顺序是向前查找</span><br><span class="line">   */</span><br><span class="line">addp12, p12, p11, LSR #(48 - (1+PTRSHIFT))</span><br><span class="line">// p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</span><br><span class="line">#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4</span><br><span class="line">addp12, p12, p11, LSL #(1+PTRSHIFT)</span><br><span class="line">// p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</span><br><span class="line">#else</span><br><span class="line">#error Unsupported cache mask storage for ARM64.</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// Clone scanning loop to miss instead of hang when cache is corrupt.</span><br><span class="line">// The slow path may detect any corruption and halt later.</span><br><span class="line">   // 再查找一遍缓存（）</span><br><span class="line">   // 拿到x12(即p12) bucket中的 imp-sel 分别存入 p17-p9</span><br><span class="line">ldpp17, p9, [x12]// &#123;imp, sel&#125; = *bucket</span><br><span class="line">// 比较 sel 与 p1（传入的参数cmd）</span><br><span class="line">1:cmpp9, p1// if (bucket-&gt;sel != _cmd)</span><br><span class="line">   // 如果不相等，即走到第二步</span><br><span class="line">b.ne2f//     scan more</span><br><span class="line">// 如果相等，即命中，直接返回imp</span><br><span class="line">CacheHit $0// call or return imp</span><br><span class="line"></span><br><span class="line">2:// not hit: p12 = not-hit bucket</span><br><span class="line">   // 如果一直找不到，则CheckMiss</span><br><span class="line">CheckMiss $0// miss if bucket-&gt;sel == 0</span><br><span class="line">// 判断p12（下标对应的bucket）是否等于p10（buckets数组第一个元素），表示前面已经没有了，但是还是没有找到</span><br><span class="line">cmpp12, p10// wrap if bucket == buckets</span><br><span class="line">// 如果等于，跳转至第3步</span><br><span class="line">b.eq3f</span><br><span class="line">// 从x12（即p12 buckets首地址），实际需要平移的内存大小BUCKET_SIZE，得到第二个bucket元素，imp-sel分别存入p17-p9，即向前查找</span><br><span class="line">ldpp17, p9, [x12, #-BUCKET_SIZE]!// &#123;imp, sel&#125; = *--bucket</span><br><span class="line">// 跳转至第1步，继续对比 sel与imp</span><br><span class="line">b1b// loop</span><br><span class="line"></span><br><span class="line">LLookupEnd$1:</span><br><span class="line">LLookupRecover$1:</span><br><span class="line">3:// double wrap</span><br><span class="line">    // 跳转至JumpMiss 因为是normal，跳转至__objc_msgSend_uncached</span><br><span class="line">JumpMiss $0</span><br><span class="line"></span><br><span class="line">.endmacro</span><br><span class="line"></span><br><span class="line">// 以下是最后跳转的汇编函数</span><br><span class="line">.macro CacheHit</span><br><span class="line">.if $0 == NORMAL</span><br><span class="line">TailCallCachedImp x17, x12, x1, x16// authenticate and call imp</span><br><span class="line">.elseif $0 == GETIMP</span><br><span class="line">movp0, p17</span><br><span class="line">cbzp0, 9f// don&#x27;t ptrauth a nil imp</span><br><span class="line">AuthAndResignAsIMP x0, x12, x1, x16// authenticate imp and re-sign as IMP</span><br><span class="line">9:ret// return IMP</span><br><span class="line">.elseif $0 == LOOKUP</span><br><span class="line">// No nil check for ptrauth: the caller would crash anyway when they</span><br><span class="line">// jump to a nil IMP. We don&#x27;t care if that jump also fails ptrauth.</span><br><span class="line">AuthAndResignAsIMP x17, x12, x1, x16// authenticate imp and re-sign as IMP</span><br><span class="line">ret// return imp via x17</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br><span class="line"></span><br><span class="line">.macro CheckMiss</span><br><span class="line">// miss if bucket-&gt;sel == 0</span><br><span class="line">.if $0 == GETIMP // 如果为GETIMP，跳转至LGetImpMiss</span><br><span class="line">cbzp9, LGetImpMiss</span><br><span class="line">.elseif $0 == NORMAL // 如果为NORMAL，跳转至__objc_msgSend_uncached</span><br><span class="line">cbzp9, __objc_msgSend_uncached</span><br><span class="line">.elseif $0 == LOOKUP // 如果为LOOKUP，跳转至__objc_msgLookup_uncached</span><br><span class="line">cbzp9, __objc_msgLookup_uncached</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br><span class="line"></span><br><span class="line">.macro JumpMiss</span><br><span class="line">.if $0 == GETIMP</span><br><span class="line">bLGetImpMiss</span><br><span class="line">.elseif $0 == NORMAL</span><br><span class="line">b__objc_msgSend_uncached</span><br><span class="line">.elseif $0 == LOOKUP</span><br><span class="line">b__objc_msgLookup_uncached</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p><strong>主要分为以下几步：</strong></p><ul><li><p>【第一步】通过 <code>cache</code> 首地址平移 <code>16</code> 字节（因为在objc_class中），<code>首地址</code> 距离 <code>cache</code> 正好 <code>16</code> 字节，即 <code>isa首地址</code> 占 <code>8</code> 字节，<code>superClass</code>占 <code>8</code> 字节），获取 <code>cache</code>，cache中 <code>高16位存mask</code>，<code>低48位存buckets</code>，即 <code>p11 = cache</code>。</p></li><li><p>【第二步】从cache中分别取出 <code>buckets和mask</code>,并由mask根据哈希算法计算出哈希下标</p><ul><li><p>通过 <code>cache</code> 和 <code>掩码</code>（即0x0000ffffffffffff）的 <code>&amp;</code> 运算，将 <code>高16位mask抹零</code>，得到buckets指针地址，即 <code>p10 = buckets</code></p></li><li><p>将 <code>cache</code> 右移 <code>48</code> 位，得到 <code>mask</code>，即 <code>p11 = mask</code></p></li><li><p>将 <code>objc_msgSend</code> 的参数 <code>p1</code> (即第二个参数_cmd) <code>&amp; mask</code>，通过 <code>哈希算法</code>，得到需要查找存储 <code>sel-imp</code> 的 <code>bucket下标index</code>，即 <code>p12 = index = _cmd &amp; mask</code>，为什么通过这种方式呢？因为在 <code>存储sel-imp时</code>，也是通过同样 <code>哈希算法计算哈希下标进行存储</code>，所以 <code>读取</code> 也需要通过同样的方式读取，如下所示：</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Class points to cache. SEL is key. Cache buckets store SEL+IMP.</span><br><span class="line">// Caches are never built in the dyld shared cache.</span><br><span class="line"></span><br><span class="line">static inline mask_t cache_hash(SEL sel, mask_t mask) </span><br><span class="line">&#123;</span><br><span class="line">    return (mask_t)(uintptr_t)sel &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>【第三步】根据所得的 <code>哈希下标Index</code> 和 <code>buckets首地址</code>，取出哈希下标对应的 <code>bucket</code></p><ul><li><p>其中 <code>PTRSHIFT</code> 等于 <code>3</code>，左移 <code>4</code> 位（即2^4 &#x3D; 16字节）的目的是计算出一个 <code>bucket</code> 实际占用的大小，结构体 <code>bucket_t</code> 中 <code>sel</code> 占 <code>8</code> 字节，<code>imp</code> 占 <code>8</code> 字节</p></li><li><p>根据计算的哈希下标 <code>index乘以单个bucket占用的内存大小</code> ，得到 <code>buckets</code> 首地址在 <code>实际内存中的偏移量</code></p></li><li><p>通过 <code>首地址+实际偏移量</code>，获取哈希下标index对应的 <code>bucket</code></p></li></ul></li><li><p>【第四步】根据获取的 <code>bucket</code>，取出其中的 <code>imp</code> 存入 <code>p17</code>，即 <code>p17 = imp</code>，取出 <code>sel</code> 存入 <code>p9</code>，即 <code>p9 = sel</code></p></li><li><p>【第五步】第一次递归循环</p><ul><li><p>比较获取的 <code>bucket</code> 中 <code>sel</code> 与 <code>objc_msgSend</code> 的第二个参数的 <code>_cmd</code>(即p1) 是否相等</p></li><li><p>如果相等，则直接跳转至 <code>CacheHit</code>，即 <code>缓存命中</code>，返回 <code>imp</code></p></li><li><p>如果不相等，有以下两种情况</p><ul><li><p>如果一直都找不到，直接跳转至 <code>CheckMiss</code>，因为 <code>$0</code> 是 <code>normal</code>，会跳转至 <code>__objc_msgSend_uncached</code>，即进入 <code>慢速查找流程</code></p></li><li><p>如果 <code>根据index获取的bucket</code> 等于 <code>buckets的第一个元素</code>，则 <code>人为</code> 的将 <code>当前bucket设置为buckets的最后一个元素</code>（通过 <code>buckets首地址+mask右移44位</code>（等同于左移4位）直接 <code>定位到bucker的最后一个元素</code>），然后继续进行递归循环（<code>第一个</code> 递归循环嵌套 <code>第二个</code> 递归循环），即【第六步】</p></li><li><p>如果 <code>当前bucket</code> 不等于 <code>buckets的第一个元素</code>，则继续 <code>向前查找</code>，进入 <code>第一次递归循环</code></p></li></ul></li></ul></li><li><p>【第六步】第二次递归循环：重复【第五步】的操作，与【第五步】中唯一区别是，如果 <code>当前的bucket还是等于 buckets的第一个元素</code>，则直接跳转至 <code>JumpMiss</code>，此时的 <code>$0</code> 是 <code>normal</code>，也是直接跳转至 <code>__objc_msgSend_uncached</code>，即进入 <code>慢速查找流程</code></p></li></ul><p>以下是整个 <code>快速查找</code> 过程 <code>值的变化</code> 过程</p><p><img src="https://user-images.githubusercontent.com/25925248/160737068-7204e3d9-2849-4267-a0c4-632c6afefe48.png"></p><h1 id="objc-msgSend通过伪代码实现"><a href="#objc-msgSend通过伪代码实现" class="headerlink" title="objc_msgSend通过伪代码实现"></a>objc_msgSend通过伪代码实现</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 查找 imp imp存储在 cache 的 bucket 下</span><br><span class="line">[person sayNB]  -&gt; imp ( cache -&gt; bucket (sel imp))</span><br><span class="line"></span><br><span class="line">// 获取当前的对象</span><br><span class="line">id person = 0x10000</span><br><span class="line">// 获取isa</span><br><span class="line">isa_t isa = 0x000000</span><br><span class="line">// isa -&gt; class -&gt; cache</span><br><span class="line">cache_t cache = isa + 16字节</span><br><span class="line"></span><br><span class="line">// arm64</span><br><span class="line">// mask|buckets 在一起的</span><br><span class="line">buckets = cache &amp; 0x0000ffffffffffff</span><br><span class="line">// 获取mask</span><br><span class="line">mask = cache LSR #48</span><br><span class="line">// 下标 = mask &amp; sel</span><br><span class="line">index = mask &amp; p1</span><br><span class="line"></span><br><span class="line">// bucket 从 buckets 遍历的开始 (起始查询的bucket)</span><br><span class="line">bucket = buckets + index * 16 (sel imp = 16)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int count = 0</span><br><span class="line">// CheckMiss $0</span><br><span class="line">do&#123;</span><br><span class="line"></span><br><span class="line">    if ((bucket == buckets) &amp;&amp; (count == 0))&#123; // 进入第二层判断</span><br><span class="line">        // bucket == 第一个元素</span><br><span class="line">        // bucket人为设置到最后一个元素</span><br><span class="line">        bucket = buckets + mask * 16</span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">    &#125;else if (count == 1) goto CheckMiss</span><br><span class="line">        </span><br><span class="line">    // &#123;imp, sel&#125; = *--bucket</span><br><span class="line">    // 缓存的查找的顺序是: 向前查找</span><br><span class="line">    bucket--;</span><br><span class="line">    imp = bucket.imp;</span><br><span class="line">    sel = bucket.sel;</span><br><span class="line">    </span><br><span class="line">&#125;while (bucket.sel != _cmd)  //  // bucket里面的sel 是否匹配_cmd</span><br><span class="line"></span><br><span class="line">// CacheHit $0</span><br><span class="line">return imp</span><br><span class="line"></span><br><span class="line">CheckMiss:</span><br><span class="line">    CheckMiss(normal)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><ul><li>在 <code>缓存（CacheLookup）查找</code> 过程中，如果没有找到方法实现，无论是走到 <code>CheckMiss</code> 还是 <code>JumpMiss</code>，最终都会走到 <code>__objc_msgSend_uncached</code> 汇编函数</li></ul><p><strong>CheckMiss源码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.macro CheckMiss</span><br><span class="line">// miss if bucket-&gt;sel == 0</span><br><span class="line">.if $0 == GETIMP</span><br><span class="line">cbzp9, LGetImpMiss</span><br><span class="line">.elseif $0 == NORMAL</span><br><span class="line">cbzp9, __objc_msgSend_uncached</span><br><span class="line">.elseif $0 == LOOKUP</span><br><span class="line">cbzp9, __objc_msgLookup_uncached</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p><strong>JumpMiss源码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.macro JumpMiss</span><br><span class="line">.if $0 == GETIMP</span><br><span class="line">bLGetImpMiss</span><br><span class="line">.elseif $0 == NORMAL</span><br><span class="line">b__objc_msgSend_uncached</span><br><span class="line">.elseif $0 == LOOKUP</span><br><span class="line">b__objc_msgLookup_uncached</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><ul><li>在 <code>objc-msg-ram64.s</code> 文件中查找 <code>__objc_msgSend_uncached</code> 的汇编源码，发现其核心是 <code>MethodTableLookup(即查询方法列表)</code> ，因此如果  <code>缓存（CacheLookup）查找</code> 没有找到，就去 <code>MethodTableLookup（即方法列表中查找）</code> ，下一章我们介绍</li></ul><p><strong>__objc_msgSend_uncached源码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line">// THIS IS NOT A CALLABLE C FUNCTION</span><br><span class="line">// Out-of-band p16 is the class to search</span><br><span class="line"></span><br><span class="line">// 方法列表查找</span><br><span class="line">MethodTableLookup</span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理14-0：方法调用的本质objc_msgSend消息发送</title>
      <link href="/BboyZJ.github.io/2023/02/25/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8614-0%EF%BC%9A%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8objc_msgSend%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/"/>
      <url>/BboyZJ.github.io/2023/02/25/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8614-0%EF%BC%9A%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8objc_msgSend%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们先得出结论：方法调用的本质是 <code>objc_msgSend消息发送</code></p><p>本文主要目的是理解 <code>objc_msgSend</code> 的 <code>方法查找</code> 流程</p><p>在上一篇文章中 <a href="https://www.bboyzj.cn/2020/09/30/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8613%EF%BC%9Acache-t%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">OC底层原理13：cache-t底层原理分析</a> 中，分析了 <code>cache的写入流程</code>，在写入流程之前，还有一个 <code>cache读取流程</code>，即 <code>objc_msgSend</code> 和 <code>cache_getImp</code> </p><p>在分析之前，首先了解什么是 <code>Runtime</code></p><h1 id="Runtime介绍"><a href="#Runtime介绍" class="headerlink" title="Runtime介绍"></a>Runtime介绍</h1><p>runtime成为运行时，它区别于编译时：</p><ul><li><p><code>运行时</code> 是 <code>代码跑起来，被装载到内存中</code> 的过程，如果此时出错，则程序会崩溃，是一个 <code>动态</code> 阶段</p></li><li><p><code>编译时</code> 是 <code>源代码编译成机器能识别的代码</code> 的过程，主要是对语言进行最基本的检查报错，即 <code>词法分析、语法分析</code> 等，是一个 <code>静态</code> 的阶段</p></li></ul><p><code>runtime</code> 的 <code>使用</code> 有以下三种方式，其中三种实现方式与编译层和底层的关系如下所示：</p><ul><li><p>通过 <code>OC代码</code>，例如 <code>[person sayNB]</code></p></li><li><p>通过 <code>Framework&amp;Service</code>，例如 <code>isKindOfClass</code></p></li><li><p>通过 <code>Runtime API</code>，例如 <code>class_getInstanceSize</code></p></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160736327-80d52458-3fd6-4717-90af-279d89403d61.png"></p><ul><li><p><code>complier</code> 就是我们了解的 <code>编译器</code>，即 <code>LLVM</code>，例如 <code>OC</code> 的 <code>alloc</code> 对应底层的 <code>objc_alloc</code></p></li><li><p><code>runtime system library</code> 就是 <code>Runtime 底层库</code>。</p></li><li><p>可以通过 <code>command + shift + 0</code> 打开官方文档</p></li></ul><h1 id="探索方法的本质"><a href="#探索方法的本质" class="headerlink" title="探索方法的本质"></a>探索方法的本质</h1><p><strong>方法的本质</strong></p><p>在 <a href="https://www.bboyzj.cn/2020/09/18/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8608%EF%BC%9Aisa%E5%92%8C%E7%B1%BB%E5%85%B3%E8%81%94%E6%8E%A2%E7%B4%A2/">OC底层原理08：isa和类关联探索</a> 文章中，通过 <code>clang</code> 编译的源码，理解了 <code>oc对象的本质</code>，同样的，使用<code>clang</code> 编译 <code>main.m -&gt; main.cpp</code> 文件，通过查看main函数中方法调用的实现，如下所示</p><ul><li>mian.m 内实现如下代码：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 👇main.m中</span><br><span class="line">ZJPerson * person = [ZJPerson alloc];</span><br><span class="line">[person sayNB];</span><br><span class="line">[person sayHello];</span><br></pre></td></tr></table></figure><ul><li>终端 <code>clang</code> 编译 <code>miam.m -&gt; main.cpp</code> 后的代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 👇clang编译后的底层实现</span><br><span class="line">ZJPerson * person = ((ZJPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;ZJPerson&quot;), sel_registerName(&quot;alloc&quot;));</span><br><span class="line">((void (*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(&quot;sayNB&quot;));</span><br><span class="line">((void (*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(&quot;sayHello&quot;));</span><br></pre></td></tr></table></figure><p><strong>总结： 通过上述代码可以看出，<code>方法的本质</code> 就是 <code>objc_msgSend消息发送</code></strong></p><h1 id="验证方法本质"><a href="#验证方法本质" class="headerlink" title="验证方法本质"></a>验证方法本质</h1><p>方法：消息（消息的接受者，消息主体）</p><ul><li>为了验证，通过 <code>objc_msgSend</code> 方法来完成 <code>[person sayNB]</code> 的调用，查看其打印是否一致</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注：👇 objc_msgSend 消息发送流程是在 &lt;objc/message.h&gt; 系统库中</span><br><span class="line">1、直接调用 `objc_msgSend`，导入头文件 `#import&lt;objc/message.h&gt;`</span><br><span class="line">2、需要将 target --&gt; Build Setting --&gt; 搜索msg --&gt; 将 enable strict checking of objc_msgSend calls 由 YES 改为 NO，将严厉的检查机制关掉，否则 `objc_msgSend` 的参数会报错</span><br><span class="line">3. `sel_registerName = @selector() = NNSelectorFromString()`</span><br></pre></td></tr></table></figure><p><img src="/BboyZJ.github.io/assets/16773117718962.jpg"></p><p><img src="/BboyZJ.github.io/assets/16773118268896.jpg"></p><ul><li>再次编译运行 <code>command + R</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZJPerson * person = [ZJPerson alloc];</span><br><span class="line">[person sayNB];</span><br><span class="line">objc_msgSend(person,sel_registerName(&quot;sayNB&quot;));</span><br></pre></td></tr></table></figure><p>其打印结果如下，发现是一致的，所以 <code>[person sayNB]</code> 等价于 <code>objc_msgSend(person,sel_registerName(&quot;sayNB&quot;))</code></p><p><img src="/BboyZJ.github.io/assets/16773118832853.jpg"></p><h1 id="子类对象方法调用-执行父类的实现"><a href="#子类对象方法调用-执行父类的实现" class="headerlink" title="子类对象方法调用-执行父类的实现"></a>子类对象方法调用-执行父类的实现</h1><ul><li>首先我们定义两个类 <code>子类ZJStudent</code> 和 <code>父类ZJPerson</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 父类 ZJPerson</span><br><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">- (void)sayNB;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJPerson</span><br><span class="line">- (void)sayNB&#123;</span><br><span class="line">    NSLog(@&quot;666&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// ZJStudent 继承父类 ZJPerson</span><br><span class="line">@interface ZJStudent : ZJPerson</span><br><span class="line">- (void)sayNB;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJStudent</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>在 <code>main.m</code> 中让子类调用 <code>sayNB</code> 方法，查看是否能输出结果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ZJPerson * person = [ZJPerson alloc];</span><br><span class="line">ZJStudent * student = [ZJStudent alloc];</span><br><span class="line">    </span><br><span class="line">// 消息的接收者还是自己 - 父类 - 请你直接找我的父亲要</span><br><span class="line">[student sayNB];</span><br><span class="line">objc_msgSend(student,sel_registerName(&quot;sayNB&quot;));</span><br></pre></td></tr></table></figure><p>运行程序，查看结果</p><p><img src="/BboyZJ.github.io/assets/16773128271287.jpg"></p><p>由打印结果可知,子类方法的调用，可以 <code>执行父类方法的实现</code></p><p><strong>那么子类是如何调用父类的方法实现的呢？我们往下探索</strong></p><h1 id="子类调用父类方法的原理"><a href="#子类调用父类方法的原理" class="headerlink" title="子类调用父类方法的原理"></a>子类调用父类方法的原理</h1><p>我们先说结论：我们还可以尝试让 <code>person</code> 的调用执行父类中的实现，通过 <code>objc_msgSendSuper</code> 实现</p><ul><li>在 <code>main.m</code> 函数中的调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ZJPerson * person = [ZJPerson alloc];</span><br><span class="line">ZJStudent * student = [ZJStudent alloc];</span><br><span class="line">    </span><br><span class="line">struct objc_super zjsuper;</span><br><span class="line">zjsuper.receiver = person; // 消息的接收者还是person</span><br><span class="line">zjsuper.super_class = [ZJPerson class]; // 告诉父类是谁</span><br><span class="line">    </span><br><span class="line">// 消息的接收者还是自己 - 父类 - 请你直接找我的父亲要</span><br><span class="line">[student sayNB];</span><br><span class="line">objc_msgSendSuper(&amp;zjsuper, sel_registerName(&quot;sayNB&quot;));      </span><br></pre></td></tr></table></figure><p><strong>进入objc_msgSendSuper内，查看一下结构</strong></p><p><img src="/BboyZJ.github.io/assets/16773136641990.jpg"></p><p><img src="/BboyZJ.github.io/assets/16773137255456.jpg"></p><p>由上图可知 <code>objc_msgSendSuper</code> 方法中有两个参数 <code>（结构体，sel）</code>，其结构体类型是 <code>objc_super</code> 定义的结构体对象，且需要指定 <code>receiver</code> 和 <code>super_class</code> 两个属性</p><ul><li>运行程序，查看打印结果：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2023-02-25 16:31:22.959805+0800 msg_seng继承父类[53476:1503775] 666</span><br><span class="line">2023-02-25 16:31:22.961094+0800 msg_seng继承父类[53476:1503775] 666</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure><p><img src="/BboyZJ.github.io/assets/16773139042426.jpg"></p><p>由打印结果，我们发现不论是 <code>[person sayHello]</code> 还是 <code>objc_msgSendSuper</code> 都执行的是 <code>父类</code> 中的 <code>sayHello</code> 的实现，所以这里，我们可以可以猜想：<code>方法调用、首先是在类中查找，如果类中没有找到，会到父类中查找。</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>由上面的结论我们知道 <code>方法的调用</code> 实际上是 <code>消息发送objc_msgSend</code></p></li><li><p>在 c 中，可以直接调用 <code>函数</code></p></li><li><p>在 OC 中，方法调用是消息发送，消息发送objc_smgSend是通过 <code>sel方法编号</code> 找到 <code>imp函数指针地址</code> ，进而找到 <code>内容</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习25：Swift中的模式和模式匹配</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A025%EF%BC%9ASwift%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A025%EF%BC%9ASwift%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><ul><li><p>模式代表 <code>单个值或复合值</code> 的 <code>结构</code>，</p></li><li><p>可以用模式来匹配各种各样的值，例如：(x,y) 匹配 元组(1,2)</p></li><li><p>可以从复合值中取出部分或全部值，然后把值绑定一个常量或变量，例如：(let x,y) 提取 (1,2)</p></li></ul><h1 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h1><p><code>Swift</code> 中模式分为两类： <code>一种能成功匹配任何类型的值</code>；<code>另一种在运行时匹配某个特定值可能会失败</code></p><ul><li><p>第一种模式用于解构简单的常量、变量和可选绑定中的值</p></li><li><p>第二种模式用于全模式匹配。</p></li></ul><p>模式分类：</p><ul><li>通配符模式（Wildcard Pattern）</li><li>标识符模式（Identifier Pattern）</li><li>值绑定模式（Value-Binding Pattern）</li><li>元组模式（Tuple Pattern）</li><li>枚举用例模式（Enumeratinal Case Pattern）</li><li>可选项模式（Optional Pattern）</li><li>类型转换模式（Type-Casting Pattern）</li><li>表达式模式（Expression Pattern）</li></ul><h1 id="通配符模式（Wildcard-Pattern）"><a href="#通配符模式（Wildcard-Pattern）" class="headerlink" title="通配符模式（Wildcard Pattern）"></a>通配符模式（Wildcard Pattern）</h1><ul><li>通配符模式（Wildcard Pattern） 用一个下划线 <code>_</code> 构成，用于匹配并忽略任何职</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for _ in 1...3 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="标识符模式（Identifier-Pattern）"><a href="#标识符模式（Identifier-Pattern）" class="headerlink" title="标识符模式（Identifier Pattern）"></a>标识符模式（Identifier Pattern）</h1><ul><li>标识符模式匹配任何值，并将匹配的值和一个变量或常量绑定起来</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let someValue = 42</span><br></pre></td></tr></table></figure><h1 id="值绑定模式（Value-Binding-Pattern）"><a href="#值绑定模式（Value-Binding-Pattern）" class="headerlink" title="值绑定模式（Value-Binding Pattern）"></a>值绑定模式（Value-Binding Pattern）</h1><ul><li>把匹配到的值绑定给一个 <code>变量let或常量var</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let point = (2,3)</span><br><span class="line">switch point &#123;</span><br><span class="line">// 将 point 中的元素绑定到 x 和 y</span><br><span class="line">case let (x,y):</span><br><span class="line">    print(&quot;\(x),\(y)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="元组模式（Tuple-Pattern）"><a href="#元组模式（Tuple-Pattern）" class="headerlink" title="元组模式（Tuple Pattern）"></a>元组模式（Tuple Pattern）</h1><ul><li>元组模式由逗号分割，具有零个或多个模式的列表，由一对圆括号括起来。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let points = [(0,0),(0,1),(1,1)]</span><br><span class="line">for (x,0) in points &#123;</span><br><span class="line">    print(&quot;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举用例模式（Enumeratinal-Case-Pattern）"><a href="#枚举用例模式（Enumeratinal-Case-Pattern）" class="headerlink" title="枚举用例模式（Enumeratinal Case Pattern）"></a>枚举用例模式（Enumeratinal Case Pattern）</h1><ul><li>匹配现有某个枚举类型的某个用例，体现在 <code>switch</code> 中 <code>case</code> 标签中，及 <code>if、while、guard </code>和 <code>for in</code> 的 <code>case</code> 中</li></ul><h1 id="可选项模式（Optional-Pattern）"><a href="#可选项模式（Optional-Pattern）" class="headerlink" title="可选项模式（Optional Pattern）"></a>可选项模式（Optional Pattern）</h1><ul><li><p>匹配 <code>Optional&lt;Wrapped&gt;</code> 枚举在 <code>some&lt;Wrapped&gt;</code> 中包装的值</p></li><li><p>可选项模式为 <code>for in</code> 语句提供了一种迭代数组的简便方式，只为数组中的非 <code>nil</code> 元素执行循环体</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let someNum: Int? = 10</span><br><span class="line">if case .some(let x) = someNum &#123;</span><br><span class="line">    print(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if case let x? = someNum &#123;</span><br><span class="line">    print(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032228371.png"></p><h1 id="类型转换模式（Type-Casting-Pattern）"><a href="#类型转换模式（Type-Casting-Pattern）" class="headerlink" title="类型转换模式（Type-Casting Pattern）"></a>类型转换模式（Type-Casting Pattern）</h1><ul><li><p>有两种：<code>is模式</code> 和 <code>as模式</code>，<code>is</code> 模式只出现在 <code>switch</code> 语句 <code>case</code> 标签中</p><ul><li><p><code>is</code> 类型：仅当一个值类型在运行时和 <code>is模式</code> 右边指定的类型一致，或子类下，才匹配值，没有返回类型</p></li><li><p>模式 <code>as</code> 类型：仅当一个值类型在运行时和 <code>as模式</code> 右边指定的类型一致，或子类下，才匹配值，如果匹配成功，被转换成 <code>as模式右边指定的类型</code></p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protocol Animal &#123;</span><br><span class="line">    var name:String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Dog:Animal &#123;</span><br><span class="line">    var name:String &#123;</span><br><span class="line">        return &quot;dog&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    var runSpeed:Int</span><br><span class="line">&#125;</span><br><span class="line">struct Bird:Animal &#123;</span><br><span class="line">    var name:String&#123;</span><br><span class="line">        return &quot;bird&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    var flightHeight:Int</span><br><span class="line">&#125;</span><br><span class="line">let animals:[Any] = [Dog(runSpeed:40),Bird(flightHeight:500)]</span><br><span class="line">for animal in animals &#123;</span><br><span class="line">    switch animal&#123;</span><br><span class="line">    case let dog as Dog:</span><br><span class="line">        print(&quot;\(dog.name) run at \(dog.runSpeed)&quot;)</span><br><span class="line">    case let bird as Bird:</span><br><span class="line">        print(&quot;\(bird.name) swip at \(bird.flightHeight)&quot;)</span><br><span class="line">    default:</span><br><span class="line">         break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032230668.png"></p><h1 id="表达式模式（Expression-Pattern）"><a href="#表达式模式（Expression-Pattern）" class="headerlink" title="表达式模式（Expression Pattern）"></a>表达式模式（Expression Pattern）</h1><ul><li><p>表达式模式代表表达式的值，只出现在 <code>switch</code> 语句中的 <code>case</code> 标签中</p></li><li><p>可重载 <code>~=</code> 运算符来提供自定义的表达式匹配行为</p></li><li><p><code>自定义类或结构体类型</code> 默认也是无法进行表达式模式匹配的，也需要重载 <code>~=</code> 运算符</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Employee&#123;</span><br><span class="line">    var salary:Int</span><br><span class="line">&#125;</span><br><span class="line">func ~= (left:ClosedRange&lt;Int&gt;,right:Employee) -&gt; Bool&#123;</span><br><span class="line">    return left.contains(right.salary)</span><br><span class="line">&#125;</span><br><span class="line">var e: Employee = Employee(salary:2000)</span><br><span class="line">switch e&#123;</span><br><span class="line">case 0...1000:</span><br><span class="line">    print(&quot;吃不饱&quot;)</span><br><span class="line">case 1000...5000:</span><br><span class="line">    print(&quot;勉强度日&quot;)</span><br><span class="line">default:</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032232137.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习24：如何在Swift里面进行控制转移</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A024%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8Swift%E9%87%8C%E9%9D%A2%E8%BF%9B%E8%A1%8C%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A024%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8Swift%E9%87%8C%E9%9D%A2%E8%BF%9B%E8%A1%8C%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="控制转移"><a href="#控制转移" class="headerlink" title="控制转移"></a>控制转移</h1><ul><li><p>continue </p></li><li><p>break</p></li><li><p>fallthrough</p></li><li><p>return</p></li><li><p>throw</p></li></ul><h1 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h1><ul><li>continue 告诉我不再继续当前循环遍历了，再次从头开始下一次遍历</li></ul><h1 id="break"><a href="#break" class="headerlink" title="break"></a>break</h1><ul><li>break 会立即结束整个控制流语句，即跳出整个循环</li></ul><h1 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h1><ul><li>你确定要贯穿行为，你可以在 <code>switch</code> 每个 <code>case</code> 末尾 使用 <code>fallthrough</code> 关键字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let num = 5</span><br><span class="line">var des = &quot;the num \(num) is&quot;</span><br><span class="line">switch num &#123;</span><br><span class="line">case 2,3,5,7:</span><br><span class="line">    des += &quot;a prime number&quot;</span><br><span class="line">    fallthrough</span><br><span class="line">default:</span><br><span class="line">    des += &quot; also a int&quot;</span><br><span class="line">&#125;</span><br><span class="line">print(des)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032224219.png"></p><h1 id="语句标签"><a href="#语句标签" class="headerlink" title="语句标签"></a>语句标签</h1><ul><li><p>可以用 <code>k</code> 来给循环语句或条件语句做标记。</p></li><li><p>配合 <code>break</code> 或 <code>continue</code> 来结束被标记的语句</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var num = 10</span><br><span class="line">whileLoop: while num &gt; 0 &#123;</span><br><span class="line">    switch num &#123;</span><br><span class="line">    case 9:</span><br><span class="line">        print(&quot;9&quot;)</span><br><span class="line">    case 10:</span><br><span class="line">        var sum = 0</span><br><span class="line">        for i in 0...10 &#123;</span><br><span class="line">            sum += i</span><br><span class="line">            if i == 9 &#123;</span><br><span class="line">                print(sum)</span><br><span class="line">                break whileLoop</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    default:</span><br><span class="line">        print(&quot;default&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    num -= 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032225782.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习23：更加强大的switch</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A023%EF%BC%9A%E6%9B%B4%E5%8A%A0%E5%BC%BA%E5%A4%A7%E7%9A%84switch/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A023%EF%BC%9A%E6%9B%B4%E5%8A%A0%E5%BC%BA%E5%A4%A7%E7%9A%84switch/</url>
      
        <content type="html"><![CDATA[<h1 id="swift"><a href="#swift" class="headerlink" title="swift"></a>swift</h1><ul><li><p><code>switch</code> 语句会将一个值与多个可能匹配的模式匹配，然后基于第一个成功匹配的模式来执行合适的代码块</p></li><li><p><code>switch</code> 语句一定得是全面的。给定类型里的每一个值都得匹配到一个 <code>switch</code> 的 <code>case</code>。你可以定义一个默认匹配的 <code>case</code> 来匹配所有未明确的值，用关键字 <code>default</code> 标记</p></li><li><p><code>OC</code> 中 <code>switch</code> 语句不全面，仍然可以运行</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let c:Character = &quot;z&quot;</span><br><span class="line">switch c &#123;</span><br><span class="line">case &quot;a&quot;:</span><br><span class="line">    print(&quot;the first letter is alphabet&quot;)</span><br><span class="line">case &quot;z&quot;:</span><br><span class="line">    print(&quot;the last letter is alphabet&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032220631.png"></p><p>修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let c:Character = &quot;z&quot;</span><br><span class="line">switch c &#123;</span><br><span class="line">case &quot;a&quot;:</span><br><span class="line">    print(&quot;the first letter is alphabet&quot;)</span><br><span class="line">case &quot;z&quot;:</span><br><span class="line">    print(&quot;the last letter is alphabet&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;other&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032221557.png"></p><h1 id="没有隐私贯穿"><a href="#没有隐私贯穿" class="headerlink" title="没有隐私贯穿"></a>没有隐私贯穿</h1><ul><li><p>相比 <code>OC</code> 和 <code>C</code> ，<code>Swift</code> 里的 <code>Switch</code> 不会默认从匹配的 <code>case</code> 末尾 <code>贯穿到下一个 case</code> 里</p></li><li><p>相反，整个 <code>Switch</code> 在匹配到第一个 <code>case</code> 执行完毕之后退出，不再需要显示 <code>break</code></p></li><li><p>每一个 <code>case</code> 的函数体必须包含至少一个可执行的语句</p></li><li><p>在一个 <code>Switch</code> 的 <code>case</code> 中匹配多个值可以用 <code>逗号分割</code>，并且可以写成多行</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let c = &quot;a&quot;</span><br><span class="line">switch c &#123;</span><br><span class="line">case &quot;a&quot;,&quot;e&quot;,&quot;i&quot;:</span><br><span class="line">    print(&quot;元音字母&quot;)</span><br><span class="line">case &quot;b&quot;,&quot;c&quot;:</span><br><span class="line">    print(&quot;符印字母&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;其他字符&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032221717.png"></p><h1 id="区间匹配"><a href="#区间匹配" class="headerlink" title="区间匹配"></a>区间匹配</h1><ul><li><code>Switch</code> 的 <code>case</code> 的值可以再一个区间中匹配</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let count = 43</span><br><span class="line">switch count&#123;</span><br><span class="line">case 0:</span><br><span class="line">    print(&quot;none&quot;)</span><br><span class="line">case 1...25:</span><br><span class="line">    print(&quot;1~25&quot;)</span><br><span class="line">case 26..&lt;51:</span><br><span class="line">    print(&quot;26~50&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;other&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032222555.png"></p><h1 id="元组匹配"><a href="#元组匹配" class="headerlink" title="元组匹配"></a>元组匹配</h1><ul><li><p>你可以使用元组来在一个 <code>switch</code> 中测试有多个值</p></li><li><p>使用下划线 <code>_</code> 来表明匹配所有可能的值</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let point = (1,1)</span><br><span class="line">switch point&#123;</span><br><span class="line">case (0,0):</span><br><span class="line">    print(&quot;point at origin&quot;)</span><br><span class="line">case (_,0):</span><br><span class="line">    print(&quot;point at x&quot;)</span><br><span class="line">case (0,_):</span><br><span class="line">    print(&quot;point at y&quot;)</span><br><span class="line">case (-2...2,-2...2):</span><br><span class="line">    print(&quot;point at box&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(0,0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032223063.png"></p><h1 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h1><ul><li><p><code>switch</code> 的 <code>case</code> 可以将匹配到的值临时 <code>绑定</code> 到一个 <code>常量或变量</code>，来给 <code>case</code> 的函数体使用</p></li><li><p>如果使用 <code>var</code> 关键字，临时的变量就会以合适的值来创建并初始化。对这个变量的任何改变都只会在 <code>case</code> 的函数体内有效</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let point = (1,0)</span><br><span class="line">switch point&#123;</span><br><span class="line">case (let x,0):</span><br><span class="line">    print(&quot;x is \(x) when y is 0&quot;)</span><br><span class="line">case (0,let y):</span><br><span class="line">    print(&quot;y is \(y) when x is 0&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;other&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032223344.png"></p><h1 id="where-语句"><a href="#where-语句" class="headerlink" title="where 语句"></a>where 语句</h1><ul><li><code>switch case</code> 可以使用 <code>where</code> 语句来检查是否符合特定的约束</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let point = (1,-1)</span><br><span class="line">switch point&#123;</span><br><span class="line">case (let x,let y) where x == y:</span><br><span class="line">    print(&quot;x == y&quot;)</span><br><span class="line">case (let x,let y) where x == -y:</span><br><span class="line">    print(&quot;x == -y&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;other&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032224503.png"></p><h1 id="复合匹配"><a href="#复合匹配" class="headerlink" title="复合匹配"></a>复合匹配</h1><ul><li><code>case</code> 后可以写多个模式来复合，在每个模式间用 <code>,</code> 号分割</li></ul><h1 id="复合匹配-值绑定"><a href="#复合匹配-值绑定" class="headerlink" title="复合匹配 - 值绑定"></a>复合匹配 - 值绑定</h1><ul><li>复合匹配同样可以包含 <code>值绑定</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习22：如何在Swift里进行循环控制</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A022%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8Swift%E9%87%8C%E8%BF%9B%E8%A1%8C%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A022%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8Swift%E9%87%8C%E8%BF%9B%E8%A1%8C%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for in 循环"></a>for in 循环</h1><ul><li><p>使用 <code>for in</code> 循环来遍历序列，比如一个范围的数字，数组中元素或者字符串中的字符</p></li><li><p>如果你不需要序列的每一个值，你可以使用下划线 <code>_</code> 来取代遍历名</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 遍历</span><br><span class="line">for i in 0...3&#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历字符串</span><br><span class="line">for c in &quot;hello,world&quot; &#123;</span><br><span class="line">    print(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历数组</span><br><span class="line">let letter = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">for str in letter &#123;</span><br><span class="line">    print(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="for-in-遍历字典"><a href="#for-in-遍历字典" class="headerlink" title="for in 遍历字典"></a>for in 遍历字典</h1><ul><li>当遍历字典时，每一个元素都返回一个 <code>(key,value) 元组</code>，你可以在 <code>for in</code> 循环体中使用显示命名常量来分解 <code>(key,value)</code> 元组成员</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let nums = [&quot;age&quot;:&quot;30&quot;,&quot;sex&quot;:&quot;男&quot;]</span><br><span class="line">for (key,value) in nums &#123;</span><br><span class="line">    print(&quot;key is \(key),value is \(value)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">for t in nums &#123;</span><br><span class="line">    print(&quot;key is \(t.0),value is \(t.1)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032219719.png"></p><h1 id="for-in-分段区间"><a href="#for-in-分段区间" class="headerlink" title="for in 分段区间"></a>for in 分段区间</h1><ul><li>使用 <code>stride(from:to:by)</code> 函数来跳过不想要的标记（<code>开区间</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in stride(from: 0, to: 50, by: 10) &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032219282.png"></p><ul><li><code>闭区间</code> 也同样适用，使用 <code>stride(from:through:by:)</code> 即可</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in stride(from: 0, through: 50, by: 10) &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032219011.png"></p><h1 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h1><ul><li><code>repeat-while</code> 循环 （oc 中是 <code>do-while</code>）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习21：如何在swift中自定义运算符</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A021%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8swift%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A021%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8swift%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义运算符"><a href="#自定义运算符" class="headerlink" title="自定义运算符"></a>自定义运算符</h1><ul><li><p>除了实现标准的运算符，在 <code>swift</code> 当中还可以声明和实现自定义运算符（custom operators）</p></li><li><p>新的运算符要在全局作用域内，使用 <code>operator</code> 关键字进行声明，同时还要指定 <code>prefix、infix</code> 或者 <code>postfix</code> 限定符</p></li></ul><p>【示例1】：一元运算符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">// 声明一元运算符</span><br><span class="line">prefix operator +++</span><br><span class="line"></span><br><span class="line">// 扩展</span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static prefix func +++ (vector: Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: vector.x + vector.x,y: vector.y + vector.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let vectorToDouble = Vector2D(x: 1.0,y: 2.0)</span><br><span class="line">let doubleVector = +++vectorToDouble</span><br><span class="line">print(&quot;\(doubleVector.x) \(doubleVector.y)&quot;)</span><br></pre></td></tr></table></figure><p>编译运行，查看打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.0 4.0</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032216751.png"></p><p>【示例2】：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 中缀运算符</span><br><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">infix operator +-: AdditionPrecedence</span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static func +- (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: left.x + right.x,y: left.y - right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let firstVector = Vector2D(x: 1.0,y: 3.0)</span><br><span class="line">let secondVector = Vector2D(x: 2.0,y: 5.0)</span><br><span class="line">let result = firstVector +- secondVector</span><br><span class="line">print(&quot;\(result.x) \(result.y)&quot;)</span><br></pre></td></tr></table></figure><p>编译运行，查看打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.0 -2.0</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032217206.png"></p><p>【示例3】：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 中缀运算符</span><br><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">infix operator *^: MultiplicationPrecedence</span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static func *^ (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: left.x * right.x,y: left.y * left.y + right.y * right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let firstVector = Vector2D(x: 1.0,y: 3.0)</span><br><span class="line">let secondVector = Vector2D(x: 2.0,y: 5.0)</span><br><span class="line">let result = firstVector *^ secondVector</span><br><span class="line">print(&quot;\(result.x) \(result.y)&quot;)</span><br></pre></td></tr></table></figure><p>编译运行，查看打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.0 34.0</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032217226.png"></p><h1 id="自定义中缀运算符的优先级和结合性"><a href="#自定义中缀运算符的优先级和结合性" class="headerlink" title="自定义中缀运算符的优先级和结合性"></a>自定义中缀运算符的优先级和结合性</h1><ul><li><p>自定义 <code>中缀（infix）</code> 运算符也可以指定优先级和结核性</p></li><li><p>每一个自定义的中缀运算符都属于一个 <code>优先级组</code></p></li><li><p>优先级组指定了自定义中缀运算符和其他中缀运算符的关系</p></li></ul><p>【示例】：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 优先级和结合性</span><br><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">infix operator +-: AdditionPrecedence</span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static func +- (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: left.x + right.x,y: left.y - right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">infix operator *^: MultiplicationPrecedence</span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static func *^ (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: left.x * right.x,y: left.y * left.y + right.y * right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let firstVector = Vector2D(x: 1.0,y: 2.0)</span><br><span class="line">let secondVector = Vector2D(x: 2.0,y: 3.0)</span><br><span class="line">let thirdVector = Vector2D(x: 3.0,y: 4.0)</span><br><span class="line">let result = firstVector +- secondVector *^ thirdVector</span><br><span class="line">print(&quot;\(result.x) \(result.y)&quot;)</span><br></pre></td></tr></table></figure><p>编译运行，查看打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7.0 -23.0</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032217682.png"></p><p>【注】：先计算 <code>*^</code> 优先级组，再计算 <code>+-</code> 优先级组</p><p>x: 2 * 3 &#x3D; 6 + 1 &#x3D; 7.0<br>y: 3 * 3 + 4 * 4 &#x3D; 2 - 25 &#x3D; -23</p><ul><li>接下来我们自己定义一个优先级组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 自定义优先级和结合性</span><br><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">infix operator +-: AdditionPrecedence</span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static func +- (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: left.x + right.x,y: left.y - right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">infix operator *^: MyPrecedencegroup</span><br><span class="line"></span><br><span class="line">// 我的优先级组</span><br><span class="line">precedencegroup MyPrecedencegroup &#123;</span><br><span class="line">    // 结合性</span><br><span class="line">    associativity: left</span><br><span class="line">    // 优先级</span><br><span class="line">    lowerThan: AdditionPrecedence</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static func *^ (left: Vector2D,right: Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: left.x * right.x,y: left.y * left.y + right.y * right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let firstVector = Vector2D(x: 1.0,y: 2.0)</span><br><span class="line">let secondVector = Vector2D(x: 2.0,y: 3.0)</span><br><span class="line">let thirdVector = Vector2D(x: 3.0,y: 4.0)</span><br><span class="line">let result = firstVector +- secondVector *^ thirdVector</span><br><span class="line">print</span><br></pre></td></tr></table></figure><p>编译运行，查看打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9.0 17.0</span><br></pre></td></tr></table></figure><p>【注】：先计算 <code>*^</code> 优先级组，再计算 <code>+-</code> 优先级组</p><p>x：1 + 2 &#x3D; 3 * 3 &#x3D; 9.0<br>y：2 - 3 &#x3D; -1 * -1 + 4 * 4 &#x3D; 17.0</p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习20：如何为类和结构体自定义运算符</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A020%EF%BC%9A%E5%A6%82%E4%BD%95%E4%B8%BA%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A020%EF%BC%9A%E5%A6%82%E4%BD%95%E4%B8%BA%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><ul><li><code>类和结构体</code> 可以为现有的运算符提供自定义的实现，称为 <code>运算符重载</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let vector = Vector2D(x: 1.0,y: 2.0)</span><br><span class="line">let anotherVertor = Vector2D(x: 3.0,y: 1.0)</span><br><span class="line">let thirdVertor = vector + anotherVertor</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303032047651.png"></p><ul><li>运算符重载</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static func + (left:Vector2D,right:Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: left.x + right.x,y: left.y + right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let vector = Vector2D(x: 1.0,y: 2.0)</span><br><span class="line">let anotherVertor = Vector2D(x: 3.0,y: 1.0)</span><br><span class="line">let thirdVector = vector + anotherVertor</span><br><span class="line">print(&quot;x is \(thirdVector.x),y is \(thirdVector.y)&quot;)</span><br></pre></td></tr></table></figure><p>编译运行，查看打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x is 4.0,y is 3.0</span><br></pre></td></tr></table></figure><h1 id="一元运算符的重载"><a href="#一元运算符的重载" class="headerlink" title="一元运算符的重载"></a>一元运算符的重载</h1><ul><li><p><code>类和结构体</code> 也能提供 <code>标准一元运算符</code> 的实现</p></li><li><p>要实现 <code>前缀</code> 或者 <code>后缀</code> 运算符，需要在声明运算符函数的时候在 <code>func</code> 关键字之前指定 <code>prefix</code> 或者 <code>postfix</code> 限定符</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">extension Vector2D &#123;</span><br><span class="line">    static prefix func - (vector:Vector2D) -&gt; Vector2D &#123;</span><br><span class="line">        return Vector2D(x: -vector.x,y: -vector.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let vector = Vector2D(x: 1.0,y: 2.0)</span><br><span class="line">let vector2 = -vector</span><br><span class="line">print(&quot;x is \(vector2.x),y is \(vector2.y)&quot;)</span><br></pre></td></tr></table></figure><p>编译运行，查看打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x is -1.0,y is -2.0</span><br></pre></td></tr></table></figure><h1 id="组合赋值运算符重载"><a href="#组合赋值运算符重载" class="headerlink" title="组合赋值运算符重载"></a>组合赋值运算符重载</h1><ul><li><p>组合赋值运算符将赋值运算符 <code>=</code> 与其他运算符进行结合</p></li><li><p>在实现的时候，需要把运算符的左参数设置成 <code>inout</code> 类型，因为这个参数的值会在运算符函数内直接被修改</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension Vector2D &#123;</span><br><span class="line">    static func += (left: inout Vector2D,right:Vector2D) &#123;</span><br><span class="line">        left = Vector2D(x: left.x + right.x,y: left.y + right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var vector3 = Vector2D(x: 1.0, y: 2.0)</span><br><span class="line">let vector4 = Vector2D(x: 2.0,y: 3.0)</span><br><span class="line">vector3 += vector4</span><br><span class="line">print(&quot;x is \(vector3.x),y is \(vector3.y)&quot;)</span><br></pre></td></tr></table></figure><p>编译运行，查看打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x is 3.0,y is 5.0</span><br></pre></td></tr></table></figure><h1 id="等价运算符重载"><a href="#等价运算符重载" class="headerlink" title="等价运算符重载"></a>等价运算符重载</h1><ul><li><p>自定义类和结构体不接收等价运算符的默认实现，也就是所谓的 <code>等于</code> 运算符 <code>==</code> 和 <code>不等于</code> 运算符 <code>!=</code></p></li><li><p>要使用等价运算符来检查你自己类型的等价，需要和其他 <code>中缀运算符</code> 一样提供一个 <code>等于</code> 运算符重载，并且遵循标准库的 <code>Equatable</code> 协议</p></li><li><p><code>swift</code> 为一下自定义类型提供等价运算符合成实现</p><ul><li>只有遵循 <code>Equatable</code> 协议存储属性的 <code>结构体</code></li><li>只拥有遵循 <code>Equatable</code> 协议关联类型的 <code>枚举</code></li><li>没有关联类型的枚举</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 等价运算符</span><br><span class="line">struct Vector2D &#123;</span><br><span class="line">    var x = 0.0,y = 0.0</span><br><span class="line">&#125;</span><br><span class="line">extension Vector2D: Equatable &#123;</span><br><span class="line">    static func == (left:Vector2D,right:Vector2D) -&gt; Bool &#123;</span><br><span class="line">        return (left.x == right.x) &amp;&amp; (left.y == right.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var vector1 = Vector2D(x: 1.0, y: 2.0)</span><br><span class="line">let vector2 = Vector2D(x: 2.0,y: 3.0)</span><br><span class="line">print(vector1 == vector2)</span><br></pre></td></tr></table></figure><p>编译运行，查看打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure><p><img src="/BboyZJ.github.io/assets/16778503288087.jpg"></p><h1 id="自定义中缀运算符的优先级和结合性"><a href="#自定义中缀运算符的优先级和结合性" class="headerlink" title="自定义中缀运算符的优先级和结合性"></a>自定义中缀运算符的优先级和结合性</h1><ul><li><p>自定义的中缀 <code>infix</code> 运算符也可以指定优先级和结合性</p></li><li><p>每一个自定义的中缀运算符都属于一个优先级组</p></li><li><p>优先级组指定了自定义中缀运算符和其他中缀运算符的关系</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习19：运算符优先级和结合性</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A019%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A019%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符优先级和结合性"><a href="#运算符优先级和结合性" class="headerlink" title="运算符优先级和结合性"></a>运算符优先级和结合性</h1><ul><li><p>运算符的优先级使得一些运算符优先于其他运算符，高优先级的运算符会先被计算</p></li><li><p>结合性定义了具有相同优先级的运算符是如何结合（或关联）的 一一 是左边结合为一组，还是与右边结合为一组。可以这样理解：它们是与左边的表达式结合的 或者 它们是与右边的表示式结合的</p></li></ul><p> <img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031851731.png"></p><h1 id="运算符优先级-显示括号"><a href="#运算符优先级-显示括号" class="headerlink" title="运算符优先级-显示括号"></a>运算符优先级-显示括号</h1><ul><li><p>2 + 3 % 4 * 5 等价于 2 + ((3 % 4) * 5)</p></li><li><p><code>swift</code> 语言中逻辑运算符 <code>&amp;&amp;</code> 和 <code>||</code> 是左相关的，这意味着多个逻辑运算符组合的表达式会首先计算最左边的</p></li></ul><p><img src="/BboyZJ.github.io/assets/16771566691861.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习18：运算符应用举例</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A018%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A018%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="两个数字交换"><a href="#两个数字交换" class="headerlink" title="两个数字交换"></a>两个数字交换</h1><ul><li>不借助临时变量，交换两个变量的值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a  = 1</span><br><span class="line">var b = 2</span><br><span class="line">a = a ^ b</span><br><span class="line">b = a ^ b</span><br><span class="line">a = a ^ b</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031839972.png"></p><h1 id="求无符号整数二进制中-1-的个数"><a href="#求无符号整数二进制中-1-的个数" class="headerlink" title="求无符号整数二进制中 1 的个数"></a>求无符号整数二进制中 1 的个数</h1><ul><li>给定一个无符号整型 <code>UInt</code> 变量，求其二进制表中 <code>1</code> 的个数，要求算法执行效率尽可能的高</li></ul><p>思路：看一个八位整数 <code>10 100 001</code> ，先判断最后一位是否为 <code>1</code> ，而 <code>与</code> 操作可以达到目前。可以把这个 <code>八位数字</code> 与 <code>00 0000 01</code> 进行 <code>与</code> 操作，如果结果为 <code>1</code>，则表示当前八位数的最后一位为 <code>1</code>，否则为 <code>0 </code>。怎么判断第 <code>二</code> 位呢？向右移位，再延续前面的判断即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 有几个 1</span><br><span class="line">func countsOfOnes(num:UInt) -&gt; UInt &#123;</span><br><span class="line">    var count:UInt = 0</span><br><span class="line">    var temp = num</span><br><span class="line">    while temp != 0 &#123;</span><br><span class="line">        // 如果都是位 1 才累加</span><br><span class="line">        count += temp &amp; 1</span><br><span class="line">        // 右移</span><br><span class="line">        temp = temp &gt;&gt; 1</span><br><span class="line">    &#125;</span><br><span class="line">    return count</span><br><span class="line">&#125;</span><br><span class="line">countsOfOnes(num: 8)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031841462.png"></p><ul><li>如果整数的二进制中有较多的 <code>0</code>，那么我们每一次右移做判断会很浪费，怎么改进前面的算法呢？有没有办法让算法的复杂度只有与 <code>1</code> 的个数有关？</li></ul><p>思路：为了简化这个问题，我们考虑只有高位 <code>1</code> 的情况。例如：11 000 000，如何跳过前面低位的 <code>6</code> 个 <code>0</code> ，而直接判断第 <code>七</code> 位的 <code>1？</code>我们可以设计 <code>11 000 000</code> 和 <code>10 111 111</code>（也就是 11 000 000 - 1）做 <code>与</code> 操作，消去最低位的 <code>1</code>。如果得到的结果为 <code>0</code>，说明我们已经找到或消去里面最后一个 <code>1</code>，如果不为 <code>0</code>，那么说明我们消去了最低位的 <code>1</code>，但是二进制中还有其他的 <code>1</code>，我们的计数器需要加 <code>1</code>，然后继续上面的操作</p><p>计数器 count &#x3D; 0</p><p>步骤一：整数不为0，说明二进制里面肯定有1，count &#x3D; 1</p><p>11 000 000 &amp; 10 111 111 &#x3D; 10 000 000 (消去第7位的1)</p><p>步骤二：结果不为 0，说明二进制里还有 1，count &#x3D; 2</p><p>10 000 000 &amp; 01 111 111 &#x3D; 0（消去第8位的1）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func countsOfOnes2(num:UInt) -&gt; UInt &#123;</span><br><span class="line">    var count:UInt = 0</span><br><span class="line">    var temp = num</span><br><span class="line">    while temp != 0 &#123;</span><br><span class="line">        count += 1</span><br><span class="line">        temp = temp &amp; (temp - 1)</span><br><span class="line">    &#125;</span><br><span class="line">    return count</span><br><span class="line">&#125;</span><br><span class="line">countsOfOnes2(num: 3)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031844480.png"></p><h1 id="引申：如果判断一个征收为2的整数次幂"><a href="#引申：如果判断一个征收为2的整数次幂" class="headerlink" title="引申：如果判断一个征收为2的整数次幂"></a>引申：如果判断一个征收为2的整数次幂</h1><ul><li><p>给定一个无符号整型 <code>UInt</code> 变量，判断是否为 <code>2</code> 的整数次幂</p></li><li><p>思路：一个整数如果是 <code>2</code> 的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位都是 <code>0</code>，根据前面的分析，把这个整数减去 <code>1</code> 后再和它自己做 <code>&amp;</code> 运算，这个整数中唯一的 <code>1</code> 就变成 <code>0</code> 了，也就是得到的结果是 <code>0</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 2的整数次幂</span><br><span class="line">func isPowerTwo(num:UInt) -&gt; Bool &#123;</span><br><span class="line">    return (num &amp; (num - 1)) == 0</span><br><span class="line">&#125;</span><br><span class="line">isPowerTwo(num: 18)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031845987.png"></p><h1 id="缺失的数字"><a href="#缺失的数字" class="headerlink" title="缺失的数字"></a>缺失的数字</h1><ul><li>很多成对出现的正整数保存在磁盘文件中，注意成对数字不一定是相邻的，如果 <code>2、3、4、3、4、2、..</code>，由于意外有一个数字消失了，如何尽快找到是哪个数字消失了？</li></ul><p>思路：考虑 <code>^</code> 异或操作的定义，当两个操作的数对应位不相同时，改数的对应位就为1。也就是说如果是相等的两个数 <code>^异或</code>，得到的结果就是 <code>0</code>，而 <code>0</code> 与任何数字 <code>^异或</code>，得到的是那个数字本身。所以我们考虑将所有的数字做 <code>^异或操作</code>，因为只有一个数字消失，那么其他俩俩出现的数字 <code>^异或后为0</code>，0与仅有的一个的数字做 <code>^异或</code>，我们就得到了消失的数字是哪个？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 缺失的数字</span><br><span class="line">func findLostNum(nums:[UInt]) -&gt; UInt &#123;</span><br><span class="line">    var lostNum:UInt = 0</span><br><span class="line">    for num in nums &#123;</span><br><span class="line">        lostNum = lostNum ^ num</span><br><span class="line">    &#125;</span><br><span class="line">    return lostNum</span><br><span class="line">&#125;</span><br><span class="line">findLostNum(nums: [1,3,2,4,2,1,3])</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031851072.png"></p><ul><li>如果有两个数字意外丢失了（丢失的不是相等的数字），改如何找到丢失的两个数字？</li></ul><p>思路：<br>假设题目中这两个只出现1次的数字分别是A和B，如果能将A，B分开到二个数组中，那显然符合 异或 解法的关键点了，因此这个题目的关键点事将A和B分开到二个数组中。<br>由于A，B肯定是不相等的，因此在二进制上肯定有一位是不同的。根据这一位是 0 还是 1 可以将A和B分开到A组合B组。<br>而这个数组中其它数字那么就属于A组，要么就属于B组。再对A组 和 B组 分别执行 异或 解法，就可以得到A,B了。<br>而要判断A，B在哪一位上不相同，只要根据 A ^ B 的结果就可以知道了，这个结果在二进制上为 1 的位都说明 A，B在这一位上是不同的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 丢失的两个不同数</span><br><span class="line">func findTwoLostNum(nums:[UInt]) -&gt; (UInt,UInt) &#123;</span><br><span class="line">    var lostNum1:UInt = 0</span><br><span class="line">    var lostNum2:UInt = 0</span><br><span class="line">    var temp:UInt = 0</span><br><span class="line">    // 计算两个数的异或结果</span><br><span class="line">    for num in nums &#123;</span><br><span class="line">        temp = temp ^ num</span><br><span class="line">    &#125;</span><br><span class="line">    // 找到第一个为 1 的位</span><br><span class="line">    var flag:UInt = 1</span><br><span class="line">    while ((flag &amp; temp) == 0) &#123;</span><br><span class="line">        flag = flag &lt;&lt; 1</span><br><span class="line">    &#125;</span><br><span class="line">    // 找到两个丢失的数字</span><br><span class="line">    for num in nums &#123;</span><br><span class="line">        if (num &amp; flag) == 0 &#123;</span><br><span class="line">            lostNum1 = lostNum1 ^ num</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            lostNum2 = lostNum2 ^ num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (lostNum1,lostNum2)</span><br><span class="line">&#125;</span><br><span class="line">findTwoLostNum(nums: [1,2,3,4,2,1])</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031851154.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习17：位运算符</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A017%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A017%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="位取反运算符"><a href="#位取反运算符" class="headerlink" title="位取反运算符"></a>位取反运算符</h1><ul><li>位取反运算符 <code>~</code> 是对所有位的数字进行取反操作</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031824254.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let n1:UInt8 = 255</span><br><span class="line">let n2 = ~n1</span><br><span class="line">print(n2)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031825231.png"></p><h1 id="位与运算符"><a href="#位与运算符" class="headerlink" title="位与运算符"></a>位与运算符</h1><ul><li>位与运算符 <code>&amp;</code> 可以对两个数的比特位进行合并，它会返回一个新的数，只有当这两个数都是 <code>1</code> 时才能返回 <code>1</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031825798.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let n1:UInt8 = 255</span><br><span class="line">let n2 = ~n1</span><br><span class="line">let n3 = n1 &amp; n2</span><br><span class="line">let n4 = n1 | n2</span><br><span class="line">print(n3)</span><br><span class="line">print(n4)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031826604.png"></p><h1 id="位或运算符"><a href="#位或运算符" class="headerlink" title="位或运算符"></a>位或运算符</h1><ul><li>位或运算符 <code>|</code> 可以对两个比特位进行比较，然后返回一个新的数，只要两个操作位任意一个为 <code>1</code> 时，那么对应的位数就为 <code>1</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031826047.png"></p><h1 id="位异或运算符"><a href="#位异或运算符" class="headerlink" title="位异或运算符"></a>位异或运算符</h1><ul><li>位异或运算符，或者说 互斥或 <code>^</code> 可以对两个数的比特位进行比较，它返回一个新的数，当两个操作数的对应位不同时，该数的对应位就为 <code>1</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031827719.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let n1:UInt8 = 255</span><br><span class="line">let n2 = ~n1</span><br><span class="line">let n5 = n1 ^ n2</span><br><span class="line">print(n5)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031828749.png"></p><h1 id="位左移和右移运算符"><a href="#位左移和右移运算符" class="headerlink" title="位左移和右移运算符"></a>位左移和右移运算符</h1><ul><li><p>位左移运算符 <code>&lt;&lt;</code> 和位右移运算符 <code>&gt;&gt;</code> 可以把所有位数的数字向左或向右移动一个确定的位数</p></li><li><p>位 <code>左移和右移</code> 具有给 <code>整数乘以或除以二</code> 的效果，将一个数 <code>左移</code> 一位相当于把这个 <code>数翻</code>倍，将一个数 <code>右移</code> 相当于把这个数 <code>减半</code></p></li></ul><h1 id="无符号整数的位移操作"><a href="#无符号整数的位移操作" class="headerlink" title="无符号整数的位移操作"></a>无符号整数的位移操作</h1><ul><li><p>已经存在的比特位按指定的位数进行左移和右移</p></li><li><p>任何移动超出整型存储边界的位都会被丢弃</p></li><li><p>用 <code>0</code> 来填充向左或向右移动后产生的空白位</p></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031829164.png"></p><h1 id="有符号整数的位移操作"><a href="#有符号整数的位移操作" class="headerlink" title="有符号整数的位移操作"></a>有符号整数的位移操作</h1><ul><li>有符号整数使用它的第一位（所谓的符号位）来表示这个整数是正数还是负数，符号位 <code>0</code> 表示 <code>正数</code>，<code>1</code> 表示 <code>负数</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031829054.png"></p><ul><li><p>其余的位数（所谓的数值位）存储了实际的值，有符号正整数和无符号数的存储方式是一样的，都是从 <code>0</code> 开始算起</p></li><li><p>但是负数的存储方式略有不同，它存储的是 <code>2</code> 的 <code>n</code> 次方减去它的绝对值，这里的 <code>n</code> 为数值位的位数</p></li></ul><p> <img src="/BboyZJ.github.io/assets/16771506508589.jpg"></p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let n6: Int = 8</span><br><span class="line">print(n6 &lt;&lt; 1)</span><br><span class="line">print(n6 &gt;&gt; 1)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031831199.png"></p><h1 id="补码表示的优点"><a href="#补码表示的优点" class="headerlink" title="补码表示的优点"></a>补码表示的优点</h1><ul><li>首先，如果想给 <code>-4</code> 加个 <code>-1</code>，只需要将这两个数的全部 <code>8</code> 个比特位相加（包括符号位），并且将计算结果中超出的部分丢掉</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031832104.png"></p><ul><li>其次，使用二进制补码可以使负数位的位左移和右移操作得到根正数同样的效果，即每向左移一位就将自身的数值 <code>乘以2</code> ，每向右移一位就将自身的数值 <code>除以2</code>，要达到此目的，对 <code>有符号的整数</code> 的右移有一个额外的规则：当对整数进行位右移操作时，遵循与无符号整数相同的规则，但是对于位移产生的空白位使用符号进行填充，而不是 <code>0</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031838090.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习16：区间运算符</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A016%EF%BC%9A%E5%8C%BA%E9%97%B4%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A016%EF%BC%9A%E5%8C%BA%E9%97%B4%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="闭区间运算符"><a href="#闭区间运算符" class="headerlink" title="闭区间运算符"></a>闭区间运算符</h1><ul><li>闭区间运算符 <code>a...b</code> 定义了从 <code>a</code> 到 <code>b</code> 的一组范围，并且包含 <code>a</code> 和 <code>b</code> ，<code>a</code> 的值不能大于 <code>b</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 闭区间</span><br><span class="line">let range = 0...5</span><br><span class="line">for index in range &#123;</span><br><span class="line">    print(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="半开区间运算符"><a href="#半开区间运算符" class="headerlink" title="半开区间运算符"></a>半开区间运算符</h1><ul><li>半开区间运算符 <code>a..&lt;b</code> 定义了从 <code>a</code> 到 <code>b</code> 但不包括 <code>b</code> 的区间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 半开半闭区间</span><br><span class="line">let range = 0..&lt;5</span><br><span class="line">for index in range &#123;</span><br><span class="line">    print(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如同闭区间运算符，<code>a</code> 的值也不能大于 <code>b</code> ，如果 <code>a</code> 与 <code>b</code> 的值相等，那返回的区间将会是空的</li></ul><h1 id="单侧区间"><a href="#单侧区间" class="headerlink" title="单侧区间"></a>单侧区间</h1><ul><li>闭区间运算符有另外一种形式来让区间朝一个方向尽可能的远，这种区间叫做单侧区间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 单侧闭区间</span><br><span class="line">let names = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</span><br><span class="line">for name in names[...2] &#123;</span><br><span class="line">    print(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031820388.png"></p><ul><li>半开区间运算符同样可以有单侧形式，只需要写它最终的值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 单侧半开半闭区间</span><br><span class="line">let names = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</span><br><span class="line">for name in names[..&lt;2] &#123;</span><br><span class="line">    print(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031822902.png"></p><ul><li>比如说，一个包含数组所有元素的区间，从索引 <code>2</code> 到数组的结束，在这种情况下，你可以省略区间运算符一侧的值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for name in names[2...] &#123;</span><br><span class="line">    print(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>单侧区间可以再其他上下文中使用，不仅仅是下标</p></li><li><p>不能变量省略了第一个值的单侧区间，因为遍历根本不知道该从哪里开始，你可以遍历省略了最终值的单侧区间</p></li></ul><h1 id="字符串索引区间"><a href="#字符串索引区间" class="headerlink" title="字符串索引区间"></a>字符串索引区间</h1><ul><li>字符串范围可以使用区间运算符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 字符串索引区间</span><br><span class="line">var str = &quot;hello,world&quot;</span><br><span class="line">let range = str.startIndex...str.index(str.endIndex, offsetBy: -6)</span><br><span class="line">str.removeSubrange(range)</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031822403.png"></p><h1 id="倒叙索引"><a href="#倒叙索引" class="headerlink" title="倒叙索引"></a>倒叙索引</h1><ul><li>通过 <code>reversed()</code> 方法，我们可以将一个正序循环变成逆序循环</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 逆序</span><br><span class="line">for i in (0...4).reversed() &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031823875.png"></p><h1 id="Comparable-区别"><a href="#Comparable-区别" class="headerlink" title="Comparable 区别"></a>Comparable 区别</h1><ul><li>区间运算符可以作用在 <code>Comparable</code> 类型上，返回闭区间和半闭区间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello,world&quot;</span><br><span class="line">let range = &quot;a&quot;...&quot;z&quot;</span><br><span class="line">for c:Character in str &#123;</span><br><span class="line">    if !range.contains(String(c)) &#123;</span><br><span class="line">        print(&quot;\(c) 不是小写字符&quot;)</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303031823752.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习15：为了Optional，合并空置运算符</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A015%EF%BC%9A%E4%B8%BA%E4%BA%86Optional%EF%BC%8C%E5%90%88%E5%B9%B6%E7%A9%BA%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A015%EF%BC%9A%E4%B8%BA%E4%BA%86Optional%EF%BC%8C%E5%90%88%E5%B9%B6%E7%A9%BA%E7%BD%AE%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="合并空值运算符"><a href="#合并空值运算符" class="headerlink" title="合并空值运算符"></a>合并空值运算符</h1><ul><li><p>合并空值运算符 <code>a ?? b</code> 如果可选项 <code>a</code> 有值则展开，如果没有值是 <code>nil</code>，则返回默认值 <code>b</code></p></li><li><p>表达式 <code>a</code> 必须是一个可选类型，表达式 <code>b</code> 必须与 <code>a</code> 的存储类型相同</p></li></ul><p><img src="/BboyZJ.github.io/assets/16776915687917.jpg"></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020126317.png"></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020126785.png"></p><ul><li><p>实际上是 <code>三元运算符</code> 作用到 <code>Optional</code> 上的缩写 <code>a != nil ? a : b</code></p></li><li><p>如果 <code>a</code> 的值是非空的，<code>b</code> 的值将不会被考虑，也就是合并空值运算符是短路的</p></li><li><p>可选值为nil时，不能强制解包</p></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020127661.png"></p><p>可以用 <code>if</code> 判断实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let a:Int? = nil</span><br><span class="line">let b = 2</span><br><span class="line">func sum(x:Int?,y:Int?) -&gt; Int&#123;</span><br><span class="line">//    return x! + y!</span><br><span class="line">    if x != nil &#123;</span><br><span class="line">        if y != nil &#123;</span><br><span class="line">            return x! + y!</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return x!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        if y != nil &#123;</span><br><span class="line">            return y!</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用 ?? 来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return (a ?? 0) + b</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习14：在Swift里如何处理算术结果溢出</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A014%EF%BC%9A%E5%9C%A8Swift%E9%87%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%AE%97%E6%9C%AF%E7%BB%93%E6%9E%9C%E6%BA%A2%E5%87%BA/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A014%EF%BC%9A%E5%9C%A8Swift%E9%87%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%AE%97%E6%9C%AF%E7%BB%93%E6%9E%9C%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="溢出运算符"><a href="#溢出运算符" class="headerlink" title="溢出运算符"></a>溢出运算符</h1><ul><li><p>在默认情况下，当向一个整数赋超出它容量的值时，<code>swift</code> 会报错而不是生成一个无效的数，给我们操作过大或过小的数时提供了额外的安全性</p></li><li><p>同时提供三个算术溢出运算符来让系统支持整数溢出运算</p><ul><li>溢出加法 <code>&amp;+</code></li><li>溢出减法 <code>&amp;-</code></li><li>溢出乘法 <code>&amp;*</code></li></ul></li></ul><h1 id="值溢出"><a href="#值溢出" class="headerlink" title="值溢出"></a>值溢出</h1><ul><li>数值可以出现向上溢出或向下溢出</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020128841.png"></p><ul><li><p>溢出也会发生在有符号整型数值上</p></li><li><p>对于无符号与有符号整型数值来说，当出现溢出时，它们会从数值所能容纳的最大数变成最小的数，同样的，当发生下溢时，它们会从所能容纳的最小数变成最大的数</p></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020128708.png"></p><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><ul><li>上溢出</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020128353.png"></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020128449.png"></p><ul><li>下溢出</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020129637.png"></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020129471.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习13：赋值和算术运算符</title>
      <link href="/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A013%EF%BC%9A%E8%B5%8B%E5%80%BC%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/BboyZJ.github.io/2023/02/23/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A013%EF%BC%9A%E8%B5%8B%E5%80%BC%E5%92%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li><p>一元运算符对一个目标进行操作。一元前缀运算符（如!b），一元后缀运算符（b!）</p></li><li><p>二元运算符对两个目标进行操作（a+b）同时因为它们出现在两个目标之间，所以是中缀</p></li><li><p>三元运算符操作三个目标，<code>swift</code> 语言也仅有一个 <code>三元运算符</code>，三元条件运算符（a?b:c）</p></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020122710.png"></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020122158.png"></p><h1 id="swift-运算符的改进"><a href="#swift-运算符的改进" class="headerlink" title="swift 运算符的改进"></a>swift 运算符的改进</h1><ul><li><p>swift在支持 <code>c</code> 中的大多数标准运算符的同时也增加了一些排除常见代码错误的能力</p></li><li><p>赋值符号 <code>=</code> 不会返回值，以防止它被无用于等于符号 <code>==</code> </p></li><li><p>算术符号 <code>+、-、*、/、%</code> 以及其他可以监测并阻止值溢出，以避免你在操作比存储类型允许的范围更大或更小的数字时得到各种奇怪的结果</p></li></ul><h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><ul><li><p>赋值运算符将一个值赋值给另外一个值</p></li><li><p>如果赋值符号右侧是拥有多个值的元组，它的元素将会一次性地拆分成常量或者变量</p></li><li><p>Swift 的赋值符号自身不会返回值</p></li></ul><h1 id="算术运算符-标准运算符"><a href="#算术运算符-标准运算符" class="headerlink" title="算术运算符-标准运算符"></a>算术运算符-标准运算符</h1><ul><li><p>标准算术运算符 <code>+ - * /</code></p></li><li><p>算术运算符同时也支持 <code>String</code> 的拼接</p></li><li><p><code>swift</code> 算术运算符默认不允许值溢出</p></li></ul><h1 id="算术运算符-余数运算符"><a href="#算术运算符-余数运算符" class="headerlink" title="算术运算符 - 余数运算符"></a>算术运算符 - 余数运算符</h1><ul><li><p>余数运算符 <code>a%b</code> 可以求出多少个 <code>b</code> 的倍数能够刚好放进 <code>a</code> 中并且返回剩下的值（就是我们所谓的余数）</p></li><li><p>当 <code>a</code> 是负数时也适用相同的方法来进行计算</p></li><li><p>当 <code>b</code> 为负数时它的正负号被忽略掉。这意味着 <code>a%b</code> 与 <code>a%-b</code> 能够获得相同的答案</p></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020123693.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let c = 9 % 4</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">let d = 9 % -4</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">let e = -9 % 4</span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020124939.png"></p><h1 id="算术运算符-一元"><a href="#算术运算符-一元" class="headerlink" title="算术运算符 - 一元"></a>算术运算符 - 一元</h1><ul><li><p>数字值的正负号可以用前缀 <code>-</code> 来切换，我们称之为一元减号运算符</p></li><li><p>一元减号运算符 <code>-</code> 直接在要进行操作的值前边放置，不加任何空格</p></li><li><p>一元加号运算符 <code>+</code> 直接返回它操作的值，不会对其进行任何的修改</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习12：获取子串和字符串比较</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A012%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AD%90%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A012%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AD%90%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h1 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h1><ul><li><p>使用下标或者类似 <code>prefix(_:)</code> 的方法得到的子字符串是 <code>Substring</code> 类型</p></li><li><p><code>Substring</code> 拥有 <code>String</code> 的大部分方法</p></li><li><p><code>Substring</code> 可以转成 <code>String</code> 类型</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;hello,world&quot;</span><br><span class="line">let index = str.firstIndex(of: &quot;,&quot;) ?? str.endIndex</span><br><span class="line">let begin = str[..&lt;index]</span><br><span class="line">let new = String(begin)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020120015.png"></p><ul><li><p>子字符串重用一部分原字符串的内存</p></li><li><p>修改字符串或子字符串之前都不需要花费拷贝内存的代价</p></li><li><p><code>String</code> 和 <code>Substring</code> 都遵循 <code>StringProtocol</code> 协议，也就是说它基本上都能很方便的兼容所有接受 <code>StringProtocol</code> 值的字符串操作函数</p></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020121376.png"></p><h1 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h1><ul><li><p>字符串和字符相等性 <code>==</code> 和 <code>!=</code></p></li><li><p>前缀相等性 <code>hasPrefis(_:)</code></p></li><li><p>后缀相等性 <code>hasSubffix(_:)</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &quot;1&quot;</span><br><span class="line">var str2 = &quot;2&quot;</span><br><span class="line">print(str1 == str2)</span><br><span class="line">print(str1.hasPrefix(&quot;1&quot;))</span><br><span class="line">print(str2.hasSuffix(&quot;2&quot;))</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020121878.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习11：索引访问和修改字符串</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A011%EF%BC%9A%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A011%EF%BC%9A%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h1><ul><li><p>每一个 <code>String</code> 值都有相关的索引类型，<code>String.Index</code>，他相当于每个 <code>Character</code> 在字符串中的位置</p></li><li><p><code>startIndex</code> 属性来访问 <code>String</code> 中第一个 <code>Character</code> 的位置。<code>endIndex</code> 属性就是 <code>String</code> 中最后一个字符串的位置</p></li><li><p><code>endIndex</code> 属性并不是字符串下标脚本的合法实际参数</p></li><li><p>如果 <code>String</code> 为空，则 <code>startIndex</code> 与 <code>endIndex</code> 相等</p></li><li><p>使用 <code>index(before:)</code> 和 <code>index(after:)</code> 方法来访问给定索引的前后</p></li><li><p>要访问给定索引更远的索引，你可以使用 <code>index(_:offetBy:)</code></p></li><li><p>使用 <code>indices</code> 属性来访问字符串中每个字符的索引</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var greeting = &quot;Hello, playground&quot;</span><br><span class="line">greeting[greeting.startIndex]</span><br><span class="line">greeting[greeting.index(before: greeting.endIndex)]</span><br><span class="line">greeting[greeting.index(after: greeting.startIndex)]</span><br><span class="line">let index = greeting.index(greeting.startIndex, offsetBy: 7)</span><br><span class="line">greeting[index]</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020116804.png"></p><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><ul><li><p>插入字符，使用 <code>insert(_:at:)</code> 方法</p></li><li><p>插入到另一个字符串的内容到特定的索引，使用 <code>insert(contentsOf:at:)</code> 方法</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello&quot;</span><br><span class="line">str.insert(&quot;!&quot;, at: str.endIndex)</span><br><span class="line">str.insert(contentsOf: &quot; world&quot;, at: str.firstIndex(of: &quot;!&quot;)!)</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020117964.png"></p><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><ul><li>移除字符，使用 <code>remove(at:)</code> 方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello&quot;</span><br><span class="line">str.remove(at: str.index(before: str.endIndex))</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020117857.png"></p><ul><li>移除一小段特定范围的字符串，使用 <code>removeSubrange(_:)</code> 方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello&quot;</span><br><span class="line">let range = str.index(str.endIndex, offsetBy: -str.count)..&lt;str.endIndex</span><br><span class="line">str.removeSubrange(range)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020117645.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习10：字符串常见操作</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A010%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A010%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串的可变性"><a href="#字符串的可变性" class="headerlink" title="字符串的可变性"></a>字符串的可变性</h1><ul><li><code>var</code> 指定的可以修改</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020114183.png"></p><ul><li><code>let</code> 指定的不可修改</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020106762.png"></p><ul><li>对比 Object-C (NSString 和 NSMutableString)</li></ul><h1 id="字符串是-值类型"><a href="#字符串是-值类型" class="headerlink" title="字符串是 值类型"></a>字符串是 值类型</h1><ul><li><p><code>String</code> 值在传递给方法或函数的时候会被复制过去</p></li><li><p>赋值给常量或变量的时候也是一样</p></li><li><p>Swift 编译器优化了字符串使用的资源，实际上拷贝只会在确实需要的时候才进行</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &quot;hello&quot;</span><br><span class="line">var str2 = str1</span><br><span class="line">print(str1 == str2)</span><br><span class="line">str1.append(&quot;,world&quot;)</span><br><span class="line">print(str1)</span><br><span class="line">print(str2)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020109392.png"></p><h1 id="操作字符"><a href="#操作字符" class="headerlink" title="操作字符"></a>操作字符</h1><ul><li><p><code>for in</code> 循环遍历 <code>String</code> 中的每一个独立的 <code>Character</code></p></li><li><p><code>Character</code> 类型</p></li><li><p><code>String</code> 值可以通过传入 <code>Character</code> 数组来构造</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;hello&quot;</span><br><span class="line">for c in str&#123;</span><br><span class="line">    print(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020109024.png"></p><h1 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h1><ul><li><p>使用加运算符 <code>+</code> 创建新字符串</p></li><li><p>使用 <code>+</code> 赋值符号 <code>+=</code> 在已经存在的 <code>String</code> 值末尾追加一个 <code>String</code> 值</p></li><li><p>使用 <code>String</code> 类型的 <code>append()</code> 方法来可以给一个 <code>String</code> 变量的末尾追加 <code>Character</code> 值</p></li></ul><h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><ul><li><p>字符串插值是一种从混合常量、变量、字面量和表达式的字符串字面量构造新 <code>String</code> 值的方法</p></li><li><p>每一个你插入到字符串字面量的元素都要被一对圆括号包裹，然后使用反斜杠前缀 <code>\()</code></p></li><li><p>类似于 <code>NSString</code> 的 <code>stringWithFormat</code> 方法，但是更加简便，更强大</p></li><li><p>可以在扩展字符串分割符中创建一个包含在其他情况下会被当做字符串插值的字符</p></li><li><p>要在使用扩展分隔符的字符串中使用字符串插值，在反斜杠后使用匹配首尾井号数量的井号</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;6 * 7 = \(6 * 7)&quot;</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020110881.png"></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020115034.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习09：字符串创建和使用</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A009%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A009%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="初始化空串"><a href="#初始化空串" class="headerlink" title="初始化空串"></a>初始化空串</h1><ul><li><p>字面量</p></li><li><p>初始化器语法</p></li><li><p><code>isEmpty</code> 检查是否为空串</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var emptyString = &quot;&quot;</span><br><span class="line">var anotherEmptyString = String()</span><br><span class="line"></span><br><span class="line">if emptyString.isEmpty &#123;</span><br><span class="line">    print(&quot;Nothing to see here&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020103809.png"></p><h1 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h1><ul><li><p>字符串字面量是被双引号 <code>“”</code> 包裹的固定顺序文本字符</p></li><li><p><code>Swift</code> 会为 <code>str</code> 常量推断类型为 <code>String</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;some string&quot;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020104645.png"></p><h1 id="多行字面量"><a href="#多行字面量" class="headerlink" title="多行字面量"></a>多行字面量</h1><ul><li><p>多行字符串字面量是用三个双引号引起来的一系列字符</p></li><li><p>多行字符串字面量把所有行包括在引号内，开始和结束默认不会有换行符</p></li><li><p>如果为了书写美观而不换行在后面加 \</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let someStr = &quot;&quot;&quot;</span><br><span class="line">1\</span><br><span class="line">2\</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">print(someStr)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020104457.png"></p><ul><li><p>要让多行字符串字面量起始或结束于换行，就在第一或最后一行写一个空行</p></li><li><p>多行字符串可以 <code>缩进</code> 以匹配周围的代码。双引号（”””）前的空格会告诉Swift其他行前应该有多少空白是需要忽略的</p></li><li><p>如果你在某行的空格超过了结束的双引号（”””），那么这些空格会被包含</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    let someStr = &quot;&quot;&quot;</span><br><span class="line">    1</span><br><span class="line">    2</span><br><span class="line">        3</span><br><span class="line">    4</span><br><span class="line">    5</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">print(someStr)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020104509.png"></p><h1 id="字符串里的特殊字符"><a href="#字符串里的特殊字符" class="headerlink" title="字符串里的特殊字符"></a>字符串里的特殊字符</h1><ul><li><p>转义特殊字符 \o（空字符）,\（反斜杠），\t（水平制表符），\n（换行符），\r（回车符），\”（双引号）以及 &#39;（单引号）</p></li><li><p>任意的 <code>Unicode</code> 标量，写作 <code>\u&#123;&#125;n</code>，里边的 <code>n</code> 是一个 <code>1-8</code> 位的16进制数字，其值是合法 <code>Unicode</code> 值</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;\u&#123;24&#125;&quot;</span><br></pre></td></tr></table></figure><ul><li>可以在多行字符串字面量中包含双引号（”）而不需要转义。要在多行字符串中包含文本 “”””””，转义至少一个双引号</li></ul><h1 id="扩展字符串分隔符-Raw-String"><a href="#扩展字符串分隔符-Raw-String" class="headerlink" title="扩展字符串分隔符(Raw String)"></a>扩展字符串分隔符(Raw String)</h1><ul><li><p>在字符串字面量中放置扩展分隔符来使 <code>包含特殊字符的字符串</code> 不让他们真的生效</p></li><li><p>把字符串放在双引号 (“) 内并由 (#) 包裹</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = #&quot;1\n2\n3\n&quot;#</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020105441.png"></p><ul><li>如果字符串里面有 <code>&quot;#</code> 则首尾需要两个 <code>##</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = ##&quot;1\&quot;#n2\#n3\#n&quot;##</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020105787.png"></p><ul><li>如果你需要字符串中某个特殊符号的效果，使用匹配你包裹的 <code>#</code> 号数量的 <code>#</code> 号，并在前面写转义符号 <code>\</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let str = #&quot;1\#n2\#n3\#n&quot;#</span><br><span class="line">print(str)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020105373.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习08：Optional的使用Optional实现原理探索</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A008%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8Optional%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A008%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8Optional%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Optional-实现探究"><a href="#Optional-实现探究" class="headerlink" title="Optional-实现探究"></a>Optional-实现探究</h1><ul><li><p><code>Optional</code> 其实是一个标准库里的一个  <code>public 的 enum</code> 类型，而且是 <code>泛型</code> 的，泛型的类型是 <code>Wrapped</code></p></li><li><p>用标准库实现语言特性的典型</p></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020100711.png"></p><ul><li><p>Optional.none 就是 <code>nil</code></p></li><li><p>Optional.some 则包装了实际的值</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str:Optional&lt;String&gt; = &quot;abc&quot;</span><br><span class="line">if let actualStr = str &#123;</span><br><span class="line">    let count = actualStr.count</span><br><span class="line">    print(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020101182.png"></p><h1 id="Optional-解包实现"><a href="#Optional-解包实现" class="headerlink" title="Optional-解包实现"></a>Optional-解包实现</h1><ul><li>泛型属性 <code>unsafelyUnwrapped</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020102043.png"></p><ul><li>理论上我我们可以直接调用 <code>unsafelyUnwrapped</code> 获取可选项的值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str:String? = &quot;abc&quot;</span><br><span class="line">let count = str.unsafelyUnwrapped.count</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020102203.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习07：Optional的使用</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A007%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A007%EF%BC%9AOptional%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要-Optional？"><a href="#为什么需要-Optional？" class="headerlink" title="为什么需要 Optional？"></a>为什么需要 Optional？</h1><ul><li><p>Object-C 中用 <code>nil</code> 表示 <code>指向不存在对象的指针</code>，其他地方用 <code>NSNotFound</code> 表示 <code>值缺失</code></p></li><li><p>Swift 中用 <code>可选（Optional）</code> 类型表示 <code>值缺失</code>，只有可选类型才能设置为 <code>nil</code></p></li><li><p>Optional 含有两种枚举，<code>None</code> 和 <code>Some(T)</code>，用来表示可能有值或可能没有值。</p></li></ul><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var optionalInteger: Int?</span><br><span class="line">var optionalInteger: Optional&lt;Int&gt;</span><br></pre></td></tr></table></figure><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><ul><li><p>通过在 <code>变量类型</code> 后面加 <code>?</code> 表示这里有一个值，它等于 <code>x</code>，或者这里根本没有值</p></li><li><p>你可以通过给可选变量赋值一个 <code>nil</code> 来将之设置为没有值</p><ul><li><p>在 <code>Object-C</code> 中 <code>nil</code> 是一个 <code>指向不存在对象的指针</code></p></li><li><p>在 <code>Swift</code> 中，<code>nil</code> 不是指针，它是 <code>值缺失的一种特殊类型</code>，任何类型的可选项都可以设置成 <code>nil</code> 而不仅仅是对象</p><ul><li>只有 <code>可选类型</code> 才能设置为 <code>nil</code></li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str: String = nil</span><br><span class="line">var str1: String? = nil  </span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020049740.png"></p><h1 id="Optional-If-语句以及强制解包"><a href="#Optional-If-语句以及强制解包" class="headerlink" title="Optional-If 语句以及强制解包"></a>Optional-If 语句以及强制解包</h1><ul><li><p><code>可选类型</code> 是没法直接使用的</p></li><li><p>需要用 <code>!</code> 号 <code>强制解包</code> 后才能使用（意思是我知道这个可选项里面有值，使用吧）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str: String? = &quot;abc&quot;</span><br><span class="line">let count = str.count</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020050383.png"></p><p>需要改成如下代码，才能正确执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str: String? = &quot;abc&quot;</span><br><span class="line">let count = str!.count</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020050208.png"></p><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str: String? = &quot;abc&quot;</span><br><span class="line">if str != nil &#123;</span><br><span class="line">    let count = str!.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020051471.png"></p><h1 id="Optional-绑定"><a href="#Optional-绑定" class="headerlink" title="Optional-绑定"></a>Optional-绑定</h1><ul><li><p>可以使用 <code>可选绑定</code> 来判断可选项是否包含值，如果包含就把赋值给一个临时的 <code>常量或变量</code></p></li><li><p>可选绑定可以与 <code>if</code> 和 <code>while</code> 的语句使用来检查可选项内部的值，并赋值给一个变量或常量</p></li><li><p>同一个 <code>if</code> 语句中包含多可选项绑定，用逗号分割即可。如果任一可选绑定结果是 <code>nil</code> 或者 <code>布尔值</code> 为 <code>false</code> ，那么整个 <code>if</code> 判断会被看做 <code>false</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str:String? = &quot;abc&quot;</span><br><span class="line">if let actualStr = str &#123;</span><br><span class="line">    let count = actualStr.count</span><br><span class="line">    print(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020052194.png"></p><h1 id="Optional-隐士解包"><a href="#Optional-隐士解包" class="headerlink" title="Optional - 隐士解包"></a>Optional - 隐士解包</h1><ul><li><p>有些可选项一旦被设定值之后，就会一直拥有值，在这种情况下，就可以去掉检查的需求，也不必每次访问的时候都进行解包</p></li><li><p>通过有 <code>声明的类型后边添加一个叹号</code>（String!）而非问号（String?）来书写 <code>隐士解包</code> 可选项</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str:String! = &quot;abc&quot;</span><br><span class="line">let count = str.count</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020052565.png"></p><ul><li>隐士解包可选项主要被用在Swift <code>类</code> 的初始化过程中</li></ul><h1 id="Optional-可选链"><a href="#Optional-可选链" class="headerlink" title="Optional-可选链"></a>Optional-可选链</h1><ul><li><p>可选项后面加问号</p></li><li><p>如果可选项不为nil，返回一个可选项结果，否则为nil</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str:String? = &quot;abc&quot;</span><br><span class="line">let count = str?.count</span><br><span class="line">let lastIndex = count - 1</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020054934.png"></p><p>将上面的代码改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var str:String? = &quot;abc&quot;</span><br><span class="line">let count = str?.count</span><br><span class="line">//let lastIndex = count - 1</span><br><span class="line">if count != nil &#123;</span><br><span class="line">    let lastIndex = count! - 1</span><br><span class="line">    print(lastIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020054879.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习06：Tuple元组</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A006%EF%BC%9ATuple%E5%85%83%E7%BB%84/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A006%EF%BC%9ATuple%E5%85%83%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h1><ul><li><code>元组</code> 把多个值合并成单一的复合型的值</li><li><code>元组</code> 内的值可以是任何类型，而且可以不必是统一类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let error = (1,&quot;没有权限&quot;)</span><br><span class="line">print(error.0)</span><br><span class="line">print(error.1)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020044769.png"></p><h1 id="元素命名"><a href="#元素命名" class="headerlink" title="元素命名"></a>元素命名</h1><ul><li>元组中的每一个元素可以指定对应的元素名称</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let error = (errorCode:1,errorMessage:&quot;没有权限&quot;)</span><br><span class="line">print(error.errorCode)</span><br><span class="line">print(error.errorMessage)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020044807.png"></p><ul><li>如果没有指定名称的元素也可以使用下标的方式来引用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let error = (1,&quot;没有权限&quot;)</span><br><span class="line">print(error.0)</span><br><span class="line">print(error.1)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020045931.png"></p><h1 id="Tuple-修改"><a href="#Tuple-修改" class="headerlink" title="Tuple 修改"></a>Tuple 修改</h1><ul><li>用 <code>var</code> 定义的元组就是可变元组，<code>let</code> 定义的元组就是不可变元组</li><li>不管是可变还是不可变元组，元组在创建后就不能增加和删除元素</li><li>可以对可变元组的元素进行修改，但是不能改变其类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var error = (errorCode:1,errorMessage:&quot;没有权限&quot;)</span><br><span class="line">error.errorCode = 2</span><br><span class="line">error.errorMessage = &quot;2&quot;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020045043.png"></p><ul><li><code>any</code> 类型可以改为任何类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var error: (Any,String) = (1,&quot;没有权限&quot;)</span><br><span class="line">error.0 = 2</span><br><span class="line">print(error)</span><br><span class="line">error.0 = &quot;abc&quot;</span><br><span class="line">print(error)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020046096.png"></p><h1 id="Tuple-分解"><a href="#Tuple-分解" class="headerlink" title="Tuple 分解"></a>Tuple 分解</h1><ul><li>将一个元组的内容分解成单独的常量或变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let error = (1,&quot;没有权限&quot;)</span><br><span class="line">let (errorCode,errorMessage) = error</span><br><span class="line">print(errorCode)</span><br><span class="line">print(errorMessage)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020047401.png"></p><ul><li>如果只需要使用其中的一部分数据，不需要的数据可以用下划线 <code>_</code> 代替</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let error = (1,&quot;没有权限&quot;)</span><br><span class="line">let (_,errorMessage) = error</span><br><span class="line">print(errorMessage)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020047151.png"></p><h1 id="作为函数返回值"><a href="#作为函数返回值" class="headerlink" title="作为函数返回值"></a>作为函数返回值</h1><ul><li>使用 <code>Tuple</code> 为函数返回多个值</li><li>返回值的 <code>Tuple</code> 可以再函数的返回类型部分被命名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func writeToFile(content:String) -&gt; (errorCode:Int,errorMessage:String) &#123;</span><br><span class="line">    return (1,&quot;没有权限&quot;)</span><br><span class="line">&#125;</span><br><span class="line">let error = writeToFile(content: &quot;&quot;)</span><br><span class="line">print(error)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020048486.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习05：数值类型</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A005%EF%BC%9A%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A005%EF%BC%9A%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h1><ul><li><p>Swift 提供了 <code>8，16，32，64</code> 位编码的有符号和无符号整数</p></li><li><p>命名方式：例如 8位无符号整数的类型是 UInt8，32位有符号整数的类型是 Int32</p></li><li><p>通过 <code>min</code> 和 <code>max</code> 属性来访问每个整数类型的最小值和最大值</p></li><li><p>Swift 提供了一个额外的整数类型：Int，它拥有与当前平台的原生字相同的长度</p></li><li><p>同时 <code>Swift</code> 也提供 <code>UInt</code> 类型，来表示平台长度相关的无符号整型</p></li><li><p>建议在用到证书的地方都使用 Int</p></li></ul><h1 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h1><ul><li>Double：64位浮点数，至少有 15 位数字的精度</li><li>Float：32位浮点数，至少有 6 为数字的精度</li><li>在两种类型都可以的情况下，推荐使用 Double 类型</li></ul><h1 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020041147.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = 8</span><br><span class="line">let b: UInt8 = 240</span><br><span class="line">print(&quot;UInt8 min \(UInt8.min),UInt8 max \(UInt8.max)&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020042980.png"></p><h1 id="Bool"><a href="#Bool" class="headerlink" title="Bool"></a>Bool</h1><ul><li>Bool：true 和 false</li><li>Swift 的类型安全机制会阻止你用一个非布尔量的值替换掉 Bool</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let i = 1</span><br><span class="line">if i &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020042119.png"></p><p>我们修改一下</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020042345.png"></p><h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><ul><li>类型别名是一个为 <code>已存在类型</code> 定义的一个 <code>可选择的名字</code></li><li>你可以用关键字 <code>typealias</code> 定义一个类型的别名</li><li>当你想通过在一个在上下文中看起来更合适可具有表达行的名字来引用一个已存在的类型时，这时别名就非常有用了</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 音频采样率</span><br><span class="line">typealias AudioSample = UInt8</span><br><span class="line">let sample:AudioSample = 32</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020043905.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习04：变量和常量</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A004%EF%BC%9A%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A004%EF%BC%9A%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="声明变量和常量"><a href="#声明变量和常量" class="headerlink" title="声明变量和常量"></a>声明变量和常量</h1><ul><li>使用关键字 <code>let</code> 声明常量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = 1</span><br><span class="line">a = 2</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020038869.png"></p><p>由于 <code>x</code> 是常量，不能给常量赋值，会报错</p><ul><li>使用关键字 <code>var</code> 声明变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var b = 1</span><br><span class="line">b = 2</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020038019.png"></p><ul><li>可以在一行中声明多个变量和常量，用逗号分割</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x = 0.0,y = 1.0,z = 2.0</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020039534.png"></p><h1 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h1><ul><li><p>在声明一个变量或常量时提供类型标注，来明确变量或常量能够存储值的类型</p></li><li><p>添加 <code>类型标注</code> 的方法是在 <code>变量或常量</code> 的名字后面加一个 <code>冒号</code>，再跟一个 <code>空格</code>，最后加上使用的 <code>类型名称</code></p></li><li><p>可以在一行中定义多个相关的变量为相同的类型，用 <code>逗号</code> 分割，只要在最后的变量名字后加上类型标注</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a: String</span><br><span class="line">a = &quot;hello&quot;</span><br><span class="line">a = 10</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020039355.png"></p><h1 id="常量和变量命名"><a href="#常量和变量命名" class="headerlink" title="常量和变量命名"></a>常量和变量命名</h1><ul><li><p>常量和变量的名字几乎可以使用任何字符，甚至包括 <code>Unicode</code> 字符</p></li><li><p>常量和变量的名字不能包含 <code>空白字符、数学符号、箭头、保留的（或者无效的）Unicode码位、连线和制表符</code>。也不能以 <code>数字</code> 开头，尽管数字几乎可以使用在名字其他的任何地方</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let π = 3.1415</span><br><span class="line">let 你好 = &quot;你好世界&quot;</span><br><span class="line">let 🐶🐂 = &quot;dog,cow&quot;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020040575.png"></p><h1 id="打印常量和变量"><a href="#打印常量和变量" class="headerlink" title="打印常量和变量"></a>打印常量和变量</h1><ul><li><p>print(_:separator:teminator)</p></li><li><p>字符串插入</p></li></ul><p>用 <code>\()</code> 来插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let π = 3.1415</span><br><span class="line">let 你好 = &quot;你好世界&quot;</span><br><span class="line">let 🐶🐂 = &quot;dog,cow&quot;</span><br><span class="line"></span><br><span class="line">print(π)</span><br><span class="line">print(&quot;\(你好)&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020040638.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习03：Playgorund使用</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A003%EF%BC%9APlayground%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A003%EF%BC%9APlayground%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>Swift 的 <code>Playgorund</code> 是为了让人人都能愉快的学习 <code>swift</code> 编程</li><li>但发展至今，这个工具越来越强大</li></ul><h1 id="Playgorund-使用"><a href="#Playgorund-使用" class="headerlink" title="Playgorund 使用"></a>Playgorund 使用</h1><ul><li>创建一个 <code>Playgorund</code> 应用</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020034182.png"></p><ul><li>Next，默认名 <code>MyPlayground</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020035090.png"></p><ul><li>可以通过 New -&gt; Playground Page 创建多个 <code>Playground</code> 来学习</li></ul><p>注：快捷键</p><p>command + option + n 创建 Playground Page</p><p>command + shift + enter 快速运行程序</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020035896.png"></p><p><img src="/BboyZJ.github.io/assets/16776886044720.jpg"></p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><ul><li>写一个求和的函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 求和函数</span><br><span class="line">func sum(a:Int,b:Int) -&gt; Int &#123;</span><br><span class="line">    return a+b</span><br><span class="line">&#125;</span><br><span class="line">// 调用求和函数 赋值给 常量 c</span><br><span class="line">let c = sum(a: 1, b: 2)</span><br><span class="line">// 打印常量 c</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020037021.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习02：REPL交互式解释器</title>
      <link href="/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A002%EF%BC%9AREPL%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
      <url>/BboyZJ.github.io/2023/02/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A002%EF%BC%9AREPL%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul><li>xcode 6.1 引进了另外一种以交互式的方式来体验 <code>Swift</code> 的方法</li><li>Read Eval PrintLoop，简称REPL</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><code>REPL</code> 除了可以 <code>定义常量和变量</code> 外，还是可 <code>定义函数</code></p><ul><li>打开终端输入</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % swift</span><br><span class="line">mac@bogon ~ % swift repl</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020033029.png"></p><h1 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020032935.png"></p><h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020031861.png"></p><h1 id="REPL-其他命令"><a href="#REPL-其他命令" class="headerlink" title="REPL 其他命令"></a>REPL 其他命令</h1><ul><li>退出：:quit</li><li>帮助：:help</li><li>将光标移动到当前行的开始处：Control + A</li><li>将光标移动到当前行的结束处：Control + E</li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习01：Swift编译流程</title>
      <link href="/BboyZJ.github.io/2023/02/21/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A001%EF%BC%9ASwift%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
      <url>/BboyZJ.github.io/2023/02/21/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A001%EF%BC%9ASwift%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="编译器架构"><a href="#编译器架构" class="headerlink" title="编译器架构"></a>编译器架构</h1><p>Swift编译过程和OC基本类似，仅仅是前端编译器不一样。</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020024798.png"></p><ul><li><code>OC/C</code> 前端编译器是 <code>Clang</code></li><li><code>Swift</code> 先解析成 <code>Swift AST</code>（抽象语法树），通过 <code>swiftc</code> 这个命令行参数，编译成 <code>Swift IL</code></li><li><code>OC</code> 和 <code>Swift</code> 最后均编译成 <code>LLVM IR</code> 中间层表示</li><li><code>OC</code> 和 <code>Swift</code> 最终通过 后端编译器 <code>LLVM compiler</code> ，编译成最终的在具体地址上可以执行的二进制，包括x86、arm和other</li></ul><h1 id="详细编译流程"><a href="#详细编译流程" class="headerlink" title="详细编译流程"></a>详细编译流程</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020025648.png"></p><ul><li>Swift 先解析成 <code>AST（抽象语法树）</code></li><li>经过一系列工具编程 <code>Swift</code> 的 <code>SIL(中间语言)</code></li><li>再经过 <code>分析、IR工具</code> 转成 <code>LLVM IR(中间表示层)</code>   </li><li>最终通过 后端编译器 LLVM compiler 编译成 .o 目标文件</li></ul><h1 id="命令行流程"><a href="#命令行流程" class="headerlink" title="命令行流程"></a>命令行流程</h1><p>使用终端创建一个简单的 <code>main.swift</code> 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd Desktop</span><br><span class="line">mac@bogon Desktop % touch main.swift</span><br></pre></td></tr></table></figure><p>此时你可以在桌面看到一个 <code>main.swift</code> 文件</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020026247.png"></p><p>在该文件下写下两个数相加的一个函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func sum(a:Int,b:Int) -&gt; Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let value = sum(a: 1, b: 2)</span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020027637.png"></p><ul><li>打开命令行工具</li></ul><p><code>mac@bogon ~ % cd Desktop</code></p><ul><li>生成 <code>AST</code> 抽象语法树</li></ul><p><code>mac@bogon ~ % swiftc main.swift -dump-ast</code></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020027831.png"></p><ul><li>生成 <code>SIL</code> 中间语言</li></ul><p><code>mac@bogon ~ % swiftc main.swift -emit-sil</code></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/20230302002831.png"></p><ul><li>生成 LLVM IR 中间表示层</li></ul><p><code>mac@bogon ~ % swiftc main.swift -emit-ir</code></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020029775.png"></p><ul><li>生成 Assembly Language 汇编语言</li></ul><p><code>mac@bogon ~ % swiftc main.swift -emit-assembly</code></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303020030034.png"></p><ul><li>生成二进制文件</li></ul><p><code>mac@bogon ~ % swiftc -o main.out main.swift</code></p><p>命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % cd /Users/mac/Desktop/01swift编译流程 </span><br><span class="line">mac@bogon 01swift编译流程 % swiftc -o main.out main.swift</span><br><span class="line">mac@bogon 01swift编译流程 % ./main.out</span><br><span class="line">3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：单例模式</title>
      <link href="/BboyZJ.github.io/2023/02/21/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/BboyZJ.github.io/2023/02/21/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>单例模式（Singleton Pattern）</code> 最 <code>swift</code> 开发中常见的 <code>设计模式之一</code>。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>保证一个类只有一个实例，并提供一个全局的访问点</li><li>减少内存开销，解决了一个类全局使用时频繁的创建和销毁</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ul><li><code>static</code> 声明一个常量实例对象shared，只分配一次内存</li><li><code>private</code> 私有化构造函数 <code>init</code>，放止外部创建新实例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MySingleton &#123;</span><br><span class="line">    // 声明静态变量实例，只初始化一次，值分配一次内存</span><br><span class="line">    static let shared = MySingleton()</span><br><span class="line">    // 私有构造函数，防止从外部创建新的实例</span><br><span class="line">    private override init () &#123;</span><br><span class="line">        super.init()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 函数</span><br><span class="line">    func doSomething() &#123;</span><br><span class="line">        print(&quot;do something&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用单例对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySingleton.shared.doSomething();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI学习12：List列表和ForEach循环的使用</title>
      <link href="/BboyZJ.github.io/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A012%EF%BC%9AList%E5%88%97%E8%A1%A8%E5%92%8CForEach%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A012%EF%BC%9AList%E5%88%97%E8%A1%A8%E5%92%8CForEach%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI学习11：Path路径的使用</title>
      <link href="/BboyZJ.github.io/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A011%EF%BC%9APath%E8%B7%AF%E5%BE%84%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A011%EF%BC%9APath%E8%B7%AF%E5%BE%84%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI学习10：State和Binding绑定的使用</title>
      <link href="/BboyZJ.github.io/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A010%EF%BC%9AState%E5%92%8CBinding%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A010%EF%BC%9AState%E5%92%8CBinding%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在本章节中，你将学会如何使用 <code>State</code> 和 <code>Binding</code> 绑定，<code>监听属性值的变化</code>，和根据 <code>Binding</code> 绑定关系，改变一个属性值同时影响另一个属性值的变化</p><p>举例：</p><p>当我们在听音乐或看视频时，点击 <code>播放</code> 按钮，<code>播放</code> 按钮变成 <code>暂停</code> 按钮，同时视频开始播放</p><p>这就用到了 <code>@State属性包装器</code> 和 <code>@Binding包装器</code></p><p>尝试完成下面的设计稿：</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090636190.png"></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ul><li>首先我们准备好图片素材，未选中的图片和选中的图片，放到Assets中</li><li>定义一个@State变量存放状态，通过点击来切换状态</li><li>创建按钮通过状态变量判断显示图片</li></ul><p>注：定义的变量放在struct下面，body上面</p><h1 id="具体代码的实现"><a href="#具体代码的实现" class="headerlink" title="具体代码的实现"></a>具体代码的实现</h1><p>知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.toggle() 切换按钮状态</span><br></pre></td></tr></table></figure><p>完成代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct ContentView: View &#123;</span><br><span class="line">    // 定义变量</span><br><span class="line">    @State var isSelect:Bool = false</span><br><span class="line">    </span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        </span><br><span class="line">        // 按钮</span><br><span class="line">        Button &#123;</span><br><span class="line">            print(&quot;点击了按钮&quot;)</span><br><span class="line">            self.isSelect.toggle()</span><br><span class="line">        &#125; label: &#123;</span><br><span class="line">            Image(systemName: isSelect ? &quot;checkmark.circle.fill&quot; : &quot;circle&quot;)</span><br><span class="line">                .font(.system(size: 150))</span><br><span class="line">                .foregroundColor(isSelect ? Color(red: 112/255, green: 182/255, blue: 3/255) : Color(red: 170/255, green: 170/255, blue: 170/255))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090636998.png"></p><h1 id="Binding绑定"><a href="#Binding绑定" class="headerlink" title="Binding绑定"></a>Binding绑定</h1><p>以上面的代码为例，如果我们在按钮下面添加一个文本Text</p><p>按钮关闭时，title文字为：未开启</p><p>按钮打开时，title文字为：已开启</p><p>我们实现一下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct ContentView: View &#123;</span><br><span class="line">    // 定义变量</span><br><span class="line">    @State var isSelect:Bool = false</span><br><span class="line">    </span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        </span><br><span class="line">        // 按钮</span><br><span class="line">        VStack &#123;</span><br><span class="line">            Button &#123;</span><br><span class="line">                print(&quot;点击了按钮&quot;)</span><br><span class="line">                self.isSelect.toggle()</span><br><span class="line">            &#125; label: &#123;</span><br><span class="line">                Image(systemName: isSelect ? &quot;checkmark.circle.fill&quot; : &quot;circle&quot;)</span><br><span class="line">                    .font(.system(size: 150))</span><br><span class="line">                    .foregroundColor(isSelect ? Color(red: 112/255, green: 182/255, blue: 3/255) : Color(red: 170/255, green: 170/255, blue: 170/255))</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 文本</span><br><span class="line">            titleView()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct titleView: View &#123;</span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        Text(&quot;未开启&quot;)</span><br><span class="line">            .font(.system(size: 25))</span><br><span class="line">            .fontWeight(.bold)</span><br><span class="line">            .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时如果我们想通过 <code>isSelect</code> 来关联 <code>Text文字</code>，<code>会报错</code>，因为找不到，不在一个视图下</p><p>因此，我们这里引入了 <code>Binding绑定</code> 概念，Binding共享了State定义的状态，State状态改变时，Binding绑定的参数会一起改变</p><ul><li>定义绑定变量 <code>isSelect</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 定义绑定</span><br><span class="line">@Binding var isSelect:Bool</span><br></pre></td></tr></table></figure><ul><li>绑定状态用$</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 文本</span><br><span class="line">titleView(isSelect: $isSelect)</span><br></pre></td></tr></table></figure><ul><li>完整代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct ContentView_Previews: PreviewProvider &#123;</span><br><span class="line">    static var previews: some View &#123;</span><br><span class="line">        ContentView()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct ContentView: View &#123;</span><br><span class="line">    // 定义变量</span><br><span class="line">    @State var isSelect:Bool = false</span><br><span class="line">    </span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        </span><br><span class="line">        // 按钮</span><br><span class="line">        VStack &#123;</span><br><span class="line">            Button &#123;</span><br><span class="line">                print(&quot;点击了按钮&quot;)</span><br><span class="line">                self.isSelect.toggle()</span><br><span class="line">            &#125; label: &#123;</span><br><span class="line">                Image(systemName: isSelect ? &quot;checkmark.circle.fill&quot; : &quot;circle&quot;)</span><br><span class="line">                    .font(.system(size: 150))</span><br><span class="line">                    .foregroundColor(isSelect ? Color(red: 112/255, green: 182/255, blue: 3/255) : Color(red: 170/255, green: 170/255, blue: 170/255))</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 文本</span><br><span class="line">            titleView(isSelect: $isSelect)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct titleView: View &#123;</span><br><span class="line">    // 绑定状态</span><br><span class="line">    @Binding var isSelect:Bool</span><br><span class="line">    </span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        Text(self.isSelect ? &quot;已开启&quot; : &quot;未开启&quot;)</span><br><span class="line">            .font(.system(size: 25))</span><br><span class="line">            .fontWeight(.bold)</span><br><span class="line">            .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090637747.png"></p>]]></content>
      
      
      <categories>
          
          <category> SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI学习09：Gradient渐变色的使用</title>
      <link href="/BboyZJ.github.io/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A009%EF%BC%9AGradient%E6%B8%90%E5%8F%98%E8%89%B2%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A009%EF%BC%9AGradient%E6%B8%90%E5%8F%98%E8%89%B2%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>如果我们想要做渐变色背景，我们需要使用SwiftUI框架内置的渐变色代码</p><ul><li>左右渐变</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><ul><li>上下渐变</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>简单描述下参数的意思：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinerGradient()：线性渐变</span><br><span class="line">gradient：渐变色，通常用颜色数组 [Color.blue,Color.green]，也就是开始颜色蓝色，结束颜色        是绿色</span><br><span class="line">startPoint：开始位置，通常使用.leading .trailing .top .botton 左右上下</span><br><span class="line">endPoint：结束位置，通常使用.leading .trailing .top .botton 左右上下</span><br></pre></td></tr></table></figure><h1 id="按钮样式协议"><a href="#按钮样式协议" class="headerlink" title="按钮样式协议"></a>按钮样式协议</h1><p>如果按钮很多，切样式都可以复用的情况下，复制一大串代码不符合 优雅代码的目标</p><p>这里我们科普一个新的概念，叫做 <code>ButtonStyles</code>，也就是按钮样式协议，继承这个协议，我们就可以实现样式</p><p>它的代码结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct GradientBackgroundStyle:ButtonStyle&#123;</span><br><span class="line">    func makeBody(configuration: Configuration) -&gt; some View &#123;</span><br><span class="line">        configuration.label</span><br><span class="line">        // Button样式</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>样式使用方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 样式引用方式</span><br><span class="line">.buttonStyle(GradientBackgroundStyle())</span><br></pre></td></tr></table></figure><h1 id="完整代码和效果"><a href="#完整代码和效果" class="headerlink" title="完整代码和效果"></a>完整代码和效果</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct ContentView: View &#123;</span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        </span><br><span class="line">        Button &#123;</span><br><span class="line">            print(&quot;登录成功&quot;)</span><br><span class="line">        &#125; label: &#123;</span><br><span class="line">            Text(&quot;微信登录&quot;)</span><br><span class="line">                .font(.system(size: 14))</span><br><span class="line">        &#125;</span><br><span class="line">        // 样式引用方式</span><br><span class="line">        .buttonStyle(GradientBackgroundStyle())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct ContentView_Previews: PreviewProvider &#123;</span><br><span class="line">    static var previews: some View &#123;</span><br><span class="line">        ContentView()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ButtonStyle</span><br><span class="line">struct GradientBackgroundStyle:ButtonStyle&#123;</span><br><span class="line">    func makeBody(configuration: Configuration) -&gt; some View &#123;</span><br><span class="line">        configuration.label</span><br><span class="line">            // 按钮修饰符</span><br><span class="line">            .frame(minWidth: 0,maxWidth: .infinity,minHeight: 0,maxHeight: 50)</span><br><span class="line">            .foregroundColor(.white)</span><br><span class="line">            .background(LinearGradient(gradient: Gradient(colors: [Color(&quot;8FD3F4&quot;),Color(&quot;84FAB0&quot;)]), startPoint: .leading, endPoint: .trailing))</span><br><span class="line">            .cornerRadius(5)</span><br><span class="line">            .padding(.horizontal,20)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI学习08：UIButton按钮的使用</title>
      <link href="/BboyZJ.github.io/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A008%EF%BC%9AUIButton%E6%8C%89%E9%92%AE%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A008%EF%BC%9AUIButton%E6%8C%89%E9%92%AE%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在本章节中，我们将学会如何使用Button按钮这个基本控件</p><p>由于Button组件在不同场景下应用不同，我们分成3个部分</p><ul><li>简单文字按钮</li><li>简单图片按钮</li><li>图片+文字按钮</li></ul><h1 id="创建按钮"><a href="#创建按钮" class="headerlink" title="创建按钮"></a>创建按钮</h1><p>swiftUI中创建按钮代码很简单，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Button &#123; // 操作</span><br><span class="line">             </span><br><span class="line">&#125; label: &#123; // 按钮样式</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一个注释：点击了按钮后，系统执行什么操作</li><li>第二个注释：按钮的样式，这个按钮是什么</li></ul><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct ContentView: View &#123;</span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        </span><br><span class="line">        Button &#123; // 操作</span><br><span class="line">             print(&quot;登录成功&quot;)</span><br><span class="line">        &#125; label: &#123; // 按钮样式</span><br><span class="line">            Text(&quot;微信登录&quot;)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090634181.png"></p><h1 id="Text常用方法"><a href="#Text常用方法" class="headerlink" title="Text常用方法"></a>Text常用方法</h1><ul><li>.frame：尺寸，<code>.infinity</code> 自适应屏幕宽高</li><li>.padding：边距，在按钮外面撑开一块面积，上下左右都留边距</li></ul><h1 id="用Button实现下面的UI"><a href="#用Button实现下面的UI" class="headerlink" title="用Button实现下面的UI"></a>用Button实现下面的UI</h1><p>效果图如下</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090635514.png"></p><p>思路：创建 <code>Button</code> 按钮，并将其 <code>提取</code> 成子视图，插入到 <code>垂直分布中</code></p><h1 id="简单文字按钮"><a href="#简单文字按钮" class="headerlink" title="简单文字按钮"></a>简单文字按钮</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 按钮视图</span><br><span class="line">struct ButtonView: View &#123;</span><br><span class="line">    // 定义变量</span><br><span class="line">    var title:String?</span><br><span class="line">    var bgColor:Color?</span><br><span class="line">    </span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        Button &#123; // 操作</span><br><span class="line">            print(&quot;\(title!)成功&quot;)</span><br><span class="line">        &#125; label: &#123; // 按钮样式</span><br><span class="line">            Text(title!)</span><br><span class="line">                .frame(minWidth: 0,maxWidth: .infinity,minHeight: 0,maxHeight: 40)</span><br><span class="line">                .background(bgColor)</span><br><span class="line">                .font(.system(size: 14))</span><br><span class="line">                .foregroundColor(.white)</span><br><span class="line">                .cornerRadius(5)</span><br><span class="line">                .padding(.horizontal,50) // 水平居中，左右边距50</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简单图片按钮"><a href="#简单图片按钮" class="headerlink" title="简单图片按钮"></a>简单图片按钮</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 图片按钮</span><br><span class="line">struct ImgButton: View &#123;</span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        Button &#123;</span><br><span class="line">            print(&quot;登录成功&quot;)</span><br><span class="line">        &#125; label: &#123;</span><br><span class="line">            Image(&quot;wechat&quot;)</span><br><span class="line">                .resizable()</span><br><span class="line">                .aspectRatio(contentMode: .fit)</span><br><span class="line">                .frame(minWidth: 0,maxWidth: 50,minHeight: 0,maxHeight: 50)</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图片-文字按钮"><a href="#图片-文字按钮" class="headerlink" title="图片+文字按钮"></a>图片+文字按钮</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 图片文字按钮</span><br><span class="line">struct ImgTextButton: View &#123;</span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        Button &#123;</span><br><span class="line">            print(&quot;登录成功&quot;)</span><br><span class="line">        &#125; label: &#123;</span><br><span class="line">            HStack &#123;</span><br><span class="line">                Image(systemName: &quot;applelogo&quot;)</span><br><span class="line">                    .font(.title)</span><br><span class="line">                Text(&quot;Apple登录&quot;)</span><br><span class="line">                    .fontWeight(.semibold)</span><br><span class="line">                    .font(.title)</span><br><span class="line">            &#125;</span><br><span class="line">            .frame(minWidth: 0,maxWidth: .infinity,minHeight: 0,maxHeight: 70)</span><br><span class="line">            .background(Color(red: 51/255, green: 51/255, blue: 51/255))</span><br><span class="line">            .foregroundColor(.white)</span><br><span class="line">            .cornerRadius(40)</span><br><span class="line">            .padding(.horizontal,20)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后呈现的代码"><a href="#最后呈现的代码" class="headerlink" title="最后呈现的代码"></a>最后呈现的代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct ContentView: View &#123;</span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        </span><br><span class="line">        VStack &#123;</span><br><span class="line">            // 微信登录</span><br><span class="line">            ButtonView(title: &quot;微信登录&quot;,bgColor: .green)</span><br><span class="line">            // Apple登录</span><br><span class="line">            ButtonView(title: &quot;Apple登录&quot;,bgColor: .black)</span><br><span class="line">            // 图片按钮</span><br><span class="line">            ImgButton()</span><br><span class="line">            // 图片+文字按钮</span><br><span class="line">            ImgTextButton()</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI学习07：ScrollView滚动视图使用</title>
      <link href="/BboyZJ.github.io/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A007%EF%BC%9AScrollView%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A007%EF%BC%9AScrollView%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在本章中，你将学会如何使用 <code>代码分组</code> 和 <code>代码复用</code> 的方式创建 <code>ScrollView</code> 滚动视图</p><p>以微信公众号为例，我们试试完成下面的UI设计图</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090632504.png"></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>由UI可知，文章是由图片Image和Text组成，而且是 <code>纵向排列</code></p><p>因此，我们实现的步骤如下：</p><ul><li>准备一些图片素材，放入到 <code>Assets.xcassets</code> 文件中</li><li>先完成基础的 <code>单个卡片的代码</code>，并将其 <code>纵向分布</code></li><li>将卡片 <code>提取成子视图</code>，嵌入到 <code>ScrollView</code> 中</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li>将图片素材，放入到 Assets.xcassets 文件中</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090632661.png"></p><ul><li>基础卡片的实现</li></ul><p>Image图片的常用方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.resizabl ：调节大小，调整图片显示的大小</span><br><span class="line">.aspectRatio() ：宽高比，.aspectRatio(contentMode: ContentMode.fit)让图片适应屏幕，并保持原有的宽高比 </span><br></pre></td></tr></table></figure><p>Text文本常用的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.font()：字体，.font(.system(size:17))，系统17号字</span><br><span class="line">.fontWeight()：字重，.fontWeight(.blod)，加粗</span><br><span class="line">.foregroundColor()：字体颜色，.foregroundColor(.black)，系统黑色</span><br><span class="line">.padding()：边距，四周留开边距</span><br></pre></td></tr></table></figure><p>单个卡片实现的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">VStack &#123;</span><br><span class="line">            // 图片</span><br><span class="line">            Image(&quot;book1&quot;)</span><br><span class="line">                .resizable() // 调整图片显示的大小</span><br><span class="line">                .aspectRatio(contentMode: ContentMode.fit) // 宽高比</span><br><span class="line">            // 文字</span><br><span class="line">            Text(&quot;你的能力是否在全世界通用，如果不能，那么需求重新评估你的能力&quot;)</span><br><span class="line">                .font(.system(size: 17))</span><br><span class="line">                .fontWeight(.bold)</span><br><span class="line">                .foregroundColor(.black)</span><br><span class="line">                .padding()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>给整个 <code>卡片</code> 加边框，通过 <code>.overlay()</code> 修饰符 <code>覆盖</code> 上去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.cornerRadius(10)</span><br><span class="line">.overlay(</span><br><span class="line">    RoundedRectangle(cornerRadius: 10)</span><br><span class="line">        .stroke(Color(red: 150/255, green: 150/255, blue: 150/255,opacity: 0.1),lineWidth: 1)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>给 <code>卡片</code> 设置一个边距，用到了 <code>.padding()</code> 修饰符，且是它的 高级用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.padding([.top,.horizontal]) 顶部，水平居中</span><br></pre></td></tr></table></figure><ul><li>将卡片提取成子视图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 卡片视图</span><br><span class="line">struct CardView: View &#123;</span><br><span class="line">    // 定义变量</span><br><span class="line">    var img:String?     // 图片</span><br><span class="line">    var title:String?   // 标题</span><br><span class="line">    </span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        VStack &#123;</span><br><span class="line">            // 图片</span><br><span class="line">            Image(img!)</span><br><span class="line">                .resizable() // 调整图片显示的大小</span><br><span class="line">                .aspectRatio(contentMode: ContentMode.fit) // 宽高比</span><br><span class="line">            // 文字</span><br><span class="line">            Text(title!)</span><br><span class="line">                .font(.system(size: 17))</span><br><span class="line">                .fontWeight(.bold)</span><br><span class="line">                .foregroundColor(.black)</span><br><span class="line">                .padding()</span><br><span class="line">        &#125;</span><br><span class="line">        .cornerRadius(10)</span><br><span class="line">        .overlay(</span><br><span class="line">            RoundedRectangle(cornerRadius: 10)</span><br><span class="line">                .stroke(Color(red: 150/255, green: 150/255, blue: 150/255,opacity: 0.1),lineWidth: 1)</span><br><span class="line">        )</span><br><span class="line">        .padding([.top,.horizontal])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>将多张卡片添加到ScrollView中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct ContentView: View &#123;</span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        ScrollView&#123;</span><br><span class="line">            VStack &#123;</span><br><span class="line">                // 卡片视图</span><br><span class="line">                CardView(img: &quot;book1&quot;,title: &quot;你的能力是否能在全世界通用，如果不能,那么需求重新评估你的能力。&quot;)</span><br><span class="line">                CardView(img: &quot;book2&quot;,title: &quot;当你判断你的想法是正确的，那么就在今天完成吧。&quot;)</span><br><span class="line">                CardView(img: &quot;book3&quot;,title: &quot;当你判断你的想法是正确的，那么就在今天完成吧。&quot;)</span><br><span class="line">                CardView(img: &quot;book4&quot;,title: &quot;将自身所学的回馈社会，不也是意见幸福的事儿么&quot;)</span><br><span class="line">                CardView(img: &quot;book2&quot;,title: &quot;成功的秘诀，绝对不要和别人做相同的事儿&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最终呈现的结果如下：</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090633694.png"></p>]]></content>
      
      
      <categories>
          
          <category> SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI学习06：定义变量</title>
      <link href="/BboyZJ.github.io/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A006%EF%BC%9A%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F/"/>
      <url>/BboyZJ.github.io/2023/02/20/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A006%EF%BC%9A%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h1><p>由上一章的案例，我们发现，除了 <code>定价方案的标题不同（连续包月，1个月，12个月）</code>，不同定价方案价格不同（￥18、￥30、￥228）、背景颜色不同，其他都一样，我们将这三个属性定义成变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct priceView: View &#123;</span><br><span class="line">    // 定义变量</span><br><span class="line">    var title: String?</span><br><span class="line">    var price: String?</span><br><span class="line">    var bgColor: Color?</span><br><span class="line">    </span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        HStack &#123;</span><br><span class="line">            // 连续包月</span><br><span class="line">            VStack &#123;</span><br></pre></td></tr></table></figure><h1 id="给变量赋予真正的值"><a href="#给变量赋予真正的值" class="headerlink" title="给变量赋予真正的值"></a>给变量赋予真正的值</h1><ul><li>将价格视图改成可以传递变量的通用函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 价格</span><br><span class="line">struct priceView: View &#123;</span><br><span class="line">    // 定义变量</span><br><span class="line">    var title: String?</span><br><span class="line">    var price: String?</span><br><span class="line">    var bgColor: Color?</span><br><span class="line">    </span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        ZStack &#123;</span><br><span class="line">            VStack()&#123;</span><br><span class="line">                Text(title!)</span><br><span class="line">                    .font(.system(size: 17))</span><br><span class="line">                    .fontWeight(.bold)</span><br><span class="line">                    .foregroundColor(Color(red: 190/255, green: 188/255, blue: 184/255))</span><br><span class="line">                Text(price!)</span><br><span class="line">                    .fontWeight(.bold)</span><br><span class="line">                    .font(.system(size: 30))</span><br><span class="line">                    .foregroundColor(Color(red: 239 / 255, green: 129 / 255, blue: 112 / 255))</span><br><span class="line">            &#125;</span><br><span class="line">            // 最大宽度自适应</span><br><span class="line">            .frame(minWidth: 0, maxWidth: .infinity, minHeight: 90)</span><br><span class="line">            .padding(20)</span><br><span class="line">            .background(Color(&quot;faf7f3&quot;))</span><br><span class="line">            .cornerRadius(4)</span><br><span class="line">            .overlay( // 覆盖</span><br><span class="line">                RoundedRectangle(cornerRadius: 4)</span><br><span class="line">                    .stroke(Color(red: 202 / 255, green: 169 / 255, blue: 106 / 255),lineWidth: 2))</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时，你可以传递4个参数，来生成 <code>垂直分布的</code> 视图</p><ul><li>连续创建三个视图并添加到 <code>水平分布中</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import SwiftUI</span><br><span class="line"></span><br><span class="line">struct ContentView: View &#123;</span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        HStack &#123;</span><br><span class="line">            // 连续包月</span><br><span class="line">            priceView(title: &quot;连续包月&quot;,price: &quot;$18&quot;,bgColor: Color(&quot;faf7f3&quot;))</span><br><span class="line">            </span><br><span class="line">            // 1个月</span><br><span class="line">            priceView(title: &quot;1个月&quot;,price: &quot;$30&quot;,bgColor: Color(red: 244/255, green: 244/255, blue: 245/255))</span><br><span class="line">            </span><br><span class="line">            // 12个月</span><br><span class="line">            priceView(title: &quot;12个月&quot;,price: &quot;$228&quot;,bgColor: Color(red: 244/255, green: 244/255, blue: 245/255))</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        .padding(10)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于连续包月上还有一个首月特惠，所以需要 <code>插入到 叠加分布</code> 中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 连续包月</span><br><span class="line">ZStack &#123;</span><br><span class="line">    priceView(title: &quot;连续包月&quot;,price: &quot;$18&quot;,perPrice: &quot;&quot;,bgColor: Color(&quot;faf7f3&quot;))</span><br><span class="line">    // 首月特惠</span><br><span class="line">    Text(&quot;首月特惠&quot;)</span><br><span class="line">        .font(.system(size: 14))</span><br><span class="line">        .fontWeight(.bold)</span><br><span class="line">        .foregroundColor(.white)</span><br><span class="line">        .background(Color(red: 202 / 255, green: 169 / 255, blue: 106 / 255))</span><br><span class="line">        .cornerRadius(4)</span><br><span class="line">        .padding(10)</span><br><span class="line">        .offset(x:0,y:-65)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后将 首月特惠 提取子视图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 首月特惠</span><br><span class="line">struct FirstSpecial: View &#123;</span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        Text(&quot;首月特惠&quot;)</span><br><span class="line">            .font(.system(size: 14))</span><br><span class="line">            .fontWeight(.bold)</span><br><span class="line">            .foregroundColor(.white)</span><br><span class="line">            .background(Color(red: 202 / 255, green: 169 / 255, blue: 106 / 255))</span><br><span class="line">            .cornerRadius(4)</span><br><span class="line">            .padding(10)</span><br><span class="line">            .offset(x:0,y:-65)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI学习05：代码分组管理</title>
      <link href="/BboyZJ.github.io/2023/02/19/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A005%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%88%86%E7%BB%84%E7%AE%A1%E7%90%86/"/>
      <url>/BboyZJ.github.io/2023/02/19/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A005%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%88%86%E7%BB%84%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要分组管理"><a href="#为什么要分组管理" class="headerlink" title="为什么要分组管理"></a>为什么要分组管理</h1><p>当我们 <code>body</code> 中代码越来越多，会显得很臃肿，不易读取，那么我们可以将其每个 <code>独立</code> 的部分 <code>提取</code> 出来</p><h1 id="提取子视图"><a href="#提取子视图" class="headerlink" title="提取子视图"></a>提取子视图</h1><ul><li>将鼠标移动到 <code>HStack分布视图</code> 上，按住 <code>command</code>，选中 <code>Extract SubView</code>，这个操作是<code>提取子视图</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090630162.png"></p><ul><li>点击后我们就可以把标题提取出来了</li></ul><p><img src="/BboyZJ.github.io/assets/16768210572677.jpg"></p><p>系统自动创建了一个 <code>ExtractedView()</code>，这个就是还未重新命名的 <code>定价方案视图</code></p><ul><li>为了方便定位代码，我们对每个子视图命名，点击鼠标右键，选择Refactor，选择Rename</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090630347.png"></p><ul><li>命名为 <code>priceView</code>，最好遵循 <code>【驼峰命名法】</code></li></ul><h1 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h1><p>Xcode -&gt; Preference -&gt; Text Editing -&gt; Code folding ribbon</p>]]></content>
      
      
      <categories>
          
          <category> SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI学习04：VStack,HStack,ZStack视图排列使用</title>
      <link href="/BboyZJ.github.io/2023/02/19/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A004%EF%BC%9AVStack-HStack-ZStack%E8%A7%86%E5%9B%BE%E6%8E%92%E5%88%97%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/19/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A004%EF%BC%9AVStack-HStack-ZStack%E8%A7%86%E5%9B%BE%E6%8E%92%E5%88%97%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在一个页面中，经常会看到许多UI控件，在不同的位置摆放，在 <code>SwiftUI</code> 中分为：</p><ul><li>VStack垂直摆放</li><li>HStack水平摆放</li><li>ZStack掩盖摆放</li></ul><h1 id="三种摆放图示"><a href="#三种摆放图示" class="headerlink" title="三种摆放图示"></a>三种摆放图示</h1><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090627303.png"></p><h1 id="创建一个新工程Stack，了解不同分布"><a href="#创建一个新工程Stack，了解不同分布" class="headerlink" title="创建一个新工程Stack，了解不同分布"></a>创建一个新工程Stack，了解不同分布</h1><ul><li>垂直分布</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 垂直分布</span><br><span class="line">VStack(alignment: .center)&#123; // 居中对齐</span><br><span class="line">    </span><br><span class="line">    Text(&quot;View1&quot;)</span><br><span class="line">        .font(.system(size: 20))</span><br><span class="line">        .foregroundColor(.blue)</span><br><span class="line">        .frame(width: 300, height: 100, alignment: .center)</span><br><span class="line">        .background(Color.green)</span><br><span class="line">        .padding(10)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Text(&quot;View2&quot;)</span><br><span class="line">        .font(.system(size: 20))</span><br><span class="line">        .foregroundColor(.blue)</span><br><span class="line">        .frame(width: 300, height: 100, alignment: .center)</span><br><span class="line">        .background(Color.green)</span><br><span class="line">        .padding(10)</span><br><span class="line">    </span><br><span class="line">    Text(&quot;View3&quot;)</span><br><span class="line">        .font(.system(size: 20))</span><br><span class="line">        .foregroundColor(.blue)</span><br><span class="line">        .frame(width: 300, height: 100, alignment: .center)</span><br><span class="line">        .background(Color.green)</span><br><span class="line">        .padding(10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预览视图如下：</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090627854.png"></p><ul><li>水平分布</li></ul><p>同理</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090627333.png"></p><ul><li>覆盖分布</li></ul><p>同理</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090628337.png"></p><h1 id="写一个简单的案列"><a href="#写一个简单的案列" class="headerlink" title="写一个简单的案列"></a>写一个简单的案列</h1><p>案列图</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090628236.png"></p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">struct ContentView: View &#123;</span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        // 定价方案</span><br><span class="line">        HStack &#123;</span><br><span class="line">            // 连续包月</span><br><span class="line">            VStack &#123;</span><br><span class="line">                ZStack &#123;</span><br><span class="line">                    VStack()&#123;</span><br><span class="line">                        Text(&quot;连续包月&quot;)</span><br><span class="line">                            .font(.system(size: 17))</span><br><span class="line">                            .fontWeight(.bold)</span><br><span class="line">                            .foregroundColor(Color(red: 190/255, green: 188/255, blue: 184/255))</span><br><span class="line">             </span><br><span class="line">                        Text(&quot;¥18&quot;)</span><br><span class="line">                            .fontWeight(.bold)</span><br><span class="line">                            .font(.system(size: 30))</span><br><span class="line">                            .foregroundColor(Color(red: 239 / 255, green: 129 / 255, blue: 112 / 255))</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 最大宽度自适应</span><br><span class="line">                    .frame(minWidth: 0, maxWidth: .infinity, minHeight: 90)</span><br><span class="line">                    .padding(20)</span><br><span class="line">                    .background(Color(&quot;faf7f3&quot;))</span><br><span class="line">                    .cornerRadius(4)</span><br><span class="line">                    .overlay( // 覆盖</span><br><span class="line">                        RoundedRectangle(cornerRadius: 4).stroke(Color(red: 202 / 255, green: 169 / 255, blue: 106 / 255),lineWidth: 2))</span><br><span class="line">                    </span><br><span class="line">                    // 首月特惠</span><br><span class="line">                    Text(&quot;首月特惠&quot;)</span><br><span class="line">                        .font(.system(size: 14))</span><br><span class="line">                        .fontWeight(.bold)</span><br><span class="line">                        .foregroundColor(.white)</span><br><span class="line">                        .background(Color(red: 202 / 255, green: 169 / 255, blue: 106 / 255))</span><br><span class="line">                        .cornerRadius(4)</span><br><span class="line">                        .padding(10)</span><br><span class="line">                        .offset(x:0,y:-65)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //1个月</span><br><span class="line">            VStack &#123;</span><br><span class="line">                Text(&quot;1个月&quot;)</span><br><span class="line">                    .fontWeight(.bold)</span><br><span class="line">                    .font(.system(size: 17))</span><br><span class="line">                    .foregroundColor(Color(red: 190 / 255, green: 188 / 255, blue: 184 / 255))</span><br><span class="line">                Text(&quot;¥30&quot;)</span><br><span class="line">                    .fontWeight(.bold)</span><br><span class="line">                    .font(.system(size: 30))</span><br><span class="line">                    .foregroundColor(Color(red: 239 / 255, green: 129 / 255, blue: 112 / 255))</span><br><span class="line">                &#125;</span><br><span class="line">                .frame(minWidth: 0, maxWidth: .infinity, minHeight: 90)</span><br><span class="line">                .padding(20)</span><br><span class="line">                .background(Color(red: 244 / 255, green: 244 / 255, blue: 245 / 255))</span><br><span class="line">                .cornerRadius(10)</span><br><span class="line">            </span><br><span class="line">                // 12个月</span><br><span class="line">                VStack()&#123;</span><br><span class="line">                    Text(&quot;12个月&quot;)</span><br><span class="line">                        .font(.system(size: 17))</span><br><span class="line">                        .fontWeight(.bold)</span><br><span class="line">                        .foregroundColor(Color(red: 190/255, green: 188/255, blue: 184/255))</span><br><span class="line">                    Text(&quot;¥288&quot;)</span><br><span class="line">                        .fontWeight(.bold)</span><br><span class="line">                        .font(.system(size: 30))</span><br><span class="line">                        .foregroundColor(Color(red: 239 / 255, green: 129 / 255, blue: 112 / 255))</span><br><span class="line">                    Text(&quot;¥19.00/月&quot;)</span><br><span class="line">                                .fontWeight(.bold)</span><br><span class="line">                                .font(.system(size: 17))</span><br><span class="line">                                .foregroundColor(Color(red: 190 / 255, green: 188 / 255, blue: 184 / 255))</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                .frame(minWidth: 0, maxWidth: .infinity, minHeight: 90)</span><br><span class="line">                .padding(20)</span><br><span class="line">                .background(Color(red: 244 / 255, green: 244 / 255, blue: 245 / 255))</span><br><span class="line">                .cornerRadius(10)</span><br><span class="line">        &#125;</span><br><span class="line">        .padding(10)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>.padding ： 设置边距</p></li><li><p>command + VStack&#x2F;HStack&#x2F;ZStack 可以在最外层嵌入 <code>分布</code></p></li></ul><p>Embed in VStack：嵌入水平分布</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090628144.png"></p><ul><li>要调整位置，我们可以使用 <code>.offset</code> 修饰符，设置偏移量</li></ul><p>X，Y分别对应坐标轴位置，X轴正数为右移，负数为左移，Y轴正数下移，负数上移。</p><ul><li>.frame(minWidth: 0, maxWidth: .infinity, minHeight: 90)</li></ul><p>最小宽度0，<code>.infinity</code> 最大宽度自适应</p><ul><li>swiftUI 修饰符有顺序，先切圆角，再加边框</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.overlay(RoundedRectangle(cornerRadius: 6).stroke(Color(red: 202 / 255, green: 169 / 255, blue: 106 / 255),lineWidth: 2))</span><br></pre></td></tr></table></figure><blockquote><p>RoundedRectangle()：圆角矩形<br>stroke：描边<br>lineWidth：线宽<br>cornerRadius：圆角度数</p></blockquote><h1 id="导入色彩的办法"><a href="#导入色彩的办法" class="headerlink" title="导入色彩的办法"></a>导入色彩的办法</h1><p>点击Assets，在底部点击“+”按钮，挑选 <code>New Color Set</code>，选择 <code>Show Color Panel </code></p>]]></content>
      
      
      <categories>
          
          <category> SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI学习03：Text文字和Image图片的使用</title>
      <link href="/BboyZJ.github.io/2023/02/19/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A003%EF%BC%9AText%E6%96%87%E5%AD%97%E5%92%8CImage%E5%9B%BE%E7%89%87%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/19/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A003%EF%BC%9AText%E6%96%87%E5%AD%97%E5%92%8CImage%E5%9B%BE%E7%89%87%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Text-文字的使用"><a href="#Text-文字的使用" class="headerlink" title="Text 文字的使用"></a>Text 文字的使用</h1><ul><li>在ContentView.swift文件中，我们实现如下代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct ContentView: View &#123;</span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        // 初始化一个文本</span><br><span class="line">        Text(&quot;Hello World&quot;)</span><br><span class="line">            // 背景颜色</span><br><span class="line">            .background(Color.red)</span><br><span class="line">            // 设置字重：字体加粗</span><br><span class="line">            .fontWeight(.bold)</span><br><span class="line">            // 字体大小</span><br><span class="line">            .font(.system(size: 20))</span><br><span class="line">            // 字体颜色</span><br><span class="line">            .foregroundColor(.blue)</span><br><span class="line">            // 阴影</span><br><span class="line">            .shadow(color: .black, radius: 1)</span><br><span class="line">            // 边距</span><br><span class="line">            .padding(10)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct ContentView_Previews: PreviewProvider &#123;</span><br><span class="line">    static var previews: some View &#123;</span><br><span class="line">        ContentView()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多参数设置如下:</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090624510.png"></p><h1 id="Image-图片的使用"><a href="#Image-图片的使用" class="headerlink" title="Image 图片的使用"></a>Image 图片的使用</h1><p>在 <code>Assets.xcassets</code> 文件中，可以导入 <code>本地图片素材，也可以设置颜色</code></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090625230.png"></p><p>上面我们导入了一张图片，回到代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 初始化一张图片</span><br><span class="line">Image(&quot;test&quot;)</span><br><span class="line">    // 缩放图片（拉伸缩放）</span><br><span class="line">    .resizable()</span><br><span class="line">    // 等比例缩放</span><br><span class="line">    .scaledToFit()</span><br><span class="line">    // 调整图片尺寸</span><br><span class="line">    .frame(width: 300)</span><br><span class="line">    // 裁剪图片</span><br><span class="line">    .clipShape(Circle())</span><br><span class="line">    // 透明度</span><br><span class="line">    .opacity(0.8)</span><br><span class="line">    // 覆盖一层视图</span><br><span class="line">    .overlay(</span><br><span class="line">        Text(&quot;编辑&quot;)</span><br><span class="line">            .fontWeight(.bold)</span><br><span class="line">            .font(.system(size: 20))</span><br><span class="line">            .foregroundColor(.white)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>最后在预览中呈现的样式如下：</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090625499.png"></p><p>知识点：Image除了可以展示 <code>本地图片</code>，还可以展示 <code>网络图片</code> 和 <code>系统图标</code></p><h1 id="官方符号"><a href="#官方符号" class="headerlink" title="官方符号"></a>官方符号</h1><p><code>Apple</code> 官方提供了 <code>3000</code> 个新符号供开发者使用，开发者几乎无需自己收集常用图标</p><p><a href="https://developer.apple.com/sf-symbols/">Apple官方图标</a></p><p>使用方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 使用系统图标</span><br><span class="line">Image(systemName: &quot;square.and.arrow.up&quot;)</span><br><span class="line">    .font(.system(size: 50))</span><br></pre></td></tr></table></figure><h1 id="安全区"><a href="#安全区" class="headerlink" title="安全区"></a>安全区</h1><p>我们看到模拟器预留了 <code>顶栏</code> 和 <code>底栏</code> 两块区域，这是 <code>安全区域</code></p><p>如果想忽略安全区域，把视图撑开整个屏幕，通过设置 <code>.edgesIgnoringSafeArea</code> 修饰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.edgesIgnoringSafeArea(.all)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI学习02：搭建一个新项目</title>
      <link href="/BboyZJ.github.io/2023/02/19/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A002%EF%BC%9A%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E9%A1%B9%E7%9B%AE/"/>
      <url>/BboyZJ.github.io/2023/02/19/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A002%EF%BC%9A%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在本章中，你将学会如何使用Xcode创建一个SwiftUI项目</p><h1 id="创建你的第一个SwiftUI项目"><a href="#创建你的第一个SwiftUI项目" class="headerlink" title="创建你的第一个SwiftUI项目"></a>创建你的第一个SwiftUI项目</h1><p>首先，启动Xcode，在顶栏选择 <code>File -&gt; New -&gt; Project</code></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090621840.png"></p><ul><li>在 <code>iOS</code> 类目下，选择 <code>App</code>，选择 <code>Next</code>，继续下一个屏幕</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090621421.png"></p><ul><li><p>choose options for your new project：完善项目的基本信息</p><ul><li>Product：项目名称，最好是英文</li><li>Team：开发者账号（个人、公司、企业）</li><li>Organization Name：组织名称</li><li>Organization Identifier：应用程序的唯一标识符，反向DNS表示法，电子邮件反地址或公司地址颠倒</li><li>Bundle Identifier：组织唯一标识.项目名称</li><li>Interface：用户界面，SwiftUI 或 Storyboard</li><li>Language：语言，Swift 或 Objective-C</li><li>Use Core Data：面向对象的数据库，不选</li><li>Include Tests：测试，不选</li></ul><p>  <img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090622814.png"></p></li></ul><p> 点击 <code>Next</code> ，选择文件保存目录后，我们成功创建一个SwiftUI项目</p><p> <img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090622213.png"></p><p>默认情况下，Xcode自动根据 <code>ContentView.swift</code> 内容生成 <code>SwiftUI</code> 示例代码</p><ul><li>可以根据顶部路径切换模拟器型号，然后单击预览区 <code>Resume</code> 按钮，查看实时预览效果</li></ul><h1 id="Xcode界面"><a href="#Xcode界面" class="headerlink" title="Xcode界面"></a>Xcode界面</h1><ul><li>中间：主编辑窗口，分两部分<ul><li>代码区</li><li>预览区</li></ul></li><li>左侧：文件导航器</li><li>右侧：实用程序窗口</li><li>下面：调试器，控制台输出</li></ul><h1 id="预览区"><a href="#预览区" class="headerlink" title="预览区"></a>预览区</h1><ul><li>Live ：</li></ul><p>模拟一个实际的真实互动情况</p><ul><li>Selectable：</li></ul><p>选择模式，选中画面内容 <code>找到</code> 对应的代码</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090623637.png"></p><ul><li>Variants：</li></ul><p>快读比较一下不同的情景，但并不生效</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090623456.png"></p><blockquote><p>Color Scheme Variants：颜色方案 Light（浅色） Dark（深色）<br>Orientation Variants：方向 竖向（Portrait） 横向（Landscape）<br>Dynamic Type Variants：动态类型 使用者选择的字体大小（从最小的XS -&gt; 最大的 AX5）</p></blockquote><ul><li>Device Setting ：</li></ul><p>设置上面的3个不同情景并生效</p><ul><li>Preview on Device：</li></ul><p>在具体的设备预览</p><h1 id="App入口"><a href="#App入口" class="headerlink" title="App入口"></a>App入口</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// @main 代表的就是这个App的入口</span><br><span class="line">@main</span><br><span class="line">struct FirstDemoApp: App &#123;</span><br><span class="line">    // body属性设计一个Scene的类型</span><br><span class="line">    var body: some Scene &#123;</span><br><span class="line">        // 视窗</span><br><span class="line">        WindowGroup &#123;</span><br><span class="line">            // 最底层的画面</span><br><span class="line">            ContentView()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个App基本的架构就是，App里面会有一个 <code>视窗Scene</code>，<code>视窗Scene</code> 里面会有 <code>View</code>，你只要设定一个遵循 <code>Protocol</code> 规范的类型，就可以拿到对应的功能，App需要知道视窗Scene是什么，scene需要知道view</p><h1 id="Assets"><a href="#Assets" class="headerlink" title="Assets"></a>Assets</h1><p>包在这个 <code>target</code> 中的档案，如图片、icon、color</p><h1 id="Preview-Content"><a href="#Preview-Content" class="headerlink" title="Preview Content"></a>Preview Content</h1><p>存放一些开发时用到的 图片和资料等，在打包的时候回自动被排除。</p>]]></content>
      
      
      <categories>
          
          <category> SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftUI学习01：Swift入门</title>
      <link href="/BboyZJ.github.io/2023/02/19/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A001%EF%BC%9ASwiftUI%E5%85%A5%E9%97%A8/"/>
      <url>/BboyZJ.github.io/2023/02/19/SwiftUI%E8%AF%BE%E7%A8%8B/SwiftUI%E5%AD%A6%E4%B9%A001%EF%BC%9ASwiftUI%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是SwiftUI？"><a href="#什么是SwiftUI？" class="headerlink" title="什么是SwiftUI？"></a>什么是SwiftUI？</h1><ul><li><p><code>SwiftUI</code> 它是一个用来设计所有 <code>Apple所有平台（如：Watch应用、Apple TV、Mac应用）App</code> 的 <code>framework</code></p></li><li><p><code>SwiftUI</code> 支持 <code>面向对象编程</code>，也面向 <code>函数式编程</code> 或 <code>面向协议编程</code>。</p></li></ul><h1 id="swiftUI特点"><a href="#swiftUI特点" class="headerlink" title="swiftUI特点"></a>swiftUI特点</h1><ul><li>framework：帮我们快速的架构UI、处理使用者互动和资料管理</li><li>宣告式语法（declarative）：简洁、好上手、快速开发</li><li>支持所有 <code>Apple</code> 平台：iOS 14.0+、iPad 14.0+、macOS 10.15+、Mac Catelyst 14.0+、tvOS 14.0+、watchOS 6.0+ 6个平台</li></ul><p>注：它有版本的限制，因为是一个相对新的framework，最少需要iOS14才能支持</p>]]></content>
      
      
      <categories>
          
          <category> SwiftUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI-学习篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习19：数据类型</title>
      <link href="/BboyZJ.github.io/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A019%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/BboyZJ.github.io/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A019%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ol><li>基本类型</li></ol><ul><li><p>数值类型：</p><ul><li>整数类型：短整型 <code>short</code>、整型 int、长整型 long</li><li>浮点类型：单精度型 <code>float</code>、双精度型 double</li></ul></li><li><p>字符类型：char</p></li></ul><ol start="2"><li>构造类型</li></ol><ul><li>数组</li><li>结构体：struct</li><li>共用体：union</li><li>枚举类型：enum</li></ul><ol start="3"><li><p>指针类型</p></li><li><p>空类型 void</p></li></ol><p>注意：</p><ul><li><code>c</code> 语言中没有字符串类型，使用 <code>字符数组char[]</code> 表示字符串</li><li>不同操作系统，数据类型 <code>占用字节长度不一样</code></li></ul><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ol><li>sizeof运算符</li></ol><p>用于 <code>获取数据类型或表达式的长度</code>，长度以 <code>字节</code> 表示</p><ol start="2"><li>signed 和 unsigned</li></ol><ul><li><p>signed：有符号，第一个位代表正负，剩余代表大小。</p></li><li><p>unsigned：无符号，所有位都为大小，没有负数。</p></li></ul><h1 id="基本数据类型的取值范围"><a href="#基本数据类型的取值范围" class="headerlink" title="基本数据类型的取值范围"></a>基本数据类型的取值范围</h1><ol><li>比特位</li></ol><p>CPU能读懂的最小单位是：比特位，bit，b。每个比特位只能存放二进制数，即0和1。</p><ol start="2"><li>字节</li></ol><p>内存机构最小寻址单位：字节，Byte，B</p><p>1Byte &#x3D; 8 bit</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习18：常量</title>
      <link href="/BboyZJ.github.io/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A018%EF%BC%9A%E5%B8%B8%E9%87%8F/"/>
      <url>/BboyZJ.github.io/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A018%EF%BC%9A%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="C-常量"><a href="#C-常量" class="headerlink" title="C 常量"></a>C 常量</h1><ul><li><p>常量是固定值，在执行期间不会改变，这些固定值，又叫做 <code>字面量</code></p></li><li><p>常量可以是任何的 <code>基本数据类型</code>。</p></li><li><p>常量 就是常规的变量，只不过在定义后不能进行修改。</p></li></ul><h1 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h1><ul><li>使用 <code>#define</code> 预处理器</li></ul><p><code>#define LENGTH 10 </code></p><ul><li>使用 <code>const</code> 关键字</li></ul><p><code>const type variable = value;</code></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习17：typedef</title>
      <link href="/BboyZJ.github.io/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A017%EF%BC%9Atypedef/"/>
      <url>/BboyZJ.github.io/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A017%EF%BC%9Atypedef/</url>
      
        <content type="html"><![CDATA[<h1 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h1><p>C 语言提供了关键字 <code>typedef</code> ，可以用它为 <code>类型</code> 取一个新的名字。</p><p>例如：为无符号字符定义一个名称 UChar</p><p><code>typedef unsigned char UChar;</code></p><p>例如：为结构体定义一个名称 MyBook</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct Book&#123;</span><br><span class="line">    char title[50];</span><br><span class="line">    int book_id;</span><br><span class="line">&#125;MyBook;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    // typedef前</span><br><span class="line">//    struct Book myBook;</span><br><span class="line">    </span><br><span class="line">    // typedef后</span><br><span class="line">    MyBook book;</span><br><span class="line">    strcpy(book.title,&quot;ZJ&quot;);</span><br><span class="line">    book.book_id = 12;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;标题：%s\n&quot;,book.title);</span><br><span class="line">    printf(&quot;书 ID:%d\n&quot;,book.book_id);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码 编译和运行 时，产生的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标题：ZJ</span><br><span class="line">书 ID:12</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure><h1 id="typedef-和-define-区别"><a href="#typedef-和-define-区别" class="headerlink" title="typedef 和 #define 区别"></a>typedef 和 #define 区别</h1><ul><li><p>typedef 仅限于为 <code>类型</code> 定义名称；#define 不仅可以为 <code>类型</code> 定义别买，也可以为 <code>数值</code> 定义</p></li><li><p>typedef由编译器 <code>执行</code> 解释；#define由编译器 <code>预处理</code> 处理</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习16：enum(枚举)</title>
      <link href="/BboyZJ.github.io/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A016%EF%BC%9Aenum-%E6%9E%9A%E4%B8%BE/"/>
      <url>/BboyZJ.github.io/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A016%EF%BC%9Aenum-%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="enum-枚举"><a href="#enum-枚举" class="headerlink" title="enum(枚举)"></a>enum(枚举)</h1><p>枚举在 <code>C</code> 中是一种 <code>基本数据类型</code>，它可以让数据 <code>更简洁、更易读</code></p><p>枚举语法定义格式：</p><p><code>enum 枚举名 &#123;枚举元素1,枚举元素2,...&#125;</code></p><p>一个星期的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum DAY&#123;</span><br><span class="line">    MON=1,TUE,WED,THU,FRI,SAT,SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="枚举变量的定义"><a href="#枚举变量的定义" class="headerlink" title="枚举变量的定义"></a>枚举变量的定义</h1><ul><li>先定义枚举类型，再定义枚举变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 定义枚举类型</span><br><span class="line">enum DAY&#123;</span><br><span class="line">    MON=1,TUE,WED,THU,FRI,SAT,SUN</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // 定义枚举变量</span><br><span class="line">    enum DAY day;</span><br><span class="line">    printf(&quot;%d\n&quot;,day=WED);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义枚举类型的同时，定义枚举变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 定义枚举类型和变量</span><br><span class="line">enum DAY&#123;</span><br><span class="line">    MON=1,TUE,WED,THU,FRI,SAT,SUN</span><br><span class="line">&#125;day;</span><br></pre></td></tr></table></figure><ul><li>省略枚举名称，直接定义枚举变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 省略枚举名称，直接定义枚举变量</span><br><span class="line">enum &#123;</span><br><span class="line">    MON=1,TUE,WED,THU,FRI,SAT,SUN</span><br><span class="line">&#125;day;</span><br></pre></td></tr></table></figure><ul><li>实例，遍历枚举</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 省略枚举名称，直接定义枚举变量</span><br><span class="line">enum &#123;</span><br><span class="line">    MON=1,TUE,WED,THU,FRI,SAT,SUN</span><br><span class="line">&#125;day;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    for (day = MON; day&lt;=SUN; day++) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,day);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码 编译和运行 时，产生结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习15：递归</title>
      <link href="/BboyZJ.github.io/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A015%EF%BC%9A%E9%80%92%E5%BD%92/"/>
      <url>/BboyZJ.github.io/2023/02/18/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A015%EF%BC%9A%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归指： 函数中使用函数自身的方法</p><p><code>C</code> 语言中支持递归，即 <code>一个函数可以调用自身</code>，在使用递归时，程序员要注意函数的 <code>退出条件</code>，否则会进入死循环</p><h1 id="数的阶乘"><a href="#数的阶乘" class="headerlink" title="数的阶乘"></a>数的阶乘</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">double factorial(unsigned int i)&#123;</span><br><span class="line">    if (i&lt;=1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return i * factorial(i-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    int i = 5;</span><br><span class="line">    printf(&quot;%d 的阶乘是：%f\n&quot;,i,factorial(i));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被 编译和运行 时，产生的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 的阶乘是：120.000000</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure><h1 id="斐波那契额数列"><a href="#斐波那契额数列" class="headerlink" title="斐波那契额数列"></a>斐波那契额数列</h1><p>当前数是前两个数之和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int fibonaci(int i)&#123;</span><br><span class="line">    if (i == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return fibonaci(i-1) + fibonaci(i-2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;    </span><br><span class="line">    for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">       printf(&quot;%d\t\n&quot;, fibonaci(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当上面的代码 编译和运行时，产生的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OCRunloop02：Runloop线程保活</title>
      <link href="/BboyZJ.github.io/2023/02/16/OCRuntime&amp;Runloop/OCRunloop02%EF%BC%9ARunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB/"/>
      <url>/BboyZJ.github.io/2023/02/16/OCRuntime&amp;Runloop/OCRunloop02%EF%BC%9ARunloop%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="创建线程类"><a href="#创建线程类" class="headerlink" title="创建线程类"></a>创建线程类</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface ZJThread : NSThread</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">//  ZJThread.m</span><br><span class="line">//  Runloop-线程保活</span><br><span class="line">//</span><br><span class="line">//  Created by Mac on 2023/2/16.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;ZJThread.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZJThread</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NextViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface NextViewController ()</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NextViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // NSThread 频繁创建线程</span><br><span class="line">    ZJThread * thread = [[ZJThread alloc]initWithTarget:self selector:@selector(test) object:nil];</span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子线程需要执行的任务</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>Run 起来之后</p><p>我们发现每次点击，都会去执行任务: <code>ZJThread 频繁创建线程</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2023-02-16 19:06:19.752652+0800 Runloop-频繁创建线程[16937:1026536] -[NextViewController test] &lt;ZJThread: 0x28150ce80&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2023-02-16 19:06:19.753833+0800 Runloop-频繁创建线程[16937:1026536] -[ZJThread dealloc]</span><br><span class="line">2023-02-16 19:06:20.309051+0800 Runloop-频繁创建线程[16937:1026537] -[NextViewController test] &lt;ZJThread: 0x28152ca00&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2023-02-16 19:06:20.309697+0800 Runloop-频繁创建线程[16937:1026537] -[ZJThread dealloc]</span><br></pre></td></tr></table></figure><p>可以看到任务一完成，线程就释放，并且这样 <code>频繁的创建线程，很消耗资源</code></p><h1 id="我们可以用Runloop来延长线程的生命周期，不让线程挂掉"><a href="#我们可以用Runloop来延长线程的生命周期，不让线程挂掉" class="headerlink" title="我们可以用Runloop来延长线程的生命周期，不让线程挂掉"></a>我们可以用Runloop来延长线程的生命周期，不让线程挂掉</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 子线程需要执行的任务</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    [[NSRunLoop currentRunLoop] run];</span><br><span class="line">        </span><br><span class="line">    NSLog(@&quot;%s ----end----&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 子线程需要执行的任务</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    [[NSRunLoop currentRunLoop] run];</span><br><span class="line">        </span><br><span class="line">    NSLog(@&quot;%s ----end----&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：发现线程执行完成任务还是会结束线程  <code>[ZJThread dealloc]</code>，这是因为 <code>run</code> 方法底层调用的是 <code>- (BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate;</code> 方法，这个方法会把 <code>runloop</code> 加入到 <code>NSDefaultRunLoopMode</code> 模式下，而 Model 下没有任何 Source0，Source1，Timer，Observe，Runloop，会立马退出，所以我们需要往 Runloop 中添加任务</p><h1 id="往-runloop-中添加任务，任何任务都行"><a href="#往-runloop-中添加任务，任何任务都行" class="headerlink" title="往 runloop 中添加任务，任何任务都行"></a>往 runloop 中添加任务，任何任务都行</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 子线程需要执行的任务</span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]);</span><br><span class="line">    NSLog(@&quot;🏌🏌🏌🏌🏌🏌🏌🏀🏀🏀🏅🏅🏅&quot;);</span><br><span class="line">    // 往RunLoop里面添加Source\Timer\Observer</span><br><span class="line">    [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span><br><span class="line">    [[NSRunLoop currentRunLoop] run];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%s ----end----&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2023-02-16 19:15:08.021488+0800 Runloop-频繁创建线程[16991:1030153] -[NextViewController test] &lt;ZJThread: 0x281b95a40&gt;&#123;number = 22, name = (null)&#125;</span><br><span class="line">2023-02-16 19:15:08.021835+0800 Runloop-频繁创建线程[16991:1030153] 🏌🏌🏌🏌🏌🏌🏌🏀🏀🏀🏅🏅🏅</span><br></pre></td></tr></table></figure><p>在运行线程就不会执行完任务就挂掉，而是执行完任务就休眠</p><p>每点击一次屏幕，都是创建了 <code>ZJThread * thread = [[ZJThread alloc]initWithTarget:self selector:@selector(test) object:nil];</code> 经过 <code>[[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</code> 和 <code>[[NSRunLoop currentRunLoop] run];</code> 线程进入休眠，导致我们没办法唤醒线程和执行线程任务，继续修改</p><h1 id="把-thread-改成局部变量"><a href="#把-thread-改成局部变量" class="headerlink" title="把 thread 改成局部变量"></a>把 thread 改成局部变量</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.thread = [[ZJThread alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br></pre></td></tr></table></figure><p>上面的写法：<code>self</code> 会引用 <code>thread</code>，<code>thread</code> 会引用 <code>self</code>，造成循环引用</p><h1 id="用block实现"><a href="#用block实现" class="headerlink" title="用block实现"></a>用block实现</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">        //如果使用如下方式创建thread，self会引用thread，thread会引用self，会造成循环引用。</span><br><span class="line">        //[[MJThread alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">    </span><br><span class="line">        self.thread = [[MJThread alloc] initWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;%@----begin----&quot;, [NSThread currentThread]);</span><br><span class="line">        </span><br><span class="line">        // 往RunLoop里面添加Source\Timer\Observer</span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        </span><br><span class="line">        //线程会一直阻塞这这一行，永远不会销毁</span><br><span class="line">        [[NSRunLoop currentRunLoop] run]; </span><br><span class="line"></span><br><span class="line">        //当把NSRunLoop停掉之后，代码就会从下一行往下走，这时候任务执行完成，线程该死的时候就会死了。</span><br><span class="line">        NSLog(@&quot;%@----end----&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.thread start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>run</code> 方法：Runloop 无法停止，它专门用于开启一个永不销毁的线程</p><h1 id="替换-run"><a href="#替换-run" class="headerlink" title="替换 run"></a>替换 run</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br></pre></td></tr></table></figure><h1 id="Runloop-的启动和退出"><a href="#Runloop-的启动和退出" class="headerlink" title="Runloop 的启动和退出"></a>Runloop 的启动和退出</h1><p>启动：</p><ul><li>run：无条件</li><li>runUntilDate：设定时间限制</li><li>runMode:beforeDate：在特定模式下</li></ul><p>停止：</p><ul><li>CFRunLoopStop(CFRunLoopGetCurrent())</li></ul><h1 id="实现线程保活"><a href="#实现线程保活" class="headerlink" title="实现线程保活"></a>实现线程保活</h1><p>ZJThread.h 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJThread.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZJThread</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>NextVC 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NextViewController.h&quot;</span><br><span class="line">#import &quot;ZJThread.h&quot;</span><br><span class="line"></span><br><span class="line">@interface NextViewController ()</span><br><span class="line">@property (nonatomic,strong)ZJThread * thread;</span><br><span class="line">@property (nonatomic,assign)BOOL isStop;</span><br><span class="line">@property (nonatomic,strong)UIButton * stopBtn;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NextViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    // 停止按钮</span><br><span class="line">    [self.view addSubview:self.stopBtn];</span><br><span class="line">    /*</span><br><span class="line">     创建线程有两种方式:</span><br><span class="line">     target：会造成循环引用</span><br><span class="line">     block：不会造成循环引用</span><br><span class="line">     */</span><br><span class="line">    [self blockCreatThread];</span><br><span class="line">&#125;</span><br><span class="line">- (void)blockCreatThread&#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    </span><br><span class="line">    self.isStop = NO; // 未停止</span><br><span class="line">    self.thread = [[ZJThread alloc] initWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;%@---begin---&quot;,[NSThread currentThread]);</span><br><span class="line">        </span><br><span class="line">        // 往runloop中添加Source\Timer\Observer</span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        while (weakSelf &amp;&amp; !weakSelf.isStop) &#123;</span><br><span class="line">            [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;%@---end---&quot;, [NSThread currentThread]);</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">         run方法无法停止，它专门用于开启一个永不销毁的线程</span><br><span class="line">         [[NSRunLoop currentRunLoop] run];</span><br><span class="line">         */</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 点击</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line">// 子线程要执行的任务</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]);</span><br><span class="line">    NSLog(@&quot;🏌🏌🏌🏌🏌🏌🏌🏀🏀🏀🏅🏅🏅&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 停止</span><br><span class="line">- (void)stop&#123;</span><br><span class="line">    if (!self.thread) return;</span><br><span class="line">    </span><br><span class="line">    // 停止子线程</span><br><span class="line">    [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:YES];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">- (void)stopThread&#123;</span><br><span class="line">    // 标记停止</span><br><span class="line">    self.isStop = YES;</span><br><span class="line">    </span><br><span class="line">    // 停止</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">    self.thread = nil;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@---end---&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    // 停止子线程</span><br><span class="line">    [self stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">- (UIButton *)stopBtn&#123;</span><br><span class="line">    if (!_stopBtn) &#123;</span><br><span class="line">        _stopBtn = [[UIButton alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];</span><br><span class="line">        _stopBtn.backgroundColor = [UIColor greenColor];</span><br><span class="line">        [_stopBtn setTitle:@&quot;stop&quot; forState:UIControlStateNormal];</span><br><span class="line">        [_stopBtn setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];</span><br><span class="line">        [_stopBtn addTarget:self action:@selector(stop) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    &#125;</span><br><span class="line">    return _stopBtn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OC-Runloop探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter面试题：Flutter</title>
      <link href="/BboyZJ.github.io/2023/02/16/%E9%9D%A2%E8%AF%95%E9%A2%98/Flutter%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%80%BB%E7%BB%93/"/>
      <url>/BboyZJ.github.io/2023/02/16/%E9%9D%A2%E8%AF%95%E9%A2%98/Flutter%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是flutter？原理是什么？"><a href="#什么是flutter？原理是什么？" class="headerlink" title="什么是flutter？原理是什么？"></a>什么是flutter？原理是什么？</h2><ol><li><p><code>flutter</code> 是 <code>google</code> 推出并 <code>开源的移动应用开发框架</code>，通过 <code>dart</code> 语言开发APP，一套代码可以同时运行在 <code>iOS</code> 和 <code>Android</code> 平台。</p></li><li><p><code>flutter</code> 底层使用 <code>skia</code> 作为 <code>2D渲染引擎</code>，通过自己的渲染引擎来 <code>绘制widget(组件)</code>，<code>dart</code> 语言借鉴了 <code>Java</code> 和 <code>JavaScript</code> 同时加入了一些 <code>现代编程语言</code> 特性。</p></li></ol><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter-面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习14：内存管理</title>
      <link href="/BboyZJ.github.io/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A014%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/BboyZJ.github.io/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A014%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>C 语言为内存 <code>分配和管理</code> 提供了几个函数，这些函数都在 <code>&lt;stdlib.h&gt;</code> 头文件中</p><h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><ul><li><code>全局变量</code> 分配在内存中的 <code>静态存储区</code></li><li><code>局部变量</code> 分配在内存中的 <code>动态存储区</code>，存放在 <code>栈（stack）</code> 区。</li><li><code>临时数据</code> 分配在内存中的 <code>动态存储区</code>，存放在 <code>堆（heap）</code> 区</li></ul><ol><li>用 <code>malloc</code> 函数开辟动态存储区</li></ol><p>void * malloc(unsigned int size);</p><p>在内存动态存储区分配一个长度为size的连续空间，形参size类型为无符号整型</p><p>malloc(100)：开辟100字节的临时分配域，其值为第一个字节的地址</p><ol start="2"><li>用 <code>calloc</code> 函数开辟动态存储区</li></ol><p>void * calloc(unsigned n,unsigned int size);</p><p>内存中分配n个长度为size的连续空间</p><ol start="3"><li>用 <code>recalloc</code> 函数重新分配动态存储区</li></ol><p>void * recalloc(void *p,unsigned int size);</p><p>如果已经用 <code>malloc</code> 和 <code>calloc</code> 函数获取了，想改变大小，用 <code>recalloc</code> 重新分配</p><p>recalloc(p,50); &#x2F;&#x2F; 将p所指向的已分配的动态内存改为50字节</p><ol start="4"><li>用 <code>free</code> 函数释放动态存储区</li></ol><p>void free(void *p);</p><p>其作用是释放指针变量p所指向的动态空间。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习13：文件</title>
      <link href="/BboyZJ.github.io/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A013%EF%BC%9A%E6%96%87%E4%BB%B6/"/>
      <url>/BboyZJ.github.io/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A013%EF%BC%9A%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h1><p><code>FILE * fopen(const char * filename,const * mode);</code></p><p>filename:文件名<br>mode：样式</p><p><img src="/BboyZJ.github.io/assets/16766950595771.jpg"></p><h1 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h1><p><code>int fclose(int c,FILE *fp);</code></p><p>fclose()函数返回零：关闭成功<br>fclose()韩式返回EOF：关闭失败</p><p>注：EOF 是一个定义在头文件&lt;stdio.h&gt;中的常量</p><h1 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h1><ul><li>把字符写入到流中</li></ul><p><code>int fputc(char c,FILE *fp);</code></p><ul><li>把字符串写入到流中</li></ul><p><code>int fputs(const char *s,FILE *fp);</code></p><p>或 </p><p><code>int fprintf(FILE *fp,const char *format,...);</code></p><p>注：请确保您有可用的tmp目录</p><h1 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h1><ul><li>读取一个字符</li></ul><p><code>int fgetc(FILE *fp);</code></p><ul><li>读取 字符串</li></ul><p><code>char * fgets(char *buf,int n,FILE *fp);</code></p><p>读取 n-1 个字符，读取到的字符串复制到缓冲区buf，并追加一个 <code>null</code> 字符；如果读取到 <code>\n或EOF</code> 结束</p><p>或</p><p><code>int fscanf(FILE *fp, const char *format, ...);</code></p><p>读取字符串，遇到 <code>空格或换行符</code> 停止</p><h1 id="二进制-I-x2F-O-函数"><a href="#二进制-I-x2F-O-函数" class="headerlink" title="二进制 I&#x2F;O 函数"></a>二进制 I&#x2F;O 函数</h1><p>二进制输入和输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t fread(void *ptr, size_t size_of_elements, </span><br><span class="line">             size_t number_of_elements, FILE *a_file);</span><br><span class="line">              </span><br><span class="line">size_t fwrite(const void *ptr, size_t size_of_elements, </span><br><span class="line">             size_t number_of_elements, FILE *a_file);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习12：预处理器</title>
      <link href="/BboyZJ.github.io/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A012%EF%BC%9A%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
      <url>/BboyZJ.github.io/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A012%EF%BC%9A%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="C-预处理器"><a href="#C-预处理器" class="headerlink" title="C 预处理器"></a>C 预处理器</h1><p>预处理器 <code>不是</code> 编译器的组成部分，是编译过程的一个单独的步骤。简言之，C预处理器是一个 <code>文本替换工具</code>，它会指示编译器在实际编译前完成所需的 <code>预处理</code>；我们把 C 预处理器(C Preprocessor) 简写成(CPP)</p><p>所有的预处理器都是以 <code>#</code> 开头，非空字符，为增加可读性，从第一列开始，下面列出了所有的预处理命令：</p><p><img src="/BboyZJ.github.io/assets/16766967005229.jpg"></p><h1 id="预处理实例"><a href="#预处理实例" class="headerlink" title="预处理实例"></a>预处理实例</h1><p><code>#define MAX_LENGTH 20</code></p><p>这个指令告诉 <code>CPP</code> 把所有的 <code>MAX_LENGTH</code> 定义为 <code>20</code>，使用 <code>#define</code> 定义常量来增强可读性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio,h&gt;</span><br><span class="line">#include &quot;myheader.h&quot;</span><br></pre></td></tr></table></figure><p>这个指令告诉 <code>CPP</code> 从 <code>系统库</code> 中读取 <code>stdio.h</code>，并添加到 <code>当前源文件</code> 中；下一行告诉 <code>CPP</code> 从 <code>本地目录</code> 中获取 <code>myheader.h</code>，并添加到 <code>当前源文件中</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#undef FILE_SIZE</span><br><span class="line">#define FILE_SIZE 30</span><br></pre></td></tr></table></figure><p>这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 30</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MESSAGE</span><br><span class="line">   #define MESSAGE &quot;You wish!&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>这个指令告诉 <code>CPP</code> 只要当 <code>MESSAGE</code> 未定义时，才定义 <code>MESSAGE</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">    /*debug here*/</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>这个指令告诉 <code>CPP</code> ，如果定义了 <code>DEBUG</code>,则执行语句。</p><h1 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h1><p>ANSI C 定义了许多宏</p><p><img src="/BboyZJ.github.io/assets/16766975236082.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;File :%s\n&quot;, __FILE__ );</span><br><span class="line">   printf(&quot;Date :%s\n&quot;, __DATE__ );</span><br><span class="line">   printf(&quot;Time :%s\n&quot;, __TIME__ );</span><br><span class="line">   printf(&quot;Line :%d\n&quot;, __LINE__ );</span><br><span class="line">   printf(&quot;ANSI :%d\n&quot;, __STDC__ );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码在 main.c 中编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File :/Users/mac/Desktop/预处理器/预处理器/main.m</span><br><span class="line">Date :Feb 18 2023</span><br><span class="line">Time :13:22:02</span><br><span class="line">Line :16</span><br><span class="line">ANSI :1</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure><h1 id="预处理器运算符"><a href="#预处理器运算符" class="headerlink" title="预处理器运算符"></a>预处理器运算符</h1><ul><li>宏延续运算符 ()</li></ul><p>一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用 宏延续运算符（\）。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define msg(a,b) \</span><br><span class="line">    printf(#a &quot;and&quot; #b &quot;\n&quot;)</span><br></pre></td></tr></table></figure><ul><li>字符串常量化运算符（#）</li></ul><p>在宏定义中，把一个 <code>宏参数</code> 转为 <code>字符串常量</code></p><p>在 main.c 中 编译和运行上面的代码，得到下面的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1and&#x27;a&#x27;</span><br></pre></td></tr></table></figure><ul><li>标记粘贴运算符（##）</li></ul><p>宏定义内标记粘贴运算符（##）会合并两个参数</p><h1 id="参数化宏"><a href="#参数化宏" class="headerlink" title="参数化宏"></a>参数化宏</h1><p><code>#define square(x) (x*x)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define max(x,y) \</span><br><span class="line">    printf(&quot;%d\n&quot;,x&gt;y?x:y);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习11：基本语法</title>
      <link href="/BboyZJ.github.io/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A011%EF%BC%9A%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/BboyZJ.github.io/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A011%EF%BC%9A%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="C-的令牌（Token）"><a href="#C-的令牌（Token）" class="headerlink" title="C 的令牌（Token）"></a>C 的令牌（Token）</h1><p>C 程序由各种令牌组成，令牌可以是 关键字、常量、字符串或一个符号。</p><h1 id="分号"><a href="#分号" class="headerlink" title="分号;"></a>分号;</h1><p>分号是语句 <code>结束符</code></p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><ul><li>单行注释</li></ul><p><code>// 单行注释</code></p><ul><li>多行注释</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 单行注释*/</span><br><span class="line">/*</span><br><span class="line">    多行注释</span><br><span class="line">    多行注释</span><br><span class="line">    ...</span><br><span class="line">*/ </span><br></pre></td></tr></table></figure><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><ul><li>auto：声明自动变量</li><li>const：定义常量，如果一个变量被const修饰，那么它的值就不能被改变</li><li>extern：声明变量或函数可以被其他文件使用</li><li>register：声明寄存器变量</li><li>typedef：给数据类型起别名</li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习10：共用体</title>
      <link href="/BboyZJ.github.io/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A010%EF%BC%9A%E5%85%B1%E7%94%A8%E4%BD%93/"/>
      <url>/BboyZJ.github.io/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A010%EF%BC%9A%E5%85%B1%E7%94%A8%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h1><p><code>共用体</code> 是一种特殊的数据类型，允许您在 <code>相同的内存位置存储不同的数据类型</code>。</p><h1 id="定义共用体"><a href="#定义共用体" class="headerlink" title="定义共用体"></a>定义共用体</h1><p>必须用 <code>union</code> 语句，方式与结构体类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">union MyData&#123;</span><br><span class="line">    int i;</span><br><span class="line">    float j;</span><br><span class="line">    char k[5];</span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure><p>当上面的代码被 编译和运行时，产生的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内存占用：8</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure><p>说明：共用体占用的内存应足够存储共用体中最大的成员，因为内存对齐，4的整数倍&#x3D;8</p><h1 id="访问共用体"><a href="#访问共用体" class="headerlink" title="访问共用体"></a>访问共用体</h1><p>我们使用 成员访问运算符(.)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    union MyData data;</span><br><span class="line">    printf(&quot;内存占用：%lu\n&quot;,sizeof(data));</span><br><span class="line">    data.i = 1;</span><br><span class="line">    data.j = 3.14;</span><br><span class="line">    strcpy(data.k, &quot;ZJ&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;i:%d\n&quot;,data.i);</span><br><span class="line">    printf(&quot;j:%f\n&quot;,data.j);</span><br><span class="line">    printf(&quot;k:%s\n&quot;,data.k);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码编译和运行是，产生的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内存占用：8</span><br><span class="line">i:1073760858</span><br><span class="line">j:2.004538</span><br><span class="line">k:ZJ</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习09：结构体</title>
      <link href="/BboyZJ.github.io/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A009%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/BboyZJ.github.io/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A009%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="声明结构体"><a href="#声明结构体" class="headerlink" title="声明结构体"></a>声明结构体</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct st&#123;</span><br><span class="line">    int a; </span><br><span class="line">    char ch[4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct st&#123;</span><br><span class="line">    int a; </span><br><span class="line">    char ch[4];</span><br><span class="line">&#125;t1;</span><br></pre></td></tr></table></figure><p>注：t1：结构体变量名</p><h1 id="初始化结构体"><a href="#初始化结构体" class="headerlink" title="初始化结构体"></a>初始化结构体</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct test t1 = &#123;5&#125;;</span><br></pre></td></tr></table></figure><h1 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct test arr[3] = &#123;1,2,3&#125;;</span><br></pre></td></tr></table></figure><h1 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h1><p>struct 结构体名 *变量名；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">struct test&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char c;</span><br><span class="line">    char arr[5];</span><br><span class="line">&#125;t1;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // 初始化结构体</span><br><span class="line">    struct test t1 = &#123;.a=1,.c=&#x27;a&#x27;,.arr=&quot;abc&quot;&#125;;</span><br><span class="line">    printf(&quot;%d %c %s\n&quot;,t1.a,t1.c,t1.arr);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="结构体指针获取成员变量"><a href="#结构体指针获取成员变量" class="headerlink" title="结构体指针获取成员变量"></a>结构体指针获取成员变量</h1><ol><li><p>(*ptr).structMenber</p></li><li><p>ptr-&gt;structMenber</p></li></ol><p>注：.运算符 高于 * ，所以(*ptr)括号不能少</p><h1 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h1><p>#pragma pack(n)：指定按照n字节对齐规则进行存储</p><h1 id="字节对齐的原因"><a href="#字节对齐的原因" class="headerlink" title="字节对齐的原因"></a>字节对齐的原因</h1><ul><li><p>计算机内存以字节为单位划分，CPU通过 <code>地址总线</code> 来访问内存，一次能处理几个字节，地址总线就读取几个字节。32位一次读取4个字节。64位一次读取8个字节。</p></li><li><p>内存对齐原因：<code>避免存取效率的损失</code></p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>结构体不占内存空间，是一个创建变量的 <code>模板</code></li><li>结构体 <code>成员变量</code> 需要开辟内存空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习08：字符串</title>
      <link href="/BboyZJ.github.io/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A008%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/BboyZJ.github.io/2023/02/15/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A008%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串的输入和输出"><a href="#字符串的输入和输出" class="headerlink" title="字符串的输入和输出"></a>字符串的输入和输出</h1><ul><li><p>scanf(格式控制,地址列表(变量前加&amp;))</p></li><li><p>printf(格式控制,地址列表)</p></li><li><p>gets(字符数组) puts(字符数组)</p></li></ul><p>区别：</p><p>gets() 和 puts() ： 只能输入或输出一个字符串</p><p>scanf() 和 printf() ：可以输出多个字符串</p><h1 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h1><p>strcat(字符数组1,字符数组2)</p><h1 id="字符串复制函数"><a href="#字符串复制函数" class="headerlink" title="字符串复制函数"></a>字符串复制函数</h1><p>strcpy(字符数组1,字符串2或字符数组名)</p><p>strncpy(字符数组1,字符串2或字符数组名,n)</p><h1 id="字符串比较函数"><a href="#字符串比较函数" class="headerlink" title="字符串比较函数"></a>字符串比较函数</h1><p>strcmp(字符数组1,字符串2或字符数组)</p><h1 id="字符串长度函数"><a href="#字符串长度函数" class="headerlink" title="字符串长度函数"></a>字符串长度函数</h1><p>strlen(字符串或字符串数组)</p><h1 id="字符串转换大小写函数"><a href="#字符串转换大小写函数" class="headerlink" title="字符串转换大小写函数"></a>字符串转换大小写函数</h1><p>大写转小写：strlwr(字符数组)</p><p>小写转大写：strupr(字符数组)</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习07：指针</title>
      <link href="/BboyZJ.github.io/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A007%EF%BC%9A%E6%8C%87%E9%92%88/"/>
      <url>/BboyZJ.github.io/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A007%EF%BC%9A%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="定义指针变量"><a href="#定义指针变量" class="headerlink" title="定义指针变量"></a>定义指针变量</h1><p>类型名 * 指针变量名</p><p><code>星号</code> 是用来指定一个 <code>变量是指针</code>。</p><h1 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h1><p><code>指针</code> 就是 <code>内存地址</code>，<code>指针变量</code> 是用来 <code>存放内存地址的变量</code>。</p><p>指针的声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int  *ip;    // 一个整型的指针</span><br><span class="line">char *cp;    // 一个字符型的指针</span><br></pre></td></tr></table></figure><h1 id="如何使用指针"><a href="#如何使用指针" class="headerlink" title="如何使用指针"></a>如何使用指针</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    int var=20;   // 实际变量的声明</span><br><span class="line">    int *ip;     // 指针变量的声明</span><br><span class="line">    </span><br><span class="line">    ip = &amp;var;  // 在 指针变量中存储 var 的地址</span><br><span class="line">    </span><br><span class="line">    printf(&quot;var 变量的地址：%p\n&quot;,&amp;var);</span><br><span class="line">    </span><br><span class="line">    /* 在指针变量中存储的地址 */</span><br><span class="line">    printf(&quot;ip 变量存储的地址: %p\n&quot;,ip);</span><br><span class="line">    /* 使用指针访问值 */</span><br><span class="line">    printf(&quot;*ip 变量的值: %d\n&quot;,*ip);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被 编译和运行 时，产生的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var 变量的地址：0x7ff7bfeff45c</span><br><span class="line">ip 变量存储的地址: 0x7ff7bfeff45c</span><br><span class="line">*ip 变量的值: 20</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure><p>注：&amp;取地址运算符。&amp;a是变量a的地址。</p><h1 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h1><p>指向整数类型的指针数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 常量</span><br><span class="line">const int MAX = 3;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // 数组</span><br><span class="line">    int var[] = &#123;10,100,200&#125;;</span><br><span class="line">    int i,*ptr[MAX];</span><br><span class="line">    for (i=0; i&lt;MAX; i++) &#123;</span><br><span class="line">        // 赋值为整数的地址</span><br><span class="line">        ptr[i] = &amp;var[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (i=0; i&lt;MAX; i++) &#123;</span><br><span class="line">        printf(&quot;value of var[%d]=%d\n&quot;,i,*ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当上面的代码被 编译和运行 时，结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value of var[0]=10</span><br><span class="line">value of var[1]=100</span><br><span class="line">value of var[2]=200</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure><h1 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h1><p>指向指针的指针是一个 <code>指针链</code>，第一个指针指向第二个指针的 <code>地址</code>，第二个指针指向 实<code>际值的位置</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int v;</span><br><span class="line">    int *p1;</span><br><span class="line">    int **p2;</span><br><span class="line">    </span><br><span class="line">    v=100;</span><br><span class="line">    </span><br><span class="line">    // 获取v的地址</span><br><span class="line">    p1=&amp;v;</span><br><span class="line">    </span><br><span class="line">    // 获取p1的地址</span><br><span class="line">    p2=&amp;p1;</span><br><span class="line">    </span><br><span class="line">    // 打印值</span><br><span class="line">    printf(&quot;var=%d\n&quot;,v);</span><br><span class="line">    printf(&quot;p1=%p\n&quot;,p1);</span><br><span class="line">    printf(&quot;*p1=%d\n&quot;,*p1);</span><br><span class="line">    printf(&quot;p2=%p\n&quot;,p2);</span><br><span class="line">    printf(&quot;**p1=%d\n&quot;,**p2);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被 编译和运行 时，结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var=100</span><br><span class="line">p1=0x7ff7bfeff3bc</span><br><span class="line">*p1=100</span><br><span class="line">p2=0x7ff7bfeff3b0</span><br><span class="line">**p1=100</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure><h1 id="传递指针给函数"><a href="#传递指针给函数" class="headerlink" title="传递指针给函数"></a>传递指针给函数</h1><p>C 语言允许传递 指针给 函数，只需要简单的声明函数参数为指针即可</p><p>示例 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // 函数的声明</span><br><span class="line">    void exchange(int *a,int *b,int *c);</span><br><span class="line">    int a,b,c;</span><br><span class="line">    printf(&quot;请输入 a b c:&quot;);</span><br><span class="line">    scanf(&quot;%d,%d,%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    exchange(&amp;a, &amp;b, &amp;c);</span><br><span class="line">    printf(&quot;order:%d,%d,%d\n&quot;,a,b,c);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void exchange(int *a,int *b,int *c)&#123;</span><br><span class="line">    // 函数的声明</span><br><span class="line">    void swap(int *x,int *y);</span><br><span class="line">    // 交换</span><br><span class="line">    if (*a &gt; *b) swap(a, b);</span><br><span class="line">    if (*a &gt; *c) swap(a, c);</span><br><span class="line">    if (*b &gt; *c) swap(b, c);</span><br><span class="line">&#125;</span><br><span class="line">void swap(int *x,int *y)&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="从函数中返回指针"><a href="#从函数中返回指针" class="headerlink" title="从函数中返回指针"></a>从函数中返回指针</h1><p>必须 <code>声明一个返回指针的函数</code>，C 语言不支持调用函数时，返回局部变量的地址，除非定义局部变量的 <code>static</code> 变量</p><p>实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX 5;</span><br><span class="line"></span><br><span class="line">// 函数定义</span><br><span class="line">int * getRandom(void)&#123;</span><br><span class="line">    static int r[10];</span><br><span class="line">    for (int i=0; i&lt;MAX; i++) &#123;</span><br><span class="line">        r[i]=rand();</span><br><span class="line">        printf(&quot;%d\n&quot;,r[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    int *p;</span><br><span class="line">    p=getRandom();</span><br><span class="line">    for (int i=0; i&lt;MAX; i++) &#123;</span><br><span class="line">        printf(&quot;*(p+[%d]):%d\n&quot;,i,*(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当上面的代码 编译和运行 时，产生的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">16807</span><br><span class="line">282475249</span><br><span class="line">1622650073</span><br><span class="line">984943658</span><br><span class="line">1144108930</span><br><span class="line">*(p+[0]):16807</span><br><span class="line">*(p+[1]):282475249</span><br><span class="line">*(p+[2]):1622650073</span><br><span class="line">*(p+[3]):984943658</span><br><span class="line">*(p+[4]):1144108930</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习06：数组</title>
      <link href="/BboyZJ.github.io/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A006%EF%BC%9A%E6%95%B0%E7%BB%84/"/>
      <url>/BboyZJ.github.io/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A006%EF%BC%9A%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h1><ul><li>数组创建</li></ul><p>type_t arr_name[const_n]</p><p>type_t : 数组元素的类型</p><p>arr_name : 数组名称</p><p>const_n : 是一个常量表达式，用来执行数组的大小</p><ul><li>数组初始化</li></ul><p>int arr[10] &#x3D; {0}; &#x2F;&#x2F; 数组的不完全初始化</p><p>int sz &#x3D; sizeof(arr)&#x2F;sizeof(arr[0]); &#x2F;&#x2F; 计算数组的元素个数</p><ul><li>数组在内存中的存储是连续的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // 数组不完成初始化</span><br><span class="line">    int arr[10] = &#123;0&#125;;</span><br><span class="line">    int sz = sizeof(arr)/sizeof(arr[0]);</span><br><span class="line">    for (int i=0; i&lt;sz; i++) &#123;</span><br><span class="line">        printf(&quot;&amp;arr[%d]=%p\n&quot;,i,&amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&amp;arr[0]=0x7ff7bfeff3c0</span><br><span class="line">&amp;arr[1]=0x7ff7bfeff3c4</span><br><span class="line">&amp;arr[2]=0x7ff7bfeff3c8</span><br><span class="line">&amp;arr[3]=0x7ff7bfeff3cc</span><br><span class="line">&amp;arr[4]=0x7ff7bfeff3d0</span><br><span class="line">&amp;arr[5]=0x7ff7bfeff3d4</span><br><span class="line">&amp;arr[6]=0x7ff7bfeff3d8</span><br><span class="line">&amp;arr[7]=0x7ff7bfeff3dc</span><br><span class="line">&amp;arr[8]=0x7ff7bfeff3e0</span><br><span class="line">&amp;arr[9]=0x7ff7bfeff3e4</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure><h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><ul><li>二维数组创建</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int arr[行][列]</span><br><span class="line"></span><br><span class="line">int arr[3][4] = &#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;;</span><br></pre></td></tr></table></figure><ul><li>二维数组的使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int arr[3][4] = &#123;&#123;1,2,3&#125;,&#123;5,6,7,8&#125;&#125;;</span><br><span class="line">    for (int i=0; i&lt;2; i++) &#123;</span><br><span class="line">        for (int j=0; j&lt;2; j++) &#123;</span><br><span class="line">            printf(&quot;%d\n&quot;,arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二维数组在内存的存储</li></ul><p>内存是连续的</p><h1 id="数组作为形式参数"><a href="#数组作为形式参数" class="headerlink" title="数组作为形式参数"></a>数组作为形式参数</h1><p>有三种方式告诉编译器将要接收一个  <code>整型指针</code></p><ol><li>形式参数是一个指针</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void myFunc(int *param)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>形式参数是一个已定大小的数组</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void myFunc(int param[10])&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>形式参数是一个未定义大小的数组</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void myFunc(int param[])&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="从函数返回数组"><a href="#从函数返回数组" class="headerlink" title="从函数返回数组"></a>从函数返回数组</h1><p>C 语言不允许返回一个完成的数组，可以通过 <code>声明一个返回指针的函数</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int * myFunc&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习05：函数与程序结构</title>
      <link href="/BboyZJ.github.io/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A005%EF%BC%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
      <url>/BboyZJ.github.io/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A005%EF%BC%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="函数的声明和定义"><a href="#函数的声明和定义" class="headerlink" title="函数的声明和定义"></a>函数的声明和定义</h1><ol><li><p>在C语言中，函数的定义顺序是有讲究的：默认情况下，只有后面定义的函数才可以调用前面定义过的函数</p></li><li><p>如果想把函数的定义写在main函数后面，而且main函数能正常调用这些函数，那就必须在main函数的前面进行函数的声明</p></li><li><p>函数的声明：</p><p> 返回值类型 函数名(参数1,参数2,…)</p></li></ol><p>注：如果只有函数的声明，没有函数的定义，那么链接时会出错</p><h1 id="多个源文件"><a href="#多个源文件" class="headerlink" title="多个源文件"></a>多个源文件</h1><p>项目大，如果都放在一个.c文件源代码会非常多，因此需要创建新的.c文件存放不同的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main.c</span><br><span class="line">int main()&#123;</span><br><span class="line">    int c = sum(1,2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum.c</span><br><span class="line">int sum(int a,int b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include</h1><ol><li>作用</li></ol><p><code>include</code> 是 <code>C</code> 语言 <code>预处理</code> 指令之一，后面跟一个文件名，会根据文件名去查找文件，并把这个文件的内容包含到当前文件中。</p><ol start="2"><li>include&lt;&gt; 和 include“”区别</li></ol><ul><li>“”：从父文件夹搜索，找不到去父的父文件夹搜索，找不到去编译器设置的inlcude路径内搜索，找不到则在系统的INCLUDE环境变量内搜索</li><li>&lt;&gt;：编译器设置的include路径内搜索，找不到则在系统的INCLUDE环境变量内搜索</li></ul><h1 id="头文件-h-和-源文件-c的分工"><a href="#头文件-h-和-源文件-c的分工" class="headerlink" title="头文件.h 和 源文件 .c的分工"></a>头文件.h 和 源文件 .c的分工</h1><ol><li>函数的声明写在 .h 文件中</li><li>函数的定义卸载 .c 源文件中</li></ol><h1 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h1><ol><li>形式参数</li></ol><p><code>形参</code> 在定义时编译系统不分配内存，只有在调用函数时才分配内存。调用结束内存被释放。</p><ol start="2"><li>实际参数</li></ol><p><code>实参</code> 出现在主函数中，当函数调用时，函数把实参的值传递给函数的形参，从而实现函数间的传递。</p><p>传递的方式有两种：<code>值传递</code> 和 <code>地址传递</code></p><h1 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h1><ul><li>局部变量：首先是一个变量，其次是这个变量在程序的 <code>局部范围有效</code></li></ul><p>书写：首字母小写</p><ul><li>全局变量：首先是变量，其次在 <code>定义处以下才有效</code></li></ul><p>书写：首字母大写</p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><ul><li>include作用：</li></ul><p>include：<code>把头文件里的内容原封不动的复制到引用该头文件的地方</code>。</p><ul><li>头文件的格式说明</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef 头文件名  // 头文件名的格式是&quot;_头文件名_&quot;，注意要大写</span><br><span class="line">#define 头文件名</span><br><span class="line"></span><br><span class="line">头文件内容</span><br><span class="line"></span><br><span class="line">#endif </span><br></pre></td></tr></table></figure><p>示例代码：头文件main.h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _MATH_H_    // 如果没有定义main.h，则执行下面的代码。这是防止重复定义</span><br><span class="line">#define _MATH_H_    // 定义头文件</span><br><span class="line"></span><br><span class="line">// 下面的代码是头文件内容</span><br><span class="line">#include&lt;stido.h&gt; // 头文件</span><br><span class="line">#define ADD 1   // 宏定义</span><br><span class="line">extern int x;   // 全局变量</span><br><span class="line">void swap(int a,int b); // 函数声明</span><br><span class="line"></span><br><span class="line">#endif  // 表示头文件结束</span><br></pre></td></tr></table></figure><h1 id="内部函数和外部函数"><a href="#内部函数和外部函数" class="headerlink" title="内部函数和外部函数"></a>内部函数和外部函数</h1><ul><li>外部函数：可以被其他源文件调用的函数</li></ul><p>在函数声明处添加 <code>extern关键字</code>，可省略</p><ul><li>内部函数：只在定义的源文件中有效</li></ul><p>在函数的返回值类型前面添加 <code>static关键字</code>，也称 <code>静态函数</code></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li>形参和实参</li></ol><p>输入两个正整数m和n，求从m加到n的和（m&lt;&#x3D;n），并输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int sum(int a,int b);</span><br><span class="line">void swap(int *a,int *b);</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    int m,n,total;</span><br><span class="line">    printf(&quot;请输入两个整数：&quot;);</span><br><span class="line">    scanf(&quot;%d,%d&quot;,&amp;m,&amp;n);</span><br><span class="line">    </span><br><span class="line">    if (m&gt;n)&#123;</span><br><span class="line">        swap(&amp;m, &amp;n);</span><br><span class="line">    &#125;</span><br><span class="line">    total = sum(m, n);</span><br><span class="line">    printf(&quot;a=%d,b=%d\n&quot;,m,n);</span><br><span class="line">    printf(&quot;total=%d\n&quot;,total);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sum(int a,int b)&#123;</span><br><span class="line">    for (int i = a+1; i &lt;= b; i++) &#123;</span><br><span class="line">        a += i;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">void swap(int *a,int *b)&#123;</span><br><span class="line">    int temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>定义选择排序和使用选择排序分别在不同的文件中</li></ul><p>main.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define ARR_LEN 10</span><br><span class="line"></span><br><span class="line">void select_sort(int arr[],int len);</span><br><span class="line">void print_arr(int arr[],int len);</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    int arr[ARR_LEN] = &#123;8,1,4,10,3,6,2,7,9,5&#125;;</span><br><span class="line">    printf(&quot;排序前：\n&quot;);</span><br><span class="line">    print_arr(arr, ARR_LEN);</span><br><span class="line">    </span><br><span class="line">    select_sort(arr, ARR_LEN);</span><br><span class="line">    printf(&quot;排序后：\n&quot;);</span><br><span class="line">    print_arr(arr, ARR_LEN);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ssort.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 交换</span><br><span class="line">static void swap(int *a,int *b)&#123;</span><br><span class="line">    int temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印数组</span><br><span class="line">extern void print_arr(int arr[],int len)&#123;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        printf(&quot;%d&quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 选择排序</span><br><span class="line">extern void select_sort(int arr[],int len)&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    for (i = 0; i &lt; len; i ++) &#123;</span><br><span class="line">        for (j = i+1; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[i] &gt; arr[j])&#123;</span><br><span class="line">                swap(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习04：语句和控制块</title>
      <link href="/BboyZJ.github.io/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A004%EF%BC%9A%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%8E%A7%E5%88%B6%E5%9D%97/"/>
      <url>/BboyZJ.github.io/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A004%EF%BC%9A%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%8E%A7%E5%88%B6%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="输入输出语句"><a href="#输入输出语句" class="headerlink" title="输入输出语句"></a>输入输出语句</h1><ol><li>printf(格式控制,输出表列)</li></ol><ul><li>%d格式符：输出有符号十进制整数。</li><li>c格式符：输出一个字符。</li><li>s格式符：输出一个字符串。</li><li>f格式符：%f-实数部分全部输出，小数部分输出6位。%m.nf-m表示包括小数在内的整个浮点数长度，n表示小数点保留几位。</li><li>p格式符：用来输出地址。</li></ul><ol start="2"><li>scanf</li></ol><p>一般形式为 scanf(格式控制,地址表列)</p><ol start="3"><li>正则</li></ol><p>需要通过 #include &lt;regex.h&gt; 库</p><ul><li>%[abc]：读取a&#x2F;b&#x2F;c任意一员</li><li>%[^a-z]：读取不在a-z之间的字符串</li><li>%[^&#x3D;]：读取字符串直到碰到&#x3D;号</li><li>%<em>[^&#x3D;]：前面</em>号表示不保存变量</li></ul><ol start="3"><li>字符输入输出</li></ol><ul><li>putchar(c)：用于输出字符c</li><li>c &#x3D; getchar()：用于输入一个字符，返回的不是char类型，而是 <code>int</code> 类型</li></ul><p>一般用法 while(c&#x3D;getchar() &amp;&amp; a!&#x3D;EOF) { }</p><p>EOF：指检测文件尾，宏定义值为-1</p><h1 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h1><ol><li><p>if(…){}</p></li><li><p>if(…){} else{}</p></li><li><p>if(…){} else if(…){} … else{…}</p></li><li><p>switch(表达式){case 常量1:语句1;case 常量2:语句2;…;case 常量n:语句n;default:语句n+1}</p></li></ol><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><ol><li>while</li></ol><p>while (表达式) {<br>    语句<br>}</p><ol start="2"><li>do…while：至少会执行一次</li></ol><p>do<br>    语句<br>while (表达式);</p><ol start="3"><li>for</li></ol><p>for (表达式1,表达式2,表达式3)<br>    语句</p><ol start="4"><li>循环打断</li></ol><p>break 或 goto</p><ol start="5"><li>continue</li></ol><p>continue 不跳出循环，而是将程序执行跳转到末尾处</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>循环打印字符串</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    char str[] = &quot;Hello World!&quot;;</span><br><span class="line">    size_t len = sizeof(str)/sizeof(char);</span><br><span class="line">    printf(&quot;%zu\n&quot;,len);</span><br><span class="line">    for (int i = 0; i&lt;len; i++) &#123;</span><br><span class="line">        printf(&quot;%c\n&quot;,str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>判断字符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 声明</span><br><span class="line">void judge_char(char ch);</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    char ch;</span><br><span class="line">    printf(&quot;请输入一个字符：&quot;);</span><br><span class="line">    scanf(&quot;%c&quot;,&amp;ch);</span><br><span class="line">    judge_char(ch);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义</span><br><span class="line">void judge_char(char ch)&#123;</span><br><span class="line">    /*</span><br><span class="line">     getchar和putchar 专门用于字符的输入和输出</span><br><span class="line">     getchar()写法上要为 变量 = getchar();</span><br><span class="line">     putchar()写法上要为 putchar(变量)</span><br><span class="line">     getchar(&#x27;\n&#x27;)输出一个控制符</span><br><span class="line">     putchar(&#x27;字母/字符&#x27;);输出一个字母/字符</span><br><span class="line">     */</span><br><span class="line">//    ch = getchar();</span><br><span class="line">    if (ch &lt; 31) &#123;</span><br><span class="line">        printf(&quot;这是一个控制字符或通讯专用字符!\n&quot;);</span><br><span class="line">    &#125;else if (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">        printf(&quot;这是一个数字!&quot;);</span><br><span class="line">    &#125;else if (ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;) &#123;</span><br><span class="line">        printf(&quot;这是一个大写字母!\n&quot;);</span><br><span class="line">    &#125;else if (ch &gt;= &#x27;a&#x27; &amp;&amp; ch &lt;= &#x27;z&#x27;) &#123;</span><br><span class="line">        printf(&quot;这是一个小写字母!\n&quot;);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        printf(&quot;这是其他字符!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>任意输入3个整数，使用if语句对这3个语句从小到大升序排序。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 交换x,y</span><br><span class="line">void swap(int *x,int *y)&#123;</span><br><span class="line">    int temp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int a,b,c;</span><br><span class="line">    printf(&quot;请输入a,b,c:\n&quot;);</span><br><span class="line">    scanf(&quot;%d,%d,%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    </span><br><span class="line">    if (a&gt;b)&#123;</span><br><span class="line">        swap(&amp;a, &amp;b);</span><br><span class="line">    &#125;</span><br><span class="line">    if (a&gt;c)&#123;</span><br><span class="line">        swap(&amp;a, &amp;c);</span><br><span class="line">    &#125;</span><br><span class="line">    if (b&gt;c)&#123;</span><br><span class="line">        swap(&amp;b, &amp;c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;升序排序结果：\n&quot;);</span><br><span class="line">    printf(&quot;%d,%d,%d\n&quot;,a,b,c);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>九九乘法表</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line">    for (i = 1; i &lt;= 9; i++) &#123;</span><br><span class="line">        for (j = 1; j &lt;= 9; j++) &#123;</span><br><span class="line">            printf(&quot;%d*%d=%2d\t&quot;,i,j,i*j);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>使用goto语句模拟循环，求10以内整数之和。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    int sum = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    LOOP: if (++i &lt;= 10) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        goto LOOP;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;10以内的正整数之和为：%d\n&quot;,sum);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>while循环：最大公约数 和 最小公倍数</li></ol><p>公约数：几个自然数共有的约数，为他们的公约数<br>最大公约数：公约数中的最大一个</p><p>公倍数：能够被一个整数整除额整数成为其倍数<br>最小公倍数：两个或多个整数的公倍数最小的一个</p><p>问：使用while循环，求两个正整数的最大公约数和最小公倍数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    int a,b,m,c;</span><br><span class="line">    printf(&quot;请输入两个数：&quot;);</span><br><span class="line">    scanf(&quot;%d,%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    // 给两个整数排序</span><br><span class="line">    if (a&lt;b)&#123;</span><br><span class="line">        int temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    m = a*b;</span><br><span class="line">    c = a%b;</span><br><span class="line">    while (c != 0) &#123;</span><br><span class="line">        a = b; // 最大公约数</span><br><span class="line">        b = c;</span><br><span class="line">        c = a%b;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;最大公约数是：%d\n&quot;,b);</span><br><span class="line">    printf(&quot;最小公倍数是：%d\n&quot;,m/b);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习03：运算符和表达式</title>
      <link href="/BboyZJ.github.io/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A003%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/BboyZJ.github.io/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A003%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h1><ul><li>判断正整数的位数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 声明</span><br><span class="line">void IntCount(int num);</span><br><span class="line">// 入口函数</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // 判断正整数的位数</span><br><span class="line">    int num;</span><br><span class="line">    printf(&quot;请输入一个正整数：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line">    IntCount(12345);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 判断正整数的位数</span><br><span class="line">void IntCount(int num) &#123;</span><br><span class="line">    int count = 0; // 位数</span><br><span class="line">    while (num &gt; 0) &#123;</span><br><span class="line">        num = num/10;</span><br><span class="line">        count += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303071310152.png"></p><ul><li>打印100以内（包含100）能被10整除的正整数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // 打印100以内被10整除的正整数</span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i &lt; 100) &#123;</span><br><span class="line">        if (i % 10 == 0) &#123;</span><br><span class="line">            printf(&quot;%d\n&quot;,i);</span><br><span class="line">        &#125;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==========</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">30</span><br><span class="line">40</span><br><span class="line">50</span><br><span class="line">60</span><br><span class="line">70</span><br><span class="line">80</span><br><span class="line">90</span><br></pre></td></tr></table></figure><ul><li>输入两个闭区间，并判断两个区间是否重叠？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#define MAX(a,b) ((a&gt;b) ? a:b)</span><br><span class="line">#define MIN(a,b) ((a&lt;b) ? a:b)</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    int start_1,end_1;</span><br><span class="line">    int start_2,end_2;</span><br><span class="line">    printf(&quot;请输入第一个闭区间(逗号分割)：&quot;);</span><br><span class="line">    scanf(&quot;%d,%d&quot;,&amp;start_1,&amp;end_1);</span><br><span class="line">    printf(&quot;请输入第二个闭区间(逗号分割)：&quot;);</span><br><span class="line">    scanf(&quot;%d,%d&quot;,&amp;start_2,&amp;end_2);</span><br><span class="line">    </span><br><span class="line">    if (MIN(end_1, end_2) &lt; MAX(start_1, start_2)) &#123;</span><br><span class="line">        printf(&quot;不重叠&quot;);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        printf(&quot;重叠&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输入任意年份的正整数n，判断该年份是否为闰年？</li></ul><p>闰年的定义：能被400整除的年份为闰年；能被4整除同时不能被100整除的年份是闰年</p><p>闰年一年有366天，2月份有29天<br>平年一年有365天，2月份有28天</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 判断闰年</span><br><span class="line">void is_leap_year(int year)&#123;</span><br><span class="line">    if (year%400==0 || (year%4==0 &amp;&amp; year%100!=0)) &#123;</span><br><span class="line">        printf(&quot;%d年是闰年\n&quot;,year);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;%d年不是闰年\n&quot;,year);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // 判断闰年</span><br><span class="line">    int year;</span><br><span class="line">    printf(&quot;请输入年份：&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;year);</span><br><span class="line">    is_leap_year(year);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>打印邮费价格表，输出20kg以内物品的邮费价格表，邮费计算规则如下：<ul><li>1kg以内6元</li><li>超过1kg,每增加1kg加收2元</li></ul></li></ul><p>注：逗号运算符与表达式小知识<br>    1.逗号运算符的优先级是所有运算符中最低的<br>    2.整个逗号表达式的值为其中最后一个子表达式的值<br>    3.逗号运算符常用在for循环头部初始化或递增多个变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define FIRST_COST 6</span><br><span class="line">#define NEXT_COST 2</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int weight,cost;</span><br><span class="line">    printf(&quot;重量\t价格\t\n&quot;);</span><br><span class="line">    for (weight=1,cost=FIRST_COST;weight&lt;=10;++weight,cost=FIRST_COST+(weight-1)*NEXT_COST) &#123;</span><br><span class="line">        printf(&quot;%d\t￥%d\n&quot;,weight,cost);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输入三个整数，求出最大值并输出？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int a,b,c,max;</span><br><span class="line">    printf(&quot;请输入3个整数：&quot;);</span><br><span class="line">    scanf(&quot;%d,%d,%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    max = c&gt;((a&gt;b)?a:b) ? c:((a&gt;b)?a:b);</span><br><span class="line">    printf(&quot;3个数中的最大值是：%d\n&quot;,max);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义并初始化一个整型数组（未显示指定数组长度），循环输出数组中每个元素。在完成以上任务的过程中，为了得到数组的长度，需要借助sizeof运算符？</li></ul><p>小知识：<br>    1.sizeof在使用的时候看上去像是一个函数（因为后面有一对小括号），但他是一个运算符。它的使用方法有以下三种：<br>        a)sizeof(变量名)<br>        b)sizeof(数据类型名)<br>        c)sizeof 变量名<br>    2. sizeof的返回值类型是size_t</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int arr[]=&#123;1,2,3,4,5&#125;;</span><br><span class="line">    size_t len = sizeof(arr)/sizeof(arr[0]);</span><br><span class="line">    size_t i;</span><br><span class="line">    for (i=0; i&lt;len; ++i) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据运算符优先级及求职顺序，使程序输出结果为2，3，1</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">    printf(&quot;请输入2个整数：&quot;);</span><br><span class="line">    scanf(&quot;%d,%d&quot;,&amp;x,&amp;y);</span><br><span class="line">    z=x++,++y,y++;</span><br><span class="line">    printf(&quot;%d,%d,%d\n&quot;,x,y,z);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习02：变量的类型</title>
      <link href="/BboyZJ.github.io/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A002%EF%BC%9A%E5%8F%98%E9%87%8F/"/>
      <url>/BboyZJ.github.io/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A002%EF%BC%9A%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ol><li>什么是变量？</li></ol><p>变量表示 <code>内存中的一个存储区域（不同的数据类型，占用的空间大小不一样）</code></p><ol start="2"><li>为什么需要变量？</li></ol><p>答：变量是其程序的 <code>基本组成单位</code></p><h1 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h1><p><code>type variable_list;</code></p><ul><li>type：变量类型</li><li>variable_list：一个或多个标识符组成，多个用逗号分割</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i, j, k;</span><br></pre></td></tr></table></figure><h1 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h1><p>变量的声明有两种：</p><ul><li>一种是需要建立存储空间。</li></ul><p><code>int i;</code> &#x2F;&#x2F; 声明，也是定义</p><ul><li>另一种是不需要建立存储空间的，用 <code>extern关键字</code> 声明的。</li></ul><p><code>extern int i;</code> &#x2F;&#x2F; 声明，不是定义</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习01：C语言概述</title>
      <link href="/BboyZJ.github.io/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A001%EF%BC%9AC%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/"/>
      <url>/BboyZJ.github.io/2023/02/13/C%E5%AD%A6%E4%B9%A0/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A001%EF%BC%9AC%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言特点"><a href="#C语言特点" class="headerlink" title="C语言特点"></a>C语言特点</h1><p><code>C</code> 语言是一门过程性语言，<code>C</code> 语言可以 <code>代替机器语言或汇编语言编写运行速度快的程序</code>。</p><ul><li>语言简洁，使用方便灵活</li><li>可移植性好</li><li>表达能力强</li><li>表达方式灵活</li><li>可进行结构化程序设计</li><li>可以直接操作计算机硬件</li><li>生成的目标代码质量高</li></ul><h1 id="编程机制"><a href="#编程机制" class="headerlink" title="编程机制"></a>编程机制</h1><p><code>C</code> 语言程序从源代码到二进制程序都经历了哪些过程？</p><ul><li>预处理(Preprocession)</li></ul><p>预处理用于将所有的 <code>#include头文件及宏定义</code> 替换成 <code>真正的内容</code><br><code>test.c</code> 到 <code>test.i</code></p><ul><li>编译(Complication)</li></ul><p>编译过程将 <code>预处理之后的程序</code> 转换成特定的 <code>汇编代码(Assemble Code)</code><br><code>test.i</code> 到 <code>test.s</code></p><ul><li>汇编(Assemble)</li></ul><p>汇编过程将 <code>汇编代码</code> 转换成 <code>机器码(machine code)</code>，这一步产生的文件叫 <code>目标文件</code>，每一个 <code>源文件</code> 都会产生一个 <code>目标文件</code><br><code>test.s</code> 到 <code>test.o</code></p><ul><li>链接(Linking)</li></ul><p>链接过程将 <code>多个目标文件及所需的库文件</code> 链接成最终的 <code>可执行文件(executable file)</code></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C面试题：C</title>
      <link href="/BboyZJ.github.io/2023/02/12/%E9%9D%A2%E8%AF%95%E9%A2%98/C%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%97%E6%B3%95/"/>
      <url>/BboyZJ.github.io/2023/02/12/%E9%9D%A2%E8%AF%95%E9%A2%98/C%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="输出一个非负整数的位数"><a href="#输出一个非负整数的位数" class="headerlink" title="输出一个非负整数的位数"></a>输出一个非负整数的位数</h1><p>例如：<br>1<del>9 &#x2F; 10 &#x3D; 0<br>10</del>99 &#x2F; 10 &#x3D; 1~9<br>….</p><p>除以10其实就是将最后一位数去掉</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 传入一个非负整数，返回其位数</span><br><span class="line">int numLen(unsigned int num) &#123;</span><br><span class="line">    int len = 0;</span><br><span class="line">    while (num &gt; 0) &#123;</span><br><span class="line">        num = num / 10;;</span><br><span class="line">        len += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return  len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int num = 12345;</span><br><span class="line">    int len = numLen(num);</span><br><span class="line">    printf(&quot;%d 是个 %d 位数\n&quot;,num,len);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">====</span><br><span class="line">12345 是个 5 位数</span><br></pre></td></tr></table></figure></div><h1 id="非负整数的各个数相加"><a href="#非负整数的各个数相加" class="headerlink" title="非负整数的各个数相加"></a>非负整数的各个数相加</h1><p>示例：<br>输入：num &#x3D; 5<br>输出：5<br>输入：12345<br>输出：15</p><p>思路：num &#x2F; 10 可以去掉最后一位，num % 10 可以得到最后一位的 数</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 正整数的长度</span><br><span class="line">int numLen(int num) &#123;</span><br><span class="line">    int len = 0;</span><br><span class="line">    while (num &gt; 0) &#123;</span><br><span class="line">        num = num / 10;</span><br><span class="line">        len += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 求各个位数之和</span><br><span class="line">int sumNum(int num) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    // 如果大于10</span><br><span class="line">    if (num &gt; 10) &#123;</span><br><span class="line">        int len = numLen(num);</span><br><span class="line">        // 先加上最后一位</span><br><span class="line">        sum += num % 10;</span><br><span class="line">        for (int i = 0; i &lt; len - 1; i ++) &#123;</span><br><span class="line">            // 去掉最后一位</span><br><span class="line">            num = num / 10;</span><br><span class="line">            // 得到最后一位的数并累加</span><br><span class="line">            sum += num % 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    int num = 5;</span><br><span class="line">    int sum = sumNum(num);</span><br><span class="line">    printf(&quot;%d 各个数之和为：%d\n&quot;,num,sum);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">125 各个数之和为：8</span><br></pre></td></tr></table></figure></div><h1 id="给定一个非负整数num，反复将各个位上的数宇相加。直到结果为一位数。返回这个结果。"><a href="#给定一个非负整数num，反复将各个位上的数宇相加。直到结果为一位数。返回这个结果。" class="headerlink" title="给定一个非负整数num，反复将各个位上的数宇相加。直到结果为一位数。返回这个结果。"></a>给定一个非负整数num，反复将各个位上的数宇相加。直到结果为一位数。返回这个结果。</h1><p>示例 1:<br>输入：num &#x3D; 38<br>输出：11<br>解释：各位相加的过程为：•<br>38–&gt; 3 + 8 –&gt;11<br>11–&gt;1+1–&gt;2.<br>由于 <code>2</code> 是一位数，所以返回 <code>2</code>。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="斐波那契额数列：兔子数列"><a href="#斐波那契额数列：兔子数列" class="headerlink" title="斐波那契额数列：兔子数列"></a>斐波那契额数列：兔子数列</h1><p>当前数是前两个数之和:</p><p>打印出这样的数字：0 1 1 2 3 5 8 13 …</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 递归求和</span><br><span class="line">int fibonaci(int i) &#123;</span><br><span class="line">    if (i == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return fibonaci(i - 1) + fibonaci(i - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // 斐波那契额数列</span><br><span class="line">    for (int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">        printf(&quot;%d\t\n&quot;,fibonaci(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=======</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br><span class="line">....</span><br></pre></td></tr></table></figure></div><h1 id="求-n-的阶乘"><a href="#求-n-的阶乘" class="headerlink" title="求 n 的阶乘"></a>求 n 的阶乘</h1><p>问：求 1x2x3x4x…n ?</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 求 n! 传入一个无符号整型</span><br><span class="line">double factorial(unsigned int i)&#123;</span><br><span class="line">    if (i&lt;=1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return i * factorial(i-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int i = 5;</span><br><span class="line">    printf(&quot;%d 的阶乘是：%f\n&quot;,i,factorial(i));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=====</span><br><span class="line">5 的阶乘是：120.000000</span><br></pre></td></tr></table></figure></div><h1 id="汽水瓶"><a href="#汽水瓶" class="headerlink" title="汽水瓶"></a>汽水瓶</h1><p>某商店规定：三个空汽水瓶可以换一瓶汽水，允许向老板借空汽水瓶（但是必须要归还）。<br>小张手上有n个空汽水瓶，她想知道自己最多可以喝到多少瓶汽水。<br>数据范围：输入的正整数满足<br>1 ≤ n ≤ 100</p><p>注意：本题存在多组输入。输入的 0 表示输入结束，并不用输出结果。</p><p><strong>示例1：</strong><br>输入例子：<br>3<br>10<br>81<br>0<br>输出例子：<br>1<br>5<br>40<br>例子说明：<br>样例 1 解释：用三个空瓶换一瓶汽水，剩一个空瓶无法继续交换<br>样例 2 解释：用九个空瓶换三瓶汽水，剩四个空瓶再用三个空瓶换一瓶汽水，剩两个空瓶，向老板借一个空瓶再用三个空瓶换一瓶汽水喝完得一个空瓶还给老板</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">    // 定义空气水平为num，最多可喝到ret</span><br><span class="line">    int num,ret;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;num) != EOF) &#123; // 汽水瓶可以是0，这里跳出循环</span><br><span class="line">        // 初始值</span><br><span class="line">        ret = 0;</span><br><span class="line">        if (num &gt; 0) &#123;</span><br><span class="line">            // 如果空瓶 &gt;= 3 那么一直可置换</span><br><span class="line">            while (num &gt;= 3) &#123;</span><br><span class="line">                // 汽水 = 汽水 + 空瓶3个换一瓶汽水</span><br><span class="line">                ret = ret + num/3;</span><br><span class="line">                // 空瓶3个换1个空瓶 + 剩余未置换的空瓶</span><br><span class="line">                num = num/3 + num%3;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果还剩2个空瓶，则还能置换一瓶汽水</span><br><span class="line">            if (num == 2) &#123;</span><br><span class="line">                ret ++;</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%d&quot;,ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [pool drain];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="明明的随机数"><a href="#明明的随机数" class="headerlink" title="明明的随机数"></a>明明的随机数</h1><p>明明生成了N个1到500之间的随机整数。请你删去其中重复的数字，即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数从小到大排序，按照排好的顺序输出。<br>数据范围： 1≤n≤1000  ，输入的数字大小满足 1≤val≤500 </p><p>输入描述：<br>第一行先输入随机整数的个数 N 。<br>接下来的 N 行每行输入一个整数，代表明明生成的随机数。<br>具体格式可以参考下面的”示例”。</p><p>示例1：<br>输入例子：<br>3<br>2<br>2<br>1<br>输出例子：<br>1<br>2<br>例子说明：输入解释：<br>第一个数字是3，也即这个小样例的N&#x3D;3，说明用计算机生成了3个1到500之间的随机整数，接下来每行一个随机数字，共3行，也即这3个随机数字为：<br>2<br>2<br>1<br>所以样例的输出为：<br>1<br>2 </p><p><strong>c 语言实现：</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">    int n; // 个数</span><br><span class="line">    int arr[1001]; // 数组</span><br><span class="line">    int j,k;    //定义循环因子，嵌套双层循环</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123;</span><br><span class="line">        // 生成随机数并添加到数组中</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            int r = rand()%1000;</span><br><span class="line">            arr[i] = r;</span><br><span class="line">        &#125;</span><br><span class="line">        // 冒泡排序</span><br><span class="line">        for(j=0; j&lt;n-1; j++)    //设置循环后界</span><br><span class="line">        &#123;</span><br><span class="line">            for(k=0; k&lt;n-j-1; k++)    //不断向后进行比较</span><br><span class="line">            &#123;</span><br><span class="line">                if(arr[k]&gt;arr[k+1])    //比较相邻的元素</span><br><span class="line">                &#123;</span><br><span class="line">                    int temp=arr[k];    //三杯水交换法</span><br><span class="line">                    arr[k]=arr[k+1];</span><br><span class="line">                    arr[k+1]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* 输出数组中每个元素的值 */</span><br><span class="line">        for (int m = 0; m &lt; n; m++ )&#123;</span><br><span class="line">        printf(&quot;Element[%d] = %d\n&quot;, m, arr[m] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [pool drain];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><p>16进制转10进制</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">    char a[] = &quot;1c&quot;;</span><br><span class="line">    func(a);</span><br><span class="line">    printf(&quot;%d\n&quot;,func(a));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int func(char a[])&#123;</span><br><span class="line">    // 长度</span><br><span class="line">    long len = strlen(a);</span><br><span class="line">    int i,j,num=0;</span><br><span class="line">    for (i = 0; i &lt; len; i ++) &#123;</span><br><span class="line">        if (a[i] == &#x27;A&#x27;)</span><br><span class="line">            num += 10 * pow(16, len - i - 1); //pow() 函数用来求 x 的 y 次方的值。</span><br><span class="line">        else if (a[i] == &#x27;B&#x27;)</span><br><span class="line">            num += 11 * pow(16, len - i - 1);</span><br><span class="line">        else if (a[i] == &#x27;C&#x27;)</span><br><span class="line">            num += 12 * pow(16, len - i - 1);</span><br><span class="line">        else if (a[i]==&#x27;D&#x27;)</span><br><span class="line">            num += 13 * pow(16, len - i - 1);</span><br><span class="line">        else if (a[i] == &#x27;E&#x27;)</span><br><span class="line">            num += 14 * pow(16, len - i - 1);</span><br><span class="line">        else</span><br><span class="line">            num += 15 * pow(16, len - i - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C-面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：Kingfisher使用</title>
      <link href="/BboyZJ.github.io/2023/02/09/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9AKingfisher%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/09/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9AKingfisher%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Kingfisher</code> 是一个 <code>下载、缓存</code> 网络图片的轻量级纯swift库，在swift中是一个SDWebImage的升级版</p><h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><ul><li>异步下载和缓存图片</li><li>提供图片处理器和过滤器</li><li>内存和磁盘的多层缓存</li><li>扩展UIImageView&#x2F;UIButton来设置图片，内置过渡动画</li></ul><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><ol><li>直接设置一张url图片</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if let url = URL(string: &quot;http://mvimg2.meitudata.com/55fe3d94efbc12843.jpg&quot;) &#123;</span><br><span class="line">    imgView.kf.setImage(with: url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：kingfisher 首先尝试从缓存中去取，如果没有，直接下载图片并且缓存下来备用；此外，<code>kingfisher</code> 默认使用 <code>url</code> 作为 <code>cacheKey</code> 以方便再次加载该图片时去缓存中根据 <code>cacheKey</code> 查找</p><ol start="2"><li>指定给一个 cacheKey 缓存图片</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let imageResource = ImageResource(downloadURL: url, cacheKey: &quot;Custom_cache_key&quot;)</span><br><span class="line">imageView.kf.setImage(with: imageResource)</span><br></pre></td></tr></table></figure><ol start="3"><li>设置占位图片</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if let url = URL(string: &quot;http://mvimg2.meitudata.com/55fe3d94efbc12843.jpg&quot;) &#123;</span><br><span class="line">    imageView.kf.setImage(with: url, placeholder: placeholder_image, options: nil, progressBlock: nil, completionHandler: nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>下载完成回调</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if let url = URL(string: &quot;http://mvimg2.meitudata.com/55fe3d94efbc12843.jpg&quot;) &#123;</span><br><span class="line">    imageView.kf.setImage(with: url, placeholder: nil, options: nil, progressBlock: nil, completionHandler: &#123; (image, error, cacheType, imageUrl) in</span><br><span class="line"></span><br><span class="line">        image       // 为 nil 时，表示下载失败</span><br><span class="line"></span><br><span class="line">        error       // 为 nil 时，表示下载成功， 非 nil 时，就是下载失败的错误信息</span><br><span class="line"></span><br><span class="line">        cacheType   // 缓存类型，是个枚举，分以下三种：</span><br><span class="line">                    // .none    图片还没缓存（也就是第一次加载图片的时候）</span><br><span class="line">                    // .memory  从内存中获取到的缓存图片（第二次及以上加载）</span><br><span class="line">                    // .disk    从磁盘中获取到的缓存图片（第二次及以上加载）</span><br><span class="line"></span><br><span class="line">        imageUrl    // 所要下载的图片的url</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>加载菊花</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum IndicatorType &#123;</span><br><span class="line">    /// 默认没有菊花</span><br><span class="line">    case none</span><br><span class="line">    /// 使用系统菊花</span><br><span class="line">    case activity</span><br><span class="line">    /// 使用一张图片作为菊花，支持gif图</span><br><span class="line">    case image(imageData: Data)</span><br><span class="line">    /// 使用自定义菊花，要遵循Indicator协议</span><br><span class="line">    case custom(indicator: Indicator)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用系统菊花</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imageView.kf.indicatorType = .activity</span><br><span class="line">imageView.kf.setImage(with: url)</span><br></pre></td></tr></table></figure><ul><li>使用gif图作为加载菊花</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let path = Bundle.main.path(forResource: &quot;myImage&quot;, ofType: &quot;gif&quot;)!</span><br><span class="line">let data = try! Data(contentsOf: URL(fileURLWithPath: path))</span><br><span class="line">imageView.kf.indicatorType = .image(imageData: data)</span><br><span class="line">imageView.kf.setImage(with: url)</span><br></pre></td></tr></table></figure><ul><li>自定义菊花，遵循 Indicator协议</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let myIndicator = CustomIndicator()</span><br><span class="line">imageView.kf.indicatorType = .custom(indicator: myIndicator)</span><br><span class="line">imageView.kf.setImage(with: url)</span><br><span class="line"></span><br><span class="line">struct CustomIndicator: Indicator &#123;</span><br><span class="line"></span><br><span class="line">    var view: IndicatorView = UIView()</span><br><span class="line"></span><br><span class="line">    func startAnimatingView() &#123;</span><br><span class="line">        view.isHidden = false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func stopAnimatingView() &#123;</span><br><span class="line">        view.isHidden = true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init() &#123;</span><br><span class="line">        view.backgroundColor = UIColor.magenta</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>根据实时下载图片的数据做进度条加载或者菊花加载（灵活，比例为：图片已下载数据 &#x2F; 图片总数据）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">imageView.kf.setImage(with: url, placeholder: nil, options: nil, progressBlock: &#123; (receivedData, totolData) in</span><br><span class="line"></span><br><span class="line">    let percentage = (Float(receivedData) / Float(totolData)) * 100.0</span><br><span class="line"></span><br><span class="line">    print(&quot;downloading progress is: \(percentage)%&quot;)</span><br><span class="line"></span><br><span class="line">    // 这里用进度条或者绘制view都可以，然后根据 percentage% 表示进度就行了</span><br><span class="line"></span><br><span class="line">&#125;, completionHandler: nil)</span><br></pre></td></tr></table></figure><p>…</p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC性能优化08：启动优化</title>
      <link href="/BboyZJ.github.io/2023/02/08/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9608%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
      <url>/BboyZJ.github.io/2023/02/08/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9608%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OC-性能优化探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC性能优化07：耗电优化</title>
      <link href="/BboyZJ.github.io/2023/02/08/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9607%EF%BC%9A%E8%80%97%E7%94%B5%E4%BC%98%E5%8C%96/"/>
      <url>/BboyZJ.github.io/2023/02/08/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9607%EF%BC%9A%E8%80%97%E7%94%B5%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="耗电的主要来源"><a href="#耗电的主要来源" class="headerlink" title="耗电的主要来源"></a>耗电的主要来源</h1><ul><li>cpu处理</li><li>网络</li><li>定位</li><li>图像</li></ul><h1 id="耗电解决方案"><a href="#耗电解决方案" class="headerlink" title="耗电解决方案"></a>耗电解决方案</h1><ol><li>cpu层面的优化</li></ol><ul><li><p>尽量降低CPU、GPU功耗</p></li><li><p>少使用定时器</p></li><li><p>优化I&#x2F;O操作</p><ul><li>写入数据最好一次性写入</li><li>读取数据最好使用GCD异步操作</li><li>数据流比较大，建议使用数据库</li></ul></li></ul><ol start="2"><li><p>网络请求层面的优化</p><ul><li>减少、压缩网络数据</li><li>如果多次请求的结果是相同的，尽量使用缓存</li><li>使用断点续传，否则网络不稳定时可能多次传输相同的内容</li><li>网络不可用时，不要尝试执行网络请求</li><li>让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间</li><li>批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载</li></ul></li><li><p>定位层面优化</p></li></ol><ul><li>如果只是需要快速确定用户位置，最好用CLLocationManager的requestLocation方法。定位完成后，会自动让定位硬件断电</li><li>如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务</li><li>尽量降低定位精度，比如尽量不要使用精度最高的kCLLocationAccuracyBest</li><li>需要后台定位时，尽量设置pausesLocationUpdatesAutomatically为YES，如果用户不太可能移动的时候系统会自动暂停位置更新</li><li>尽量不要使用startMonitoringSignificantLocationChanges，优先考虑startMonitoringForRegion:</li></ul><ol start="4"><li>硬件检测优化(不常用)</li></ol><ul><li>用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件</li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-性能优化探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC性能优化06：Leaks内存泄漏探索</title>
      <link href="/BboyZJ.github.io/2023/02/08/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606%EF%BC%9ALeaks%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2023/02/08/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606%EF%BC%9ALeaks%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <code>XCode</code> 中，提供两种工具帮助查找泄漏点</p><h1 id="Analyze-静态分析工具"><a href="#Analyze-静态分析工具" class="headerlink" title="Analyze 静态分析工具"></a>Analyze 静态分析工具</h1><ul><li>通过 <code>Product -&gt; Analyze</code>，快捷键 <code>CMD + Shift + b</code>:</li></ul><ol><li>逻辑错误：访问空指针或未初始化的变量等</li><li>内存管理错误：如内存泄漏等</li><li>声明错误：从未使用过的变量</li><li>API调用错误：未包含使用的库和框架</li></ol><h1 id="Instruments-动态分析工具"><a href="#Instruments-动态分析工具" class="headerlink" title="Instruments 动态分析工具"></a>Instruments 动态分析工具</h1><ol><li><code>CMD + i</code> 打开</li></ol><p><img src="/BboyZJ.github.io/assets/16758464140338.jpg"></p><ol start="2"><li>打开界面的介绍</li></ol><p><img src="/BboyZJ.github.io/assets/16758463594933.png"></p><p>在 <code>instruments</code> 中，选择了 <code>Leaks</code> 模板，默认情况下也会添加 <code>Allocations</code> 模板，基本上凡是内存分析都会使用 <code>Allocations</code> 模板，它可以 <code>监控内存分布情况</code>：</p><ul><li><p>选中 <code>Allocations</code> 模板即图1区域，3区域会显示随着时间变化内存使用的折线图，图4显示内存使用的详细信息以及对象分配情况</p></li><li><p>选中 <code>Leask</code> 模板即图2区域，可以查看内存泄漏情况，如果 3区域有 <code>红X</code> 出现，则 <code>内存泄漏</code>，4区域显示内存泄漏的对象</p></li></ul><ol start="3"><li>打开 <code>leaks</code> 进行监测</li></ol><p>点击泄漏对象可以看到他们的内存地址，占用字节，所属框架和响应方法等信息，打开扩展视图，可以看到右边的跟踪堆栈信息</p><p><img src="/BboyZJ.github.io/assets/16758464822723.png"></p><ol start="4"><li>监测结果分析</li></ol><p><img src="/BboyZJ.github.io/assets/16758467369185.png"></p><ol start="5"><li>Allocations 内存分布版面介绍</li></ol><p><img src="/BboyZJ.github.io/assets/16758469054226.png"></p><p><img src="/BboyZJ.github.io/assets/16758469444738.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> OC-性能优化探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：判断是否是Debug环境</title>
      <link href="/BboyZJ.github.io/2023/02/07/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AFDebug%E7%8E%AF%E5%A2%83/"/>
      <url>/BboyZJ.github.io/2023/02/07/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AFDebug%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="build-setting-配置"><a href="#build-setting-配置" class="headerlink" title="build setting 配置"></a>build setting 配置</h1><p>target -&gt; builf setting -&gt; swift flags -&gt; other swift flags 下 点击 <code>debug</code> 添加 <code>-D DEBUG</code>，注意 <code>release</code> 下不添加</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090608956.png"></p><h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if DEFBU</span><br><span class="line">    // debug</span><br><span class="line">#else</span><br><span class="line">    // release</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：RxSwift使用</title>
      <link href="/BboyZJ.github.io/2023/02/07/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9ARxSwift%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/07/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9ARxSwift%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>OC</code> 响应式编程一般使用 <code>ReactiveCocoa</code>，而 <code>Swift</code> 响应式编程一般使用 <code>RxSwift</code>，<br><code>RxSwift</code> 本质是 <code>观察者模式</code>，目的是让 <code>数据/事件流和异步任务</code> 能够更方便的序列化处理。</p><h1 id="RxSwift-引入"><a href="#RxSwift-引入" class="headerlink" title="RxSwift 引入"></a>RxSwift 引入</h1><p>Podfile文件中添加如下，并 <code>pod update</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 响应式编程库</span><br><span class="line">pod &#x27;RxSwift&#x27;</span><br><span class="line">pod &#x27;RxCocoa&#x27;</span><br></pre></td></tr></table></figure><h1 id="RxSwift-使用"><a href="#RxSwift-使用" class="headerlink" title="RxSwift 使用"></a>RxSwift 使用</h1><ol><li>Target Action</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lazy var bag: DisposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">btn.rx.tap.subscribe &#123; event in</span><br><span class="line">    print(&quot;点击按钮&quot;)</span><br><span class="line">&#125;.disposed(by: bag);</span><br></pre></td></tr></table></figure><ol start="2"><li>监听输入框文字变化</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lazy var bag: DisposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">tf.rx.text.subscribe(onNext: &#123;string in</span><br><span class="line">    print(&quot;输入变化：\(string!)&quot;);</span><br><span class="line">&#125;).disposed(by: bag)</span><br></pre></td></tr></table></figure><ol start="3"><li>输入框文字绑定到label上</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lazy var bag: DisposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">tf.rx.text.bind(to:label.rx.text).disposed(by: bag)</span><br></pre></td></tr></table></figure><ol start="4"><li>通知</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lazy var bag: DisposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">NotificationCenter.default.rx.notification(.NSExtensionHostWillEnterForeground).subscribe(onNext: &#123; notification in</span><br><span class="line">    print(&quot;Application will enter foreground&quot;);</span><br><span class="line">&#125;).disposed(by: bag)</span><br></pre></td></tr></table></figure><ol start="5"><li>监听属性改变</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">label.rx.observe(String.self, &quot;text&quot;).subscribe &#123; event in</span><br><span class="line">   print(&quot;文本改变：\(event.element!!)&quot;)</span><br><span class="line">&#125;.disposed(by: bag)</span><br><span class="line"></span><br><span class="line">label.rx.observe(CGRect.self, &quot;frame&quot;).subscribe &#123; event in</span><br><span class="line">    print(&quot;frame改变：\(event.element!!)&quot;)</span><br><span class="line">&#125;.disposed(by: bag)</span><br></pre></td></tr></table></figure><ol start="6"><li>监听滚动偏移</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrollView.rx.contentOffset.subscribe &#123; point in</span><br><span class="line">  print(&quot;滚动偏移：\(point.element!)&quot;)</span><br><span class="line">&#125;.disposed(by: bag)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：swift中typealias使用</title>
      <link href="/BboyZJ.github.io/2023/02/05/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%ADtypealias%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/05/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%ADtypealias%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>typealias：类型别名</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>第一种方式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 定义闭包</span><br><span class="line">typealias SuccessCallBack = (_ code:String,_ message:String) -&gt; void</span><br><span class="line"></span><br><span class="line">// 声明闭包</span><br><span class="line">var customCallBack : SuccessCallBack?</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">if let call = customCallBack &#123;</span><br><span class="line">    call(&quot;你是谁&quot;,&quot;你管我是谁&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二种方式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 定义闭包</span><br><span class="line">var callBack:((_ code:String,_ message:String) -&gt; Void)?</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">if let call = callBack &#123;</span><br><span class="line">    call(&quot;我是谁&quot;,&quot;我也不知道我是谁&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：HandyJSON的使用</title>
      <link href="/BboyZJ.github.io/2023/02/04/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9AHandyJSON%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/04/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9AHandyJSON%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>HandyJSON</code> 是阿里巴巴开源的一个用于Swift语言中的 <code>JSON序列化/反序列化库</code>，可以很方便进行 <code>json和model</code> 的转换，以及常用的 <code>字典和模型</code> 的互相转换</p><h1 id="JSON转Model"><a href="#JSON转Model" class="headerlink" title="JSON转Model"></a>JSON转Model</h1><p>只需要在定义时，实现HandyJSON协议，这个协议只要求实现一个空的init()函数</p><ul><li>定义 <code>BaseModel</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import HandyJSON</span><br><span class="line"></span><br><span class="line">class BaseModel: HandyJSON &#123;</span><br><span class="line">    // 返回的数据</span><br><span class="line">    var data : Any?</span><br><span class="line">    // 业务码</span><br><span class="line">    var code : Int?</span><br><span class="line">    // 提示信息</span><br><span class="line">    var msg : String?</span><br><span class="line">    required init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>转换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if let baseModel = BaseModel.deserialize(from:jsonString)&#123;</span><br><span class="line">    print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="model-转-json"><a href="#model-转-json" class="headerlink" title="model 转 json"></a>model 转 json</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSONSerializer.serializeToJson(object:xxx)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：swift中extension使用</title>
      <link href="/BboyZJ.github.io/2023/02/04/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%ADextension%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/04/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%ADextension%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>swift</code> 中的 <code>扩展Extension</code>，类似 <code>OC</code> 中的 <code>分类Category</code></p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul><li><p>扩展可以为 枚举、结构体、类、协议 添加新功能</p><p>  添加方法、计算属性、下标、初始化器、嵌套类型、协议等</p></li></ul><h1 id="扩展不能办到的事"><a href="#扩展不能办到的事" class="headerlink" title="扩展不能办到的事"></a>扩展不能办到的事</h1><ul><li><p>不能覆盖原有的功能</p><p>  OC是允许覆盖的，但swift是安全的，是不允许覆盖的</p></li><li><p>不能添加存储属性</p><p>  因为属性会改变内存结构，但扩展是不允许改变原有的内存结构</p></li><li><p>不能向已有的属性添加属性观察值</p></li><li><p>不能添加父类</p><p>  不能扩展后面书写冒号继承父类（Extension Car:Person），因为继承有可能改变原有类的结构</p></li><li><p>不能添加指定初始化器，不能添加反初始化器</p></li><li><p>required初始化器不能在扩展中，只能在原有类中</p></li></ul><h1 id="实用"><a href="#实用" class="headerlink" title="实用"></a>实用</h1><ul><li>扩展方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">extension ViewController &#123;</span><br><span class="line">    // MARK：- 实例方法</span><br><span class="line">    // 声明无参数无返回值的实例方法</span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // MARK：类方法</span><br><span class="line">    // 声明私有类方法</span><br><span class="line">    private class func eat() &#123;</span><br><span class="line">        print(&quot;eat&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // MARK：静态方法（属于特殊的类方法）</span><br><span class="line">    static func speak() &#123;</span><br><span class="line">        print(&quot;speak&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>扩展协议</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension ViewController: UITableViewDataSource， UITableViewDelegate &#123;</span><br><span class="line">    func tableView(_ tableView: UITableView， numberOfRowsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">        return 5</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func tableView(_ tableView: UITableView， cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line">        return UITableViewCell()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：swift中方法的声明</title>
      <link href="/BboyZJ.github.io/2023/02/04/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E5%A3%B0%E6%98%8E/"/>
      <url>/BboyZJ.github.io/2023/02/04/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// MARK：实例方法</span><br><span class="line">// 声明无参数无返回值的实例方法</span><br><span class="line">func run() &#123;</span><br><span class="line">    print(&quot;run&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 声明带参的实例方法，其中：dest 被称为参数标签，可以使用 “_” 代替</span><br><span class="line">func run(dest distance: Int) &#123;</span><br><span class="line">    print(distance);</span><br><span class="line">&#125;</span><br><span class="line">// 声明带多个参数的实例方法</span><br><span class="line">func run(dest distance: Int,sour position:Int) &#123;</span><br><span class="line">    print(distance+position);</span><br><span class="line">&#125;</span><br><span class="line">// 声明带参数有返回值的实例方法</span><br><span class="line">func run(dest distance: Int) -&gt; Bool &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">// 声明带参数有多个返回值的实例方法</span><br><span class="line">func run(dest distance: Int) -&gt; (Bool,Int) &#123;</span><br><span class="line">    return (true,10);</span><br><span class="line">&#125;</span><br><span class="line">// 声明私有实例方法，其中 private 可更换其他访问权限的关键字</span><br><span class="line">private func cry(content value:String)&#123;</span><br><span class="line">    print(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 声明类方法</span><br><span class="line">class func walk()&#123;</span><br><span class="line">    print(&quot;walk&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 声明私有类方法</span><br><span class="line">private class func eat() &#123;</span><br><span class="line">    print(&quot;eat&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// MARK：静态方法（属于特殊的类方法）</span><br><span class="line">static func speak() &#123;</span><br><span class="line">    print(&quot;speak&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 私有静态方法</span><br><span class="line">private static func see() &#123;</span><br><span class="line">    print(&quot;see&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注：实例方法由实例对象调用；类方法和静态方法用类对象调用</strong></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：swift中guard语句</title>
      <link href="/BboyZJ.github.io/2023/02/03/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%ADguard%E8%AF%AD%E5%8F%A5/"/>
      <url>/BboyZJ.github.io/2023/02/03/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%ADguard%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">guard 条件 else &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当 <code>guard</code> 语句条件为 <code>false</code> 时，执行大括号里面的代码</li><li>当 <code>guard</code> 语句条件为 <code>true</code> 时，跳过guard语句</li></ul><h1 id="列子"><a href="#列子" class="headerlink" title="列子"></a>列子</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func login(_ info:[String:String])&#123;</span><br><span class="line">    guard let username = info[&quot;username&quot;] else &#123;</span><br><span class="line">        print(&quot;请输入用户名&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    guard let password = info[&quot;password&quot;] else &#123;</span><br><span class="line">        print(&quot;请输入密码&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;用户名：\(username)&quot;,&quot;密码：\(password)&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习08：swift中@available和#available</title>
      <link href="/BboyZJ.github.io/2023/02/03/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD@available%E5%92%8C#available/"/>
      <url>/BboyZJ.github.io/2023/02/03/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD@available%E5%92%8C#available/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于 <code>函数、类、协议等</code>，可以使用 <code>@available</code> 声明这些类型的声明周期依赖于特定的平台和操作系统版本。而 <code>#available</code> 用在判断语句中，在不同平台上做不同的逻辑</p><h1 id="available"><a href="#available" class="headerlink" title="@available"></a>@available</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@available(iOS 9,*)</span><br><span class="line">func myMethod()&#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>iOS 9 : 表示在 <code>iOS 9</code> 版本以上才可用</li><li>星号 * : 表示包含了所有平台</li></ul><h1 id="availble"><a href="#availble" class="headerlink" title="#availble"></a>#availble</h1><p>#availble 用于条件语句代码块中，判断不同的平台下，做不通的逻辑处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if #availble(iOS 9,*) &#123;</span><br><span class="line">    // iOS 9 及以上系统运行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">guard #availble(iOS 9,*) else &#123;</span><br><span class="line">    // iOS 9 以下系统运行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> swift-学习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：swift中as、as！、as？号的使用</title>
      <link href="/BboyZJ.github.io/2023/02/03/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%ADas%E3%80%81as%EF%BC%81%E3%80%81as%EF%BC%9F%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/03/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%ADas%E3%80%81as%EF%BC%81%E3%80%81as%EF%BC%9F%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="关于-as"><a href="#关于-as" class="headerlink" title="关于 as"></a>关于 as</h1><ul><li>将子类转换为基类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Auto &#123;&#125;</span><br><span class="line">class Car : Auto &#123;&#125;</span><br><span class="line">let car = Car()</span><br><span class="line">let truck = car as Auto</span><br></pre></td></tr></table></figure><ul><li>数值类型的转换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let n1 = 56 as Int</span><br></pre></td></tr></table></figure><ul><li>模式匹配</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">swich Auto &#123;</span><br><span class="line">    case let car as Car:</span><br><span class="line">        print(&quot;这里是Car类型对象&quot;);</span><br><span class="line">    case let truck as Truck:</span><br><span class="line">        print(&quot;这里是Truck类型对象&quot;);</span><br><span class="line">    default: break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="as"><a href="#as" class="headerlink" title="as!"></a>as!</h1><p>向下强制类型转换，如果转换失败会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Auto &#123;&#125;</span><br><span class="line">class Car: Auto &#123;&#125;</span><br><span class="line">let auto: Auto = Car()</span><br><span class="line">let car = auto as! Car</span><br></pre></td></tr></table></figure><h1 id="as-1"><a href="#as-1" class="headerlink" title="as?"></a>as?</h1><p>向下强制类型转换，如果转换失败会返回nil</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let auto: Auto = Car()</span><br><span class="line">if let car = auto as? Car &#123;</span><br><span class="line">   print(&quot;这是Car&quot;)</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  print(&quot;这不是Car&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：swift中？、！、？？号的使用</title>
      <link href="/BboyZJ.github.io/2023/02/03/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%EF%BC%9F%E3%80%81%EF%BC%81%E3%80%81%EF%BC%9F%EF%BC%9F%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2023/02/03/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%EF%BC%9F%E3%80%81%EF%BC%81%E3%80%81%EF%BC%9F%EF%BC%9F%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>swift 中 <code>?</code> 是 <code>可选</code> 的意思，<code>!</code> 是 <code>强制解包</code> 的意思，<code>??</code> 是用于判断 <code>变量/常量</code> 数值是否为 <code>nil</code></p><h1 id="？号的使用"><a href="#？号的使用" class="headerlink" title="？号的使用"></a>？号的使用</h1><p>声明一个 <code>Optional</code> 变量或常量时，在数据类型后面加上 ？ 号即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 名字</span><br><span class="line">var name : String?</span><br></pre></td></tr></table></figure><h1 id="号的使用"><a href="#号的使用" class="headerlink" title="!号的使用"></a>!号的使用</h1><p><code>！</code> 号用于解包，一般只有在保证 <code>变量/常量</code> 有值，才能进行 <code>强行解包</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a : Int?</span><br><span class="line">a = 5;</span><br><span class="line">print(a!);</span><br></pre></td></tr></table></figure><h1 id="号"><a href="#号" class="headerlink" title="?? 号"></a>?? 号</h1><p><code>??</code> 号用于判断 <code>变量/常量</code> 数值是否为 <code>nil</code>，为nil则使用 <code>??</code> 号后面的值替代</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a : Int?</span><br><span class="line">print(a ?? 0);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：Alamofire网络请求封装</title>
      <link href="/BboyZJ.github.io/2023/02/03/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9AAlamofire%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85/"/>
      <url>/BboyZJ.github.io/2023/02/03/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9AAlamofire%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Alamofire</code> 是一个使用 <code>swift</code> 开发的网络请求框架，开发团队是 <code>AFNetworking</code> 的原团队。语法简洁，采用 <code>链式编程</code> 的思想，本质是基于 <code>NSURLSession</code> 进行封装。在实际项目中一般要进行 <code>二次封装</code>。</p><h1 id="根据后台返回的数据定义-BaseModel"><a href="#根据后台返回的数据定义-BaseModel" class="headerlink" title="根据后台返回的数据定义 BaseModel"></a>根据后台返回的数据定义 BaseModel</h1><ul><li>定义 <code>BaseModel</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import HandyJSON</span><br><span class="line"></span><br><span class="line">class BaseModel: HandyJSON &#123;</span><br><span class="line">    // 返回的数据</span><br><span class="line">    var data : Any?</span><br><span class="line">    // 业务码</span><br><span class="line">    var code : Int?</span><br><span class="line">    // 提示信息</span><br><span class="line">    var msg : String?</span><br><span class="line">    required init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BaseModel-建立后，就可以正式开始准备搭建网络请求工具了"><a href="#BaseModel-建立后，就可以正式开始准备搭建网络请求工具了" class="headerlink" title="BaseModel 建立后，就可以正式开始准备搭建网络请求工具了"></a>BaseModel 建立后，就可以正式开始准备搭建网络请求工具了</h1>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：lazy探索</title>
      <link href="/BboyZJ.github.io/2023/02/02/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Alazy%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2023/02/02/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Alazy%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p><code>lazy</code> 的本质是 <code>声明并执行的闭包</code>，或一个有返回值的函数调用，<code>只执行一次</code></p></li><li><p><code>lazy属性</code> 就是 <code>初始值</code> 直到 <code>第一次使用的时候</code> 才执行的属性</p></li><li><p><code>lazy</code> 属性必须是变量（var修饰符）,因为常量属性（let修饰符）必须在初始化之前就有值，所以常量属性不能定义为lazy</p></li></ul><h1 id="OC中的延迟加载"><a href="#OC中的延迟加载" class="headerlink" title="OC中的延迟加载"></a>OC中的延迟加载</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong)UILabel * label;</span><br><span class="line">- (UILabel *)label&#123;</span><br><span class="line">    if (!_label)&#123;</span><br><span class="line">        _label = [[UILabel alloc] init];</span><br><span class="line">        NSLog(@&quot;只在首次访问输出&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return _label;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Swift-延迟加载"><a href="#Swift-延迟加载" class="headerlink" title="Swift 延迟加载"></a>Swift 延迟加载</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lazy var myL: UILabel = &#123;</span><br><span class="line">    var myL = UILabel(frame: CGRectZero);</span><br><span class="line">    myL.backgroundColor = UIColor.green;</span><br><span class="line">    myL.text = &quot;我&quot;;</span><br><span class="line">    print(&quot;只在首次访问输出&quot;);</span><br><span class="line">    return myL;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>相比 <code>OC</code> 的实现，<code>lazy</code> 简单多了。</p><p><code>lazy var label: UILabel = UILabel()</code></p><h1 id="控件懒加载"><a href="#控件懒加载" class="headerlink" title="控件懒加载"></a>控件懒加载</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lazy var btn = &#123; () -&gt; UIButton in</span><br><span class="line">    // () -&gt; UIButton in 可以省略前提是已指定类型</span><br><span class="line">    // 执行类型不可省略</span><br><span class="line">    return UIButton(type: .custom);</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>常见写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lazy var btn: UIButton = &#123; </span><br><span class="line">    // () -&gt; UIButton in 可以省略前提是已指定类型</span><br><span class="line">    // 执行类型不可省略</span><br><span class="line">    return UIButton(type: .custom);</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：swift中宏定义替代方案</title>
      <link href="/BboyZJ.github.io/2023/02/02/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%E5%AE%8F%E5%AE%9A%E4%B9%89%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/"/>
      <url>/BboyZJ.github.io/2023/02/02/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9Aswift%E4%B8%AD%E5%AE%8F%E5%AE%9A%E4%B9%89%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>swift中没有宏定义，苹果简介用 <code>let</code> 或 <code>get</code> 属性来替代宏定义值</p><h1 id="第一种：获取的值不会变"><a href="#第一种：获取的值不会变" class="headerlink" title="第一种：获取的值不会变"></a>第一种：获取的值不会变</h1><p>可以直接使用 <code>let KnavBarHeight = 44.0;</code></p><h1 id="第二种：获取的值会变"><a href="#第二种：获取的值会变" class="headerlink" title="第二种：获取的值会变"></a>第二种：获取的值会变</h1><p><code>let</code> 定义的是常量，如果后面的值会变可以使用 <code>函数</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func StatusBar_height() -&gt; CGFloat&#123;</span><br><span class="line">    return UIApplication.shared.statusBarFrame.size.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>StatusBar_height()</code> 获取状态栏的高度</p><h1 id="第三种：输入有参数"><a href="#第三种：输入有参数" class="headerlink" title="第三种：输入有参数"></a>第三种：输入有参数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func RGB_COLOR(r:CGFloat,g:CGFloat,b:CGFloat) -&gt; UIColor&#123;</span><br><span class="line">    return UIColor(red:r,green:g,blue:b,alpha:1);</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>注：<code>func</code> 也可以用 <code>var</code> 代替</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>创建 <code>Common.swift</code> 文件存放</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090612687.png"></p><ul><li>创建 <code>SRSF-Swift-Bridging-Header</code> 存放三方库</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090612238.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter学习01:Mac环境搭建</title>
      <link href="/BboyZJ.github.io/2023/01/08/Flutter%E5%AD%A6%E4%B9%A0/Flutter%E5%AD%A6%E4%B9%A001%EF%BC%9AMac%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/BboyZJ.github.io/2023/01/08/Flutter%E5%AD%A6%E4%B9%A0/Flutter%E5%AD%A6%E4%B9%A001%EF%BC%9AMac%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="下载Flutter"><a href="#下载Flutter" class="headerlink" title="下载Flutter"></a>下载Flutter</h1><ol><li>方式一：</li></ol><ul><li><p>下载 <a href="https://docs.flutter.dev/development/tools/sdk/releases?tab=macos#macos">flutter</a> SDK：<a href="https://flutter.io/sdk-archive/#macos">https://flutter.io/sdk-archive/#macos</a></p></li><li><p>将文件解压到目标路径</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@192 ~ % cd 目标文件路径</span><br><span class="line">mac@192 ~ % unzip ~/Downloads/flutter_macos_3.3.10-stable.zip</span><br></pre></td></tr></table></figure><ul><li>配置 <code>flutter</code> 的 <code>PATH</code> 环境变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@192 ~ % export PATH=&quot;$PATH:`pwd`/flutter/bin&quot;</span><br></pre></td></tr></table></figure><p>pwd：是 <code>flutter</code> 下 <code>bin</code> 的文件路径</p><ol start="2"><li><p>方式二：</p><p> 直接从 <code>Github</code> 上下载：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@192 ~ % git clone https://github.com/flutter/flutter.git -b stable</span><br></pre></td></tr></table></figure><h1 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h1><ul><li>进入根目录</li></ul><p><code>mac@192 ~ % cd ~</code></p><ul><li>创建 <code>.bash_profile</code></li></ul><p><code>mac@192 ~ % touch .bash_profile</code></p><ul><li>编辑 <code>.bash_profile</code></li></ul><p><code>mac@192 ~ % open -e .bash_profile</code></p><ul><li>设置环境变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Flutter</span><br><span class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn # 国内镜像</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn # 国内镜像</span><br><span class="line">export PATH=&quot;$PATH:/Users/mac/Desktop/Flutter/flutter/bin&quot;</span><br></pre></td></tr></table></figure><p>注：<code>export PATH=&quot;$PATH:【flutter的bin目录】</code></p><ul><li>保存 <code>.bash_profile</code></li></ul><p><code>mac@192 ~ % command+s</code></p><ul><li>更新</li></ul><p><code>mac@192 ~ % source .bash_profile</code></p><ul><li>验证是否成功</li></ul><p><code>mac@192 ~ % flutter doctor</code></p><p>如果终端显示如下，证明成功了，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Downloading Darwin x64 Dart SDK from Flutter engine 3316dd8728419ad3534e3f6112aa6291f587078a...</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100  202M  100  202M    0     0  5622k      0  0:00:36  0:00:36 --:--:-- 6859k</span><br><span class="line">Building flutter tool...</span><br><span class="line">Flutter assets will be downloaded from https://storage.flutter-io.cn. Make sure</span><br><span class="line">you trust this source!</span><br><span class="line">Downloading Material fonts...                                    1,526ms</span><br><span class="line">Downloading Gradle Wrapper...                                      262ms</span><br><span class="line">Downloading package sky_engine...                                  473ms</span><br><span class="line">Downloading flutter_patched_sdk tools...                         1,162ms</span><br><span class="line">Downloading flutter_patched_sdk_product tools...                   638ms</span><br><span class="line">Downloading darwin-x64 tools...                                     5.5s</span><br><span class="line">Downloading libimobiledevice...                                     78ms</span><br><span class="line">Downloading usbmuxd...                                              75ms</span><br><span class="line">Downloading libplist...                                             75ms</span><br><span class="line">Downloading openssl...                                             249ms</span><br><span class="line">Downloading ios-deploy...                                           88ms</span><br><span class="line">Downloading darwin-x64/font-subset tools...                        255ms</span><br><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[✓] Flutter (Channel stable, 3.3.10, on macOS 12.6.1 21G217 darwin-x64, locale</span><br><span class="line">    zh-Hans-CN)</span><br><span class="line">[!] Android toolchain - develop for Android devices (Android SDK version 30.0.0)</span><br><span class="line">    ✗ cmdline-tools component is missing</span><br><span class="line">      Run `path/to/sdkmanager --install &quot;cmdline-tools;latest&quot;`</span><br><span class="line">      See https://developer.android.com/studio/command-line for more details.</span><br><span class="line">    ✗ Android license status unknown.</span><br><span class="line">      Run `flutter doctor --android-licenses` to accept the SDK licenses.</span><br><span class="line">      See https://flutter.dev/docs/get-started/install/macos#android-setup for</span><br><span class="line">      more details.</span><br><span class="line">[!] Xcode - develop for iOS and macOS (Xcode 14.1)</span><br><span class="line">    ! CocoaPods 1.10.1 out of date (1.11.0 is recommended).</span><br><span class="line">        CocoaPods is used to retrieve the iOS and macOS platform side&#x27;s plugin</span><br><span class="line">        code that responds to your plugin usage on the Dart side.</span><br><span class="line">        Without CocoaPods, plugins will not work on iOS or macOS.</span><br><span class="line">        For more info, see https://flutter.dev/platform-plugins</span><br><span class="line">      To upgrade see</span><br><span class="line">      https://guides.cocoapods.org/using/getting-started.html#installation for</span><br><span class="line">      instructions.</span><br><span class="line">[✓] Chrome - develop for the web</span><br><span class="line">[!] Android Studio (not installed)</span><br><span class="line">[✓] VS Code (version 1.73.1)</span><br><span class="line">[✓] Connected device (3 available)</span><br><span class="line">[✓] HTTP Host Availability</span><br></pre></td></tr></table></figure><ul><li>针对 <code>CocoaPods 1.10.1 out of date (1.11.0 is recommended)</code> 我们只需要下载安装就可以了：</li></ul><p><code>mac@192 ~ % sudo gem install -n /usr/local/bin cocoapods</code></p><p>通过 <code>pod --version</code> 查看最新版本</p><ul><li>针对 <code>cmdline-tools component is missing</code> 错误</li></ul><p>打开 <code>Android studio</code> 下 <code>tools--&gt;SDK manager</code> 中进入 <code>SDK tools</code> 中：</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090541572.png"></p><p>找到 <code>Android SDK</code> 点击 <code>Apply</code> 进行下载</p><ul><li>再次 <code>flutter doctor</code> 运行，出现如下，则代表成功</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[✓] Flutter (Channel stable, 3.3.10, on macOS 12.6.1 21G217 darwin-x64, locale</span><br><span class="line">    zh-Hans-CN)</span><br><span class="line">[✓] Android toolchain - develop for Android devices (Android SDK version 30.0.0)</span><br><span class="line">[✓] Xcode - develop for iOS and macOS (Xcode 14.1)</span><br><span class="line">[✓] Chrome - develop for the web</span><br><span class="line">[✓] Android Studio (version 2021.1)</span><br><span class="line">[✓] VS Code (version 1.73.1)</span><br><span class="line">[✓] Connected device (3 available)</span><br><span class="line">[✓] HTTP Host Availability</span><br><span class="line"></span><br><span class="line">• No issues found!</span><br></pre></td></tr></table></figure><ul><li>打开 <code>Android studio</code> 程序，安装 flutter：</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090542392.png"></p><ul><li>安装 <code>dart</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090542872.png"></p><ul><li>安装完成，重新启动 <code>Android studio</code>，就可以开发 flutter 了</li></ul><h1 id="升级-flutter"><a href="#升级-flutter" class="headerlink" title="升级 flutter"></a>升级 flutter</h1><ol><li>flutter SDK 所有分支</li></ol><p>beat&#x2F;dev&#x2F;master&#x2F;stable，其中stable为稳定分支，dev和master为开发分支，运行 <code>flutter channel</code> 查看所有分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mac@bogon ~ % flutter channel</span><br><span class="line">Flutter channels:</span><br><span class="line">  master</span><br><span class="line">  beta</span><br><span class="line">* stable</span><br></pre></td></tr></table></figure><ul><li>“*” 号本地的flutter SDK 跟踪分支，切换分支 <code>flutter channel beta</code> 和 <code>flutter channel master</code></li></ul><ol start="2"><li>升级 <code>flutter sdk</code> 和 <code>依赖包</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure><p>该命令会同时更新 <code>Flutter SDK</code>  和 <code>flutter依赖包</code>，如果只想更新依赖包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter packages get 获取项目所有的依赖包</span><br><span class="line">flutter packages upgrade 获取项目所有依赖包的最新版本</span><br></pre></td></tr></table></figure><h1 id="IDE配置和使用"><a href="#IDE配置和使用" class="headerlink" title="IDE配置和使用"></a>IDE配置和使用</h1><p><code>Flutter</code> 建议使用 <code>Android Studio</code> 和 <code>VS Code</code> 之一开发体验，通过 <code>IDE和插件</code> 可获得代码补全、语法高亮、widget编辑辅助、运行和调试等功能，帮助我们极大的提高开发效率</p><ol><li><p>Android Studio</p></li><li><p>VS Code</p></li></ol><p><a href="https://book.flutterchina.club/chapter1/install_flutter.html#_1-3-2-ide%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8">Flutter官网</a></p><h1 id="连接到-ios-真机设备"><a href="#连接到-ios-真机设备" class="headerlink" title="连接到 ios 真机设备"></a>连接到 ios 真机设备</h1><p><a href="https://book.flutterchina.club/chapter1/install_flutter.html#_1-3-2-ide%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8">Flutter官网</a></p><p>如果出现如下：</p><p>flutter真机运行 无法打开“iproxy”,因为无法验证开发者</p><p>执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo xattr -d com.apple.quarantine </span><br><span class="line">sudo xattr -d com.apple.quarantine </span><br><span class="line">sudo xattr -d com.apple.quarantine</span><br><span class="line">sudo xattr -d com.apple.quarantine /Users/mac/Desktop/Flutter/flutter/bin/cache/artifacts/usbmuxd/iproxy</span><br></pre></td></tr></table></figure><p>其中 <code>/Users/mac/Desktop/Flutter/flutter</code> 是你桌面flutter的路径</p>]]></content>
      
      
      <categories>
          
          <category> Flutter-学习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC数据结构00：入门</title>
      <link href="/BboyZJ.github.io/2022/11/23/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8400%EF%BC%9A%E5%85%A5%E9%97%A8/"/>
      <url>/BboyZJ.github.io/2022/11/23/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8400%EF%BC%9A%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>数据结构概念：</li></ul><p>我们把现实中 大量复杂的问题 <code>以特定的数据类型和特定的存储结构保存到</code> 主存储器（内存）中，在此基础上实现某个功能（排序等）的操作叫 <code>算法</code>。</p><p>数据结构 &#x3D; 元素 + 元素关系</p><p>算法 &#x3D; 对数据结构的操作</p><ul><li>算法：解决问题的方法和步骤</li></ul><p>衡量标准：</p><p>时间复杂度：<code>算法要执行的次数</code>，非执行时间</p><p>空间复杂度：算法执行过程 <code>大概要占用的最大内存</code></p><h1 id="指针定义"><a href="#指针定义" class="headerlink" title="指针定义"></a>指针定义</h1><ul><li>地址</li></ul><p><code>地址是内存单元的编号</code>，其编号从 <code>0</code> 开始的非负整数，范围：0 – 0xFFFFFFFF x64平台下最大内存地址为 2^64 - 1</p><ul><li>指针</li></ul><p><code>指针就是地址，地址就是指针</code> 即 <code>* = &amp;</code>，<code>指针变量</code> 是存放 <code>内存单元地址</code> 的变量，它内部保存的值是对应的 <code>地址</code>， <code>地址就是内存单元编号</code>。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int  i = 10; // 定义一个 整形变量 i 初始值 10</span><br><span class="line">int *p = i; // 定义一个 整形的指针变量p，变量p 指向 i的地址</span><br><span class="line"></span><br><span class="line">// 这两行等于上面两行</span><br><span class="line">int *p; </span><br><span class="line">*p = &amp;i;</span><br></pre></td></tr></table></figure><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体是用户根据自己的实际需要，自定义的复合数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 学生类型</span><br><span class="line">typedef struct Student &#123; // 结构体定义</span><br><span class="line">    int age;</span><br><span class="line">    char *name;</span><br><span class="line">&#125;myStudent;</span><br><span class="line"></span><br><span class="line">// 直接传递 只占用 4 byte 的指针，省时效率也高&lt;推荐用法&gt;</span><br><span class="line">void func(struct Student *p)&#123;</span><br><span class="line">    print(&quot;age = %d&quot;,p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两种结构体的使用方式：</p><ul><li>直接使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct Student stu = &#123;12,&quot;xiaojian&quot;&#125;;</span><br></pre></td></tr></table></figure><ul><li>通过指针使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct Student *p = &amp;stu;</span><br><span class="line">p -&gt; age = 31;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-数据结构探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3学习02：运行Python方式</title>
      <link href="/BboyZJ.github.io/2022/07/22/Python%E5%AD%A6%E4%B9%A0/Python3%E5%AD%A6%E4%B9%A002%EF%BC%9A%E8%BF%90%E8%A1%8CPython%E6%96%B9%E5%BC%8F/"/>
      <url>/BboyZJ.github.io/2022/07/22/Python%E5%AD%A6%E4%B9%A0/Python3%E5%AD%A6%E4%B9%A002%EF%BC%9A%E8%BF%90%E8%A1%8CPython%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>运行 Python 有三种方式：</p><p>1、交互式解析器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python # Unix/Linux</span><br></pre></td></tr></table></figure><p>2、命令行脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python script.py # Unix/Linux</span><br></pre></td></tr></table></figure><p>注：在执行脚本时，请检查脚本是否有可执行权限</p><p>3、集成开发环境（IDE：Integrated Development Environment）: PyCharm）</p><ul><li><p>PyCharm 是由 JetBrains 打造的一款 Python IDE，支持 macOS、 Windows、 Linux 系统。</p></li><li><p>PyCharm 功能 : 调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制等</p></li><li><p>PyCharm 下载地址 : <a href="https://www.jetbrains.com/pycharm/download/">https://www.jetbrains.com/pycharm/download/</a></p></li><li><p>PyCharm 安装教程地址 : <a href="https://www.w3cschool.cn/python3/python3-l4i738c3.html">https://www.w3cschool.cn/python3/python3-l4i738c3.html</a></p></li><li><p>Python IDE 安装教程地址：<a href="https://www.w3cschool.cn/python/python-ide.html">https://www.w3cschool.cn/python/python-ide.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3学习01：Mac安装Python3</title>
      <link href="/BboyZJ.github.io/2022/07/22/Python%E5%AD%A6%E4%B9%A0/Python3%E5%AD%A6%E4%B9%A001%EF%BC%9AMac%E5%AE%89%E8%A3%85Python3/"/>
      <url>/BboyZJ.github.io/2022/07/22/Python%E5%AD%A6%E4%B9%A0/Python3%E5%AD%A6%E4%B9%A001%EF%BC%9AMac%E5%AE%89%E8%A3%85Python3/</url>
      
        <content type="html"><![CDATA[<h1 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h1><p>打开 <a href="https://www.python.org/downloads/macos/">python官网</a> ，选择下面稳定版本的最新的包进行下载安装</p><p><img src="/BboyZJ.github.io/assets/16584729404264.jpg"></p><h1 id="安装-Python3"><a href="#安装-Python3" class="headerlink" title="安装 Python3"></a>安装 Python3</h1><p>按照安装的提示，一直下一步即可</p><p><img src="/BboyZJ.github.io/assets/16584730134974.jpg"></p><h1 id="安装配置-pip"><a href="#安装配置-pip" class="headerlink" title="安装配置 pip"></a>安装配置 pip</h1><p><strong>什么是 pip？</strong></p><p><code>pip</code> 这个包是 <code>python</code> 强大的模组下载必备工具包</p><p><strong>打开终端输入下面的代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% curl https://bootstrap.pypa.io/get-pip.py | python3</span><br></pre></td></tr></table></figure><p>安装成功后，如下：</p><p><img src="/BboyZJ.github.io/assets/16584730752450.jpg"></p><h1 id="Python3-环境变量配置"><a href="#Python3-环境变量配置" class="headerlink" title="Python3 环境变量配置"></a>Python3 环境变量配置</h1><p>想让Mac OS系统内默认的 <code>python</code> 版本为新安装的 <code>python 3.10</code>，按照下面的步骤进行配置：</p><p>1、终端输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% which Python3</span><br><span class="line">/Library/Frameworks/Python.framework/Versions/3.10/bin/Python3</span><br></pre></td></tr></table></figure><p>然后把第二行的路径复制下来，保存到一个地方</p><p><img src="/BboyZJ.github.io/assets/16584737982143.jpg"></p><p>2、在终端输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% vim ~/.bash_profile</span><br></pre></td></tr></table></figure><p><img src="/BboyZJ.github.io/assets/16584744806953.jpg"></p><p>敲击键盘上的 <code>i</code> 按键，进入插入模式，界面最左下方出现 <code>INSERT</code> 几个字母</p><p>3、使用键盘上的方向键，将白色的光标移动到随便一个空白行，输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Setting PATH for Python 3.10 （这两行应该是注释，但是本小白不敢删）</span><br><span class="line"># The original version is saved in .bash_profile.pysave （这两行应该是注释，但是本小白不敢删）</span><br><span class="line">PATH=&quot;/Library/Frameworks/Python.framework/Versions/3.10/bin:$&#123;PATH&#125;&quot;</span><br><span class="line">export PATH</span><br><span class="line">alias python=&quot;/Library/Frameworks/Python.framework/Versions/3.10/bin/python3&quot;</span><br></pre></td></tr></table></figure><p>引号里面的路径是刚才执行 <code>步骤 1</code> 保存下来的路径，然后 <code>PATH=</code> 后面的命令，请务必按照以上的格式删减几个字母，只保留到 <code>bin</code> （看清楚啊，后面没有斜杠）就可以！！！</p><p>4、保存退出</p><p>输入结束后敲击键盘左上角的 <code>ESC</code> 按键，<code>INSERT</code> 消失，此时，按住 <code>shift + ：</code>键，接着输入 <code>wq</code> 如下图所示，然后敲击 <code>回车键</code> 页面会自动关闭。</p><p><img src="/BboyZJ.github.io/assets/16584749336841.jpg"></p><p>5、输入下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>显示进程完成即可</p><p>6、输入下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% vim ~/.zshrc</span><br></pre></td></tr></table></figure><p>输入步骤3中的内容，操作类似</p><p>7、关闭终端页面，重新打开，输入下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% python</span><br></pre></td></tr></table></figure><p>出现下面的内容即配置环境变量成功</p><p><img src="/BboyZJ.github.io/assets/16584753411712.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC逆向05：汇编总结</title>
      <link href="/BboyZJ.github.io/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9105%EF%BC%9A%E6%B1%87%E7%BC%96%E6%80%BB%E7%BB%93/"/>
      <url>/BboyZJ.github.io/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9105%EF%BC%9A%E6%B1%87%E7%BC%96%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OC-逆向探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC逆向04：OC反汇编（下）</title>
      <link href="/BboyZJ.github.io/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9104%EF%BC%9AOC%E5%8F%8D%E6%B1%87%E7%BC%96%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/BboyZJ.github.io/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9104%EF%BC%9AOC%E5%8F%8D%E6%B1%87%E7%BC%96%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OC-逆向探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC逆向04：OC反汇编（上）</title>
      <link href="/BboyZJ.github.io/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9104%EF%BC%9AOC%E5%8F%8D%E6%B1%87%E7%BC%96%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/BboyZJ.github.io/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9104%EF%BC%9AOC%E5%8F%8D%E6%B1%87%E7%BC%96%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OC-逆向探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC逆向03：循环选择指针（下）</title>
      <link href="/BboyZJ.github.io/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9103%EF%BC%9A%E5%BE%AA%E7%8E%AF%E9%80%89%E6%8B%A9%E6%8C%87%E9%92%88%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/BboyZJ.github.io/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9103%EF%BC%9A%E5%BE%AA%E7%8E%AF%E9%80%89%E6%8B%A9%E6%8C%87%E9%92%88%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OC-逆向探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC逆向03：循环选择指针（上）</title>
      <link href="/BboyZJ.github.io/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9103%EF%BC%9A%E5%BE%AA%E7%8E%AF%E9%80%89%E6%8B%A9%E6%8C%87%E9%92%88%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/BboyZJ.github.io/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9103%EF%BC%9A%E5%BE%AA%E7%8E%AF%E9%80%89%E6%8B%A9%E6%8C%87%E9%92%88%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OC-逆向探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC逆向02：函数本质（下）</title>
      <link href="/BboyZJ.github.io/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9102%EF%BC%9A%E5%87%BD%E6%95%B0%E6%9C%AC%E8%B4%A8%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/BboyZJ.github.io/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9102%EF%BC%9A%E5%87%BD%E6%95%B0%E6%9C%AC%E8%B4%A8%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要是讲解函数的 参数、返回值、局部变量 在汇编中是如何存储的，以及 CPSR 标志寄存器</p><h1 id="函数的参数和返回值"><a href="#函数的参数和返回值" class="headerlink" title="函数的参数和返回值"></a>函数的参数和返回值</h1><ul><li><p>arm64下，函数的 参数 是存放在 x0-x7（w0-w7） 这8个寄存器里面的，如果超过 8 个参数，就会入栈</p><ul><li><p>如果自定义函数时，参数最好不要超过6个（因为有两个隐藏参数 self,_cmd）</p></li><li><p>如果函数需要多个参数，可以传入数组、结构体、指针等类型</p></li></ul></li><li><p>函数的 返回值 放在 x0寄存器 中</p><ul><li>如果返回值 大于8个 字节，就会 利用内存传递</li></ul></li></ul><h1 id="查看系统的参数汇编"><a href="#查看系统的参数汇编" class="headerlink" title="查看系统的参数汇编"></a>查看系统的参数汇编</h1><p>下面通过系统中对函数的汇编来查看系统对参数、返回值是如何操作的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int sum(int a, int b)&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">- (void)viewDidLoad&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    sum(10, 20);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看汇编，在跳转到sum函数之前，已经将参数存入 w0、w1</li></ul><p><img src="/BboyZJ.github.io/assets/16512207531087.jpg"></p><ul><li>在sum函数中，读取w0、w1，放入w8、w9。然后将相加后的结果放入w0（即返回值在w0寄存器）</li></ul><p><img src="/BboyZJ.github.io/assets/16512209280989.jpg"></p><h1 id="自己优化实现sum"><a href="#自己优化实现sum" class="headerlink" title="自己优化实现sum"></a>自己优化实现sum</h1><p>运行发现，其结果与sum函数是一致的，结果都是30</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--asm.s--&gt;</span><br><span class="line">.text</span><br><span class="line">.global _suma</span><br><span class="line"></span><br><span class="line">_suma:</span><br><span class="line">    add x0, x0, x1</span><br><span class="line">    ret </span><br><span class="line">    </span><br><span class="line">&lt;!--调用--&gt;</span><br><span class="line">int suma();</span><br><span class="line">- (void)viewDidLoad&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    printf(&quot;%d&quot;,suma(10, 20));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--查看打印结果--&gt;</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h1 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h1><p>来看一下代码的汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int test(int a, int b, int c, int d, int e, int f, int g, int h, int i)&#123;</span><br><span class="line">    return a + b + c + d + e + f + g + h + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    test(1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>test函数断住，查看汇编</li></ul><p><img src="/BboyZJ.github.io/assets/16512215244437.jpg"></p><p>以下是 <code>viewDidLoad</code> 栈空间的存入分析过程</p><p><img src="/BboyZJ.github.io/assets/16512222727899.jpg"></p><ul><li>以下是 <code>test</code> 函数的汇编分析</li></ul><p><img src="/BboyZJ.github.io/assets/16512226271779.jpg"></p><h2 id="编译器优化-1"><a href="#编译器优化-1" class="headerlink" title="编译器优化"></a>编译器优化</h2><ul><li>将debug模式改成release模式，此时再来查看汇编代码，发现没有test函数，被优化掉了</li></ul><p><img src="/BboyZJ.github.io/assets/16512228732992.jpg"></p><ul><li>如果非要执行 test，可以这样写</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    printf(&quot;%d&quot;, test(1, 2, 3, 4, 5, 6, 7, 8, 9));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码如下，发现优化后的test函数在汇编中，其本质是一个 <code>数</code>，也就是 test函数的返回值（相当于将 <code>printf(&quot;%d&quot;, test(1, 2, 3, 4, 5, 6, 7, 8, 9));</code> 直接优化成了 <code>printf(&quot;%d&quot;, 45);</code>)</p><p><img src="/BboyZJ.github.io/assets/16512234239388.jpg"></p><h1 id="通过汇编实现函数"><a href="#通过汇编实现函数" class="headerlink" title="通过汇编实现函数"></a>通过汇编实现函数</h1><ul><li>定义函数声明及调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int funcA(int a, int b);</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    int a = funcA(10, 20);</span><br><span class="line">    printf(&quot;%d&quot;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>汇编实现 funcA</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--sam中--&gt;</span><br><span class="line">.text</span><br><span class="line">.global _funcA, _sum</span><br><span class="line"></span><br><span class="line">_funcA:</span><br><span class="line">    sub sp, sp, #0x10</span><br><span class="line">    stp x29, x30, [sp] // 保护lr</span><br><span class="line">    bl _sum</span><br><span class="line">    ldp x29, x30, [sp]</span><br><span class="line">    add sp, sp, #0x10</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">_sum:</span><br><span class="line">    add x0, x0, x1</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">&lt;!--vc中--&gt;</span><br><span class="line">int funcA();</span><br><span class="line">- (void)viewDidLoad&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    printf(&quot;%d&quot;,funcA(10,20));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><p><strong>【说明】：</strong></p><ul><li><p>关于b指令：只是跳转，不改变lr寄存器</p></li><li><p>拉伸空间和参数个数有没有关系？</p><ul><li>有关系，参数越多时，如果寄存器放不下，就需要用到内存。就会将栈空间放大，影响栈空间的不仅仅是参数个数，还有局部变量</li></ul></li></ul><h1 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h1><p>如果返回值是 一个结构体，一个寄存器放不下，这是什么情况？</p><p>有以下代码，运行查看其汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct str &#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    int c;</span><br><span class="line">    int d;</span><br><span class="line">    int f;</span><br><span class="line">    int g;</span><br><span class="line">&#125;;</span><br><span class="line">struct Str getStr(int a, int b, int c, int d, int f, int g)&#123;</span><br><span class="line">    struct Str str1;</span><br><span class="line">    str1.a = a;</span><br><span class="line">    str1.b = b;</span><br><span class="line">    str1.c = c;</span><br><span class="line">    str1.d = d;</span><br><span class="line">    str1.f = f;</span><br><span class="line">    str1.g = g;</span><br><span class="line">    return str1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    struct Str str2 = getStr(1, 2, 3, 4, 5, 6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>断点运行，以下是 <code>viewDidLoad</code> 函数的汇编</li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-逆向探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC逆向02：函数本质（上）</title>
      <link href="/BboyZJ.github.io/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9102%EF%BC%9A%E5%87%BD%E6%95%B0%E6%9C%AC%E8%B4%A8%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/BboyZJ.github.io/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9102%EF%BC%9A%E5%87%BD%E6%95%B0%E6%9C%AC%E8%B4%A8%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文的主要目的是理解 <code>函数栈</code> 以及涉及的相关 <code>指令</code></p><p>在讲函数的本质之前，首先需要讲下以下几个概念 <code>栈、SP、FP</code></p><h1 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li>栈：是一种 <code>具有特殊的访问方式的存储空间</code>（即 <code>后进先出</code> Last In First Out，<code>LIFO</code>）</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165877691-e0fe53cc-93c8-40c4-8cbb-a3445092ca40.jpg"></p><ul><li><p>高地址往低地址存数据（<code>存：高--&gt;低</code>）</p></li><li><p>栈空间开辟：往低地址开辟（<code>开辟：高--&gt;低</code>）</p></li></ul><h2 id="SP和FP寄存器"><a href="#SP和FP寄存器" class="headerlink" title="SP和FP寄存器"></a>SP和FP寄存器</h2><ul><li><p><code>SP寄存器</code>：在任意时刻会 <code>保存我们栈顶的地址</code></p></li><li><p><code>FP寄存器</code>（也称为 <code>x29</code> 寄存器）：属于通用寄存器，但是在某些时刻（例如函数嵌套调用时）可以 <code>利用它保存栈底的地址</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line"></span><br><span class="line">* arm64开始，取消了32位的LDM、STM、PUSH、POP指令，取而代之的是ldr/ldp、str/stp（r和p的区别在于处理的寄存器个数，r表示处理1个寄存器，p表示处理两个寄存器）</span><br><span class="line">* arm64中，对栈的操作是 16字节对齐 的</span><br></pre></td></tr></table></figure><p>以下是arm64之前和arm64之后的一个对比</p><p><img src="https://user-images.githubusercontent.com/25925248/165877713-b57fc265-1f30-4965-b5b6-dc17d4a346a7.jpg"></p><ul><li>在arm64之前，栈顶指针是压栈时一个数据移动一个单元</li><li>在arm64开始，首先是 <code>从高地址往低地址开辟一段空间（由编译器决定）</code>，然后再放入数据，所以不存在push、pop操作。这种情况可以通过内存读写指令（<code>ldr/ldp、str/stp</code>）对其进行操作</li></ul><h2 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h2><p>以下是常见的函数调用 <code>开辟（sub）</code> 以及 <code>恢复栈空间（add）</code> 的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 开辟栈空间</span><br><span class="line">sub    sp, sp, #0x40             ; 拉伸（开辟）0x40（64字节）空间</span><br><span class="line">stp    x29, x30, [sp, #0x30]     ; x29\x30 寄存器入栈保护</span><br><span class="line">add    x29, sp, #0x30            ; x29指向栈帧的底部</span><br><span class="line">... </span><br><span class="line">ldp    x29, x30, [sp, #0x30]     ; 恢复x29/x30 寄存器的值</span><br><span class="line">// 恢复栈空间</span><br><span class="line">add    sp, sp, #0x40             ; 栈平衡</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h2 id="内存读写指令"><a href="#内存读写指令" class="headerlink" title="内存读写指令"></a>内存读写指令</h2><p><strong>注意：</strong></p><ul><li><p><code>读/写数据</code> 都是往 高地址 <code>读/写</code></p></li><li><p>写数据：先拉伸栈空间，在拿sp进行写数据，即 <code>先申请空间再写数据</code></p></li></ul><p><strong>str（store register）指令：</strong></p><ul><li>将数据从寄存器中读出来，存到 <code>内存</code> 中（即一个寄存器是 <code>8字节=64位</code>）</li></ul><p><strong>ldr（load register）指令：</strong></p><ul><li><p>将数据从内存中读出来，存到 <code>寄存器</code> 中</p></li><li><p>此时 <code>ldr</code> 和 <code>str</code> 的变种 <code>ldp和stp</code> 还可以操作 <code>2个</code> 寄存器（即 <code>16字节=128位</code>）</p></li></ul><h2 id="堆栈练习"><a href="#堆栈练习" class="headerlink" title="堆栈练习"></a>堆栈练习</h2><p>使用32个字节空间作为这段程序的栈空间，然后利用栈将x0和x1的值进行交换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub sp, sp, #0x20       ;拉伸栈空间32个字节</span><br><span class="line">stp x0, x1, [sp, #0x10] ;sp往上加16个字节（两个8字节的寄存器），存放x0和x1</span><br><span class="line">ldp x1, x0, [sp, #0x10] ;将sp偏移16个字节的值从取出来，放入x1和x0，内存是temp（寄存器里面的值进行交换了）</span><br><span class="line">add sp, sp, #0x20       ;栈平衡</span><br><span class="line">ret                     ;返回</span><br></pre></td></tr></table></figure><p><strong>栈的操作如下图所示：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/165877747-40c08e41-164d-4bd7-95b3-bacc3cf9d99f.jpg"></p><p><strong>调式查看栈</strong></p><ul><li>在 asm文件中写入如下代码：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _A,_B</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    sub sp, sp, #0x20</span><br><span class="line">    stp x0, x1, [sp, #0x10]</span><br><span class="line">    ldp x1, x0, [sp, #0x10]</span><br><span class="line">    add sp, sp, #0x20</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><ul><li>在 VC 中调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">// 函数的声明</span><br><span class="line">int B();</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    B();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>断点到 <code>sub sp, sp, #0x20</code>： 进行调试，如下图</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165877782-ebaca024-9985-4d61-834c-6e4bd1415b80.jpg"></p><p>由上图可知，sp的初始地址是 <code>0x000000016f491a80</code>，正常由高地址往低地址 <code>拉伸（开辟）</code> #0x20个地址后，sp的最新地址为 <code>0x000000016f491a80 - 0x20 = 0x000000016f491a60</code></p><ul><li>按住 <code>control Step into</code>，往下走一步查看结果</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165877797-84cef9dc-5837-443a-9f6f-f9bd66a26085.jpg"></p><ul><li>此时 <code>x0，x1</code> 的默认地址如下图</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165877802-0afedacc-a62e-4bfa-b77d-2a627f263e69.jpg"></p><ul><li><code>stp x0, x1, [sp, #0x10]</code>：将 <code>sp</code> 的偏移 <code>#0x10</code> 写入 <code>x0，x1</code>，结果如下图：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165877809-8c5b755b-79fe-447e-ba10-652758eacd9f.jpg"></p><ul><li><code>ldp x1, x0, [sp, #0x10]</code>：将 <code>sp</code> 的内存地址加上 <code>#0x10</code>，读取 <code>x0，x1</code> 的数据并交换结果如下；</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165877818-ade8c981-e6c2-4cff-9368-82d4ed6f541a.jpg"></p><ul><li><code>add sp, sp, #0x20</code>：走到栈平衡，最后将 <code>sp</code> 指针地址加上 <code>#0x20</code>，即 <code>sp恢复了</code>，此时的a和b仍然在内存中，等待着下一轮栈拉伸后数据的写入覆盖。如果此时读取，读取到的是垃圾数据</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165877824-7915eaea-4ae6-4071-be69-29aa95150802.jpg"></p><ul><li>如果上面默认的地址不方便看，你可以重写 <code>register write x0 0xa</code> 和 <code>register write x1 0xb</code> 的来断点调试，如下图：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165877828-1da5ed85-77dd-4ff5-873e-ee20ee003b5d.jpg"></p><p><strong>疑问：栈空间不断开辟，死循环，会不会崩溃？</strong></p><p>在这里我们将会处理上篇 <a href="https://www.bboyzj.cn/2022/04/20/OC%E9%80%86%E5%90%9101%EF%BC%9A%E5%88%9D%E5%A7%8B%E6%B1%87%E7%BC%96/">OC逆向01：初始汇编</a> 文章中文末遗留的问题</p><p>下面我们通过一个汇编代码来演示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--asm.s--&gt;</span><br><span class="line">.text</span><br><span class="line">.global _B</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    sub sp,sp,#0x20</span><br><span class="line">    stp x0,x1,[sp,#0x10]</span><br><span class="line">    ldp x1,x0,[sp,#0x10];寄存器里面的值进行交换</span><br><span class="line">    bl _B</span><br><span class="line">    add sp,sp,#0x20</span><br><span class="line">    ret</span><br><span class="line">    </span><br><span class="line">&lt;!--调用--&gt;</span><br><span class="line">int B();</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果发现：死循环会崩溃，会导致 <code>堆栈溢出</code></p><p><img src="https://user-images.githubusercontent.com/25925248/165878330-a8724c53-c3a0-48fc-8e07-f81c0269c27f.jpg"></p><h2 id="bl、ret指令"><a href="#bl、ret指令" class="headerlink" title="bl、ret指令"></a>bl、ret指令</h2><p><strong>bl标号</strong></p><ul><li>b：转到标号处执行指令（即b）</li><li>将 <code>下一条指令的地址</code> 放入通用寄存器 <code>lr（x30）</code> 中</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165907393-b5a445ac-42e8-45a5-9fa0-b58230a95637.jpg"></p><p>等到B函数ret时，通过lr获取回家的路（注：<code>lr就是保存回家的路</code>）</p><p><strong>ret</strong></p><ul><li><p>默认使用 <code>lr(x30)寄存器</code> 的值，通过底层指令提示CPU此处作为下条指令地址</p></li><li><p>arm64平台的特色指令，它面向硬件做了优化处理的</p></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>下面通过汇编代码来演示 <code>bl、ret指令</code></p><ul><li>asm文件下代码如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _A, _B</span><br><span class="line"></span><br><span class="line">_A:</span><br><span class="line">    mov x0, #0xaaaa</span><br><span class="line">    bl _B</span><br><span class="line">    mov x0, #0xaaaa</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    mov x0, #0xbbbb</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><ul><li>vc中执行如下代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 函数的声明</span><br><span class="line">int A();</span><br><span class="line">int B();</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    printf(@&quot;A&quot;);</span><br><span class="line">    A();</span><br><span class="line">    printf(@&quot;B&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>断点 <code>mov x0，#0xaaaa</code> 运行：发现 <code>lr</code> 保存了下一条指令的地址是 <code>1f78</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165907463-7429e0d8-09ed-444f-b823-385facf324d8.jpg"></p><ul><li>往下执行 <code>bl _B</code> ：此时 <code>x0</code> 的地址为 <code>0xaaaa</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165907474-58c5c158-2aa7-4e75-bda5-0d21fe65e1e9.jpg"></p><ul><li>继续执行 <code>bl _B</code>，跳转到 <code>B</code>，此时的 <code>lr</code> 会变成 <code>A</code> 中 <code>bl</code> 的下一条指令的地址 <code>1f20</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165907549-add8c93c-b1be-4a85-8fa7-0528c94de017.jpg"></p><ul><li>执行完B中的 <code>mov x0, #0xbbbb</code>，x0 变成 <code>bbbb</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165907579-d20b57c9-4e1e-400e-965c-2a798b298f1f.jpg"></p><ul><li>执行 <code>B</code> 中的 <code>ret</code>，<code>lr</code> 会回到 <code>A</code> 中 <code>1f20</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165907624-fa004fd1-e39a-4607-94c4-6596506acc13.jpg"></p><ul><li>继续执行 <code>A</code> 中的 <code>ret</code>，会再次回到 <code>1f20</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165907673-708eb03d-94c9-4b64-923b-a8fe3b1c4952.jpg"></p><ul><li><p>走到这里，发现 <code>死循环了</code>，主要是因为 <code>lr</code> 一直是 <code>1f20</code>，<code>ret</code> 只会看 <code>lr</code>。</p><ul><li>其中 <code>pc</code> 是指 <code>接下来要执行的内存地址</code>，<code>ret</code> 是指让CPU将 <code>lr</code> 作为接下来执行的地址（相当于将lr赋值给pc）</li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165907711-6e3449f2-ee23-431e-8fd9-f636ada6a11e.jpg"></p><p><strong>疑问1：此时B回到A没问题，那么A回到viewDidLoad怎么回事呢？</strong></p><ul><li><p>需要在A的bl之前 <code>保护lr寄存器</code></p><ul><li><p><strong>疑问2：是否可以保存到其他寄存器上？</strong></p><ul><li><p>答案是 <code>不可以</code>，原因是不安全，因为你不确定这个寄存器会在什么时候被别人使用</p></li><li><p>正确做法：<code>lr保存到栈区</code></p></li></ul></li></ul></li></ul><p><strong>系统中函数嵌套是如何返回的？</strong></p><p>下面我们来看一下系统是如何操作的，例如：<code>d -&gt; c -&gt; viewDidLoad</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void d()&#123;</span><br><span class="line">&#125;</span><br><span class="line">void c()&#123;</span><br><span class="line">    d();</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">- (void)viewDidLoad&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    printf(&quot;A&quot;);</span><br><span class="line">    c();</span><br><span class="line">    printf(&quot;B&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看汇编，断点在 <code>c()</code> 函数</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165907777-b0445a62-79ff-4ff4-886e-2a4671ea9c84.jpg"></p><ul><li><code>stp x29,x30,[sp,#-0x10]</code>：边开辟栈，边写入，其中 <code>x29就是fp（栈底）</code>，<code>x30是lr</code>，<code>!</code> 的含义是，将[]中计算的结果给sp，即 <code>sp-=0x10</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165907817-6b4444cb-7a81-4727-9763-2837d930d4a4.jpg"></p><ul><li><code>ldp    x29, x30, [sp], #0x10</code>：读取sp执行地址的数据，放入x29、x30；<code>[sp], #0x10</code> 表示 <code>sp=sp+0x10</code>，以此保证 <code>栈平衡</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165907855-29abbe8d-2cd0-443d-930a-eff32f539872.jpg"></p><p><strong>【结论】</strong>：当有函数嵌套调用时，将上一个函数的地址通过<code> lr（即x30）</code> 放在栈中保存，保证可以找到回家的路，如下图所示</p><p><img src="https://user-images.githubusercontent.com/25925248/165907899-adb6019c-c638-4001-a60a-bf7de51ef164.jpg"></p><p>自定义汇编代码完善：<code>_A中保存回家的路</code><br>所以根据系统的函数嵌套操作，最终在_A中增加了如下汇编代码，用于保存回家的路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--导致死循环的汇编代码--&gt;</span><br><span class="line">_A:</span><br><span class="line">    mov x0. #0xaaaa</span><br><span class="line">    bl _B</span><br><span class="line">    mov x0, #0xaaaa</span><br><span class="line">    ret</span><br><span class="line">    </span><br><span class="line">&lt;!--增加lr保存：可以找到回家的路--&gt;</span><br><span class="line">_A:</span><br><span class="line">    sub sp, sp, #0x10  // 拉伸</span><br><span class="line">    str x30, [sp]     // 存</span><br><span class="line">    mov x0, #0xaaaa</span><br><span class="line">    // 保护lr寄存器，存储到栈区域</span><br><span class="line">    bl _B</span><br><span class="line">    mov x0, #0xaaa</span><br><span class="line">    ldr x30, [sp]      // 修改lr，用于A找到回家的路</span><br><span class="line">    add sp, sp, #0x10 // 栈平衡</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>修改_A、_B：改成简写形式</p><ul><li>其中lr是x30的一个别名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">_A:</span><br><span class="line">    sub sp, sp, #0x10  // 拉伸</span><br><span class="line">    str x30, [sp]      // 存</span><br><span class="line">    mov x0, #0xaaaa</span><br><span class="line">    // 保护lr寄存器，存储到栈区域</span><br><span class="line">    bl _B</span><br><span class="line">    mov x0, #0xaaa</span><br><span class="line">    ldr x30, [sp]      // 修改lr，用于A找到回家的路</span><br><span class="line">    add sp, sp, #0x10  // 栈平衡</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    mov x0, #0xbbbb</span><br><span class="line">    ret</span><br><span class="line">    </span><br><span class="line">&lt;!--改成简写形式--&gt;</span><br><span class="line">_A:</span><br><span class="line">    sub sp, sp, #0x10  // 拉伸</span><br><span class="line">    str x30, [sp]      // 存</span><br><span class="line">    mov x0, #0xaaaa</span><br><span class="line">    // 保护lr寄存器，存储到栈区域</span><br><span class="line">    bl _B</span><br><span class="line">    mov x0, #0xaaa</span><br><span class="line">    // ldr x30, [sp]      // 修改lr，用于A找到回家的路</span><br><span class="line">    // add sp, sp, #0x10  // 栈平衡</span><br><span class="line">    ldr x30, [sp], #0x10  // 将sp的值读取出来，给到x30，然后sp += 0x10</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    mov x0, #0xbbbb</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p><strong>【断点调试】:</strong></p><ul><li><code>str x30, [sp, #-0x10]</code>：查看此时 <code>sp寄存器</code> 的地址 <code>sp = 0x000000016b411a80</code>，<code>lr</code> 的地址 <code>lr = 0x00000001003d9f90</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165907949-dbc11d23-135d-4705-9ace-30b8a04d5615.jpg"></p><ul><li>执行到 <code>mov x0, #0xaaaa</code>：sp变了，lr未变</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165907963-d6fcc34f-c7ab-4503-9594-47fa07e9d8ff.jpg"></p><ul><li>执行 <code>mov x0, #0xaaaa</code>，x0 为 <code>aaaa</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165908041-70f758fc-5728-47c2-ad8f-44f9d45e851e.jpg"></p><ul><li>执行A中的 <code>bl _B</code>：跳转到B，此时 <code>lr = 0x0000000100929f40</code>，<code>x0</code> 变成 <code>bbbb</code>，<code>sp = 0x000000016f4d9a70</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165908095-956b50c9-aff6-4f3f-b83a-9527ca18ec4f.jpg"></p><ul><li>执行B的ret：从B回到A，此时lr还是 <code>lr = 0x0000000100929f40</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165908144-6324ea28-b686-4d75-9eaf-4732275a4cf8.jpg"></p><ul><li>执行A中的 <code>ldr    x30, [sp], #0x10</code>，发现此时 lr变了为 <code>lr = 0x0000000100929f90</code>，sp也变了为 <code>sp = 0x000000016f4d9a80</code>。从这里可以看出，A找到了回家的路</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165908203-9b69e84f-99de-4bcc-9f7d-cec8f83948e1.jpg"></p><h1 id="x30寄存器"><a href="#x30寄存器" class="headerlink" title="x30寄存器"></a>x30寄存器</h1><ul><li><p><code>x30</code> 寄存器 <code>存放</code> 的是 <code>函数的返回地址</code>，当ret指令执行时刻，会寻找x30寄存器保存的地址值</p></li><li><p>注意：<code>在函数嵌套调用时，需要将x30入栈</code></p></li><li><p><code>lr</code> 是 <code>x30</code> 的别名</p></li><li><p><code>sp</code> 栈里面的操作必须是 <code>16字节对齐</code>，崩溃是在栈的操作时挂的</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p><code>栈</code>：是一种具有特殊的访问方式的存储空间（<code>先进后出</code>，Last In First Out，<code>FIFO</code>）</p><ul><li>ARM64里面对 <code>栈的操作</code> 是 <code>16字节对齐</code> 的</li></ul></li><li><p><code>SP和FP寄存器</code></p><ul><li>SP寄存器在任意时刻会 <code>保存栈顶的地址</code></li><li>FP寄存器也称为 <code>x29寄存器</code>，属于 <code>通用寄存器</code>，但是在某些时刻利用它 <code>保存栈底的地址</code></li></ul></li><li><p>栈的读写指令</p><ul><li><p>读：<code>ldr</code>（load register）指令 <code>LDR、LDP</code></p></li><li><p>写：<code>str</code>（store register）指令 <code>STR、STP</code></p></li></ul></li><li><p>汇编练习</p><ul><li><p>指令</p><ul><li><p><code>sub sp，sp，$0x10</code>：拉伸栈空间 <code>16</code> 字节</p></li><li><p><code>stp x0，x1，[sp]</code>：sp所在位置存放x0、x1</p></li></ul></li></ul></li><li><p><code>bl</code> 指令</p><ul><li><p>跳转指令：<code>bl</code> 标号，表示程序执行到标号处。将下一条指令的地址保存到lr寄存器</p></li><li><p><code>B</code> 代表着 <code>跳转</code></p></li><li><p><code>L</code> 表示 <code>lr</code>（x30）寄存器</p></li></ul></li><li><p><code>ret</code> 指令</p><ul><li>类似函数的 <code>return</code></li><li>让CPU执行lr寄存器所指向的指令</li></ul></li><li><p>避免嵌套函数无法回去：需要保护bl（即 <code>lr寄存器，存放回家的路</code> ），保存在当前函数自己的栈空间</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-逆向探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC逆向01：初始汇编</title>
      <link href="/BboyZJ.github.io/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9101%EF%BC%9A%E5%88%9D%E5%A7%8B%E6%B1%87%E7%BC%96/"/>
      <url>/BboyZJ.github.io/2022/04/20/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9101%EF%BC%9A%E5%88%9D%E5%A7%8B%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在逆向开发中，非常重要的一个环节就是 <code>静态分析</code>，众所周知，手机上安装 <code>APP</code> 其本质是一个 <code>二进制文件</code>，因为iPhone手机本质上执行的指令是二进制，是由手机上的 <code>CPU</code> 执行的；而静态分析是建立在分析二进制上面的。所以在学习逆向之前，需要提前了解相关的汇编知识</p><h1 id="汇编语言的发展"><a href="#汇编语言的发展" class="headerlink" title="汇编语言的发展"></a>汇编语言的发展</h1><h2 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h2><p>是由 <code>0和1</code> 组成的机器指令，表示特定的功能，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加：0100 0000</span><br><span class="line">减：0100 1000</span><br><span class="line">乘：1111 0111 1110 0000</span><br><span class="line">除：1111 0111 1111 0000</span><br></pre></td></tr></table></figure><h2 id="汇编语言（assembly-language）"><a href="#汇编语言（assembly-language）" class="headerlink" title="汇编语言（assembly language）"></a>汇编语言（assembly language）</h2><p>由于使用机器语言表示时不方便记忆，于是开始使用 <code>助记符</code> 来代替机器语言，例如下面使用助记符表示的 <code>加减乘除</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加：INC EAX 通过编译器 0100 0000</span><br><span class="line">减：DEC EAX 通过编译器 0100 1000</span><br><span class="line">乘：MUL EAX 通过编译器 1111 0111 1110 0000</span><br><span class="line">除：DIV EAX 通过编译器 1111 0111 1111 0000</span><br></pre></td></tr></table></figure><h2 id="高级语言（High-level-programming-language）"><a href="#高级语言（High-level-programming-language）" class="headerlink" title="高级语言（High-level programming language）"></a>高级语言（High-level programming language）</h2><p>在后期，为了更加高效的编程，在汇编语言的基础上有了更高级的语言，例如：<br><code>C/C++/Java/OC/Swift</code> 等，这些语言更加接近人类的自然语言，例如C语言表示加减乘除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加：A+B 通过编译器 0100 0000</span><br><span class="line">减：A-B 通过编译器 0100 1000</span><br><span class="line">乘：A*B 通过编译器 1111 0111 1110 0000</span><br><span class="line">除：A/B 通过编译器 1111 0111 1111 0000</span><br></pre></td></tr></table></figure><p>最终的代码在终端设备上显示的过程如下：</p><p><img src="https://user-images.githubusercontent.com/25925248/165726946-adfbee49-d243-4a8d-bb37-e62e6defcc52.jpg"></p><p><strong>【说明】：</strong></p><ul><li><p><code>汇编语言</code> 与 <code>机器语言</code> 是 <code>--对应</code> 的关系，每一条机器指令都有与之对应的汇编指令</p></li><li><p><code>汇编语言</code> 可以通过 <code>编译</code> 得到 <code>机器语言</code>，<code>机器语言</code> 可以通过 <code>反编译</code> 得到 <code>汇编语言</code></p></li><li><p><code>高级语言</code> 可以通过 <code>编译</code> 得到 <code>汇编语言/机器语言</code>，但 <code>汇编汇演/机器语言</code> 几乎不可能还原成高级语言</p><ul><li>不同的 <code>高级语言</code> 可以得到 <code>同样的</code> 汇编语言，但是同一个 <code>汇编语言</code> 无法推断出用什么高级语言</li><li>不同的 <code>CPU架构</code>，而CPU架构对应不同的 <code>指令集</code></li></ul></li></ul><h2 id="汇编语言的特点"><a href="#汇编语言的特点" class="headerlink" title="汇编语言的特点"></a>汇编语言的特点</h2><p>汇编语言主要有以下几个特点：</p><ul><li>可以 <code>直接访问、控制</code> 各种硬件设备，比如 <code>存储器、CPU等</code>，能最大限度地发挥硬件的功能</li><li>能够不受编译器的限制，对生成的二进制代码进行完全的控制</li><li>目标代码简短，占用内存少，执行速度快</li><li>汇编指令是机器指令的 <code>助记符</code>，同机器指令一一对应，每一种CPU都有自己的机器指令&#x2F;汇编指令集</li><li>知识点过多，要求过高，需要开发者对CPU等硬件结构有所了解，不易于编写、调式，以及维护</li><li>不区分大小写，例如mov和MOV是一样的</li></ul><h1 id="汇编语言的用途（哥-我学了能干啥？）"><a href="#汇编语言的用途（哥-我学了能干啥？）" class="headerlink" title="汇编语言的用途（哥 我学了能干啥？）"></a>汇编语言的用途（哥 我学了能干啥？）</h1><p>按理说，汇编这么难，为什么还要学呢？以及学了能干什么？</p><h2 id="汇编学习的目的"><a href="#汇编学习的目的" class="headerlink" title="汇编学习的目的"></a>汇编学习的目的</h2><p>任何高级语言最终都会被编译汇编，学习了汇编的相关知识，可以更好的日常开发，学习探索中帮助我们更好的排查问，理解底层运行的机制，大致分为以下几点：</p><ul><li><p>是理解整个计算机系统的最佳起点和最有效途径</p></li><li><p>为编写高效代码打下基础</p></li><li><p>理解代码的本质，例如：</p><ul><li>函数的本质是什么？</li><li>++a底层是如何执行的？</li><li>编译器在底层到底帮我们做了哪些工作？</li><li>DEBUG模式和RELEASE模式到底有哪些地方是不同的？以及被我们忽略的？</li></ul></li></ul><h2 id="汇编使用的场景"><a href="#汇编使用的场景" class="headerlink" title="汇编使用的场景"></a>汇编使用的场景</h2><ul><li><p>可以 <code>编写驱动程序、操作系统</code>，例如Linux内核的某些关键字</p></li><li><p>对性能要求极高的程序或代码片段，可 <code>与高级语言混合使用（称为内联汇编）</code></p></li><li><p>用于 <code>软件安全方面</code></p><ul><li>病毒的分析与防治</li><li>逆向、加壳、脱壳、破解、外挂、免杀、加解密、黑客等</li></ul></li></ul><p>所以综上所述，汇编时所有👨🏻‍💻都需要了解的一门非常重要的语言，这也是为什么大学生中计算机相关专业学生的必修课，就好比修房子，地基稳了，高楼才能平地起</p><h1 id="汇编语言的种类"><a href="#汇编语言的种类" class="headerlink" title="汇编语言的种类"></a>汇编语言的种类</h1><p>目前讨论比较多的汇编语言有：</p><ul><li>8086汇编（8086处理器是16bit的CPU）</li><li>Win32汇编</li><li>Win64汇编</li><li>ARM汇编（嵌入式、Mac、iOS）</li><li>…</li></ul><p>我们iPhone里面用到的是 <code>ARM汇编</code>，但是不同的设备也有差异，因CPU的架构不同</p><p><img src="https://user-images.githubusercontent.com/25925248/165726987-fa4840c7-6978-48ef-9019-1d7fbc6ab5e8.jpg"></p><h1 id="必备常识"><a href="#必备常识" class="headerlink" title="必备常识"></a>必备常识</h1><p>想要学好汇编，需要有以下几个常识：</p><ul><li><p>1、首先需要了解CPU等硬件的架构</p></li><li><p>2、APP&#x2F;程序的执行过程</p></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165727016-89a9e54f-7e6f-498a-af9c-91671afafabb.jpg"></p><ul><li><p>可执行文件：程序&#x2F;APP在本地磁盘的文件</p></li><li><p>image（镜像文件）：可执行文件被装载到内存的文件（在早起，其本质与可执行文件是一模一样的）</p></li><li><p>内存中除了 <code>指令</code>，还有 <code>数据</code>，但都是 <code>0和1</code> 组合，CPU是如何区分的？是通过CPU上的部件CPU寄存器来区分</p></li><li><p>3、硬件相关最为重要的是CPU&#x2F;内存</p></li><li><p>4、在汇编中，大部分指令都是和CPU和内存相关的</p></li></ul><h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><p><code>总线</code> 是CPU和内存之间的桥梁，如下图所示，是iPhoneX上的A11（CPU芯片）</p><p><img src="https://user-images.githubusercontent.com/25925248/165727050-704e6232-9383-4214-b339-64ca301512ab.jpg"></p><p>从图中可以看出：每一个CPU芯片都有很多管脚，这些管脚和总线相连，CPU通过总线跟外部件进行交互</p><p><strong>总线</strong>：是一根根导线的集合</p><h2 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h2><p>总线主要分为三类，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/165727076-6628e0ee-661b-4516-91bd-ef8524869e8c.jpg"></p><ul><li>1、地址总线：CPU是通过地址总线来指定存储单元的</li><li>2、数据总线：CPU与内存&#x2F;其他部件之间的数据传送通道</li><li>3、控制总线：CPU通过控制总线对外部器件进行控制</li></ul><p><strong>举例：CPU从内存的3号单元读取数据</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/165727600-b2d0129f-b2cc-4bae-851f-8a6f8b9ffd05.jpg"></p><ul><li><p>1、CPU想操作内存中的数据，首先需要找到内存地址：CPU通过地址总线，将3这个地址传递给内存你，即寻址到内存的3号单元</p></li><li><p>2、需要操作3号单元的数据，还需要确定是读还是写：CPU通过控制总线告诉内存需要进行的操作，假设是读</p></li><li><p>3、内存知道了CPU想要进行的操作：内存将3号单元的数据通过数据线传递给CPU</p></li></ul><h2 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h2><ul><li><p>它的宽度决定了 <code>CPU的寻址能力</code>，即地址总线决定了CPU所能访问的最大内存空间的大小，例如：<code>10根地址线</code> 能访问的最大内存是 <code>2^10 = 1024</code> 位二进制数据（即 <code>1KB</code> ）</p></li><li><p>地址总线是地址线数量之和</p></li><li><p><code>8086</code> 的 <strong><code>地址总线</code></strong> 宽度是 <code>20</code>，所以寻址能力是 <code>1M（即2^20）</code></p></li><li><p>内存地址的单元是 <code>字节byte（简写B）</code>，每个字节里面可以放 <code>8位（即bit）</code>，以下是内存条的图示：</p></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165727689-82a153ce-e0e0-46e6-873e-4b8391829fd8.jpg"></p><p><strong>注意区分 <code>数量单位</code> 和 <code>容量单位</code></strong></p><ul><li>数量单位：<code>1M = 1024K，1K = 1024</code></li><li>容量单位：字节byte（B） <code>1024B = 1KB，1024KB = 1MB</code>，IBM银行的独立系统是以2字节为一个单位，常用的电脑是以1字节为一个单位</li><li>网络宽带 <code>100M=100Mbps</code>（比特位，每秒传输 <code>100/8 = 12.5MB/s</code>）</li></ul><h2 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h2><ul><li><p>它的宽度决定了 <code>CPU的单次数据传送量（即吞吐量）</code>，也就是 <code>数据传送速度</code> 即CPU和外界数据的传送速度</p></li><li><p>每条数据线一次只能传输一位二进制数据，例如：<code>8根</code> 数据线 <code>一次</code> 可传送 <code>一个8位</code> 二进制数据（即一个字节的数据）</p></li><li><p>数据总线是数据线数量之和</p></li><li><p><code>8086</code> 的 <strong><code>数据总线</code></strong> 总宽度是 <code>16</code>，所以单次最大传送 <code>2个字节</code> 的数据</p></li></ul><p>我们常说的32位（4字节）、64位（8字节）CPU，这里的32、64指的就是数据吞吐量</p><h2 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h2><ul><li><p>它的宽度决定了 <code>CPU对其他器件的控制能力</code>，能有多少中控制，即CPU对外部器件的控制能力</p></li><li><p>控制总线是控制线数量之和</p></li></ul><h1 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h1><ul><li>一个CPU的寻址能力为8KB，那么它的地址总线的宽度为 2^13</li></ul><p>答：我们知道 10根 -&gt; 2^0 -&gt; 1KB，所以，8KB -&gt; 2^3 -&gt; 13根</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><ul><li><p>CPU是通过 <code>总线</code> 和硬件设备连接的</p></li><li><p>内存有RAM主存储器、RAM主存储器（内存条）</p></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165727760-aa6b4190-5ca8-49ca-8a93-3254279f76c3.jpg"></p><ul><li>下图是按照物理地址划分的内存，有 <code>主存储器、显存地址、显卡地址、网卡地址、系统地址</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165727818-8b27a544-53af-4e32-8dd7-a58efab7788e.jpg"></p><p>其中内存中的 <code>低地址</code> 是给 <code>用户用的</code>，<code>高地址</code> 是给 <code>系统用的</code>，如下所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/165727829-aad0e46e-ef9a-4e4f-9d70-410f147c85f8.jpg"></p><ul><li><p>内存地址空间的大小受CPU地址总线宽度的限制，8086的地址总线宽度为20，可以定位2^20个不同的内存单元（内存地址范围0x00000~0xFFFFF），所以8086的内存空间大小为1MB</p></li><li><p><code>0x00000~0x9FFFF</code>：主存储器，<code>可读可写</code></p></li><li><p><code>0xA0000~0xBFFFF</code>：向显存中写入数据，这些数据会被显卡输出到显示器，<code>可读可写</code></p></li><li><p><code>0xC0000~0xFFFFF</code>：存储各种硬件&#x2F;系统信息，<code>只读</code></p></li></ul><h1 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h1><p>很多人学不好进制，原因是总以十进制为依托去考虑其他进制，需要运算的时候也总是先转换为十进制，在转换为其他进制，其实这种方式是错的</p><p>我们为什么一定要转换成十进制呢？仅仅是因为我们对十进制最熟悉，所以才转换</p><p>每一种进制都是完美的，想学号进制首先要忘掉十进制，也要忘掉进制间的转换</p><h2 id="进制的定义"><a href="#进制的定义" class="headerlink" title="进制的定义"></a>进制的定义</h2><ul><li>八进制由8个符号组成：0 1 2 3 4 5 6 7 <code>逢八进一</code></li><li>十进制由10个符号组成：0 1 2 3 4 5 6 7 8 9 <code>逢十进一</code></li><li>N进制就是由N个符号组成：<code>逢N进一</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--练习--&gt;</span><br><span class="line">1+1在___情况下等于3</span><br><span class="line"></span><br><span class="line">&lt;!--答案--&gt;</span><br><span class="line">十进制由10个符号组成: 0 1 3 2 8 A B E S 7 逢十进一</span><br><span class="line">如果这样定义十进制：1+1等于3</span><br><span class="line"></span><br><span class="line">&lt;!--目的--&gt;</span><br><span class="line">传统定义的十进制和自定义的十进制不一样，如果不告诉别人符号表，别人是无法拿到具体的数据的。这样的应用场景主要是用于加密</span><br></pre></td></tr></table></figure><h2 id="进制的运算"><a href="#进制的运算" class="headerlink" title="进制的运算"></a>进制的运算</h2><h3 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h3><p><strong>八进制加法表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0  1  2  3  4  5  6  7 </span><br><span class="line">10 11 12 13 14 15 16 17</span><br><span class="line">20 21 22 23 24 25 26 27</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">1+1 = 2                     </span><br><span class="line">1+2 = 3   2+2 = 4               </span><br><span class="line">1+3 = 4   2+3 = 5   3+3 = 6</span><br><span class="line">1+4 = 5   2+4 = 6   3+4 = 7   4+4 = 10  </span><br><span class="line">1+5 = 6   2+5 = 7   3+5 = 10  4+5 = 11  5+5 = 12</span><br><span class="line">1+6 = 7   2+6 = 10  3+6 = 11  4+6 = 12  5+6 = 13  6+6 =14</span><br><span class="line">1+7 = 10  2+7 = 11  3+7 = 12  4+7 = 13  5+7 = 14  6+7 =15  7+7 = 16</span><br></pre></td></tr></table></figure><p><strong>八进制乘法表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27...</span><br><span class="line">1*1 = 1                     </span><br><span class="line">1*2 = 2   2*2 = 4               </span><br><span class="line">1*3 = 3   2*3 = 6   3*3 = 11    </span><br><span class="line">1*4 = 4   2*4 = 10  3*4 = 14  4*4 = 20</span><br><span class="line">1*5 = 5   2*5 = 12  3*5 = 17  4*5 = 24  5*5 = 31</span><br><span class="line">1*6 = 6   2*6 = 14  3*6 = 22  4*6 = 30  5*6 = 36  6*6 = 44</span><br><span class="line">1*7 = 7   2*7 = 16  3*7 = 25  4*7 = 34  5*7 = 43  6*7 = 52  7*7 = 61</span><br></pre></td></tr></table></figure><p><strong>做个练习</strong></p><ul><li>2 + 3 &#x3D; ___，2 * 3 &#x3D; ___，4 + 5 &#x3D; ___，4 * 5 &#x3D; ___</li><li>277 + 333 &#x3D; ___，276 * 54 &#x3D; ___， 237 - 54 &#x3D; ___ ，234&#x2F;4 &#x3D; ___</li></ul><p>第一排的计算，我们可以很好的得出结论<br>但是第二排涉及数据较大，如何计算呢？下面以 <code>277 + 333</code> 为例，计算过程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">实际上是以加法表为基本的每个位置相加</span><br><span class="line">   277      最后一位相加   倒数第二位相加    第一位相加</span><br><span class="line">+  333  -&gt;   7+3=12   -&gt;  7+3=12     -&gt;  2+3=5  -&gt; 所以最后的结果是632</span><br><span class="line">            保留2进1     保留2+1=3，进1    保留5+1=6</span><br></pre></td></tr></table></figure><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p><strong>二进制的简写形式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">       二进制: 1 0 1 1 1 0 1 1 1 1 0 0</span><br><span class="line">三个二进制一组: 101 110 111 100</span><br><span class="line">       八进制:   5   6   7   4</span><br><span class="line">四个二进制一组: 1011 1011 1100</span><br><span class="line">     十六进制:    b    b    c</span><br></pre></td></tr></table></figure><p>使用二进制从0到1111：0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111</p><p>发现这样使用二进制太麻烦，所以将其改为更简单一点的符号</p><p>0 1 2 3 4 5 6 7 8 9 A B C D E F 这就是十六进制了</p><h1 id="数据的宽度"><a href="#数据的宽度" class="headerlink" title="数据的宽度"></a>数据的宽度</h1><p>数学上的数字是没有大小限制的，可以无限大</p><p>但是在计算机中，由于硬件的制约，数据都是有长度限制的（称为 <code>数据宽度</code>），超过最多宽度的数据会被丢弃</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;AppDelegate.h&quot;</span><br><span class="line"></span><br><span class="line">int test()&#123;</span><br><span class="line">    int cTemp = 0x1FFFFFFFF;</span><br><span class="line">    return cTemp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    printf(&quot;%x\n&quot;,test());</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打断点在 <code>int cTemp</code> 处和 <code>return cTemp</code> 处，调试结果发现 <code>0</code> 溢出了：</p><p><img src="https://user-images.githubusercontent.com/25925248/165728027-c014f88f-9705-4007-9612-b990a9d189f3.jpg"></p><p>也可以此处通过获取的地址，然后在 <code>Debug-Debug Workflow-ViewMemory</code> 中输入地址（0x000000016d82f70c） 查看</p><p><img src="https://user-images.githubusercontent.com/25925248/165728053-0edd1b4c-c9c1-4d31-91b1-d89eaa9096eb.jpg"></p><h1 id="计算机中常见的数据宽度"><a href="#计算机中常见的数据宽度" class="headerlink" title="计算机中常见的数据宽度"></a>计算机中常见的数据宽度</h1><ul><li><code>位（bit）</code>：<code>1个位</code> 就是 <code>1个二进制</code>，即 <code>0或1</code></li><li><code>字节（byte）</code>：<code>1个字节</code> 由 <code>8个bit</code> 组成，内存中的最小单元byte</li><li><code>字（Word）</code>：<code>1个字</code> 由 <code>两个字节</code> 组成（16位），第2个字节分别称为 <code>高字节和低字节</code></li><li><code>双字（DoubleWork）</code>：1个双字由两个字组成（32位）</li></ul><p>那么计算机存储数据它分为 <code>有符号数和无符号数</code>，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/165728076-10923f99-2ad9-4eb9-a5d6-b514baad4efd.jpg"></p><ul><li><p>无符号数，直接换算</p></li><li><p>有符号数，符号放在第1位，第1位是0即 <code>正数</code>，为1即 <code>负数</code>：</p><ul><li>正数：0  1  2  3  4  5  6  7</li><li>负数：F  E  D  C  B  A  9  8<br>-1 -2 -3 -4 -5 -6 -7 -8</li></ul></li></ul><h1 id="自定义进制符号"><a href="#自定义进制符号" class="headerlink" title="自定义进制符号"></a>自定义进制符号</h1><p><strong>【练习1】</strong></p><p>现在有10进制数10个符号分别为：2，9，1，7，6，5，4，8，3，A <code>逢10进1</code>，那么：</p><p>123 + 234 &#x3D; （AA6）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">十进制:    0  1  2  3  4  5  6  7  8  9</span><br><span class="line">自定义:    2  9  1  7  6  5  4  8  3  A</span><br><span class="line">(十进制10)92 99 91 97 96 95 94 98 93 9A</span><br><span class="line">         12 19 11 17 16 15 14 18 13 1A</span><br><span class="line">         72 79 71 77 76 75 74 78 73 7A</span><br><span class="line">         62 69 61 67 66 65 64 68 63 6A</span><br><span class="line">         52 59 51 57 56 55 54 58 53 5A</span><br><span class="line">         42 49 41 47 46 45 44 48 43 4A</span><br><span class="line">         82 89 81 87 86 85 84 88 83 8A</span><br><span class="line">         32 39 31 37 36 35 34 38 33 3A</span><br><span class="line">         922</span><br><span class="line">         </span><br><span class="line">(00)2  (01)9  (02)1  (03)7  (04)6  (05)5  (06)4  (07)8  (08)3  (09)A</span><br><span class="line">(10)92 (11)99 (12)91 (13)97 (14)96 (15)95 (16)94 (17)98 (18)93 (19)9A</span><br><span class="line">(20)12 (21)19 (22)11 (23)17 (24)16 (25)15 (26)14 (27)18 (28)13 (29)1A</span><br><span class="line">(30)72 (31)79 (32)71 (33)77 (34)76 (35)75 (36)74 (37)78 (38)73 (39)7A</span><br><span class="line">(40)62 (41)69 (42)61 (43)67 (44)66 (45)65 (46)64 (47)68 (48)63 (49)6A</span><br><span class="line">(50)52 59 51 57 56 55 54 58 53 5A</span><br><span class="line">(60)42 49 41 47 46 45 44 48 43 4A</span><br><span class="line">(70)82 89 81 87 86 85 84 88 83 8A</span><br><span class="line">(80)32 39 31 37 36 35 34 38 33 3A</span><br><span class="line">(90)922</span><br></pre></td></tr></table></figure><p>刚才通过10进制运算可以转换，然后查表，但是如果是其他进制，就不能转换，要学会直接查表。</p><p><code>【练习2】</code></p><p>现在有9进制数9个符号，分别是：2，9，1，7，6，5,4，8，3 <code>逢9进1</code>，那么：123 + 234 &#x3D; （9926）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">十进制:    0  1  2  3  4  5  6  7  8  </span><br><span class="line">自定义:    2  9  1  7  6  5  4  8  3  </span><br><span class="line">         92 99 91 97 96 95 94 98 93 </span><br><span class="line">         12 19 11 17 16 15 14 18 13 </span><br><span class="line">         72 79 71 77 76 75 74 78 73 </span><br><span class="line">         62 69 61 67 66 65 64 68 63 </span><br><span class="line">         52 59 51 57 56 55 54 58 53 </span><br><span class="line">         42 49 41 47 46 45 44 48 43 </span><br><span class="line">         82 89 81 87 86 85 84 88 83 </span><br><span class="line">         32 39 31 37 36 35 34 38 33 </span><br><span class="line">         922</span><br><span class="line">         </span><br><span class="line">(00)2  (01)9  (02)1  (03)7  (04)6  (05)5  (06)4  (07)8  (08)3  </span><br><span class="line">(10)92 (11)99 (12)91 (13)97 (14)96 (15)95 (16)94 (17)98 (18)93 </span><br><span class="line">(20)12 19 11 17 16 15 14 18 13 </span><br><span class="line">(30)72 79 71 77 76 75 74 78 73 </span><br><span class="line">(40)62 69 61 67 66 65 64 68 63 </span><br><span class="line">(50)52 59 51 57 56 55 54 58 53 </span><br><span class="line">(60)42 49 41 47 46 45 44 48 43 </span><br><span class="line">(70)82 89 81 87 86 85 84 88 83 </span><br><span class="line">(80)32 39 31 37 36 35 34 38 33 </span><br><span class="line">(90)922 ...</span><br></pre></td></tr></table></figure><h1 id="CPU和寄存器"><a href="#CPU和寄存器" class="headerlink" title="CPU和寄存器"></a>CPU和寄存器</h1><h2 id="内部部件之间是由-总线-连接，如下图所示："><a href="#内部部件之间是由-总线-连接，如下图所示：" class="headerlink" title="内部部件之间是由 总线 连接，如下图所示："></a>内部部件之间是由 <code>总线</code> 连接，如下图所示：</h2><p><img src="https://user-images.githubusercontent.com/25925248/165728280-ea4489e6-4f36-48d9-80fb-72c8285be4b8.jpg"></p><ul><li><p>CPU除了有 <code>控制器、运算器</code>，还有 <code>寄存器</code>，其中寄存器的作用就是 <code>运行数据的临时存储</code></p></li><li><p>CPU的运算速度是非常快的，为了性能 <code>CPU</code> 在内部 <code>开辟了一小块临时存储区域</code>，并在进行运算时先将数据从内存中 <code>复制</code> 到这一小块临时区域中，运算就在这一小块临时存储区进行，称这一小块临时存储区域为 <code>寄存器</code></p></li></ul><p><strong>【针对arm64的CPU来说】</strong></p><ul><li><p>如果寄存器以 <code>x</code> 开头，则表明是一个 <code>64位（84/8=8字节）的寄存器z</code>。</p></li><li><p>如果寄存器以 <code>w</code> 开头，则表明是一个 <code>32位（32/8=4字节） 的寄存器</code></p></li></ul><p>在系统中没有提供16位和32位的寄存器供访问和使用，其中 <code>32位的寄存器是64位寄存器的低32位的部分，并不是独立存在的</code></p><ul><li><p>对于程序来说，CPU中最主要的部件是 <code>寄存器</code>，可以通过改变寄存器的内容来实现对CPU的控制</p></li><li><p>不同CPU，寄存器的个数和结构是不相同的</p></li></ul><h2 id="查看寄存器"><a href="#查看寄存器" class="headerlink" title="查看寄存器"></a>查看寄存器</h2><p>默认情况下是不显示的，如下图：</p><p><img src="https://user-images.githubusercontent.com/25925248/165869573-4525b548-a1d3-4756-96cf-8895ed7cf905.jpg"></p><p>选中后，会出现三种寄存器，如下图：</p><p><img src="https://user-images.githubusercontent.com/25925248/165869628-55c98904-1a7b-45be-9b97-3b5dcb4a6819.jpg"></p><h2 id="浮点和向量寄存器"><a href="#浮点和向量寄存器" class="headerlink" title="浮点和向量寄存器"></a>浮点和向量寄存器</h2><p>因为浮点数的存储以及其运算的特殊性，CPU中专门提供 <code>浮点寄存器</code> 来处理浮点数</p><ul><li><p>浮点寄存器</p><ul><li><code>64位：D0-D31</code></li><li><code>32位：S0-S31</code></li></ul></li></ul><p>现在 <code>CPU支持向量运算</code>（向量运算在图形处理相关的领域用的非常多），为了支持向量计算，系统也提供了众多的向量寄存器</p><ul><li>向量寄存器 <code>128</code> 位：<code>V0 - V31</code></li></ul><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><ul><li>通用寄存器也称为 <code>数据地址寄存器</code>。通常用来 <code>做数据计算的临时存储、累加、计数、地址保存等功能</code>。定义这些寄存器的作用主要是用于在CPU指令中保存操作数，在CPU中当做一些常规变量来使用</li></ul><p>ARM64中</p><ul><li><p>64位：x0-x30，XZR(寄存器)</p></li><li><p>32位：W0-W30,WZR(零寄存器)</p></li><li><p>arm64拥有 <code>32个64位的通用寄存器X0-X30</code>，以及XZR（零寄存器）。这些通用寄存器有时也有特定用途</p><ul><li>那么 <code>w0-w28</code> 这些32位的，因为64位CPU可以兼容32位，所以可以只使用64位寄存器的低32位</li><li>例如 w0就是x0的低32位</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：了解过8086汇编的一定知道，还有一种特殊的寄存器段寄存器：CS、DS、SS 、ES。这四个寄存器主要用来保存这些段的基地址，是属于Intel架构的CPU的，在arm中并没有</span><br></pre></td></tr></table></figure><ul><li>通常，<code>CPU会先将内存中的数据存储到通用寄存器中，然后再对寄存器中的数据进行运算</code></li></ul><p><strong>例子：假设内存中有块红色内存空间的值是3，现在想把它的值加1，并将结果存储到蓝色内存空间，如何做呢？</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/165869665-b5c60699-e697-4bf4-86c8-f44b04a2f110.jpg"></p><ul><li><p>CPU首先会将红色内存空间的值放到X0寄存器中：<code>mov X0，红色内存空间</code></p></li><li><p>然后让X0寄存器与1相加：<code>add X0,1</code></p></li><li><p>最后将值赋值给内存空间：<code>mov 蓝色内存空间，X0</code></p></li></ul><h2 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h2><ul><li><p>为 <code>指令指针寄存器</code>，它 <code>指示了CPU当前要读取指令的地址</code></p></li><li><p>在内存&#x2F;磁盘中，指令和数据没有任何区别，都是二进制信息</p></li><li><p>CPU在工作时，将有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义</p><ul><li>例如 1110 0000 0000 0011 0000 1000 1010 1010</li><li>可以当做数据 0xE003008AA</li><li>也可以当做指令 mov x0,x8</li></ul></li><li><p>CPU根据什么将内存中的信息看作指令呢？</p><ul><li>CPU将pc指向的内存单元的内容看作指令</li><li>如果内存中的某段内容曾经被CPU执行过，那么它所在的内存单元必然被pc指向过</li></ul></li></ul><h2 id="寄存器的案例分析"><a href="#寄存器的案例分析" class="headerlink" title="寄存器的案例分析"></a>寄存器的案例分析</h2><p>下面通过以下代码的例子来分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;AppDelegate.h&quot;</span><br><span class="line"></span><br><span class="line">int test()&#123;</span><br><span class="line">    int cTemp = 0x1FFFFFFFF;</span><br><span class="line">    return cTemp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    printf(&quot;%x\n&quot;,test());</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以下是demo的汇编图示</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165869709-c46f0372-2441-4bdf-a72e-a860054e5c21.jpg"></p><h2 id="pc寄存器调式"><a href="#pc寄存器调式" class="headerlink" title="pc寄存器调式"></a>pc寄存器调式</h2><ul><li>打印 <code>pc</code> 寄存器，现在是 <code>d613c</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165869741-6018575b-f46d-4707-89df-3a8b14cbc860.jpg"></p><ul><li>按住 <code>control+Setp into</code>，继续打印</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165869775-99c49a8f-ad8a-4cc5-a976-e5fae67e038a.jpg"></p><p><strong>除了读还可以写:</strong></p><ul><li><code>register write pc</code> 0x1025d6134</li><li><code>register read pc</code> 此时是读不出来的，因为断点断住了，如果step into ，此时断点断在哪里？</li></ul><h1 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h1><p>iPhoneX上搭载的arm处理器 <code>A11</code>，它的1级缓存的容量是64Kb，2级缓存的容量是8M</p><p>CPU每执行一条指令前都需要从内存中将指令读取到CPU内存并执行，而寄存器的运行速度相比内存读写要快很多，为了性能，CPU还集成了一个<code> 高速缓存区域</code>。当程序运行时，先将要执行的指令代码以及数据复制到高速缓存中（由操作系统完成），然后CPU直接从高速缓存依次读取指令来执行</p><h1 id="bl指令"><a href="#bl指令" class="headerlink" title="bl指令"></a>bl指令</h1><ul><li>CPU从何处执行指令，是由pc中的内容决定的，可以 <code>通过改变pc的内容来控制CPU执行目标指令</code></li><li>arm64提供了一个 <code>mov指令（传送指令）</code>，可以用来改变大部分寄存器的值，例如 mov x0,#10、mov x1,#20</li><li>但是，<code>mov指令并不能用于设置pc的值</code>，arm64没有提供这样的功能</li><li>arm64提供了另外的指令来 <code>修改pc的值</code>，这些指令统一称为 <code>转移指令</code>，其中最简单的是 <code>bl指令</code></li></ul><h2 id="bl指令练习"><a href="#bl指令练习" class="headerlink" title="bl指令练习"></a>bl指令练习</h2><p>现在有两段代码，假设程序先执行A，请写出指令执行顺序，最终寄存器x0的值是多少？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_A:</span><br><span class="line">    mov x0,#0xa0</span><br><span class="line">    mov x1,#0x00</span><br><span class="line">    add x1, x0, #0x14</span><br><span class="line">    mov x0,x1</span><br><span class="line">    bl _B</span><br><span class="line">    mov x0,#0x0</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">_B:</span><br><span class="line">    add x0, x0, #0x10</span><br><span class="line">    ret</span><br><span class="line">    </span><br><span class="line">// 分析流程</span><br><span class="line">流程：</span><br><span class="line">    mov x0,#0xa0            -- x0：0xa0</span><br><span class="line">    mov x1,#0x00            -- x1：0x00</span><br><span class="line">    add x1, x0, #0x14       -- x1：0xa0+0x14=0xb4</span><br><span class="line">    mov x0,x1               -- x0：0xb4</span><br><span class="line">    bl _B                   -- 跳转到B</span><br><span class="line">    add x0, x0, #0x10       -- x0：0xb4+0x10=0xc4</span><br><span class="line">    ret                     -- 回到bl跳转的下一行</span><br><span class="line">    mov x0,#0x0             -- x0：0x00</span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">x0的值：0x00</span><br></pre></td></tr></table></figure><h2 id="汇编代码验证"><a href="#汇编代码验证" class="headerlink" title="汇编代码验证"></a>汇编代码验证</h2><p>下面来写一段汇编代码验证（<code>command + n -&gt; empty -&gt; asm.s</code>）（汇编代码文件，会编译成源码）</p><p><img src="https://user-images.githubusercontent.com/25925248/165869808-cf91c5f3-44ea-4f0d-88e6-19b78eb280ee.jpg"></p><p><strong>如何执行呢？</strong></p><ul><li>在VC中定义函数的声明</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165869834-2365f962-dda1-44e5-adcf-1ed24107fa45.jpg"></p><ul><li>在 <code>mov x0,#0xa0</code> 执行处加断点，并执行程序，开启汇编调试</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165869839-291c742f-38bc-49c6-988f-d2a8c976b4fd.jpg"></p><ul><li>按住 <code>control+step into</code>，进入A的具体汇编</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165869877-ebc46aba-5209-4986-b023-f210d9b32e9f.jpg"></p><ul><li>继续 <code>control+step into</code>，到 <code>bl _B</code> 处</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165869882-6959cbeb-3d3f-4cf4-a8fa-9f4b3e1a9b7a.jpg"></p><ul><li>按住 <code>control+step into</code>，进入汇编代码B</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165869927-66fa0327-0254-43b5-a651-717ac52a3c1f.jpg"></p><ul><li>执行到A的ret</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/165869968-6540f722-de14-4863-8cca-29f49c5c7c0c.jpg"></p><p><strong>疑问：</strong> 发现走到这里死循环了，这是为什么呢？预知后事如何，请看下一篇</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>1、汇编概述</p><ul><li><p>使用 <code>助记符代替机器指令</code> 的一种编程语言</p></li><li><p>汇编和机器指令是 <code>一一对应</code> 的关系，拿到二进制就可以反汇编</p></li><li><p>由于汇编和CPU的指令集是对应的，所以汇编不具备移植性</p></li></ul></li><li><p>2、总线：是由一堆导线的集合</p><ul><li><p><code>地址总线</code>：其宽度决定了寻址能力</p></li><li><p><code>数据总线</code>：其宽度决定了CPU数据的吞吐量</p></li><li><p><code>控制总线</code>：其宽度决定了CPU对其他器件的控制能力</p></li></ul></li><li><p>3、进制</p><ul><li><p>任意进制都是由对应个数的符号组成的，符号可以自定义</p></li><li><p>2&#x2F;8&#x2F;16是相对完美的进制，他们之间的关系</p></li><li><p><code>3</code> 个二进制使用一个 <code>8进制</code> 标识</p></li><li><p><code>4</code> 个二进制使用一个 <code>16进制</code> 标识</p></li><li><p>两个16进制可以标识一个字节，即8位</p></li></ul></li><li><p>数量单位</p><p>  1024 &#x3D; 1k，1024k &#x3D; 1M，1024M &#x3D; 1G</p></li><li><p>容量单位</p><p>  1024 &#x3D; 1KB，1024KB &#x3D; 1MB，1024MB &#x3D; 1GB</p></li><li><p>数据的宽度</p><p>  计算机中的数据是有宽度的，超过了就会溢出</p></li><li><p>4、<code>寄存器</code>：CPU为了性能，自内部开辟了一小块临时存储区域</p><ul><li><p><code>浮点向量寄存器</code>：用于浮点数&#x2F;向量的存储及运算</p></li><li><p><code>异常状态寄存器</code></p></li><li><p><code>通用寄存器</code>：除了存放数据有时也有特殊的用途</p><ul><li><p>ARM64拥有32个64位的通用寄存器 <code>X0-X30</code> 以及XZR（零寄存器）</p></li><li><p>为了兼容32位，所以arm64位拥有 <code>W0-W28</code> 以及WZR 30个32位寄存器</p></li><li><p>32位寄存器并不是独立存在的，例如 W0是X0的低32位</p></li></ul></li><li><p><code>PC寄存器</code>：指令指针寄存器</p><ul><li><p>PC寄存器里面的值保存的就是CPU接下来需要执行的指令地址</p></li><li><p>改变PC的值可以改变程序的执行流程</p></li><li><p>mov指令不能更改PC寄存器的值，需要通过bl跳转指令来改变PC寄存器的值</p></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-逆向探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC逆向11：代码注入（下）</title>
      <link href="/BboyZJ.github.io/2022/02/08/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9111%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/BboyZJ.github.io/2022/02/08/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9111%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OC-逆向探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC逆向11：代码注入（上）</title>
      <link href="/BboyZJ.github.io/2022/02/08/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9111%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/BboyZJ.github.io/2022/02/08/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9111%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要讲解代码注入的两种方式： <code>Framework注入、dylib注入</code></p><h1 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h1><p>一般修改原始的程序，是 <code>利用代码注入</code> 的方式，注入代码就会选择利用 <code>Framework</code> 或者 <code>dylib</code> 等三方库的方式注入</p><ul><li>查看Mach-O文件</li></ul><p>在了解注入前，我们首先需要了解 ipa包 中的静态库是如何注入的，有以下两种方式查看Mach-O可执行文件</p><pre><code>* 终端命令：otool -l Demo* MachOView 二进制文件分析工具（注：分析时可能出现无法分析的情况，可以通过CMD + O打开）</code></pre><p><code>Mach-O</code> 文件中主要看 <code>load Commands（即加载命令集）</code>，从这里可以看出动态库的加载等，其中大部分格式为：LC_LOAD_DYLIB（xxx），是在指定路径下加载xxx，如下所示</p><p><img src="/BboyZJ.github.io/assets/16443094108857.jpg"></p><p>所以，综上所述，如果需要注入代码，是 <code>以动态库的形式注入</code></p><h1 id="方式一：Framework手动注入"><a href="#方式一：Framework手动注入" class="headerlink" title="方式一：Framework手动注入"></a>方式一：Framework手动注入</h1><ol><li>第一步：动态库进入App包，即Framework注入</li></ol><ul><li>创建一个 <code>Framework</code>，命令为ZJHook（创建位置：<code>target -&gt; + -&gt; ios -&gt; Framework</code>）</li></ul><p><img src="/BboyZJ.github.io/assets/16443096456885.jpg"></p><ul><li>在 ZJHook中创建 <code>inject</code> 文件，在声明周期方法load函数中写注入代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+(void)load&#123;</span><br><span class="line">    NSLog(@&quot;CJLHook ------ 注入成功&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译工程<code>Demo</code>（注：这里的工程依然需要重签名），然后查看工程的可执行文件Demo，查找其中的<code>Frameworks</code>，从这里可以看到<code>ZJHook</code>，但是此时并不会执行其中的load函数</li></ul><p><img src="/BboyZJ.github.io/assets/16443110052513.jpg"></p><p><code>load不会执行的原因</code>：查看此时的Mach-O文件中的 Load Commands，并没有发现ZJHook，随意此时是不会执行其中的load函数的</p><ol start="2"><li>第二步：yololib手动注入，修改Mach-O字段</li></ol><ul><li>通过yololib工具修改Mach-O字段：.&#x2F;yololib Demo Frameworks&#x2F;ZJHook.framework&#x2F;ZJHook（注：需要将Demo可执行文件拷贝过来）</li></ul><h1 id="方式2：dylib注入"><a href="#方式2：dylib注入" class="headerlink" title="方式2：dylib注入"></a>方式2：dylib注入</h1><p>准备工作：创建一个空工程，并进行Demo的重签名，可以参考这篇文件iOS逆向10：应用重签名（下）</p><p><strong>dylib注入</strong></p><ul><li><p>选择 <code>target -&gt; + &gt; mac os -&gt; Library</code> ，命名为 <code>ZJHook</code></p></li><li><p>在 <code>Build Setting</code> 中配置 <code>ZJHook</code></p><ul><li><code>Base SDK</code>  改为 <code>ios</code></li><li><code>Code Signing identify</code> 改为 <code>iOS Developer</code></li></ul></li><li><p>当前工程拷贝 lib</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-逆向探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC逆向12：Mach-O文件（下）</title>
      <link href="/BboyZJ.github.io/2022/01/25/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9112%EF%BC%9AMach-O%E6%96%87%E4%BB%B6%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/BboyZJ.github.io/2022/01/25/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9112%EF%BC%9AMach-O%E6%96%87%E4%BB%B6%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要介绍Mach-O的结构演示</p><h1 id="Mach-O内部结构"><a href="#Mach-O内部结构" class="headerlink" title="Mach-O内部结构"></a>Mach-O内部结构</h1><p>因为Mach-O文件本身是一种文件格式，所以我们一定需要了解其文件内部结构，其内部结构如下图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/152944951-e0b4435a-4a9e-476c-bd3a-fc7df90b7205.jpg"></p><p><code>Mach-O</code> 的组成结构主要分为 <code>三部分</code></p><ul><li><p><code>Header</code> 包含该 二进制文件的一般信息</p><ul><li>字节顺序、结构类型、加载指令的数量等</li><li>使得可以快速确认一些信息，比如当前文件用于32位还是64位，对应的处理器是什么？文件类型是什么？</li></ul></li><li><p><code>Load commands</code> （加载命令）一张包含很多内容的表</p><ul><li>内容包括 <code>区域的位置、符号表、动态符号表</code> 等</li></ul></li><li><p><code>Data</code>（数据）通常是对象文件中最大的部分</p><ul><li>包含 <code>Segment</code> 的具体 <code>数据</code>，首先是 <code>分段</code>，然后段中 <code>分节</code></li></ul></li></ul><h1 id="终端命令：otool"><a href="#终端命令：otool" class="headerlink" title="终端命令：otool"></a>终端命令：otool</h1><p>在终端中，我们通过 <code>otool</code> 查看Mach-O的一些指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> % otool</span><br><span class="line">Usage: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool [-arch arch_type] [-fahlLDtdorSTMRIHGvVcXmqQjCP] [-mcpu=arg] [--version] &lt;object file&gt; ...</span><br><span class="line">-f print the fat headers</span><br><span class="line">-a print the archive header</span><br><span class="line">-h print the mach header</span><br><span class="line">-l print the load commands</span><br><span class="line">-L print shared libraries used</span><br><span class="line">-D print shared library id name</span><br><span class="line">-t print the text section (disassemble with -v)</span><br><span class="line">-x print all text sections (disassemble with -v)</span><br><span class="line">-p &lt;routine name&gt;  start dissassemble from routine name</span><br><span class="line">-s &lt;segname&gt; &lt;sectname&gt; print contents of section</span><br><span class="line">-d print the data section</span><br><span class="line">-o print the Objective-C segment</span><br><span class="line">-r print the relocation entries</span><br><span class="line">-S print the table of contents of a library (obsolete)</span><br><span class="line">-T print the table of contents of a dynamic shared library (obsolete)</span><br><span class="line">-M print the module table of a dynamic shared library (obsolete)</span><br><span class="line">-R print the reference table of a dynamic shared library (obsolete)</span><br><span class="line">-I print the indirect symbol table</span><br><span class="line">-H print the two-level hints table (obsolete)</span><br><span class="line">-G print the data in code table</span><br><span class="line">-v print verbosely (symbolically) when possible</span><br><span class="line">-V print disassembled operands symbolically</span><br><span class="line">-c print argument strings of a core file</span><br><span class="line">-X print no leading addresses or headers</span><br><span class="line">-m don&#x27;t use archive(member) syntax</span><br><span class="line">-B force Thumb disassembly (ARM objects only)</span><br><span class="line">-q use llvm&#x27;s disassembler (the default)</span><br><span class="line">-Q use otool(1)&#x27;s disassembler</span><br><span class="line">-mcpu=arg use `arg&#x27; as the cpu for disassembly</span><br><span class="line">-j print opcode bytes</span><br><span class="line">-P print the info plist section as strings</span><br><span class="line">-C print linker optimization hints</span><br><span class="line">--version print the version of /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>查看Mach-O的header信息：<code>otool -f Demo</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">% cd /Users/zhangjian/Library/Developer/Xcode/DerivedData/Demo-edwjvapoqaffzeeiyzyhfryhfrsr/Build/Products/Release-iphoneos/Demo.app zhangjian@zhangjiandeMBP Demo.app % otool -f Demo</span><br><span class="line">Fat headers</span><br><span class="line">fat_magic 0xcafebabe</span><br><span class="line">nfat_arch 3</span><br><span class="line">architecture 0</span><br><span class="line">    cputype 12</span><br><span class="line">    cpusubtype 9</span><br><span class="line">    capabilities 0x0</span><br><span class="line">    offset 16384</span><br><span class="line">    size 79280</span><br><span class="line">    align 2^14 (16384)</span><br><span class="line">architecture 1</span><br><span class="line">    cputype 12</span><br><span class="line">    cpusubtype 11</span><br><span class="line">    capabilities 0x0</span><br><span class="line">    offset 98304</span><br><span class="line">    size 79280</span><br><span class="line">    align 2^14 (16384)</span><br><span class="line">architecture 2</span><br><span class="line">    cputype 16777228</span><br><span class="line">    cpusubtype 0</span><br><span class="line">    capabilities 0x0</span><br><span class="line">    offset 180224</span><br><span class="line">    size 80000</span><br><span class="line">    align 2^14 (16384)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="MachOView-软件"><a href="#MachOView-软件" class="headerlink" title="MachOView 软件"></a>MachOView 软件</h1><ul><li><p>首先 Show in finder 找到Demo.app程序包 -&gt; 右键显示包内容 -&gt; 找打exex可执行文件</p></li><li><p>将demo拖拽到 MachOView 查看 Mach-O 文件</p></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/152945054-6272275f-3742-45c8-9f45-7a8dcd08e1a6.jpg"></p><ul><li>验证 ARM-V7 与 ARM_V7S  之间是否是分页？</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/152945122-c621d978-0b67-4f98-a28b-95a9ddc44d78.jpg"></p><pre><code>* ARM_V7 与 ARM_V7S 的差值：16384 + 79280 - 98304 = -2640* ARM_V7 的大小：-2640 - 79280 = -81920，查看这个值是否 pageSize(4096)的倍数* 是否是PageSize的倍数：91920/4096 = -20（MacOs中），但是由于是iOS，所以 20/4 = 5页，说明是分页了，即按页对齐</code></pre><h1 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h1><ul><li>otool 与 MachOView 查看的Mach-O进行对比</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/152945261-e2b14d64-d084-4493-882b-444b7fe778ca.jpg"></p><h1 id="MachOView演示"><a href="#MachOView演示" class="headerlink" title="MachOView演示"></a>MachOView演示</h1><p>通过 <code>MachOView</code> 查看Mach-O结构，分为三部分：<code>Header、Load Commands、Data</code></p><p><img src="https://user-images.githubusercontent.com/25925248/152945321-b9275a16-f95b-40a8-8bb4-fd6b0dddf538.jpg"></p><ul><li>查看 arm64 下 Mach-O 的header</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/152945395-a24af1cf-0bb2-4efa-b9c6-63f96c50ac09.jpg"></p><ul><li>查看 Load Commands</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/152945649-42956103-9867-4044-9ead-7aedbd74866c.jpg"></p><pre><code>* VM Addr：虚拟内存地址* VM Size：虚拟内存大小，在运行时，在内存中的大小，4g    * 64位地址：0x12345678a2345678    * 32位地址：0x12345678* File offset：数据在文件中偏移量* File size：数据在文件中的大小</code></pre><ul><li>Section 中分为两大类：<code>__TEST（代码）、__DATA（数据）</code></li></ul><h1 id="Header-的数据结构"><a href="#Header-的数据结构" class="headerlink" title="Header 的数据结构"></a>Header 的数据结构</h1><ul><li>在 <code>CMD + shift + O</code> 搜索 <code>loader.h</code>，找到 <code>Mach_Header_64</code>（arm64架构）的数据结构如下所示，与 <code>mach_header</code> 相比，只是多了一个 <code>reverse</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 1.mach_header</span><br><span class="line">struct mach_header &#123;</span><br><span class="line">uint32_tmagic;/* 魔数，快速定位属于64位还是32位 */</span><br><span class="line">cpu_type_tcputype;/* cpu类型 */</span><br><span class="line">cpu_subtype_tcpusubtype;/* cpu具体类型 */</span><br><span class="line">uint32_tfiletype;/* 文件类型 */</span><br><span class="line">uint32_tncmds;/* Load commands的条数 */</span><br><span class="line">uint32_tsizeofcmds;/* Load commands的大小 */</span><br><span class="line">uint32_tflags;/* 标志位标识二进制文件支持的功能，主要是和系统加载、链接有关 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 2.mach_header_64</span><br><span class="line">struct mach_header_64 &#123;</span><br><span class="line">uint32_tmagic;/* 魔数，快速定位属于64位还是32位 */</span><br><span class="line">cpu_type_tcputype;/* cpu类型 */</span><br><span class="line">cpu_subtype_tcpusubtype;/* cpu具体类型 */</span><br><span class="line">uint32_tfiletype;/* 文件类型 */</span><br><span class="line">uint32_tncmds;/* Load commands的条数 */</span><br><span class="line">uint32_tsizeofcmds;/* Load commands的大小 */</span><br><span class="line">uint32_tflags;/* 标志位标识二进制文件支持的功能，主要是和系统加载、链接有关 */</span><br><span class="line">uint32_treserved;/* reserved */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>查看filetype种类</p><ul><li>OC文件：<code>#define MH_OBJECT 0x1</code></li><li>可执行文件：<code>#define MH_EXECUTE 0x2</code></li><li>…</li></ul></li></ul><h1 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h1><p>Load Commands 中的相关字段含义如下所示：</p><ul><li><code>LC_SEGMENT_64</code>：将文件中（32位或64位）的段映射到进程地址空间中，主要分为<code>__TEXT</code>、<code>__DATA</code>、<code>LINKEDIT</code>几大块</li><li><code>LC_DYLD_INFO_ONLY</code>：动态链接相关信息</li><li><code>LC_SYMTAB</code>：符号地址</li><li><code>DYSYMTAB</code>：动态符号表地址</li><li><code>LC_LOAD_DYLINKER</code>：使用谁加载，我们使用dyld</li><li><code>LC_UUID：Mach</code>-O文件的唯一标识UUID</li><li><code>LC_VERSION_MIN_MACOSX</code>：支持最低的操作系统版本</li><li><code>LC_SOURCE_VERSION</code>：源代码版本</li><li><code>LC_MAIN</code>：设值程序主线程的入口地址和栈大小</li><li><code>LC_ENCRYPTION_INFO_64</code>：加密信息</li><li><code>LC_LOAD_DYLIB</code>：依赖库的路径，包含三方库</li><li><code>LC_FUNCTION_STARTS</code>：函数起始地址表</li><li><code>LC_CODE_SIGNATURE</code>：代码签名</li></ul><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><ol><li><code>LC_SEGMENT_64</code> 中 <code>__TEXT、__DATA、LINKERDIT</code> 的对应关系如下图所示</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/152945718-0add234b-5c71-4f17-b4b3-ad74f51b8f16.jpg"></p><ol start="2"><li>查看 LC_DYLD_INFO_ONLY 动态链接信息</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/152945808-13348397-e953-4a61-9031-c1666f88488a.jpg"></p><p>其中 Rebase 是重定向，重定向过程简述如下：</p><p><img src="https://user-images.githubusercontent.com/25925248/152945877-bf26baf5-a753-4303-a2cb-dffe1cd38b8c.jpg"></p><ul><li><p><code>代码段</code> 放入Mach-O文件，在编译时期，会生成一个 <code>偏移地址</code></p></li><li><p>在运行时期，<code>mach-o文件放入虚拟内存</code>，其内存也是随机变化的(由系统分配 -<code>ASLR</code>)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </p></li><li><p>所以之前的代码段在mach-o中偏移值就不能使用了，需要通过 <code>ASLR + Rebase Info Offset</code> 重定向，主要改变的是汇编代码</p></li></ul><ol start="3"><li>查看 <code>LC_SYMTAB</code> 符号地址</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/152945949-7fa1cb84-ebf7-4d1c-9388-86f9c2b6f7da.jpg"></p><ol start="4"><li>查看 <code>LC_LOAD_DYLINKER</code> ，使用谁链接，这里使用的是<code>dyld</code></li></ol><p><img src="https://user-images.githubusercontent.com/25925248/152945970-09e4c7ad-be94-49be-9eed-9f5141db11b8.jpg"></p><ol start="5"><li>查看 LC_UUID，mach-o文件识别的唯一标识</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/152946058-f4a87c51-ede7-48f6-b2ef-46fde5cde6c6.jpg"></p><ol start="6"><li>查看 LC_VERSION_MIN_MACOSX，支持的最低版本信息</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/152946133-185624c4-c420-453c-b727-d62488ad7e7a.jpg"></p><ol start="7"><li>查看 LC_SOURCE_VERSION，代码版本</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/152946159-0eef7477-70d2-430e-a697-a8b5e796a908.jpg"></p><ol start="8"><li>查看 LC_MAIN，入口函数</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/152946275-27d16de3-ad6b-405c-909e-abc523d52466.jpg"></p><p>作用：用于你想时找不到切入点时（例如：做了防护，运行就闪退），可以从这里找到</p><ol start="9"><li>查看 <code>LC_ENCRYPTION_INFO_64</code> ，此时 <code>Crypt ID</code> 为 <code>0</code>，表示还没有加密</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/152946291-d1c1cf92-5136-4ec2-9ff8-30aa011389f0.jpg"></p><h1 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h1><ol><li>如果我们想快速定位代码段，需要通过 <code>LC_SEGMENT_64(__TEXT)</code> 中的 <code>VM Adress</code></li></ol><p><img src="https://user-images.githubusercontent.com/25925248/152946311-17ac476f-2a7c-4fa1-8819-3f1b3a106a3e.jpg"></p><ol start="2"><li>查看 代码段 的 起始位置</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/152946404-f9c198be-4d98-487c-993d-e82ed09ac324.jpg"></p><p>也可以通过 objdump 命令来查看： objdump –macho -d Demo</p><p><img src="https://user-images.githubusercontent.com/25925248/152946418-e360948a-8f7d-494e-beb3-ebb1135441ed.jpg"></p><p>从这里看出，正好与Mach-O文件中的对应</p><ol start="3"><li>查看stub、stub_helper：主要是用于符号绑定，这里的 <code>0x10006574</code> 全是指向的 <code>00006574</code> 偏移，且前面6句汇编都是在做 <code>符号绑定</code></li></ol><p><img src="https://user-images.githubusercontent.com/25925248/152946428-d44d88a5-a2dd-4f16-99b9-34283455cd1e.jpg"></p><ol start="4"><li>查看外部符号表（即 调用外部函数，只有在运行时才绑定），有两个：懒加载、非懒加载</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/152946602-1d20b0ed-b440-4708-85d2-31791d0d9a0c.jpg"></p><p>这里是先 <code>绑定</code> 专门 <code>用来绑定外部的函数</code>，在用这个函数去绑定其他函数</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>Mach-O 内部结构</p><ul><li><p>header ：用于快速确定该文件的CPU类型、文件类型</p></li><li><p>Load Commands：指示加载器如何设置并加载二进制数据</p></li><li><p>Data：存放数据，例如代码、数据、字符串常量、类、方法等。</p><ul><li>Section 中分为两大类：__TEXT(代码)、__DATA（数据）</li></ul></li><li><p>可以通过 <code>otool</code> 命令查看Mach-O信息，例如查看header信息：<code>otool -f Demo</code></p></li><li><p>可以通过 <code>objump</code> 命令来查看代码段： <code>objump --macho -d Demo</code></p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-逆向探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC逆向12：Mach-O文件（上）</title>
      <link href="/BboyZJ.github.io/2022/01/25/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9112%EF%BC%9AMach-O%E6%96%87%E4%BB%B6%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/BboyZJ.github.io/2022/01/25/OC%E9%80%86%E5%90%91/OC%E9%80%86%E5%90%9112%EF%BC%9AMach-O%E6%96%87%E4%BB%B6%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要介绍 <code>Mach-O文件格式</code> 以及 <code>通用二进制文件</code></p><h1 id="Mach-O-文件概述"><a href="#Mach-O-文件概述" class="headerlink" title="Mach-O 文件概述"></a>Mach-O 文件概述</h1><ul><li><p><code>Mach-O</code>其实是 <code>Mach Object</code> 文件格式的缩写，是 <code>Mac</code> 以及 <code>iOS</code> 上 <code>可执行文件的格式</code>，类似于 <code>Window</code> 上的 <code>PE格式</code>（Portable Executable），<code>linux</code> 上的 <code>elf格式</code>（Executable And LinkingFormat）。</p></li><li><p><code>Mach-O</code> 是一种 <code>用于可执行文件、目标代码、动态库的文件格式</code>，作为 <code>a.out格式</code> 的替代，<code>Mach-O</code> 提供了更强的扩展性</p></li></ul><h1 id="Mach-O-文件格式"><a href="#Mach-O-文件格式" class="headerlink" title="Mach-O 文件格式"></a>Mach-O 文件格式</h1><p>常见的 Mach-O格式 有以下几种：</p><ul><li>目标文件 <code>.o</code></li><li>库文件，细分主要有以下几种：<ul><li><code>.a</code></li><li><code>.dylib</code></li><li><code>.framework</code></li></ul></li><li>可执行文件</li><li>dyld</li><li>dsym</li></ul><p>我们可以通过终端的 <code>file</code> 指令来查看文件的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$cd 文件目录</span><br><span class="line">$file 文件</span><br></pre></td></tr></table></figure><h1 id="目标文件-o"><a href="#目标文件-o" class="headerlink" title="目标文件 .o"></a>目标文件 .o</h1><ol><li>新建一个 <code>.c</code> 文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% cd Desktop </span><br><span class="line">% touch demo.c</span><br></pre></td></tr></table></figure><ol start="2"><li>在 .c 文件中实现如下</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;test\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>通过 clang 命令编译 .c 文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">% clang -c demo.c</span><br><span class="line"></span><br><span class="line">% file demo.o</span><br><span class="line">demo.o: Mach-O 64-bit object x86_64</span><br><span class="line"></span><br><span class="line">% clang demo.o</span><br><span class="line"></span><br><span class="line">% ls</span><br><span class="line">a.outdemo.cdemo.o </span><br><span class="line"></span><br><span class="line">% file a.out </span><br><span class="line">a.out: Mach-O 64-bit executable x86_64</span><br><span class="line"></span><br><span class="line">% ./a.out </span><br><span class="line">test</span><br></pre></td></tr></table></figure><ul><li><code>ls</code>：查看当前文件夹</li><li><code>clang -c demo.c</code> ： 将 <code>.c文件</code> 编译成 <code>.o文件</code>（OC在后端中使用的是LLVM编译，而前端使用的工具是 clang，即理解为 LLVM包含clang）</li><li><code>file demo.o</code> ： 查看文件类型 Mach-O文件、64位、x86_64架构</li><li><code>clang demo.o</code> ： 将 <code>.o文件</code> 编译成 <code>可执行文件</code></li><li><code>./a.out</code> ： 执行可执行文件</li></ul><ol start="4"><li>也可以通过一行命令将 <code>.c文件</code> 编译成可执行文件 ： <code>clang -o demo2 demo.c</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% clang -o demo2 demo.c</span><br><span class="line"></span><br><span class="line">% ls</span><br><span class="line">demo.cdemo2</span><br><span class="line"></span><br><span class="line">% ./demo2</span><br><span class="line">test</span><br></pre></td></tr></table></figure><ol start="5"><li><code>重复4</code> 的操作，再次生成一个可执行文件 <code>demo3</code>，此时问题来了，这三个可执行文件（即 a、demo2、demo3）是否是一样的？我们可以通过 <code>md5</code> 验证，如果hash值一样，则说明一样的，反之不一样</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">% md5 a.out</span><br><span class="line">MD5 (a.out) = 922bae326e46b2ac90f5ad4bf2ed031c</span><br><span class="line"></span><br><span class="line">% md5 demo2</span><br><span class="line">MD5 (demo2) = 922bae326e46b2ac90f5ad4bf2ed031c</span><br><span class="line"></span><br><span class="line">% md5 demo3</span><br><span class="line">MD5 (demo3) = 922bae326e46b2ac90f5ad4bf2ed031c</span><br></pre></td></tr></table></figure><h1 id="中间产物-o文件"><a href="#中间产物-o文件" class="headerlink" title="中间产物 .o文件"></a>中间产物 .o文件</h1><p>其中 <code>.c</code> 和 <code>.out</code> 文件的区别是中间多了一个 <code>.o</code> 文件。而在我们的实际开发中，其实是由多个源码的，所以最终的 <code>可执行文件是由多个源码</code> 生成的，如下所示，将 <code>两个.o</code> 文件编译成 <code>一个可执行文件</code></p><ul><li>新建两个 .c 文件</li></ul><p>test.c 代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 函数外定义变量 x 和 y</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">int addtwonum()</span><br><span class="line">&#123;</span><br><span class="line">    // 函数内声明变量 x 和 y 为外部变量</span><br><span class="line">    extern int x;</span><br><span class="line">    extern int y;</span><br><span class="line">    // 给外部变量（全局变量）x 和 y 赋值</span><br><span class="line">    x = 1;</span><br><span class="line">    y = 2;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test1.c 代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int result;</span><br><span class="line">    result = 1;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;result 为: %d&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 <code>clang</code> 将 <code>两个.c文件</code> 生成 <code>两个.o文件</code>：<code>clang -c test1.c test.c</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% clang -c test1.c test.c</span><br><span class="line">% ls</span><br><span class="line">test1.o   test.ctest.o  test1.c</span><br></pre></td></tr></table></figure><ul><li>通过 clang 将 <code>两个.o文件</code> 编译成 <code>两个可执行文件</code>：<code>clang -o demo test1.o test.o</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% clang -o demo test1.o test.o</span><br></pre></td></tr></table></figure><p>如果出现如下报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% clang -o demo test1.o test.o</span><br><span class="line">duplicate symbol &#x27;_main&#x27; in:</span><br><span class="line">    test1.o</span><br><span class="line">    test.o</span><br><span class="line">ld: 1 duplicate symbol for architecture x86_64</span><br><span class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure><p>说明: <code>text.c</code> 和 <code>test1.c</code> 中的 <code>代码相同</code>，需要将其中一个中的代码删除即可，即保证 test1.c 和 test.c 内代码不同</p><ul><li><p>如果此时换一下链接顺序呢？例如： <code>clang -o demo1 test.o test1.o</code></p></li><li><p>多个源码一次性生成可执行文件： <code>clang -o demo2 test1.c test.c</code> </p></li><li><p>对比上述生成三个可执行文件，是否是同一个？这里我们也通过 md5 生成的 hash值 进行对比：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% md5 demo</span><br><span class="line">MD5 (demo) = 4be533adc572558230adcbd067379fea</span><br><span class="line">% md5 demo1</span><br><span class="line">MD5 (demo1) = a3ff882d7d541fe3bc2a11538bc2e031</span><br><span class="line">% md5 demo2</span><br><span class="line">MD5 (demo2) = 4be533adc572558230adcbd067379fea</span><br></pre></td></tr></table></figure><p><strong>结论</strong>：通过对比发现，如果改变了 .o文件的 连接顺序，那么 Mach-O 也会发生改变</p><ul><li>这里可以通过 <code>objdump --macho -d demo</code> 查看 <code>Mach-O</code> 链接顺序，如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">% objdump --macho -d demo</span><br><span class="line">demo:</span><br><span class="line">(__TEXT,__text) section</span><br><span class="line">_main:</span><br><span class="line">100003f30:55pushq%rbp</span><br><span class="line">100003f31:48 89 e5movq%rsp, %rbp</span><br><span class="line">100003f34:48 83 ec 10subq$16, %rsp</span><br><span class="line">100003f38:c7 45 fc 00 00 00 00movl$0, -4(%rbp)</span><br><span class="line">100003f3f:c7 45 f8 01 00 00 00movl$1, -8(%rbp)</span><br><span class="line">100003f46:8b 75 f8movl-8(%rbp), %esi</span><br><span class="line">100003f49:48 8d 3d 56 00 00 00leaq86(%rip), %rdi ## literal pool for: &quot;result \344\270\272: %d&quot;</span><br><span class="line">100003f50:b0 00movb$0, %al</span><br><span class="line">100003f52:e8 2d 00 00 00callq0x100003f84 ## symbol stub for: _printf</span><br><span class="line">100003f57:31 c0xorl%eax, %eax</span><br><span class="line">100003f59:48 83 c4 10addq$16, %rsp</span><br><span class="line">100003f5d:5dpopq%rbp</span><br><span class="line">100003f5e:c3retq</span><br><span class="line">100003f5f:90nop</span><br><span class="line">_addtwonum:</span><br><span class="line">100003f60:55pushq%rbp</span><br><span class="line">100003f61:48 89 e5movq%rsp, %rbp</span><br><span class="line">100003f64:48 8d 0d a9 40 00 00leaq_y(%rip), %rcx</span><br><span class="line">100003f6b:48 8d 05 9e 40 00 00leaq_x(%rip), %rax</span><br><span class="line">100003f72:c7 00 01 00 00 00movl$1, (%rax)</span><br><span class="line">100003f78:c7 01 02 00 00 00movl$2, (%rcx)</span><br><span class="line">100003f7e:8b 00movl(%rax), %eax</span><br><span class="line">100003f80:03 01addl(%rcx), %eax</span><br><span class="line">100003f82:5dpopq%rbp</span><br><span class="line">100003f83:c3retq</span><br></pre></td></tr></table></figure><p>源文件链接顺序是 <code>main + addtwonum</code></p><ul><li>这里可以通过 <code>objdump --macho -d demo1</code> 查看 <code>Mach-O</code> 链接顺序，如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">% objdump --macho -d demo1</span><br><span class="line">demo1:</span><br><span class="line">(__TEXT,__text) section</span><br><span class="line">_addtwonum:</span><br><span class="line">100003f20:55pushq%rbp</span><br><span class="line">100003f21:48 89 e5movq%rsp, %rbp</span><br><span class="line">100003f24:48 8d 0d e9 40 00 00leaq_y(%rip), %rcx</span><br><span class="line">100003f2b:48 8d 05 de 40 00 00leaq_x(%rip), %rax</span><br><span class="line">100003f32:c7 00 01 00 00 00movl$1, (%rax)</span><br><span class="line">100003f38:c7 01 02 00 00 00movl$2, (%rcx)</span><br><span class="line">100003f3e:8b 00movl(%rax), %eax</span><br><span class="line">100003f40:03 01addl(%rcx), %eax</span><br><span class="line">100003f42:5dpopq%rbp</span><br><span class="line">100003f43:c3retq</span><br><span class="line">100003f44:90nop</span><br><span class="line">100003f45:90nop</span><br><span class="line">100003f46:90nop</span><br><span class="line">100003f47:90nop</span><br><span class="line">100003f48:90nop</span><br><span class="line">100003f49:90nop</span><br><span class="line">100003f4a:90nop</span><br><span class="line">100003f4b:90nop</span><br><span class="line">100003f4c:90nop</span><br><span class="line">100003f4d:90nop</span><br><span class="line">100003f4e:90nop</span><br><span class="line">100003f4f:90nop</span><br><span class="line">_main:</span><br><span class="line">100003f50:55pushq%rbp</span><br><span class="line">100003f51:48 89 e5movq%rsp, %rbp</span><br><span class="line">100003f54:48 83 ec 10subq$16, %rsp</span><br><span class="line">100003f58:c7 45 fc 00 00 00 00movl$0, -4(%rbp)</span><br><span class="line">100003f5f:c7 45 f8 01 00 00 00movl$1, -8(%rbp)</span><br><span class="line">100003f66:8b 75 f8movl-8(%rbp), %esi</span><br><span class="line">100003f69:48 8d 3d 32 00 00 00leaq50(%rip), %rdi ## literal pool for: &quot;result \344\270\272: %d&quot;</span><br><span class="line">100003f70:b0 00movb$0, %al</span><br><span class="line">100003f72:e8 09 00 00 00callq0x100003f80 ## symbol stub for: _printf</span><br><span class="line">100003f77:31 c0xorl%eax, %eax</span><br><span class="line">100003f79:48 83 c4 10addq$16, %rsp</span><br><span class="line">100003f7d:5dpopq%rbp</span><br><span class="line">100003f7e:c3retq</span><br></pre></td></tr></table></figure><p>源文件的链接顺序是 <code>addtwonum + main</code></p><ul><li>这里可以通过 <code>objdump --macho -d demo2</code> 查看 <code>Mach-O</code> 链接顺序，如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">% objdump --macho -d demo2</span><br><span class="line">demo2:</span><br><span class="line">(__TEXT,__text) section</span><br><span class="line">_main:</span><br><span class="line">100003f30:55pushq%rbp</span><br><span class="line">100003f31:48 89 e5movq%rsp, %rbp</span><br><span class="line">100003f34:48 83 ec 10subq$16, %rsp</span><br><span class="line">100003f38:c7 45 fc 00 00 00 00movl$0, -4(%rbp)</span><br><span class="line">100003f3f:c7 45 f8 01 00 00 00movl$1, -8(%rbp)</span><br><span class="line">100003f46:8b 75 f8movl-8(%rbp), %esi</span><br><span class="line">100003f49:48 8d 3d 56 00 00 00leaq86(%rip), %rdi ## literal pool for: &quot;result \344\270\272: %d&quot;</span><br><span class="line">100003f50:b0 00movb$0, %al</span><br><span class="line">100003f52:e8 2d 00 00 00callq0x100003f84 ## symbol stub for: _printf</span><br><span class="line">100003f57:31 c0xorl%eax, %eax</span><br><span class="line">100003f59:48 83 c4 10addq$16, %rsp</span><br><span class="line">100003f5d:5dpopq%rbp</span><br><span class="line">100003f5e:c3retq</span><br><span class="line">100003f5f:90nop</span><br><span class="line">_addtwonum:</span><br><span class="line">100003f60:55pushq%rbp</span><br><span class="line">100003f61:48 89 e5movq%rsp, %rbp</span><br><span class="line">100003f64:48 8d 0d a9 40 00 00leaq_y(%rip), %rcx</span><br><span class="line">100003f6b:48 8d 05 9e 40 00 00leaq_x(%rip), %rax</span><br><span class="line">100003f72:c7 00 01 00 00 00movl$1, (%rax)</span><br><span class="line">100003f78:c7 01 02 00 00 00movl$2, (%rcx)</span><br><span class="line">100003f7e:8b 00movl(%rax), %eax</span><br><span class="line">100003f80:03 01addl(%rcx), %eax</span><br><span class="line">100003f82:5dpopq%rbp</span><br><span class="line">100003f83:c3retq</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>源文件的链接顺序是 <code>main + addtwonum</code></p><p>上述所说的链接顺序，对应到我们日常开发中是指工程中的 <code>target -&gt; Build Phase -&gt; Compiles Sources</code>，这里就是对应源文件的 <code>编译顺序</code>，如果源文件的顺序发生了变化，生成的可执行文件是不一样的</p><h1 id="库-文件"><a href="#库-文件" class="headerlink" title="库 文件"></a>库 文件</h1><ul><li><p>什么是库？</p><p>  主要是程序代码的集合，即将N个文件组织起来，是共享程序代码的一种方式，</p></li><li><p>库的分类</p><ul><li><p><code>开源库（公有库）</code>：源码是公开的，可以看到每个文件的实现，例如Github中的AFNetworking、SDWebImage等</p></li><li><p><code>闭源库（私有库）</code>：源码未公开，是经过编译后的二进制文件，看不到具体的实现，再细分又分为 静态库 和 动态库。</p></li></ul></li></ul><h1 id="静态库-amp-动态库"><a href="#静态库-amp-动态库" class="headerlink" title="静态库 &amp; 动态库"></a>静态库 &amp; 动态库</h1><ol><li>静态库：静态库的存在形式主要有两种（建议用.framework）：<code>.a + .framework</code></li></ol><ul><li><p><code>.a</code> 是一个 纯二进制文件，<code>.a</code> 不能直接使用，至少需要<code>.h</code>文件配合，可能还会需要资源文件</p></li><li><p><code>.framework</code> 中除了有二进制文件外，还有资源文件，且可以 <code>直接使用</code></p></li><li><p>两者的关系： <code>.a + .h + sourceFile = .frmework</code></p></li><li><p>优势：方便共享代码，便于合理使用</p><ul><li>实现iOS的模块化，即将固定业务模块化为静态库</li><li>共享代码，但不希望被看到代码的具体实现</li></ul></li></ul><ol start="3"><li><p>动态库：动态库的存在形式也是两种：<code>.dylib + .framework</code></p></li><li><p>.framework 为什么即是静态库又是动态库？</p></li></ol><ul><li>系统的 .framework 是动态库</li><li>自定义的 .framework 是静态库</li></ul><ol start="4"><li>静态库和动态库的区别</li></ol><ul><li><code>静态库</code> 在 <code>链接</code> 时会被完整的拷贝到项目中，如果有多个APP都是用了同一个静态库，<code>会拷贝多份</code>，浪费内存</li><li><code>动态库</code> 不会复制，<code>只有一份</code>，在程序运行时 动态加载 到内存中，多个APP共用一份，节约内存</li></ul><h1 id="验证-a-dylib-是否是-Mach-O文件"><a href="#验证-a-dylib-是否是-Mach-O文件" class="headerlink" title="验证 .a  .dylib 是否是 Mach-O文件"></a>验证 .a  .dylib 是否是 Mach-O文件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd 项目根目录下</span><br></pre></td></tr></table></figure><ol><li>验证 .a</li></ol><ul><li><p>在项目中，通过<code>find</code>命令查找到 <code>.a</code> 文件: 终端输入 <code>find /usr -name &quot;*.a&quot;</code></p></li><li><p>随机查看一个 <code>.a</code> 文件，是一个 <code>dynamically</code> 类型： <code>file .a文件路径</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">zhangjian@zhangjiandeMBP SRSF % find /usr -name &quot;*.a&quot;</span><br><span class="line">find: /usr/sbin/authserver: Permission denied</span><br><span class="line">/usr/local/lib/libbrotlidec-static.a</span><br><span class="line">/usr/local/lib/libev.a</span><br><span class="line">/usr/local/lib/libjemalloc.a</span><br><span class="line">/usr/local/lib/libnghttp2.a</span><br><span class="line">/usr/local/lib/libevent_extra.a</span><br><span class="line">/usr/local/lib/libevent.a</span><br><span class="line">/usr/local/lib/libevent_core.a</span><br><span class="line">/usr/local/lib/libprotobuf.a</span><br><span class="line">/usr/local/lib/liblz4.a</span><br><span class="line">/usr/local/lib/libprotoc.a</span><br><span class="line">/usr/local/lib/libprotobuf-lite.a</span><br><span class="line">/usr/local/lib/libbrotlienc-static.a</span><br><span class="line">/usr/local/lib/libbrotlicommon-static.a</span><br><span class="line">/usr/local/lib/libuv.a</span><br><span class="line">/usr/local/lib/libzstd.a</span><br><span class="line">/usr/local/lib/libevent_openssl.a</span><br><span class="line">/usr/local/lib/libmysqlservices.a</span><br><span class="line">/usr/local/lib/libjemalloc_pic.a</span><br><span class="line">/usr/local/lib/libmysqlclient.a</span><br><span class="line">/usr/local/lib/libevent_pthreads.a</span><br><span class="line">/usr/local/Cellar/nghttp2/1.43.0/lib/libnghttp2.a</span><br><span class="line">/usr/local/Cellar/mysql-client/8.0.25/lib/libmysqlclient.a</span><br><span class="line">/usr/local/Cellar/libuv/1.41.0/lib/libuv.a</span><br><span class="line">/usr/local/Cellar/jemalloc/5.2.1_1/lib/libjemalloc.a</span><br><span class="line">/usr/local/Cellar/jemalloc/5.2.1_1/lib/libjemalloc_pic.a</span><br><span class="line">/usr/local/Cellar/brotli/1.0.9/lib/libbrotlidec-static.a</span><br><span class="line">/usr/local/Cellar/brotli/1.0.9/lib/libbrotlienc-static.a</span><br><span class="line">/usr/local/Cellar/brotli/1.0.9/lib/libbrotlicommon-static.a</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicui18n.a</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicutest.a</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicuio.a</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicudata.a</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicuuc.a</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicutu.a</span><br><span class="line">/usr/local/Cellar/lz4/1.9.3/lib/liblz4.a</span><br><span class="line">/usr/local/Cellar/zstd/1.5.0/lib/libzstd.a</span><br><span class="line">/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlservices.a</span><br><span class="line">/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlclient.a</span><br><span class="line">/usr/local/Cellar/libevent/2.1.12/lib/libevent_extra.a</span><br><span class="line">/usr/local/Cellar/libevent/2.1.12/lib/libevent.a</span><br><span class="line">/usr/local/Cellar/libevent/2.1.12/lib/libevent_core.a</span><br><span class="line">/usr/local/Cellar/libevent/2.1.12/lib/libevent_openssl.a</span><br><span class="line">/usr/local/Cellar/libevent/2.1.12/lib/libevent_pthreads.a</span><br><span class="line">/usr/local/Cellar/openssl@1.1/1.1.1k/lib/libcrypto.a</span><br><span class="line">/usr/local/Cellar/openssl@1.1/1.1.1k/lib/libssl.a</span><br><span class="line">/usr/local/Cellar/libev/4.33/lib/libev.a</span><br><span class="line">/usr/local/Cellar/protobuf/3.17.3/lib/libprotobuf.a</span><br><span class="line">/usr/local/Cellar/protobuf/3.17.3/lib/libprotoc.a</span><br><span class="line">/usr/local/Cellar/protobuf/3.17.3/lib/libprotobuf-lite.a</span><br><span class="line"></span><br><span class="line">% file /usr/local/Cellar/protobuf/3.17.3/lib/libprotobuf-lite.a</span><br><span class="line">/usr/local/Cellar/libevent/2.1.12/lib/libevent_openssl.a: current ar archive random library</span><br></pre></td></tr></table></figure><p>这个.a库是看不出来是 dynamically类型</p><ol start="2"><li>验证 <code>.dylib</code></li></ol><ul><li><p>在项目中通过 <code>find</code> 查找 <code>.dylib文件</code>： <code>find /usr -name &quot;*.dylib&quot;</code></p></li><li><p>查看 <code>.dylib</code> 文件： <code>file .dylib文件路径</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">find: /usr/sbin/authserver: Permission denied</span><br><span class="line">/usr/local/Homebrew/Library/Homebrew/test/support/fixtures/mach/fat.dylib</span><br><span class="line">/usr/local/Homebrew/Library/Homebrew/test/support/fixtures/mach/i386.dylib</span><br><span class="line">/usr/local/Homebrew/Library/Homebrew/test/support/fixtures/mach/x86_64.dylib</span><br><span class="line">/usr/local/lib/libmysqlrouter_http_auth_backend.1.dylib</span><br><span class="line">/usr/local/lib/libmysqlharness_stdx.1.dylib</span><br><span class="line">/usr/local/lib/libevent_pthreads-2.1.7.dylib</span><br><span class="line">/usr/local/lib/libbrotlidec.1.dylib</span><br><span class="line">/usr/local/lib/libuv.dylib</span><br><span class="line">/usr/local/lib/libbrotlicommon.1.dylib</span><br><span class="line">/usr/local/lib/liblz4.1.9.3.dylib</span><br><span class="line">/usr/local/lib/libcares.dylib</span><br><span class="line">/usr/local/lib/libmysqlharness.1.dylib</span><br><span class="line">/usr/local/lib/libbrotlienc.dylib</span><br><span class="line">/usr/local/lib/libprotobuf-lite.dylib</span><br><span class="line">/usr/local/lib/libevent_openssl-2.1.7.dylib</span><br><span class="line">/usr/local/lib/libevent_extra.dylib</span><br><span class="line">/usr/local/lib/libbrotlienc.1.dylib</span><br><span class="line">/usr/local/lib/libuv.1.dylib</span><br><span class="line">/usr/local/lib/libevent_extra-2.1.7.dylib</span><br><span class="line">/usr/local/lib/libprotoc.28.dylib</span><br><span class="line">/usr/local/lib/libprotobuf.28.dylib</span><br><span class="line">/usr/local/lib/libmysqlharness_tls.1.dylib</span><br><span class="line">/usr/local/lib/libevent.dylib</span><br><span class="line">/usr/local/lib/libcares.2.dylib</span><br><span class="line">/usr/local/lib/libcares.2.4.2.dylib</span><br><span class="line">/usr/local/lib/libbrotlienc.1.0.9.dylib</span><br><span class="line">/usr/local/lib/libmysqlclient.21.dylib</span><br><span class="line">/usr/local/lib/libev.dylib</span><br><span class="line">/usr/local/lib/libprotoc.dylib</span><br><span class="line">/usr/local/lib/libzstd.1.5.0.dylib</span><br><span class="line">/usr/local/lib/libevent-2.1.7.dylib</span><br><span class="line">/usr/local/lib/libevent_pthreads.dylib</span><br><span class="line">/usr/local/lib/liblz4.dylib</span><br><span class="line">/usr/local/lib/libmysqlrouter_io_component.1.dylib</span><br><span class="line">/usr/local/lib/libmysqlrouter_http.1.dylib</span><br><span class="line">/usr/local/lib/libjemalloc.2.dylib</span><br><span class="line">/usr/local/lib/libnghttp2.14.dylib</span><br><span class="line">/usr/local/lib/libprotobuf.dylib</span><br><span class="line">/usr/local/lib/libmysqlclient.dylib</span><br><span class="line">/usr/local/lib/libevent_openssl.dylib</span><br><span class="line">/usr/local/lib/liblz4.1.dylib</span><br><span class="line">/usr/local/lib/libmysqlrouter_http_auth_realm.1.dylib</span><br><span class="line">/usr/local/lib/libbrotlicommon.dylib</span><br><span class="line">/usr/local/lib/libnghttp2.dylib</span><br><span class="line">/usr/local/lib/libzstd.1.dylib</span><br><span class="line">/usr/local/lib/libbrotlidec.dylib</span><br><span class="line">/usr/local/lib/libmysqlrouter.1.dylib</span><br><span class="line">/usr/local/lib/libbrotlidec.1.0.9.dylib</span><br><span class="line">/usr/local/lib/libevent_core.dylib</span><br><span class="line">/usr/local/lib/libbrotlicommon.1.0.9.dylib</span><br><span class="line">/usr/local/lib/libev.4.dylib</span><br><span class="line">/usr/local/lib/libzstd.dylib</span><br><span class="line">/usr/local/lib/libjemalloc.dylib</span><br><span class="line">/usr/local/lib/libprotobuf-lite.28.dylib</span><br><span class="line">/usr/local/lib/libevent_core-2.1.7.dylib</span><br><span class="line">/usr/local/Cellar/nghttp2/1.43.0/lib/libnghttp2.14.dylib</span><br><span class="line">/usr/local/Cellar/nghttp2/1.43.0/lib/libnghttp2.dylib</span><br><span class="line">/usr/local/Cellar/mysql-client/8.0.25/lib/libssl.dylib</span><br><span class="line">/usr/local/Cellar/mysql-client/8.0.25/lib/libssl.1.1.dylib</span><br><span class="line">/usr/local/Cellar/mysql-client/8.0.25/lib/plugin/libssl.1.1.dylib</span><br><span class="line">/usr/local/Cellar/mysql-client/8.0.25/lib/plugin/libcrypto.1.1.dylib</span><br><span class="line">/usr/local/Cellar/mysql-client/8.0.25/lib/libmysqlclient.21.dylib</span><br><span class="line">/usr/local/Cellar/mysql-client/8.0.25/lib/libcrypto.dylib</span><br><span class="line">/usr/local/Cellar/mysql-client/8.0.25/lib/libmysqlclient.dylib</span><br><span class="line">/usr/local/Cellar/mysql-client/8.0.25/lib/libcrypto.1.1.dylib</span><br><span class="line">/usr/local/Cellar/libuv/1.41.0/lib/libuv.dylib</span><br><span class="line">/usr/local/Cellar/libuv/1.41.0/lib/libuv.1.dylib</span><br><span class="line">/usr/local/Cellar/jemalloc/5.2.1_1/lib/libjemalloc.2.dylib</span><br><span class="line">/usr/local/Cellar/jemalloc/5.2.1_1/lib/libjemalloc.dylib</span><br><span class="line">/usr/local/Cellar/brotli/1.0.9/lib/libbrotlidec.1.dylib</span><br><span class="line">/usr/local/Cellar/brotli/1.0.9/lib/libbrotlicommon.1.dylib</span><br><span class="line">/usr/local/Cellar/brotli/1.0.9/lib/libbrotlienc.dylib</span><br><span class="line">/usr/local/Cellar/brotli/1.0.9/lib/libbrotlienc.1.dylib</span><br><span class="line">/usr/local/Cellar/brotli/1.0.9/lib/libbrotlienc.1.0.9.dylib</span><br><span class="line">/usr/local/Cellar/brotli/1.0.9/lib/libbrotlicommon.dylib</span><br><span class="line">/usr/local/Cellar/brotli/1.0.9/lib/libbrotlidec.dylib</span><br><span class="line">/usr/local/Cellar/brotli/1.0.9/lib/libbrotlidec.1.0.9.dylib</span><br><span class="line">/usr/local/Cellar/brotli/1.0.9/lib/libbrotlicommon.1.0.9.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicui18n.69.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicuio.69.1.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicuio.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicuuc.69.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicutest.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicudata.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicudata.69.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicutu.69.1.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicui18n.69.1.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicuuc.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicutu.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicui18n.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicutest.69.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicudata.69.1.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicutest.69.1.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicuuc.69.1.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicuio.69.dylib</span><br><span class="line">/usr/local/Cellar/icu4c/69.1/lib/libicutu.69.dylib</span><br><span class="line">/usr/local/Cellar/lz4/1.9.3/lib/liblz4.1.9.3.dylib</span><br><span class="line">/usr/local/Cellar/lz4/1.9.3/lib/liblz4.dylib</span><br><span class="line">/usr/local/Cellar/lz4/1.9.3/lib/liblz4.1.dylib</span><br><span class="line">/usr/local/Cellar/c-ares/1.17.1/lib/libcares.dylib</span><br><span class="line">/usr/local/Cellar/c-ares/1.17.1/lib/libcares.2.dylib</span><br><span class="line">/usr/local/Cellar/c-ares/1.17.1/lib/libcares.2.4.2.dylib</span><br><span class="line">/usr/local/Cellar/zstd/1.5.0/lib/libzstd.1.5.0.dylib</span><br><span class="line">/usr/local/Cellar/zstd/1.5.0/lib/libzstd.1.dylib</span><br><span class="line">/usr/local/Cellar/zstd/1.5.0/lib/libzstd.dylib</span><br><span class="line">/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlrouter_http_auth_backend.1.dylib</span><br><span class="line">/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlharness_stdx.1.dylib</span><br><span class="line">/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlharness.1.dylib</span><br><span class="line">/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlharness_tls.1.dylib</span><br><span class="line">/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlclient.21.dylib</span><br><span class="line">/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlrouter_io_component.1.dylib</span><br><span class="line">/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlrouter_http.1.dylib</span><br><span class="line">/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlclient.dylib</span><br><span class="line">/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlrouter_http_auth_realm.1.dylib</span><br><span class="line">/usr/local/Cellar/mysql/8.0.25_1/lib/libmysqlrouter.1.dylib</span><br><span class="line">/usr/local/Cellar/libevent/2.1.12/lib/libevent_pthreads-2.1.7.dylib</span><br><span class="line">/usr/local/Cellar/libevent/2.1.12/lib/libevent_openssl-2.1.7.dylib</span><br><span class="line">/usr/local/Cellar/libevent/2.1.12/lib/libevent_extra.dylib</span><br><span class="line">/usr/local/Cellar/libevent/2.1.12/lib/libevent_extra-2.1.7.dylib</span><br><span class="line">/usr/local/Cellar/libevent/2.1.12/lib/libevent.dylib</span><br><span class="line">/usr/local/Cellar/libevent/2.1.12/lib/libevent-2.1.7.dylib</span><br><span class="line">/usr/local/Cellar/libevent/2.1.12/lib/libevent_pthreads.dylib</span><br><span class="line">/usr/local/Cellar/libevent/2.1.12/lib/libevent_openssl.dylib</span><br><span class="line">/usr/local/Cellar/libevent/2.1.12/lib/libevent_core.dylib</span><br><span class="line">/usr/local/Cellar/libevent/2.1.12/lib/libevent_core-2.1.7.dylib</span><br><span class="line">/usr/local/Cellar/openssl@1.1/1.1.1k/lib/libssl.dylib</span><br><span class="line">/usr/local/Cellar/openssl@1.1/1.1.1k/lib/libssl.1.1.dylib</span><br><span class="line">/usr/local/Cellar/openssl@1.1/1.1.1k/lib/libcrypto.dylib</span><br><span class="line">/usr/local/Cellar/openssl@1.1/1.1.1k/lib/engines-1.1/padlock.dylib</span><br><span class="line">/usr/local/Cellar/openssl@1.1/1.1.1k/lib/engines-1.1/capi.dylib</span><br><span class="line">/usr/local/Cellar/openssl@1.1/1.1.1k/lib/libcrypto.1.1.dylib</span><br><span class="line">/usr/local/Cellar/libev/4.33/lib/libev.dylib</span><br><span class="line">/usr/local/Cellar/libev/4.33/lib/libev.4.dylib</span><br><span class="line">/usr/local/Cellar/protobuf/3.17.3/lib/libprotobuf-lite.dylib</span><br><span class="line">/usr/local/Cellar/protobuf/3.17.3/lib/libprotoc.28.dylib</span><br><span class="line">/usr/local/Cellar/protobuf/3.17.3/lib/libprotobuf.28.dylib</span><br><span class="line">/usr/local/Cellar/protobuf/3.17.3/lib/libprotoc.dylib</span><br><span class="line">/usr/local/Cellar/protobuf/3.17.3/lib/libprotobuf.dylib</span><br><span class="line">/usr/local/Cellar/protobuf/3.17.3/lib/libprotobuf-lite.28.dylib</span><br><span class="line">/usr/lib/libobjc-trampolines.dylib</span><br><span class="line">/usr/lib/libLeaksAtExit.dylib</span><br><span class="line">/usr/lib/libstdc++.6.dylib</span><br><span class="line">/usr/lib/libpython2.7.dylib</span><br><span class="line">/usr/lib/libhunspell-1.2.0.dylib</span><br><span class="line">/usr/lib/libMTLCapture.dylib</span><br><span class="line">/usr/lib/system/libsystem_pthread.dylib</span><br><span class="line">/usr/lib/system/introspection/libsystem_pthread.dylib</span><br><span class="line">/usr/lib/system/introspection/libdispatch.dylib</span><br><span class="line">/usr/lib/system/libsystem_kernel.dylib</span><br><span class="line">/usr/lib/system/libsystem_platform.dylib</span><br><span class="line">/usr/lib/libgmalloc.dylib</span><br><span class="line">/usr/lib/swift/libswiftRemoteMirror.dylib</span><br><span class="line">/usr/lib/swift/libswiftCreateML.dylib</span><br><span class="line">/usr/lib/libiodbc.2.dylib</span><br><span class="line">/usr/lib/libffi-trampolines.dylib</span><br><span class="line">/usr/lib/ssh-keychain.dylib</span><br><span class="line">/usr/lib/libpython.dylib</span><br><span class="line">/usr/lib/libiodbcinst.2.dylib</span><br><span class="line"></span><br><span class="line">% file /usr/lib/libpython.dylib</span><br><span class="line">/usr/lib/libpython.dylib: Mach-O universal binary with 2 architectures: [x86_64:Mach-O 64-bit dynamically linked shared library x86_64] [arm64e]</span><br><span class="line">/usr/lib/libpython.dylib (for architecture x86_64):Mach-O 64-bit dynamically linked shared library x86_64</span><br><span class="line">/usr/lib/libpython.dylib (for architecture arm64e):Mach-O 64-bit dynamically linked shared library arm64e</span><br></pre></td></tr></table></figure><ol start="3"><li>可执行文件</li></ol><p>这里的可执行文件，即一般是指日常项目中，编译后生成的可执行文件，可以通过 file 查看其文件类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% file /Users/zhangjian/Desktop/demo1 </span><br><span class="line">/Users/zhangjian/Desktop/demo1: Mach-O 64-bit executable x86_64</span><br></pre></td></tr></table></figure><ol start="4"><li>dyld</li></ol><p><code>dyld</code>（the dynamic link editor）是苹果的 <code>动态连接器</code>，是苹果操作系统一个重要的组成部分，在系统内核做好程序准备工作之后，交由dyld负责余下的工作，而且它是开源的，任何人可以通过苹果官网下载它的源码来阅读理解它的运作方式，了解系统加载动态库的细节。</p><ul><li>共享缓存机制</li></ul><p>在iOS系统中，每个程序依赖的<code>动态库</code>都需要通过<code>dyld</code>（位于&#x2F;usr&#x2F;lib&#x2F;dyld）一个一个 加载到内存，然而，很多系统库几乎是每个程序都会用到的，如果在每个程序运行的时候都重复的去加载一次，势必造成运行缓慢，为了优化启动速度和提高程序性能，共享缓存机制就应运而生。所有默认的动态链接库被合并成一个大的缓存文件，放到<code>/System/Library/Caches/com.apple.dyld/目录</code>下，按照不同的架构分别保存着</p><ul><li>验证dyld</li></ul><p>查找Mac中的dyld</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">zhangjian@zhangjiandeMBP ~ % cd /usr/lib  </span><br><span class="line">zhangjian@zhangjiandeMBP lib % ls</span><br><span class="line"></span><br><span class="line">charset.aliaslibstdc++.6.dylib</span><br><span class="line">cronlog</span><br><span class="line">dsc_extractor.bundlepam</span><br><span class="line">dtracepkgconfig</span><br><span class="line">dyldpython2.7</span><br><span class="line">groffrpcsvc</span><br><span class="line">libLeaksAtExit.dylibruby</span><br><span class="line">libMTLCapture.dylibsasl2</span><br><span class="line">libffi-trampolines.dylibsqlite3</span><br><span class="line">libgmalloc.dylibssh-keychain.dylib</span><br><span class="line">libhunspell-1.2.0.dylibswift</span><br><span class="line">libiodbc.2.dylibsystem</span><br><span class="line">libiodbcinst.2.dylibupdaters</span><br><span class="line">libobjc-trampolines.dylibxpc</span><br><span class="line">libpython.dylibzsh</span><br><span class="line">libpython2.7.dylib</span><br><span class="line"></span><br><span class="line">zhangjian@zhangjiandeMBP lib % ls dyld</span><br><span class="line">dyld</span><br></pre></td></tr></table></figure><p>查看 <code>dyld</code>的文件类型： <code>file dyld</code>，是一个 <code>动态链接器</code>，其本身也是一个<code>Mach-O</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zhangjian@zhangjiandeMBP lib % file dyld</span><br><span class="line">dyld: Mach-O universal binary with 3 architectures: [i386:Mach-O dynamic linker i386] [x86_64:Mach-O 64-bit dynamic linker x86_64] [arm64e]</span><br><span class="line">dyld (for architecture i386):Mach-O dynamic linker i386</span><br><span class="line">dyld (for architecture x86_64):Mach-O 64-bit dynamic linker x86_64</span><br><span class="line">dyld (for architecture arm64e):Mach-O 64-bit dynamic linker arm64e</span><br></pre></td></tr></table></figure><ol start="5"><li>dsym文件</li></ol><ul><li>dsym介绍</li></ul><p>Xcode编译项目后，我们会看到一个同名的 <code>dSYM文件</code>，dSYM是 <code>保存16进制函数地址映射信息的中转文件</code>，我们调试的 <code>symbols</code> 都会包含在这个文件中，并且每次编译项目的时候都会生成一个新的 dSYM文件，位于<code>/Users/&lt;用户名&gt;/Library/Developer/Xcode/Archives</code>目录下，所以对于每一个发布版本我们都很有必要保存对应的 Archives 文件。</p><p>当我们软件 <code>release</code> 模式打包或上线后，不会像我们在xcode中那样直观的看到 <code>崩溃</code> 的错误日志，这个时候我们就需要 <code>分析crash report</code>文件了，iOS设备中会有日志文件保存我们每个应用出错的函数内存地址，通过 <code>xcode</code> 的 <code>organizer</code> 可以将iOS设备中的 <code>deviceLog</code> 导出成 <code>crash文件</code>，这个时候我们就可以 通过出错的函数地址去 <code>查询dSYM</code> 文件中程序对应的函数和文件名，但前提是我们需要有软件版本对应的dSYM文件，这也是为什么我们很有必要保存每个发布版本的 <code>Archives</code> 文件了</p><ul><li>验证 .dSYM文件</li></ul><p>程序 <code>真机+release</code> 编译时，有一个 <code>.dSYM文件</code></p><p><img src="https://user-images.githubusercontent.com/25925248/152944480-381f1890-540c-4e90-b7c6-fe0b7c9eb505.jpg"></p><ul><li><code>.dSYM</code> 也是一个 <code>mach-o</code> 文件，是一个 <code>符号表</code>，主要用于出现崩溃后可以通过这个文件 <code>取符号</code>，方便 <code>查询问题</code></li></ul><h1 id="通用二进制文件"><a href="#通用二进制文件" class="headerlink" title="通用二进制文件"></a>通用二进制文件</h1><p>mac系统所支持的cpu及硬件平台发生了很大的变化，为了解决软件在多个平台硬件平台上的 <code>兼容性</code> 问题，苹果开发了一个 <code>通用的二进制文件格式（Universal Binary）</code>，又称 <code>胖二进制（Fat Binary）</code></p><ul><li>苹果公司提出的一种程序代码，能同时 <code>适用多种架构的二进制文件</code></li><li>同一个程序包中同时为多种架构提供最理想的性能。</li><li>因为需要存储多种代码，通用二进制应用程序通常比单一平台二进制的程序要大</li><li>但是由于两种架构有 <code>共通的非执行资源（代码以外的）</code>，所以并不会达到单一版本的两倍之多</li><li>而且由于执行中只调用一部分代码，运行起来也不需要额外的内存</li></ul><p><strong>演示</strong></p><ul><li>在日常开发的项目中，可以通过<code>Build Setting -&gt; Mach-O type</code>，指定 Mach-O文件的类型，如下图：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/152944589-f10187b9-daa5-4041-8f96-760188f4fe85.jpg"></p><ul><li><p>一般我们通过真机生成的可执行文件，其架构是arm64，是一个单一架构</p><ul><li>iOS 9.0 以上的系统否支持 64位架构</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% cd /Users/zhangjian/Library/Developer/Xcode/DerivedData/SRSF-bzdqlauzaknekvclilbreawtebqi/Build/Products/Debug-iphoneos/中图云书房.app</span><br><span class="line">% file 中图云书房 </span><br><span class="line">中图云书房: Mach-O 64-bit executable arm64</span><br></pre></td></tr></table></figure></li><li><p>同时也可以在 <code>Build Setting -&gt; Architectures</code> 中设值编译的 <code>架构</code></p><ul><li>环境变量 <code>$(ARCHS_STANDRAD)</code> ：包含 <code>arm64、armv7</code></li></ul><p>  <img src="https://user-images.githubusercontent.com/25925248/152944738-29cd2fee-4dfd-4d4d-bcff-256e5498101c.jpg"></p><ul><li>还有一种架构：armv7s，iPhone5、iPhone5c可用的架构，可在工程中添加，此时查看<code> Release + 真机环境</code> 可执行文件，支持3个架构</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% cd /Users/zhangjian/Library/Developer/Xcode/DerivedData/Demo-edwjvapoqaffzeeiyzyhfryhfrsr/Build/Products/Release-iphoneos/Demo.app </span><br><span class="line"></span><br><span class="line">% file Demo</span><br><span class="line">Demo: Mach-O universal binary with 3 architectures: [arm_v7:Mach-O executable arm_v7] [arm_v7s:Mach-O executable arm_v7s] [arm64:Mach-O 64-bit executable arm64]</span><br><span class="line">Demo (for architecture armv7):Mach-O executable arm_v7</span><br><span class="line">Demo (for architecture armv7s):Mach-O executable arm_v7s</span><br><span class="line">Demo (for architecture arm64):Mach-O 64-bit executable arm64</span><br></pre></td></tr></table></figure><h1 id="ARM架构"><a href="#ARM架构" class="headerlink" title="ARM架构"></a>ARM架构</h1><p><code>ARM架构</code>过去称作 <code>进阶精简指令集机器（Advanced RISC Machine，更早称作：Acorn RISC Machine）</code>，是一个 <code>32位精简指令集（RISC）</code>处理器架构，ARM处理器非常适用于通讯领域，符合其主要设计目标为低耗电的特性</p><p><code>ARM</code>和<code>Intel</code>处理器的第一个区别是，前者使用 <code>精简指令集（RISC）</code>,而后者使用 <code>复杂指令集（CISC）</code></p><p>ARM处理器指令集：是指计算机ARM操作系统指令系统</p><ul><li><p>armv6、armv7、armv7s、arm64、arm64e 都是arm处理器的指令集，所有指令集原则上都是 <code>向下兼容</code> 的</p></li><li><p>苹果A7处理器支持两个不同的指令集：</p></li></ul><p><code>32位</code> ARM指令集（<code>armv6 | armv7 | armv7s</code>）<br><code>64位</code> ARM指令集（<code>arm64</code>）</p><ul><li><code>i386 | x86_64</code> 是 <code>Mac</code> 处理器的指令集</li></ul><p><strong>iOS 设备支持的指令集</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/152944846-bca8fe8e-c0c3-4988-bd76-4b3688206f38.jpg"></p><h1 id="通用二进制源码"><a href="#通用二进制源码" class="headerlink" title="通用二进制源码"></a>通用二进制源码</h1><ul><li>通过 CMD + shift + O 搜索 fat.h</li><li>找到其中通用二进制文件的头部结构 fat_header 如下所示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct fat_header &#123;</span><br><span class="line">uint32_tmagic;/* magic字段被定义为常量FAT_MAGIC，表示这是一个胖二进制 */</span><br><span class="line">uint32_tnfat_arch;/* 表示有多少个Mach-O文件 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>每个胖二进制都用 fat_arch 结构表示，在 fat_header 之后，紧接着一个活多个连续的fat_arch结构体</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct fat_arch &#123;</span><br><span class="line">cpu_type_tcputype;/* cpu 类型 */</span><br><span class="line">cpu_subtype_tcpusubtype;/* cpu的子类型 */</span><br><span class="line">uint32_toffset;/* 制定了当前cpu架构数据相对于当前文件开头的偏移量 */</span><br><span class="line">uint32_tsize;/* 数据的大小 */</span><br><span class="line">uint32_talign;/* 数据的内存对齐边界，取值必须是2的次方，它确保了当前cpu架构的目标文件在加载到内存中时，数据是经过内存优化对齐的 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="终端指令"><a href="#终端指令" class="headerlink" title="终端指令"></a>终端指令</h1><ul><li>可以通过tool来查看fat_header信息：<code>otool -f 可执行文件</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">% cd /Users/zhangjian/Library/Developer/Xcode/DerivedData/Demo-edwjvapoqaffzeeiyzyhfryhfrsr/Build/Products/Release-iphoneos/Demo.app </span><br><span class="line"></span><br><span class="line">% otool -f Demo</span><br><span class="line">Fat headers</span><br><span class="line">fat_magic 0xcafebabe</span><br><span class="line">nfat_arch 3</span><br><span class="line">architecture 0</span><br><span class="line">    cputype 12</span><br><span class="line">    cpusubtype 9</span><br><span class="line">    capabilities 0x0</span><br><span class="line">    offset 16384</span><br><span class="line">    size 79280</span><br><span class="line">    align 2^14 (16384)</span><br><span class="line">architecture 1</span><br><span class="line">    cputype 12</span><br><span class="line">    cpusubtype 11</span><br><span class="line">    capabilities 0x0</span><br><span class="line">    offset 98304</span><br><span class="line">    size 79280</span><br><span class="line">    align 2^14 (16384)</span><br><span class="line">architecture 2</span><br><span class="line">    cputype 16777228</span><br><span class="line">    cpusubtype 0</span><br><span class="line">    capabilities 0x0</span><br><span class="line">    offset 180224</span><br><span class="line">    size 80000</span><br><span class="line">    align 2^14 (16384)</span><br><span class="line">zhangjian@zhangjiandeMBP Demo.app % </span><br></pre></td></tr></table></figure><ul><li><p>可以通过lipo命令拆分、合并胖二进制文件，常用命令如下：</p><ul><li><p>$<code>lipo -info MachO文件</code>：使用lifo -info 可以查看MachO文件包含的架构</p></li><li><p>$<code>lipo MachO文件 -thin 架构 -output 输出文件路径</code>：使用<code>lipo -thin</code> 拆分某种架构</p></li><li><p>$<code>lipo -create MachO1 MachO2 -output 输出文件路径</code>：使用<code>lipo -create</code> 合并 多种架构</p></li></ul></li></ul><h1 id="lipo演示"><a href="#lipo演示" class="headerlink" title="lipo演示"></a>lipo演示</h1><ul><li>查看二进制文件中包含的架构：lipo -info Demo</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% cd /Users/zhangjian/Library/Developer/Xcode/DerivedData/Demo-edwjvapoqaffzeeiyzyhfryhfrsr/Build/Products/Release-iphoneos/Demo.app </span><br><span class="line"></span><br><span class="line">% lipo -info Demo </span><br><span class="line">Architectures in the fat file: Demo are: armv7 armv7s arm64</span><br></pre></td></tr></table></figure><ul><li><p>拆分：<code>lipo Demo -thin armv7 -output Demo_armv7</code>，如果拆分没有的架构会报错</p></li><li><p>查看拆分后的可执行文件类型：<code>file Demo_armv7</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% lipo Demo -thin armv7 -output Demo_armv7</span><br><span class="line">% file Demo_armv7</span><br><span class="line">Demo_armv7: Mach-O executable arm_v7</span><br></pre></td></tr></table></figure><ul><li>合并：<code>lipo -create Demo_armv7 Demo_arm64 -output Demo_v7_64</code></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p><code>Mach-O</code> 其实是<code> Mach Object</code>文件格式的缩写，是mac以及iOS上可执行文件的格式，是一种 <code>用于可执行文件、目标代码、动态库的文件格式</code>，且 Mach-O提供了更强的扩展性</p></li><li><p>常见的Mach-O格式：<code>.o</code>、<code>库文件（.a、.dylib、.framework）</code>、<code>可执行文件</code>、<code>dyld</code>、<code>.dsym</code></p><ul><li><p><code>.a + .h + sourceFile = .framwork</code></p></li><li><p>动态.framework：系统Framework库</p></li><li><p>静态.framwork：自定义的Framework库</p></li></ul></li><li><p>查看文件类型命令：<code>file 文件路径</code></p></li><li><p>查看Mach-O源文件的链接顺序：<code>objdump --macho -d 可执行文件</code></p></li><li><p><code>dyld</code>（the dynamic link editor）是苹果的动态链接器，mac中路径为&#x2F;usr&#x2F;lib</p></li><li><p><code>dSYM</code> 是保存 16 进制函数地址映射信息的中转文件，位于<code>/Users/&lt;用户名&gt;/Library/Developer/Xcode/Archives</code>目录。可以用于通过出错的函数地址去查询 dSYM 文件中程序对应的函数名和文件名</p></li><li><p><code>通用二进制</code>文件（Universal Binary，也称为<code>胖二进制</code>（Fat Binary））。主要适用于解决多个平台的兼容性问题</p></li><li><p>通过otool来查看fat_header信息：<code>otool -f 可执行文件</code></p></li><li><p>lipo命令拆分、合并胖二进制文件</p><ul><li><p>$<code>lipo -info MachO</code>文件：使用<code>lifo -info</code> 可以查看MachO文件包含的架构</p></li><li><p>$<code>lipo MachO文件 –thin 架构 –output 输出文件路径</code>：使用<code>lifo –thin</code> 拆分某种架构</p></li><li><p>$<code>lipo -create MachO1 MachO2 -output 输出文件路径</code>： 使用<code>lipo -create</code> 合并多种架构</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-逆向探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC高级强化04：静态库和动态库</title>
      <link href="/BboyZJ.github.io/2022/01/07/OC%E8%BF%9B%E9%98%B6/OC%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%9604%EF%BC%9AZJBlog/"/>
      <url>/BboyZJ.github.io/2022/01/07/OC%E8%BF%9B%E9%98%B6/OC%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%9604%EF%BC%9AZJBlog/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的库文件格式"><a href="#常见的库文件格式" class="headerlink" title="常见的库文件格式"></a>常见的库文件格式</h1><ul><li>.a 静态库</li><li>.dylib 传统意义的动态库</li><li>.framework 可静态库也可动态库</li><li>.xcframework 2018年推出的针对不同架构的库</li></ul><h1 id="什么是库？"><a href="#什么是库？" class="headerlink" title="什么是库？"></a>什么是库？</h1><p>库(<code>Library</code>)说白了就是一段编译好的而进行代码，加上头文件就可以供别人使用</p><h1 id="什么时候会用到库"><a href="#什么时候会用到库" class="headerlink" title="什么时候会用到库?"></a>什么时候会用到库?</h1><ul><li>某些代码需要给别人使用，但是我们不希望别人看到源码，就需要咦库的形式进行封装，只暴露出头文件</li><li>对于某些不会进行大的改动的代码，我们想减少编译的时间，就可以把它打包成库，因为库是已经编译好的二进制了，编译的时候只需要 <code>Link</code> 一下，不会浪费编译时间。</li></ul><h1 id="什么是链接？"><a href="#什么是链接？" class="headerlink" title="什么是链接？"></a>什么是链接？</h1><p>库在使用的时候需要链接（Link），链接的方式有两种：</p><ul><li><p>静态</p></li><li><p>动态</p></li></ul><h1 id="a静态库"><a href="#a静态库" class="headerlink" title=".a静态库"></a>.a静态库</h1><p><code>.o</code> 文件的合集</p><h1 id="dylib动态库"><a href="#dylib动态库" class="headerlink" title=".dylib动态库"></a>.dylib动态库</h1><p><code>.a</code> 静态库 <code>链接</code> 之后的产物，即最终链接产物</p><h1 id="什么是tdb格式"><a href="#什么是tdb格式" class="headerlink" title="什么是tdb格式"></a>什么是tdb格式</h1><p>tdb全程是text-based stub libraries，本质上就是一个YAML描述的文本文件。</p><p>他的作用是用于记录动态库的一些信息，包括导出的符号、动态库的架构信息、动态库的依赖信息</p><p>用于避免在真机开发过程中直接使用传统的dylib。</p><p>对于真机来说，由于动态库都是在设备上，在xcode上使用基于tbd格式的伪framework可以打打减少xcode的大小</p><p>@rpath</p><p>Runpath search Paths</p><p>dylib 搜索路径</p><p>运行时 ‘@rpath’ 指示 ‘dylib’ 按顺序搜索路径列表，以找到动态库，‘@rpath’ 保存一个活多个路径变量</p><p>@rpath 谁链接我，谁给我提供rpath</p><p>@executable_path：表示可执行程序所在你的目录，解析为可执行文件的绝对路径</p><p>@loader_path：表示被加载的Mach-O所在的目录，每次加载时，都可能被设置为不同的路径，由上层指定</p>]]></content>
      
      
      <categories>
          
          <category> OC-高级强化探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC高级强化03：符号与链接</title>
      <link href="/BboyZJ.github.io/2022/01/07/OC%E8%BF%9B%E9%98%B6/OC%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%9603%EF%BC%9A%E7%AC%A6%E5%8F%B7%E4%B8%8E%E9%93%BE%E6%8E%A5/"/>
      <url>/BboyZJ.github.io/2022/01/07/OC%E8%BF%9B%E9%98%B6/OC%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%9603%EF%BC%9A%E7%AC%A6%E5%8F%B7%E4%B8%8E%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="编译成目标文件-o的过程"><a href="#编译成目标文件-o的过程" class="headerlink" title="编译成目标文件.o的过程"></a>编译成目标文件.o的过程</h1><ol><li>对代码进行 <code>汇编</code></li><li>把 <code>符号</code> 进行 <code>归类</code> -&gt; <code>重定位符号表</code></li></ol><ul><li>重定位符号表 -&gt; .m&#x2F;.o 用到的 API</li></ul><ol start="3"><li>.o -&gt; <code>链接</code> -&gt; 符号表和重定位符号表 合并到 <code>一张表中</code> -&gt; 生成可执行文件 <code>exec</code></li></ol><ul><li>链接 -&gt; 处理目标文件符号的过程</li></ul><h1 id="全局-和-本地-符号"><a href="#全局-和-本地-符号" class="headerlink" title="全局 和 本地 符号"></a>全局 和 本地 符号</h1><ul><li>全局符号：可见性 - 对整个项目可见</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 全局变量</span><br><span class="line">int global_uninit_value</span><br><span class="line">// 全局符号</span><br><span class="line">void global_object() &#123;</span><br><span class="line">    NSLog(@&quot;global_object&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本地符号：可见性 - 只对当前文件可见</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 静态变量 -&gt; 本地变量</span><br><span class="line">static int static_init_value = 9;</span><br><span class="line">// 本地符号</span><br><span class="line">static void global_object() &#123;</span><br><span class="line">    NSLog(@&quot;static_global_object&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>attribute</strong>(())</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以给编译器传递属性：</span><br><span class="line">__attribute__((deprecated)) ：告诉编译器已废弃</span><br></pre></td></tr></table></figure><ul><li>two_levelnamespace &amp; flat_namespace</li></ul><p><code>二级命名空间</code> 与 <code>一级命名空间</code>。连接器默认采用 <code>二级命名空间</code>，也就是除了会记录符号名称，还会记录属于哪个 <code>Mach-O</code> 的，比如会记录下来 _NSLog 来自Foundation。</p><ul><li>终端查看符号表的方式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% man nm 查看具体的文档</span><br><span class="line">% nm --help </span><br></pre></td></tr></table></figure><h1 id="符号表说明"><a href="#符号表说明" class="headerlink" title="符号表说明"></a>符号表说明</h1><p><img src="https://user-images.githubusercontent.com/25925248/148521680-4c60b2f0-15c5-43e4-a955-67050bf209ca.jpeg"></p><h1 id="下面我们来通过终端来查看一个可执行文件的符号表"><a href="#下面我们来通过终端来查看一个可执行文件的符号表" class="headerlink" title="下面我们来通过终端来查看一个可执行文件的符号表"></a>下面我们来通过终端来查看一个可执行文件的符号表</h1><p>-pa ：不排序，显示所有符号</p><p><img src="https://user-images.githubusercontent.com/25925248/148521755-986985d9-e621-4770-83a4-2f73ca7b8e94.jpg"></p><p>上面的 t、s等就是符号的种类</p><h1 id="man-nm-如何使用呢"><a href="#man-nm-如何使用呢" class="headerlink" title="man nm 如何使用呢"></a>man nm 如何使用呢</h1><ul><li>终端输入 man nm</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/148521826-caa76f3d-aeb1-4693-a481-68d1c87079c1.jpg"></p><ul><li>终端输入 &#x2F;-p</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/148521895-fe74b1fe-6be8-4378-a80b-ec4d01f7c889.jpg"></p><ul><li>终端输入 &#x2F;-a</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/148521972-9f443eff-1437-4137-b910-a0033c55f1d8.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> OC-高级强化探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC高级强化02：Mach-O与链接器</title>
      <link href="/BboyZJ.github.io/2022/01/05/OC%E8%BF%9B%E9%98%B6/OC%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%9602%EF%BC%9AMach-O%E4%B8%8E%E9%93%BE%E6%8E%A5%E5%99%A8/"/>
      <url>/BboyZJ.github.io/2022/01/05/OC%E8%BF%9B%E9%98%B6/OC%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%9602%EF%BC%9AMach-O%E4%B8%8E%E9%93%BE%E6%8E%A5%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Mach-O-是什么？"><a href="#Mach-O-是什么？" class="headerlink" title="Mach-O 是什么？"></a>Mach-O 是什么？</h1><p>Mach-O(Mach Object)是 macOS、iOS、iPadOS 用来 <code>存储程序和库</code> 的 <code>文件格式</code>。<br>对应系统通过应用 二进制接口（application binary interface，缩写 <code>ABI</code>）来运行该格式的文件。</p><p>Mach-O格式用来替代BSD系统的a.out格式。Mach-O文件格式 <code>保存</code> 了在 <code>编译过程</code> 和 <code>链接过程</code> 中产生的 <code>机器代码和数据</code>，从而为 <code>静态链接和动态链接</code> 的代码提供了单一文件格式。</p><p>我习惯将 <code>Mach-O = 配置文件 + 二进制代码</code></p><p>Mach-O文件格式如下：</p><p><img src="/BboyZJ.github.io/assets/IMG_2076.PNG" alt="IMG_2076"></p><ul><li>Mach-O 是可读可写的，</li><li>Mach-O + 签名 苹果就认你这个Mach-O</li><li>Mach-O __TEXT 代码段 只读</li><li>Mach-O __DATA 数据段</li></ul><h1 id="点击Xcode运行按钮的时候，系统做了哪些事情？"><a href="#点击Xcode运行按钮的时候，系统做了哪些事情？" class="headerlink" title="点击Xcode运行按钮的时候，系统做了哪些事情？"></a>点击Xcode运行按钮的时候，系统做了哪些事情？</h1><p>首先，加载ipa包里可执行文件</p><p><code>Product</code> -&gt; <code>LoginApp</code> -&gt; <code>show in finder</code> -&gt; 右键显示包内容，找到 <code>LoginApp可执行文件</code></p><p><img src="https://user-images.githubusercontent.com/25925248/148356203-621bb40f-ef94-4bb9-90a9-ca787548c434.jpg"></p><p><strong>可执行文件的调用过程：</strong></p><p>1）调用 <code>fork</code> 函数，创建一个 <code>process</code> 进程</p><p>2）调用 <code>execve</code> 或其衍生函数，在该进程上加载，执行我们的 <code>Mach-O</code> 文件，当我们调用 <code>execve</code>(应用程序加载器)，内核实际上在执行以下操作：</p><ul><li>将文件加载到内存</li><li>开始分析 <code>Mach-O</code> 中的 <code>mach_header</code>，已确认它是有效的 <code>Mach-O</code> 文件</li></ul><p><strong>Mach-O 中是不是都是二进制？</strong></p><p>答：<code>Mach-O</code> 中就是二进制</p><p><strong>Mach-O 是不是可读可写的？</strong></p><p>答：<code>Mach-O</code> 是 <code>可读可写</code> 的 <code>二进制文件</code> </p><p><strong>程序的入口为什么一定是 main ？</strong></p><p>答：<code>Mach-O</code> 中默认指定了程序的入口必须是 <code>main</code>，我们写的代码最终会转成 <code>二进制</code>，最后落在 <code>Mach-O</code> 中，它的排列是按照一定规则的。</p><h1 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h1><ol><li>什么是 <code>编译</code>？</li></ol><p>答：实际上，<code>编译</code> 的过程就是去把写在文件(.h&#x2F;.m等)中的 <code>代码</code> 放到对应的 <code>Mach-O的配置</code>中。</p><ol start="2"><li>什么是 <code>链接</code>？</li></ol><p>答：当我 <code>编译</code> 可执行文件的时候，中间要经过一个目标文件 <code>.o</code> 文件，<code>链接</code>的本质就是把多个目标文件组合成一个文件的过程</p><p>在代码 <code>编译</code> 中，我们会生成多个.o目标文件，最后要生成一个可执行文件，而<code>链接</code>就是把多个.o的<code>目标文件符号表合</code> 并成一起，最终生成一个可执行文件的过程。</p><h1 id="符号表-Symbol-Table"><a href="#符号表-Symbol-Table" class="headerlink" title="符号表 Symbol Table"></a>符号表 Symbol Table</h1><p>Symbol Table：就是用来保存符号</p><p>String Table：就是用来保存符号的名称</p><p>Indirect Symbol Table：间接符号表，保存使用的外部符号，更准确一点就是使用的<code>外部动态库</code>的符号，是Symbol Table的子集。</p><h1 id="如何让Xcode编译的命令显示到终端上"><a href="#如何让Xcode编译的命令显示到终端上" class="headerlink" title="如何让Xcode编译的命令显示到终端上"></a>如何让Xcode编译的命令显示到终端上</h1><ul><li>首先打开终端 <code>command + t</code> 新建一个窗口，输入 <code>tty</code>，会输出一个像链接一样的东西，这个链接的意思就是你可以把其他地方的输出定位到这个地方</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Last login: Thu Jan  6 10:21:55 on ttys001</span><br><span class="line">zhangjian@zhangjiandeMacBook-Pro ~ % tty</span><br><span class="line">/dev/ttys005</span><br></pre></td></tr></table></figure><ul><li>然后在XCode中，LoginApp -&gt; Build Phases -&gt; 点击+号 -&gt; 添加 Run Script 执行脚本，添加如下内容，让输出的内容 <code>重定向</code> 显示到终端上</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;ZJ_Cat&quot; &gt; /dev/ttys005</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/25925248/148356392-edec7ccd-d2d4-42f7-adb2-1a961a27a0a9.jpg"></p><ul><li>点击运行按钮，你会在终端上打印 <code>ZJ_Cat</code> 内容</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/148356448-84071f53-380f-4699-88a1-bacfe9d1c8d1.jpg"></p><ul><li>我们知道在 <code>xxconfig</code> 定义的变量可以在项目中获取， 同样的也可以被运行脚本的 <code>Run Script</code> 所获取</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;$&#123;HOST_URL&#125;&quot; &gt; /dev/ttys005</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/25925248/148356517-f510ceb3-47a8-4998-b617-a2924e51c8f0.jpg"></p><p>由此可见，我们可以通过 <code>脚本+xxconfig</code> 来实现查看 <code>可执行文件</code> 的输出的 <code>符号表</code></p><h1 id="这里我先不做xxconfig-脚本记录，暂时列出几个知识点："><a href="#这里我先不做xxconfig-脚本记录，暂时列出几个知识点：" class="headerlink" title="这里我先不做xxconfig+脚本记录，暂时列出几个知识点："></a>这里我先不做xxconfig+脚本记录，暂时列出几个知识点：</h1><ol><li>项目瘦身的顺序：</li></ol><ul><li>-O1 -Oz 生成目标文件 （编译）</li><li>dead code strip 使代码剥离 （链接）</li><li>strip 剥离符号（mach-o）</li></ul><ol start="2"><li><p>$SRCROOT 代码的路径</p></li><li><p>-p：不排序</p></li><li><p>-a：显示所有符号，包含调式符号</p></li><li><p>nm -pa 可执行文件路径 : 查看可执行文件的符号表</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> OC-高级强化探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC高级强化01：多环境配置</title>
      <link href="/BboyZJ.github.io/2022/01/04/OC%E8%BF%9B%E9%98%B6/OC%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%9601%EF%BC%9A%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/BboyZJ.github.io/2022/01/04/OC%E8%BF%9B%E9%98%B6/OC%E9%AB%98%E7%BA%A7%E5%BC%BA%E5%8C%9601%EF%BC%9A%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h1><ul><li>Project : 包含了项目所有的代码、资源文件和所有信息。</li><li>Target : 对指定代码和资源文件的具体构建方式。</li><li>Scheme : 对指定的Target的环境配置</li></ul><p>在实际开发中，我们必须要进行网络请求（<code>内网和外网</code>），而网络请求则就要针对不同的环境（<code>开发</code>、<code>测试</code>、<code>生产</code>）有不同的的<code>主机名称（URL_HOST）</code>，那么我们如何获取某个环境下的<code>URL_HOST</code>，那么在这个过程中，我们需要进行配置，而配置的方式有三种：</p><ul><li>Target 配置</li><li>Scheme 配置</li><li>xcconfig 配置</li></ul><h2 id="Target-配置"><a href="#Target-配置" class="headerlink" title="Target 配置"></a>Target 配置</h2><p>1、新建Dev的Target</p><ul><li><p>选中 <code>Target</code> 下 <code>LoginApp</code> -&gt; 右键选中 <code>Duplicate</code> 复制 -&gt; 生成新的 <code>LoginApp copy</code> -&gt; 将其改名为 <code>LoginApp-Dev</code> </p></li><li><p>修改 <code>Bundle Identifier</code> 名为 <code>com.srsf.LoginApp-Dev</code></p></li><li><p>修改新生成的 <code>LoginApp copy-info</code> 名为 <code>LoginApp-Dev-info</code>，plist名称改变同时需要在 <code>Build Settings</code> -&gt; <code>Packaging</code> -&gt; <code>info.list File</code> 下 -&gt; 将 <code>LoginApp copy-info</code> 改成  <code>LoginApp-Dev-info</code>。</p></li></ul><p>如下图：</p><p><img src="https://user-images.githubusercontent.com/25925248/148040037-bc48f2b1-d2b6-46b9-9691-9c5bb2790677.png" alt="新建Dev构建方式"></p><p>注：到目前为止，你运行 <code>LoginApp</code> 和 <code>LoginApp-Dev</code> 会生成两个 <code>App</code>。</p><p>2、添加自定义宏 <code>macros</code></p><ul><li>选中 <code>LoginApp-Dev</code> -&gt; <code>Builds Settings</code> -&gt; <code>all</code> -&gt; 搜索 <code>macros</code> -&gt; <code>Apple Clang - Preprocessing</code> -&gt; 选中 <code>Debug</code> 右键空白双击 -&gt; 弹出添加 DEV&#x3D;1；同理，Release 设置 DEV&#x3D;0</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/148154855-3f871465-7416-4840-92f9-5e0d600feece.png" alt="自定义宏DEV"></p><ul><li>此时，自定义的宏已经生效了，此时可以在任意地方调用下面的方式进行判断使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if DEV</span><br><span class="line">    #define URL_HOST @&quot;http://192.168.0.1&quot;</span><br><span class="line">#else</span><br><span class="line">    #define URL_HOST @&quot;http://192.168.0.2&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>当你切换不同的<code>Scheme</code>时，打印不同的<code>URL_HOST</code></p><p>3、总结</p><p><code>Target</code> 配置这种方式，每创建一个 <code>target</code> 都会产生新的 <code>info.plist</code>，每一个都需要去配置 <code>macros</code>，配置比较乱，<code>不推荐</code>使用。</p><h2 id="Scheme-配置"><a href="#Scheme-配置" class="headerlink" title="Scheme 配置"></a>Scheme 配置</h2><p>1、首先我们要了解到 <code>Scheme</code> 默认是有两种环境变量 <code>Debug</code> 和 <code>Release</code>，可以在 <code>Edit Scheme</code> -&gt; <code>Run</code> -&gt; <code>info</code> -&gt; <code>Build Configuration</code> 下查看。</p><p><img src="https://user-images.githubusercontent.com/25925248/148157263-f4050f0a-5394-4301-b45b-8f2b1a513549.png"></p><p>2、其次，与之对应的环境配置在 <code>Project</code> -&gt; <code>LoginApp</code> -&gt; <code>Configurations</code> 下也可以看到</p><p><img src="https://user-images.githubusercontent.com/25925248/148157442-489a540a-7e7b-4a46-99f1-afe78599c0dd.png"></p><p>3、在 <code>Project</code> -&gt; <code>Configurations</code> 下，我们可以创建一个自己的配置环境 <code>Beta</code>,现在我们有 了 <code>三</code> 种配置方式，对应的在 <code>Edit Scheme</code> -&gt; <code>Run</code> -&gt; <code>info</code> -&gt; <code>Build Configuration</code> 下也有三种，同时在 <code>Target</code> -&gt; <code>Build Settings</code> -&gt; <code>Build Active Architecture Only</code> 下也有对应的三种配置方式，说明这是一个 <code>全局</code> 的配置，如下图：</p><p><img src="https://user-images.githubusercontent.com/25925248/148163968-d92e293e-9d3f-4f88-8060-5b6dc784ee0c.png" alt="1"></p><p><img src="https://user-images.githubusercontent.com/25925248/148164034-cab45e0e-bfe1-40e2-92f7-ec088ceaeedc.png" alt="2"></p><p><img src="https://user-images.githubusercontent.com/25925248/148164072-7bb0e3a3-ac39-4ff3-a29c-37f4cc1bb2b0.png" alt="3"></p><p>3、新建 Scheme</p><ul><li>点击 <code>LoginApp</code> -&gt; manager Schemes -&gt; 点击 + 号 -&gt; 添加 Debug 和 Beta 两种，加上 LoginApp 本身Release就是三种，对应上面 三种 配置</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/148164763-187ae8cd-4478-46ff-b4d6-847ed0d21440.png">)</p><ul><li>点击 <code>Edit Scheme</code> 切换 <code>Scheme</code>，并指定 <code>Configurations</code>，如下图</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/148170785-850c4843-0f28-4f43-a57f-09f0368884fe.jpg"></p><p>4、自定义主机名URL_HOST</p><ul><li><code>Target</code> -&gt; <code>Build Settings</code> -&gt; 点击 + 号 -&gt; <code>Add User-Defined Settings</code> -&gt; <code>URL_HOST</code>，此时我们发现其对应的配置也是三个，分别设值如下：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/148171973-25130a7c-53af-4c95-a0bc-3dbab6b15faf.png"></p><p>5、将 <code>URL_HOST</code> 添加到 <code>info.plist</code> 文件中，<code>Build Settings</code> 中的 配置可以通过 <code>info.plist</code> 暴露出来，可以直接读出来</p><p><img src="https://user-images.githubusercontent.com/25925248/148171617-8564db08-7c08-41a3-bfab-4511c2a2de8d.png"></p><p>6、在项目中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString * path = [NSBundle.mainBundle pathForResource:@&quot;Info&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">NSDictionary * infoDic = [[NSDictionary alloc] initWithContentsOfFile:path];</span><br><span class="line">NSLog(@&quot;%@&quot;,infoDic[@&quot;HOST_URL&quot;]);</span><br></pre></td></tr></table></figure><p>切换 <code>Scheme</code> ，打印如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Debug：http://137.0.0.2</span><br><span class="line">Beta：http://137.0.0.1</span><br><span class="line">LoginApp：http://www.zjboy.com</span><br></pre></td></tr></table></figure><p>7、同理配置图标的也一样</p><p><img src="https://user-images.githubusercontent.com/25925248/148173031-4941acc4-ae67-4972-b4cf-cfdafe8a8c2f.png"></p><p><img src="/BboyZJ.github.io/assets/16413657363279.jpg"></p><h2 id="xcconfig-配置"><a href="#xcconfig-配置" class="headerlink" title="xcconfig 配置"></a>xcconfig 配置</h2><p>1、在实际项目中，我们可能会有多个主机名称HOST_URL，因此，我们还是需要去配置多个Configurations，下面还是以三个为准</p><ul><li>在 <code>Project</code> -&gt; <code>LoginApp</code> -&gt; <code>Configurations</code> 下，我们可以创建一个自己的配置环境 <code>Beta</code>,现在我们有 了 <code>三</code> 种配置方式，对应的在 <code>Edit Scheme</code> -&gt; <code>Run</code> -&gt; <code>info</code> -&gt; <code>Build Configuration</code> 下也有三种，同时在 <code>Target</code> -&gt; <code>Build Settings</code> -&gt; <code>Build Active Architecture Only</code> 下也有对应的三种配置方式，说明这是一个 <code>全局</code> 的配置，如下图：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/148163968-d92e293e-9d3f-4f88-8060-5b6dc784ee0c.png" alt="1"></p><p><img src="https://user-images.githubusercontent.com/25925248/148164034-cab45e0e-bfe1-40e2-92f7-ec088ceaeedc.png" alt="2"></p><p>2、在主项目下，创建 <code>Congifg</code> 文件，并在下面创建三个对应环境的 <code>.xxconfig</code> 文件</p><ul><li>在Config文件夹下 -&gt; command + N -&gt; 搜索config</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/148355879-6b0d7d6f-3a30-49cf-af9d-9dfeae7c34de.jpg"></p><ul><li>输入对应的名称 -&gt; 点击create</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/148355970-ade68d43-9816-4697-92d6-b451aa09e20d.jpg"></p><ul><li>创建成功之后，如下图</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/148356017-6f74c235-2b17-4e3b-8acf-e190f8c98a91.jpg"></p><p>2、选择对应Target的进行配置</p><p><img src="https://user-images.githubusercontent.com/25925248/148356086-b84672de-cce9-472e-a564-027283494400.jpg"></p><p>3、在 xxconfig 文件中写入 HOST_URL</p><ul><li>Debug 下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = /</span><br><span class="line">HOST_URL = http:$&#123;A&#125;/127.0.0.1</span><br></pre></td></tr></table></figure><ul><li>Beta</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = /</span><br><span class="line">HOST_URL = http:$&#123;A&#125;/127.0.0.2</span><br></pre></td></tr></table></figure><ul><li>Release ：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = /</span><br><span class="line">HOST_URL = http:$&#123;A&#125;/www.bboyzj.cn</span><br></pre></td></tr></table></figure><p>4、同样，我们需要在 <code>info.plist</code> 文件中暴露，在项目中取出</p><p><img src="https://user-images.githubusercontent.com/25925248/148171617-8564db08-7c08-41a3-bfab-4511c2a2de8d.png"></p><p>5、项目中代码取出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString * path = [NSBundle.mainBundle pathForResource:@&quot;Info&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">    NSDictionary * infoDic = [[NSDictionary alloc] initWithContentsOfFile:path];</span><br><span class="line">    NSLog(@&quot;%@&quot;,infoDic[@&quot;HOST_URL&quot;]);</span><br></pre></td></tr></table></figure><p>切换不同的 scheme 的打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Debug：http://127.0.0.1</span><br><span class="line"></span><br><span class="line">Beta： http://127.0.0.2</span><br><span class="line"></span><br><span class="line">Release：https://www.bboyzj.cn</span><br></pre></td></tr></table></figure><h1 id="除了上面三种配置实现，其实还有一种实现，就是pch实现"><a href="#除了上面三种配置实现，其实还有一种实现，就是pch实现" class="headerlink" title="除了上面三种配置实现，其实还有一种实现，就是pch实现"></a>除了上面三种配置实现，其实还有一种实现，就是pch实现</h1><ul><li>到 Target -&gt; Build Settings -&gt; 设值不同的DEBUG值</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/148196781-2ff38e17-209d-443f-b39e-b9ca84e30de4.jpg"></p><ul><li>具体是现代吗</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#if (DEBUG == 1)</span><br><span class="line">    #define kBaseUrl @&quot;http://127.0.0.1&quot;</span><br><span class="line">#elif (DEBUG == 2)</span><br><span class="line">    #define kBaseUrl @&quot;http://127.0.0.2&quot;</span><br><span class="line">#else</span><br><span class="line">    #define kBaseUrl @&quot;https://www.bboyzj.cn&quot;</span><br><span class="line">#endif</span><br><span class="line">    NSLog(@&quot;url:%@&quot;,kBaseUrl);</span><br></pre></td></tr></table></figure><h2 id="xxconfig-其他功能"><a href="#xxconfig-其他功能" class="headerlink" title="xxconfig 其他功能"></a>xxconfig 其他功能</h2><ul><li>xxconfig 全名是 xcodeConfig，它不仅仅是一个文件，它的本质是控制 <code>Build Settings</code> 里面的选项(比如配置动态库、静态库等)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// ld 配置到链接器上</span><br><span class="line">// OTHER_LDFLAGS 即 Other Linker Flags 的缩写</span><br><span class="line">OTHER_LDFLAGS = -framework &quot;AFNetworking&quot;</span><br></pre></td></tr></table></figure><ul><li>在Debug配置下运行，报错 <code>ld: framework not found AFNetworking</code> ，然后我们找到 <code>Other Linker Flags</code>，可以看到如下</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/148196904-7440e9d8-760f-4561-a009-e6fd2bee9c98.jpg"></p><ul><li><p>他的原理与 <code>cocoapods</code> 的原理相同</p></li><li><p>想查找 <code>Build Settings</code> 中选项的缩写，这里有一个网站可以去查看 <a href="https://xcodebuildsettings.com/">Build Settings 缩写网站</a></p></li></ul><p>比如搜索一个 <code>header search path</code>，找到其缩写 <code>HEADER_SEARCH_PATHS</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEADER_SEARCH_PATHS = \user\zjbboy</span><br></pre></td></tr></table></figure><p>你会在 <code>build settings</code> 找到</p><p><img src="https://user-images.githubusercontent.com/25925248/148196977-df00dadc-eacb-45f8-b8c4-6bef7a716402.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> OC-高级强化探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理41：内存优化（一）野指针探测</title>
      <link href="/BboyZJ.github.io/2021/07/22/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8641%EF%BC%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E9%87%8E%E6%8C%87%E9%92%88%E6%8E%A2%E6%B5%8B/"/>
      <url>/BboyZJ.github.io/2021/07/22/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8641%EF%BC%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E9%87%8E%E6%8C%87%E9%92%88%E6%8E%A2%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要讲解两种野指针检测的原理和实现</p><h1 id="技术点：野指针探测"><a href="#技术点：野指针探测" class="headerlink" title="技术点：野指针探测"></a>技术点：野指针探测</h1><p>本文的主要目的是理解野指针的形成过程以及如果去检测野指针</p><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>在介绍野指针之前，首先说下目前的异常处理类型，附 <a href="https://developer.apple.com/documentation/xcode/understanding-the-exception-types-in-a-crash-report">苹果官网链接</a></p><h1 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h1><p>异常类型分为两类：</p><ul><li><p>软件异常：主要来自 <code>kill()、phread_kill()、iOS中的NSException未捕获、absort等</code></p></li><li><p>硬件异常：硬件的信号处理器trap，是和平台相关的，野指针崩溃大部分是硬件异常</p></li></ul><p>而处理异常时，需要关注两个概念</p><ul><li><p><code>Mach</code>异常：<code>Mach</code>层异常</p></li><li><p><code>UNIX</code>信号：BSD层获取</p></li></ul><p>iOS中的POSIX API就是通过Mach之上的BSD层实现的，如下图所示：</p><p><img src="/BboyZJ.github.io/assets/16488640293427.jpg"></p><ul><li><p><code>Mach</code> 是一个受 <code>Acccent</code> 启发而高出的Unix系统</p></li><li><p><code>BSD</code> 层是建立在Mach之上，是XNU中一个不可分割的一部分，BSD负责提供可靠的、现代的API</p></li><li><p><code>POSIX</code> 表示可移植操作系统接口（Portable Operation System Interface）</p></li></ul><p>所以，综上所述，Mach异常和UNIX信号存在对应的关系</p><p><img src="/BboyZJ.github.io/assets/16488657025540.jpg"></p><ul><li>硬件异常流程：硬件异常 -&gt; Mach异常 -&gt; UNIX信号</li><li>软件异常流程：软件异常 -&gt; UNIX异常</li></ul><h1 id="Mach异常与UNIX信号的转换"><a href="#Mach异常与UNIX信号的转换" class="headerlink" title="Mach异常与UNIX信号的转换"></a>Mach异常与UNIX信号的转换</h1><p>下面是 <code>Mach异常</code> 与 <code>UNIX信号</code> 的转换关系代码，来自 <code>xnu</code> 中的 <code>bsd/uxkern/ux_exception.c</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">switch(exception) &#123;</span><br><span class="line">case EXC_BAD_ACCESS:</span><br><span class="line">    if (code == KERN_INVALID_ADDRESS)</span><br><span class="line">        *ux_signal = SIGSEGV;</span><br><span class="line">    else</span><br><span class="line">        *ux_signal = SIGBUS;</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case EXC_BAD_INSTRUCTION:</span><br><span class="line">    *ux_signal = SIGILL;</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case EXC_ARITHMETIC:</span><br><span class="line">    *ux_signal = SIGFPE;</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case EXC_EMULATION:</span><br><span class="line">    *ux_signal = SIGEMT;</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case EXC_SOFTWARE:</span><br><span class="line">    switch (code) &#123;</span><br><span class="line"></span><br><span class="line">    case EXC_UNIX_BAD_SYSCALL:</span><br><span class="line">    *ux_signal = SIGSYS;</span><br><span class="line">    break;</span><br><span class="line">    case EXC_UNIX_BAD_PIPE:</span><br><span class="line">    *ux_signal = SIGPIPE;</span><br><span class="line">    break;</span><br><span class="line">    case EXC_UNIX_ABORT:</span><br><span class="line">    *ux_signal = SIGABRT;</span><br><span class="line">    break;</span><br><span class="line">    case EXC_SOFT_SIGNAL:</span><br><span class="line">    *ux_signal = SIGKILL;</span><br><span class="line">    break;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">case EXC_BREAKPOINT:</span><br><span class="line">    *ux_signal = SIGTRAP;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将其对应关系汇总成一个表格，如下所示</li></ul><p><img src="/BboyZJ.github.io/assets/16488661552655.jpg"></p><ul><li>其中 Mach异常有以下</li></ul><p><img src="/BboyZJ.github.io/assets/16488662828917.jpg"></p><ul><li>UNIX信号有以下几种</li></ul><p><img src="/BboyZJ.github.io/assets/16488663202265.jpg"></p><h1 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h1><p>指向的 <code>对象被释放或收回</code>，但是该 <code>指针没有做任何的修改</code>，以至于 该<code>指针仍指向已经回收的内存地址</code>，这个指针就是 <code>野指针</code></p><h2 id="野指针分类"><a href="#野指针分类" class="headerlink" title="野指针分类"></a>野指针分类</h2><p>这个参考腾讯Bugly团队的总结，大致分为两类</p><ul><li>内存没被覆盖</li><li>内存被覆盖</li></ul><p>如下图所示</p><p><img src="/BboyZJ.github.io/assets/16488665261518.jpg"></p><h2 id="为什么OC野指针的crash这么多？"><a href="#为什么OC野指针的crash这么多？" class="headerlink" title="为什么OC野指针的crash这么多？"></a>为什么OC野指针的crash这么多？</h2><p>我们一般在APP发版前，都会经过多轮的 <code>自测、内侧、灰度测试</code> 等，按照常理来说，大部分的crash应该都被覆盖了，但是由于 <code>野指针的随机性</code>，使得经常在测试时不会出现crash，而是在 <code>线上出现crash</code>，这对App体验来说是非常致命的</p><p>而野指针的随机性问题大致可以分为两类：</p><ul><li>跑不进出错的逻辑，执行不到出错的代码，这种可以通过 <code>提高测试场景覆盖率</code> 来解决</li><li>跑进有问题的逻辑，但是野指针指向的地址并不一定会导致crash，原因是因为：<code>野指针</code> 其本质是指向 <code>已经删除的对象</code> 或 <code>受限内存区域</code> 的指针，这里说的 <code>OC野指针</code>，是指 <code>OC对象释放后指针未置空而导致的野指针</code>。这里不必现的原因是因为 <code>dealloc</code> 执行后只是告诉系统，这片 <code>内存我不用了</code>，<code>而系统并没有让这片内存不能访问</code>。</li></ul><h2 id="野指针解决思路"><a href="#野指针解决思路" class="headerlink" title="野指针解决思路"></a>野指针解决思路</h2><p>这里主要是借鉴Xcode中的两种处理方案：</p><p><img src="/BboyZJ.github.io/assets/16488670422301.jpg"></p><ul><li>Malloc Scrrbble，其<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/MallocDebug.html">官方解释</a>如下：申请内存 <code>alloc</code> 时在内存上填 <code>0xAA</code>，释放内存 <code>dealloc</code> 在内存上填 <code>0x55</code>。</li></ul><p><img src="/BboyZJ.github.io/assets/16488671458859.jpg"></p><ul><li><code>Zombie Objects</code>，其 <a href="https://developer.apple.com/documentation/xcode/investigating-crashes-for-zombie-objects?preferredLanguage=occ">官方解释</a> 如下：一个对象已经解除了它的引用，已经释放掉，但是此时仍然是可以接收消息，这个对象就叫做 <code>Zombie Objects（僵尸对象）</code>。这种方案的重点就是 <code>将释放的对象，全部转为僵尸对象</code></li></ul><p><img src="/BboyZJ.github.io/assets/16488672958625.jpg"></p><h2 id="两种方案对比"><a href="#两种方案对比" class="headerlink" title="两种方案对比"></a>两种方案对比</h2><ul><li><p><code>僵尸对象</code> 相比 <code>Malloc Scribble</code>，不需要考虑会不会崩溃的问题，只要野指针指向僵尸对象，那么再次访问野指针就一定会崩溃</p></li><li><p>僵尸对象这种方式，不如 <code>Malloc Scribble覆盖面广</code>，可以通过 <code>hook free</code> 方法将c函数也包含在其中</p></li></ul><h2 id="Malloc-Scribble"><a href="#Malloc-Scribble" class="headerlink" title="Malloc Scribble"></a>Malloc Scribble</h2><p>思路：当访问到对象内存中填写的是 <code>0xAA、0x55</code> 时，程序就会出现异常</p><ul><li>申请内存 <code>alloc</code> 时在内存上填 <code>0xAA</code></li><li>释放内存 <code>dealloc</code> 使在内存上填 <code>0x55</code></li></ul><p>以上的申请和释放的填充分别对应以下两种情况</p><ul><li>申请：没有错初始化就直接被访问</li><li>释放：释放后访问</li></ul><p>所以综上所述，针对野指针，我们的解决办法是：在对象释放时做数据填充 <code>0x55</code> 即可，关于对象的释放流程可以参考这篇文章 <a href="">OC底层原理35：内存管理（一）TaggedPointer&#x2F;retain&#x2F;release&#x2F;dealloc&#x2F;</a></p><h1 id="野指针探测实现1"><a href="#野指针探测实现1" class="headerlink" title="野指针探测实现1"></a>野指针探测实现1</h1><p>这个实现主要依据 <a href="https://github.com/fangjinfeng/MySampleCode/tree/master/FJFZombieSnifferDemo">腾讯Bugly工程师：陈其锋</a> 的分享，在其代码的主要思路是：</p><ul><li><p>通过 <code>fishhook</code> 替换 <code>c函数</code> 的 <code>free</code> 方法为自定义的 <code>safe_free</code>，类似于 <code>Method Swizzling</code></p></li><li><p>在 <code>safe_free</code> 方法中对 <code>已经释放变量的内</code>存，填充 <code>0x55</code> ，使已经释放变量 <code>不能访问</code>，从而使某些野指针的crash从不必现变成 <code>必现</code></p><ul><li><p>为了 <code>防止填充0x55的内存内新的数据内容填充</code>，使野指针crash变成不必现，在这里采用的策略是，safe_free不释放这片内存，而是自己保留着，即safe_free方法中不会真的调用free。</p></li><li><p>同时为了 <code>防止系统内存过快消耗（因为要保留内存）</code>，需要在 <code>保留内存大于一定值时释放一部分</code>，防止被系统杀死，同时，在收到 <code>系统内存警告</code> 时，也需要 <code>释放一部分内存</code></p></li></ul></li><li><p>发生crash时，得到的崩溃信息有限，不利于排查问题，所以这里采用代理类（即集成自 NSProxy的子类），重写消息转发的三个方法（参考这篇文章 <a href="https://www.bboyzj.cn/2020/10/06/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8614-3%EF%BC%9A%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%E4%B9%8B%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E5%86%B3%E8%AE%AE&%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/">OC底层原理14-3：消息流程分析之动态方法决议 &amp; 消息转发</a>），以及NSObject的实例方法，来获取异常信息。但是这样的话，还有一个问题，就是NSProxy只能做OC对象的代理，所以需要在safe_free中增加对象类型的判断</p></li></ul><p>以下是完整的野指针探测实现代码</p><ul><li>引入fishhook</li></ul><p><img src="/BboyZJ.github.io/assets/16488770386627.jpg"></p><ul><li>实现NSProxy的代理子类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--1、MIZombieProxy.h--&gt;</span><br><span class="line">@interface MIZombieProxy : NSProxy</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) Class originClass;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&lt;!--2、MIZombieProxy.m--&gt;</span><br><span class="line">#import &quot;MIZombieProxy.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation MIZombieProxy</span><br><span class="line"></span><br><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector&#123;</span><br><span class="line">    return [self.originClass instancesRespondToSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel&#123;</span><br><span class="line">    return [self.originClass instanceMethodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation: (NSInvocation *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    [self _throwMessageSentExceptionWithSelector: invocation.selector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define MIZombieThrowMesssageSentException() [self _throwMessageSentExceptionWithSelector: _cmd]</span><br><span class="line">- (Class)class&#123;</span><br><span class="line">    MIZombieThrowMesssageSentException();</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isEqual:(id)object&#123;</span><br><span class="line">    MIZombieThrowMesssageSentException();</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line">- (NSUInteger)hash&#123;</span><br><span class="line">    MIZombieThrowMesssageSentException();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">- (id)self&#123;</span><br><span class="line">    MIZombieThrowMesssageSentException();</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isKindOfClass:(Class)aClass&#123;</span><br><span class="line">    MIZombieThrowMesssageSentException();</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isMemberOfClass:(Class)aClass&#123;</span><br><span class="line">    MIZombieThrowMesssageSentException();</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)conformsToProtocol:(Protocol *)aProtocol&#123;</span><br><span class="line">    MIZombieThrowMesssageSentException();</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isProxy&#123;</span><br><span class="line">    MIZombieThrowMesssageSentException();</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)description&#123;</span><br><span class="line">    MIZombieThrowMesssageSentException();</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - MRC</span><br><span class="line">- (instancetype)retain&#123;</span><br><span class="line">    MIZombieThrowMesssageSentException();</span><br><span class="line">    return  nil;</span><br><span class="line">&#125;</span><br><span class="line">- (oneway void)release&#123;</span><br><span class="line">    MIZombieThrowMesssageSentException();</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    MIZombieThrowMesssageSentException();</span><br><span class="line">    [super dealloc];</span><br><span class="line">&#125;</span><br><span class="line">- (NSUInteger)retainCount&#123;</span><br><span class="line">    MIZombieThrowMesssageSentException();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">- (struct _NSZone *)zone&#123;</span><br><span class="line">    MIZombieThrowMesssageSentException();</span><br><span class="line">    return  nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - private</span><br><span class="line">- (void)_throwMessageSentExceptionWithSelector:(SEL)selector&#123;</span><br><span class="line">    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;(-[%@ %@]) was sent to a zombie object at address: %p&quot;, NSStringFromClass(self.originClass),NSStringFromSelector(selector), self] userInfo:nil];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>hook free 方法的具体实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--1、MISafeFree.h--&gt;</span><br><span class="line">@interface MISafeFree : NSObject</span><br><span class="line"></span><br><span class="line">//系统警告时，用函数释放一些内存</span><br><span class="line">void free_safe_mem(size_t freeNum);</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&lt;!--2、MISafeFree.m--&gt;</span><br><span class="line">#import &quot;MISafeFree.h&quot;</span><br><span class="line">#import &quot;queue.h&quot;</span><br><span class="line">#import &quot;fishhook.h&quot;</span><br><span class="line">#import &quot;MIZombieProxy.h&quot;</span><br><span class="line"></span><br><span class="line">#import &lt;dlfcn.h&gt;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &lt;malloc/malloc.h&gt;</span><br><span class="line"></span><br><span class="line">//用于保存zombie类</span><br><span class="line">static Class kMIZombieIsa;</span><br><span class="line">//用于保存zombie类的实例变量大小</span><br><span class="line">static size_t kMIZombieSize;</span><br><span class="line"></span><br><span class="line">//用于表示调用free函数</span><br><span class="line">static void(* orig_free)(void *p);</span><br><span class="line">//用于保存已注册的类的集合</span><br><span class="line">static CFMutableSetRef registeredClasses = nil;</span><br><span class="line">/*</span><br><span class="line"> 用来保存自己保留的内存</span><br><span class="line"> - 1、队列要线程安全或者自己加锁</span><br><span class="line"> - 2、这个队列内部应该尽量少申请和释放堆内存</span><br><span class="line"> */</span><br><span class="line">struct DSQueue *_unfreeQueue = NULL;</span><br><span class="line">//用来记录自己保存的内存的大小</span><br><span class="line">int unfreeSize = 0;</span><br><span class="line"></span><br><span class="line">//最多存储的内存，大于这个值就释放一部分</span><br><span class="line">#define MAX_STEAL_MEM_SIZE 1024*1024*100</span><br><span class="line">//最多保留的指针个数，超过就释放一部分</span><br><span class="line">#define MAX_STEAL_MEM_NUM 1024*1024*10</span><br><span class="line">//每次释放时释放的指针数量</span><br><span class="line">#define BATCH_FREE_NUM 100</span><br><span class="line"></span><br><span class="line">@implementation MISafeFree</span><br><span class="line"></span><br><span class="line">#pragma mark - Public Method</span><br><span class="line">//系统警告时，用函数释放一些内存</span><br><span class="line">void free_safe_mem(size_t freeNum)&#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">    //获取队列的长度</span><br><span class="line">    size_t count = ds_queue_length(_unfreeQueue);</span><br><span class="line">    //需要释放的内存大小</span><br><span class="line">    freeNum = freeNum &gt; count ? count : freeNum;</span><br><span class="line">    //遍历并释放</span><br><span class="line">    for (int i = 0; i &lt; freeNum; i++) &#123;</span><br><span class="line">        //获取未释放的内存块</span><br><span class="line">        void *unfreePoint = ds_queue_get(_unfreeQueue);</span><br><span class="line">        //创建内存块申请的大小</span><br><span class="line">        size_t memSize = malloc_size(unfreePoint);</span><br><span class="line">        //原子减操作，多线程对全局变量进行自减</span><br><span class="line">        __sync_fetch_and_sub(&amp;unfreeSize, (int)memSize);</span><br><span class="line">        //释放</span><br><span class="line">        orig_free(unfreePoint);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Life Circle</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">    loadZombieProxyClass();</span><br><span class="line">    init_safe_free();</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Private Method</span><br><span class="line">void safe_free(void* p)&#123;</span><br><span class="line">    </span><br><span class="line">    //获取自己保留的内存的大小</span><br><span class="line">    int unFreeCount = ds_queue_length(_unfreeQueue);</span><br><span class="line">    //保留的内存大于一定值时就释放一部分</span><br><span class="line">    if (unFreeCount &gt; MAX_STEAL_MEM_NUM*0.9 || unfreeSize&gt;MAX_STEAL_MEM_SIZE) &#123;</span><br><span class="line">        free_safe_mem(BATCH_FREE_NUM);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //创建p申请的内存大小</span><br><span class="line">        size_t memSize = malloc_size(p);</span><br><span class="line">        //有足够的空间才覆盖</span><br><span class="line">        if (memSize &gt; kMIZombieSize) &#123;</span><br><span class="line">            //指针强转为id对象</span><br><span class="line">            id obj = (id)p;</span><br><span class="line">            //获取指针原本的类</span><br><span class="line">            Class origClass = object_getClass(obj);</span><br><span class="line">            //判断是不是objc对象</span><br><span class="line">            char *type = @encode(typeof(obj));</span><br><span class="line">            /*</span><br><span class="line">             - strcmp 字符串比较</span><br><span class="line">             - CFSetContainsValue 查看已注册类中是否有origClass这个类</span><br><span class="line">             </span><br><span class="line">             如果都满足，则将这块内存填充0x55</span><br><span class="line">             */</span><br><span class="line">            if (strcmp(&quot;@&quot;, type) == 0 &amp;&amp; CFSetContainsValue(registeredClasses, origClass)) &#123;</span><br><span class="line">                //内存上填充0x55</span><br><span class="line">                memset(obj, 0x55, memSize);</span><br><span class="line">                //将自己类的isa复制过去</span><br><span class="line">                memcpy(obj, &amp;kMIZombieIsa, sizeof(void*));</span><br><span class="line">                //为obj设置指定的类</span><br><span class="line">                object_setClass(obj, [MIZombieProxy class]);</span><br><span class="line">                //保留obj原本的类</span><br><span class="line">                ((MIZombieProxy*)obj).originClass = origClass;</span><br><span class="line">                //多线程下int的原子加操作，多线程对全局变量进行自加，不用理会线程锁了</span><br><span class="line">                __sync_fetch_and_add(&amp;unfreeSize, (int)memSize);</span><br><span class="line">                //入队</span><br><span class="line">                ds_queue_put(_unfreeQueue, p);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                orig_free(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            orig_free(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//加载野指针自定义类</span><br><span class="line">void loadZombieProxyClass()&#123;</span><br><span class="line">    registeredClasses = CFSetCreateMutable(NULL, 0, NULL);</span><br><span class="line">    </span><br><span class="line">    //用于保存已注册类的个数</span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    //获取所有已注册的类</span><br><span class="line">    Class *classes = objc_copyClassList(&amp;count);</span><br><span class="line">    //遍历，并保存到registeredClasses中</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        CFSetAddValue(registeredClasses, (__bridge const void *)(classes[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    //释放临时变量内存</span><br><span class="line">    free(classes);</span><br><span class="line">    classes = NULL;</span><br><span class="line">    </span><br><span class="line">    kMIZombieIsa = objc_getClass(&quot;MIZombieProxy&quot;);</span><br><span class="line">    kMIZombieSize = class_getInstanceSize(kMIZombieIsa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化以及free符号重绑定</span><br><span class="line">bool init_safe_free()&#123;</span><br><span class="line">    //初始化用于保存内存的队列</span><br><span class="line">    _unfreeQueue = ds_queue_create(MAX_STEAL_MEM_NUM);</span><br><span class="line">    //dlsym 在打开的库中查找符号的值，即动态调用free函数</span><br><span class="line">    orig_free = (void(*)(void*))dlsym(RTLD_DEFAULT, &quot;free&quot;);</span><br><span class="line">    /*</span><br><span class="line">     rebind_symbols:符号重绑定</span><br><span class="line">     - 参数1：rebindings 是一个rebinding数组，其定义如下</span><br><span class="line">         struct rebinding &#123;</span><br><span class="line">           const char *name;  // 目标符号名</span><br><span class="line">           void *replacement; // 要替换的符号值（地址值）</span><br><span class="line">           void **replaced;   // 用来存放原来的符号值（地址值）</span><br><span class="line">         &#125;;</span><br><span class="line">     - 参数2：rebindings_nel 描述数组的长度</span><br><span class="line">     */</span><br><span class="line">    //重绑定free符号，让它指向自定义的safe_free函数</span><br><span class="line">    rebind_symbols((struct rebinding[])&#123;&#123;&quot;free&quot;, (void*)safe_free&#125;&#125;, 1);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    id obj = [[NSObject alloc] init];</span><br><span class="line">    self.assignObj = obj;</span><br><span class="line">    </span><br><span class="line">//    [MIZombieSniffer installSniffer];</span><br><span class="line">&#125;</span><br><span class="line">- (IBAction)mallocScribbleAction:(id)sender &#123;</span><br><span class="line">    </span><br><span class="line">    UIView* testObj = [[UIView alloc] init];</span><br><span class="line">    [testObj release];</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        UIView* testView = [[UIView alloc] initWithFrame:CGRectMake(0,200,CGRectGetWidth(self.view.bounds), 60)];</span><br><span class="line">        [self.view addSubview:testView];</span><br><span class="line">    &#125;</span><br><span class="line">    [testObj setNeedsLayout];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下</p><p><img src="/BboyZJ.github.io/assets/16488771182594.jpg"></p><h1 id="Zombie-Objects"><a href="#Zombie-Objects" class="headerlink" title="Zombie Objects"></a>Zombie Objects</h1><p><strong>僵尸对象</strong></p><ul><li><p>可以用来检测内存错误（<code>EXC_BAD_ACCESS</code>）,它可以捕获任何阐释访问坏内存的调用</p></li><li><p>给僵尸对象发送消息的话，它仍然是可以响应的，然后会发生崩溃，并输出错误日志来显示野指针对象调用的类名和方法</p></li></ul><p><strong>苹果的僵尸对象检测原理</strong></p><p>首先我们来看下Xcode中僵尸对象是如何实现的，具体操作步骤可以参考这篇文章 <a href="https://www.jianshu.com/go-wild?ac=2&url=https%253A%252F%252Fzhiyongzou.github.io%252F2017%252F08%252F25%252FiOS-Zombie-Object-%2525E5%252583%2525B5%2525E5%2525B0%2525B8%2525E5%2525AF%2525B9%2525E8%2525B1%2525A1-%2525E5%25258E%25259F%2525E7%252590%252586%2525E6%25258E%2525A2%2525E7%2525B4%2525A2%252F">iOS Zombie Objects(僵尸对象)原理探索</a></p><ul><li>从 dealloc 的源码中，我们可以看到 Replaced by NSZombie，即 对象释放 时，NSZombie 将 dealloc 里做替换，如下所示</li></ul><p><img src="/BboyZJ.github.io/assets/16488773598076.jpg"></p><p>所以僵尸对象的生成过程伪代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//1、获取到即将deallocted对象所属类（Class）</span><br><span class="line">Class cls = object_getClass(self);</span><br><span class="line"></span><br><span class="line">//2、获取类名</span><br><span class="line">const char *clsName = class_getName(cls)</span><br><span class="line"></span><br><span class="line">//3、生成僵尸对象类名</span><br><span class="line">const char *zombieClsName = &quot;_NSZombie_&quot; + clsName;</span><br><span class="line"></span><br><span class="line">//4、查看是否存在相同的僵尸对象类名，不存在则创建</span><br><span class="line">Class zombieCls = objc_lookUpClass(zombieClsName);</span><br><span class="line">if (!zombieCls) &#123;</span><br><span class="line">     //5、获取僵尸对象类 _NSZombie_</span><br><span class="line"> Class baseZombieCls = objc_lookUpClass(“_NSZombie_&quot;);</span><br><span class="line"></span><br><span class="line">     //6、创建 zombieClsName 类</span><br><span class="line"> zombieCls = objc_duplicateClass(baseZombieCls, zombieClsName, 0);</span><br><span class="line">&#125;</span><br><span class="line">//7、在对象内存未被释放的情况下销毁对象的成员变量及关联引用。</span><br><span class="line">   objc_destructInstance(self);</span><br><span class="line"></span><br><span class="line">//8、修改对象的 isa 指针，令其指向特殊的僵尸类</span><br><span class="line">objc_setClass(self, zombieCls);</span><br></pre></td></tr></table></figure><ul><li>当僵尸对象再次被访问时，将进入消息转发流程，开始处理僵尸对象访问，输出日志并发生crash</li></ul><p><img src="/BboyZJ.github.io/assets/16488774216302.jpg"></p><p>所以僵尸对象触发流程伪代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//1、获取对象class</span><br><span class="line">Class cls = object_getClass(self);</span><br><span class="line"></span><br><span class="line">//2、获取对象类名</span><br><span class="line">const char *clsName = class_getName(cls);</span><br><span class="line"></span><br><span class="line">//3、检测是否带有前缀_NSZombie_</span><br><span class="line">if (string_has_prefix(clsName, &quot;_NSZombie_&quot;)) &#123;</span><br><span class="line">//4、获取被野指针对象类名</span><br><span class="line">  const char *originalClsName = substring_from(clsName, 10);</span><br><span class="line"></span><br><span class="line">　//5、获取当前调用方法名</span><br><span class="line">　const char *selectorName = sel_getName(_cmd);</span><br><span class="line">　　</span><br><span class="line">　//6、输出日志</span><br><span class="line">　Log(&#x27;&#x27;*** - [%s %s]: message sent to deallocated instance %p&quot;, originalClsName, selectorName, self);</span><br><span class="line"></span><br><span class="line">　//7、结束进程</span><br><span class="line">　abort();</span><br></pre></td></tr></table></figure><p>所以综上所述，这野指针探测方式的思路是：<code>dealloc</code> 方法的替换，其关键是调用 <code>objc_destructInstance</code> 来解除对象的关联引用</p><h1 id="野指针探测实现2"><a href="#野指针探测实现2" class="headerlink" title="野指针探测实现2"></a>野指针探测实现2</h1><p>这种思路主要来源 <a href="https://www.jianshu.com/go-wild?ac=2&url=http%253A%252F%252FLXDZombieSniffer">sindrilin</a> 的源码，其主要思路是：</p><p><strong>野指针检测流程</strong></p><ul><li><p>开启野指针检测</p></li><li><p>设值监控到野指针的回调block，在block中打印信息，或者存储堆栈</p></li><li><p>检测到野指针是否crash</p></li><li><p>最大内存占用空间</p></li><li><p>是否记录dealloc调用栈</p></li><li><p>监控策略</p><ul><li><p>只监控自定义对象</p></li><li><p>白名单策略</p></li><li><p>黑名单策略</p></li><li><p>监控所有对象</p></li></ul></li><li><p>交换NSObject的dealloc方法</p></li></ul><p><strong>触发野指针</strong></p><ul><li><p>开始处理对象</p></li><li><p>是否达到替换条件</p><ul><li>根据监控策略，是否属于要检测的类</li><li>空间是否足够</li></ul></li><li><p>如果符合条件，则获取对象，并解除引用，如果不符合则正常释放，即调用原来的dealloc方法</p></li><li><p>向对象内填充数据</p></li><li><p>赋值僵尸对象的类指针替换isa</p></li><li><p>对象+dealloc调用栈，保存在僵尸对象中</p></li><li><p>根据情况是否清理内存和对象</p></li></ul><p><strong>通过僵尸对象检测的实现思路</strong></p><ul><li><p>通过OC中 Method Swizzling，交换 根类NSObject和NSProxy 的 dealloc 方法为 自定义的dealloc 方法</p></li><li><p>为了 避免内存空间释放后被重写造成野指针 的问题，通过 字典存储被释放的对象，同时设置在 30s后调用dealloc方法将字典中存储的对象释放，避免内存增大</p></li><li><p>为了获取更多的崩溃信息，这里同样需要创建NSProxy的子类</p></li></ul><p><strong>具体实现</strong></p><ul><li><p>创建NSProxy的子类，其实现与上面的 MIZombieProxy 是一模一样的</p></li><li><p>hook dealloc 函数的具体实现</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--1、MIZombieSniffer.h--&gt;</span><br><span class="line">@interface MIZombieSniffer : NSObject</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line"> *  @method installSniffer</span><br><span class="line"> *  启动zombie检测</span><br><span class="line"> */</span><br><span class="line">+ (void)installSniffer;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line"> *  @method uninstallSnifier</span><br><span class="line"> *  停止zombie检测</span><br><span class="line"> */</span><br><span class="line">+ (void)uninstallSnifier;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line"> *  @method appendIgnoreClass</span><br><span class="line"> *  添加白名单类</span><br><span class="line"> */</span><br><span class="line">+ (void)appendIgnoreClass: (Class)cls;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&lt;!--2、MIZombieSniffer.m--&gt;</span><br><span class="line">#import &quot;MIZombieSniffer.h&quot;</span><br><span class="line">#import &quot;MIZombieProxy.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">typedef void (*MIDeallocPointer) (id objc);</span><br><span class="line">//野指针探测器是否开启</span><br><span class="line">static BOOL _enabled = NO;</span><br><span class="line">//根类</span><br><span class="line">static NSArray *_rootClasses = nil;</span><br><span class="line">//用于存储被释放的对象</span><br><span class="line">static NSDictionary&lt;id, NSValue*&gt; *_rootClassDeallocImps = nil;</span><br><span class="line"></span><br><span class="line">//白名单</span><br><span class="line">static inline NSMutableSet *__mi_sniffer_white_lists()&#123;</span><br><span class="line">    //创建白名单集合</span><br><span class="line">    static NSMutableSet *mi_sniffer_white_lists;</span><br><span class="line">    //单例初始化白名单集合</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        mi_sniffer_white_lists = [[NSMutableSet alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return mi_sniffer_white_lists;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static inline void __mi_dealloc(__unsafe_unretained id obj)&#123;</span><br><span class="line">    //获取对象的类</span><br><span class="line">    Class currentCls = [obj class];</span><br><span class="line">    Class rootCls = currentCls;</span><br><span class="line">    </span><br><span class="line">    //获取非NSObject和NSProxy的类</span><br><span class="line">    while (rootCls != [NSObject class] &amp;&amp; rootCls != [NSProxy class]) &#123;</span><br><span class="line">        //获取rootCls的父类，并赋值</span><br><span class="line">        rootCls = class_getSuperclass(rootCls);</span><br><span class="line">    &#125;</span><br><span class="line">    //获取类名</span><br><span class="line">    NSString *clsName = NSStringFromClass(rootCls);</span><br><span class="line">    //根据类名获取dealloc的imp指针</span><br><span class="line">    MIDeallocPointer deallocImp = NULL;</span><br><span class="line">    [[_rootClassDeallocImps objectForKey:clsName] getValue:&amp;deallocImp];</span><br><span class="line">    </span><br><span class="line">    if (deallocImp != NULL) &#123;</span><br><span class="line">        deallocImp(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//hook交换dealloc</span><br><span class="line">static inline IMP __mi_swizzleMethodWithBlock(Method method, void *block)&#123;</span><br><span class="line">    /*</span><br><span class="line">     imp_implementationWithBlock ：接收一个block参数，将其拷贝到堆中，返回一个trampoline</span><br><span class="line">     可以让block当做任何一个类的方法的实现，即当做类的方法的IMP来使用</span><br><span class="line">     */</span><br><span class="line">    IMP blockImp = imp_implementationWithBlock((__bridge id _Nonnull)(block));</span><br><span class="line">    //method_setImplementation 替换掉method的IMP</span><br><span class="line">    return method_setImplementation(method, blockImp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@implementation MIZombieSniffer</span><br><span class="line"></span><br><span class="line">//初始化根类</span><br><span class="line">+ (void)initialize</span><br><span class="line">&#123;</span><br><span class="line">    _rootClasses = [@[[NSObject class], [NSProxy class]] retain];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - public</span><br><span class="line">+ (void)installSniffer&#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        if (!_enabled) &#123;</span><br><span class="line">            //hook根类的dealloc方法</span><br><span class="line">            [self _swizzleDealloc];</span><br><span class="line">            _enabled = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)uninstallSnifier&#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        if (_enabled) &#123;</span><br><span class="line">            //还原dealloc方法</span><br><span class="line">            [self _unswizzleDealloc];</span><br><span class="line">            _enabled = NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//添加百名单</span><br><span class="line">+ (void)appendIgnoreClass:(Class)cls&#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        NSMutableSet *whiteList = __mi_sniffer_white_lists();</span><br><span class="line">        NSString *clsName = NSStringFromClass(cls);</span><br><span class="line">        [clsName retain];</span><br><span class="line">        [whiteList addObject:clsName];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - private</span><br><span class="line">+ (void)_swizzleDealloc&#123;</span><br><span class="line">    static void *swizzledDeallocBlock = NULL;</span><br><span class="line">    </span><br><span class="line">    //定义block，作为方法的IMP</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        swizzledDeallocBlock = (__bridge void *)[^void(id obj) &#123;</span><br><span class="line">            //获取对象的类</span><br><span class="line">            Class currentClass = [obj class];</span><br><span class="line">            //获取类名</span><br><span class="line">            NSString *clsName = NSStringFromClass(currentClass);</span><br><span class="line">            //判断该类是否在白名单类</span><br><span class="line">            if ([__mi_sniffer_white_lists() containsObject: clsName]) &#123;</span><br><span class="line">                //如果在白名单内，则直接释放对象</span><br><span class="line">                __mi_dealloc(obj);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //修改对象的isa指针，指向MIZombieProxy</span><br><span class="line">                /*</span><br><span class="line">                 valueWithBytes:objCType  创建并返回一个包含给定值的NSValue对象，该值会被解释为一个给定的NSObject类型</span><br><span class="line">                 - 参数1：NSValue对象的值</span><br><span class="line">                 - 参数2：给定值的对应的OC类型，需要使用编译器指令@encode来创建</span><br><span class="line">                 */</span><br><span class="line">                NSValue *objVal = [NSValue valueWithBytes: &amp;obj objCType: @encode(typeof(obj))];</span><br><span class="line">                //为obj设置指定的类</span><br><span class="line">                object_setClass(obj, [MIZombieProxy class]);</span><br><span class="line">                //保留对象原本的类</span><br><span class="line">                ((MIZombieProxy *)obj).originClass = currentClass;</span><br><span class="line">                </span><br><span class="line">                //设置在30s后调用dealloc将存储的对象释放，避免内存空间的增大</span><br><span class="line">                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(30 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    __unsafe_unretained id deallocObj = nil;</span><br><span class="line">                    //获取需要dealloc的对象</span><br><span class="line">                    [objVal getValue: &amp;deallocObj];</span><br><span class="line">                    //设置对象的类为原本的类</span><br><span class="line">                    object_setClass(deallocObj, currentClass);</span><br><span class="line">                    //释放</span><br><span class="line">                    __mi_dealloc(deallocObj);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; copy];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    //交换了根类NSObject和NSProxy的dealloc方法为originalDeallocImp</span><br><span class="line">    NSMutableDictionary *deallocImps = [NSMutableDictionary dictionary];</span><br><span class="line">    //遍历根类</span><br><span class="line">    for (Class rootClass in _rootClasses) &#123;</span><br><span class="line">        //获取指定类中dealloc方法</span><br><span class="line">        Method oriMethod = class_getInstanceMethod([rootClass class], NSSelectorFromString(@&quot;dealloc&quot;));</span><br><span class="line">        //hook - 交换dealloc方法的IMP实现</span><br><span class="line">        IMP originalDeallocImp = __mi_swizzleMethodWithBlock(oriMethod, swizzledDeallocBlock);</span><br><span class="line">        //设置IMP的具体实现</span><br><span class="line">        [deallocImps setObject: [NSValue valueWithBytes: &amp;originalDeallocImp objCType: @encode(typeof(IMP))] forKey: NSStringFromClass(rootClass)];</span><br><span class="line">    &#125;</span><br><span class="line">    //_rootClassDeallocImps字典存储交换后的IMP实现</span><br><span class="line">    _rootClassDeallocImps = [deallocImps copy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)_unswizzleDealloc&#123;</span><br><span class="line">    //还原dealloc交换的IMP</span><br><span class="line">    [_rootClasses enumerateObjectsUsingBlock:^(Class rootClass, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        IMP originDeallocImp = NULL;</span><br><span class="line">        //获取根类类名</span><br><span class="line">        NSString *clsName = NSStringFromClass(rootClass);</span><br><span class="line">        //获取hook后的dealloc实现</span><br><span class="line">        [[_rootClassDeallocImps objectForKey:clsName] getValue:&amp;originDeallocImp];</span><br><span class="line">        </span><br><span class="line">        NSParameterAssert(originDeallocImp);</span><br><span class="line">        //获取原本的dealloc实现</span><br><span class="line">        Method oriMethod = class_getInstanceMethod([rootClass class], NSSelectorFromString(@&quot;dealloc&quot;));</span><br><span class="line">        //还原dealloc的实现</span><br><span class="line">        method_setImplementation(oriMethod, originDeallocImp);</span><br><span class="line">    &#125;];</span><br><span class="line">    //释放</span><br><span class="line">    [_rootClassDeallocImps release];</span><br><span class="line">    _rootClassDeallocImps = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) id assignObj;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    id obj = [[NSObject alloc] init];</span><br><span class="line">    self.assignObj = obj;</span><br><span class="line">    </span><br><span class="line">    [MIZombieSniffer installSniffer];</span><br><span class="line">&#125;</span><br><span class="line">- (IBAction)zombieObjectAction:(id)sender &#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%@&quot;, self.assignObj);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印崩溃信息如下</p><p><img src="/BboyZJ.github.io/assets/16488787909724.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习15：SDWebImage探索</title>
      <link href="/BboyZJ.github.io/2021/07/13/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A015%EF%BC%9ASDWebImage%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2021/07/13/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A015%EF%BC%9ASDWebImage%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>SDWebImage</code> 是一个 <code>异步加载图片的库</code>，提供了一个<code>UIImageView+WebCache</code>类支持来自互联网的远程图片，具有<code>缓存管理、异步下载、同一个URL次数控制和优化等</code>特征。</p><h1 id="SDWebImage-加载图片的流程"><a href="#SDWebImage-加载图片的流程" class="headerlink" title="SDWebImage 加载图片的流程"></a>SDWebImage 加载图片的流程</h1><ol><li><p>通过 <code>UIImageView+WebCache</code> 类调用 <code>sd_setImageWithURL:placeholderImage</code>调用 <code>UIView+WebCache</code>类中的方法<code>sd_internalSetImageWithURL:placeholderImage:options:context:setImageBlock:progress:completed:</code>，如果有占位图片，先显示占位图片，然后根据 <code>url</code> 处理图片。</p></li><li><p>如果内存缓存中没有图片，则从磁盘中查找，根据对<code>URL</code>的<code>MD5</code>处理查找图片，如果找到图片，将图片添加到内存缓存，同时将找到的图片返回并显示。</p></li><li><p>如果磁盘和内存都找不到图片，则需要下载图片，通过共享或重新生成一个下载器<code>SDWebImageDownloader</code>下载图片。</p></li><li><p>图片下载由NSURLSession来完成，下载完成后对图片进行内存和磁盘缓存，并返回显示。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 下载图片</span><br><span class="line">        operation.loaderOperation = [imageLoader requestImageWithURL:url options:options context:context progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123;</span><br></pre></td></tr></table></figure><h1 id="SDWebImageView-缓存机制"><a href="#SDWebImageView-缓存机制" class="headerlink" title="SDWebImageView 缓存机制"></a>SDWebImageView 缓存机制</h1><ol><li>首先，<code>SDWebImage</code>的图片缓存采用的是 <code>memory</code>（内存） 和 <code>disk</code>（磁盘） 双重机制，<code>SDImageCache</code> 中有 <code>memoryCache</code> 和 <code>diskCache</code> 两个属性；<code>memoryCache</code> 是将图片存储在内存中 ； <code>diskCache</code> 是将图片放到 <code>NSCacheDiretory</code> 目录中，具体如下：</li></ol><ul><li><p><code>Memory</code>内存中查找：<code>SDImageCache</code>中查找图片缓存，如果找到直接返回，反之进入硬盘查找</p></li><li><p><code>Disk</code>硬盘中查找：如果硬盘中找到，还需要将图片存储到 <code>memory</code> 中 ，如果找不到，则下载</p></li><li><p>下载：使用 <code>downloader</code>下载，失败加入<code>failedURLS</code>集合，下载拒绝再次加载，下载成功则写入 <code>memory</code> 和 <code>disk</code>，并返回显示</p></li><li><p>Disk缓存策略-APP在结束时执行清理任务：<br>  1）清除过期的缓存文件<br>  2）如果清除过期的缓存文件未满足条件，则先清除最早的文件，并且是折半清除。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理40：组件化（二）组件间通讯方式</title>
      <link href="/BboyZJ.github.io/2021/07/05/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8640%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/"/>
      <url>/BboyZJ.github.io/2021/07/05/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8640%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要讲组件化之间是如何 <code>通讯</code> 的</p><h1 id="组件化通讯方案"><a href="#组件化通讯方案" class="headerlink" title="组件化通讯方案"></a>组件化通讯方案</h1><p>目前的主流方式有三种：</p><ul><li><p><code>URL</code> 路由</p></li><li><p><code>target-action</code></p></li><li><p><code>protocol</code> 匹配</p></li></ul><h1 id="URL路由"><a href="#URL路由" class="headerlink" title="URL路由"></a>URL路由</h1><p>目前iOS上大部分路由工具都是基于URL匹配的，或者根据命名约定，用runtime方法进行动态调用</p><p>这些动态化的方案的有点是实现简单，缺点是需要维护 <code>字符串表</code>，或者依赖于命名约定，无法在编译时暴露出所有问题，需要在运行时才能发现错误</p><p>URL路由方式主要是以蘑菇街为代表的 <a href="https://www.jianshu.com/p/412b20d9a0f6">MGJRouter</a></p><p>其实现思路是：</p><ul><li><p>App启动时实例化各组件模块，然后这些组件向 <code>ModuleManager</code> 注册 <code>Url</code>，有些时候不需要实例化，使用class注册</p></li><li><p>当组件A需要调用组件B时，向 <code>ModuleManager</code> 传递URL，参数跟随URL以GET方式传递，类似openURL。然后由 <code>ModuleManager</code> 负责调度组件B，最后完成任务</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1.注册某个URL</span><br><span class="line">MGJRouter.registerURLPattern(&quot;app://home&quot;) &#123; (info) in</span><br><span class="line">    print(&quot;info:\(info)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.调用路由</span><br><span class="line">MGJRouter.openURL(&quot;app://home&quot;)</span><br></pre></td></tr></table></figure><p><strong>URL路由的优点</strong></p><ul><li>极高的动态性，适合经常开展运营活动的App，例如电商</li><li>方便地统一管理多平台的路由规则</li><li>易于适配URL Scheme</li></ul><p><strong>URL路由的缺点</strong></p><ul><li><p>传参方式有限，并且无法利用编译器进行参数类型检查，因此所有的参数都是通过字符串转换而来</p></li><li><p>只适用于界面模块，不适用于通用模块</p></li><li><p>参数的格式不明确，是个灵活的 dictionary，也需要有个地方可以查参数格式</p></li><li><p>不支持storyboard</p></li><li><p>依赖于字符串硬编码，难以管理，蘑菇街做了个后台专门管理</p></li><li><p>无法保证所使用的模块一定存在</p></li><li><p>解耦能力有限，url的注册、实现、使用必须用相同的字符规则，一旦任何一方作出修改都会导致其他方的代码失效，并且重构难度大</p></li></ul><p>除了 <code>MGJRouter</code>，还有以下这些三方框架</p><ul><li><a href="https://github.com/clayallsopp/routable-ios">routable-ios</a></li><li><a href="https://www.jianshu.com/p/412b20d9a0f6">JLRoutes</a></li><li><a href="https://www.jianshu.com/p/412b20d9a0f6">HHRouter</a></li></ul><h1 id="target-action"><a href="#target-action" class="headerlink" title="target-action"></a>target-action</h1><p>这个方案是基于OC的 <code>runtime、category</code> 特性动态获取模块，例如通过 <code>NSClassFromString</code> 获取类并创建实例，通过 <code>performSelector + NSInvocation</code> 动态调用方法</p><p>其主要的代表框架是 <a href="https://www.jianshu.com/p/412b20d9a0f6">casatwy的CTMediator</a></p><p>其实现思路是：</p><ul><li><p>利用 <code>分类</code> 为路由添加新接口，在接口中 <code>通过字符串获取对应的类</code></p></li><li><p>通过 <code>runtime</code> 创建实例，动态调用实例的方法</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//******* 1、分类定义新接口</span><br><span class="line">extension CTMediator&#123;</span><br><span class="line">    @objc func A_showHome()-&gt;UIViewController?&#123;</span><br><span class="line">        let params = [</span><br><span class="line">            kCTMediatorParamsKeySwiftTargetModuleName: &quot;ZJBase_Example&quot;</span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line">        if let vc = self.performTarget(&quot;A&quot;, action: &quot;Extension_HomeViewController&quot;, params: params, shouldCacheTarget: false) as? UIViewController&#123;</span><br><span class="line">            return vc</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//******* 2、模块提供者提供target-action的调用方式（对外需要加上public关键字）</span><br><span class="line">class Target_A: NSObject &#123;</span><br><span class="line">    </span><br><span class="line">    @objc func Action_Extension_HomeViewController(_ params: [String: Any])-&gt;UIViewController&#123;</span><br><span class="line">         </span><br><span class="line">        let home = HomeViewController()</span><br><span class="line">        return home</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//******* 3、使用</span><br><span class="line">if let vc = CTMediator.sharedInstance().A_showHome() &#123;</span><br><span class="line">            self.navigationController?.pushViewController(vc, animated: true)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>其模块间的引用关系如下图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/162383654-d820d060-c93d-4162-bed3-2b8473670650.png"></p><p><strong>缺点</strong></p><ul><li><p>需要在 <code>mediator</code> 和 <code>target</code> 中重新添加每一个接口，模块化时代码较为繁琐</p></li><li><p>在 <code>category</code> 中仍然引入了 <code>字符串编码</code>，内部使用字典传参，一定程度上也存在和URL路由相同的问题</p></li><li><p>无法保证使用的模块一定存在，target在修改后，使用者只能在运行时才能发现错误</p></li><li><p>可能会创建过多的 <code>target</code> 类</p></li></ul><p><strong>CTMediator源码分析</strong></p><ul><li>通过分类中调用的 <code>performTarget</code> 来到 <code>CTMediator</code> 中的具体实现，即 <code>performTarget:action:params:shouldCacheTarget:</code>，主要是通过传入的name，找到对应的 <code>target和action</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget</span><br><span class="line">&#123;</span><br><span class="line">    if (targetName == nil || actionName == nil) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //在swift中使用时，需要传入对应项目的target名称，否则会找不到视图控制器</span><br><span class="line">    NSString *swiftModuleName = params[kCTMediatorParamsKeySwiftTargetModuleName];</span><br><span class="line">    </span><br><span class="line">    // generate target 生成target</span><br><span class="line">    NSString *targetClassString = nil;</span><br><span class="line">    if (swiftModuleName.length &gt; 0) &#123;</span><br><span class="line">        //swift中target文件名拼接</span><br><span class="line">        targetClassString = [NSString stringWithFormat:@&quot;%@.Target_%@&quot;, swiftModuleName, targetName];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //OC中target文件名拼接</span><br><span class="line">        targetClassString = [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName];</span><br><span class="line">    &#125;</span><br><span class="line">    //缓存中查找target</span><br><span class="line">    NSObject *target = [self safeFetchCachedTarget:targetClassString];</span><br><span class="line">    //缓存中没有target</span><br><span class="line">    if (target == nil) &#123;</span><br><span class="line">        //通过字符串获取对应的类</span><br><span class="line">        Class targetClass = NSClassFromString(targetClassString);</span><br><span class="line">        //创建实例</span><br><span class="line">        target = [[targetClass alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // generate action 生成action方法名称</span><br><span class="line">    NSString *actionString = [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName];</span><br><span class="line">    //通过方法名字符串获取对应的sel</span><br><span class="line">    SEL action = NSSelectorFromString(actionString);</span><br><span class="line">    </span><br><span class="line">    if (target == nil) &#123;</span><br><span class="line">        // 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的</span><br><span class="line">        [self NoTargetActionResponseWithTargetString:targetClassString selectorString:actionString originParams:params];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //是否需要缓存</span><br><span class="line">    if (shouldCacheTarget) &#123;</span><br><span class="line">        [self safeSetCachedTarget:target key:targetClassString];</span><br><span class="line">    &#125;</span><br><span class="line">    //是否响应sel</span><br><span class="line">    if ([target respondsToSelector:action]) &#123;</span><br><span class="line">        //动态调用方法</span><br><span class="line">        return [self safePerformAction:action target:target params:params];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理</span><br><span class="line">        SEL action = NSSelectorFromString(@&quot;notFound:&quot;);</span><br><span class="line">        if ([target respondsToSelector:action]) &#123;</span><br><span class="line">            return [self safePerformAction:action target:target params:params];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。</span><br><span class="line">            [self NoTargetActionResponseWithTargetString:targetClassString selectorString:actionString originParams:params];</span><br><span class="line">            @synchronized (self) &#123;</span><br><span class="line">                [self.cachedTarget removeObjectForKey:targetClassString];</span><br><span class="line">            &#125;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入 <code>safePerformAction: target: params:</code> 实现，主要是通过 <code>invocation</code> 进行 <code>参数传递+消息转发</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (id)safePerformAction:(SEL)action target:(NSObject *)target params:(NSDictionary *)params</span><br><span class="line">&#123;</span><br><span class="line">    //获取方法签名</span><br><span class="line">    NSMethodSignature* methodSig = [target methodSignatureForSelector:action];</span><br><span class="line">    if(methodSig == nil) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取方法签名中的返回类型，然后根据返回值完成参数传递</span><br><span class="line">    const char* retType = [methodSig methodReturnType];</span><br><span class="line">    //void类型</span><br><span class="line">    if (strcmp(retType, @encode(void)) == 0) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    //...省略其他类型的判断</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="protocol-class"><a href="#protocol-class" class="headerlink" title="protocol class"></a>protocol class</h1><p>protocol匹配的 <code>实现思路</code> 是：</p><ul><li>将 <code>protocol</code> 和对应的 <code>类</code> 进行 <code>字典匹配</code></li><li>通过用 <code>protocol</code> 获取 <code>class</code>，在 <code>动态创建实例</code></li></ul><p>protocol比较典型的三方矿建就是 <a href="https://github.com/alibaba/BeeHive">阿里的BeeHive</a>，<code>BeeHive</code> 借鉴了Spring Service、Apache DSO的架构理念，<code>采用AOP+扩展App声明周期API</code> 形式，将 <code>业务功能、基础功能</code> 模块以模块方式以解决大型应用中的复杂问题，并让 <code>模块之间以Service形式调用</code>，将复杂问题切分，以AOP方式模块化服务</p><p><strong>BeeHive核心思想</strong></p><ul><li>各个模块间调用从直接调用对应模块，变成调用 <code>Service</code> 的形式，避免了直接依赖</li><li>App声明周期的分发，将耦合在AppDelegate中逻辑拆分，买个模块以微应用的形式独立存在</li></ul><p>示例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1、注册</span><br><span class="line">[[BeeHive shareInstance] registerService:@protocol(HomeServiceProtocol) service:[BHViewController class]];</span><br><span class="line"></span><br><span class="line">// 2、使用</span><br><span class="line">#import &quot;BHService.h&quot;</span><br><span class="line"></span><br><span class="line">id&lt; HomeServiceProtocol &gt; homeVc = [[BeeHive shareInstance] createService:@protocol(HomeServiceProtocol)];</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>利用接口调用，实现了参数传递时的类型安全</li><li>直接使用模块的protocol接口，无序再重复封装</li></ul><p><strong>缺点</strong></p><ul><li>用框架来创建所有对象，创建方式不同，即不支持外部传入参数</li><li>用 OC runtime 创建对象，不支持swift</li><li>只做了 protocol 和 class 的匹配，不支持更复杂的创建方式和依赖注入</li><li>无法保证所使用的protocol一定存在对应的模块，也无法直接判断某个protocol是否能用于获取模块</li></ul><p>除了 <code>BeeHive</code>，还有 <a href="https://www.jianshu.com/p/412b20d9a0f6">Swinject</a></p><h1 id="BeeHive模块注册"><a href="#BeeHive模块注册" class="headerlink" title="BeeHive模块注册"></a>BeeHive模块注册</h1><p>在 <code>BeeHive</code> 主要是通过 <code>BHModuleManager</code> 来管理各个模块的。<code>BHModuleManager</code> 中只会管理已经被注册过的模块。</p><p>BeeHive提供了三种不同的调用形式，<code>静态plist，动态注册，annotation</code>。Module、Service之间没有关联，每个业务模块可以单独实现Module或者Service的功能。</p><ol><li>Annotation方式注册<br>这种方式主要是通过 <code>BeeHiveMod</code> 宏进行 <code>Annotation</code> 标记</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//***** 使用</span><br><span class="line">BeeHiveMod(ShopModule)</span><br><span class="line"></span><br><span class="line">//***** BeeHiveMod的宏定义</span><br><span class="line">#define BeeHiveMod(name) \</span><br><span class="line">class BeeHive; char * k##name##_mod BeeHiveDATA(BeehiveMods) = &quot;&quot;#name&quot;&quot;;</span><br><span class="line"></span><br><span class="line">//***** BeeHiveDATA的宏定义 </span><br><span class="line">#define BeeHiveDATA(sectname) __attribute((used, section(&quot;__DATA,&quot;#sectname&quot; &quot;)))</span><br><span class="line"></span><br><span class="line">//*****  全部转换出来后为下面的格式</span><br><span class="line">char * kShopModule_mod __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveMods&quot;&quot; &quot;))) = &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure><p>这里针对 <code>__attribute</code> 需要说明以下几点</p><ul><li><p>第一个参数 <code>used</code>：用来修饰函数，被used修饰以后，意味着即使函数没有被引用，在Release下也不会被优化。如果不加这个修饰，那么Release环境链接器下会去掉没有被引用的段。</p></li><li><p>通过使用 <code>__attribute__((section(&quot;name&quot;)))</code> 来指明哪个段。数据则用<code>__attribute__((used))</code> 来标记，防止链接器会优化删除未被使用的段，然后将模块注入到 <code>__DATA</code> 中</p></li><li><p>进入 <code>BHReadConfiguration</code> 方法，主要是通过 <code>Mach-O</code> 找到存储的数据段，取出放入数组中</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">NSArray&lt;NSString *&gt;* BHReadConfiguration(char *sectionName,const struct mach_header *mhp)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *configs = [NSMutableArray array];</span><br><span class="line">    unsigned long size = 0;</span><br><span class="line">#ifndef __LP64__</span><br><span class="line">    // 找到之前存储的数据段(Module找BeehiveMods段 和 Service找BeehiveServices段)的一片内存</span><br><span class="line">    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#else</span><br><span class="line">    const struct mach_header_64 *mhp64 = (const struct mach_header_64 *)mhp;</span><br><span class="line">    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    unsigned long counter = size/sizeof(void*);</span><br><span class="line">    // 把特殊段里面的数据都转换成字符串存入数组中</span><br><span class="line">    for(int idx = 0; idx &lt; counter; ++idx)&#123;</span><br><span class="line">        char *string = (char*)memory[idx];</span><br><span class="line">        NSString *str = [NSString stringWithUTF8String:string];</span><br><span class="line">        if(!str)continue;</span><br><span class="line">        </span><br><span class="line">        BHLog(@&quot;config = %@&quot;, str);</span><br><span class="line">        if(str) [configs addObject:str];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return configs; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>读取本地Plist文件</li></ol><ul><li>首先，需要设置好路径</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/BeeHive&quot;; // 可选，默认为BeeHive.bundle/BeeHive.plist</span><br></pre></td></tr></table></figure><ul><li>创建plist文件，Plist文件的格式也是数组中包含多个字典。字典里面有两个Key，一个是<code>@&quot;moduleLevel&quot;</code>，另一个是 <code>@&quot;moduleClass&quot;</code> 。注意根的数组的名字叫<code>@“moduleClasses”</code>。</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162383772-d61d99f3-78b3-4e26-b139-1474e1c6ff60.png"></p><ul><li>进入 <code>loadLocalModules</code> 方法，主要是从 <code>Plist</code> 里面取出数组，然后把数组加入到<code>BHModuleInfos</code> 数组里面</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//初始化context时，加载Modules和Services</span><br><span class="line">-(void)setContext:(BHContext *)context</span><br><span class="line">&#123;</span><br><span class="line">    _context = context;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        [self loadStaticServices];</span><br><span class="line">        [self loadStaticModules];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">//加载modules</span><br><span class="line">- (void)loadStaticModules</span><br><span class="line">&#123;</span><br><span class="line">    // 读取本地plist文件里面的Module，并注册到BHModuleManager的BHModuleInfos数组中</span><br><span class="line">    [[BHModuleManager sharedManager] loadLocalModules];</span><br><span class="line">    //注册所有modules，在内部根据优先级进行排序</span><br><span class="line">    [[BHModuleManager sharedManager] registedAllModules];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)loadLocalModules</span><br><span class="line">&#123;</span><br><span class="line">    //plist文件路径</span><br><span class="line">    NSString *plistPath = [[NSBundle mainBundle] pathForResource:[BHContext shareInstance].moduleConfigName ofType:@&quot;plist&quot;];</span><br><span class="line">    //判断文件是否存在</span><br><span class="line">    if (![[NSFileManager defaultManager] fileExistsAtPath:plistPath]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //读取整个文件[@&quot;moduleClasses&quot; : 数组]</span><br><span class="line">    NSDictionary *moduleList = [[NSDictionary alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">    //通过moduleClasses key读取 数组 [[@&quot;moduleClass&quot;:&quot;aaa&quot;, @&quot;moduleLevel&quot;: @&quot;bbb&quot;], [...]]</span><br><span class="line">    NSArray&lt;NSDictionary *&gt; *modulesArray = [moduleList objectForKey:kModuleArrayKey];</span><br><span class="line">    NSMutableDictionary&lt;NSString *, NSNumber *&gt; *moduleInfoByClass = @&#123;&#125;.mutableCopy;</span><br><span class="line">    //遍历数组</span><br><span class="line">    [self.BHModuleInfos enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        [moduleInfoByClass setObject:@1 forKey:[obj objectForKey:kModuleInfoNameKey]];</span><br><span class="line">    &#125;];</span><br><span class="line">    [modulesArray enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if (!moduleInfoByClass[[obj objectForKey:kModuleInfoNameKey]]) &#123;</span><br><span class="line">            //存储到 BHModuleInfos 中</span><br><span class="line">            [self.BHModuleInfos addObject:obj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>load方法注册</li></ol><p>该方法 <code>注册Module</code> 就是在 <code>Load</code> 方法里面注册Module的类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    [BeeHive registerDynamicModule:[self class]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入 <code>registerDynamicModule</code> 实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">&#123;</span><br><span class="line">    [[BHModuleManager sharedManager] registerDynamicModule:moduleClass];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">&#123;</span><br><span class="line">    [self registerDynamicModule:moduleClass shouldTriggerInitEvent:NO];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)registerDynamicModule:(Class)moduleClass</span><br><span class="line">       shouldTriggerInitEvent:(BOOL)shouldTriggerInitEvent</span><br><span class="line">&#123;</span><br><span class="line">    [self addModuleFromObject:moduleClass shouldTriggerInitEvent:shouldTriggerInitEvent];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其底层还是同第一种方式一样，最终会走到<code>addModuleFromObject:shouldTriggerInitEvent:</code>方法中</p><ul><li>load方法，还可以使用 <code>BH_EXPORT_MODULE</code> 宏代替</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define BH_EXPORT_MODULE(isAsync) \</span><br><span class="line">+ (void)load &#123; [BeeHive registerDynamicModule:[self class]]; &#125; \</span><br><span class="line">-(BOOL)async &#123; return [[NSString stringWithUTF8String:#isAsync] boolValue];&#125;</span><br></pre></td></tr></table></figure><p><code>BH_EXPORT_MODULE</code> 宏里面可以传入一个参数，代表 <code>是否异步加载Module模块</code>，如果是<code>YES</code>就是 <code>异步加载</code>，如果是 <code>NO</code> 就是 <code>同步加载</code>。</p><ol start="2"><li>BeeHive 模块事件</li></ol><p>BeeHive会给每个模块提供生命周期事件，用于与BeeHive宿主环境进行必要信息交互，感知模块生命周期的变化。</p><p>BeeHive各个模块会收到一些事件。在 <code>BHModuleManager</code> 中，所有的事件被定义成了<code>BHModuleEventType</code> 枚举。如下所示，其中有2个事件很特殊，一个是 <code>BHMInitEvent</code>，一个是 <code>BHMTearDownEvent</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, BHModuleEventType)</span><br><span class="line">&#123;</span><br><span class="line">    //设置Module模块</span><br><span class="line">    BHMSetupEvent = 0,</span><br><span class="line">    //用于初始化Module模块，例如环境判断，根据不同环境进行不同初始化</span><br><span class="line">    BHMInitEvent,</span><br><span class="line">    //用于拆除Module模块</span><br><span class="line">    BHMTearDownEvent,</span><br><span class="line">    BHMSplashEvent,</span><br><span class="line">    BHMQuickActionEvent,</span><br><span class="line">    BHMWillResignActiveEvent,</span><br><span class="line">    BHMDidEnterBackgroundEvent,</span><br><span class="line">    BHMWillEnterForegroundEvent,</span><br><span class="line">    BHMDidBecomeActiveEvent,</span><br><span class="line">    BHMWillTerminateEvent,</span><br><span class="line">    BHMUnmountEvent,</span><br><span class="line">    BHMOpenURLEvent,</span><br><span class="line">    BHMDidReceiveMemoryWarningEvent,</span><br><span class="line">    BHMDidFailToRegisterForRemoteNotificationsEvent,</span><br><span class="line">    BHMDidRegisterForRemoteNotificationsEvent,</span><br><span class="line">    BHMDidReceiveRemoteNotificationEvent,</span><br><span class="line">    BHMDidReceiveLocalNotificationEvent,</span><br><span class="line">    BHMWillPresentNotificationEvent,</span><br><span class="line">    BHMDidReceiveNotificationResponseEvent,</span><br><span class="line">    BHMWillContinueUserActivityEvent,</span><br><span class="line">    BHMContinueUserActivityEvent,</span><br><span class="line">    BHMDidFailToContinueUserActivityEvent,</span><br><span class="line">    BHMDidUpdateUserActivityEvent,</span><br><span class="line">    BHMHandleWatchKitExtensionRequestEvent,</span><br><span class="line">    BHMDidCustomEvent = 1000</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要分为三种</p><ul><li><code>系统事件</code>：主要是指 <code>Application生命周期事件!</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162383825-1e06fb75-8aa2-4044-8176-6d249e3064a4.png"></p><p>一般的做法是<code>AppDelegate</code>改为 <code>继承自BHAppDelegate</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface TestAppDelegate : BHAppDelegate &lt;UIApplicationDelegate&gt;</span><br></pre></td></tr></table></figure><ul><li><code>应用事件</code>：官方给出的流程图，其中 <code>modSetup、modInit</code> 等，可以用于编码实现各插件模块的设置与初始化。</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162383863-7f1e8d00-a2b1-48b2-a262-0e0840fda1dd.png"></p><ul><li>自定义事件</li></ul><p>以上所有的事件都可以通过调用 <code>BHModuleManager</code> 的 <code>triggerEvent:</code> 来处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)triggerEvent:(NSInteger)eventType</span><br><span class="line">&#123;</span><br><span class="line">    [self triggerEvent:eventType withCustomParam:nil];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)triggerEvent:(NSInteger)eventType</span><br><span class="line">     withCustomParam:(NSDictionary *)customParam &#123;</span><br><span class="line">    [self handleModuleEvent:eventType forTarget:nil withCustomParam:customParam];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">#pragma mark - module protocol</span><br><span class="line">- (void)handleModuleEvent:(NSInteger)eventType</span><br><span class="line">                forTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">          withCustomParam:(NSDictionary *)customParam</span><br><span class="line">&#123;</span><br><span class="line">    switch (eventType) &#123;</span><br><span class="line">            //初始化事件</span><br><span class="line">        case BHMInitEvent:</span><br><span class="line">            //special</span><br><span class="line">            [self handleModulesInitEventForTarget:nil withCustomParam :customParam];</span><br><span class="line">            break;</span><br><span class="line">            //析构事件</span><br><span class="line">        case BHMTearDownEvent:</span><br><span class="line">            //special</span><br><span class="line">            [self handleModulesTearDownEventForTarget:nil withCustomParam:customParam];</span><br><span class="line">            break;</span><br><span class="line">            //其他3类事件</span><br><span class="line">        default: &#123;</span><br><span class="line">            NSString *selectorStr = [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">            [self handleModuleEvent:eventType forTarget:nil withSeletorStr:selectorStr andCustomParam:customParam];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中可以发现，除去 <code>BHMInitEvent</code> 初始化事件和 <code>BHMTearDownEvent</code> 拆除Module事件这两个特殊事件以外，所有的事件都是调用的<code>handleModuleEvent:forTarget:withSeletorStr:andCustomParam:</code>方法，其内部实现主要是遍历 <code>moduleInstances</code> 实例数组，调用 <code>performSelector:withObject:</code> 方法实现对应方法调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleModuleEvent:(NSInteger)eventType</span><br><span class="line">                forTarget:(id&lt;BHModuleProtocol&gt;)target</span><br><span class="line">           withSeletorStr:(NSString *)selectorStr</span><br><span class="line">           andCustomParam:(NSDictionary *)customParam</span><br><span class="line">&#123;</span><br><span class="line">    BHContext *context = [BHContext shareInstance].copy;</span><br><span class="line">    context.customParam = customParam;</span><br><span class="line">    context.customEvent = eventType;</span><br><span class="line">    if (!selectorStr.length) &#123;</span><br><span class="line">        selectorStr = [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">    &#125;</span><br><span class="line">    SEL seletor = NSSelectorFromString(selectorStr);</span><br><span class="line">    if (!seletor) &#123;</span><br><span class="line">        selectorStr = [self.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">        seletor = NSSelectorFromString(selectorStr);</span><br><span class="line">    &#125;</span><br><span class="line">    NSArray&lt;id&lt;BHModuleProtocol&gt;&gt; *moduleInstances;</span><br><span class="line">    if (target) &#123;</span><br><span class="line">        moduleInstances = @[target];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        moduleInstances = [self.BHModulesByEvent objectForKey:@(eventType)];</span><br><span class="line">    &#125;</span><br><span class="line">    //遍历 moduleInstances 实例数组，调用performSelector:withObject:方法实现对应方法调用</span><br><span class="line">    [moduleInstances enumerateObjectsUsingBlock:^(id&lt;BHModuleProtocol&gt; moduleInstance, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if ([moduleInstance respondsToSelector:seletor]) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">            //进行方法调用</span><br><span class="line">            [moduleInstance performSelector:seletor withObject:context];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">            </span><br><span class="line">            [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[NSString stringWithFormat:@&quot;%@ --- %@&quot;, [moduleInstance class], NSStringFromSelector(seletor)]];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:这里所有的 <code>Module</code> 必须是遵循 <code>BHModuleProtocol</code> 的，否则无法接收到这些事件的消息。</p><ol start="3"><li>BeeHive模块调用</li></ol><p>在BeeHive中是通过 <code>BHServiceManager</code> 来管理各个 <code>Protocol</code> 的。<code>BHServiceManager</code> 中只会管理已经被注册过的 <code>Protocol</code>。</p><p>注册 <code>Protocol</code> 的方式总共有三种，和注册 <code>Module</code> 是一样一一对应的</p><ul><li>Annotation方式注册</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//****** 1、通过BeeHiveService宏进行Annotation标记</span><br><span class="line">BeeHiveService(HomeServiceProtocol,BHViewController)</span><br><span class="line"></span><br><span class="line">//****** 2、宏定义</span><br><span class="line">#define BeeHiveService(servicename,impl) \</span><br><span class="line">class BeeHive; char * k##servicename##_service BeeHiveDATA(BeehiveServices) = &quot;&#123; \&quot;&quot;#servicename&quot;\&quot; : \&quot;&quot;#impl&quot;\&quot;&#125;&quot;;</span><br><span class="line"></span><br><span class="line">//****** 3、转换后的格式，也是将其存储到特殊的段</span><br><span class="line">char * kHomeServiceProtocol_service __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveServices&quot;&quot; &quot;))) = &quot;&#123; \&quot;&quot;&quot;HomeServiceProtocol&quot;&quot;\&quot; : \&quot;&quot;&quot;BHViewController&quot;&quot;\&quot;&#125;&quot;;</span><br></pre></td></tr></table></figure><ul><li><p>读取本地plist文件</p></li><li><p>首先同Module一样，需要先设置好路径</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[BHContext shareInstance].serviceConfigName = @&quot;BeeHive.bundle/BHService&quot;;</span><br></pre></td></tr></table></figure><ul><li>设置plist文件</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162383924-4e3279f9-dcfb-4328-839e-bef79af509a9.png"></p><ul><li>同样也是在 <code>setContext</code> 时注册 <code>services</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//加载services</span><br><span class="line">-(void)loadStaticServices</span><br><span class="line">&#123;</span><br><span class="line">    [BHServiceManager sharedManager].enableException = self.enableException;</span><br><span class="line">    </span><br><span class="line">    [[BHServiceManager sharedManager] registerLocalServices];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)registerLocalServices</span><br><span class="line">&#123;</span><br><span class="line">    NSString *serviceConfigName = [BHContext shareInstance].serviceConfigName;</span><br><span class="line">    //获取plist文件路径</span><br><span class="line">    NSString *plistPath = [[NSBundle mainBundle] pathForResource:serviceConfigName ofType:@&quot;plist&quot;];</span><br><span class="line">    if (!plistPath) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSArray *serviceList = [[NSArray alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">    </span><br><span class="line">    [self.lock lock];</span><br><span class="line">    //遍历并存储到allServicesDict中</span><br><span class="line">    for (NSDictionary *dict in serviceList) &#123;</span><br><span class="line">        NSString *protocolKey = [dict objectForKey:@&quot;service&quot;];</span><br><span class="line">        NSString *protocolImplClass = [dict objectForKey:@&quot;impl&quot;];</span><br><span class="line">        if (protocolKey.length &gt; 0 &amp;&amp; protocolImplClass.length &gt; 0) &#123;</span><br><span class="line">            [self.allServicesDict addEntriesFromDictionary:@&#123;protocolKey:protocolImplClass&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>load方法注册</li></ol><p>在 <code>Load</code> 方法里面注册 <code>Protocol</code> 协议，主要是调用 <code>BeeHive</code> 里面的<code>registerService:service:</code> 完成 <code>protocol</code> 的注册</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">   [[BeeHive shareInstance] registerService:@protocol(UserTrackServiceProtocol) service:[BHUserTrackViewController class]];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (void)registerService:(Protocol *)proto service:(Class) serviceClass</span><br><span class="line">&#123;</span><br><span class="line">    [[BHServiceManager sharedManager] registerService:proto implClass:serviceClass];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，三种方式就创建完成了</p><p><strong>Protocol的获取</strong></p><p><code>Protocol</code> 与 <code>Module</code> 的区别在于，<code>Protocol</code> 比 <code>Module</code> 多了一个方法，可以返回 <code>Protocol实例对象</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">- (id)createService:(Protocol *)proto;</span><br><span class="line">&#123;</span><br><span class="line">    return [[BHServiceManager sharedManager] createService:proto];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (id)createService:(Protocol *)service</span><br><span class="line">&#123;</span><br><span class="line">    return [self createService:service withServiceName:nil];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (id)createService:(Protocol *)service withServiceName:(NSString *)serviceName &#123;</span><br><span class="line">    return [self createService:service withServiceName:serviceName shouldCache:YES];</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">- (id)createService:(Protocol *)service withServiceName:(NSString *)serviceName shouldCache:(BOOL)shouldCache &#123;</span><br><span class="line">    if (!serviceName.length) &#123;</span><br><span class="line">        serviceName = NSStringFromProtocol(service);</span><br><span class="line">    &#125;</span><br><span class="line">    id implInstance = nil;</span><br><span class="line">    //判断protocol是否已经注册过</span><br><span class="line">    if (![self checkValidService:service]) &#123;</span><br><span class="line">        if (self.enableException) &#123;</span><br><span class="line">            @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:[NSString stringWithFormat:@&quot;%@ protocol does not been registed&quot;, NSStringFromProtocol(service)] userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *serviceStr = serviceName;</span><br><span class="line">    //如果有缓存，则直接从缓存中获取</span><br><span class="line">    if (shouldCache) &#123;</span><br><span class="line">        id protocolImpl = [[BHContext shareInstance] getServiceInstanceFromServiceName:serviceStr];</span><br><span class="line">        if (protocolImpl) &#123;</span><br><span class="line">            return protocolImpl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取类后，然后响应下层的方法</span><br><span class="line">    Class implClass = [self serviceImplClass:service];</span><br><span class="line">    if ([[implClass class] respondsToSelector:@selector(singleton)]) &#123;</span><br><span class="line">        if ([[implClass class] singleton]) &#123;</span><br><span class="line">            if ([[implClass class] respondsToSelector:@selector(shareInstance)])</span><br><span class="line">                //创建单例对象</span><br><span class="line">                implInstance = [[implClass class] shareInstance];</span><br><span class="line">            else</span><br><span class="line">                //创建实例对象</span><br><span class="line">                implInstance = [[implClass alloc] init];</span><br><span class="line">            if (shouldCache) &#123;</span><br><span class="line">                //缓存</span><br><span class="line">                [[BHContext shareInstance] addServiceWithImplInstance:implInstance serviceName:serviceStr];</span><br><span class="line">                return implInstance;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return implInstance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return [[implClass alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createService</code> 会先检查Protocol协议是否是注册过的。然后接着取出字典里面对应的Class，如果实现了 <code>shareInstance</code> 方法，那么就创建一个 <code>单例对象</code>，如果没有，那么就创建一个 <code>实例对象</code>。如果还实现了singleton，就能进一步的把 <code>implInstance</code> 和<code>serviceStr</code> 对应的加到 <code>BHContext</code> 的 <code>servicesByName</code> 字典里面 <code>缓存</code> 起来。这样就可以随着上下文传递了</p><ul><li>进入 <code>serviceImplClass</code> 实现，从这里可以看出 <code>protocol</code> 和 <code>类</code> 是通过 <code>字典</code> 绑定的，<code>protocol</code>作为<code>key</code>，<code>serviceImp</code>（类的名字）作为<code>value</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (Class)serviceImplClass:(Protocol *)service</span><br><span class="line">&#123;</span><br><span class="line">    //通过字典将 协议 和 类 绑定，其中协议作为key，serviceImp（类的名字）作为value</span><br><span class="line">    NSString *serviceImpl = [[self servicesDict] objectForKey:NSStringFromProtocol(service)];</span><br><span class="line">    if (serviceImpl.length &gt; 0) &#123;</span><br><span class="line">        return NSClassFromString(serviceImpl);</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Module-amp-Protocol"><a href="#Module-amp-Protocol" class="headerlink" title="Module &amp; Protocol"></a>Module &amp; Protocol</h1><p>这里简单总结下：</p><ul><li><p>对于 <code>Module</code>：数组存储</p></li><li><p>对于 <code>Protocol</code>：通过字典将 <code>protocol</code> 与 <code>类</code> 进行 <code>绑定</code>，<code>key</code> 为 <code>protocol</code>， <code>value</code> 为 <code>serviceImp</code> 即类名</p></li></ul><h1 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h1><ul><li><p><code>BHConfig</code> 类：是一个单例，其内部有一个 <code>NSMutableDictionary</code> 类型的 <code>config</code> 属性，该属性维护了一些动态的环境变量，作为 <code>BHContext</code> 的补充存在</p></li><li><p><code>BHContext</code> 类：是一个单例，其内部有两个 <code>NSMutableDictionary</code> 的属性，分别是 <code>modulesByName</code> 和 <code>servicesByName</code>。这个类主要用来保存上下文信息的。例如在 <code>application:didFinishLaunchingWithOptions:</code> 的时候，就可以初始化大量的上下文信息</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//保存信息</span><br><span class="line">[BHContext shareInstance].application = application;</span><br><span class="line">[BHContext shareInstance].launchOptions = launchOptions;</span><br><span class="line">[BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/BeeHive&quot;;//可选，默认为BeeHive.bundle/BeeHive.plist</span><br><span class="line">[BHContext shareInstance].serviceConfigName = @&quot;BeeHive.bundle/BHService&quot;;</span><br></pre></td></tr></table></figure><ul><li><p><code>BHTimeProfiler</code> 类：用来进行计算时间性能方面的Profiler</p></li><li><p><code>BHWatchDog</code> 类：用来开一个线程，监听主线程是否堵塞</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理39：组件化（一）方案</title>
      <link href="/BboyZJ.github.io/2021/06/22/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8639%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%B9%E6%A1%88/"/>
      <url>/BboyZJ.github.io/2021/06/22/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8639%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p><strong>组件化方案</strong></p><p>常用的组件化方案主要有两种：</p><ul><li><p><code>本地组件化</code>：主要是通过在 <code>工程中创建library</code>，利用 <code>cocoapods</code> 的 <code>workspec</code> 进行本地管理，不需要将项目上传git，而是直接在本项目中以 <code>framework</code> 的方法进行调用</p></li><li><p><code>cocoapods组件化</code>：主要是利用 <code>cocoapods</code> 来进行管理模块的 <code>远程管理</code>，需要将项目上传git（需要注意：这里的组件化模块分为 <code>公有库</code> 和 <code>私有库</code>，对公司而言，一般是 <code>私有库</code>）</p></li></ul><h1 id="本地组件化"><a href="#本地组件化" class="headerlink" title="本地组件化"></a>本地组件化</h1><h2 id="创建主工程"><a href="#创建主工程" class="headerlink" title="创建主工程"></a>创建主工程</h2><ul><li>首先创建一个名为 <code>Modularization</code> 的工程</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162391343-e72a3235-b07f-41da-9fbf-cca1a55c4e8b.jpg"></p><ul><li>集成 cocoapods，进行本地管理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhangjian@zhangjiandeMBP ~ % cd /Users/zhangjian/Desktop/Modularization </span><br><span class="line">zhangjian@zhangjiandeMBP Modularization % pod init</span><br><span class="line">Ignoring ffi-1.13.1 because its extensions are not built. Try: gem pristine ffi --version 1.13.1</span><br><span class="line">zhangjian@zhangjiandeMBP Modularization % pod install</span><br></pre></td></tr></table></figure><h2 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h2><p>假设有以下几个模块</p><ul><li><p><code>主工程</code>：承载主要的表层业务代码</p></li><li><p><code>Core</code>：独立存在，应用加密、接口请求等敏感代码</p></li><li><p><code>Base</code>：基类封装，拓展，基本的数据处理</p></li><li><p><code>Service</code>：服务层，封装业务工具类，例如网络层服务、持久化服务等</p></li><li><p><code>Pods</code>：三方依赖</p></li></ul><p>其中，各个模块间的关系如下图</p><p><img src="https://user-images.githubusercontent.com/25925248/162391360-04089910-c38d-4859-b4f2-dfc4de229332.jpg"></p><p>下面，我们来进行模块的创建，以 <code>Core</code> 模块为例：</p><ul><li>选择  <code>File -&gt; new -&gt; project -&gt; iOS -&gt; Framework</code>，新建一个 <code>ZJCore</code> 模块</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162391370-c14294a9-e941-4a20-ad6d-edaa12a76afc.jpg"></p><p><img src="https://user-images.githubusercontent.com/25925248/162391384-d4ee6235-4b4c-49fb-b448-2416822359df.jpg"></p><ul><li>选择正确的 <code>Group</code> 和 <code>WorkSpace</code>（这里注意：创建的 <code>library</code> 最好放在 <code>主工程根目录下</code>，否则后续的 <code>podfile</code> 执行 <code>pod install</code> 会报错）</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162391398-93ed8a4d-7f60-48c5-af68-8db35d74d8c0.jpg"></p><p>创建成功后，看到的结果如下：</p><p><img src="https://user-images.githubusercontent.com/25925248/162392357-ddca5e46-b788-4d08-9af5-7e48c475bd1f.jpg"></p><p><img src="https://user-images.githubusercontent.com/25925248/162391438-632eac8a-b78a-4901-995f-f997caeea671.jpg"></p><ul><li>将创建的 <code>library</code> 的 <code>Build Settings -&gt; Mach-O Type</code> 修改为静态库 <code>Static Library</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162391454-6eb6908f-7e29-4e00-afb5-cad186bcc1c0.jpg"></p><h2 id="主工程调用Library"><a href="#主工程调用Library" class="headerlink" title="主工程调用Library"></a>主工程调用Library</h2><ul><li>在 <code>ZJCore</code> 中新建一个文件，并添加如下代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJCoreSetting : NSObject</span><br><span class="line">// 声明属性</span><br><span class="line">@property (nonatomic,copy)NSString * name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ZJCoreSetting</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>在 <code>Build Phases -&gt; Headers -&gt; Public</code> 中将新建的文件拖拽到 <code>Puclic</code> 中，这样主工程才能访问该文件</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162391477-33f10151-72cd-48ae-9b9c-0ef6e22a1e4f.jpg"></p><ul><li>在ZJCore文件中添加引用</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162392415-896bf8dd-d51d-4d63-b548-babfc3101fc8.jpg"></p><ul><li>在主工程中，选择 <code>target -&gt; Frameworks,Libraries,and Embedded Content -&gt; + 号 -&gt; 添加 ZJCore</code>，只需要build主工程，library能够自动联编</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162392476-8813bdd9-e9e9-4508-80e5-40b5bd8101be.jpg"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先 <code>#import &lt;ZJCore/ZJCoreSetting.h&gt;</code>，然后使用</p><p><img src="https://user-images.githubusercontent.com/25925248/162392563-05712fc4-c7b3-4fde-ae68-05291475888b.jpg"></p><p>这里需要注意的是，子library之间的互相调用，与主工程调用library类似，主需要添加依赖、暴露header即可</p><h2 id="使用cocoapods管理三方依赖"><a href="#使用cocoapods管理三方依赖" class="headerlink" title="使用cocoapods管理三方依赖"></a>使用cocoapods管理三方依赖</h2><p>假设我们需要在 <code>ZJCore</code> 中封装网络层代码，需要用到三方库 <code>AFNetworking</code>，在podfile中有如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Uncomment the next line to define a global platform for your project</span><br><span class="line">platform :ios, &#x27;9.0&#x27;</span><br><span class="line"></span><br><span class="line">################# 三方依赖</span><br><span class="line"># 网络</span><br><span class="line">def network_layer_pods</span><br><span class="line">  pod &#x27;AFNetworking&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">################# 模块</span><br><span class="line">target &#x27;ZJCore&#x27; do</span><br><span class="line">  # 配置libray路径</span><br><span class="line">  project &#x27;ZJCore/ZJCore.xcodeproj&#x27;</span><br><span class="line">  </span><br><span class="line">  network_layer_pods</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">################# 主工程</span><br><span class="line">target &#x27;Modularization&#x27; do</span><br><span class="line">  # Comment the next line if you don&#x27;t want to use dynamic frameworks</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  network_layer_pods</span><br><span class="line">  </span><br><span class="line">  # Pods for Modularization</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>终端 <code>pod install</code> ，然后等待成功，成功后你可以在 <code>ZJCore</code> 模块中引用头文件 <code>#import &lt;AFNetworking.h&gt;</code> 并使用三方库如下：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162392633-b133fffd-2556-4cef-a001-1f592cd00385.jpg"></p><p>到此，一个本地组件化的模块就配置完成了</p><h1 id="cocoapods组件化"><a href="#cocoapods组件化" class="headerlink" title="cocoapods组件化"></a>cocoapods组件化</h1><p>除了本地组件化，还可以使用 <code>cocoapods</code>，其原理如下图所示</p><p><img src="https://user-images.githubusercontent.com/25925248/162392666-70284e13-deb7-410a-9aa9-3b1b7f445d43.jpg"></p><p>这里还是以本地组件化中的结构为例</p><h2 id="创建私有仓库"><a href="#创建私有仓库" class="headerlink" title="创建私有仓库"></a>创建私有仓库</h2><ul><li><p>在 <code>github</code> 上创建一个 <code>MySpecs</code> 仓库</p><p>  具体步骤：<code>登录github -&gt; 点击右上角+号 -&gt; new reponsitory -&gt; 输入 repository name 为 MySpecs</code>，选择仓库类型为 <code>private</code>，点击 <code>Create reponsitory</code></p></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162392746-36c9099d-8664-4306-92be-466c2aca0804.jpg"></p><ul><li>将私有仓库添加至本地 <code>~/.cocoapods/repos</code> 目录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add MySpecs git@github.com:13718004742/MySpecs.git</span><br></pre></td></tr></table></figure><p>查看添加结果</p><p><img src="https://user-images.githubusercontent.com/25925248/162392777-6cbbadfd-25cc-45f5-80eb-04b9f8ff69fc.jpg"></p><h2 id="创建pods工程，即组件化工程"><a href="#创建pods工程，即组件化工程" class="headerlink" title="创建pods工程，即组件化工程"></a>创建pods工程，即组件化工程</h2><ul><li>使用终端创建 <code>ZJServices</code> 模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% cd Desktop </span><br><span class="line">% pod lib create ZJServices</span><br></pre></td></tr></table></figure><ul><li>根据提示一次输入：<code>iOS、Objc、Yes、None、No、ZJ</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162392799-d5cba246-02d9-45a0-b82e-eeff822222eb.jpg"></p><ul><li>进入模块的目录，将文件拷贝至 <code>ZJServices -&gt; Classes</code> 中，删掉 ReplaceMe.m -&gt; 替换成你封装好的文件</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162392814-28eae045-d508-492b-9cdf-3d769be574ce.jpg"></p><ul><li>执行 <code>pod install</code>，会将 <code>Classes更新至pods中</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% cd /Users/zhangjian/Desktop/ZJServices/Example</span><br><span class="line">% pod install</span><br></pre></td></tr></table></figure><p>成功后，查看工程结构如下：</p><p><img src="https://user-images.githubusercontent.com/25925248/162392831-12aeb8c9-f923-49cc-ac32-0d15bbdc2362.jpg"></p><h2 id="配置pods工程"><a href="#配置pods工程" class="headerlink" title="配置pods工程"></a>配置pods工程</h2><p>修改模块的配置文件，即 <code>ZJServices.podspec</code></p><ul><li>如果需要依赖三方库，需要配置 <code>s.dependecy</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.dependency &#x27;AFNetworking&#x27;, &#x27;~&gt; 4.0.1&#x27;</span><br></pre></td></tr></table></figure><ul><li>如果模块间需要相互引用，同样需要配置 <code>s.dependency</code>，以 <code>ZJCore</code> 为例，需要引用 <code>ZJService</code>，在桌面以同样的方式再次创建一个 <code>ZJCore</code>，然后修改如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 1.修改 podspec 文件</span><br><span class="line">s.dependency &#x27;ZJServices&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/25925248/162392857-25e04acc-6c48-43c5-b63a-9f997319dacf.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 2. 修改podfile 文件</span><br><span class="line">pod &#x27;ZJServices&#x27;, :path =&gt; &#x27;../../ZJServices&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/25925248/162392875-0757b94d-500d-4e89-bc90-05dfb673baab.jpg"></p><ul><li><p>如果需要加载资源，如 <code>图片/json/bundle</code> 文件等</p><ul><li>在模块的 <code>Assets</code> 文件夹中添加资源文件</li><li>在 <code>specs</code> 里配置资源路径（必须配置！！否则无法读取资源）</li><li>访问时需要指定资源文件路径</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1. 修改 podspec 文件，自动创建ZJCore.bundle</span><br><span class="line">s.resource_bundles = &#123;</span><br><span class="line">    &#x27;ZJCore&#x27; =&gt; [&#x27;ZJCore/Assets/*.png&#x27;]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>ZJCore</code> 为显示的图片资源的 <code>bundle</code> 名字，在本地会显示 <code>ZJCore.bundle</code>，这个 <code>可以自定义</code>，<code>ZJCore/Assets</code> 为图片文件目录，回到 <code>ZJCore</code> 的 <code>Example</code> 模块，安装 <code>pod install</code></p><p><img src="https://user-images.githubusercontent.com/25925248/162392892-38e08dca-aeca-4c51-bb8e-f92bfdc44ae8.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 2. 使用</span><br><span class="line">UIImageView *imgView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];</span><br><span class="line">imgView.backgroundColor = [UIColor yellowColor];</span><br><span class="line">[self.view addSubview:imgView];</span><br><span class="line">    </span><br><span class="line">//到指定目录</span><br><span class="line">NSURL * bundleURL = [[NSBundle mainBundle] URLForResource:@&quot;Frameworks&quot; withExtension:nil];</span><br><span class="line">bundleURL = [bundleURL URLByAppendingPathComponent:@&quot;ZJCore&quot;];</span><br><span class="line">bundleURL = [bundleURL URLByAppendingPathExtension:@&quot;framework&quot;];</span><br><span class="line">if (bundleURL) &#123;</span><br><span class="line">    NSBundle *imgBundle = [NSBundle bundleWithURL:bundleURL];</span><br><span class="line">    bundleURL = [imgBundle URLForResource:@&quot;ZJCore&quot; withExtension:@&quot;bundle&quot;];</span><br><span class="line">    if (bundleURL) &#123;</span><br><span class="line">        NSBundle *bundle = [NSBundle bundleWithURL:bundleURL];</span><br><span class="line">        NSInteger scale = [[UIScreen mainScreen] scale];</span><br><span class="line">        NSString *imgName = [NSString stringWithFormat:@&quot;%@@%zdx.png&quot;, @&quot;zj&quot;,scale];</span><br><span class="line">        imgView.image = [UIImage imageWithContentsOfFile:[bundle pathForResource:imgName ofType:nil]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，图片资源在 <code>Frameworks</code> 下的 <code>ZJCore.framework</code> 下的 <code>ZJCore.bundle</code> 包中，右键打开包内容，即可看到 <code>zj@2x.png</code> 图片，如下图：</p><p><img src="https://user-images.githubusercontent.com/25925248/162392900-4a13d5c5-e5ed-4ff7-b930-094415da6cb5.jpg"></p><ul><li>同理，模块中的json文件的获取方式也是一样的</li></ul><h2 id="提交至git"><a href="#提交至git" class="headerlink" title="提交至git"></a>提交至git</h2><p>这里提交至git的模块是pods工程才可以，以 <code>ZJCore</code> 为例</p><ul><li><p>需要在github上创建一个私有repository，命名为 <code>ZJCore</code></p></li><li><p>执行以下终端命令</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;第一次提交&quot; </span><br><span class="line">// 即第一个步骤中创建的仓库地址</span><br><span class="line">$ git remote add origin git@github.com:13718004742/ZJCore.git</span><br><span class="line">// 查看当前主分支名</span><br><span class="line">$ git branch</span><br><span class="line">$ git push -u -f origin master </span><br><span class="line">// 一定要有标签，不然会有下面的警告</span><br><span class="line">// podspec文件中获取Git版本控制的项目需要tag号， % git tag -d rm 表示删除</span><br><span class="line">$ git tag &quot;0.1.0&quot; </span><br><span class="line">$ git push --tags </span><br></pre></td></tr></table></figure><h2 id="验证podspec文件"><a href="#验证podspec文件" class="headerlink" title="验证podspec文件"></a>验证podspec文件</h2><p>执行终端命令 <code>pod spec lint</code>，注意：<code>pod spec</code> 相对于 <code>pod lib</code> 会更为精确</p><pre><code>* pod lib 相当于只验证一个本地仓库* pod spec 会同时验证本地仓库和远程仓库</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% pod spec lint --allow-warnings</span><br></pre></td></tr></table></figure><p>如果出现如下错误</p><p><img src="https://user-images.githubusercontent.com/25925248/162392936-7f529feb-cfc9-49c7-828e-222187f1b449.jpg"></p><p>解决办法将 <code>podspec</code> 文件下的所有 <code>https://...</code> 均改为 <code>git@github...</code> </p><h2 id="提交到私有仓库"><a href="#提交到私有仓库" class="headerlink" title="提交到私有仓库"></a>提交到私有仓库</h2><p>执行 <code>pod repo</code> 查看本地 <code>MySpecs Repo</code></p><p>执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// pod repo push [本地Spec Repo名称][podspec文件路径]</span><br><span class="line">// 举例</span><br><span class="line">$ pod repo push MySpecs ZJCore.podspec --verbose --allow-warnings </span><br></pre></td></tr></table></figure><p>提交成功后，可在本地仓库中看到提交路径 <code>MySpecs -&gt; ZJCore</code></p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ul><li>在 <code>Classes</code> -&gt; 创建模块 <code>UIView、UILabel</code>等，并在各模块内存放你想拷贝的代码文件，如下图</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162393372-e8286d48-8617-4985-a4d7-70d3092e0478.jpg"></p><ul><li>上传改动到远程仓库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;xxx&quot;</span><br><span class="line">$ git push origin master</span><br><span class="line">// tag 值增加</span><br><span class="line">$ git tag 0.x.x</span><br><span class="line">//推送tag到服务器上</span><br><span class="line">$ git push --tags</span><br></pre></td></tr></table></figure><ul><li>修改.podspec</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162393391-e3df9bfb-37ca-43bb-8611-a3d8b2151d40.jpg"></p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><ul><li>新建一个 <code>ZJDemo</code> 工程，在项目的 <code>podfile</code> 里面添加</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Uncomment the next line to define a global platform for your project</span><br><span class="line">platform :ios, &#x27;9.0&#x27;</span><br><span class="line"></span><br><span class="line"># 私有库ZJCore</span><br><span class="line">source &#x27;git@github.com:13718004742/MySpecs.git&#x27;</span><br><span class="line"></span><br><span class="line">target &#x27;ZJDemo&#x27; do</span><br><span class="line">  # Comment the next line if you don&#x27;t want to use dynamic frameworks</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  # 私有库ZJCore</span><br><span class="line">  pod &#x27;ZJCore&#x27;</span><br><span class="line"></span><br><span class="line">  # Pods for ZJDemo</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>执行 <code>pod install</code> 即可</li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理38：界面优化方案</title>
      <link href="/BboyZJ.github.io/2021/06/09/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8638%EF%BC%9A%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
      <url>/BboyZJ.github.io/2021/06/09/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8638%EF%BC%9A%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要讲：</p><ul><li>卡顿原理：卡顿的原因 - <code>掉帧</code></li><li>卡顿检测工具</li><li>实战项目优化</li></ul><h1 id="界面卡顿"><a href="#界面卡顿" class="headerlink" title="界面卡顿"></a>界面卡顿</h1><p>通常来说，计算机中的显示过程是下面这样的，通过 <code>CPU、GPU、显示器</code> 协同工作来将图片显示到屏幕上的</p><p><img src="https://user-images.githubusercontent.com/25925248/162383391-72571ac3-d00a-44bc-bd32-3a044288ce11.png"></p><ul><li><p><code>CPU</code> 计算好显示的 <code>内容</code>，提交到 <code>GPU</code></p></li><li><p><code>GPU</code> 经过 <code>渲染</code> 完成后，将渲染的结果放入 <code>FrameBuffer(帧缓存区)</code></p></li><li><p>随后 <code>视频控制器</code> 会按照 <code>VSync(垂直同步)</code> 信号逐行读取 <code>FrameBuffer</code> 的数据</p></li><li><p>经过可能的 <code>数模转换</code> 传递给 <code>显示器</code> 进行显示</p></li></ul><p>最开始时，FrameBuffer只有一个，这种情况下 <code>FrameBuffer</code> 的读取和刷新有很大的 <code>效率</code> 问题，为了解决这个问题，引入了 <code>双缓存区</code>，即 <code>双缓冲机制</code>，即 <code>前FrameBuffer</code> 和 <code>后FrameBuffer</code>，GPU渲染结果来回切换放入 <code>前、后FrameBuffer</code> 中。视频控制器来回切换读取<code> 前后FrameBuffer</code>，交给 显示器显示</p><p><code>双缓存机制</code> 虽然解决了 <code>效率问题</code>，但是随之而言的是新的问题，当视频控制器还未 <code>读取的频率</code> 和 <code>渲染的频率</code> 不一致时，就会产生 <code>掉帧</code>，例如屏幕内容显示一半，GPU将新的一帧内容提交到 FrameBuffer，并将两个FrameBuffer而进行交换后，视频控制器就将新的一帧数据的下半段显示到屏幕上，造成 <code>屏幕撕裂</code> 现象</p><p>为了解决这个问题，采用了 <code>垂直同步信号机制</code>，即固定屏幕刷新率 <code>每秒刷新60次</code>，当开启垂直同步后，GPU会等待显示器的VSync信号发出后，才进行新的一帧渲染和FrameBuffer更新，而目前iOS设备中采用的正是 <code>双缓存区+VSync</code></p><p><strong>屏幕卡顿原因</strong></p><p>下面我们来说说，屏幕卡顿的原因</p><p>在 <code>VSync</code> 信号到来后，<code>系统图形服务</code> 会通过 <code>CADisplayLink</code> 等机制通知 <code>App</code>，App 主线程开始在 <code>CPU</code> 中计算显示内容，随后CPU会将计算好的内容提交到GPU去。由GPU进行变换、合成、渲染。随后 <code>GPU</code> 会把渲染结果提交到 <code>帧缓冲区</code> 去，等待下一次 <code>VSync</code> 信号到来时显示到屏幕上。由于垂直同步信号的机制，<code>如果在一个VSync时间内，CPU后者GPU没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示</code>，而这时显示屏会保留之前的内容不改变。所以可以简单理解 <code>掉帧</code> 为 <code>过时不候</code></p><p>如下图所示，是一个显示过程，第1个在VSync到来期间，GPU渲染提前完成，正常显示；第2个在VSync期间，仍在处理中，此时屏幕不刷新，依旧显示第1帧；第3个VSync期间，切换到另一个FrameBuffer，让CPU渲染；此时就出现了 <code>掉帧2</code> 情况，渲染时就会出现明显的 <code>卡顿现象</code></p><p><img src="https://user-images.githubusercontent.com/25925248/162383478-8a64cad7-9e0f-4939-8a08-fff88a2889a6.png"></p><p>从图中可以看出，CPU和GPU不论是哪个阻碍了显示流程，都会造成 <code>掉帧</code> 现象，所以为了给用户提供更好的体验，在开发中，我们需要进行 <code>卡顿检测</code> 以及相应的 <code>优化</code></p><h1 id="卡顿监控"><a href="#卡顿监控" class="headerlink" title="卡顿监控"></a>卡顿监控</h1><p>卡顿监控的方案一般有三种：</p><ul><li><p>YYFPSLabel：通过 <code>CADisplayLink + YYWeakProxy</code> </p></li><li><p><code>FPS监控</code>：为了保持流程的UI交互，App的刷新频率应该保持在 <code>60fps</code> 左右，其原因是因为 <code>iOS</code> 设备默认的刷新频率是 <code>60次/秒</code>，而1次刷新（即VSync信号发出）的间隔是 <code>1000ms/60次= 16.67ms/1次</code> ，所以如果在 <code>16.67ms</code> 内没有准备好下一帧数据，就会产生卡顿</p></li><li><p><code>主线程卡顿监控</code>：通过 <code>子线程监测主线程Runloop</code>，判断两个状态（<code>kCFRunLoopBeforeSource</code> 和 <code>kCFRunLoopAfrerWaiting</code>）之间的耗时是否达到一定阀值</p></li></ul><h1 id="FPS监控"><a href="#FPS监控" class="headerlink" title="FPS监控"></a>FPS监控</h1><p>FPS的监控，主要是通过 <code>CADislayLink</code> 实现，借助 <code>link</code> 的时间差，来计算一次刷新所需要的时间，然后通过 <code>刷新次数/时间差</code> 得到刷新频次，并判断是否在其范围，通过显示不同的文字颜色来表示卡顿严重成都。</p><ul><li>创建一个 <code>SPSDisplay</code> 工具类，实现如下代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface FPSDisplay: NSObject</span><br><span class="line">+ (instancetype)shareFPSDisplay;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;FPSDisplay.h&quot;</span><br><span class="line"></span><br><span class="line">#define SCREEN_HEIGHT [UIScreen mainScreen].bounds.size.height</span><br><span class="line">#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width</span><br><span class="line"></span><br><span class="line">@interface FPSDisplay ()</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) UILabel *displayLabel;</span><br><span class="line">@property (strong, nonatomic) CADisplayLink *link;</span><br><span class="line">@property (assign, nonatomic) NSInteger count;</span><br><span class="line">@property (assign, nonatomic) NSTimeInterval lastTime;</span><br><span class="line">@property (strong, nonatomic) UIFont *font;</span><br><span class="line">@property (strong, nonatomic) UIFont *subFont;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FPSDisplay</span><br><span class="line"></span><br><span class="line">+ (instancetype)shareFPSDisplay &#123;</span><br><span class="line">    static FPSDisplay *shareDisplay;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        shareDisplay = [[FPSDisplay alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return shareDisplay;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        [self initDisplayLabel];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)initDisplayLabel &#123;</span><br><span class="line">    CGRect frame = CGRectMake(SCREEN_WIDTH - 100, 44, 80, 30);</span><br><span class="line">    self.displayLabel = [[UILabel alloc] initWithFrame: frame];</span><br><span class="line">    self.displayLabel.layer.cornerRadius = 5;</span><br><span class="line">    self.displayLabel.clipsToBounds = YES;</span><br><span class="line">    self.displayLabel.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">    self.displayLabel.userInteractionEnabled = NO;</span><br><span class="line">    self.displayLabel.backgroundColor = [UIColor colorWithWhite:0.000 alpha:0.700];</span><br><span class="line">    _font = [UIFont fontWithName:@&quot;Menlo&quot; size:14];</span><br><span class="line">    if (_font) &#123;</span><br><span class="line">        _subFont = [UIFont fontWithName:@&quot;Menlo&quot; size:4];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        _font = [UIFont fontWithName:@&quot;Courier&quot; size:14];</span><br><span class="line">        _subFont = [UIFont fontWithName:@&quot;Courier&quot; size:4];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self initCADisplayLink];</span><br><span class="line">    </span><br><span class="line">    [[self keyWindow] addSubview:self.displayLabel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(UIWindow*)keyWindow</span><br><span class="line">&#123;</span><br><span class="line">    UIWindow *foundWindow = nil;</span><br><span class="line">    NSArray  *windows = [[UIApplication sharedApplication]windows];</span><br><span class="line">    for (UIWindow  *window in windows) &#123;</span><br><span class="line">        if (window.isKeyWindow) &#123;</span><br><span class="line">            foundWindow = window;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return foundWindow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)initCADisplayLink &#123;</span><br><span class="line">    self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];</span><br><span class="line">    [self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)tick:(CADisplayLink *)link &#123;</span><br><span class="line">    if (self.lastTime == 0) &#123;           //对LastTime进行初始化</span><br><span class="line">        self.lastTime = link.timestamp;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    self.count += 1;   //记录tick在1秒内执行的次数</span><br><span class="line">    NSTimeInterval delta = link.timestamp - self.lastTime;  //计算本次刷新和上次更新FPS的时间间隔</span><br><span class="line">    </span><br><span class="line">    //大于等于1秒时，来计算FPS</span><br><span class="line">    if (delta &gt;= 1) &#123;</span><br><span class="line">        self.lastTime = link.timestamp;</span><br><span class="line">        float fps = self.count / delta;         // 次数 除以 时间 = FPS （次/秒）</span><br><span class="line">        self.count = 0;</span><br><span class="line">        [self updateDisplayLabelText: fps];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)updateDisplayLabelText: (float) fps &#123;</span><br><span class="line">    CGFloat progress = fps / 60.0;</span><br><span class="line">    UIColor *color = [UIColor colorWithHue:0.27 * (progress - 0.2) saturation:1 brightness:0.9 alpha:1];</span><br><span class="line">    self.displayLabel.text = [NSString stringWithFormat:@&quot;%d FPS&quot;,(int)round(fps)];</span><br><span class="line">    self.displayLabel.textColor = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [_link invalidate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[FPSDisplay shareFPSDisplay];</span><br></pre></td></tr></table></figure><h1 id="主线程卡顿监控"><a href="#主线程卡顿监控" class="headerlink" title="主线程卡顿监控"></a>主线程卡顿监控</h1><p>除了FPS，还可以通过 <code>RunLoop</code> 来监控，因为卡顿的是事务，而事务是交由 <code>主线程</code> 的 <code>RunLoop</code> 处理的。</p><p>也可以直接使用三方库</p><ul><li><p><code>OC</code> 可以使用 <a href="https://www.jianshu.com/p/412b20d9a0f6">微信matrix</a>、<a href="https://github.com/didi/DoraemonKit">滴滴DoramonKit</a></p></li><li><p><code>Swift</code> 的卡顿检测第三方 <a href="https://www.jianshu.com/p/412b20d9a0f6">ANREye</a>，其主要思路是：创建子线程进行循环监测，每次检测时设置标记置为true，然后派发任务到主线程，标记置为false，接着子线程睡眠超过阀值时，判断标记是否为false，如果没有，说明主线程发生了卡顿</p></li></ul><h1 id="界面优化"><a href="#界面优化" class="headerlink" title="界面优化"></a>界面优化</h1><p><strong>CPU层面的优化</strong></p><ul><li><p>尽量 <code>用轻量级的对象</code> 代替重量级的对象，可以对性能有所优化，例如: 不需要相应 <code>触摸</code> 时间的控件，用 <code>CALayer</code> 代替 <code>UIView</code></p></li><li><p>尽量减少 对 <code>UIView</code> 和 <code>CALayer</code> 的属性修改</p><ul><li><p>CALayer内部并没有属性，当调用属性方法时，其内部是通过运行时 <code>resolveInstanceMethod</code> 为对象临时添加一个方法，并将对应属性值保存在内部的一个 Dictionary中，同时还会通知delegate、创建动画等，非常haoshi</p></li><li><p><code>UIView</code> 相关的显示属性，例如frame、bounds、transform等，实际上都是从CALayer映射来的，对齐进行调整时，消耗的资源比一般属性要大</p></li></ul></li><li><p>当有大量对象释放时，也是非常耗时的，尽量挪到后台线程去释放</p></li><li><p>尽量 <code>提前计算视图布局</code>，即 <code>预排版</code>，例如cell的行高</p></li><li><p><code>Autolayout</code> 在简单页面情况下我们可以很好的提升开发效率，但是对于复杂视图而言，会产生严重的性能问题，随着视图数量的增长，<code>Autolayout</code> 带来的CPU消耗是程指数上升的，所以尽量使用 <code>代码布局</code>，如果不想手动调整frame等，也可以借助三方库，例如<code>Masonry（OC）、SnapKit(swift)</code>等等</p></li><li><p>文本处理的优化：当一个界面有大量文本时，其行高的计算、绘制也是非常耗时的</p><ul><li><p>如果对文本没有特殊要求，可以使用UILabel内部的实现方式，且需要放到子线程中进行，避免则塞主线程</p><ul><li><p>计算文本宽高：<code>[NSAttributedString boundingRectWithSize:options:context:]</code></p></li><li><p>文本绘制： <code>[NSAttributedString drawWithRect:options:context:]</code></p></li></ul></li><li><p>自定义文本控件，利用 <code>TextKit</code> 或最底层的 <code>CoreText</code> 对文本 <code>异步绘制</code>。并且 <code>CoreText</code> 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整和绘制都需要计算一次），CoreText直接使用了 <code>CoreGraphics</code> 占用内存小，效率高</p></li></ul></li><li><p>图片处理（解码+绘制）</p><ul><li><p>当使用 <code>UIImage</code> 或 <code>CGImageSource</code> 的方法创建图片时，图片的数据不会立即解码，而是在设置时解码（即图片设置到 <code>UIImageView/CALayer.contents</code> 中，然后在 <code>CALayer</code> 提交至GPU渲染前，<code>CGImage</code> 中的数据才进行解码）。这一步是 <code>无可避免</code> 的，且是发生在 <code>主线程</code> 中的。想要绕开这个机制，常见的做法是在子线程中优先将图片绘制到 <code>CGBitmapContext</code>，然后从 <code>Bitmap</code> 直接创建图片，例如 <code>SDWebImage</code> 三方框架对图片的编解码处理，这就是 <code>Image</code> 的 <code>预解码</code></p></li><li><p>当使用 <code>CG</code> 开头的方法 <code>绘制图像</code> 到画布中，然后从画布中创建图片时，可以将图像的 <code>绘制</code> 在 <code>子线程</code> 中进行</p></li></ul></li><li><p>图片优化</p><ul><li><p>尽量使用 <code>PNG</code> 格式图片，不适用 <code>JPEG</code> 图片</p></li><li><p>通过 <code>子线程预解码，主线程渲染</code>，即通过 <code>Bitmap</code> 创建图片，在子线程赋值 image</p></li><li><p>优化图片大小，尽量避免动态缩放</p></li><li><p>尽量将多张图合并为一张进行显示</p></li></ul></li><li><p>尽量 <code>避免使用透明的view</code>，因为使用透明的view，会导致在GPU中计算像素时，会将透明view下层图层的像素也计算进来，即 <code>颜色混合</code> 处理</p></li><li><p><code>按需加载</code> ，例如在TableView中滑动时不加载图片，使用默认占位图，而是在滑动停止时加载</p></li><li><p>少使用 <code>addView</code> 给 <code>cell</code> 动态添加 <code>view</code></p></li></ul><h1 id="GPU层面的优化"><a href="#GPU层面的优化" class="headerlink" title="GPU层面的优化"></a>GPU层面的优化</h1><p>相对于CPU而言，GPU主要是接收CPU提交的 <code>纹理+顶点</code>，经过一系列 <code>transform</code>，最终 <code>混合并渲染</code>，输出到 <code>屏幕上</code></p><ul><li><p>尽量 <code>减少在短时间内大量图片的显示</code>，尽可能将 <code>多张图片合为一张显示</code>，主要是因为当有大量图片进行显示时，无论是CPU计算还是GPU的渲染，都是非常耗时的，很可能出现掉帧的情况</p></li><li><p>尽量 <code>避免图片的尺寸超过4096x4096</code>，因为当图片超过这个尺寸时，会先由CPU进行预处理，然后再提交给GPU处理，导致额外CPU资源消耗</p></li><li><p>尽量 <code>减少视图数量和层次</code>，主要是因为视图过多且重叠时，GPU会将其混合，混合的过程也是非常耗时的</p></li><li><p><code>尽量避免离屏渲染</code></p></li><li><p><code>异步渲染</code>，例如可以将cell中的所有控件、视图合并成一张图片进行显示。可以参考 <a href="https://www.jianshu.com/p/412b20d9a0f6">Graver</a> 三方框架</p></li></ul><p><strong>注：上述这些优化方式的落地实现，需要根据自身项目进行评估，合理的使用进行优化</strong></p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理37：内存管理（三）AutoReleasePool &amp; NSRunLoop 底层分析</title>
      <link href="/BboyZJ.github.io/2021/06/02/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8637%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89AutoReleasePool-NSRunLoop-%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/"/>
      <url>/BboyZJ.github.io/2021/06/02/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8637%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89AutoReleasePool-NSRunLoop-%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要分析 <code>AutoReleasePool</code> 以及 <code>NSRunLoop </code> 的底层实现</p><h1 id="AutoReleasePool-自动释放池"><a href="#AutoReleasePool-自动释放池" class="headerlink" title="AutoReleasePool 自动释放池"></a>AutoReleasePool 自动释放池</h1><p><code>自动释放池</code> 是OC中的一种 <code>内存自动回收机制</code>，它可以将加入 <code>AutoReleasePool</code> 中的 <code>变量release的时机延迟</code>，简单来说，就是当创建一个 <code>对象</code>，在正常情况下，变量会在超出其作用域的时，立即release。如果对象加入到了自动释放池中，这个对象并 <code>不会立即释放</code>，会 <code>等到runloop休眠/超出autoreleasepool&#123;&#125;作用域</code> 之后才能 <code>被释放</code>。其机制如下图所示</p><p><img src="/BboyZJ.github.io/assets/16499858677848.png"></p><ul><li><p>从程序启动到加载完成，主线程对应的 <code>runloop</code> 会处于 <code>休眠</code> 状态，等待用户交互来唤醒runloop</p></li><li><p>用户的每一次 <code>交互</code> 都会启动一次 <code>runloop</code>，用于处理用户的 <code>所有点击、触摸事件等</code></p></li><li><p><code>runloop</code> 在 <code>监听到交互事件</code> 后，就会 <code>创建</code> 自动释放池，并将所有 <code>延迟释放</code> 的对象添加到自动释放池</p></li><li><p>在一次完整的runloop结束之前，会向自动释放池中所有对象 <code>发送release消息</code>，然后 <code>销毁</code> 自动释放池</p></li></ul><h2 id="clang分析"><a href="#clang分析" class="headerlink" title="clang分析"></a>clang分析</h2><p>根据之前源码分析经验，我们先通过 <code>clang</code> 来分析</p><ul><li>定义如下代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过clang编译成底层实现，命令为：<code>xcrun -sdk iphonesimulator clang -arch x86_64 - rewrite-objc main.m</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//*********__AtAutoreleasePool**********</span><br><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">    //构造函数</span><br><span class="line">    __AtAutoreleasePool() &#123;</span><br><span class="line">            atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">    &#125;</span><br><span class="line">    //析构函数</span><br><span class="line">    ~__AtAutoreleasePool() &#123;</span><br><span class="line">            objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">     &#125;</span><br><span class="line">      void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//*********main*********</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">   &#123; </span><br><span class="line">        // 是一个结构体</span><br><span class="line">        __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，自动释放池其本质也是一个 <code>对象</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;&#125;</span><br><span class="line">//等价于</span><br><span class="line">&#123;__AtAutoreleasePool __autoreleasepool; &#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>__AtAutoreleasePool</code> 是一个 <code>结构体</code>，由 <code>构造函数 + 析构函数</code>，结构体定义的对象在作用域结束后，会自动调用析构函数</p></li><li><p>其中 <code>&#123;&#125;</code> 是作用域，优点是 <code>结构清晰，可读性强</code>，可以 <code>及时创建销毁</code></p></li></ul><p>关于涉及的构造和析构函数的调用时机，可以通过下面一个案例来验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct ZJTest&#123;</span><br><span class="line">    ZJTest</span><br><span class="line">()&#123;</span><br><span class="line">        printf(&quot;123 - %s\n&quot;, __func__);</span><br><span class="line">    &#125;</span><br><span class="line">    ~ZJTest()&#123;</span><br><span class="line">        printf(&quot;456 - %s\n&quot;, __func__);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        ZJTest test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//**********运行结果**********</span><br><span class="line">123 - ZJTest</span><br><span class="line">456 - ~ZJTest</span><br></pre></td></tr></table></figure><p>从而可以得出，在 <code>ZJTest</code> 创建对象时，会自动调用 <code>构造函数</code>，在出了{}作用域后，会自动调用析构函数</p><h2 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h2><ul><li>在main代码部分加断点，运行程序，并开启汇编调试</li></ul><p><img src="/BboyZJ.github.io/assets/16499903608932.jpg"></p><p>通过调试结果发现，证明了我们clang分析的结果</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><code>autoreleasepool</code> 其本质是一个 <code>结构体对象</code>，一个自动释放池对象就是页，是 <code>栈结构存储</code>，符合 <code>先进后出</code> 的原则</p></li><li><p>页的栈底是一个 <code>56</code> 字节大小的 <code>空占位符</code>，一页总大小为 <code>4096</code> 字节</p></li><li><p>只有 <code>第一页</code> 有 <code>哨兵</code> 对象，最多存储 <code>504</code> 个对象，从第二页开始最多存储 <code>505</code> 个对象</p></li><li><p><code>autoreleasepool</code> 在加入要释放的对象时，底层调用的是 <code>objc_autoreleasePoolPush</code> 方法</p></li><li><p><code>autoreleasepool</code> 在调用析构函数释放时，内部的实现时调用 <code>objc_autoreleasePoolPop</code> 方法</p></li></ul><h1 id="底层分析"><a href="#底层分析" class="headerlink" title="底层分析"></a>底层分析</h1><p>在 <code>objc</code> 源码中，对 <code>AutoreleasePool</code> 的解释如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Autorelease pool implementation</span><br><span class="line"></span><br><span class="line">- A thread&#x27;s autorelease pool is a stack of pointers. </span><br><span class="line">线程的自动释放池是指针的堆栈</span><br><span class="line"></span><br><span class="line">- Each pointer is either an object to release, or POOL_BOUNDARY which is an autorelease pool boundary.</span><br><span class="line">每个指针都是要释放的对象，或者是POOL_BOUNDARY，它是自动释放池的边界。</span><br><span class="line"></span><br><span class="line">- A pool token is a pointer to the POOL_BOUNDARY for that pool. When the pool is popped, every object hotter than the sentinel is released.</span><br><span class="line">池令牌是指向该池的POOL_BOUNDARY的指针。弹出池后，将释放比哨点更热的每个对象。</span><br><span class="line"></span><br><span class="line">- The stack is divided into a doubly-linked list of pages. Pages are added and deleted as necessary. </span><br><span class="line">堆栈分为两个双向链接的页面列表。根据需要添加和删除页面。</span><br><span class="line"></span><br><span class="line">- Thread-local storage points to the hot page, where newly autoreleased objects are stored. </span><br><span class="line">线程本地存储指向热页面，该页面存储新自动释放的对象。</span><br></pre></td></tr></table></figure><p><strong>通过描述。有以下几点说明：</strong></p><ul><li><p><code>自动释放池</code> 是一个关于 <code>指针</code> 的 <code>堆栈</code></p></li><li><p>其中的指针是指要 <code>释放的对象</code> 或者 <code>pool_boundary</code> 哨兵（现在经常被称为 <code>边界</code>）</p></li><li><p>自动释放池是一个 <code>页</code>  的结构（细腻内存中提及），而且这个 <code>页</code> 是一个 <code>双向链接</code>（表示父节点和子节点，在类中提及过，即类的继承链）</p></li><li><p><code>自动释放池</code> 和 <code>线程</code> 有关系</p></li></ul><p><strong>对于 <code>自动释放池</code>，我们主要关心的点有以下三点：</strong></p><ul><li><p>自动释放池是什么时候 <code>创建</code>？</p></li><li><p>对象时 <code>如何加入到自动释放池</code> 的？</p></li><li><p><code>哪些对象才会加入</code> 自动释放池？</p></li></ul><p>下面带着这些问题，我们来进一步探索自动释放池的底层原理</p><h1 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h1><ul><li>从最初的 <code>clang</code> 或者 <code>汇编</code> 分析我们了解了自动释放池其底层是调用的 <code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code> 两个方法，其源码实现如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//***********push方法***********</span><br><span class="line">void *</span><br><span class="line">objc_autoreleasePoolPush(void)</span><br><span class="line">&#123;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//***********pop方法***********</span><br><span class="line">void</span><br><span class="line">objc_autoreleasePoolPop(void *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从源码中我们发现，都是调用的 <code>AutoreleasePoolPage</code> 的 <code>push</code> 和 <code>pop</code>，以下是其定义，从定义中可以看出，自动释放池是一个 <code>页</code>，同时也是一个 <code>对象</code>，这个 <code>页</code> 的大小是 <code>4096字节</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">//************宏定义************</span><br><span class="line">#define PAGE_MIN_SIZE           PAGE_SIZE</span><br><span class="line">#define PAGE_SIZE               I386_PGBYTES</span><br><span class="line">#define I386_PGBYTES            4096            /* bytes per 80386 page */</span><br><span class="line"></span><br><span class="line">//************类定义************</span><br><span class="line">class AutoreleasePoolPage : private AutoreleasePoolPageData</span><br><span class="line">&#123;</span><br><span class="line">    friend struct thread_data_t;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    //页的大小</span><br><span class="line">    static size_t const SIZE =</span><br><span class="line">#if PROTECT_AUTORELEASEPOOL</span><br><span class="line">        PAGE_MAX_SIZE;  // must be multiple of vm page size</span><br><span class="line">#else</span><br><span class="line">        PAGE_MIN_SIZE;  // size and alignment, power of 2</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    //构造函数</span><br><span class="line">    AutoreleasePoolPage(AutoreleasePoolPage *newParent) :</span><br><span class="line">        AutoreleasePoolPageData(begin(),//开始存储的位置</span><br><span class="line">                                objc_thread_self(),//传的是当前线程，当前线程时通过tls获取的</span><br><span class="line">                                newParent,</span><br><span class="line">                                newParent ? 1+newParent-&gt;depth : 0,//如果是第一页深度为0，往后是前一个的深度+1</span><br><span class="line">                                newParent ? newParent-&gt;hiwat : 0)</span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //析构函数</span><br><span class="line">    ~AutoreleasePoolPage() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    //页的开始位置</span><br><span class="line">    id * begin() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //页的结束位置</span><br><span class="line">    id * end() &#123;...&#125;</span><br><span class="line">   </span><br><span class="line">    //页是否为空</span><br><span class="line">    bool empty() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //页是否满了</span><br><span class="line">    bool full() &#123;...&#125;</span><br><span class="line">   </span><br><span class="line">    //页的存储是否少于一半</span><br><span class="line">    bool lessThanHalfFull() &#123;...&#125;</span><br><span class="line">     </span><br><span class="line">     //添加释放对象</span><br><span class="line">    id *add(id obj)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //释放所有对象</span><br><span class="line">    void releaseAll() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //释放到stop位置之前的所有对象</span><br><span class="line">    void releaseUntil(id *stop) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //杀掉</span><br><span class="line">    void kill() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //释放本地线程存储空间</span><br><span class="line">    static void tls_dealloc(void *p) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //获取AutoreleasePoolPage</span><br><span class="line">    static AutoreleasePoolPage *pageForPointer(const void *p) &#123;...&#125;</span><br><span class="line">    static AutoreleasePoolPage *pageForPointer(uintptr_t p)  &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //是否有空池占位符</span><br><span class="line">    static inline bool haveEmptyPoolPlaceholder() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //设置空池占位符</span><br><span class="line">    static inline id* setEmptyPoolPlaceholder()&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //获取当前操作页</span><br><span class="line">    static inline AutoreleasePoolPage *hotPage()&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //设置当前操作页</span><br><span class="line">    static inline void setHotPage(AutoreleasePoolPage *page) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //获取coldPage</span><br><span class="line">    static inline AutoreleasePoolPage *coldPage() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //快速释放</span><br><span class="line">    static inline id *autoreleaseFast(id obj)&#123;...&#125;</span><br><span class="line">   </span><br><span class="line">   //添加自动释放对象，当页满的时候调用这个方法</span><br><span class="line">    static __attribute__((noinline))</span><br><span class="line">    id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //添加自动释放对象，当没页的时候使用这个方法</span><br><span class="line">    static __attribute__((noinline))</span><br><span class="line">    id *autoreleaseNoPage(id obj)&#123;...&#125;</span><br><span class="line">   </span><br><span class="line">   //创建新页</span><br><span class="line">    static __attribute__((noinline))</span><br><span class="line">    id *autoreleaseNewPage(id obj) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    //自动释放</span><br><span class="line">    static inline id autorelease(id obj)&#123;...&#125;</span><br><span class="line">   </span><br><span class="line">    //入栈</span><br><span class="line">    static inline void *push() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //兼容老的 SDK 出栈方法</span><br><span class="line">    __attribute__((noinline, cold))</span><br><span class="line">    static void badPop(void *token)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //出栈页面</span><br><span class="line">    template&lt;bool allowDebug&gt;</span><br><span class="line">    static void</span><br><span class="line">    popPage(void *token, AutoreleasePoolPage *page, id *stop)&#123;...&#125;</span><br><span class="line">    __attribute__((noinline, cold))</span><br><span class="line">    static void</span><br><span class="line">    popPageDebug(void *token, AutoreleasePoolPage *page, id *stop)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //出栈</span><br><span class="line">    static inline void</span><br><span class="line">    pop(void *token)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    static void init()&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //打印</span><br><span class="line">    __attribute__((noinline, cold))</span><br><span class="line">    void print()&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //打印所有</span><br><span class="line">    __attribute__((noinline, cold))</span><br><span class="line">    static void printAll()&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    //打印Hiwat</span><br><span class="line">    __attribute__((noinline, cold))</span><br><span class="line">    static void printHiwat()&#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li><p>从其定义中发现，<code>AutoreleasePoolPage</code> 是集成自 <code>AutoreleasePoolPageData</code>，且该类的属性也是来自父类，以下是 <code>AutoreleasePoolPage</code> 的定义：</p><ul><li>发现其中有 <code>AutoreleasePoolPage</code> 对象，所以有以下关系链 <code>AutoreleasePoolPage -&gt; AutoreleasePoolPageData -&gt; AutoreleasePoolPage</code>，从这里可以说明自动释放池除了是一个 <code>页</code> ，还是一个 <code>双向链表</code> 结构</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage;</span><br><span class="line">struct AutoreleasePoolPageData</span><br><span class="line">&#123;</span><br><span class="line">    // 用来校验AutoreleasePoolPage的结构是否完整</span><br><span class="line">    magic_t const magic;//16个字节</span><br><span class="line">    // 指向最新添加的autoreleased对象的下一个位置，初始化时指向begin()</span><br><span class="line">    __unsafe_unretained id *next;//8字节</span><br><span class="line">    // 指向当前线程</span><br><span class="line">    pthread_t const thread;//8字节</span><br><span class="line">    // 指向父节点，第一个结点的parent值为nil</span><br><span class="line">    AutoreleasePoolPage * const parent;//8字节</span><br><span class="line">    // 指向子节点，最后一个结点的child值为nil</span><br><span class="line">    AutoreleasePoolPage *child;//8字节</span><br><span class="line">    // 表示深度，从0开始，往后递增1</span><br><span class="line">    uint32_t const depth;//4字节</span><br><span class="line">    // 表示high water mark 最大入栈数量标记</span><br><span class="line">    uint32_t hiwat;//4字节</span><br><span class="line"></span><br><span class="line">    // 初始化</span><br><span class="line">    AutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat)</span><br><span class="line">        : magic(), next(_next), thread(_thread),</span><br><span class="line">          parent(_parent), child(nil),</span><br><span class="line">          depth(_depth), hiwat(_hiwat)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>AutoreleasePoolPageData</code> 结构体的内存大小为 <code>56</code> 字节：</p><ul><li><p>属性 <code>magic</code> 的类型是 <code>magic_t</code> 结构体，所占内存大小为 <code>m[4]</code>，所占内存（即<code>4*4=16</code>字节）</p></li><li><p>属性 <code>next</code>（指针）、<code>thread</code>（对象）、<code>parent</code>（对象）、<code>child</code>（对象）均占 <code>8</code> 字节（即<code>4*8=32</code>字节）</p></li><li><p>属性 <code>depth、hiwat</code> 类型为 <code>unit32_t</code>，实际类型是 <code>unsigned int</code> 类型，均占 <code>4</code> 字节（即<code>2*4=8</code>字节）</p></li></ul><h1 id="objc-autoreleasePoolPush-源码分析"><a href="#objc-autoreleasePoolPush-源码分析" class="headerlink" title="objc_autoreleasePoolPush 源码分析"></a>objc_autoreleasePoolPush 源码分析</h1><p>进入 <code>push</code> 源码实现，有以下逻辑</p><ul><li><p>判断是否为有 <code>pool</code></p><ul><li><p>如果没有，则通过 <code>autoreleaseNewPage</code> 方法创建</p></li><li><p>如果有，则通过 <code>autoreleaseFast</code> 压栈 <code>哨兵对象</code></p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 入栈</span><br><span class="line">static inline void *push() </span><br><span class="line">&#123;</span><br><span class="line">    id *dest;</span><br><span class="line">    // 判断是否有pool</span><br><span class="line">    if (slowpath(DebugPoolAllocation)) &#123;</span><br><span class="line">        // Each autorelease pool starts on a new pool page.自动释放池从新池页面开始</span><br><span class="line">        // 如果没有，则创建</span><br><span class="line">        dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 压栈一个POOL_BOUNDARY，即压栈哨兵</span><br><span class="line">        dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建页-autoreleaseNewPage"><a href="#创建页-autoreleaseNewPage" class="headerlink" title="创建页 autoreleaseNewPage"></a>创建页 autoreleaseNewPage</h2><ul><li><p>进入 <code>objc_autoreleasePoolPush -&gt; push -&gt; autoreleaseNewPage</code> 源码实现，主要是通过 <code>hotPage</code> 获取当前页，判断当前页是否存在</p><ul><li><p>如果存在，则通过 <code>autoreleaseFullPage</code> 方法 <code>压栈对象</code></p></li><li><p>如果不存在，则通过 <code>autoreleaseNoPage</code> 方法 <code>创建页</code></p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">//创建新页</span><br><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseNewPage(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    //获取当前操作页</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    //如果存在，则压栈对象</span><br><span class="line">    if (page) return autoreleaseFullPage(obj, page);</span><br><span class="line">    //如果不存在，则创建页</span><br><span class="line">    else return autoreleaseNoPage(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//******** hotPage方法 ********</span><br><span class="line">//获取当前操作页</span><br><span class="line">static inline AutoreleasePoolPage *hotPage() </span><br><span class="line">&#123;</span><br><span class="line">    //获取当前页</span><br><span class="line">    AutoreleasePoolPage *result = (AutoreleasePoolPage *)</span><br><span class="line">        tls_get_direct(key);</span><br><span class="line">    //如果是一个空池，则返回nil，否则，返回当前线程的自动释放池</span><br><span class="line">    if ((id *)result == EMPTY_POOL_PLACEHOLDER) return nil;</span><br><span class="line">    if (result) result-&gt;fastcheck();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//******** autoreleaseNoPage方法 ********</span><br><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseNoPage(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    // &quot;No page&quot; could mean no pool has been pushed</span><br><span class="line">    // or an empty placeholder pool has been pushed and has no contents yet</span><br><span class="line">    ASSERT(!hotPage());</span><br><span class="line"></span><br><span class="line">    bool pushExtraBoundary = false;</span><br><span class="line">    //判断是否是空占位符，如果是，则压栈哨兵标识符置为YES</span><br><span class="line">    if (haveEmptyPoolPlaceholder()) &#123;</span><br><span class="line">        // We are pushing a second pool over the empty placeholder pool</span><br><span class="line">        // or pushing the first object into the empty placeholder pool.</span><br><span class="line">        // Before doing that, push a pool boundary on behalf of the pool </span><br><span class="line">        // that is currently represented by the empty placeholder.</span><br><span class="line">        pushExtraBoundary = true;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果对象不是哨兵对象，且没有Pool，则报错</span><br><span class="line">    else if (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        // We are pushing an object with no pool in place, </span><br><span class="line">        // and no-pool debugging was requested by environment.</span><br><span class="line">        _objc_inform(&quot;MISSING POOLS: (%p) Object %p of class %s &quot;</span><br><span class="line">                     &quot;autoreleased with no pool in place - &quot;</span><br><span class="line">                     &quot;just leaking - break on &quot;</span><br><span class="line">                     &quot;objc_autoreleaseNoPool() to debug&quot;, </span><br><span class="line">                     objc_thread_self(), (void*)obj, object_getClassName(obj));</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果对象是哨兵对象，且没有申请自动释放池内存，则设置一个空占位符存储在tls中，其目的是为了节省内存</span><br><span class="line">    else if (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) &#123;//如果传入参数为哨兵</span><br><span class="line">        // We are pushing a pool with no pool in place,</span><br><span class="line">        // and alloc-per-pool debugging was not requested.</span><br><span class="line">        // Install and return the empty pool placeholder.</span><br><span class="line">        return setEmptyPoolPlaceholder();//设置空的占位符</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We are pushing an object or a non-placeholder&#x27;d pool.</span><br><span class="line"></span><br><span class="line">    // Install the first page.</span><br><span class="line">    //初始化第一页</span><br><span class="line">    AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);</span><br><span class="line">    //设置page为当前聚焦页</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    </span><br><span class="line">    // Push a boundary on behalf of the previously-placeholder&#x27;d pool.</span><br><span class="line">    //压栈哨兵的标识符为YES，则压栈哨兵对象</span><br><span class="line">    if (pushExtraBoundary) &#123;</span><br><span class="line">        //压栈哨兵</span><br><span class="line">        page-&gt;add(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Push the requested object or pool.</span><br><span class="line">    //压栈对象</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>autoreleaseNoPage</code> 方法中发现 <code>当前线程的自动释放池</code> 是通过 <code>AutoreleasePoolPage</code> 创建的，其定义中有 <code>构造方法</code>，而构造方法的实现是通过父类 <code>AutoreleasePoolPageData</code> 的初始化方法（从上面的定义中可以得知）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//**********AutoreleasePoolPage构造方法**********</span><br><span class="line">    AutoreleasePoolPage(AutoreleasePoolPage *newParent) :</span><br><span class="line">        AutoreleasePoolPageData(begin(),//开始存储的位置</span><br><span class="line">                                objc_thread_self(),//传的是当前线程，当前线程时通过tls获取的</span><br><span class="line">                                newParent,</span><br><span class="line">                                newParent ? 1+newParent-&gt;depth : 0,//如果是第一页深度为0，往后是前一个的深度+1</span><br><span class="line">                                newParent ? newParent-&gt;hiwat : 0)</span><br><span class="line">&#123; </span><br><span class="line">    if (parent) &#123;</span><br><span class="line">        parent-&gt;check();</span><br><span class="line">        ASSERT(!parent-&gt;child);</span><br><span class="line">        parent-&gt;unprotect();</span><br><span class="line">        //this 表示 新建页面，将当前页面的子节点 赋值为新建页面</span><br><span class="line">        parent-&gt;child = this;</span><br><span class="line">        parent-&gt;protect();</span><br><span class="line">    &#125;</span><br><span class="line">    protect();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//**********AutoreleasePoolPageData初始化方法**********</span><br><span class="line">AutoreleasePoolPageData(__unsafe_unretained id* _next, pthread_t _thread, AutoreleasePoolPage* _parent, uint32_t _depth, uint32_t _hiwat)</span><br><span class="line">        : magic(), next(_next), thread(_thread),</span><br><span class="line">          parent(_parent), child(nil),</span><br><span class="line">          depth(_depth), hiwat(_hiwat)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中 <code>AutoreleasePoolPageData</code> 方法传入的参数含义为：</p><ul><li><code>begin()</code> 表示 <code>压栈</code> 的位置（即下一个要释放对象的压栈地址）。可以通过源码调式 begin，发现其具体实现等于 <code>页首地址+56</code>，其中的 <code>56</code> 就是结构体 <code>AutoreleasePoolPageData</code> 的内存大小</li></ul><p><img src="/BboyZJ.github.io/assets/16504313207573.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//********begin()********</span><br><span class="line">//页的开始位置</span><br><span class="line">id * begin() &#123;</span><br><span class="line">    //等于 首地址+56（AutoreleasePoolPage类所占内存大小）</span><br><span class="line">    return (id *) ((uint8_t *)this+sizeof(*this));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>objc_thread_self()</code> 表示的是 <code>当前线程</code>，而当前线程时通过tls获取的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((const))</span><br><span class="line">static inline pthread_t objc_thread_self()</span><br><span class="line">&#123;</span><br><span class="line">    //通过tls获取当前线程</span><br><span class="line">    return (pthread_t)tls_get_direct(_PTHREAD_TSD_SLOT_PTHREAD_SELF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>newParent</code> 表示 <code>父节点</code></p></li><li><p>后续两个参数是 <code>通过父节点的深度、最大入栈个数</code> 计算 <code>depth</code> 以及 <code>hiwat</code></p></li></ul><h2 id="查看自动释放池内存结构"><a href="#查看自动释放池内存结构" class="headerlink" title="查看自动释放池内存结构"></a>查看自动释放池内存结构</h2><p>由于在ARC模式下，是无法手动调用 <code>autorelease</code>，所以将Demo切换至MRC模式（<code>Build Settings -&gt; Object-C Automatic Refrence Counting</code> 设置为 <code>NO</code>）</p><p><img src="/BboyZJ.github.io/assets/16504316576585.png"></p><ul><li>定义如下代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//************打印自动释放池结构************</span><br><span class="line">extern void _objc_autoreleasePoolPrint(void);</span><br><span class="line"></span><br><span class="line">//************运行代码************</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        //循环创建对象，并加入自动释放池</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">             NSObject *objc = [[NSObject alloc] sutorelease];</span><br><span class="line">        &#125;</span><br><span class="line">        //调用</span><br><span class="line">        _objc_autoreleasePoolPrint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，发现是6个，但是我们压栈的对象其实只有5个，其中的 <code>POOL</code> 表示 <code>哨兵</code>，即 <code>边界</code>，其目的是 <code>为了防止越界</code></p><p><img src="/BboyZJ.github.io/assets/16504317957435.jpg"></p><p>查看自动释放池的内存结构，发现，页的首地址与 <code>哨兵对象</code> 相差 <code>0x38</code>，转换成十进制刚好是 <code>56</code>，也就是 <code>AutoreleasePoolPage</code> 自己本身的内存大小</p><ul><li>将上述的测试代码的数据改为 <code>505</code>，其内存结构如下，发现第一页满了，存储了 <code>504</code> 个要释放的对象，第二页只存储了一个</li></ul><p><img src="/BboyZJ.github.io/assets/16504324748465.png"></p><ul><li>在将数据改为 <code>505+506</code>，来验证第二页是否也是存储了 <code>504</code> 个对象</li></ul><p><img src="/BboyZJ.github.io/assets/16504325130777.jpg"></p><p>通过运行发现，第一页存储 <code>504</code>，第二页存储 <code>505</code>，第三页存储 <code>2个</code></p><p><strong>结论</strong></p><p>所以通过上述测试，可以得出以下结论：</p><ul><li><p>第一页可以存放 <code>504</code> 个对象，且 <code>只有第一页有哨兵</code>，当第一页压栈满了，就会开辟新的一页</p></li><li><p>第二页开始，最多可以存放 <code>505</code> 个对象</p></li><li><p>一页的大小等于 <code>505 * 8 = 4040</code></p></li></ul><p>这个结论同样可以通过 <code>AutoreleasePoolPage</code> 中的 <code>SIZE</code> 来得到印证，从其定义中我们可以得出，一页的大小是 <code>4096</code> 字节，而在其构造函数中 <code>对象的压栈位置</code>，是从 <code>首地址+56</code> 开始的，所以可以一页中实际可以存储 <code>4096 - 56= 4040字节</code>，转换成对象时 <code>4040/8 = 505</code> 个，即一页最多可以 <code>存储505个对象</code>，其中 <code>第一页有哨兵对象</code>，只能存储 <code>504</code> 个对象，其结构图示如下：</p><p><img src="/BboyZJ.github.io/assets/16504377810811.png"></p><h2 id="面试题：哨兵在一个自动释放池有几个"><a href="#面试题：哨兵在一个自动释放池有几个" class="headerlink" title="面试题：哨兵在一个自动释放池有几个"></a>面试题：哨兵在一个自动释放池有几个</h2><ul><li><p>只有一个哨兵对象，且哨兵在第一页</p></li><li><p>第一页最多可存 <code>504</code> 个对象，第二页开始最多存 <code>505</code> 个</p></li></ul><h1 id="压栈对象-autoreleaseFast"><a href="#压栈对象-autoreleaseFast" class="headerlink" title="压栈对象 autoreleaseFast"></a>压栈对象 autoreleaseFast</h1><ul><li><p>进入 autoreleaseFast 源码，主要有以下几步：</p><ul><li><p>获取当前操作页，并判断页是否存在以及是否满了</p></li><li><p>如果 <code>页存在，且未满</code>，则通过 <code>add</code> 方法压栈对象</p></li><li><p>如果 <code>页存在，且满了</code>，则通过 <code>autoreleaseFullPage</code> 方法安排新的页</p></li><li><p>如果 <code>页不存在</code>，则通过 <code>autoreleaseNoPage</code> 方法创建新页</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> static inline id *autoreleaseFast(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    //获取当前操作页</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    //判断页是否满了</span><br><span class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        //如果未满，则压栈</span><br><span class="line">        return page-&gt;add(obj);</span><br><span class="line">    &#125; else if (page) &#123;</span><br><span class="line">        //如果满了，则安排新的页面</span><br><span class="line">        return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //页不存在，则新建页</span><br><span class="line">        return autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h2 id="autoreleaseFullPage-方法"><a href="#autoreleaseFullPage-方法" class="headerlink" title="autoreleaseFullPage 方法"></a>autoreleaseFullPage 方法</h2><p>这个方法主要是用于判断当前页是否已经存储满了，如果当前页已经满了，通过 <code>do-while循环</code> 查找 <code>子节点对应的页</code>，如果不存在，则 <code>新建页</code>，并 <code>压栈对象</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//添加自动释放对象，当页满的时候调用这个方法</span><br><span class="line">static __attribute__((noinline))</span><br><span class="line">id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)</span><br><span class="line">&#123;</span><br><span class="line">    // The hot page is full. </span><br><span class="line">    // Step to the next non-full page, adding a new page if necessary.</span><br><span class="line">    // Then add the object to that page.</span><br><span class="line">    ASSERT(page == hotPage());</span><br><span class="line">    ASSERT(page-&gt;full()  ||  DebugPoolAllocation);</span><br><span class="line">    </span><br><span class="line">    //do-while遍历循环查找界面是否满了</span><br><span class="line">    do &#123;</span><br><span class="line">        //如果子页面存在，则将页面替换为子页面</span><br><span class="line">        if (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        //如果子页面不存在，则新建页面</span><br><span class="line">        else page = new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; while (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    //设置为当前操作页面</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    //对象压栈</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>autoreleasePoolPage</code> 初始化方法中可以看出，主要是通过操作 <code>child</code> 对象，将 <code>当前页的child指向新建页面</code>，由此可以得出 <code>页是通过双向链表链接</code></p><h2 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h2><p>这个方法主要是 <code>添加释放对象</code>，其底层的实现时通过 <code>next</code> 指针存储释放对象，并将 next指针递增，表示下一个释放对象存储的位置，从这里可以看出 <code>页</code> 是通过 <code>栈结构存储</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//添加释放对象</span><br><span class="line">id *add(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!full());</span><br><span class="line">    unprotect();</span><br><span class="line">    //传入对象存储的位置</span><br><span class="line">    id *ret = next;  // faster than `return next-1` because of aliasing</span><br><span class="line">    //将obj压栈到next指针位置，然后next进行++，即下一个对象存储的位置</span><br><span class="line">    *next++ = obj;</span><br><span class="line">    protect();</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="autorelease底层分析"><a href="#autorelease底层分析" class="headerlink" title="autorelease底层分析"></a>autorelease底层分析</h1><p>在demo中，我们通过 <code>autorelease</code> 方法，在MRC模式下，将对象压栈到自动释放池，下面分析其底层实现</p><ul><li><p>查看 <code>autorelease</code> 方法源码</p><ul><li><p>如果不是对象 或者 是小对象，则直接返回</p></li><li><p>如果是对象，则调用对象的 <code>autorelease</code> 进行释放</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((aligned(16), flatten, noinline))</span><br><span class="line">id</span><br><span class="line">objc_autorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    //如果不是对象，则直接返回</span><br><span class="line">    if (!obj) return obj;</span><br><span class="line">    //如果是小对象，也直接返回</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return obj;</span><br><span class="line">    return obj-&gt;autorelease();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入对象的 autorelease 实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">👇</span><br><span class="line">inline id </span><br><span class="line">objc_object::autorelease()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    //判断是否是自定义类</span><br><span class="line">    if (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        return rootAutorelease();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ((id(*)(objc_object *, SEL))objc_msgSend)(this, @selector(autorelease));</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">inline id </span><br><span class="line">objc_object::rootAutorelease()</span><br><span class="line">&#123;</span><br><span class="line">    //如果是小对象，直接返回</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line">    if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this;</span><br><span class="line"></span><br><span class="line">    return rootAutorelease2();</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">__attribute__((noinline,used))</span><br><span class="line">id </span><br><span class="line">objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    return AutoreleasePoolPage::autorelease((id)this);</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">static inline id autorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line">    ASSERT(!obj-&gt;isTaggedPointer());</span><br><span class="line">    //autoreleaseFast 压栈操作</span><br><span class="line">    id *dest __unused = autoreleaseFast(obj);</span><br><span class="line">    ASSERT(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里看出，无论是 <code>压栈哨兵对象，还是普通对象</code>，都会来到 <code>autorelease</code> 方法，只是 <code>区别标识不同</code> 而已</p><h1 id="objc-autoreleasePoolPop-源码分析"><a href="#objc-autoreleasePoolPop-源码分析" class="headerlink" title="objc_autoreleasePoolPop 源码分析"></a>objc_autoreleasePoolPop 源码分析</h1><p>在 <code>objc_autoreleasePoolPop</code> 方法中有个参数，在clang分析时，发现传入的参数是 <code>push</code> 压栈后返回的哨兵对象，即 <code>ctxt</code>，其目的是 <code>避免出栈混乱，防止将别的对象出栈</code></p><ul><li><p>进入 <code>pop</code> 源码实现，主要有以下几步</p><ul><li><p>空页面的处理，并 根据token获取page</p></li><li><p>容错处理</p></li><li><p>通过 popPage 出栈页</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//出栈</span><br><span class="line">static inline void</span><br><span class="line">pop(void *token)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line">   //判断对象是否是空占位符</span><br><span class="line">    if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        //如果当是空占位符</span><br><span class="line">        // Popping the top-level placeholder pool.</span><br><span class="line">        //获取当前页</span><br><span class="line">        page = hotPage();</span><br><span class="line">        if (!page) &#123;</span><br><span class="line">            // Pool was never used. Clear the placeholder.</span><br><span class="line">            //如果当前页不存在，则清除空占位符</span><br><span class="line">            return setHotPage(nil);</span><br><span class="line">        &#125;</span><br><span class="line">        // Pool was used. Pop its contents normally.</span><br><span class="line">        // Pool pages remain allocated for re-use as usual.</span><br><span class="line">        //如果当前页存在，则将当前页设置为coldPage,token设置为coldPage的开始位置</span><br><span class="line">        page = coldPage();</span><br><span class="line">        token = page-&gt;begin();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //获取token所在的页</span><br><span class="line">        page = pageForPointer(token);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    //判断最后一个位置，是否是哨兵</span><br><span class="line">    if (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">        //最后一个位置不是哨兵，即最后一个位置是一个对象</span><br><span class="line">        if (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            //如果是第一个位置，且没有父节点，什么也不做</span><br><span class="line">            // Start of coldest page may correctly not be POOL_BOUNDARY:</span><br><span class="line">            // 1. top-level pool is popped, leaving the cold page in place</span><br><span class="line">            // 2. an object is autoreleased with no pool</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果是第一个位置，且有父节点，则出现了混乱</span><br><span class="line">            // Error. For bincompat purposes this is not </span><br><span class="line">            // fatal in executables built with old SDKs.</span><br><span class="line">            return badPop(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) &#123;</span><br><span class="line">        return popPageDebug(token, page, stop);</span><br><span class="line">    &#125;</span><br><span class="line">    //出栈页</span><br><span class="line">    return popPage&lt;false&gt;(token, page, stop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入 <code>popPage</code> 源码，其中传入的 <code>allowDebug</code> 为false，则通过 <code>releaseUntil</code> 出栈当前页 <code>stop</code> 位置之前的所有对象，即出栈中的对象 <code>发送release消息</code>，直到遇到传入的 <code>哨兵对象</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//出栈页面</span><br><span class="line">template&lt;bool allowDebug&gt;</span><br><span class="line">    static void</span><br><span class="line">    popPage(void *token, AutoreleasePoolPage *page, id *stop)</span><br><span class="line">&#123;</span><br><span class="line">    if (allowDebug &amp;&amp; PrintPoolHiwat) printHiwat();</span><br><span class="line">    //出栈当前操作页面对象</span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    // memory: delete empty children 删除空子项</span><br><span class="line">    if (allowDebug &amp;&amp; DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        // special case: delete everything during page-per-pool debugging</span><br><span class="line">        //调试期间删除每个特殊情况下的所有池</span><br><span class="line">        //获取当前页面的父节点</span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        //将当前页面杀掉</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        //设置操作页面为父节点页面</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (allowDebug &amp;&amp; DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        // special case: delete everything for pop(top)</span><br><span class="line">        // when debugging missing autorelease pools</span><br><span class="line">        //特殊情况：调试丢失的自动释放池时删除pop（top）的所有内容</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (page-&gt;child) &#123;</span><br><span class="line">        // hysteresis: keep one empty child if page is more than half full 如果页面已满一半以上，则保留一个空子级</span><br><span class="line">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>进入 <code>releaseUntil</code> 实现，主要是通过 <code>循环遍历</code>，判断对象是否等于stop，其目的是    释放stop之前的所有的对象</p><ul><li><p>首先通过 <code>获取page的next释放对象（即page的最后一个对象）</code>，并对 <code>next</code> 进行 <code>递减</code>，获取 <code>上一个对象</code></p></li><li><p>判断 <code>是否哨兵对象</code>，如果不是则自动调用 <code>objc_release</code> 释放</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//释放到stop位置之前的所有对象</span><br><span class="line">void releaseUntil(id *stop) </span><br><span class="line">&#123;</span><br><span class="line">    // Not recursive: we don&#x27;t want to blow out the stack  不是递归的：我们不想破坏堆栈</span><br><span class="line">    // if a thread accumulates a stupendous amount of garbage</span><br><span class="line">    //判断下一个对象是否等于stop，如果不等于，则进入while循环</span><br><span class="line">    while (this-&gt;next != stop) &#123;</span><br><span class="line">        // Restart from hotPage() every time, in case -release </span><br><span class="line">        // autoreleased more objects 每次从hotPage（）重新启动，以防-release自动释放更多对象</span><br><span class="line">        //获取当前操作页面，即hot页面</span><br><span class="line">        AutoreleasePoolPage *page = hotPage();</span><br><span class="line"></span><br><span class="line">        // fixme I think this `while` can be `if`, but I can&#x27;t prove it</span><br><span class="line">        //如果当前页是空的</span><br><span class="line">        while (page-&gt;empty()) &#123;</span><br><span class="line">            //将page赋值为父节点页</span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            //并设置当前页为父节点页</span><br><span class="line">            setHotPage(page);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page-&gt;unprotect();</span><br><span class="line">        //next进行--操作，即出栈</span><br><span class="line">        id obj = *--page-&gt;next;</span><br><span class="line">        //将页索引位置置为SCRIBBLE，表示已经被释放</span><br><span class="line">        memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));</span><br><span class="line">        page-&gt;protect();</span><br><span class="line"></span><br><span class="line">        if (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">            //释放</span><br><span class="line">            objc_release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置当前页</span><br><span class="line">    setHotPage(this);</span><br><span class="line"></span><br><span class="line">#if DEBUG</span><br><span class="line">    // we expect any children to be completely empty</span><br><span class="line">    for (AutoreleasePoolPage *page = child; page; page = page-&gt;child) &#123;</span><br><span class="line">        ASSERT(page-&gt;empty());</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入 <code>kill</code> 实现，主要是销毁当前页，将 <code>当前页赋值为父节点页</code>，并将 <code>父节点页的child对象指针置为nil</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//销毁</span><br><span class="line">void kill() </span><br><span class="line">&#123;</span><br><span class="line">    // Not recursive: we don&#x27;t want to blow out the stack </span><br><span class="line">    // if a thread accumulates a stupendous amount of garbage</span><br><span class="line">    AutoreleasePoolPage *page = this;</span><br><span class="line">    //获取最后一个页</span><br><span class="line">    while (page-&gt;child) page = page-&gt;child;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage *deathptr;</span><br><span class="line">    do &#123;</span><br><span class="line">        deathptr = page;</span><br><span class="line">        //子节点 变成 父节点</span><br><span class="line">        page = page-&gt;parent;</span><br><span class="line">        if (page) &#123;</span><br><span class="line">            page-&gt;unprotect();</span><br><span class="line">            //子节点为nil</span><br><span class="line">            page-&gt;child = nil;</span><br><span class="line">            page-&gt;protect();</span><br><span class="line">        &#125;</span><br><span class="line">        delete deathptr;</span><br><span class="line">    &#125; while (deathptr != this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>通过上面的分析，针对自动释放池的push和pop，总结如下：</p><ul><li><p>在自动释放池的 压栈（即push）操作中</p><ul><li>当没有pool，即只有空占位符（存储在tls中）时，则创建页，压栈哨兵对象</li><li>在页中 压栈普通对象 主要是通过 next 指针 递增 进行的</li><li>当 页满 了时，需要设置页的 child 对象为 新建页</li></ul></li></ul><p>所以，综上所述，autorelease 和 objc_autoreleasePush 的整体底层的流程如下图所示</p><p><img src="/BboyZJ.github.io/assets/16504439133624.png"></p><ul><li><p>在自动释放池的 <code>出栈（即 pop</code>）操作中</p><ul><li>在页中 <code>出栈普通对象</code> 主要是通过 <code>next</code> 指针 <code>递减</code> 进行的</li><li>当 <code>页空</code> 了时，需要赋值页的 <code>parent</code> 对象为 <code>当前页</code></li></ul></li></ul><p>综上所述，<code>objc_autoreleasePoolPop</code> 出栈的流程如下所示</p><p><img src="/BboyZJ.github.io/assets/16504440127961.png"></p><h1 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h1><p>对于Runloop，主要关心的点有以下几个</p><ul><li><p>runoop是什么？</p></li><li><p>runloop和线程是什么关系？</p></li><li><p>runloop是什么时候创建的？</p></li></ul><h2 id="Runloop介绍"><a href="#Runloop介绍" class="headerlink" title="Runloop介绍"></a>Runloop介绍</h2><p><code>Runloop</code> 是时间接收和分发机制的一个实现，是线程相关的基础框架的一部分，一个<code>Runloop就是一个时间处理的循环</code>，用来不停的调度工作以及处理输入事件。</p><p><code>Runloop</code> 本质是一个 <code>do-while循环</code>，没事做就休息，来活了就干活。与普通的 <code>while</code> 循环时有区别的，普通的 <code>while循环</code> 会导致CPU进入 <code>忙等待状态</code>，即一直消耗cpu，而Runloop则不会，Runloop是一种 <code>闲等待</code>，即Runloop具备 <code>休眠功能</code>。</p><h2 id="Runloop的作用"><a href="#Runloop的作用" class="headerlink" title="Runloop的作用"></a>Runloop的作用</h2><ul><li><p>保持程序的持续运行</p></li><li><p>处理APP中的各种事件（触摸、定时器、performSelector（一种方法的调用方式））</p></li><li><p>节省CPU资源，提高程序的性能，该做事就做事，该休息就休息</p></li></ul><h1 id="Runloop源码分析"><a href="#Runloop源码分析" class="headerlink" title="Runloop源码分析"></a>Runloop源码分析</h1><p>Runloop源码的<a href="https://opensource.apple.com/tarballs/CF/">下载地址</a>，在其中找到最新版本下载即可</p><h2 id="Runloop和线程的关系"><a href="#Runloop和线程的关系" class="headerlink" title="Runloop和线程的关系"></a>Runloop和线程的关系</h2><p>一般在日常开发中，对于 <code>Runloop的获取</code> 主要有以下两种方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 主运行循环</span><br><span class="line">CFRunLoopRef mainRunloop = CFRunLoopGetMain();</span><br><span class="line">// 当前运行循环</span><br><span class="line">CFRunLoopRef currentRunloop = CFRunLoopGetCurrent();</span><br></pre></td></tr></table></figure><ul><li>进入 <code>CFRunLoopGetMain</code> 源码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    static CFRunLoopRef __main = NULL; // no retain needed</span><br><span class="line">    // pthread_main_thread_np 主线程</span><br><span class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</span><br><span class="line">    return __main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入 <code>_CFRunLoopGet0</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// should only be called by Foundation</span><br><span class="line">// t==0 is a synonym for &quot;main thread&quot; that always works</span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    //如果t不存在，则标记为主线程（即默认情况，默认是主线程）</span><br><span class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    if (!__CFRunLoops) &#123;</span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">        </span><br><span class="line">        //创建全局字典，标记为kCFAllocatorSystemDefault</span><br><span class="line">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        //通过主线程 创建主运行循环</span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        //利用dict，进行key-value绑定操作，即可以说明，线程和runloop是一一对应的</span><br><span class="line">        // dict : key value</span><br><span class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">        </span><br><span class="line">        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">            CFRelease(dict);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        CFRelease(mainLoop);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    //通过其他线程获取runloop</span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        //如果没有获取到，则新建一个运行循环</span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">        if (!loop) &#123;</span><br><span class="line">            //将新建的runloop 与 线程进行key-value绑定</span><br><span class="line">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">            loop = newLoop;</span><br><span class="line">        &#125;</span><br><span class="line">        // don&#x27;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">        CFRelease(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    if (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</span><br><span class="line">        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以说明，<code>Runloop</code> 只有 <code>两种</code>，一种是 <code>主线程的</code>，一种是 <code>其他线程的</code>。即<code>Runloop和线程是一一对应的</code></p><h2 id="Runloop的创建"><a href="#Runloop的创建" class="headerlink" title="Runloop的创建"></a>Runloop的创建</h2><ul><li>进入 <code>__CFRunLoopCreate</code> 源码，其中主要是对runloop属性的赋值操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static CFRunLoopRef __CFRunLoopCreate(pthread_t t) &#123;</span><br><span class="line">    CFRunLoopRef loop = NULL;</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    uint32_t size = sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase);</span><br><span class="line">    loop = (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopTypeID, size, NULL);</span><br><span class="line">    //如果loop为空，则直接返回NULL</span><br><span class="line">    if (NULL == loop) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    //runloop属性配置</span><br><span class="line">    (void)__CFRunLoopPushPerRunData(loop);</span><br><span class="line">    __CFRunLoopLockInit(&amp;loop-&gt;_lock);</span><br><span class="line">    loop-&gt;_wakeUpPort = __CFPortAllocate();</span><br><span class="line">    if (CFPORT_NULL == loop-&gt;_wakeUpPort) HALT;</span><br><span class="line">    __CFRunLoopSetIgnoreWakeUps(loop);</span><br><span class="line">    loop-&gt;_commonModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode);</span><br><span class="line">    loop-&gt;_commonModeItems = NULL;</span><br><span class="line">    loop-&gt;_currentMode = NULL;</span><br><span class="line">    loop-&gt;_modes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    loop-&gt;_blocks_head = NULL;</span><br><span class="line">    loop-&gt;_blocks_tail = NULL;</span><br><span class="line">    loop-&gt;_counterpart = NULL;</span><br><span class="line">    loop-&gt;_pthread = t;</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">    loop-&gt;_winthread = GetCurrentThreadId();</span><br><span class="line">#else</span><br><span class="line">    loop-&gt;_winthread = 0;</span><br><span class="line">#endif</span><br><span class="line">    rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);</span><br><span class="line">    if (NULL != rlm) __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入 <code>CFRunLoopRef</code> 的定义，根据定义得知，其实 <code>RunLoop也是一个对象</code>。是 <code>__CFRunLoop</code> 结构体的 <code>指针类型</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __CFRunLoop * CFRunLoopRef;</span><br><span class="line">👇</span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;            /* locked for accessing mode list */</span><br><span class="line">    __CFPort _wakeUpPort;            // used for CFRunLoopWakeUp</span><br><span class="line">    Boolean _unused;</span><br><span class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    uint32_t _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    struct _block_item *_blocks_head;</span><br><span class="line">    struct _block_item *_blocks_tail;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从定义中可以得出，<code>一个RunLoop依赖于多个Mode</code>，意味着一个RunLoop需要处理多个事务，即 <code>一个Mode对应多个item</code>，而一个item包含了 <code>timer、source、observer</code>，如下图所示：</p><p><img src="/BboyZJ.github.io/assets/16505035096425.png"></p><h2 id="Mode类型"><a href="#Mode类型" class="headerlink" title="Mode类型"></a>Mode类型</h2><p>其中 <code>mode</code> 在苹果文档中提及的有五个，而在iOS中公开暴露出来的只有 <code>NSDefaultRunLoopMode</code> 和 <code>NSRunLoopCommonModes</code>。<code>NSRunLoopCommonModes</code> 实际上是一个 <code>Mode</code> 的集合，默认包括 <code>NSDefaultRunLoopMode</code> 和 <code>NSEventTrackingRunLoopMode</code></p><ul><li><p><code>NSDefaultRunLoopMode</code>：默认的 <code>mode</code>，正常情况下都是在这个mode</p></li><li><p><code>NSConnectionReplyMode</code></p></li><li><p><code>NSModalPanelRunLoopMode</code></p></li><li><p><code>NSEventTrackingRunLoopMode</code>：使用这个mode去跟踪来自用户交互的事件（比如UITableView上下滑动）</p></li><li><p><code>NSRunLoopCommonModes</code>：伪模式，灵活性更好</p></li></ul><h2 id="Source-amp-Timer-amp-Observer"><a href="#Source-amp-Timer-amp-Observer" class="headerlink" title="Source &amp; Timer &amp; Observer"></a>Source &amp; Timer &amp; Observer</h2><ul><li><p><code>source</code>： 表示可以 <code>唤醒runloop的一些事件</code>，例如用户点击了屏幕，就会创建一个runloop，主要分为 <code>source0</code> 和 <code>source1</code></p><ul><li><code>source0</code> 表示 <code>非系统事件</code>，即用户自定义的事件</li><li><code>source1</code> 表示 <code>系统事件</code>，主要负责底层的通讯，具备唤醒能力</li></ul></li><li><p><code>timer</code>： 就是常用的 <code>NSTimer</code> 定时器一类</p></li><li><p><code>observer</code>：主要用于监听runloop的状态变化，并作出一定响应，主要有以下一些状态</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    //进入RunLoop</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),</span><br><span class="line">    //即将处理Timers</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</span><br><span class="line">    //即将处理Source</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</span><br><span class="line">    //即将进入休眠</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</span><br><span class="line">    //被唤醒</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</span><br><span class="line">    //退出RunLoop</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="验证：runloop和mode是一对多"><a href="#验证：runloop和mode是一对多" class="headerlink" title="验证：runloop和mode是一对多"></a>验证：runloop和mode是一对多</h2><p>下面，通过上面的代码调式来验证我们上面提及的关系</p><ul><li><p>通过lldb命令获取 <code>mainRunLoop、currentRunLoop</code> 的 <code>currentMode</code></p><ul><li>po CFRunLoopCopyCurrentMode(mainRunloop)</li><li>po CFRunLoopCopyCurrentMode(currentRunloop)</li></ul></li></ul><p><img src="/BboyZJ.github.io/assets/16505046382407.jpg"></p><p>从这里，可以说明，runloop在运行时的mode只有一个</p><ul><li>获取 <code>mainRunloop</code> 的所有模型，即 <code>po CFRunLoopCopyAllModes(mainRunloop)</code></li></ul><p><img src="/BboyZJ.github.io/assets/16505047055014.jpg"></p><p>从结果可以验证 <code>runloop</code> 和 <code>CFRunloopMode</code> 具有 <code>一对多</code> 的关系</p><h2 id="验证：mode和item也是一对多"><a href="#验证：mode和item也是一对多" class="headerlink" title="验证：mode和item也是一对多"></a>验证：mode和item也是一对多</h2><ul><li>在上述代码中，加断点，通过bt查看堆栈信息，从这里看出timer的item类型如下所示：</li></ul><p><img src="/BboyZJ.github.io/assets/16505050509921.jpg"></p><ul><li><p>在 <code>runloop</code> 源码中查看 <code>item</code> 类型，有以下几种</p><ul><li><p>block应用：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK</strong></p></li><li><p>调用timer：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong></p></li><li><p>响应source0：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong></p></li><li><p>响应source1：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</strong></p></li><li><p>GCD主队列：<strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong></p></li><li><p>observer：<strong>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</strong></p></li></ul><p>  <img src="/BboyZJ.github.io/assets/16505052599469.jpg"></p></li><li><p>在这里以 <code>timer</code> 为例，一般初始化timer时，都会将timer通过 <code>addTimer:forMode:</code> 方法添加到runloop中，于是在源码中查找 <code>addTimer</code> 的相关方法，即 <code>CFRunLoopAddTimer</code> 方法，其源码实现如下，其实现主要判断是否是 <code>kCFRunLoopCommonModes</code> ，然后查找runloop的mode进行匹配处理</p><ul><li><p>其中 <code>kCFRunLoopCommonModes</code> 不是一种模式，是一种抽象的 <code>伪模式</code> ，比 <code>defaultMode</code> 更加灵活</p></li><li><p>通过 <code>CFSetAddValue(rl-&gt;_commonModeItems, rlt);</code> 可以得知，<code>runloop</code> 与 <code>mode</code> 是 <code>一对多</code> 的，同时可以得出 <code>mode</code> 与 <code>item</code> 也是 <code>一对多</code> 的</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return;</span><br><span class="line">    if (!__CFIsValid(rlt) || (NULL != rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop != rl)) return;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    </span><br><span class="line">    // 重点 : kCFRunLoopCommonModes</span><br><span class="line">    if (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">        //如果是kCFRunLoopCommonModes 类型</span><br><span class="line">       </span><br><span class="line">        CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</span><br><span class="line">        </span><br><span class="line">        if (NULL == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">            rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        &#125;</span><br><span class="line">        //runloop与mode 是一对多的， mode与item也是一对多的</span><br><span class="line">        CFSetAddValue(rl-&gt;_commonModeItems, rlt);</span><br><span class="line">        if (NULL != set) &#123;</span><br><span class="line">            CFTypeRef context[2] = &#123;rl, rlt&#125;;</span><br><span class="line">            /* add new item to all common-modes */</span><br><span class="line">            //执行</span><br><span class="line">            CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (void *)context);</span><br><span class="line">            CFRelease(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //如果是非commonMode类型</span><br><span class="line">        //查找runloop的模型</span><br><span class="line">        CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);</span><br><span class="line">        if (NULL != rlm) &#123;</span><br><span class="line">            if (NULL == rlm-&gt;_timers) &#123;</span><br><span class="line">                CFArrayCallBacks cb = kCFTypeArrayCallBacks;</span><br><span class="line">                cb.equal = NULL;</span><br><span class="line">                rlm-&gt;_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;cb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断mode是否匹配</span><br><span class="line">        if (NULL != rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) &#123;</span><br><span class="line">            __CFRunLoopTimerLock(rlt);</span><br><span class="line">            if (NULL == rlt-&gt;_runLoop) &#123;</span><br><span class="line">                rlt-&gt;_runLoop = rl;</span><br><span class="line">            &#125; else if (rl != rlt-&gt;_runLoop) &#123;</span><br><span class="line">                __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">                __CFRunLoopModeUnlock(rlm);</span><br><span class="line">                __CFRunLoopUnlock(rl);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果匹配，则将runloop加进去，而runloop的执行依赖于  [runloop run]</span><br><span class="line">            CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name);</span><br><span class="line">            __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">            __CFRunLoopTimerFireTSRLock();</span><br><span class="line">            __CFRepositionTimerInMode(rlm, rlt, false);</span><br><span class="line">            __CFRunLoopTimerFireTSRUnlock();</span><br><span class="line">            if (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) &#123;</span><br><span class="line">                // Normally we don&#x27;t do this on behalf of clients, but for</span><br><span class="line">                // backwards compatibility due to the change in timer handling...</span><br><span class="line">                if (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (NULL != rlm) &#123;</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RunLoop执行"><a href="#RunLoop执行" class="headerlink" title="RunLoop执行"></a>RunLoop执行</h2><p>众所周知，runloop的执行依赖于 <code>run</code> 方法，从下面的堆栈信息中可以看出，其底层执行的是 <code>__CFRunLoopRun</code> 方法</p><p><img src="/BboyZJ.github.io/assets/16505067486223.png"></p><ul><li><p>进入 __CFRunLoopRun 源码，针对不同的对象，有不同的处理</p><ul><li><p>如果有 observer，则调用 __CFRunLoopDoOnservers</p></li><li><p>如果有 block，则调用 __CFRunLoopDoBlocks</p></li><li><p>如果有 timer，则调用 __CFRunLoopDoTimers</p></li><li><p>如果是 source0，则调用 __CFRunLoopDoSources0</p></li><li><p>如果是 source1，则调用 __CFRunLoopDoSources1</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/* rl, rlm are locked on entrance and exit */</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    do&#123;</span><br><span class="line">        ...</span><br><span class="line">         //通知 Observers: 即将处理timer事件</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        //通知 Observers: 即将处理Source事件</span><br><span class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        //处理Blocks</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        //处理sources0</span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        //处理sources0返回为YES</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            // 处理Blocks</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        //如果是timer</span><br><span class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                // Re-arm the next timer, because we apparently fired early</span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        //如果是source1</span><br><span class="line">        CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">        if (rls) &#123;</span><br><span class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">            mach_msg_header_t *reply = NULL;</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">            if (NULL != reply) &#123;</span><br><span class="line">                (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</span><br><span class="line">                CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">            &#125;</span><br><span class="line">#elif DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    &#125;while (0 == retVal);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入 __CFRunLoopDoTimers 源码，主要是通过for循环，对单个timer进行处理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) &#123;    /* DOES CALLOUT */</span><br><span class="line">    ...</span><br><span class="line">    //循环遍历，做下层单个timer的执行</span><br><span class="line">    for (CFIndex idx = 0, cnt = timers ? CFArrayGetCount(timers) : 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx);</span><br><span class="line">        Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt);</span><br><span class="line">        timerHandled = timerHandled || did;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入 <code>__CFRunLoopDoTimer</code> 源码，主要逻辑是 <code>timer</code> 执行完毕后，会主动调用 <code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</code> 函数，正好与timer堆栈调用的一致</li></ul><p><img src="/BboyZJ.github.io/assets/16505069926108.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// mode and rl are locked on entry and exit</span><br><span class="line">static Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt) &#123; </span><br><span class="line">    ...</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-&gt;_callout, rlt, context_info);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="timer执行总结"><a href="#timer执行总结" class="headerlink" title="timer执行总结"></a>timer执行总结</h2><ul><li><p>为自定义的timer，设置mode，并将其加入 runloop 中</p></li><li><p>在runloop的 run 方法执行时，会调用 __CFRunLoopDoTimers 执行所有的timer</p></li><li><p>在 __CFRunLoopDoTimers 方法中，会通过for循环执行单个timer的操作</p></li><li><p>在 __CFRunLoopDoTimer 方法中，timer执行完毕后，会执行对应的timer回调函数</p></li></ul><p>以上，是针对 <code>timer</code> 的执行分析，对于 <code>observer、block、source0、source1</code>，其执行原理与timer是类似的，这里就不再重复说明，一下是 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">苹果官方文档</a> 针对runloop处理不同源的图示：</p><p><img src="/BboyZJ.github.io/assets/16505072624441.jpg"></p><h2 id="RunLoop底层管理"><a href="#RunLoop底层管理" class="headerlink" title="RunLoop底层管理"></a>RunLoop底层管理</h2><p>从上述的堆栈信息中可以看出，run在底层的实现路径为 <code>CFRunLoopRun -&gt; CFRunLoopRun -&gt; __CFRunLoopRun</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopRun(void) &#123;    /* DOES CALLOUT */</span><br><span class="line">    int32_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        // 1.0e10 : 科学技术 1*10^10</span><br><span class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>进入 <code>CFRunLoopRunSpecific</code> 源码，，首先根据modeName找到对应的mode，然后主要分为三种情况：</p><ul><li><p>如果是 <code>entry</code>，则通知observer，即将 <code>进入runloop</code></p></li><li><p>如果是 <code>exit</code>，则通过observer，即将 <code>退出runloop</code></p></li><li><p>如果是其他中间状态，主要是通过runloop处理各种源</p></li></ul></li></ul><p>其伪代码表示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    </span><br><span class="line">    //首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);</span><br><span class="line">    </span><br><span class="line">    // 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    // 内部函数，进入loop</span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    // 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入 <code>__CFRunLoopRun</code> 源码，由于这部分代码较多，于是这里用伪代码代替。其主要逻辑是 <code>根据不同的事件源进行不同的处理</code>，当RunLoop休眠时，可以通过相应的事件唤醒RunLoop</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">//核心函数</span><br><span class="line">/* rl, rlm are locked on entrance and exit */</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode)&#123;</span><br><span class="line">    </span><br><span class="line">    //通过GCD开启一个定时器，然后开始跑圈</span><br><span class="line">    dispatch_source_t timeout_timer = NULL;</span><br><span class="line">    ...</span><br><span class="line">    dispatch_resume(timeout_timer);</span><br><span class="line">    </span><br><span class="line">    int32_t retVal = 0;</span><br><span class="line">    </span><br><span class="line">    //处理事务,即处理items</span><br><span class="line">    do &#123;</span><br><span class="line">        </span><br><span class="line">        // 通知 Observers: 即将处理timer事件</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        </span><br><span class="line">        // 通知 Observers: 即将处理Source事件</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources)</span><br><span class="line">        </span><br><span class="line">        // 处理Blocks</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        // 处理sources0</span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        </span><br><span class="line">        // 处理sources0返回为YES</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            // 处理Blocks</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 判断有无端口消息(Source1)</span><br><span class="line">        if (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) &#123;</span><br><span class="line">            // 处理消息</span><br><span class="line">            goto handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        // 通知 Observers: 即将进入休眠</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        // 等待被唤醒</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</span><br><span class="line">        </span><br><span class="line">        // user callouts now OK again</span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        // 通知 Observers: 被唤醒，结束休眠</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    handle_msg:</span><br><span class="line">        if (被timer唤醒) &#123;</span><br><span class="line">            // 处理Timers</span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time())；</span><br><span class="line">        &#125;else if (被GCD唤醒)&#123;</span><br><span class="line">            // 处理gcd</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125;else if (被source1唤醒)&#123;</span><br><span class="line">            // 被Source1唤醒，处理Source1</span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 处理block</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;//处理源</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;//超时</span><br><span class="line">        &#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal = kCFRunLoopRunStopped;//停止</span><br><span class="line">        &#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped = false;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;//停止</span><br><span class="line">        &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunFinished;//结束</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;while (0 == retVal);</span><br><span class="line">    </span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，综上所述，RunLoop的执行流程，如下所示：</p><p><img src="/BboyZJ.github.io/assets/16505074680640.png"></p><h1 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h1><h2 id="AutoreleasePool相关"><a href="#AutoreleasePool相关" class="headerlink" title="AutoreleasePool相关"></a>AutoreleasePool相关</h2><h3 id="面试题1：临时变量什么时候释放"><a href="#面试题1：临时变量什么时候释放" class="headerlink" title="面试题1：临时变量什么时候释放"></a>面试题1：临时变量什么时候释放</h3><ul><li><p>如果在 <code>正常情况下</code>，一般是 <code>超出作用域就会立即释放</code></p></li><li><p>如果将临时变量加入了 <code>自动释放池</code>，会延迟释放，即在 <code>runloop休眠/超出autoreleasePool作用域之后会释放</code></p></li></ul><h3 id="面试题2：AutoreleasePool原理"><a href="#面试题2：AutoreleasePool原理" class="headerlink" title="面试题2：AutoreleasePool原理"></a>面试题2：AutoreleasePool原理</h3><ul><li><p>自动释放池的本质是一个 <code>autoreleasePoolPage结构体对象</code>，是一个 <code>栈结构存储的页</code>，每一个 <code>autoreleasePoolPage</code> 都是以 <code>双向链表</code> 的形式链接</p></li><li><p>自动释放池的 <code>压栈</code> 和 <code>出栈</code> 主要是通过结构体的 <code>构造函数</code> 和 <code>析构函数</code> 调用底层的 <code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code>，实际上调用的是 <code>autoreleasePoolPage</code> 的 <code>push</code> 和 <code>pop</code> 两个方法</p></li><li><p>每次调用 <code>push</code> 操作其实就是创建一个新的 <code>autoreleasePoolPage</code>，而 <code>autoreleasePoolPage</code> 的具体操作就是插入一个 <code>POOL_BOUNDARY</code>,并返回插入 <code>POOL_BOUNDARY</code> 的内存地址。而 <code>push</code> 内部调用 <code>autoreleaseFast</code> 方法处理，主要有以下三种情况</p><ul><li><p>当 <code>page存在且不满</code> 时，调用add方法将对象添加至page的next指针处，并next递增</p></li><li><p>当 <code>page存在且已满</code> 时，调用 <code>autoreleaseFullPage</code> 初始化一个新的page，然后调用add方法将对象添加至page栈中</p></li><li><p>当 <code>page不存在</code> 时，调用 <code>autoreleaseNoPage</code> 创建一个hotPage，然后调用add方法将对象添加至page栈中</p></li></ul></li><li><p>当执行 <code>pop</code> 时，会传入一个值，这个值就是push操作的返回值，即 <code>POOL_BOUNDARY</code> 的内存地址 <code>token</code>，所以pop内部的实现就是根据token找到哨兵对象所处的page中，然后使用 <code>objc_release</code> 释放token之前的对象，并把next指针指到正确的位置</p></li></ul><h3 id="面试题3：autoreleasePool能否嵌套使用？"><a href="#面试题3：autoreleasePool能否嵌套使用？" class="headerlink" title="面试题3：autoreleasePool能否嵌套使用？"></a>面试题3：autoreleasePool能否嵌套使用？</h3><ul><li><p>可以嵌套使用，其目的是可以 控制应用程序的内存峰值，使其不要太高</p></li><li><p>可以嵌套的原因是因为自动释放池是以栈为节点，通过双向链表的形式链接的，且是和线程一一对应的</p></li><li><p>自动释放池的 多层嵌套 其实就是不停的 push哨兵对象，在pop时，会先释放里面的，在释放外面的</p></li></ul><h3 id="面试题4：哪些对象可以加入autoreleasePool？alloc创建可以吗？"><a href="#面试题4：哪些对象可以加入autoreleasePool？alloc创建可以吗？" class="headerlink" title="面试题4：哪些对象可以加入autoreleasePool？alloc创建可以吗？"></a>面试题4：哪些对象可以加入autoreleasePool？alloc创建可以吗？</h3><ul><li><p>使用 <code>alloc、new、copy</code> 关键字生成的对象和 <code>retain</code> 了的对象 <code>需要手动释放</code>，不会被添加到自动释放池</p></li><li><p>设置为 <code>autorelease</code> 的对象 不需要手动释放，会直接进入自动释放池</p></li><li><p>所有 <code>autorelease</code> 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中</p></li></ul><h3 id="面试题5：autoreleasePool的释放实际是什么时候？"><a href="#面试题5：autoreleasePool的释放实际是什么时候？" class="headerlink" title="面试题5：autoreleasePool的释放实际是什么时候？"></a>面试题5：autoreleasePool的释放实际是什么时候？</h3><ul><li><p>APP启动后，苹果主线程 <code>runloop</code> 里面注册了两个 <code>observer</code>，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p></li><li><p>第一个 <code>observer</code> 监视的事件是 <code>Entry</code>（即将键入loop），其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池，其 order 是 -2147483647，优先级最高，保证创建释放池发生在其他所有回调之前</p></li><li><p>第二个 <code>observer</code> 监视了两个事件：<code>BeforeWaiting</code>(准备进入休眠)时 调用<code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> <code>释放旧的池创建新的池子</code>。 <code>Exit（即退出loop）时调用 _objc_autoreleasePoolPop()来释放自动释放池</code>。这个observer的order是214748647，<code>优先级最低</code>，保证其释放池子发生在其他所有回调之后。</p></li></ul><h3 id="面试题6：thread和autoreleasePool的关系？"><a href="#面试题6：thread和autoreleasePool的关系？" class="headerlink" title="面试题6：thread和autoreleasePool的关系？"></a>面试题6：thread和autoreleasePool的关系？</h3><p>在 <a href="https://developer.apple.com/documentation/foundation/nsautoreleasepool#//apple_ref/doc/uid/TP40003623">官方文档</a> 中，找到如下说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects (see Threads). As new pools are created, they get added to the top of the stack. When pools are deallocated, they are removed from the stack. Autoreleased objects are placed into the top autorelease pool for the current thread. When a thread terminates, it automatically drains all of the autorelease pools associated with itself.</span><br></pre></td></tr></table></figure><p>大致意思是：</p><ul><li><p><code>每个线程</code>，包括 <code>主线程</code> 在内都维护了 <code>自己的自动释放池堆栈结构</code></p></li><li><p><code>新的</code> 自动释放池在被创建时，会被添加到 <code>栈顶</code>，当自动释放池 <code>销毁时</code>，会 <code>从栈中移除</code></p></li><li><p>对于 <code>当前线程</code> 来说，会 <code>将自动释放池的对象</code> 放入自动释放池的 <code>栈顶</code>，在线程停止时，会 <code>自动释放掉与该线程相关联的所有自动释放池</code></p></li></ul><p><strong>总结：</strong> 每个线程都有与之关联的自动释放池堆栈结构，新的pool在创建时会被压栈到栈顶，pool销毁时，会被出栈，对于当前线程来说，释放对象会被压栈到栈顶，线程停止时，会自动释放与之相关联的自动释放池</p><h3 id="面试题7：runloop和autorelease的关系"><a href="#面试题7：runloop和autorelease的关系" class="headerlink" title="面试题7：runloop和autorelease的关系"></a>面试题7：runloop和autorelease的关系</h3><p>在 <a href="https://developer.apple.com/documentation/foundation/nsautoreleasepool#//apple_ref/doc/uid/TP40003623">官方文档</a> 中，找到如下说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</span><br></pre></td></tr></table></figure><p>大致意思如下：</p><ul><li><p>主线程的 <code>runloop</code> 在每次事件循环之前，会自动创建一个 <code>autoreleasePool</code></p></li><li><p>并且会在 <code>事件循环</code> 结束时，执行 <code>drain</code> 操作，释放其中的对象</p></li></ul><h2 id="RunLoop相关"><a href="#RunLoop相关" class="headerlink" title="RunLoop相关"></a>RunLoop相关</h2><h3 id="面试题1：当前有个子线程，子线程中有个timer，timer是否能够执行，并进行持续大打印？"><a href="#面试题1：当前有个子线程，子线程中有个timer，timer是否能够执行，并进行持续大打印？" class="headerlink" title="面试题1：当前有个子线程，子线程中有个timer，timer是否能够执行，并进行持续大打印？"></a>面试题1：当前有个子线程，子线程中有个timer，timer是否能够执行，并进行持续大打印？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ZJThread *thread = [[ZJThread alloc] initWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">       // thread.name = nil 因为这个变量只是捕捉</span><br><span class="line">       // ZJThread *thread = nil</span><br><span class="line">       // thread = 初始化 捕捉一个nil进来</span><br><span class="line">       NSLog(@&quot;%@---%@&quot;,[NSThread currentThread],[[NSThread currentThread] name]);</span><br><span class="line">       [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">           NSLog(@&quot;hello word&quot;);            </span><br><span class="line">           // 退出线程--结果runloop也停止了</span><br><span class="line">           if (self.isStopping) &#123;</span><br><span class="line">               [NSThread exit];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;];</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   thread.name = @&quot;lgcode.com&quot;;</span><br><span class="line">   [thread start];</span><br></pre></td></tr></table></figure><ul><li>不可以，因为 子线程的runloop默认是不启动的，需要 runloop run 启动，需要将上述代码改成下面：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ZJThread *thread = [[ZJThread alloc] initWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">        // thread.name = nil 因为这个变量只是捕捉</span><br><span class="line">        // ZJThread *thread = nil</span><br><span class="line">        // thread = 初始化 捕捉一个nil进来</span><br><span class="line">        NSLog(@&quot;%@---%@&quot;,[NSThread currentThread],[[NSThread currentThread] name]);</span><br><span class="line">        [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">            NSLog(@&quot;hello word&quot;);            </span><br><span class="line">            // 退出线程--结果runloop也停止了</span><br><span class="line">            if (self.isStopping) &#123;</span><br><span class="line">                [NSThread exit];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        [[NSRunLoop currentRunLoop] run];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    thread.name = @&quot;lgcode.com&quot;;</span><br><span class="line">    [thread start];</span><br></pre></td></tr></table></figure><h3 id="面试题2：runloop和线程的关系"><a href="#面试题2：runloop和线程的关系" class="headerlink" title="面试题2：runloop和线程的关系"></a>面试题2：runloop和线程的关系</h3><ul><li><p>每个线程都有一个与之对应的runloop，所以 <code>runloop与线程是一一对应的</code>，其绑定关系通过一个 <code>全局的Dictionary存储</code>，线程为 <code>key</code>，runloop为 <code>value</code></p></li><li><p>线程中的runloop主要用来里线程的，当线程runloop开启后，会在执行完任务后进行休眠状态，当有事件触发唤醒时，又开始工作，即 <code>有活时干活，没活就休息</code>。</p></li><li><p><code>主线程</code> 的 <code>runloop</code> 是 <code>默认开启的</code>，在程序启动之后，会一直运行，不会退出</p></li><li><p>其他线程的 <code>runloop默认是不开启的</code>，如果需要，则手动开启</p></li></ul><h3 id="面试题3：NSRunLoop-和-CFRunLoopRef区别"><a href="#面试题3：NSRunLoop-和-CFRunLoopRef区别" class="headerlink" title="面试题3：NSRunLoop 和 CFRunLoopRef区别"></a>面试题3：NSRunLoop 和 CFRunLoopRef区别</h3><ul><li><p><code>NSRunLoop</code> 是 <code>基于CFRunLoopRef</code> 面向对象的 <code>API</code>，是 <code>不安全</code> 的。</p></li><li><p><code>CFRunLoopRef</code> 是 <code>基于C</code> 语言的，是 <code>线程安全</code> 的</p></li></ul><h3 id="面试题4：RunLoop的mode作用是什么？"><a href="#面试题4：RunLoop的mode作用是什么？" class="headerlink" title="面试题4：RunLoop的mode作用是什么？"></a>面试题4：RunLoop的mode作用是什么？</h3><p>mode 主要是用于指定runloop中事件优先级的</p><h3 id="面试题5：以-scheduledTimerWithTimeInterval-的方式触发的timer，在滑动页面上的利润表时，timer会暂停回调，为什么？如何解决？"><a href="#面试题5：以-scheduledTimerWithTimeInterval-的方式触发的timer，在滑动页面上的利润表时，timer会暂停回调，为什么？如何解决？" class="headerlink" title="面试题5：以 +scheduledTimerWithTimeInterval: 的方式触发的timer，在滑动页面上的利润表时，timer会暂停回调，为什么？如何解决？"></a>面试题5：以 +scheduledTimerWithTimeInterval: 的方式触发的timer，在滑动页面上的利润表时，timer会暂停回调，为什么？如何解决？</h3><ul><li><p>timer停止的原因是因为滑动 <code>scrollView</code> 时，主线程的runloop会从 <code>NSDefaultRunLoopMode</code> 切换到 <code>NSTrackingRunLoopMode</code> ，而 <code>timer</code> 是添加在 <code>NSDefaultRunLoopMode</code> 上的，所以timer不会执行</p></li><li><p>将 <code>timer</code> 放入 <code>NSRunLoopCommonModes</code> 中执行</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理36：内存管理（二）強引用分析</title>
      <link href="/BboyZJ.github.io/2021/05/29/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8636%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BC%B7%E5%BC%95%E7%94%A8%E5%88%86%E6%9E%90/"/>
      <url>/BboyZJ.github.io/2021/05/29/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8636%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BC%B7%E5%BC%95%E7%94%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要是通过 <code>定时器</code> 来梳理 <code>强引用</code> 的几种解决方案</p><h1 id="強应用（強持有）"><a href="#強应用（強持有）" class="headerlink" title="強应用（強持有）"></a>強应用（強持有）</h1><p>假设有 <code>A和B</code> 两个页面，从A <code>push</code> 到B页面，在B页面中有如下定时器代码，当从B <code>pop</code> 回到A界面时，发现定时器没有停止，其方法仍然在执行，为什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(fireHome) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure><p>其主要原因是 <code>B页面没有释放</code>，即 <code>没有执行dealloc方法</code>，导致timer也无法停止和释放</p><p><strong>解决方式一</strong></p><ul><li>重写 <code>didMoveParentViewController</code> 方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)didMoveToParentViewController:(UIViewController *)parent&#123;</span><br><span class="line">    // 无论push 进来 还是 pop 出去 正常跑</span><br><span class="line">    // 就算继续push 到下一层 pop 回去还是继续</span><br><span class="line">    if (parent == nil) &#123;</span><br><span class="line">       [self.timer invalidate];</span><br><span class="line">        self.timer = nil;</span><br><span class="line">        NSLog(@&quot;timer 走了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方式二</strong></p><ul><li>定义timer时，采用 <code>闭包</code> 的形式，因此不需要指定target</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)blockTimer&#123;</span><br><span class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">        NSLog(@&quot;timer fire - %@&quot;,timer);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们从底层来深入研究，为什么 <code>B</code> 页面有了 <code>timer</code> 之后，导致 <code>B</code> 页面释放不掉，即不会走到 <code>dealloc</code> 方法，我们可以通过官方文档查看 <code>timerWithTimeInterval:target:selector:userInfo:repeats:</code> 方法中对target的描述</p><p><img src="/BboyZJ.github.io/assets/16497482156978.jpg"></p><p>从文档中可以看出，timer对传入的target具有強持有，即 <code>timer</code> 持有 <code>self</code>。由于timer是定义在B页面中，所以 <code>self也持有timer</code>，因此 <code>self- &gt; timer -&gt; self</code> 构成了 <code>循环引用</code></p><p>在 <a href="https://www.bboyzj.cn/2021/04/22/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8630%EF%BC%9ABlock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">OC底层原理30：Block底层原理</a> 文章中，针对循环引用提供了几种解决方式，我们可以尝试通过 <code>__weak</code> 即 <code>弱引用</code> 来解决，代码修改如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.timer = [NSTimer timerWithTimeInterval:1 target:weakSelf selector:@selector(fireHome) userInfo:nil repeats:YES];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure><p>我们再次运行程序，运行 <code>push-pop</code> 跳转，发现 <code>问题还是存在</code>，即定时器方法仍然在执行，并 <code>没有执行B的dealloc方法</code>，为什么呢?</p><ul><li>我们使用 <code>__weak</code> 虽然打破了 <code>self -&gt; timer -&gt; self</code> 之前的循环引用，即引用链变成了 <code>self -&gt; timer -&gt; weakSelf -&gt; self</code>。但是在这里我们分析的并不全面，此时还有一个 <code>Runloop对timer的強持有</code>，因为 <code>Runloop</code> 的 <code>生命周期</code> 比 <code>B</code> 页面 <code>更长</code>，所以导致了 <code>timer无法释放</code>，同时也导致了 <code>B</code> 页面的 <code>self也无法释放</code>。所以，<code>最初引用链</code> 应该是这样的：</li></ul><p><img src="/BboyZJ.github.io/assets/16497487564959.png"></p><p>加上 <code>weakSelf</code> 之后，变成了这样</p><p><img src="/BboyZJ.github.io/assets/16497487783801.png"></p><p><strong>weakSelf 与 self</strong></p><p>对于 <code>weakSelf</code> 和 <code>self</code> ，主要有以下两个疑问？</p><ul><li><p><code>weakSelf</code> 会对引用计数进行 <code>+1</code> 操作么？</p></li><li><p><code>weakSelf</code> 和 <code>self</code> 的指针地址相同么？是指向同一片内存么？</p></li><li><p>带着疑问，我们在 <code>weakSelf</code> 前后打印 <code>self</code> 的引用计数</p></li></ul><p><img src="/BboyZJ.github.io/assets/16497490452738.jpg"></p><p>因此可以得出一个结论：<code>weakSelf没有对内存进行+1操作</code></p><ul><li>继续打印 <code>weakSelf</code> 和 <code>self</code> 对象，以及指针地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">po weakSelf</span><br><span class="line">po self</span><br><span class="line"></span><br><span class="line">p &amp;weakSelf</span><br><span class="line">p &amp;self</span><br></pre></td></tr></table></figure><p>打印结果如下</p><p><img src="/BboyZJ.github.io/assets/16497495278213.jpg"></p><p>从打印结果可以看出，当前 <code>self</code> 取地址和 <code>weakSelf</code> 取地址的值是不一样的。意味着 <code>两个指针地址，指向的是同一片内存空间</code>，即 <code>weakSelf和self的内存地址是不一样的，都指向同一片内存空间</code> 的</p><p><img src="/BboyZJ.github.io/assets/16497496531731.jpg"></p><ul><li><p>从上面打印可以看出，此时 <code>timer</code> 捕获的是 <code>&lt;LGTimerViewController: 0x102c04dd0&gt;</code> ，是一个 <code>对象</code>，所以 <code>无法通过weakSelf来解决強持有</code>。即引用链关系为 ：<code>NSRunloop -&gt; timer -&gt; weakSelf(&lt;LGTimerViewController: 0x102c04dd0&gt;)</code> 。所以 <code>RunLoop对整个对象的空间有強持有</code>，runloop没停，<code>timer</code> 和 <code>weakSelf</code> 是无法释放的</p></li><li><p>而我们在 <code>block</code> 原理中提及的 <code>block循环引用</code>，与 <code>timer</code> 是 <code>有区别</code> 的。通过block底层原理的方法 <code>__Block_object_assign</code> 可知，block捕获的是 <code>对象的指针地址</code>，即 <code>weakSelf是临时变量的指针地址</code>，跟 <code>self</code> 没有关系，因为 <code>weakSelf是新的地址空间</code>。所以此时的weakSelf相当于中间值。其引用关系链为 <code>self -&gt; block -&gt; weakSelf(临时变量的指针地址)</code>，可以通过 <code>地址</code> 拿到 <code>指针</code></p></li></ul><p>所以在这里，我们需要区别下 <code>block</code> 和 <code>timer</code> 循环引用的模型</p><ul><li><p><strong>timer模型</strong>：<code>self -&gt; timer -&gt; weakSelf -&gt; self</code>，当前的 <code>timer</code> 捕获的是 <code>B页面的内存，即vc对象的内存</code>，即 <code>weakSelf表示的是vc对象</code></p></li><li><p><strong>block模型</strong>：<code>self -&gt; block -&gt; weakSelf -&gt; self</code>，当前的block捕获的是 <code>指针地址</code>，即 <code>weakSelf</code> 表示的是 <code>指向self的临时变量的指针地址</code></p></li></ul><h1 id="解决-強引用（強持有）"><a href="#解决-強引用（強持有）" class="headerlink" title="解决 強引用（強持有）"></a>解决 強引用（強持有）</h1><p>有以下几种解决思路：依赖 <code>中介者模式、打破強持有</code>，其中 <code>推荐思路四</code></p><h2 id="思路一：pop时在其他方法中销毁timer"><a href="#思路一：pop时在其他方法中销毁timer" class="headerlink" title="思路一：pop时在其他方法中销毁timer"></a>思路一：pop时在其他方法中销毁timer</h2><p>根据前面的解释，我们知道由于 <code>Runloop对timer的強持有</code>，导致了 <code>Runloop间接的強持有了self</code>（因为timer中捕获的是 <code>vc对象</code>）。所以导致 <code>dealloc</code> 方法无法执行。需要查看在pop时，是否还有其他方法可以销毁 <code>timer</code>。这个方法就是 <code>didMoveToParentViewController</code></p><ul><li><p><code>didMoveToParentViewController</code> 方法，是用于当一个视图控制器中添加或者移除 viewController后，必须调用的方法。目的是为了告诉iOS，已经完成添加&#x2F;删除子控制器的操作。</p></li><li><p>在B界面中重写 <code>didMoveToParentViewController</code> 方法</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)didMoveToParentViewController:(UIViewController *)parent&#123;</span><br><span class="line">    // 无论push 进来 还是 pop 出去 正常跑</span><br><span class="line">    // 就算继续push 到下一层 pop 回去还是继续</span><br><span class="line">    if (parent == nil) &#123;</span><br><span class="line">       [self.timer invalidate];</span><br><span class="line">        self.timer = nil;</span><br><span class="line">        NSLog(@&quot;timer 走了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路二：中介者模式，即不使用self，依赖于其他对象"><a href="#思路二：中介者模式，即不使用self，依赖于其他对象" class="headerlink" title="思路二：中介者模式，即不使用self，依赖于其他对象"></a>思路二：中介者模式，即不使用self，依赖于其他对象</h2><p>在timer模式中，我们重点关注的是 <code>fireHome</code> 能执行，并 <code>不关心timer捕获target</code> 是谁，由于这里 <code>不方便使用self</code>（因为会有强持有问题），所以 <code>可以将target换成其他对象</code>，例如将target换成 <code>NSObject对象</code>，将 <code>fireHome</code> 交给 <code>target</code> 执行</p><ul><li>将timer的target由self改成objc</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 1.定义成其他对象</span><br><span class="line">@property (nonatomic, strong)id target;</span><br><span class="line"></span><br><span class="line">// 2.修改target</span><br><span class="line">self.target = [[NSObject alloc] init];</span><br><span class="line">class_addMethod([NSObject class],@selector(fireHome),(IMP)fireHomeObjc,&quot;v@:&quot;);</span><br><span class="line">self.timer = [];</span><br><span class="line"></span><br><span class="line">// 3.imp</span><br><span class="line">- (void)fireHome&#123;</span><br><span class="line">    num++;</span><br><span class="line">    NSLog(@&quot;hello word - %d&quot;,num);</span><br><span class="line">&#125;</span><br><span class="line">void fireHomeObjc(id obj)&#123;</span><br><span class="line">    NSLog(@&quot;%s -- %@&quot;,__func__,obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4.dealloc</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看运行结果如下</p><p><img src="/BboyZJ.github.io/assets/16498168708118.jpg"></p><p>运行发现执行 <code>dealloc</code> 之后，timer还是会继续执行。原因是 <code>解决了中介者的释放</code>，但是 <code>没有解决中介者的回收</code>，即 <code>self.target的回收</code>。所以这种方式 <code>有缺陷</code></p><p>可以通过在 dealloc 方法中，取消定时器来解决，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc&#123;</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">    self.timer = nil;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码查看结果如下，发现 pop 之后，timer释放，从而中介者也会进行回收释放</p><p><img src="/BboyZJ.github.io/assets/16498170423914.jpg"></p><h2 id="思路三：自定义封装timer"><a href="#思路三：自定义封装timer" class="headerlink" title="思路三：自定义封装timer"></a>思路三：自定义封装timer</h2><p>这种方式是根据思路二的原理，自定义封装timer，其步骤如下：</p><ul><li><p>自定义<code>timerWapper</code></p><ul><li><p>在初始化方法中，定义一个timer，其target是自己。即 <code>timerWapper</code> 中的 timer，一直监听自己，判断 <code>selector</code>，此时的selector已交给了传入的target（即vc对象），此时有一个方法 <code>fireHomeWapper</code>，在方法中，判断target是否存在</p><ul><li><p>如果 <code>target存在</code>，则需要让vc知道，即向传入的target发送selector消息，并将此时的timer作为参数也一并传入，所以vc就可以得知 fireHome 方法，这种方式是定时器方法能够执行的原因</p></li><li><p>如果 <code>target不存在</code>，已经释放了，则释放当前的 <code>timerWapper</code> ，即打破了Runloop对timerWapper的強持有（<code>timerWapper &lt;- x - RunLoop</code>）</p></li></ul></li></ul></li><li><p>自定义 <code>zj_invalidate</code> 方法中释放timer。这个方法在vc的dealloc方法中调用，即 vc释放，从而导致timerWapper释放，打破了 <code>vc</code> 对 <code>timerWapper</code> 的強持有（<code>vc -&gt; x -&gt; timerWapper</code>）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//********** .h文件 *********</span><br><span class="line">@interface ZJTimerWapper : NSObject</span><br><span class="line">- (instancetype)zj_initWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;</span><br><span class="line">- (void)zj_invalidate;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//********** .m文件 ********</span><br><span class="line">@implementation ZJTimerWapper</span><br><span class="line">- (instancetype)zj_initWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo&#123;</span><br><span class="line">    if (self == [super init]) &#123;</span><br><span class="line">        // 传入vc</span><br><span class="line">        self.target = aTarget;</span><br><span class="line">        // 传入定时器方法</span><br><span class="line">        self.aSelector = aSelector;</span><br><span class="line">        </span><br><span class="line">        if ([self.target respondsToSelector:self.aSelector]) &#123; </span><br><span class="line">            Method method    = class_getInstanceMethod([self.target class], aSelector);</span><br><span class="line">            const char *type = method_getTypeEncoding(method);</span><br><span class="line">            // 给timerWapper添加方法</span><br><span class="line">            class_addMethod([self class], aSelector, (IMP)fireHomeWapper, type);</span><br><span class="line">            // 启动一个timer，target是self，即监听自己</span><br><span class="line">            self.timer = [NSTimer scheduledTimerWithTimeInterval:ti target:self selector:aSelector userInfo:userInfo repeats:yesOrNo];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 一直跑 runloop</span><br><span class="line">void fireHomeWapper(ZJTimerWapper *warpper)&#123;</span><br><span class="line">    // 判断target是否存在</span><br><span class="line">    if (warpper.target) &#123;</span><br><span class="line">    // 如果存在则需要vc知道，即向传入的target发送selector消息，并将此时的timer参数一并传入，所以vc就可以得知 fireHome 方法，这种方式就是定时器方法能够执行的原因</span><br><span class="line">        void (*zj_msgSend)(void *,SEL, id) = (void *)objc_msgSend;</span><br><span class="line">         zj_msgSend((__bridge void *)(warpper.target), warpper.aSelector,warpper.timer);</span><br><span class="line">    &#125;else&#123; </span><br><span class="line">        // 如果target不存在，已经释放，则释放当前的timerWrapper</span><br><span class="line">        [warpper.timer invalidate];</span><br><span class="line">        warpper.timer = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 在vc的dealloc方法中调用，通过vc释放，从而让timer释放</span><br><span class="line">- (void)zj_invalidate&#123;</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">    self.timer = nil;</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>timerWapper的使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 定义</span><br><span class="line">self.timerWapper = [[ZJTimerWapper alloc] zj_initWithTimeInterval:1 target:self selector:@selector(fireHome) userInfo:nil repeats:YES];</span><br><span class="line"></span><br><span class="line">// 释放</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">     [self.timerWapper zj_invalidate];</span><br><span class="line">     NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="/BboyZJ.github.io/assets/16498214951972.jpg"></p><p>这种方式看起来比较繁琐，步骤很多，而且针对 <code>timerWapper</code>，需要不断的添加method，需要进行一系列的处理</p><h2 id="思路四：利用NSProxy虚基类的子类"><a href="#思路四：利用NSProxy虚基类的子类" class="headerlink" title="思路四：利用NSProxy虚基类的子类"></a>思路四：利用NSProxy虚基类的子类</h2><p>下面来介绍一种 <code>timer</code> 強引用 <code>最常用</code> 的处理方式：<code>NSProxy子类</code></p><p>可以通过 <code>NSProxy</code> 虚基类，可以交给其子类实现，NSproxy的介绍在前面的文章已经介绍过了，这里不再重复</p><ul><li>首先定义一个集成自 <code>NSProxy</code> 的子类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//**********NSProxy子类**********</span><br><span class="line">@interface ZJProxy : NSProxy</span><br><span class="line">+ (instancetype)proxyWithTransformObject:(id)object;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface ZJProxy()</span><br><span class="line">@property (nonatomic, weak) id object;</span><br><span class="line"></span><br><span class="line">@implementation ZJProxy</span><br><span class="line">+ (instancetype)proxyWithTransformObject:(id)object&#123;</span><br><span class="line">    ZJProxy *proxy = [ZJProxy alloc];</span><br><span class="line">    proxy.object = object;</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br><span class="line">-(id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    return self.object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将timer中的target传入NSProxy子类对象，即timer持有NSProxy子类对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//**********解决timer強持有的问题*********</span><br><span class="line">self.proxy = [ZJProxy proxyWithTransformObject:self];</span><br><span class="line">self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self.proxy selector:@selector(fireHome) userInfo:nil repeats:YES];</span><br><span class="line"></span><br><span class="line">//在dealloc中将timer正常释放</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">    self.timer = nil;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的目的是将 <code>強引用的注意力转移成了消息转发</code>。虚基类只负责消息转发，即使用 <code>NSProxy</code> 作为 <code>中间代理、中间者</code></p><p>这里有个疑问，定义 <code>proxy</code> 对象，在dealloc释放时，还存在么？</p><ul><li><p>proxy对象会正常释放，因为 <code>vc</code> 正常释放了，所以可以释放其持有者，即 <code>timer和proxy</code>，timer的释放也打破了 <code>runloop对proxy的强持有</code>。完美的达到了 <code>两层释放</code>，即 <code>vc -&gt; proxy &lt;- runloop</code>，解释如下：</p><ul><li><p>vc释放，导致了 <code>proxy</code> 的释放</p></li><li><p>dealloc方法中，timer进行了释放，所以runloop强引用也释放了</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理35：内存管理（一）TaggedPointer/retain/release/dealloc/retainCount 底层分析</title>
      <link href="/BboyZJ.github.io/2021/05/22/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8635%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89TaggedPointer-retain-release-dealloc-retainCount-%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/"/>
      <url>/BboyZJ.github.io/2021/05/22/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8635%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89TaggedPointer-retain-release-dealloc-retainCount-%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要是分析内存管理中的内存管理方案，以及 <code>retain、retainCount、release、dealloc</code> 的底层源码分析</p><h1 id="ARC-amp-MRC"><a href="#ARC-amp-MRC" class="headerlink" title="ARC &amp; MRC"></a>ARC &amp; MRC</h1><p>iOS中的内存管理方案，大致可以分为两类：<code>MRC</code>(手动内存管理) 和 <code>ARC</code>(自动内存管理)</p><p><strong>MRC</strong></p><ul><li><p>在 <code>MRC</code> 时代，系统是通过对象的引用计数来判断一个是否销毁，有以下规则</p><ul><li><p>对象被 <code>创建时</code> 引用计数都为 <code>1</code></p></li><li><p>当对象 <code>被其他指针引用</code> 时，需要手动调用 <code>[objc retain]</code>，使对象的 <code>引用计数+1</code></p></li><li><p>当指针变量不再使用对象时，需要手动调用 <code>[objc release]</code> 来 <code>释放</code> 对象，使对象的 <code>引用计数-1</code></p></li><li><p>当一个对象的 <code>引用计数为0</code> 时，系统就会 <code>销毁</code> 这个对象</p></li></ul></li><li><p>所以，在MRC模式下，必须遵守：<code>谁创建，谁释放，谁引用，谁管理</code></p></li></ul><p><strong>ARC</strong></p><ul><li><code>ARC</code> 模式是在WWDC2011和iOS5引入的自动管理机制，即 <code>自动引用计数</code>，是编译器的一种特性。其规则与MRC一致，区别在于，<code>ARC模式下不需要手动retain、release、autorelease，编译器会在适当位置插入release和autorelease</code></li></ul><h1 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h1><p>我们在前面介绍了 <code>内存五大区</code>，其实除了 <code>内存区</code>，还有 <code>内核区</code> 和 <code>保留区</code>，以 4GB 手机为例，如下所示，系统将其中的 3GB 给了 五大区 + 保留区，剩余的 1GB 给内核区使用</p><p><img src="/BboyZJ.github.io/assets/16494039125752.jpg"></p><ul><li><p><code>内核区</code>：系统用来进行内核处理操作的区域</p></li><li><p><code>五大区</code>：这里不再作说明，具体请参考上面的链接</p></li><li><p><code>保留区</code>：预留给系统处理nil等</p></li></ul><p>这里有个疑问，为什么五大区的最后内存地址是从 <code>0x00400000</code> 开始的。其主要原因是 <code>0x00000000</code> 表示 <code>nil</code>，不能直接用nil表示一个段，所以单独给了一段内存用于 <code>处理nil</code> 等情况</p><h1 id="内存布局相关面试题"><a href="#内存布局相关面试题" class="headerlink" title="内存布局相关面试题"></a>内存布局相关面试题</h1><p><strong>面试题1：全局变量和局部变量在内存中是否有区别？如果有，是什么区别？</strong></p><ul><li><p><code>有区别</code></p></li><li><p><code>全局变量</code> 保存在内存的 <code>全局存储区（即bss+data段）</code>，占用静态的存储单元</p></li><li><p><code>局部变量</code> 保存在 <code>栈</code> 中，只有在所在 <code>函数被调用时才动态的为变量分配存储单元</code></p></li></ul><p><strong>面试题2：Block中可以修改全局变量，全局静态变量，局部静态变量，局部变量吗？</strong></p><ul><li><p>可以修改 <code>全局变量，全局静态变量</code>，因为 <code>全局变量</code> 和 <code>静态全局变量</code> 是 <code>全局</code> 的，作用域广</p></li><li><p>可以修改局部静态变量，不可以修改局部变量</p><ul><li><p><code>局部静态变量（static修饰的）和 局部变量</code>，被block从外面捕获的，成为 <code>__main_block_imp_0</code> 这个结构体的成员变量</p></li><li><p>局部变量 是以 指针形式，被block捕获的，由于捕获的是指针，所以 可以修改 局部静态变量的值</p></li></ul></li><li><p>ARC环境下，一旦使用 <code>__block</code> 修饰并在block中修改，就会 <code>触发copy</code>，block就会从 <code>栈区copy到堆区</code>，此时的 <code>block是堆区block</code></p></li><li><p>ARC模式下，block中引用 <code>id类型</code> 的数据，<code>无论有没有__block修饰，都会retain</code>，对于 <code>基础数据类型，没有__block就无法修改变量值</code>，如果有 <code>__block修饰</code>，也是在底层修改 <code>__block_byref_a_0</code> 结构体，将其内部的 <code>forwarding</code> 指针指向 <code>copy</code>后的地址，来达到值的修改</p></li></ul><h1 id="内存管理方案"><a href="#内存管理方案" class="headerlink" title="内存管理方案"></a>内存管理方案</h1><p>内存管理方案除了前文提及的 <code>MRC</code> 和 <code>ARC</code>，还有以下三种：</p><ul><li><p><code>Tagged Pointer</code>：专门用来处理小对象，例如NSNumber、NSDate、小NSString等</p></li><li><p><code>Nonpointer_isa</code>：非指针类型的isa，主要是用来优化64位地址，这个在 <a href="https://www.bboyzj.cn/2020/09/18/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8608%EF%BC%9Aisa%E5%92%8C%E7%B1%BB%E5%85%B3%E8%81%94%E6%8E%A2%E7%B4%A2/">OC底层原理08：isa和类关联探索</a> 一文中，已经介绍了</p></li><li><p><code>SideTables</code>：<code>散列表</code>，在散列表中主要有两个表，分别是 <code>引用计数表、弱引用表</code></p></li></ul><p>这里主要着重借号 <code>Tagged Pointer</code> 和 <code>SideTables</code>，我们通过一个面试题来引入 <code>Tagged Pointer</code></p><p><strong>面试题</strong></p><p>以下代码会有什么问题？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,strong)dispatch_queue_t queue;</span><br><span class="line">@property (nonatomic,copy)NSString * nameStr;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)taggedPointerDemo&#123;</span><br><span class="line">    self.queue = dispatch_queue_create(&quot;com.zj.cn&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    for (int i = 0; i &lt; 10000; i ++) &#123;</span><br><span class="line">        dispatch_async(self.queue, ^&#123;</span><br><span class="line">            // alloc 堆 iOS优化 - taggedpointer</span><br><span class="line">            self.nameStr = [NSString stringWithFormat:@&quot;zj&quot;];</span><br><span class="line">            NSLog(@&quot;%@&quot;,self.nameStr);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    NSLog(@&quot;来了&quot;);</span><br><span class="line">    for (int i = 0; i &lt; 10000; i ++) &#123;</span><br><span class="line">        dispatch_async(self.queue, ^&#123;</span><br><span class="line">            self.nameStr = [NSString stringWithFormat:@&quot;zj_越努力，越幸运&quot;];</span><br><span class="line">            NSLog(@&quot;%@&quot;,self.nameStr);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>运行以上代码，发现 <code>taggedPointerDemo</code> 单独运行没有问题，当触发 <code>touchBegan</code> 方法后。程序会崩溃，崩溃的原因是 <code>多条线程同时对一个对象进行解释</code>，导致了 <code>过渡释放</code> 所以崩溃。其根本原因是因为 <code>nameStr</code> 在底层的类型不一致导致的，我们可以通过调试看出</p><p><img src="/BboyZJ.github.io/assets/16496631385650.jpg"></p><p><img src="/BboyZJ.github.io/assets/16496632176327.jpg"></p><ul><li><p><code>taggedPointerDemo</code> 方法中的 <code>nameStr</code> 类型是 <code>NSTaggedPointerString</code>，存储在 <code>常量区</code>。因为 <code>nameStr</code> 在 <code>alloc</code> 分配时在 <code>堆区</code>，由于较小，所以经过xcode在iOS中的优化，成了 <code>NSTaggedPointerString</code> 类型，存储在 <code>常量区</code></p></li><li><p><code>touchesBegan</code> 方法中的 <code>nameStr</code> 类型是 <code>NSCFString</code> 类型，存储在 <code>堆上</code></p></li></ul><p><strong>NSString的内存管理</strong></p><p>我们可以通过NSString初始化的两种方式，来测试NSString的内存管理</p><ul><li><p>通过 <code>WithString + @&quot;&quot;</code> 方式初始化</p></li><li><p>通过 <code>WithFormat</code> 方式初始化</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#define ZJLog(_c) NSLog(@&quot;%@ -- %p -- %@&quot;,_c,_c,[_c class]);</span><br><span class="line"></span><br><span class="line">- (void)testNSString&#123;</span><br><span class="line">    // 初始化方式一：通过 WithString + @&quot;&quot; 方式</span><br><span class="line">    NSString * s1 = @&quot;1&quot;;</span><br><span class="line">    NSString * s2 = [[NSString alloc] initWithString:@&quot;2&quot;];</span><br><span class="line">    NSString * s3 = [NSString stringWithString:@&quot;3&quot;];</span><br><span class="line">    </span><br><span class="line">    ZJLog(s1);</span><br><span class="line">    ZJLog(s2);</span><br><span class="line">    ZJLog(s3);</span><br><span class="line">    </span><br><span class="line">    // 初始化方式二：通过 WithFormat</span><br><span class="line">    // 字符串长度在9以内</span><br><span class="line">    NSString * s4 = [NSString stringWithFormat:@&quot;123456789&quot;];</span><br><span class="line">    NSString * s5 = [[NSString alloc] initWithFormat:@&quot;123456789&quot;];</span><br><span class="line">    </span><br><span class="line">    // 字符串长度大于9</span><br><span class="line">    NSString * s6 = [NSString stringWithFormat:@&quot;1234567890&quot;];</span><br><span class="line">    NSString * s7 = [[NSString alloc] initWithFormat:@&quot;1234567890&quot;];</span><br><span class="line">    </span><br><span class="line">    ZJLog(s4);</span><br><span class="line">    ZJLog(s5);</span><br><span class="line">    ZJLog(s6);</span><br><span class="line">    ZJLog(s7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是运行的结果</p><p><img src="/BboyZJ.github.io/assets/16496643079397.jpg"></p><p>所以，从上面可以总结出，NSString的 <code>内存管理</code> 主要分为3中</p><ul><li><p><code>__NSCFConstantString</code>：字符串常量区，是一种 <code>编译时常量</code>，retainCount值很大，对其操作，<code>不会引起引用计数变化，存储在字符串常量区</code></p></li><li><p><code>__NSCFString</code>：是在 <code>运行时</code> 创建的 <code>NSString子类</code>，创建后 <code>引用计数会加1，存储在堆上</code></p></li><li><p><code>NSTaggedPointerString</code>：标签指针，是苹果在64位环境下对 <code>NSString、NSNumber</code> 等对象做的优化，对于NSString对象来说</p><ul><li><p>当 <code>字符串是由数字、英文字母组合且长度小于等于9</code> 时，会自动成为 <code>NSTaggedPointerString</code> 类型，存储在 <code>常量区</code></p></li><li><p>当有 <code>中文或其他特殊符号</code> 时，会直接成为 <code>__NSCFString</code> 类型，存储在 <code>堆区</code></p></li></ul></li></ul><h1 id="Tagged-Pointer-小对象"><a href="#Tagged-Pointer-小对象" class="headerlink" title="Tagged Pointer 小对象"></a>Tagged Pointer 小对象</h1><p>由一个NSString的面试题，引出了 <code>Tagged Pointer</code> ，为了探索小对象的引用计数器，处理我们需要进入 <code>objc</code> 源码中查看 <code>retain、release</code> 源码中对 <code>Tagged Pointer</code> 小对象的处理</p><p><strong>小对象的引用计数处理分析</strong></p><ul><li>查看 <code>setProperty -&gt; reallySetProperty</code> 源码，其中是对 <code>新值retain</code>，<code>旧值release</code></li></ul><p><img src="/BboyZJ.github.io/assets/16496663752526.jpg"></p><ul><li>进入 <code>objc_retain、objc_release</code> 源码，在这里都判断是否是小对象，如果是小对象，则不会进行retain和release，会直接返回，因此可以得出一个结论：<code>如果是小对象，不会进行retain和release</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//****************objc_retain****************</span><br><span class="line">__attribute__((aligned(16), flatten, noinline))</span><br><span class="line">id </span><br><span class="line">objc_retain(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return obj;</span><br><span class="line">    //判断是否是小对象，如果是，则直接返回对象</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return obj;</span><br><span class="line">    //如果不是小对象，则retain</span><br><span class="line">    return obj-&gt;retain();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//****************objc_release****************</span><br><span class="line">__attribute__((aligned(16), flatten, noinline))</span><br><span class="line">void </span><br><span class="line">objc_release(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return;</span><br><span class="line">    //如果是小对象，则直接返回</span><br><span class="line">    if (obj-&gt;isTaggedPointer()) return;</span><br><span class="line">    //如果不是小对象，则release</span><br><span class="line">    return obj-&gt;release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小对象地址分析</strong></p><ul><li><p>一般的 <code>NSString</code> 对象指针，都是 <code>string值 + 指针地址</code>，两者是 <code>分开</code> 的</p></li><li><p>对于 <code>Tagged Pointer</code> 指针，其 <code>指针+值</code>，都能在小对象中体现，所以 <code>Tagged Pointer即包含指针，也包含值</code></p></li></ul><p>在之前的文章讲类加载时，其中的 <code>_read_image</code> 源码中有一个方法对小对象进行了处理，即 <code>initializeTaggedPointerObfuscator</code> 方法</p><ul><li>进入 <code>_read_image -&gt; initializeTaggedPointerObfuscator</code> 源码实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">initializeTaggedPointerObfuscator(void)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    if (sdkIsOlderThan(10_14, 12_0, 12_0, 5_0, 3_0) ||</span><br><span class="line">        // Set the obfuscator to zero for apps linked against older SDKs,</span><br><span class="line">        // in case they&#x27;re relying on the tagged pointer representation.</span><br><span class="line">        DisableTaggedPointerObfuscation) &#123;</span><br><span class="line">        objc_debug_taggedpointer_obfuscator = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //在iOS14之后，对小对象进行了混淆，通过与操作+_OBJC_TAG_MASK混淆</span><br><span class="line">    else &#123;</span><br><span class="line">        // Pull random data into the variable, then shift away all non-payload bits.</span><br><span class="line">        arc4random_buf(&amp;objc_debug_taggedpointer_obfuscator,</span><br><span class="line">                       sizeof(objc_debug_taggedpointer_obfuscator));</span><br><span class="line">        objc_debug_taggedpointer_obfuscator &amp;= ~_OBJC_TAG_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现中，我们可以看出，在iOS14之后，Tagged Pointer 采用了混淆处理，如下所示</p><p><img src="/BboyZJ.github.io/assets/16496674152595.jpg"></p><ul><li>我们可以在源码中通过 objc_debug_taggedpointer_obfuscator 查找 taggedPointer 的 编码 和 解码 ，来查看底层是如何混淆处理的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//编码</span><br><span class="line">static inline void * _Nonnull</span><br><span class="line">_objc_encodeTaggedPointer(uintptr_t ptr)</span><br><span class="line">&#123;</span><br><span class="line">    return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);</span><br><span class="line">&#125;</span><br><span class="line">//解码</span><br><span class="line">static inline uintptr_t</span><br><span class="line">_objc_decodeTaggedPointer(const void * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    return (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator;</span><br></pre></td></tr></table></figure><p>通过实现，我们可以得知，在编码和解码部分，经过了 <code>两层异或</code>，其目的是 <code>得到小对象自己</code>，例如以 <code>1010 0001</code> 为例，假设 <code>mask</code> 为 <code>1010 1000</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 1010 0001 </span><br><span class="line">^0101 1000 mask（编码）</span><br><span class="line"> 1111 1001</span><br><span class="line">^0101 1000 mask（解码）</span><br><span class="line"> 1010 0001</span><br></pre></td></tr></table></figure><ul><li>所以在外界，为了 <code>获取小对象的真是地址</code>，我们可以将解码的源码拷贝到外面，将NSString混淆部分进行 <code>解码</code>，如下所示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">extern uintptr_t objc_debug_taggedpointer_obfuscator;</span><br><span class="line"></span><br><span class="line">- (void)test&#123;</span><br><span class="line">    NSString * s1 = [NSString stringWithFormat:@&quot;a&quot;];</span><br><span class="line">    NSString * s2 = [NSString stringWithFormat:@&quot;b&quot;];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%p - %@&quot;,s1,s1);</span><br><span class="line">    NSLog(@&quot;%p - %@&quot;,s2,s2);</span><br><span class="line">    NSLog(@&quot;0x%lx&quot;,_objc_decodeTaggedPointer_(s2));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">uintptr_t</span><br><span class="line">_objc_decodeTaggedPointer_(id ptr)</span><br><span class="line">&#123;</span><br><span class="line">    return (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下</p><p><img src="/BboyZJ.github.io/assets/16496679551430.jpg"><br>观察解码后的 小对象地址，其中的 <code>10</code> 表示 <code>b</code> 的 <code>ASCII</code> 码，再以 <code>NSNumber</code> 为例，同样可以看出，<code>8</code> 就是我们实际的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSNumber * n1 = @1;</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;%@ - %p - 0x%lx&quot;,n1,n1,_objc_decodeTaggedPointer_(n1));</span><br></pre></td></tr></table></figure><p>打印结果如下</p><p><img src="/BboyZJ.github.io/assets/16496682779087.jpg"></p><p>到这里，我们验证了 <code>小对象指针地址中确实存储了值</code>。</p><h1 id="TaggedPointer-总结"><a href="#TaggedPointer-总结" class="headerlink" title="TaggedPointer 总结"></a>TaggedPointer 总结</h1><ul><li><p><code>Tagged Pointer</code> 小对象类型（用于存储 <code>NSNumber、NSDate、小NSString</code>），小对象指针不再是简单的地址，而是 <code>地址+值</code>，即 <code>真正的值</code>，所以，实际上 <code>它不再是一个对象了，它只是一个披着对象皮的普通变量</code> 而已。所以可以直接进行读取。优点是 <code>占用空间小、节省内存</code></p></li><li><p><code>Tagged Pointer</code> 小对象 <code>不会进入retain和release</code>，而是 <code>直接返回了</code>，意味着 不需要ARC进行管理，所以 <code>可以直接被系统自主的释放和回收</code></p></li></ul><p><code>Tagged Pointer</code> 的 <code>内存并不存储在堆</code> 中，而是在 <code>常量区</code> 中，也 <code>不需要malloc和free</code>，所以可以直接读取，相比存储在堆区的数据 <code>读取</code>，<code>效率上快乐3倍左右</code>，<code>创建</code> 的效率相比堆区 <code>快了近100倍左右</code></p><ul><li><p>所以，综合来说，<code>Tagged Pointer</code> 的内存管理方案，比常规的内存管理，要快的多</p></li><li><p><code>Tagged Pointer</code> 的64位地址中，<code>前4</code> 位代表类型，<code>后4</code> 位主要适用于系统做一些处理，中间56位用于存储值</p></li><li><p>优化内存建议：对于 <code>NSString</code> 来说，当字符串 <code>较小</code> 时，建议直接通过 <code>@&quot;&quot;</code> 初始化，因为存储在 <code>常量区</code>，可以直接进行读取，会比 <code>WithFormat初始化方式</code> 更加快速</p></li></ul><h1 id="SideTable-散列表"><a href="#SideTable-散列表" class="headerlink" title="SideTable 散列表"></a>SideTable 散列表</h1><p>当 <code>引用计数</code> 存储到一定值时，并不会在存储到 <code>Nonpointer_isa</code> 的位域的 <code>extra_rc</code> 中，而是会存储到 <code>SideTable散列表中</code></p><p>下面我们就来继续探索引用计数retain的底层实现</p><p><strong>retain源码分析</strong></p><ul><li><p>进入 <code>objc_retain -&gt; retain -&gt; rootRetain</code> 源码实现，主要有以下几部分逻辑</p><ul><li><p>【第一步】判断是否为 <code>Nonapointer_isa</code></p></li><li><p>【第二步】操作引用计数</p><ul><li><p>如果不是 <code>Nonapointer_isa</code>，则直接操作 <code>SideTable</code> 散列表，此时的散列表并不只有一张，而是有很多张（后续会分析，为什么需要多张？）</p></li><li><p>判断 <code>是否正在释放</code>，如果正在释放，则执行dealloc流程</p></li><li><p>执行 <code>extra_rc + 1</code>，即引用计数+1操作，并给一个引用计数的 状态标识carry， 用于表示 <code>extra_rc</code> 是否满了</p></li><li><p>如果 <code>carry</code> 的状态表示 <code>extac_rc的引用计数满了</code> ，此时需要操作 <code>散列表</code>，即满状态拿出来存到 <code>extra_rc</code>，另一半存在散列表的 <code>extrc_half</code>。这么做的原因是因为如果都存储在 <code>散列表</code>，每次对散列表操作都需要开解锁，操作耗时，消耗性能大，这么 <code>对半分</code> 操作的目的在于 <code>提高性能</code>。</p></li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE id </span><br><span class="line">objc_object::rootRetain(bool tryRetain, bool handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line"></span><br><span class="line">    bool sideTableLocked = false;</span><br><span class="line">    bool transcribeToSideTable = false;</span><br><span class="line">    //为什么有isa？因为需要对引用计数+1，即retain+1，而引用计数存储在isa的bits中，需要进行新旧isa的替换</span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line">    //重点</span><br><span class="line">    do &#123;</span><br><span class="line">        transcribeToSideTable = false;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        //判断是否为nonpointer isa</span><br><span class="line">        if (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            //如果不是 nonpointer isa，直接操作散列表sidetable</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (rawISA()-&gt;isMetaClass()) return (id)this;</span><br><span class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;</span><br><span class="line">            else return sidetable_retain();</span><br><span class="line">        &#125;</span><br><span class="line">        // don&#x27;t check newisa.fast_rr; we already called any RR overrides</span><br><span class="line">        //dealloc源码</span><br><span class="line">        if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        //执行引用计数+1操作，即对bits中的 1ULL&lt;&lt;45（arm64） 即extra_rc，用于该对象存储引用计数值</span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc++</span><br><span class="line">        //判断extra_rc是否满了，carry是标识符</span><br><span class="line">        if (slowpath(carry)) &#123;</span><br><span class="line">            // newisa.extra_rc++ overflowed</span><br><span class="line">            if (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                return rootRetain_overflow(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">            // Leave half of the retain counts inline and </span><br><span class="line">            // prepare to copy the other half to the side table.</span><br><span class="line">            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            sideTableLocked = true;</span><br><span class="line">            transcribeToSideTable = true;</span><br><span class="line">            //如果extra_rc满了，则直接将满状态的一半拿出来存到extra_rc</span><br><span class="line">            newisa.extra_rc = RC_HALF;</span><br><span class="line">            //给一个标识符为YES，表示需要存储到散列表</span><br><span class="line">            newisa.has_sidetable_rc = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    if (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        // Copy the other half of the retain counts to the side table.</span><br><span class="line">        //将另一半存在散列表的rc_half中，即满状态下是8位，一半就是1左移7位，即除以2</span><br><span class="line">        //这么操作的目的在于提高性能，因为如果都存在散列表中，当需要release-1时，需要去访问散列表，每次都需要开解锁，比较消耗性能。extra_rc存储一半的话，可以直接操作extra_rc即可，不需要操作散列表。性能会提高很多</span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure><p><strong>问题1：散列表为什么在内存有多张？最多能够多少张？</strong></p><ul><li><p>如果散列表只有一张表，意味着全局所有的对象都会存储在一张表中，都会进行开锁解锁（锁是锁整个表的读写）。当开锁时，由于所有数据都在一张表，则意味着 数据不安全</p></li><li><p>如果 每个对象都开一个表，会 耗费性能，所以也不能有无数个表</p></li><li><p>散列表的类型是 SideTable，有如下定义</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">    spinlock_t slock;//开/解锁</span><br><span class="line">    RefcountMap refcnts;//引用计数表</span><br><span class="line">    weak_table_t weak_table;//弱引用表</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过查看 <code>sidetable_unlock</code> 方法定位 <code>SideTables</code>，其内部是通过 <code>SideTablesMap</code> 的get方法获取。而 <code>SideTablesMap</code> 是通过 <code>StripedMap&lt;SideTable&gt;</code> 定义的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void </span><br><span class="line">objc_object::sidetable_unlock()</span><br><span class="line">&#123;</span><br><span class="line">    //SideTables散列表并不只是一张，而是很多张，与关联对象表类似</span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    return SideTablesMap.get();</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">static objc::ExplicitInit&lt;StripedMap&lt;SideTable&gt;&gt; SideTablesMap;</span><br></pre></td></tr></table></figure><p>从而进入 <code>StripedMap</code> 的定义，从这里可以看出，<code>同一时间，真机中散列表最多只能有8张</code></p><p><img src="/BboyZJ.github.io/assets/16497320614761.jpg"></p><p><strong>问题2：为什么在用散列表，而不用数组、链表？</strong></p><ul><li><p><code>数组</code>：特点在于 <code>查询方便（即通过下标访问），增删比较麻烦</code>（类似于之前讲过的 <code>methodList</code>，通过 <code>memcopy、memove</code> 增删，非常麻烦），所以数据的特性是 <code>读取快、存储不方便</code></p></li><li><p><code>链表</code>：特点在于 <code>增删方便、查询慢</code>（需要从头头节点开始遍历查询），所以链表的特性是 <code>存储快、读取慢</code></p></li><li><p><code>散列表</code> ： <code>本质</code> 就是一张 <code>哈希表</code>，哈希表 <code>集合了数组和链表的长处，增删改查都比较方便</code>，例如 拉链哈希表（在之前锁的文章中，讲过 <code>tls</code> 的存储结构就是 <code>拉链形式</code>的），是最常用的，如下所示</p></li></ul><p><img src="/BboyZJ.github.io/assets/16497416366405.jpg"></p><p>可以从 <code>SideTables -&gt; StripedMap -&gt; indexForPointer</code> 中验证是 <code>通过嘻哈函数计算哈希下标</code> 以及 <code>sideTables</code> 为什么可以 <code>使用[]</code> 的原因</p><p><img src="/BboyZJ.github.io/assets/16497417926987.jpg"></p><p>所以，综上所述，<code>retain</code> 的底层流程如下所示</p><p><img src="/BboyZJ.github.io/assets/16497418497244.jpg"></p><p><strong>总结：retain完成回答</strong></p><ul><li><p>retain 在底层首先会 判断是否是 Nonpointer isa，如果 不是，则直接操作散列表，进行+1操作</p></li><li><p>如果 是Nonpointer isa，还需要 判断是否正在释放，如果正在 释放，则执行dealloc流程，释放弱引用表和引用技术表，最后free释放对象内存</p></li><li><p>如果 <code>不是正在释放，则对Nonpointer isa进行常规引用计数+1</code>，这里需要注意一点的是，<code>extra_rc</code> 在真机上只有 <code>8位用于存储引用计数的值</code>，当存储 <code>满了</code> 时，需要 <code>借助散列表</code> 用于存储。需要将满了 <code>extra_rc</code> 对半分，一半（即2^7）存储在 <code>散列表</code> 中，另一半还是存储在 <code>extra_rc</code> 中，用于常规的引用计数的+1或者-1操作，然后再返回</p></li></ul><h1 id="release-源码分析"><a href="#release-源码分析" class="headerlink" title="release 源码分析"></a>release 源码分析</h1><p>分析了 <code>retain</code> 的底层实现，下面来分析 <code>release</code> 的底层实现</p><ul><li><p>通过 <code>setProperty -&gt; reallySetProperty -&gt; objc_release -&gt; release -&gt; rootRelease -&gt; rootRelease</code> 顺序，进入 rootRelease 源码，其操作与retain相反</p><ul><li><p>判断是否是 <code>Nonpointer isa</code> ，如果不是，则 <code>直接对散列表进行-1操作</code></p></li><li><p>如果是 <code>Nonpointer isa</code> ，则对extra_rc 中的引用计数值进行 -1 操作，并存储此时的 extra_rc 状态到 carry 中</p></li><li><p>如果此时的状态 carry 为 0，则走到 underflow 流程</p></li><li><p>underflow 流程有以下几步</p><ul><li><p>判断 <code>散列表</code> 中 <code>是否存储了一半的引用计数</code></p></li><li><p>如果是，则从 <code>散列表</code> 中取出 <code>存储的一半引用计数</code>，进行 <code>-1操作</code>，然后存储到 <code>extra_rc</code> 中</p></li><li><p>如果此时 <code>extra_rc</code> 没有值，散列表中也是空的，则直接进行析构，即 <code>dealloc</code> 操作，属于自动触发</p></li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE bool </span><br><span class="line">objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return false;</span><br><span class="line"></span><br><span class="line">    bool sideTableLocked = false;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    do &#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        //判断是否是Nonpointer isa</span><br><span class="line">        if (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            //如果不是，则直接操作散列表-1</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (rawISA()-&gt;isMetaClass()) return false;</span><br><span class="line">            if (sideTableLocked) sidetable_unlock();</span><br><span class="line">            return sidetable_release(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line">        // don&#x27;t check newisa.fast_rr; we already called any RR overrides</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        //进行引用计数-1操作，即extra_rc-1</span><br><span class="line">        newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc--</span><br><span class="line">        //如果此时extra_rc的值为0了，则走到underflow</span><br><span class="line">        if (slowpath(carry)) &#123;</span><br><span class="line">            // don&#x27;t ClearExclusive()</span><br><span class="line">            goto underflow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                             oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    if (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line"> underflow:</span><br><span class="line">    // newisa.extra_rc-- underflowed: borrow from side table or deallocate</span><br><span class="line"></span><br><span class="line">    // abandon newisa to undo the decrement</span><br><span class="line">    newisa = oldisa;</span><br><span class="line">    //判断散列表中是否存储了一半的引用计数</span><br><span class="line">    if (slowpath(newisa.has_sidetable_rc)) &#123;</span><br><span class="line">        if (!handleUnderflow) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            return rootRelease_underflow(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Transfer retain count from side table to inline storage.</span><br><span class="line"></span><br><span class="line">        if (!sideTableLocked) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            sidetable_lock();</span><br><span class="line">            sideTableLocked = true;</span><br><span class="line">            // Need to start over to avoid a race against </span><br><span class="line">            // the nonpointer -&gt; raw pointer transition.</span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Try to remove some retain counts from the side table.</span><br><span class="line">        //从散列表中取出存储的一半引用计数</span><br><span class="line">        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);</span><br><span class="line"></span><br><span class="line">        // To avoid races, has_sidetable_rc must remain set </span><br><span class="line">        // even if the side table count is now zero.</span><br><span class="line"></span><br><span class="line">        if (borrowed &gt; 0) &#123;</span><br><span class="line">            // Side table retain count decreased.</span><br><span class="line">            // Try to add them to the inline count.</span><br><span class="line">            //进行-1操作，然后存储到extra_rc中</span><br><span class="line">            newisa.extra_rc = borrowed - 1;  // redo the original decrement too</span><br><span class="line">            bool stored = StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                                oldisa.bits, newisa.bits);</span><br><span class="line">            if (!stored) &#123;</span><br><span class="line">                // Inline update failed. </span><br><span class="line">                // Try it again right now. This prevents livelock on LL/SC </span><br><span class="line">                // architectures where the side table access itself may have </span><br><span class="line">                // dropped the reservation.</span><br><span class="line">                isa_t oldisa2 = LoadExclusive(&amp;isa.bits);</span><br><span class="line">                isa_t newisa2 = oldisa2;</span><br><span class="line">                if (newisa2.nonpointer) &#123;</span><br><span class="line">                    uintptr_t overflow;</span><br><span class="line">                    newisa2.bits = </span><br><span class="line">                        addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &amp;overflow);</span><br><span class="line">                    if (!overflow) &#123;</span><br><span class="line">                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </span><br><span class="line">                                                       newisa2.bits);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!stored) &#123;</span><br><span class="line">                // Inline update failed.</span><br><span class="line">                // Put the retains back in the side table.</span><br><span class="line">                sidetable_addExtraRC_nolock(borrowed);</span><br><span class="line">                goto retry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Decrement successful after borrowing from side table.</span><br><span class="line">            // This decrement cannot be the deallocating decrement - the side </span><br><span class="line">            // table lock and has_sidetable_rc bit ensure that if everyone </span><br><span class="line">            // else tried to -release while we worked, the last one would block.</span><br><span class="line">            sidetable_unlock();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // Side table is empty after all. Fall-through to the dealloc path.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //此时extra_rc中值为0，散列表中也是空的，则直接进行析构，即自动触发dealloc流程</span><br><span class="line">    // Really deallocate.</span><br><span class="line">    //触发dealloc的时机</span><br><span class="line">    if (slowpath(newisa.deallocating)) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        if (sideTableLocked) sidetable_unlock();</span><br><span class="line">        return overrelease_error();</span><br><span class="line">        // does not actually return</span><br><span class="line">    &#125;</span><br><span class="line">    newisa.deallocating = true;</span><br><span class="line">    if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;</span><br><span class="line"></span><br><span class="line">    if (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line"></span><br><span class="line">    __c11_atomic_thread_fence(__ATOMIC_ACQUIRE);</span><br><span class="line"></span><br><span class="line">    if (performDealloc) &#123;</span><br><span class="line">        //发送一个dealloc消息</span><br><span class="line">        ((void(*)(objc_object *, SEL))objc_msgSend)(this, @selector(dealloc));</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure><p>所以，综上所述，release 的底层流程如下图所示</p><p><img src="/BboyZJ.github.io/assets/16497437513555.png"></p><h1 id="dealloc-源码分析"><a href="#dealloc-源码分析" class="headerlink" title="dealloc 源码分析"></a>dealloc 源码分析</h1><p>在 <code>retain</code> 和 <code>release</code> 的底层实现中，都提及了 <code>dealloc</code> 析构函数，下面来分析 <code>dealloc</code> 的底层实现</p><ul><li><p>进入 <code>dealloc -&gt; _objc_rootDealloc -&gt; rootDealloc</code> 源码实现，主要有两件事：</p><ul><li>根据条件 <code>判断是否有isa、cxx、关联对象、若引用表、引用计数表</code>，如果没有，则 <code>直接free释放内存</code></li><li>如果有，则进入 <code>object_diapose</code> 方法</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    //对象要释放，需要做哪些事情？</span><br><span class="line">    //1、isa - cxx - 关联对象 - 弱引用表 - 引用计数表</span><br><span class="line">    //2、free</span><br><span class="line">    if (isTaggedPointer()) return;  // fixme necessary?</span><br><span class="line"></span><br><span class="line">    //如果没有这些，则直接free</span><br><span class="line">    if (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(this);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        //如果有</span><br><span class="line">        object_dispose((id)this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>进入 object_dispose 源码，其目的有以下几个</p><ul><li><p>销毁实例，主要有以下操作</p><ul><li><p>调用c++析构函数</p></li><li><p>删除关联引用</p></li><li><p>释放散列表</p></li><li><p>清空弱引用表</p></li></ul></li><li><p>free释放内存</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">object_dispose(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return nil;</span><br><span class="line">    //销毁实例而不会释放内存</span><br><span class="line">    objc_destructInstance(obj);</span><br><span class="line">    //释放内存</span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        // Read all of the flags at once for performance.</span><br><span class="line">        bool cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        bool assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        // This order is important.</span><br><span class="line">        //调用C ++析构函数</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        //删除关联引用</span><br><span class="line">        if (assoc) _object_remove_assocations(obj);</span><br><span class="line">        //释放</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">inline void </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    //判断是否为nonpointer isa</span><br><span class="line">    if (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        // Slow path for raw pointer isa.</span><br><span class="line">        //如果不是，则直接释放散列表</span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    //如果是，清空弱引用表 + 散列表</span><br><span class="line">    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        // Slow path for non-pointer isa with weak refs and/or side table data.</span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">NEVER_INLINE void</span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line">    table.lock();</span><br><span class="line">    if (isa.weakly_referenced) &#123;</span><br><span class="line">        //清空弱引用表</span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)this);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isa.has_sidetable_rc) &#123;</span><br><span class="line">        //清空引用计数</span><br><span class="line">        table.refcnts.erase(this);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>所以，综上所述，dealloc 底层的流程图如图所示</p><p><img src="/BboyZJ.github.io/assets/16497441152982.jpg"></p><p>所以，到目前为止，从最开始的 <code>alloc底层分析 -&gt; retain -&gt; release -&gt; dealloc</code> 就全部串联起来了</p><h1 id="retainCount-源码分析"><a href="#retainCount-源码分析" class="headerlink" title="retainCount 源码分析"></a>retainCount 源码分析</h1><p>引用计数的分析通过一个面试题来说明</p><p><strong>面试题：alloc创建的对象的引用计数为多少？</strong></p><ul><li>定义如下代码，打印其引用计数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSObject *objc = [NSObject alloc];</span><br><span class="line">NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)objc));</span><br></pre></td></tr></table></figure><p>其打印结果如下</p><p><img src="/BboyZJ.github.io/assets/16497444706819.jpg"></p><ul><li>进入 retainCount -&gt; _objc_rootRetainCount -&gt; rootRetainCount 源码，其实现如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)retainCount &#123;</span><br><span class="line">    return _objc_rootRetainCount(self);</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">uintptr_t</span><br><span class="line">_objc_rootRetainCount(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    return obj-&gt;rootRetainCount();</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">inline uintptr_t </span><br><span class="line">objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (uintptr_t)this;</span><br><span class="line"></span><br><span class="line">    sidetable_lock();</span><br><span class="line">    isa_t bits = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);</span><br><span class="line">    //如果是nonpointer isa，才有引用计数的下层处理</span><br><span class="line">    if (bits.nonpointer) &#123;</span><br><span class="line">        //alloc创建的对象引用计数为0，包括sideTable,所以对于alloc来说，是 0+1=1，这也是为什么通过retaincount获取的引用计数为1的原因</span><br><span class="line">        uintptr_t rc = 1 + bits.extra_rc;</span><br><span class="line">        if (bits.has_sidetable_rc) &#123;</span><br><span class="line">            rc += sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        return rc;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果不是，则正常返回</span><br><span class="line">    sidetable_unlock();</span><br><span class="line">    return sidetable_retainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们可以通过源码断点调试，来查看此时的 <code>extra_rc</code> 的值，结果如下</p><p><img src="/BboyZJ.github.io/assets/16497448354905.jpg"></p><p><strong>答案：</strong> 综上所述，<code>alloc</code> 创建的对象 <code>实际的引用计数为0</code>，其引用计数打印结果为1，是因为在底层 <code>rootRetainCount</code> 方法中，<code>引用计数默认+1</code> 了，但是这里 <code>只有</code> 对引用计数的 <code>读取</code> 操作，是没有写入操作的，简单来说就是：<code>为了防止alloc创建的对象被释放（引用计数为0会被释放），所以在编译阶段，程序底层默认进行了+1操作。实际上在extra_rc中的引用计数仍然诶0</code></p><p><strong>总结</strong></p><ul><li><p><code>alloc</code> 创建的对象 <code>没有retain 和 release</code></p></li><li><p><code>alloc</code> 创建对象的 <code>引用计数为0</code>，会在 <code>编译时期</code>，程序 <code>默认加1</code>，所以读取引用计数时为1</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理34：启动优化（三）二进制重排</title>
      <link href="/BboyZJ.github.io/2021/05/17/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8634%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%87%8D%E6%8E%92/"/>
      <url>/BboyZJ.github.io/2021/05/17/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8634%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%87%8D%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在之前的两篇文章中，大致介绍了一些基本概念以及启动优化的思路，下面来着重介绍一个 <code>pre-main阶段</code> 的优化方案，即 <code>二进制重排</code>，这个方案最开始是由抖音的这篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485101&idx=1&sn=abbbb6da1aba37a04047fc210363bcc9&chksm=e9d0cd4fdea7445989cf26623a16fc8ce2876bf3bda95a5532bb0e5e5b1420765653df0b94d1&mpshare=1&scene=1&srcid=0316fLf0VRLHLhRPFDH6LuQo&sharer_sharetime=1595570815854&sharer_shareid=ff29c649ff1b5cea91081f325b5ada59#rd">抖音研发实践：基于二进制文件重排的解决方案 APP启动速度提升超15%</a>提出来的。</p><h1 id="二进制重排实现"><a href="#二进制重排实现" class="headerlink" title="二进制重排实现"></a>二进制重排实现</h1><p>在虚拟内存部分，我们知道，当进程访问一个虚拟内存page，而对应的物理内存不存在时，会触发 <code>缺页中断（Page Fault）</code>，因此阻塞进程，此时就需要先加载数据到物理内存，然后继续访问，这个对性能有一定影响的。如果存在大量的 <code>缺页中断</code>，会非常的耗时。</p><p>基于 <code>Page fault</code>，我们思考，APP在冷却启动过程中，会有大量的类、分类、三方等需要加载和执行，此时产生的 <code>Page Fault</code> 所带来的的耗时是很大的，以 <code>实际项目</code> 为例，我们来看下，在启动阶段的 <code>Page Fault</code> 的次数</p><ul><li><code>CMD + i</code> 快捷键，选择 <code>System Trace</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/153550501-334072e9-9506-48a4-b766-37c7b5f91671.jpg"></p><ul><li>点击启动（启动前需要重启手机，清除缓存数据），第一个界面出来后，停掉，按照下图中操作</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/153550511-77bf402f-7241-4c40-9249-c06cb1646a81.jpg"></p><p>从图中可以看出 实际项目 发生的 <code>Page Fault</code> 有 <code>1101</code> 次，可想而知，这个是非常影响性能的。</p><ul><li>下面，我们通过<code>Demo</code>查看方法在编译时期的排列顺序，在<code>ViewController</code>中按下列顺序定义以下几个方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void test1()&#123;</span><br><span class="line">    printf(&quot;1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test2()&#123;</span><br><span class="line">    printf(&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    test1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    printf(&quot;3&quot;);</span><br><span class="line">    test2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>Build Setting</code> -&gt; <code>write Link Map File</code> 设置为 <code>YES</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/153550546-dffc25ce-e7b9-4724-a110-9b56ec581bbb.jpg"></p><ul><li><code>CMD + B</code> 编译 <code>Demo</code>，查看 <code>执行顺序</code> 打印结果为 <code>3 2 1</code>，那么代码的 <code>加载顺序</code> 是什么？<code>show in finder</code> 在对应路径下查找 <code>link map</code> 文件，如下图所示：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/153550660-f20a7605-0753-4878-abc6-4511d0b60aa8.jpg"></p><ul><li>打开.txt文件，可以发现类中 <code>函数的加载顺序是从上到下</code> 的，而 <code>文件</code> 的顺序是根据 <code>Buid Phases</code> -&gt; <code>Compile Source</code> 中的顺序加载的</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/153550715-7d6ec216-c269-476e-96ec-b0b94a6fcd62.jpg"></p><p><img src="https://user-images.githubusercontent.com/25925248/153550686-70904775-c6d0-4c03-adcf-2a6f5fe65e3a.jpg"></p><ul><li>从上面的 <code>Page fault</code> 的次数以及加载顺序，可以发现其实 <code>导致 Page Fault 次数过多的根本原因是启动时刻需要调用的方法，处于不同的 Page Fault 导致的</code>，因此我们的优化思路就是：<code>将所有启动时刻需要调用的方法，排列在一起，即放在一个页中，这样就从多个 Page Fault变成了一个Page Fault</code>，这就是 <code>二进制重排</code> 的核心原理，如下所示：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/153550819-259ae795-d8e5-4cf0-9a93-9718d489fb91.jpg"></p><p><strong>注意：在iOS生成环境中的APP，在发生Page Fault进行重新加载时，iOS系统还会对其做一次 签名验证，因此 iOS 生产环境的 Page Fault 比 Debug环境下所产生的耗时更多</strong></p><h1 id="二进制重排实践"><a href="#二进制重排实践" class="headerlink" title="二进制重排实践"></a>二进制重排实践</h1><p>下面，我们来进行具体的实践，首先先理解几个名词</p><ul><li><p>Link Map</p><p>  <code>linkmap</code> 是iOS编译过程的中间产物，<code>记录了二进制文件的布局</code>，需要在Xcode的 <code>Build Settings</code> 里面开启 <code>Write Link Map File</code>，Link Map 主要包含三个部分：</p><ul><li><code>Object Files</code> ：生成二进制用到的link单元的路径和文件编号</li><li><code>Sections</code> ：记录Mach-O每个<code>Segment/Section</code>的地址范围</li><li><code>Symbols</code> ：按照顺序记录每个符号的地址范围</li></ul></li><li><p>ld</p><p>  <code>ld</code> 是Xcode使用的链接器，有一个参数 <code>order_file</code>，我们可以通过在 <code>Build Settings</code> -&gt; <code>Order Files</code> 配置一个后缀为 <code>order</code> 的文件路径，在这个 <code>order</code> 文件中，将所需要的符号按照顺序写在里面，在项目编译时，会找找这个文件的顺序进行加载，以此来达到我们的优化</p><p>  所以说，<code>二进制重排的本质就是对启动加载的符号进行重新排列</code></p><p>  到目前为止，原理我们基本弄清楚了，如果项目比较小，完全可以自定义一个 <code>order</code> 文件，将方法的顺序手动添加，但是如果项目比较大，设计到的方法特别多，此时我们如何获取启动运行的函数呢？有以下几种思路：</p><ul><li><p><code>hook objc_msgsSend</code>：我们知道，函数的本质就是发送消息，在底层都会来到 <code>objc_msgSend</code>，但是由于<code>objc_msgSend</code>的参数是可变的，需要通过 汇编 获取，对开发人员要求较高，而且也只能拿到 <code>oc</code> 和 <code>swift</code> 中 <code>@objc</code> 后的方法</p></li><li><p><code>静态扫描</code>：扫描 <code>mach-o</code> 特定段和节里面所存储的符号一级函数数据</p></li><li><p><code>Clang插桩</code>：即 <code>批量hook</code>，可以实现 <code>100%符号覆盖</code>，即完全获取 <code>swift、oc、block</code>函数</p></li></ul></li></ul><h1 id="自定义-order-文件，改变执行顺序"><a href="#自定义-order-文件，改变执行顺序" class="headerlink" title="自定义 order 文件，改变执行顺序"></a>自定义 order 文件，改变执行顺序</h1><ul><li>cd 到 Demo 根目录，新建 order文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangjian@zhangjiandeMBP ~ % cd /Users/zhangjian/Desktop/Demo </span><br><span class="line">zhangjian@zhangjiandeMBP Demo % touch zj.order</span><br></pre></td></tr></table></figure><ul><li>order 文件中书写如下内容</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/154636492-fbca10f0-8a62-4977-bab6-027d13da3c96.jpg"></p><ul><li>在 <code>build setting</code> 搜索 <code>order file</code> 将根目录下的order文件路径填入：<code>./zj.order</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/154636576-08c9d491-00ae-4124-ac2f-1894fc094d4a.jpg"></p><ul><li><code>cmd + b</code> 重新编译，没有报错，说明有一个符号没有找不到会自动或略掉，继续查看 <code>link map</code> 文件</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/154636649-d63b1c4d-c76d-43e6-aa00-769f499f6b3c.jpg"></p><p>由上图可知，main变成第一位、viewDidLoad变成第二位、test1变成第三位，这就是<code>二进制重排</code></p><h1 id="Clang-插桩"><a href="#Clang-插桩" class="headerlink" title="Clang 插桩"></a>Clang 插桩</h1><p>  <code>llvm</code> 内置了一个简单的代码覆盖率检测（<code>SanitizerCoverage</code>），它在函数级、基本块级和边缘级插入对用户定义函数的调用，我们这里的批量hook，就需要借助于 <code>SanitizerCoverage</code></p><p>  关于clang的插桩覆盖的官方文档如下：<a href="http://clang.llvm.org/docs/SanitizerCoverage.html">clang自带代码覆盖工具</a> 文档中有详细概述，以及简短Demo演示</p><ol><li>【第一步：配置】开启 <code>SanitizerCoverage</code></li></ol><ul><li>OC项目，需要在：<code>Build Settings</code> 里面的 <code>Other C Flags</code> 中添加 <code>-fsanitize-coverage=trace-pc-guard</code></li></ul><p>  <img src="https://user-images.githubusercontent.com/25925248/154636785-80b31dc3-d46b-454b-bd32-9cd8b0112f38.jpg"></p><ul><li>此时 <code>CMD + B</code> 编译，会报两个符号错误，说明添加了上面就会调用下面的两个符号： <code>__sanitizer_cov_trace_pc_guard_init</code> 和 <code>__sanitizer_cov_trace_pc_guard</code></li></ul><p>  <img src="https://user-images.githubusercontent.com/25925248/154636804-8a345df2-4723-41f2-9a6c-2210b0a87b69.jpg"></p><ol start="2"><li>【第二步：重写方法】</li></ol><ul><li>将官方文档中的两个方法拷贝到 <code>TraceDemo</code> 项目中，如下图所示并运行，会报错找不 到 <code>__sanitizer_symbolize_pc</code>，我们将其注释，再次运行，成功</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">// trace-pc-guard-cb.cc</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sanitizer/coverage_interface.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test1()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void (^block1)(void) = ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,</span><br><span class="line">                                                    uint32_t *stop) &#123;</span><br><span class="line">  static uint64_t N;  // Counter for the guards.</span><br><span class="line">  if (start == stop || *start) return;  // Initialize only once.</span><br><span class="line">  printf(&quot;INIT: %p %p\n&quot;, start, stop);</span><br><span class="line">  for (uint32_t *x = start; x &lt; stop; x++)</span><br><span class="line">    *x = ++N;  // Guards should start from 1.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123;</span><br><span class="line">  // 将load方法过滤掉了，所以需要注释掉</span><br><span class="line">  if (!*guard) return;</span><br><span class="line">  // 获取PC</span><br><span class="line">  /*</span><br><span class="line">    - PC 当前函数返回上一个调用的地址</span><br><span class="line">    - 0 当前这个函数地址，即当前函数的返回地址</span><br><span class="line">    - 1 当前函数调用者的地址，即上一个函数的返回地址</span><br><span class="line">  */</span><br><span class="line">  void *PC = __builtin_return_address(0);</span><br><span class="line">  char PcDescr[1024];</span><br><span class="line">  // 再次运行这个符号找不到，找不到我就不调用了吗，删掉</span><br><span class="line">  // __sanitizer_symbolize_pc(PC, &quot;%p %F %L&quot;, PcDescr, sizeof(PcDescr));</span><br><span class="line">  printf(&quot;guard: %p %x PC %s\n&quot;, guard, *guard, PcDescr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    test1();</span><br><span class="line">    block1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>__sanitizer_cov_trace_pc_guard_init 方法</p><ul><li>由上面运行结果可知，<code>start</code> &#x3D; <code>0x10204d3a0</code>，<code>stop</code> &#x3D; <code>0x10204d3d8</code>,那么这个是什么意思呢？</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/154636878-b572902c-b916-4e3d-b833-c570a3bd4138.jpg"></p><ul><li>参数1 <code>start</code> 是一个指针，指向无符号intl类型，4个字节，相当于一个数组的 <code>起始位置</code>，即符号的起始位置（是从高位往低位读）</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/154636896-96fc6218-d008-4022-a8b1-e842272f1141.jpg"></p><ul><li>参数2 <code>stop</code> ，由于数据的地址是往下读的（即 从高往低读，所以此时获取的地址并不是stop真正的地址，而是标记的最后的地址，读取stop时，由于stop占了4个字节，stop 真实地址 &#x3D; stop打印的地址-0x4）</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/154637021-fec3105e-1d37-4254-ba1a-ec49e5fc7f54.jpg"></p><ul><li>stop 内存地址中存储的值表示什么？在增加一个 <code>方法/block/属性</code> 后，发现其值也会增加对应的数，例如增加一个 touchesBegan方法，运行并打印得到 <code>INIT: 0x104f0d3a8 0x104f0d3e4</code>，重新查看 <code>start</code> 和 <code>stop</code> 的值：</li></ul><p> <img src="https://user-images.githubusercontent.com/25925248/154637039-e0e93bba-7f67-4de0-940e-fd2a7619a8b9.jpg"></p><p><strong>由此可见 增加一个方法 对应 stop值就增加一个</strong></p></li></ul><ol start="3"><li>【第三步：通过返回地址拿到符号】</li></ol><ul><li><p><code>__sanitizer_cov_trace_pc_guard</code> 方法，主要是捕获所有的启动时刻的符号，将所有符号入队</p><ul><li><p>参数 <code>guard</code> 是一个 <code>哨兵</code>，告诉我们是 <code>第几个被调用的</code></p></li><li><p>引入库 <code>#import &lt;dlfcn.h&gt;</code> ，并点击屏幕可以通过返回地址拿到符号</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123;</span><br><span class="line">    if (!*guard) return;</span><br><span class="line">    // 当前返回上一个调用的地址</span><br><span class="line">    void *PC = __builtin_return_address(0);</span><br><span class="line">    // 通过返回地址PC，获取符号</span><br><span class="line">    Dl_info info;</span><br><span class="line">    dladdr(PC, &amp;info);</span><br><span class="line">    printf(&quot;frame:%s \nfbase:%p \nsname:%s \nsaddr:%p\n\n&quot;,info.dli_fname,info.dli_fbase,info.dli_sname,info.dli_saddr);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    char PcDescr[1024];</span><br><span class="line">    // 再次运行这个符号找不到，找不到我就不调用了吗，删掉</span><br><span class="line">    // y__sanitizer_symbolize_pc(PC, &quot;%p %F %L&quot;, PcDescr, sizeof(PcDescr));</span><br><span class="line">    // printf(&quot;guard: %p %x PC %s\n&quot;, guard, *guard, PcDescr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  查看打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 文件的内存地址</span><br><span class="line">frame:/private/var/containers/Bundle/Application/A9B590E7-FC2A-4C54-85C1-FFFE55ACE448/TraceDemo.app/TraceDemo </span><br><span class="line">// 文件内存地址</span><br><span class="line">fbase:0x10251c000 </span><br><span class="line">// 符号名称</span><br><span class="line">sname:-[ViewController touchesBegan:withEvent:] </span><br><span class="line">// 起始位置地址</span><br><span class="line">saddr:0x102521b78</span><br><span class="line"></span><br><span class="line">frame:/private/var/containers/Bundle/Application/A9B590E7-FC2A-4C54-85C1-FFFE55ACE448/TraceDemo.app/TraceDemo </span><br><span class="line">fbase:0x10251c000 </span><br><span class="line">sname:test1 </span><br><span class="line">saddr:0x1025219e0</span><br><span class="line"></span><br><span class="line">frame:/private/var/containers/Bundle/Application/A9B590E7-FC2A-4C54-85C1-FFFE55ACE448/TraceDemo.app/TraceDemo </span><br><span class="line">fbase:0x10251c000 </span><br><span class="line">sname:block1_block_invoke </span><br><span class="line">saddr:0x1025219fc</span><br></pre></td></tr></table></figure><ol start="4"><li>【第四步：创建队列保存符号】</li></ol><ul><li><p>引入头文件 <code>#import &lt;OSAtomic.h&gt;</code>，符号的存储需要借助于链表，所以需要定义链表节点 ZJNode</p></li><li><p>通过 OSQueueHead 创建原子队列，其目的是保证线程安全</p></li><li><p>通过 OSAtomicEnqueue 方法将 node 入队，通过链表 next 指针可以访问下一个符号</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 原子队列-线程安全</span><br><span class="line">static OSQueueHead symbolList = OS_ATOMIC_QUEUE_INIT;</span><br><span class="line"></span><br><span class="line">// 定义符号结构体，以链表的形式</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    // 指针8个字节</span><br><span class="line">    void *pc;</span><br><span class="line">    void *next;</span><br><span class="line">&#125;ZJNode;</span><br><span class="line"></span><br><span class="line">void __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123;</span><br><span class="line">    // 将load方法过滤掉了，所以需要注释掉</span><br><span class="line">    if (!*guard) return;</span><br><span class="line">    // 当前返回上一个调用的地址</span><br><span class="line">    void *PC = __builtin_return_address(0);</span><br><span class="line">    </span><br><span class="line">    // 创建结构体</span><br><span class="line">    ZJNode * node = malloc(sizeof(ZJNode));</span><br><span class="line">    *node = (ZJNode)&#123;PC,NULL&#125;;</span><br><span class="line">    </span><br><span class="line">    // 加入结构体</span><br><span class="line">    // 符号的访问不是通过下标访问，是通过链表的next指针，所以需要借用offsetof（结构体类型，下一个的地址即next）</span><br><span class="line">    OSAtomicEnqueue(&amp;symbolList, node, offsetof(ZJNode, next));</span><br><span class="line">    </span><br><span class="line">    // 通过返回地址PC，获取符号</span><br><span class="line">    Dl_info info;</span><br><span class="line">    dladdr(PC, &amp;info);</span><br><span class="line">    // printf(&quot;frame:%s \nfbase:%p \nsname:%s \nsaddr:%p\n\n&quot;,info.dli_fname,info.dli_fbase,info.dli_sname,info.dli_saddr);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    char PcDescr[1024];</span><br><span class="line">    // 再次运行这个符号找不到，找不到我就不调用了吗，删掉</span><br><span class="line">    // y__sanitizer_symbolize_pc(PC, &quot;%p %F %L&quot;, PcDescr, sizeof(PcDescr));</span><br><span class="line">    // printf(&quot;guard: %p %x PC %s\n&quot;, guard, *guard, PcDescr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    while (YES) &#123; // 一次循环！也会被HOOK一次</span><br><span class="line">        ZJNode * node = OSAtomicDequeue(&amp;symbolList, offsetof(ZJNode, next));</span><br><span class="line">        if (node == NULL) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        Dl_info info = &#123;0&#125;;</span><br><span class="line">        dladdr(node-&gt;pc, &amp;info);</span><br><span class="line">        printf(&quot;%s \n&quot;,info.dli_sname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>【第五步：解决死循环问题】</li></ol><ul><li>当我们重新运行，点击屏幕，会发现一直重新打印，出现死循环 <code>touchesBegan</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/154637158-b062d257-017c-4362-9c17-c01fb0da2994.jpg"></p><ul><li>我们打开汇编调式，发现有 <code>3</code> 个 <code>__sanitizer_cov_trace_pc_guard</code> 调用</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/154637186-68c60d8f-9f70-4561-a2ad-60be2776e602.jpg"></p><ul><li><p>第一次 bl 是 <code>touchBegin</code>；第二次是因为 while 循环，即只要是 跳转，就会被 hook，即有 bl&#x2F;b 的指令，就会被 hook；第三次就 printf</p></li><li><p>解决方式：将 <code>Build Setting</code> 中的 <code>Other C Flags</code> 的 <code>-fsanitize-coverage=trace-pc-guard</code> 改成 <code>-fsanitize-coverage=func,trace-pc-guard</code>，再次运行，看下面的结果显示已经没有死循环了</p></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/154637280-560a81a8-55cc-4b90-9da8-c4b451e2ded8.jpg"></p><p>由上面的结果可知，还有几个问题需要解决：<code>重复、顺序是反的，并且没有load</code></p><ol start="6"><li>【第六步：生成数组去重、取反】</li></ol><ul><li>添加 <code>+ load</code> 方法（需要注释掉<code>if (!*guard) return;</code>这句代码）、调用<code>test、block</code>方法，重新点击屏幕并查看结果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test()&#123;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void (^block)(void) = ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>查看打印结果</p><p><img src="https://user-images.githubusercontent.com/25925248/154637311-90ebb586-2602-4cd0-ae6b-f11ebf7d30e7.jpg"></p><ul><li>取反、去重</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 定义数组</span><br><span class="line">    NSMutableArray&lt;NSString *&gt; * symbolNames = [NSMutableArray array];</span><br><span class="line">    </span><br><span class="line">    while (YES) &#123;</span><br><span class="line">        ZJNode * node = OSAtomicDequeue(&amp;symbolList, offsetof(ZJNode, next));</span><br><span class="line">        if (node == NULL) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        Dl_info info = &#123;0&#125;;</span><br><span class="line">        dladdr(node-&gt;pc, &amp;info);</span><br><span class="line">//        printf(&quot;%s \n&quot;,info.dli_sname);</span><br><span class="line">        // 转成字符串</span><br><span class="line">        NSString * name = @(info.dli_sname);</span><br><span class="line">        </span><br><span class="line">        if ([name hasPrefix:@&quot;+[&quot;] ||</span><br><span class="line">            [name hasPrefix:@&quot;-[&quot;]) &#123;</span><br><span class="line">            // 如果是oc方法名称直接存</span><br><span class="line">            [symbolNames addObject:name];</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果不是oc直接加个_存</span><br><span class="line">        [symbolNames addObject:[@&quot;_&quot; stringByAppendingString:name]];</span><br><span class="line">    &#125;</span><br><span class="line">    // 反向遍历数组</span><br><span class="line">    symbolNames = (NSMutableArray&lt;NSString *&gt; *)[[symbolNames reverseObjectEnumerator] allObjects];</span><br><span class="line">    // 去重</span><br><span class="line">    NSEnumerator * enumerator = [symbolNames reverseObjectEnumerator];</span><br><span class="line">    NSMutableArray * funcs = [NSMutableArray arrayWithCapacity:symbolNames.count];</span><br><span class="line">    NSString * name;</span><br><span class="line">    while (name = [enumerator nextObject])&#123;</span><br><span class="line">        // 数组中不包含name</span><br><span class="line">        if (![funcs containsObject:name]) &#123;</span><br><span class="line">            [funcs addObject:name];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,funcs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行，查看打印结果</p><p><img src="https://user-images.githubusercontent.com/25925248/154637336-a703638a-af00-4cfe-9be8-e62ed038079f.jpg"></p><ol start="7"><li>【第七步：生成order文件】</li></ol><ul><li>数组转成字符串</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 数组转成字符串</span><br><span class="line">    NSString * funcStr = [symbolNames componentsJoinedByString:@&quot;\n&quot;];</span><br></pre></td></tr></table></figure><ul><li>字符串写入文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 字符串写入文件</span><br><span class="line">    // 文件路径</span><br><span class="line">    NSString * filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;zj.order&quot;];</span><br><span class="line">    // 文件内容</span><br><span class="line">    NSData * fileContents = [funcStr dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    [[NSFileManager defaultManager] createFileAtPath:filePath contents:fileContents attributes:nil];</span><br></pre></td></tr></table></figure><ol start="8"><li>【第八步：找到order文件，并配置order文件】</li></ol><ul><li>CMD + shift + 2 -&gt; Devices -&gt; TraceDemo -&gt; Download Container 将文件下载到桌面 -&gt; 显示包内容 -&gt; tmp -&gt; 找到 zj.order</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/154637366-41b1ddba-b743-44fc-b335-4e7f254f37ab.jpg"></p><p><img src="https://user-images.githubusercontent.com/25925248/154637576-d4b10778-8f23-4645-a2f9-1a0a4f4ac21a.jpg"></p><ul><li>配置 zj.order 到项目中，首先 <code>link map</code> 设值为 YES，配置前：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/154637651-138f1b3f-d460-48d4-9b4c-83bf737e601b.jpg"></p><ul><li>将 zj.order放在根目录，配置 <code>order file</code> 为 <code>./zj.order</code> ，配置后：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/154637674-1670006a-562b-4d89-9a99-4b8b6aff9d82.jpg"></p><ul><li>此时发现配置后的执行顺序和配置前的执行顺序有明显的区别，此时此时 <code>二进制重排成功</code>。</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul><li><p>如果是Swift项目，还需要额外在 <code>Other Swift Flags</code> 中加入 <code>-sanitize-coverage=func</code> 和 <code>-sanitize=undefined</code></p></li><li><p>OC 和 swift 混编</p></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/154637708-149724a0-b257-421a-892e-45b3e97b71c5.jpg"></p><ul><li>OC 中引入头文件</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/154637927-259806b4-368b-4365-87c2-aa58e8c8ae1e.jpg"></p><p><img src="https://user-images.githubusercontent.com/25925248/154637952-8831a914-a13f-4e3c-bb59-c0c3199cb46b.jpg"></p><ul><li>按照上面的进行配置并查看 zj.order</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/154637975-543b5944-1382-4dfe-906b-87d5cc8a5b1d.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理33：启动优化（二）优化建议</title>
      <link href="/BboyZJ.github.io/2021/05/11/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8633%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/"/>
      <url>/BboyZJ.github.io/2021/05/11/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8633%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="冷启动和热启动"><a href="#冷启动和热启动" class="headerlink" title="冷启动和热启动"></a>冷启动和热启动</h1><p>启动的过程一般是指 <code>从用户点击APP图标</code> 到 <code>进入到APP页面</code> 的过程，一般在iOS开发中分为 <code>冷启动</code> 和 <code>热启动</code></p><ul><li><p><code>冷启动</code>：用户将 <code>设备重启</code> 或者是 <code>手动kill掉APP进程</code>，又或者是 <code>APP长时间未打开过</code>，当用户点击启动APP图标的过程，这时需要创建一个新的 <code>进程</code> 分配给APP，并且内存中 <code>不包含任何数据</code>，必须从磁盘中载入数据到内存中的过程。</p></li><li><p><code>热启动</code>：用户在使用APP过程中，按下 <code>Home键</code>，APP不会立即被kill掉，而是存活一段时间，这段时间里用户再打开APP，此时APP还在退到后台前的状态，APP进程还在系统中，无需开启新的进程，APP也不会重新加载数据到内存中的过程。</p></li></ul><h1 id="启动优化概念"><a href="#启动优化概念" class="headerlink" title="启动优化概念"></a>启动优化概念</h1><p>WWDC <code>2016</code> 中首次出现了APP启动优化的话题，其中提到：</p><ul><li><code>App启动最佳速度是400ms以内</code> ，因为从点击App图标启动，然后 <code>Launch Screen</code> 出现再消失的时间就是400ms。</li><li><code>App启动最慢不得大于20s</code> ，否则进程会被系统杀死</li></ul><p>我们这里所说的启动优化，一般是指 <code>冷启动</code> 情况下的启动优化，是指用户唤起App开始到<code>AppDelegate</code> 中的 <code>didFinishLaunchingWithOptions</code> 方法执行完毕为止，并以 <code>main()</code> 函数为分界点，分为 <code>pre-main</code> 和 <code>main()</code> 两个阶段：</p><ul><li><code>pre-main</code> 阶段：是指从用户唤起App到 <code>main()</code> 函数执行之前的过程</li><li><code>main()</code> 阶段：是指 <code>main()</code> 函数开始执行到 <code>didFinishLaunchingWithOptions</code> 方法执行结束的过程</li></ul><p>所以， <code>pre-main() + main()</code> 的过程就是从用户点击App图标到用户能看到主界面的过程，即需要优化的部分。</p><h1 id="pre-main-启动优化"><a href="#pre-main-启动优化" class="headerlink" title="pre-main()启动优化"></a>pre-main()启动优化</h1><p>我们在前面 <a href="">OC底层原理15：dyld源码分析</a> 中，已经了解了dyld的加载流程，<code>pre-main()</code> 阶段的 <code>启动时间</code> 就是 <code>dyld加载过程的时间</code></p><p>针对 <code>pre-main()</code> 阶段的启动时间，苹果提供了APP启动时间检测方法，在 <code>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Environment Variables</code> 点击 <code>+</code> 号添加环境变量 <code>DYLD_PRINT_STATISTICS</code> 设为 <code>1</code>，如下图：</p><p><img src="https://user-images.githubusercontent.com/25925248/116049036-68ecd480-a6a8-11eb-9064-adbe420d5acc.png"></p><p>然后运行，以下是 <code>手机型号iPhone11 14.4.2</code> 启动的我目前正在开发的电商项目的<code>pre-main()</code>时间：</p><p><img src="https://user-images.githubusercontent.com/25925248/116048789-23c8a280-a6a8-11eb-83bf-393c03c9ba57.png"></p><p>如果想要更加详细的信息，就设置 <code>DYLD_PRINT_STATISTICS_DETAILS</code> 为 <code>1</code>，得到以下信息：</p><p><img src="https://user-images.githubusercontent.com/25925248/116049978-8a9a8b80-a6a9-11eb-9d04-f67980e50376.png"></p><p><strong>说明</strong><br><code>pre-main</code> 阶段总共用时 <code>1.3s</code></p><ul><li><p><code>dylib loading time</code> (动态库耗时)：主要是加载动态库，用时 <code>336.24ms</code></p></li><li><p><code>rebase/binding time</code> (偏移修正&#x2F;符号绑定耗时)，耗时 <code>61.26ms</code></p><ul><li><p><code>rebase</code>（偏移修正）：任何一个App生成的二进制文件，在二进制文件内部所有的方法、函数调用，都有一个地址，这个地址是在 <code>当前二进制文件中的偏移地址</code>。一旦在运行时刻（即运行到内存中），每次系统都会 随机分配一个<code>ASLR(Address Space Layout Randomization，赋值空间布局随机化)</code>地址值（是一个安全机制，会分配一个随机的数值，插入在二进制文件的开头），例如，二进制文件中有一个test方法，偏移值是 0x001，而随机分配的 <code>ASLR</code> 是 <code>0x1000</code>，如果想访问test方法，其内存地址（即真是地址）变为 <code>ASLR+偏移值 = 运行时确定的内存地址（即0x1000 + 0x0001 = 0x1001）</code></p></li><li><p><code>binding</code>（绑定）：例如 NSLog方法，在编译时期 生成的 <code>mach-o文件中</code>，会创建一个符号 <code>!NSLog</code>（目前指向一个随机的地址），然后在运行时（从磁盘加载到内存中，是一个镜像文件），会将真正的地址给符号（即在内存中将地址与符号进行绑定，是 <code>dyld</code> 做的，也称为 <code>动态库符号绑定</code>），一句话概括：<code>绑定就是给符号赋值的过程</code></p></li></ul></li><li><p><code>Objc setup time</code>（OC类注册的耗时）：<code>OC</code> 类越多，越耗时</p></li><li><p><code>initializer time</code> ：（执行load和构造函数的耗时）</p></li></ul><p>针对这几部，有以下几点优化建议：</p><ul><li><p>尽量 <code>少用外部动态库</code>，苹果官方建议自定义的动态库最好 <code>不要超过6个</code>，如果超过6个，需要 <code>合并</code> 动态库</p></li><li><p>减少 <code>OC</code> 类，因为类越多，越耗时</p></li><li><p>将不必须在 <code>+load</code> 方法中做的事情延迟到 <code>+initialize</code> 中，尽量不要用 <code>C++</code> 虚函数</p></li><li><p>如果是Swift，尽量使用 <code>struct</code></p></li></ul><h1 id="main-函数阶段的优化"><a href="#main-函数阶段的优化" class="headerlink" title="main 函数阶段的优化"></a>main 函数阶段的优化</h1><p>在 <code>main</code> 函数之后的 <code>didFinishLaunching</code> 方法中，主要是执行了各种业务，有很多并不是必须在这里执行的，这种业务我们可以采取 <code>延迟加载</code>，防止影响启动时间</p><p>在 <code>didFinishLaunching</code> 中的业务主要分为三个阶段</p><ul><li>【第一类】初始化第三方sdk</li><li>【第二类】App运行环境配置</li><li>【第三类】自己工具类的初始化等</li></ul><p><code>main</code>函数阶段的优化建议主要有以下几点：</p><ul><li><p>减少启动初始化的流程，能懒加载的懒加载，能延迟的延迟，能放后台初始化的放后台，尽量少占用主线程的启动时间</p></li><li><p>优化代码逻辑，去除非必须的代码逻辑，减少每个流程的消耗时间</p></li><li><p>启动阶段能 <code>使用多线程</code> 来初始化的，就使用多线程</p></li><li><p>尽量 <code>使用纯代码</code> 来进行UI框架的搭建，尤其是主UI框架，例如 UITabBarController，尽量避免使用Xib或者SB，相比纯代码而言，这种更耗时</p></li><li><p>删除废弃类、方法</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理32：启动优化（一）基本概念</title>
      <link href="/BboyZJ.github.io/2021/05/04/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8632%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/BboyZJ.github.io/2021/05/04/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8632%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>早期的 <code>数据访问</code> 是直接通过 <code>物理地址</code> 访问 <code>物理内存</code>，而物理内存是有 <code>固定大小的</code>，这种方式有以下两个问题：</p><ul><li><code>1.内存不够用</code></li><li><code>2.内存数据的安全问题</code></li></ul><h1 id="内存不够用的解决方案：虚拟内存"><a href="#内存不够用的解决方案：虚拟内存" class="headerlink" title="内存不够用的解决方案：虚拟内存"></a>内存不够用的解决方案：虚拟内存</h1><p>针对问题1，我们在 <code>进程和物理内存</code> 之间增加一个 <code>中间层</code>，这个中间层就是所谓的 <code>虚拟内存</code>，主要用于解决当多个进程同时存在时，对物理内存的管理，<code>提高了CPU的利用率，使多个进程可以同时、按需加载</code>，所以虚拟内存其本质就是 <code>一张虚拟地址和物理地址对应关系的映射表</code></p><ul><li><p><code>每个进程</code>都有一个独立的 <code>虚拟内存</code>，其地址都是 <code>从0开始</code>，到最后结束，大小是 <code>4G</code>固定的，每个虚拟内存又划分为一个一个的 <code>页</code>，所有页放在一起组成 <code>页表</code>，统称 <code>虚拟内存分页管理</code>，页的大小在 <code>iOS中是16K，Linux、MacOS等是4K</code>，每次加载都是以<code>页</code>为单位加载的，进程间是无法互相访问的，保证了进程间数据的安全性。</p></li><li><p>一个进程中，只有部分功能是活跃的，所以只需要 <code>将进程中活跃的部分放入物理内存</code>，避免物理内存的浪费</p></li><li><p>当 <code>CPU</code> 需要 <code>访问数据</code> 时，首先是访问<code>虚拟内存</code>，然后通过<code>虚拟内存地址寻址</code>，这个虚拟地址在被送到内存条之前先转换为物理地址，这个转换的过程叫 <code>地址翻译（需要CPU的硬件MMU和操作系统配合）</code>，即可以理解为在 <code>虚拟地址和物理地址对应表</code> 中找到对应的 <code>物理地址</code>，然后对相应的物理地址进行访问</p></li><li><p>如果在访问时，虚拟地址的内容未加载到物理内存，会发生<code>缺页异常（pagefault）</code>，将当前进程阻塞掉，此时操作系统需要先将数据载入到物理内存中，这个过程很快用户感知不到（每页16K），然后再寻址，进行读取。这样就避免了内存浪费。</p></li><li><p>如果在访问时，物理内存满了，操作系统会将 <code>新数据将旧数据覆盖</code></p></li></ul><p>如下图所示，<code>虚拟内存与物理内存</code>间的关系：</p><p><img src="https://user-images.githubusercontent.com/25925248/126608815-dfb1e740-c280-448e-968e-05a7986cf594.png"></p><h1 id="内存数据安全问题的解决方案：ASLR技术"><a href="#内存数据安全问题的解决方案：ASLR技术" class="headerlink" title="内存数据安全问题的解决方案：ASLR技术"></a>内存数据安全问题的解决方案：ASLR技术</h1><p>在上面解释的虚拟内存中，我们提到了<code>虚拟内存的起始地址与大小都是固定的</code>，这意味着，当我们访问时，其数据的地址也是固定的，这会导致我们的数据非常容易被破解，为了解决这个问题，所以苹果为了解决这个问题，在iOS4.3开始引入了 <code>ASLR</code>技术。</p><p><code>ASLR</code> 的概念：（Address Space Layout Randomization）<code>地址空间配置随机加载</code>，是一种 <code>针对缓冲区溢出</code> 的 <code>安全保护技术</code>，通过对<code>堆、栈、共享库映射等线性区布局的随机化</code>，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。</p><p>其目的通过 <code>利用随机方式配置数据地址空间</code>，使某些敏感数据（例如App登录注册、支付相关代码）配置到一个恶意程序无法事先获知的地址，令攻击者难以进行攻击</p><p>由于<code>ASLR</code>的存在，导致<code>可执行文件和动态链接库</code>在虚拟内存中的 <code>记载地址每次启动都不固定</code> ，所以需要在编译时来修复镜像中的资源指针，来指向正确的地址，即 <code>正确的内存地址 = ASLR地址 + 偏移值</code></p><h1 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h1><p>不同的操作系统，其可执行文件的格式也不同，<code>系统内核</code> 将 <code>可执行文件</code> 读取到 <code>内存</code>，然后根据可执行文件的 <code>头签名（magic魔数）</code>判断二进制文件的格式。</p><table><thead><tr><th>可执行文件</th><th>魔数</th><th>用途</th></tr></thead><tbody><tr><td>PE32&#x2F;PE32+</td><td>MZ</td><td>Windows的可执行文件</td></tr><tr><td>ELF</td><td>\x7FFLF</td><td>Linux和大部分UNIX的可执行文件和库文件</td></tr><tr><td>脚本</td><td>#!</td><td>主要用于shell脚本，也有一些解释器脚本使用这个格式，这是一种特殊的二进制文件格式，#!后面指向真正的可执行文件（比如python），而脚本其他内容，都被当做输入传递给这个命令</td></tr><tr><td>通用二进制格式（胖二进制格式）</td><td>Oxcafebabe(小端)</td><td>包含多种架构支持的Mach-O格式，iOS和OS X支持的格式</td></tr><tr><td>Mach-O</td><td>0xfeedface(32位) 0xfeedfacf(64位)</td><td>iOS和OS X支持的格式</td></tr></tbody></table><p>其中 <code>PE、ELF、Mach-O</code> 这三种可执行文件格式都是 <code>COFF(Command file format)</code>格式的变种，COFF的主要贡献是目标文件里面 <code>引入了 段 的机制</code>，不同的目标文件可以拥有不同数量和不同类型的 <code>段</code>、</p><h1 id="通用二进制文件"><a href="#通用二进制文件" class="headerlink" title="通用二进制文件"></a>通用二进制文件</h1><p>因为不同的<code>CPU</code>平台支持的指令不同，比如 <code>arm64</code> 和 <code>x86</code>，苹果中的通用二进制格式就是 <code>将多种架构的Mach-O文件打包在一起</code>，然后系统根据自己的CPU平台，选择合适的 <code>Mach-O</code>，所以 <code>通用二进制格式</code>又被称为 <code>胖二进制格式</code>，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/126613671-75080877-4869-48da-8928-cb5b4f698136.png"></p><p>通用二进制格式的定义在 <code>&lt;Mach-O/fat.h&gt;中</code>，可以下载<a href="https://opensource.apple.com/tarballs/xnu/">xnu</a>，然后根据 <code>xnu -&gt;EXTERNAL_HEADERS -&gt;mach-o</code>中找到该文件，通用二进制文件开始的 <code>Fat Header</code> 是 <code>fat_header</code> 结构体，而 <code>Fat Archs</code> 是表示通用二进制文件中有多少个 <code>Mach-O</code>，单个  <code>Mach-O</code> 的描述是通过 <code>fat_arch</code> 结构体。两个结构体的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> - magic：可以让系统内核读取该文件时知道是通用二进制文件</span><br><span class="line"> - nfat_arch：表明下面有多个fat_arch结构体，即通用二进制文件包含多少个Mach-O</span><br><span class="line"> */</span><br><span class="line">struct fat_header &#123;</span><br><span class="line">    uint32_t    magic;      /* FAT_MAGIC */</span><br><span class="line">    uint32_t    nfat_arch;  /* number of structs that follow */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> fat_arch是描述Mach-O</span><br><span class="line"> - cputype 和 cpusubtype：说明Mach-O适用的平台</span><br><span class="line"> - offset（偏移）、size（大小）、align（页对齐）描述了Mach-O二进制位于通用二进制文件的位置</span><br><span class="line"> */</span><br><span class="line">struct fat_arch &#123;</span><br><span class="line">    cpu_type_t  cputype;    /* cpu specifier (int) */</span><br><span class="line">    cpu_subtype_t   cpusubtype; /* machine specifier (int) */</span><br><span class="line">    uint32_t    offset;     /* file offset to this object file */</span><br><span class="line">    uint32_t    size;       /* size of this object file */</span><br><span class="line">    uint32_t    align;      /* alignment as a power of 2 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以，综上所述</p><ul><li><p>通用二进制文件是苹果公司提出的一种新的二进制文件的存储结构，可以 <code>同时存储多种架构的二进制指令</code>，使CPU在读取该二进制文件时可以自动检测并选用合适的架构，以最理想的方式进行读取。</p></li><li><p>由于通用二进制文件会同时存储多种架构，所以比单一架构的二进制文件大很多，会占用大量的磁盘空间，但由于系统会自动选择最合适的，不相关的架构代码不会占用内存空间，且<code>执行效率高</code>了</p></li><li><p>还可以通过指令来进行Mach-O的合并与拆分</p><ul><li>查看当前Mach-O的架构：<code>lipo -info MachO文件</code></li><li>合并：<code>lipo -create MachO1 MachO2 -output 输出文件路径</code></li><li>拆分：<code>lipo MachO文件 –thin 架构 –output 输出文件路径</code></li></ul></li></ul><h1 id="Mach-O文件"><a href="#Mach-O文件" class="headerlink" title="Mach-O文件"></a>Mach-O文件</h1><p><code>Mach-O</code>文件是<code>Mach Object</code>文件格式的缩写，它是用于可执行文件、动态库、目标代码的文件格式。作为<code>a.out</code>格式的替代，<code>Mach-O</code>格式提供了更强的扩展性，以及更快的符号表信息访问速度</p><p>熟悉Mach-O文件格式，有助于更好的理解苹果底层的运行机制，更好的掌握dyld加载Mach-O的步骤。</p><p><strong>查看Mach-O文件</strong></p><p>如果想要查看具体的 <code>Mach-O</code> 文件信息，可以通过以下 <code>两种</code> 方式，<code>推荐</code> 使用 <code>第二种</code> 方式，更直观：</p><ul><li>【方式一】<code>otool</code>终端命令：<code>otool -l Mach-O文件名</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/153368597-a97b5b2b-8e07-4767-a6e1-7e1f7daebed0.jpg"></p><ul><li>【方式二】<code>MachOView</code> 工具（推荐）：将Mach-O可执行文件拖动到<code>MachOView</code>工具打开：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/153368655-4e06a6c3-0832-42d0-8255-95b9e4521798.jpg"></p><h1 id="Mach-O文件格式"><a href="#Mach-O文件格式" class="headerlink" title="Mach-O文件格式"></a>Mach-O文件格式</h1><p>对于OS X 和 iOS来说，Mach-O是其<code>可执行文件的格式</code>，主要包括以下几种文件类型</p><ul><li><code>Excutable</code>：可执行文件</li><li><code>Dylib</code>：动态链接库</li><li><code>Bundle</code>：无法被链接的动态库，只能在运行时使用dlopen加载</li><li><code>Image</code>：指的是Excutable、Dylib和Bundle的一种</li><li><code>Framework</code>：包含Dylib、资源文件和头文件的集合</li></ul><p>下面图示是Mach-O镜像文件格式：</p><p><img src="https://user-images.githubusercontent.com/25925248/126616605-09779701-20fc-4b11-8401-a57499ea413f.png"></p><p><strong>以上是Mach-O文件的格式，一个完成的Mach-O文件主要分为三大部分：</strong></p><ul><li><p><code>Header Mach-O头部</code>：主要是Mach-O的cpu架构，文件类型以及加载命令等信息</p></li><li><p><code>Load Commands 加载命令</code>：描述了文件中数据的具体组织结构，不同的数据类型使用不同的加载命令表示</p></li><li><p><code>Data 数据</code>：数据中的每个段（segment）的数据都保存在这里，段的概念与ELF文件中段的概念类似。每个段都有一个或多个部分，它们放置了具体的数据与代码，主要包含代码，数据，例如符号表，动态符号表等等</p></li></ul><h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>Mach-O的<code>Header</code>包含了<code>整个Mach-O文件的关键信息</code>，使得CPU能快速知道Mac-O的基本信息，其在<code>Mach.h</code>（路径同前文的fat.h一致）针对<code>32</code>位和<code>64</code>位架构的cpu，分别使用了<code>mach_header</code>和<code>mach_header_64</code>结构体来<code>描述Mach-O头部</code>。<code>mach_header</code>是连接器加载时最先读取的内容，决定了一些基础架构、系统类型、指令条数等信息，这里查看64位架构的<code>mach_header_64</code>结构体定义，相比于32位架构的<code>mach_header</code>，只是多了一个<code>reserved</code>保留字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> - magic：0xfeedface(32位) 0xfeedfacf(64位)，系统内核用来判断是否是mach-o格式</span><br><span class="line"> - cputype：CPU类型，比如ARM</span><br><span class="line"> - cpusubtype：CPU的具体类型，例如arm64、armv7</span><br><span class="line"> - filetype：由于可执行文件、目标文件、静态库和动态库等都是mach-o格式，所以需要filetype来说明mach-o文件是属于哪种文件</span><br><span class="line"> - ncmds：sizeofcmds：LoadCommands加载命令的条数（加载命令紧跟header之后）</span><br><span class="line"> - sizeofcmds：LoadCommands加载命令的大小</span><br><span class="line"> - flags：标志位标识二进制文件支持的功能，主要是和系统加载、链接有关</span><br><span class="line"> - reserved：保留字段</span><br><span class="line"> */</span><br><span class="line">struct mach_header_64 &#123;</span><br><span class="line">    uint32_t    magic;      /* mach magic number identifier */</span><br><span class="line">    cpu_type_t  cputype;    /* cpu specifier */</span><br><span class="line">    cpu_subtype_t   cpusubtype; /* machine specifier */</span><br><span class="line">    uint32_t    filetype;   /* type of file */</span><br><span class="line">    uint32_t    ncmds;      /* number of load commands */</span><br><span class="line">    uint32_t    sizeofcmds; /* the size of all the load commands */</span><br><span class="line">    uint32_t    flags;      /* flags */</span><br><span class="line">    uint32_t    reserved;   /* reserved */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中<code>filetype</code>主要记录Mach-O的文件类型，常用的有以下几种:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define MH_OBJECT   0x1     /* 目标文件*/</span><br><span class="line">#define MH_EXECUTE  0x2     /* 可执行文件*/</span><br><span class="line">#define MH_DYLIB    0x6     /* 动态库*/</span><br><span class="line">#define MH_DYLINKER 0x7     /* 动态链接器*/</span><br><span class="line">#define MH_DSYM     0xa     /* 存储二进制文件符号信息，用于debug分析*/</span><br></pre></td></tr></table></figure><p>相对应的，Header在MachOView中的展示如下:</p><p><img src="https://user-images.githubusercontent.com/25925248/153368728-d56fe848-28a5-47fd-a0b1-1eabd023b3b4.png"></p><h1 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h1><p>在Mach-O文件中，<code>Load Commands</code>主要是用于 <code>加载指令</code>，其大小和数目在Header中已经被提供，其在Mach.h中的定义如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> load_command用于加载指令</span><br><span class="line"> - cmd 加载命令的类型</span><br><span class="line"> - cmdsize 加载命令的大小</span><br><span class="line"> */</span><br><span class="line">struct load_command &#123;</span><br><span class="line">    uint32_t cmd;       /* type of load command */</span><br><span class="line">    uint32_t cmdsize;   /* total size of command in bytes */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在<code>MachOView</code>中查看<code>Load Commands</code>，其中记录了很多信息，例如<code>动态链接器的位置、程序的入口、依赖库的信息、代码的位置、符号表的位置</code>等等，如下所示:</p><p><img src="https://user-images.githubusercontent.com/25925248/126617758-5cbc66b9-99db-40d8-8af8-6c72cb3ecd66.png"></p><p>其中<code>LC_SEGMENT_64</code>的类型<code>segment_command_64</code>定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> segment_command 段加载命令</span><br><span class="line"> - cmd：表示加载命令类型，</span><br><span class="line"> - cmdsize：表示加载命令大小（还包括了紧跟其后的nsects个section的大小）</span><br><span class="line"> - segname：16个字节的段名字</span><br><span class="line"> - vmaddr：段的虚拟内存起始地址</span><br><span class="line"> - vmsize：段的虚拟内存大小</span><br><span class="line"> - fileoff：段在文件中的偏移量</span><br><span class="line"> - filesize：段在文件中的大小</span><br><span class="line"> - maxprot：段页面所需要的最高内存保护（4 = r，2 = w，1 = x）</span><br><span class="line"> - initprot：段页面初始的内存保护</span><br><span class="line"> - nsects：段中section数量</span><br><span class="line"> - flags：其他杂项标志位</span><br><span class="line"> </span><br><span class="line"> - 从fileoff（偏移）处，取filesize字节的二进制数据，放到内存的vmaddr处的vmsize字节。（fileoff处到filesize字节的二进制数据，就是“段”）</span><br><span class="line"> - 每一个段的权限相同（或者说，编译时候，编译器把相同权限的数据放在一起，成为段），其权限根据initprot初始化。initprot指定了如何通过读/写/执行位初始化页面的保护级别</span><br><span class="line"> - 段的保护设置可以动态改变，但是不能超过maxprot中指定的值（在iOS中，+x和+w是互斥的）</span><br><span class="line"> */</span><br><span class="line">struct segment_command_64 &#123; /* for 64-bit architectures */</span><br><span class="line">    uint32_t    cmd;        /* LC_SEGMENT_64 */</span><br><span class="line">    uint32_t    cmdsize;    /* includes sizeof section_64 structs */</span><br><span class="line">    char        segname[16];    /* segment name */</span><br><span class="line">    uint64_t    vmaddr;     /* memory address of this segment */</span><br><span class="line">    uint64_t    vmsize;     /* memory size of this segment */</span><br><span class="line">    uint64_t    fileoff;    /* file offset of this segment */</span><br><span class="line">    uint64_t    filesize;   /* amount to map from the file */</span><br><span class="line">    vm_prot_t   maxprot;    /* maximum VM protection */</span><br><span class="line">    vm_prot_t   initprot;   /* initial VM protection */</span><br><span class="line">    uint32_t    nsects;     /* number of sections in segment */</span><br><span class="line">    uint32_t    flags;      /* flags */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h1><p><code>Load Command</code>s 后就是<code>Data</code>区域，这个区域<code>存储了具体的只读、可读写代码</code>，例如方法、符号表、字符表、代码数据、连接器所需的数据（重定向、符号绑定等）。主要是存储具体的数据。其中大多数的Mach-O文件均包含以下三个段：</p><ul><li><code>__TEXT 代码段</code>：只读，包括函数，和只读的字符串</li><li><code>__DATA 数据段</code>：读写，包括可读写的全局变量等</li><li><code>__LINKEDIT</code>： __LINKEDIT包含了方法和变量的元数据（位置，偏移量），以及代码签名等信息。</li></ul><p>在<code>Data</code>区中，<code>Section</code>占了很大的比例，<code>Section</code>在<code>Mach.h</code>中是以结构体<code>section_64</code>（在arm64架构下）表示，其定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> Section节在MachO中集中体现在TEXT和DATA两段里.</span><br><span class="line"> - sectname：当前section的名称</span><br><span class="line"> - segname：section所在的segment名称</span><br><span class="line"> - addr：内存中起始位置</span><br><span class="line"> - size：section大小</span><br><span class="line"> - offset：section的文件偏移</span><br><span class="line"> - align：字节大小对齐</span><br><span class="line"> - reloff：重定位入口的文件偏移</span><br><span class="line"> - nreloc：重定位入口数量</span><br><span class="line"> - flags：标志，section的类型和属性</span><br><span class="line"> - reserved1：保留（用于偏移量或索引）</span><br><span class="line"> - reserved2：保留（用于count或sizeof）</span><br><span class="line"> - reserved3：保留</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">struct section_64 &#123; /* for 64-bit architectures */</span><br><span class="line">    char        sectname[16];   /* name of this section */</span><br><span class="line">    char        segname[16];    /* segment this section goes in */</span><br><span class="line">    uint64_t    addr;       /* memory address of this section */</span><br><span class="line">    uint64_t    size;       /* size in bytes of this section */</span><br><span class="line">    uint32_t    offset;     /* file offset of this section */</span><br><span class="line">    uint32_t    align;      /* section alignment (power of 2) */</span><br><span class="line">    uint32_t    reloff;     /* file offset of relocation entries */</span><br><span class="line">    uint32_t    nreloc;     /* number of relocation entries */</span><br><span class="line">    uint32_t    flags;      /* flags (section type and attributes)*/</span><br><span class="line">    uint32_t    reserved1;  /* reserved (for offset or index) */</span><br><span class="line">    uint32_t    reserved2;  /* reserved (for count or sizeof) */</span><br><span class="line">    uint32_t    reserved3;  /* reserved */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Section</code>在<code>MachOView</code>中可以看出，主要集中体现在<code>TEXT</code>和<code>DATA</code>两段里，如下所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/126618103-a6b4972f-729a-44e3-b7e2-a176556b45b5.png"></p><p>其中常见的section，主要有以下一些：</p><p><img src="https://user-images.githubusercontent.com/25925248/153372980-d7a225f7-a889-4905-8bad-571ba85d0179.jpg"><br><img src="https://user-images.githubusercontent.com/25925248/153373133-5ee3b160-94c3-4e53-875b-2c89e2f459a8.jpg"></p><p>所以，综上所述，Mach-O的格式如下：</p><p><img src="https://user-images.githubusercontent.com/25925248/153373172-453ce279-be37-42b1-bdc9-6432cab2025b.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理31：LLVM编译流程&amp;Cland插件开发</title>
      <link href="/BboyZJ.github.io/2021/04/29/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8631%EF%BC%9ALLVM%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B-Cland%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
      <url>/BboyZJ.github.io/2021/04/29/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8631%EF%BC%9ALLVM%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B-Cland%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理30：Block底层原理</title>
      <link href="/BboyZJ.github.io/2021/04/22/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8630%EF%BC%9ABlock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/BboyZJ.github.io/2021/04/22/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8630%EF%BC%9ABlock%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Block类型"><a href="#Block类型" class="headerlink" title="Block类型"></a>Block类型</h1><p><code>block</code> 主要有三种类型： <code>全局区、堆区、栈区</code></p><ul><li><code>__NSGlobalBlock__</code> ：全局block，存储在 <code>全局区</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void(^block)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;ZJ&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时的block无参数，也无返回值，属于<code>全局block</code>，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/127948369-17bd73e0-625c-4012-95ad-59a190514565.png"></p><ul><li><code>__NSMallocBlock__</code> ：堆区block，因为block即是 <code>函数</code> ，也是 <code>对象</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)mallocBlock&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    void(^ block)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;ZJ - %d&quot;,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    NSLog(@&quot;%@&quot;,block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的block会访问外部变量，即 <code>底层拷贝a</code> ，所以是 <code>堆区block</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-08-02 11:11:56.986272+0800 001---Block深入浅出[1126:696422] &lt;__NSMallocBlock__: 0x2800e3c00&gt;</span><br></pre></td></tr></table></figure><ul><li><code>__NSStackBlock__</code> ：block本身默认是 <code>栈block</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 栈block</span><br><span class="line">- (void)stackBlock&#123;</span><br><span class="line">    __block int a = 10;</span><br><span class="line">    void(^block)(void) = ^&#123;</span><br><span class="line">        a = 20;</span><br><span class="line">        NSLog(@&quot;ZJ - %d&quot;,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    NSLog(@&quot;%@&quot;,^&#123;</span><br><span class="line">        a = 20;</span><br><span class="line">        NSLog(@&quot;ZJ - %d&quot;,a);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【小知识点】</strong>：当block内部需要修改或访问外部变量a时，外部变量需要额外用 <code>__block</code> 修饰，否则修改不了</p><p>我们来看一下结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-08-02 11:15:47.243001+0800 001---Block深入浅出[1131:698266] &lt;__NSMallocBlock__: 0x28037a700&gt;</span><br></pre></td></tr></table></figure><p>为什么？居然还是 <code>__NSMallocBlock__</code> ，堆区？<br>答：因为在 <code>ARC</code> 环境下，编译器自动帮我们加了 <code>copy</code> 操作。在 <code>局部变量a</code> 在没有处理（即没有 <code>拷贝</code> 之前）是 <code>栈区block</code>，处理之后（即 <code>拷贝</code> 之后）是 <code>堆区block</code>，目前的栈区block越来越少了。</p><p>当我们关掉ARC如下：</p><p><img src="https://user-images.githubusercontent.com/25925248/127952600-c96f2af4-58ed-4653-872c-a156ce508960.png"></p><p>再来打印一下结果：</p><p><img src="https://user-images.githubusercontent.com/25925248/127952732-80d98b33-8d37-4504-b2f7-9813bef0fd57.png"></p><p><strong>【总结】</strong></p><ul><li><p>block直接存储在 <code>全局区</code></p></li><li><p>如果 <code>block访问外界变量</code> ，并进行block相应拷贝，即 <code>copy</code></p><ul><li>在 <code>ARC</code> 环境下，<code>存储在堆区</code></li><li>在 <code>非ARC</code> 环境下，<code>存储在栈区</code></li></ul></li></ul><h2 id="Block变量捕获"><a href="#Block变量捕获" class="headerlink" title="Block变量捕获"></a>Block变量捕获</h2><p>为了保证Block内部能够正常访问外部变量，block有个自动捕获外部变量的机制</p><p><strong>1、<code>auto</code> 类型局部变量：局部变量截获 <code>是值截获</code>。</strong></p><p><strong>例子：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSInteger num = 3;</span><br><span class="line">NSInteger(^block)(NSInteger) = ^NSInteger(NSInteger n)&#123;</span><br><span class="line">    // num = 4; // 编译器报错</span><br><span class="line">    return n*num;</span><br><span class="line">&#125;;</span><br><span class="line">num = 1;</span><br><span class="line">NSLog(@&quot;%zd&quot;,block(2));</span><br></pre></td></tr></table></figure><p><strong>查看打印结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里的输出是6而不是2，原因就是对局部变量num的截获是值截获。</span><br><span class="line">同样，在block里如果修改变量num，也是无效的，甚至编译器会报错。</span><br></pre></td></tr></table></figure><p><strong>2、 <code>static</code> 类型局部变量：局部静态变量截获是 <code>指针截获</code></strong></p><p><strong>例子：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 静态变量-指针捕获</span><br><span class="line">static int a = 10;</span><br><span class="line">NSInteger(^Sblock)(NSInteger) = ^NSInteger(NSInteger n)&#123;</span><br><span class="line">    return n*a;</span><br><span class="line">&#125;;</span><br><span class="line">a = 1;</span><br><span class="line">NSLog(@&quot;%zd&quot;,Sblock(2));</span><br></pre></td></tr></table></figure><p><strong>打印结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-08-02 00:49:30.467652+0800 OC-Block初探[15224:868821] 2</span><br></pre></td></tr></table></figure><p><strong>结论:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态局部变量截获的是指针，在外部修改为1，对block有影响</span><br></pre></td></tr></table></figure><p><strong>3、__block修饰的变量: <code>__block</code> 变量截获是 <code>指针截获</code>,并且生成了一个新的结构体对象</strong></p><p><strong>例子：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// __block修饰变量-指针捕获</span><br><span class="line">__block NSInteger n = 3;</span><br><span class="line">void(^Bblock)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;%zd&quot;,n); // __block修饰变量</span><br><span class="line">&#125;;</span><br><span class="line">n = 4;</span><br><span class="line">Bblock();</span><br></pre></td></tr></table></figure><p><strong>打印结果:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-08-02 01:01:44.760288+0800 OC-Block初探[15345:878899] 4</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__block修饰的变量也是以指针形式截获的</span><br></pre></td></tr></table></figure><p>解释：<code>__block</code> 是将外部变量包装成了一个对象并将 <code>n</code> 存在这个对象中，实际上block外面的 <code>n</code> 的地址也是指向这个对象中存储的 <code>n</code> 的，而block底层是有一个指针指向这个对象的，所以当外部更改n时，block里面通过指针找到这个对象进而找到n，然后获取到n的值，所以n发生了变化。</p><p><strong>4、<code>全局变量、静态全局变量：不截获,直接取值</code></strong></p><p><strong>例子:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSInteger num1 = 3; // 全局变量</span><br><span class="line">static NSInteger num2 = 30; // 静态全局变量</span><br><span class="line">- (void)blockTest&#123;</span><br><span class="line">    void(^block)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;%zd&quot;,num1); // 全局变量</span><br><span class="line">        NSLog(@&quot;%zd&quot;,num2); // 全局静态变量</span><br><span class="line">    &#125;;</span><br><span class="line">    num1 = 4;</span><br><span class="line">    num2 = 40;</span><br><span class="line">    </span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-08-02 01:01:44.760418+0800 OC-Block初探[15345:878899] 4</span><br><span class="line">2020-08-02 01:01:44.760514+0800 OC-Block初探[15345:878899] 40</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">全局变量、静态全局变量是不截获,直接取值</span><br></pre></td></tr></table></figure><p><strong>5、<code>对象</code>：对象类型的也是一样的，值截取</strong></p><p><strong>例子：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)blockTest1&#123;</span><br><span class="line">    // 局部对象</span><br><span class="line">    NSMutableArray * arr = [NSMutableArray arrayWithObjects:@1,@2, nil];</span><br><span class="line">    void(^block)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,arr);</span><br><span class="line">        [arr addObject:@(4)];</span><br><span class="line">        NSLog(@&quot;%@&quot;,arr);</span><br><span class="line">    &#125;;</span><br><span class="line">    [arr addObject:@3];</span><br><span class="line">    arr = nil;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>查看打印结果:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2020-08-11 10:41:59.416461+0800 OC-Block变量截获的原理[31602:1829372] (</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3</span><br><span class="line">)</span><br><span class="line">2020-08-11 10:41:59.416882+0800 OC-Block变量截获的原理[31602:1829372] (</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>结论:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">局部对象变量也是一样，截获的是值，而不是指针，在外部将其置为nil，对block没有影响，而该对象调用方法会影响</span><br></pre></td></tr></table></figure><h1 id="Block循环引用"><a href="#Block循环引用" class="headerlink" title="Block循环引用"></a>Block循环引用</h1><ul><li><p><code>正常释放</code>：是指A持有B的引用，当A调用dealloc方法，给B发送release信号，B收到release信号，如果此时B的retainCount（即引用计数）为0时，则调用B的dealloc方法</p></li><li><p><code>循坏引用</code>：A、B互相持有，所有导致A无法调用dealloc方法给B发送release信号，而B也无法接收到release信号，所以A、B此时都无法释放</p></li></ul><p><strong>关系图如下：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/127963640-38d55552-982b-4d57-82bc-e8e3dd1d8a1c.png"></p><h1 id="Block循环引用解决"><a href="#Block循环引用解决" class="headerlink" title="Block循环引用解决"></a>Block循环引用解决</h1><h2 id="请问下面两段代码是否有循环引用？"><a href="#请问下面两段代码是否有循环引用？" class="headerlink" title="请问下面两段代码是否有循环引用？"></a>请问下面两段代码是否有循环引用？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 代码一</span><br><span class="line">self.name = @&quot;ZJ&quot;;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,self.name);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">// 代码二</span><br><span class="line">[UIView animateWithDuration:1 animations:^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,self.name);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><ul><li><p>【代码一】：发生了 <code>循环引用</code>，因为在 <code>block</code> 内部使用了 <code>外部变量name</code>，导致 <code>block持有了self</code>，而 <code>self</code> 原本是持有 <code>block</code> 的，所以导致 <code>self和block的相互持有</code>，即 <code>self -&gt; name -&gt; block -&gt; self</code>。</p></li><li><p>【代码二】：没发生 <code>循环引用</code> ，虽然使用了 <code>外部变量name</code>，但是 <code>self</code>并没有持有<code>animation</code> 的 <code>block</code>,仅仅只有 <code>block</code> 持有 <code>self</code> ，不构成互相持有，即 <code>block -&gt; self -&gt; name</code>。</p></li></ul><h2 id="解决循环引用常见的几种方式"><a href="#解决循环引用常见的几种方式" class="headerlink" title="解决循环引用常见的几种方式"></a>解决循环引用常见的几种方式</h2><ul><li><p><strong>【方式一】：</strong> <code>weak-strong-dance</code> 强弱共舞</p></li><li><p><strong>【方式二】：</strong> <code>__block</code> 修饰对象（需要注意的是在block内部需要 <code>置空</code> 对象，而且 <code>block必须调用</code>）</p></li><li><p><strong>【方式三】：</strong> 传递 <code>对象self</code> 作为block的参数，提供给block内部使用</p></li><li><p><strong>【方式四】：</strong> 使用 <code>NSProxy</code></p></li></ul><p><strong>1、【方式一】：weak-strong-dance</strong></p><ul><li>如果block内部并未嵌套block，直接使用 <code>__weak</code> 修饰 <code>self</code> 即可：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^ZJBlock)(void);</span><br><span class="line">...</span><br><span class="line">@property (nonatomic, copy) ZJBlock block;</span><br><span class="line">...</span><br><span class="line"> __weak typeof(self) weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,weakSelf.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时的 <code>weakSelf</code> 和 <code>self</code> 指向同一片 <code>内存空间</code>，且使用 <code>__weak不会导致self的引用计数发生变化</code>，可以通过打印 <code>weakSelf</code> 和 <code>self</code> 的指针地址和引用计数来验证，如下所示：</p><p><strong>运行下面的代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// block</span><br><span class="line">NSLog(@&quot;%ld&quot;,(long)CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,weakSelf.name);</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;%p - %p&quot;,weakSelf,self);</span><br><span class="line">NSLog(@&quot;%ld&quot;,(long)CFGetRetainCount((__bridge CFTypeRef)(self.block)));</span><br><span class="line">NSLog(@&quot;%ld&quot;,(long)CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br></pre></td></tr></table></figure><p><strong>得到的结果如下：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/127974858-7dc045e9-9d44-45ca-9263-0988b8cb7e1f.png"></p><ul><li>如果 <code>block</code> 内部嵌套 <code>block</code>，需要同时使用 <code>__weak</code> 和 <code>__strong</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,strongSelf.name);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">self.block();</span><br></pre></td></tr></table></figure><p>其中 <code>strongSelf</code> 是一个 <code>临时变量</code> ，在block的作用域内，即内部 <code>block执行完</code> 就释放 <code>strongSelf</code></p><p>这种方式属于 <code>打破self对block的强引用</code>，依赖于 <code>中介者模式</code>，属于自动置为 <code>nil</code>，即 <code>自动释放</code></p><p><strong>2、【方式二】：__block修饰变量</strong></p><p>这种方式同样依赖于 <code>中介者模式</code>，属于 <code>手动释放</code>，是通过 <code>__block</code> 修饰对象，主要是因为 <code>__block</code> 修饰的对象时可以改变的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__block ViewController * vc = self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,vc.name);</span><br><span class="line">        vc = nil;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">self.block();</span><br></pre></td></tr></table></figure><p>需要注意的是这里的 <code>block必须调用</code>，如果不调用block，vc就不会被置空，那么依旧是循环引用，<code>self</code> 和 <code>block</code> 都不会被释放</p><p><strong>3、【方式三】：对象self作为参数</strong></p><p>主要是将 <code>对象self作为参数</code> ，提供给block内部使用，不会有引用计数问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.block = ^(BlockViewController * vc) &#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,vc.name);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">self.block(self);</span><br></pre></td></tr></table></figure><p><strong>4、【方式四】：NSProxy虚拟类</strong></p><ul><li><p><code>oc</code> 是只能 <code>单继承</code> 的语言，但是它是 <code>基于运行时的机制</code>，所以通过 <code>NSProxy</code> 来实现 <code>伪多继承</code> ，填补了多继承的空白</p></li><li><p><code>NSProxy</code> 和 <code>NSObject</code> 是同级的一个类，也可以说是一个<code>虚拟类</code>，只是实现了<code>NSObject</code> 的协议</p></li><li><p><code>NSProxy</code> 其实是一个 <code>消息重定向封装的一个抽象类</code>，类似于一个 <code>代理人，中间件</code>，可以通过继承它，并重写两个方法来实现消息转发到另一个实例</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation;</span><br><span class="line">- (nullable NSMethodSignature *)methodSignatureForSelector:(SEL)sel NS_SWIFT_UNAVAILABLE(&quot;NSInvocation and related APIs not available&quot;);</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong></p><p><code>NSProxy</code> 的使用场景主要有两种：</p><ul><li>实现 <code>多继承</code> 功能</li><li>解决了 <code>NSTimer &amp; CADisplayLink</code> 创建时 <code>对self强引用</code> 的问题，参考 <code>YYKit</code> 的 <code>YYWeakProxy</code>。</li></ul><p><strong>循环引用解决原来</strong></p><p>主要是通过自定义 <code>NSProxy</code> 类的对象来代替 <code>self</code>，并使用方法实现消息转发</p><p>下面是 <code>NSProxy</code> 子类的实现以及使用的场景：</p><p><strong>【场景一】：多继承</strong></p><ul><li>自定义一个 <code>NSProxy</code> 的子类 <code>ZJProxy</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJProxy : NSProxy</span><br><span class="line">- (id)transformObjc:(NSObject *)objc;</span><br><span class="line">+ (instancetype)proxyWithObjc:(id)objc;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface ZJProxy ()</span><br><span class="line">@property(nonatomic, weak, readonly) NSObject *objc;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJProxy</span><br><span class="line">- (id)transformObjc:(NSObject *)objc&#123;</span><br><span class="line">    _objc = objc;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)proxyWithObjc:(id)objc&#123;</span><br><span class="line">    return  [[self alloc] transformObjc:objc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1.获取target类中的sel方法的方法签名</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    return [self.objc methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line">// 2. 类似于方法重定向</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class="line">    // 判断objc是否实现了该方法</span><br><span class="line">    if ([self.objc respondsToSelector:invocation.selector]) &#123;</span><br><span class="line">        // 让objc调用该方法</span><br><span class="line">        [invocation invokeWithTarget:self.objc];</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        // 找不到该方法</span><br><span class="line">        [invocation doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector&#123;</span><br><span class="line">    return [self.objc respondsToSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>自定义 <code>Cat</code> 和 <code>Dog</code> 类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//********Cat类********</span><br><span class="line">@interface Cat : NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Cat</span><br><span class="line">- (void)eat&#123;</span><br><span class="line">   NSLog(@&quot;猫吃鱼&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//********Dog类********</span><br><span class="line">@interface Dog : NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Dog</span><br><span class="line">- (void)shut&#123;</span><br><span class="line">    NSLog(@&quot;狗叫&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>通过 <code>ZJProxy</code> 实现 <code>多继承</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Dog * dog = [[Dog alloc] init];</span><br><span class="line">Cat * cat = [[Cat alloc] init];</span><br><span class="line">ZJProxy *proxy = [ZJProxy alloc];</span><br><span class="line">    </span><br><span class="line">[proxy transformObjc:cat];</span><br><span class="line">[proxy performSelector:@selector(eat)];</span><br><span class="line">    </span><br><span class="line">[proxy transformObjc:dog];</span><br><span class="line">[proxy performSelector:@selector(shut)];</span><br></pre></td></tr></table></figure><p><strong>【场景二】：通过 <code>ZJProxy</code> 解决 <code>NSTimer计时器中self强引用</code> 问题</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.timer = [NSTimer timerWithTimeInterval:1 target:[ZJProxy proxyWithObjc:self] selector:@selector(print) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure><p>别忘了在 <code>dealloc</code> 中调用 <code>[self.timer invalidate]</code></p><p><strong>【场景三】：通过 <code>ZJProxy</code> 解决 <code>CADisplayLink计时器中self强引用</code> 问题</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.link = [CADisplayLink displayLinkWithTarget:[ZJProxy proxyWithObjc:self] selector:@selector(linkMethod:)];</span><br><span class="line">[self.link addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure><p>同样，别忘了在 <code>dealloc</code> 中调用 <code>[self.link invalidate]</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>循环引用的解决方式，从根本上来说就两种，以 <code>self -&gt; block -&gt; self</code> 为例：</p><ul><li><p>打破 <code>self</code> 对 <code>block</code> 的强引用，可以block属性修饰符使用 <code>weak</code>，但是这样会导致blcok还没有创建完就释放了，所以从这里打破强引用行不通。</p></li><li><p>打破 <code>block</code> 对 <code>self</code> 的强引用，主要就是self的作用域和block的作用域的 <code>通讯</code>，通讯有 <code>代理、传值、通知、传参</code> 等几种方式，用于解决循环引用。</p><ul><li><code>weak-strong-dance</code></li><li><code>__block（block内对象置空，且调用block）</code></li><li>将对象 <code>self</code> 作为block的参数</li><li>通过 <code>NSProxy</code> 子类代替 <code>self</code></li></ul></li></ul><h1 id="Block-底层本质"><a href="#Block-底层本质" class="headerlink" title="Block 底层本质"></a>Block 底层本质</h1><p>主要是通过 <code>clang、断点调试</code> 等方式分析Block底层</p><p><strong>本质</strong></p><ul><li>定义 <code>block.c</code> 文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    void(^block)(void) = ^&#123;</span><br><span class="line">        printf(&quot;ZJ&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>到 <code>block.c</code> 文件目录，通过 <code>xcrun -sdk iphonesimulator clang -arch x86_64 -rewrite-objc block.c</code>，将 <code>block.c</code> 编译成 <code>block.app</code>，其中block在底层被编译成了一下的形式：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简化后：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数</span><br><span class="line">void(*block)(void) = __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">// block调用执行</span><br><span class="line">block-&gt;FuncPtr(block);</span><br></pre></td></tr></table></figure><p>相当于 <code>block</code> 等于 <code>__main_block_impl_0</code>，是一个 <code>函数</code></p><!--如果出现报错：xcrun: error: SDK "iphonesimulator" cannot be located:解决办法：Xcode -> Preferences -> Locations -> Command Line Tools：选择一下你现在用的版本即可--><ul><li>查看<code>__main_block_impl_0</code>，是一个 <code>结构体</code>，同时可以说明 <code>block</code> 是一个<code>__main_block_impl_0</code> 类型的 <code>对象</code>，这也是为什么 <code>block</code> 能够 <code>%@</code> 打印的原因</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// block代码块的结构体类型</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// block_impl的结构体类型</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>【总结】</strong>：<code>block</code> 的 <code>本质</code> 是 <code>对象、函数、结构体</code>，由于block函数没有名称，也被称为 <code>匿名函数</code></p><p><code>block</code> 通过 <code>clang</code> 编译后的源码间的关系如下图所示：以 <code>block</code> 修饰的变量为例：</p><p><img src="https://user-images.githubusercontent.com/25925248/128323860-4a3e3ea3-1e0a-417b-add6-3031b15a2920.png"></p><p><strong>1、block为什么需要调用？</strong></p><p>在底层block的类型 <code>__main_block_imp_0</code> 结构体，通过其同名构造函数创建，第一个传入的block内部实现代码块，即 <code>__main_block_func_0</code>，用 <code>fp</code> 表示，然后赋值给 <code>impl</code> 属性，然后在 <code>main</code> 中进行了调用，这也是block为什么需要调用的原因。如果不调用，block内部实现的代码块将无法执行，可以总结以下两点：</p><ul><li><p><code>函数声明</code>：即block内部实现声明了一个函数 <code>__main_block_func_0</code></p></li><li><p><code>执行具体的函数实现</code>：通过调用block的<code>FuncPstr</code>指针，调用<code>block</code></p></li></ul><p><strong>2、block是如何获取外界变量的</strong></p><ul><li>定义一个变量，并在block中调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    void(^block)(void) = ^&#123;</span><br><span class="line">        printf(&quot;ZJ - %ld&quot;,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>底层编译后</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int a; // 编译时就自动生成了相应的变量</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock; // block的isa默认是stackBlock</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp; // 函数指针赋值</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int a = __cself-&gt;a; // bound by copy 值拷贝，即 a = 10，此时的a于传入的__cself的a并不是同一个</span><br><span class="line">        printf(&quot;ZJ - %ld&quot;,a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__main_block_func_0</code> 中的 <code>a</code> 是 <code>值拷贝</code>，如果此时在block内部实现中做 <code>a++</code> 操作，是有问题的，会造成编译器的代码歧义，即此时的 <code>a</code> 是只读的</p><p><strong>总结：</strong> block捕获外界变量时，在 <code>内部会自动生成同一个属性来保存</code></p><h1 id="block的原理"><a href="#block的原理" class="headerlink" title="__block的原理"></a>__block的原理</h1><ul><li>对 <code>a</code> 加一个 <code>__block</code>，然后在block中对 <code>a</code> 进行 <code>++</code> 操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    __block int a = 10;</span><br><span class="line">    void(^block)(void) = ^&#123;</span><br><span class="line">        a ++;</span><br><span class="line">        printf(&quot;ZJ - %ld&quot;,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>底层编译如下：</p><ul><li>main中的 <code>a</code> 是通过外界变量封装的 <code>对象</code></li><li><code>__main_block_impl_0</code> 中，将 <code>对象a</code> 的地址 <code>&amp;a</code> 给构造函数</li><li>在 <code>__main_block_func_0</code> 内部对a的处理是 <code>指针拷贝</code>，此时创建的对象a与传入对象的a <code>指向同一片内存空间</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// __block修饰的外界变量结构体</span><br><span class="line">struct __Block_byref_a_0 &#123; </span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// __block的结构体类型</span><br><span class="line">struct __main_block_impl_0 &#123; </span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_a_0 *a; // by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// block内部实现</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref 指针拷贝，此时对象a 与 __cself对象的a指向同一片地址空间</span><br><span class="line">        // 等同于 外界的a++</span><br><span class="line">        (a-&gt;__forwarding-&gt;a) ++;</span><br><span class="line">        printf(&quot;ZJ - %ld&quot;,(a-&gt;__forwarding-&gt;a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    // __Block_byref_a_0 是结构体，a 等于 结构体的赋值，即外界变量a 封装成对象</span><br><span class="line">    // &amp;a 是外界变量a的地址</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 10&#125;;</span><br><span class="line">    // _main_block_img_0中的第三个参数&amp;a，是封装对象a的地址</span><br><span class="line">    void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><code>外界变量</code> 会生成 <code>__block_byref_a_0</code> 结构体</li><li>结构体用来 <code>保存原始变量的指针和值</code></li><li>将变量生成的 <code>结构体对象的指针地址，传递给block</code>，然后在block内部就可以对外界变量进行操作了</li></ul><p><strong>两种拷贝对比：</strong></p><ul><li><p><code>值拷贝</code>：-<code>深拷贝</code>，只是拷贝值，且拷贝的值不可以更改，指向不同的内存空间，案列中普通变量<code>a</code>就是<code>值拷贝</code></p></li><li><p><code>指针拷贝</code>：-<code>浅拷贝</code>，生成的对象指向同一片内存空间，案列中经过<code>__block</code>修饰的变量<code>a</code>就是 <code>指针拷贝</code></p></li></ul><h1 id="block底层的真正类型"><a href="#block底层的真正类型" class="headerlink" title="block底层的真正类型"></a>block底层的真正类型</h1><p><strong>分析block源码所在位置</strong></p><ul><li>运行下面的代码，并开启 <code>Always Show Disassembly</code>反汇编</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">void(^block)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;ZJ = %d&quot;,a);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><ul><li>通过在block处打断点，分析运行时的block</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/128460979-d5e44fb3-836e-4a67-adfd-4325e6de4fa6.png"></p><ul><li>加 <code>objc_retainBlock</code> 符号断点，发现会走到 <code>_Block_copy</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/128461677-621a5b62-43d6-4d20-9bb7-54843152f766.png"></p><ul><li>加 <code>_Block_copy</code> 符号断点，运行时在 <code>libsystem_blocks.dylib</code> 源码中</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/128461750-54867562-1cba-4a3b-a01a-8fe498ebb01b.png"></p><p>可以到苹果开源网站下载最新的 <a href="https://opensource.apple.com/source/libclosure/">libcloseure-074</a> 源码，通过查看 <code>_Block_copy</code> 的源码实现，发现block底层的真正类型是<code>_Block_layout</code></p><h1 id="Block的真正类型"><a href="#Block的真正类型" class="headerlink" title="Block的真正类型"></a>Block的真正类型</h1><p>查看 <code>Block_layout</code> 类型的定义，是一个结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Block 结构体</span><br><span class="line">struct Block_layout &#123;</span><br><span class="line">    // 指向表明block类型的类</span><br><span class="line">    void *isa; // 8字节</span><br><span class="line">    // 用来作标识符的，类似于isa中的位域,按bit位表示一些block的附加信息</span><br><span class="line">    volatile int32_t flags; // contains ref count 4字节</span><br><span class="line">    // 保留信息，可以理解预留位置，用于存储block内部变量信息</span><br><span class="line">    int32_t reserved; // 4字节</span><br><span class="line">    // 函数指针，指向具体的block实现的调用地址</span><br><span class="line">    BlockInvokeFunction invoke;</span><br><span class="line">    // block的附加信息</span><br><span class="line">    struct Block_descriptor_1 *descriptor;</span><br><span class="line">    // imported variables</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>isa</code>：指向表明block类型的类</p></li><li><p><code>flags</code>：标识符，按bit位表示一些block的附加信息，类似于isa中的位域，其中<code>flags</code> 的种类有以下几种，主要重点关注 <code>BLOCK_HAS_COPY_DISPOSE</code> 和 <code>BLOCK_HAS_SIGNATURE</code>。<code>BLOCK_HAS_COPY_DISPOSE</code> 决定是否有<code>Block_descriptor_2</code>。<code>BLOCK_HAS_SIGNATURE</code> 决定是否有<code>Block_descriptor_3</code>：</p><ul><li>第1 位 - <code>BLOCK_DEALLOCATING</code>，释放标记，-般常用 <code>BLOCK_NEEDS_FREE</code> 做 <code>位与</code> 操作，一同传入 <code>Flags</code> ， 告知该 <code>block</code> 可释放。 </li><li>低16位 - <code>BLOCK_REFCOUNT_MASK</code>，存储引用计数的值;是一个可选用参数</li><li>第24位 - <code>BLOCK_NEEDS_FREE</code>，低16是否有效的标志，程序根据它来决定是否增加或是减少引用计数位的 值;</li><li>第25位 - <code>BLOCK_HAS_COPY_DISPOSE</code>，是否拥有拷贝辅助函数(a copy helper function);</li><li>第26位 - <code>BLOCK_IS_GC</code>，是否拥有 <code>block</code> 析构函数;</li><li>第27位，标志是否有垃圾回收; </li><li>第28位 - <code>BLOCK_IS_GLOBAL</code>，标志是否是全局block;</li><li>第30位 - <code>BLOCK_HAS_SIGNATURE</code>，与 <code>BLOCK_USE_STRET</code> 相对，判断当前 <code>block</code> 是否拥有一个签名。用于 <code>runtime</code> 时动态调用。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 注释: flags 标识</span><br><span class="line">// Values for Block_layout-&gt;flags to describe block objects</span><br><span class="line">enum &#123;</span><br><span class="line">    // 释放标记，一般常用于BLOCK_BYREF_NEEDS_FREE做位与运算，一同传入flags，告知该block可释放</span><br><span class="line">    BLOCK_DEALLOCATING =      (0x0001),  // runtime</span><br><span class="line">    // 存储引用引用计数的 值，是一个可选用参数</span><br><span class="line">    BLOCK_REFCOUNT_MASK =     (0xfffe),  // runtime</span><br><span class="line">    // 低16位是否有效的标志，程序根据它来决定是否增加或者减少引用计数位的值</span><br><span class="line">    BLOCK_NEEDS_FREE =        (1 &lt;&lt; 24), // runtime</span><br><span class="line">    // 是否拥有拷贝辅助函数，（a copy helper function）决定block_description_2</span><br><span class="line">    BLOCK_HAS_COPY_DISPOSE =  (1 &lt;&lt; 25), // compiler</span><br><span class="line">    // 是否拥有block C++析构函数</span><br><span class="line">    BLOCK_HAS_CTOR =          (1 &lt;&lt; 26), // compiler: helpers have C++ code</span><br><span class="line">    // 标志是否有垃圾回收，OSX</span><br><span class="line">    BLOCK_IS_GC =             (1 &lt;&lt; 27), // runtime</span><br><span class="line">    // 标志是否是全局block</span><br><span class="line">    BLOCK_IS_GLOBAL =         (1 &lt;&lt; 28), // compiler</span><br><span class="line">    // 与BLOCK_HAS_SIGNATURE相对，判断是否当前block拥有一个签名，用于runtime时动态调用</span><br><span class="line">    BLOCK_USE_STRET =         (1 &lt;&lt; 29), // compiler: undefined if !BLOCK_HAS_SIGNATURE</span><br><span class="line">    // 是否有签名</span><br><span class="line">    BLOCK_HAS_SIGNATURE  =    (1 &lt;&lt; 30), // compiler</span><br><span class="line">    // 使用有拓展，决定block_description_3</span><br><span class="line">    BLOCK_HAS_EXTENDED_LAYOUT=(1 &lt;&lt; 31)  // compiler</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>reserved</code>：保留信息，可以理解预留位置，猜测是用于存储block内部变量信息</p></li><li><p><code>invoke</code>：是一个函数指针，指向block的执行代码</p></li><li><p><code>descriptor：</code> block的附加信息，比如保留变量数、block的大小、进行copy或dispose的辅助函数指针。有三类：</p><ul><li><code>Block_descriptor_1</code> 是必选的</li><li><code>Block_descriptor_2</code> 和 <code>Block_descriptor_3</code> 都是可选的</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#define BLOCK_DESCRIPTOR_1 1</span><br><span class="line">struct Block_descriptor_1 &#123;</span><br><span class="line">    uintptr_t reserved;//保留信息</span><br><span class="line">    uintptr_t size;//block大小</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define BLOCK_DESCRIPTOR_2 1</span><br><span class="line">struct Block_descriptor_2 &#123;</span><br><span class="line">    // requires BLOCK_HAS_COPY_DISPOSE</span><br><span class="line">    BlockCopyFunction copy;//拷贝函数指针</span><br><span class="line">    BlockDisposeFunction dispose;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define BLOCK_DESCRIPTOR_3 1</span><br><span class="line">struct Block_descriptor_3 &#123;</span><br><span class="line">    // requires BLOCK_HAS_SIGNATURE</span><br><span class="line">    const char *signature;//签名</span><br><span class="line">    const char *layout;     // contents depend on BLOCK_HAS_EXTENDED_LAYOUT 布局</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上关于 <code>descriptor</code> 的可以从其构造函数中体现，其中 <code>Block_descriptor_2</code> 和<code>Block_descriptor_3</code> 都是通过 <code>Block_descriptor_1</code> 的地址，经过内存平移得到的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static struct Block_descriptor_1 * _Block_descriptor_1(struct Block_layout *aBlock)</span><br><span class="line">&#123;</span><br><span class="line">    return aBlock-&gt;descriptor;//默认打印</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// 注释:Block 的描述 : copy 和 dispose 函数</span><br><span class="line">static struct Block_descriptor_2 * _Block_descriptor_2(struct Block_layout *aBlock)</span><br><span class="line">&#123;</span><br><span class="line">    if (! (aBlock-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE)) return NULL;</span><br><span class="line">    uint8_t *desc = (uint8_t *)aBlock-&gt;descriptor;//descriptor_1的地址</span><br><span class="line">    desc += sizeof(struct Block_descriptor_1);//通过内存平移获取</span><br><span class="line">    return (struct Block_descriptor_2 *)desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注释: Block 的描述 : 签名相关</span><br><span class="line">static struct Block_descriptor_3 * _Block_descriptor_3(struct Block_layout *aBlock)</span><br><span class="line">&#123;</span><br><span class="line">    if (! (aBlock-&gt;flags &amp; BLOCK_HAS_SIGNATURE)) return NULL;</span><br><span class="line">    uint8_t *desc = (uint8_t *)aBlock-&gt;descriptor;</span><br><span class="line">    desc += sizeof(struct Block_descriptor_1);</span><br><span class="line">    if (aBlock-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">        desc += sizeof(struct Block_descriptor_2);</span><br><span class="line">    &#125;</span><br><span class="line">    return (struct Block_descriptor_3 *)desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="block内存变化"><a href="#block内存变化" class="headerlink" title="block内存变化"></a>block内存变化</h1><p><strong>1、没有外部变量的 <code>block</code>:</strong></p><ul><li>打断点运行，走到 <code>objc_retainBlock</code>，block断点处读取寄存器 <code>x0</code>，此时 <code>block</code> 是 <code>全局block</code>，即 <code>__NSGlobalBlock__</code>：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/128474915-09c6eacc-62da-4479-a39c-865dd09b1f99.png"></p><p><strong>2、增加外部变量a的block：</strong></p><ul><li>同上，执行到符号断点 <code>objc_retainBlock</code>，得到的 <code>block</code> 是 <code>栈block</code>，即<code>__NSStackBlock</code>：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/128475461-5b02492b-5d28-46d8-a161-b6118cd0140e.png"></p><ul><li>增加 <code>_Block_copy</code> 符号断点并断住，直接在最后的 <code>ret</code> 加断点，读取 <code>x0</code>，发现经过 <code>_Block_copy</code> 之后，变成了 <code>堆block</code>，即 <code>__NSMallocBlock__</code>，主要是因为block地址发生了改变，为堆 <code>block</code>:</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/128476618-ceecf044-162b-4084-9164-8fd07d474982.png"></p><p><strong>调用情况</strong></p><ul><li>同样也可以通过断点来验证</li></ul><p><img src="/BboyZJ.github.io/assets/16508769047375.jpg"></p><ul><li><p><code>register read x0</code> 读取x0，为堆block</p></li><li><p><code>register read x9</code> 读取x9</p></li><li><p><code>register read x11</code> ，此时是指向一片内存空间，用于存储 <code>_block_invoke</code></p></li></ul><p><img src="/BboyZJ.github.io/assets/16508769378666.jpg"></p><ul><li>按住 <code>control + step into</code>，进入 <code>_block_invoke</code>，可以得出是通过内存平移得到的block内部实现</li></ul><p><img src="/BboyZJ.github.io/assets/16508769975300.jpg"></p><p>前面提到的 <code>Block_layout</code> 的结构体源码,从源码中可以看出，有个属性 <code>invoke</code>，即block的执行者，是从 <code>isa</code> 的首地址平移 <code>16</code> 字节取到 <code>invoke</code>，然后进行调用执行的</p><h1 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h1><ul><li><p>继续操作，读取 <code>x0</code> 寄存器,看内存布局,通过 <code>内存平移 3*8</code> 就可获得 <code>Block_layout</code> 的属性 <code>descriptor</code>,主要是为了查看是否有 <code>Block_descriptor_2</code> 和 <code>Block_descriptor_3</code>，其中3中有block的签名</p><ul><li><code>register read x0</code>，读取寄存器x0</li><li><code>po 0x00000002828a2160</code> ， 打印block</li><li><code>x/8gx 0x00000002828a2160</code> ，即打印block内存情况</li></ul></li></ul><p><img src="/BboyZJ.github.io/assets/16508771126805.jpg"></p><ul><li><code>x/8gx 0x00000001008a0010</code> ， 查看descriptor的内存情况，其中第三个<code>0x000000010089f395</code> 表示签名</li></ul><p><img src="/BboyZJ.github.io/assets/16508771384080.jpg"></p><ul><li><p>判断是否有 <code>Block_descriptor_2</code>，即flags的 <code>BLOCK_HAS_COPY_DISPOSE</code>（拷贝辅助函数）是否有值</p><ul><li><code>p/x 1&lt;&lt;25</code> ，即1左移25位，其十六进制为 <code>0x2000000</code></li><li><code>p 0x02000000 &amp; 0x00000000c1000002</code> ，即 <code>BLOCK_HAS_COPY_DISPOSE &amp; flags</code> ，等于0，表示没有 <code>Block_descriptor_2</code></li></ul></li></ul><p><img src="/BboyZJ.github.io/assets/16508772073802.jpg"></p><ul><li><p>判断是否有 <code>Block_descriptor_3</code></p><ul><li><code>p/x 1&lt;&lt;30</code>，即1左移30位</li><li><code>p 0x40000000 &amp; 0x00000000c1000002</code> ，即 <code>BLOCK_HAS_SIGNATURE &amp; flags</code> ，有值，说明有 <code>Block_descriptor_3</code></li></ul></li></ul><p><img src="/BboyZJ.github.io/assets/16508772669653.jpg"></p><ul><li><code>p (char *)0x000000010089f395</code> – 获取 <code>Block_descriptor_3</code> 中的属性 <code>signature</code> 签名</li></ul><p><img src="/BboyZJ.github.io/assets/16508772949416.jpg"></p><ul><li><code>po [NSMethodSignature signatureWithObjCTypes:&quot;v8@?0&quot;]</code> ，即打印签名</li></ul><p><img src="/BboyZJ.github.io/assets/16508773252829.jpg"></p><p><strong>其中签名的部分说明如下:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//无返回值</span><br><span class="line">return value: -------- -------- -------- --------</span><br><span class="line">    type encoding (v) &#x27;v&#x27;</span><br><span class="line">    flags &#123;&#125;</span><br><span class="line">    modifiers &#123;&#125;</span><br><span class="line">    frame &#123;offset = 0, offset adjust = 0, size = 0, size adjust = 0&#125;</span><br><span class="line">    memory &#123;offset = 0, size = 0&#125;</span><br><span class="line">argument 0: -------- -------- -------- --------</span><br><span class="line">    //encoding = (@),类型是 @?</span><br><span class="line">    type encoding (@) &#x27;@?&#x27;</span><br><span class="line">    //@是isObject ，？是isBlock，代表 isBlockObject</span><br><span class="line">    flags &#123;isObject, isBlock&#125;</span><br><span class="line">    modifiers &#123;&#125;</span><br><span class="line">    frame &#123;offset = 0, offset adjust = 0, size = 8, size adjust = 0&#125;</span><br><span class="line">    //所在偏移位置是8字节</span><br><span class="line">    memory &#123;offset = 0, size = 8&#125;</span><br></pre></td></tr></table></figure><p>block的签名信息类似于方法的签名信息，主要是体现block的返回值，参数以及类型等信息</p><h1 id="block三次copy分析"><a href="#block三次copy分析" class="headerlink" title="block三次copy分析"></a>block三次copy分析</h1><p><strong>_Block_copy源码分析</strong></p><p>进入 <code>_Block_copy</code> 源码，将 <code>block</code> 从栈区拷贝至堆区</p><ul><li><p>如果需要释放，则直接释放</p></li><li><p>如果是 <code>globalBlock</code> – 不需要copy，直接返回</p></li><li><p>反之，只有两种情况：<code>栈区block</code> or <code>堆区block</code>，由于堆区block需要申请空间，前面并没有申请空间的相关代码，所以只能是 <code>栈区block</code>:</p><ul><li><p>通过 <code>malloc</code> 申请内存空间用于接收block</p></li><li><p>通过 <code>memmove</code> 将block拷贝至新申请的内存中</p></li><li><p>设置block对象的类型为堆区block，即 <code>result-&gt;isa = _NSConcreteMallocBlock</code></p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// Copy, or bump refcount, of a block.  If really copying, call the copy helper if present.</span><br><span class="line">// 重点提示: 这里是核心重点 block的拷贝操作: 栈Block -&gt; 堆Block</span><br><span class="line">void *_Block_copy(const void *arg) &#123;</span><br><span class="line">    struct Block_layout *aBlock;</span><br><span class="line"></span><br><span class="line">    if (!arg) return NULL;</span><br><span class="line">    </span><br><span class="line">    // The following would be better done as a switch statement</span><br><span class="line">    aBlock = (struct Block_layout *)arg;//强转为Block_layout类型对象，防止对外界造成影响</span><br><span class="line">    if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;//是否需要释放</span><br><span class="line">        // latches on high</span><br><span class="line">        latching_incr_int(&amp;aBlock-&gt;flags);</span><br><span class="line">        return aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;//如果是全局block，直接返回</span><br><span class="line">        return aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;//为栈block 或者 堆block，由于堆区需要申请内存，所以只可能是栈区</span><br><span class="line">        // Its a stack block.  Make a copy. 它是一个堆栈块block，拷贝。</span><br><span class="line">        struct Block_layout *result =</span><br><span class="line">            (struct Block_layout *)malloc(aBlock-&gt;descriptor-&gt;size);//申请空间并接收</span><br><span class="line">        if (!result) return NULL;</span><br><span class="line">        //通过memmove内存拷贝，将 aBlock 拷贝至result</span><br><span class="line">        memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first</span><br><span class="line">#if __has_feature(ptrauth_calls)</span><br><span class="line">        // Resign the invoke pointer as it uses address authentication.</span><br><span class="line">        result-&gt;invoke = aBlock-&gt;invoke;//可以直接调起invoke</span><br><span class="line">#endif</span><br><span class="line">        // reset refcount</span><br><span class="line">        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    // XXX not needed 告知可释放</span><br><span class="line">        result-&gt;flags |= BLOCK_NEEDS_FREE | 2;  // logical refcount 1</span><br><span class="line">        _Block_call_copy_helper(result, aBlock);</span><br><span class="line">        // Set isa last so memory analysis tools see a fully-initialized object.</span><br><span class="line">        result-&gt;isa = _NSConcreteMallocBlock;//设置block对象类型为堆区block</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>_Block_ovject_assign分析</strong></p><p>想要分析block的三层copy，首先需要知道外部变量的种类有哪些，其中用的最多的是 <code>BLOCK_FIELD_IS_OBJECT</code> 和 <code>BLOCK_FIELD_IS_BYREF</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 注释: Block 捕获的外界变量的种类</span><br><span class="line">// Runtime support functions used by compiler when generating copy/dispose helpers</span><br><span class="line"></span><br><span class="line">// Values for _Block_object_assign() and _Block_object_dispose() parameters</span><br><span class="line">enum &#123;</span><br><span class="line">    // see function implementation for a more complete description of these fields and combinations</span><br><span class="line">    //普通对象，即没有其他的引用类型</span><br><span class="line">    BLOCK_FIELD_IS_OBJECT   =  3,  // id, NSObject, __attribute__((NSObject)), block, ...</span><br><span class="line">    //block类型作为变量</span><br><span class="line">    BLOCK_FIELD_IS_BLOCK    =  7,  // a block variable</span><br><span class="line">    //经过__block修饰的变量</span><br><span class="line">    BLOCK_FIELD_IS_BYREF    =  8,  // the on stack structure holding the __block variable</span><br><span class="line">    //weak 弱引用变量</span><br><span class="line">    BLOCK_FIELD_IS_WEAK     = 16,  // declared __weak, only used in byref copy helpers</span><br><span class="line">    //返回的调用对象 - 处理block_byref内部对象内存会加的一个额外标记，配合flags一起使用</span><br><span class="line">    BLOCK_BYREF_CALLER      = 128, // called from __block (byref) copy/dispose support routines.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 <code>_Block_object_assign</code> 是在底层编译代码中，外部变量拷贝时调用的方法就是它</p><ul><li><p>进入 <code>_Block_object_assign</code> 源码</p><ul><li><p>如果是普通对象，则交给 <code>系统arc处理</code>，并拷贝 <code>对象指针</code>，即 <code>引用计数+1</code>，所以外界变量不能释放</p></li><li><p>如果是 <code>block类型</code> 的变量，则通过 <code>_Block_copy</code> 操作，将block从栈区拷贝到堆区</p></li><li><p>如果是 <code>__block修饰</code> 的变量，调用 <code>_Block_byref_copy</code> 函数 进行内存拷贝以及常规处理</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">static struct Block_byref *_Block_byref_copy(const void *arg) &#123;</span><br><span class="line">    </span><br><span class="line">    //强转为Block_byref结构体类型，保存一份</span><br><span class="line">    struct Block_byref *src = (struct Block_byref *)arg;</span><br><span class="line"></span><br><span class="line">    if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == 0) &#123;</span><br><span class="line">        // src points to stack 申请内存</span><br><span class="line">        struct Block_byref *copy = (struct Block_byref *)malloc(src-&gt;size);</span><br><span class="line">        copy-&gt;isa = NULL;</span><br><span class="line">        // byref value 4 is logical refcount of 2: one for caller, one for stack</span><br><span class="line">        copy-&gt;flags = src-&gt;flags | BLOCK_BYREF_NEEDS_FREE | 4;</span><br><span class="line">        // block内部持有的Block_byref 和 外界的Block_byref 所持有的对象是同一个，这也是为什么__block修饰的变量具有修改能力</span><br><span class="line">        // copy 和 scr 的地址指针达到了完美的同一份拷贝，目前只有持有能力</span><br><span class="line">        copy-&gt;forwarding = copy; // patch heap copy to point to itself</span><br><span class="line">        src-&gt;forwarding = copy;  // patch stack to point to heap copy</span><br><span class="line">        copy-&gt;size = src-&gt;size;</span><br><span class="line">        // 如果有copy能力</span><br><span class="line">        if (src-&gt;flags &amp; BLOCK_BYREF_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">            // Trust copy helper to copy everything of interest</span><br><span class="line">            // If more than one field shows up in a byref block this is wrong XXX</span><br><span class="line">            //Block_byref_2是结构体，__block修饰的可能是对象，对象通过byref_keep保存，在合适的时机进行调用</span><br><span class="line">            struct Block_byref_2 *src2 = (struct Block_byref_2 *)(src+1);</span><br><span class="line">            struct Block_byref_2 *copy2 = (struct Block_byref_2 *)(copy+1);</span><br><span class="line">            copy2-&gt;byref_keep = src2-&gt;byref_keep;</span><br><span class="line">            copy2-&gt;byref_destroy = src2-&gt;byref_destroy;</span><br><span class="line"></span><br><span class="line">            if (src-&gt;flags &amp; BLOCK_BYREF_LAYOUT_EXTENDED) &#123;</span><br><span class="line">                struct Block_byref_3 *src3 = (struct Block_byref_3 *)(src2+1);</span><br><span class="line">                struct Block_byref_3 *copy3 = (struct Block_byref_3*)(copy2+1);</span><br><span class="line">                copy3-&gt;layout = src3-&gt;layout;</span><br><span class="line">            &#125;</span><br><span class="line">            // 等价于 __Block_byref_id_object_copy</span><br><span class="line">            (*src2-&gt;byref_keep)(copy, src);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // Bitwise copy.</span><br><span class="line">            // This copy includes Block_byref_3, if any.</span><br><span class="line">            memmove(copy+1, src+1, src-&gt;size - sizeof(*src));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // already copied to heap</span><br><span class="line">    else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_BYREF_NEEDS_FREE) == BLOCK_BYREF_NEEDS_FREE) &#123;</span><br><span class="line">        latching_incr_int(&amp;src-&gt;forwarding-&gt;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return src-&gt;forwarding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>进入 <code>_Block_byref_copy</code> 源码</p><ul><li><p>将传入的对象，强转为 <code>Block_byref</code> 结构体类型对象，保存一份</p></li><li><p>没有将外界变量拷贝到堆，需要申请内存，其进行拷贝</p></li><li><p>如果已经拷贝过了，则进行处理并返回</p></li><li><p>其中 <code>copy</code> 和src的 <code>forwarding</code> 指针都指向同一片内存，这也是为什么__block修饰的对象具有修改能力的原因</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">static struct Block_byref *_Block_byref_copy(const void *arg) &#123;</span><br><span class="line">    </span><br><span class="line">    //强转为Block_byref结构体类型，保存一份</span><br><span class="line">    struct Block_byref *src = (struct Block_byref *)arg;</span><br><span class="line"></span><br><span class="line">    if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == 0) &#123;</span><br><span class="line">        // src points to stack 申请内存</span><br><span class="line">        struct Block_byref *copy = (struct Block_byref *)malloc(src-&gt;size);</span><br><span class="line">        copy-&gt;isa = NULL;</span><br><span class="line">        // byref value 4 is logical refcount of 2: one for caller, one for stack</span><br><span class="line">        copy-&gt;flags = src-&gt;flags | BLOCK_BYREF_NEEDS_FREE | 4;</span><br><span class="line">        //block内部持有的Block_byref 和 外界的Block_byref 所持有的对象是同一个，这也是为什么__block修饰的变量具有修改能力</span><br><span class="line">        //copy 和 scr 的地址指针达到了完美的同一份拷贝，目前只有持有能力</span><br><span class="line">        copy-&gt;forwarding = copy; // patch heap copy to point to itself</span><br><span class="line">        src-&gt;forwarding = copy;  // patch stack to point to heap copy</span><br><span class="line">        copy-&gt;size = src-&gt;size;</span><br><span class="line">        //如果有copy能力</span><br><span class="line">        if (src-&gt;flags &amp; BLOCK_BYREF_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">            // Trust copy helper to copy everything of interest</span><br><span class="line">            // If more than one field shows up in a byref block this is wrong XXX</span><br><span class="line">            //Block_byref_2是结构体，__block修饰的可能是对象，对象通过byref_keep保存，在合适的时机进行调用</span><br><span class="line">            struct Block_byref_2 *src2 = (struct Block_byref_2 *)(src+1);</span><br><span class="line">            struct Block_byref_2 *copy2 = (struct Block_byref_2 *)(copy+1);</span><br><span class="line">            copy2-&gt;byref_keep = src2-&gt;byref_keep;</span><br><span class="line">            copy2-&gt;byref_destroy = src2-&gt;byref_destroy;</span><br><span class="line"></span><br><span class="line">            if (src-&gt;flags &amp; BLOCK_BYREF_LAYOUT_EXTENDED) &#123;</span><br><span class="line">                struct Block_byref_3 *src3 = (struct Block_byref_3 *)(src2+1);</span><br><span class="line">                struct Block_byref_3 *copy3 = (struct Block_byref_3*)(copy2+1);</span><br><span class="line">                copy3-&gt;layout = src3-&gt;layout;</span><br><span class="line">            &#125;</span><br><span class="line">            //等价于 __Block_byref_id_object_copy</span><br><span class="line">            (*src2-&gt;byref_keep)(copy, src);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // Bitwise copy.</span><br><span class="line">            // This copy includes Block_byref_3, if any.</span><br><span class="line">            memmove(copy+1, src+1, src-&gt;size - sizeof(*src));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // already copied to heap</span><br><span class="line">    else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_BYREF_NEEDS_FREE) == BLOCK_BYREF_NEEDS_FREE) &#123;</span><br><span class="line">        latching_incr_int(&amp;src-&gt;forwarding-&gt;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return src-&gt;forwarding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码调试</strong></p><ul><li>定义一个 <code>__block</code> 修饰的 <code>NSString对象</code>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> __block NSString * zj_name = [NSString stringWithFormat:@&quot;ZJ&quot;];</span><br><span class="line">void (^block1)(void) = ^&#123; // block_copy</span><br><span class="line">    zj_name = @&quot;ZJ&quot;;</span><br><span class="line">    NSLog(@&quot;ZJ - %@&quot;,zj_name);</span><br><span class="line">    </span><br><span class="line">    // block 内存</span><br><span class="line">&#125;;</span><br><span class="line">block1();</span><br></pre></td></tr></table></figure><ul><li><p>xcrun编译结果如下：</p><ul><li><p>编译后的 <code>zj_name</code> 比普通变量多了 <code>__Block_byref_id_object_copy_131</code> 和 <code>__Block_byref_id_object_dispose_131</code></p></li><li><p><code>__Block_byref_zj_name_0</code> 结构体中多了 <code>__Block_byref_id_object_copy</code> 和 <code>__Block_byref_id_object_dispose</code></p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//********编译后的zj_name********</span><br><span class="line"> __Block_byref_zj_name_0 zj_name =</span><br><span class="line">        &#123;(void*)0,</span><br><span class="line">            (__Block_byref_zj_name_0 *)&amp;zj_name,</span><br><span class="line">            33554432,</span><br><span class="line">            sizeof(__Block_byref_zj_name_0),</span><br><span class="line">            __Block_byref_id_object_copy_131,</span><br><span class="line">            __Block_byref_id_object_dispose_131,</span><br><span class="line">            ((NSString * _Nonnull (*)(id, SEL, NSString * _Nonnull, ...))(void *)objc_msgSend)((id)objc_getClass(&quot;NSString&quot;), sel_registerName(&quot;stringWithFormat:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_hr_l_56yp8j4y11491njzqx6f880000gn_T_main_9f330d_mi_0)&#125;;</span><br><span class="line">            </span><br><span class="line">//********__Block_byref_zj_name_0结构体********</span><br><span class="line">struct __Block_byref_zj_name_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_zj_name_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> void (*__Block_byref_id_object_copy)(void*, void*);</span><br><span class="line"> void (*__Block_byref_id_object_dispose)(void*);  // 5*8 = 40</span><br><span class="line"> NSString *zj_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> //********__Block_byref_id_object_copy_131********</span><br><span class="line"> //block自身拷贝（_Block_copy） -- __block bref结构体拷贝(_Block_object_assign) -- _Block_object_assign中对外部变量（存储在bref）拷贝一份到内存</span><br><span class="line">static void __Block_byref_id_object_copy_131(void *dst, void *src) &#123;</span><br><span class="line">    // dst 外部捕获的变量，即结构体 - 5*8 = 40，然后就找到了zj_name(zj_name在bref初始化时就赋值了)</span><br><span class="line">    _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> //********__Block_byref_id_object_dispose_131********</span><br><span class="line">static void __Block_byref_id_object_dispose_131(void *src) &#123;</span><br><span class="line"> _Block_object_dispose(*(void * *) ((char*)src + 40), 131);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 <code>libclosure-74</code> 可编译源码断点调试，关键方法的执行顺序为：<code>_Block_copy -&gt; _Block_byref_copy -&gt; _Block_object_assign</code>,正好对应上述的三层copy</li></ul><p>综上所述，block是如何取到 <code>zj_name</code> 的？</p><ul><li><p>通过 <code>_Block_copy</code> 方法，将block拷贝一份至堆区</p></li><li><p>通过 <code>_Block_object_assign</code> 方法正常拷贝，因为__block修饰的外界变量在底层是 <code>Block_byref</code> 结构体</p></li><li><p>发现外部变量还存有一个对象，<code>从bref中取出相应对象zj_name</code>，拷贝至block空间，才能使用（相同空间才能使用，不同则不能使用）。最后通过 <code>内存平移</code> 就得到了 <code>zj_name</code>，此时的zj_name 和 外界的zj_name是同一片内存空间（从<code>_Block_object_assign</code> 方法中的 <code>*dest = object</code> 看出）</p></li></ul><p><strong>三层copy总结</strong></p><p>总上所述，block三层拷贝是指以下三层：</p><ul><li><p>【第一层】通过 <code>_Block_copy</code> 实现对象的 <code>自身拷贝</code>，从 <code>栈区</code> 拷贝到 <code>堆区</code></p></li><li><p>【第二层】通过 <code>_Block_byref_copy</code> 方法，将对象拷贝为 <code>Block_byref</code> 结构体类型</p></li><li><p>【第三层】通过 <code>_Block_object_assign</code> 方法，对 <code>__block</code> 修饰的 <code>当前变量的拷贝</code></p></li></ul><p>注：只有 <code>__block修饰</code> 的对象，block即copy才有三层</p><p><strong>_Block_object_dispose分析</strong></p><p>同一般的 <code>retain</code> 和 <code>release</code> 一样，<code>_Block_object_dispose</code> 其本质主要是 <code>retain</code>，所以对应的还有一个 <code>release</code>，即 <code>_Block_object_dispose</code> 方法，其源码实现如下，也是通过区分block种类，进行不同释放操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// When Blocks or Block_byrefs hold objects their destroy helper routines call this entry point</span><br><span class="line">// to help dispose of the contents 当Blocks或Block_byrefs持有对象时，其销毁助手例程将调用此入口点以帮助处置内容</span><br><span class="line">void _Block_object_dispose(const void *object, const int flags) &#123;</span><br><span class="line">    switch (os_assumes(flags &amp; BLOCK_ALL_COPY_DISPOSE_FLAGS)) &#123;</span><br><span class="line">      case BLOCK_FIELD_IS_BYREF | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">      case BLOCK_FIELD_IS_BYREF://__block修饰的变量，即bref类型的</span><br><span class="line">        // get rid of the __block data structure held in a Block</span><br><span class="line">        _Block_byref_release(object);</span><br><span class="line">        break;</span><br><span class="line">      case BLOCK_FIELD_IS_BLOCK://block类型的变量</span><br><span class="line">        _Block_release(object) ;</span><br><span class="line">        break;</span><br><span class="line">      case BLOCK_FIELD_IS_OBJECT://普通对象</span><br><span class="line">        _Block_release_object(object);</span><br><span class="line">        break;</span><br><span class="line">      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT:</span><br><span class="line">      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK:</span><br><span class="line">      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK  | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入 <code>_Block_byref_release</code> 源码，主要就是对象、变量的释放销毁</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void _Block_byref_release(const void *arg) &#123;</span><br><span class="line">    //对象强转为Block_byref类型结构体</span><br><span class="line">    struct Block_byref *byref = (struct Block_byref *)arg;</span><br><span class="line"></span><br><span class="line">    // dereference the forwarding pointer since the compiler isn&#x27;t doing this anymore (ever?)</span><br><span class="line">    byref = byref-&gt;forwarding;//取消指针引用</span><br><span class="line">    </span><br><span class="line">    if (byref-&gt;flags &amp; BLOCK_BYREF_NEEDS_FREE) &#123;</span><br><span class="line">        int32_t refcount = byref-&gt;flags &amp; BLOCK_REFCOUNT_MASK;</span><br><span class="line">        os_assert(refcount);</span><br><span class="line">        if (latching_decr_int_should_deallocate(&amp;byref-&gt;flags)) &#123;</span><br><span class="line">            if (byref-&gt;flags &amp; BLOCK_BYREF_HAS_COPY_DISPOSE) &#123;//是否有拷贝辅助函数</span><br><span class="line">                struct Block_byref_2 *byref2 = (struct Block_byref_2 *)(byref+1);</span><br><span class="line">                (*byref2-&gt;byref_destroy)(byref);//销毁拷贝对象</span><br><span class="line">            &#125;</span><br><span class="line">            free(byref);//释放</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，综上所述，Block的 <code>三层copy</code> 的流程如下图所示：</p><p><img src="/BboyZJ.github.io/assets/16508774872343.png"></p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理29：锁的原理</title>
      <link href="/BboyZJ.github.io/2021/04/10/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8629%EF%BC%9A%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/BboyZJ.github.io/2021/04/10/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8629%EF%BC%9A%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要介绍常见的锁，以及 <code>synchronized、NSLock、递归锁、条件锁</code> 的底层分析</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>借鉴一张锁的性能数据对比图，如下所示</p><p><img src="https://user-images.githubusercontent.com/25925248/162384806-7de609e9-b21f-4647-82db-7725dcf59ab4.jpg"></p><p>可以看出，图中锁的性能从高到底依次是：<code>OSSPinLock(自旋锁) -&gt; dispatch_semaphone(信号量) -&gt; ptread_mutex(互斥锁) -&gt; OSSPinLock(自旋锁) -&gt; NSCondition(条件锁) -&gt; pthread_mutex(recusive 互斥锁) -&gt; NSRecursiveLock(递归锁) -&gt; NSConditionLock(条件锁) -&gt; synchronized(互斥锁)</code> </p><p>图中大致分为以下几类：</p><ul><li><p>【自旋锁】：在自旋锁中，<code>线程会反复检查变量是否可用</code>。由于线程这个过程中一致保持执行，所以是一种忙等待。一旦获取了自旋锁，线程 <code>就会一直保持该锁</code>，直到显示释放自旋锁。自旋锁避免了进程上下文的调度开销，因此对于 <code>线程只会阻塞很短时间的场合</code> 是 <code>有效</code> 的。对于iOS属性的修饰符 <code>atomic</code>，自带一把自旋锁</p><ul><li>OSSpinLock</li><li>atomic</li></ul></li><li><p>【互斥锁】：<code>互斥锁</code> 是一种用于 <code>多线程编程</code> 中，<code>防止两条线程同时对同一公共资源（例如全局变量）进行读写的机制</code>，该目的是通过 <code>将代码切成一个个临界区</code> 而达成</p><ul><li>@synchroized</li><li>NSLock</li><li>pthread_mutex</li></ul></li><li><p>【条件锁】：<code>条件锁</code> 就是 <code>条件变量</code>，当进程的某些 <code>资源要求不满足</code> 时就 <code>进入休眠</code>，即锁住了，当 <code>资源被分配到了</code>，<code>条件锁打开了</code>，进程继续进行</p><ul><li>NSCondition</li><li>NSConditionLock</li></ul></li><li><p>【递归锁】：递归锁就是 <code>同一个线程可以加锁N次而不会引发死锁</code>。递归锁是 <code>特殊的互斥锁</code>，即是 <code>带有递归性质的互斥锁</code></p><ul><li>pthread_mutex(recursive)</li><li>NSRecursiveLock</li></ul></li><li><p>【信号量】：<code>信号量</code> 是一种 <code>更高级的同步机制</code>，<code>互斥锁</code> 可以说是 <code>semaphore在取值0/1时的特例</code>，信号量可以有更多的取值空间，用来 <code>实现更加复杂的同步</code>，而不是单单的线程间互斥</p><ul><li>dispatch_semaphore</li></ul></li><li><p>【读写锁】：读写锁实际是一种 <code>特殊的自旋锁</code>。将对共享资源的访问分成 <code>读者</code> 和 <code>写者</code>，<code>读者</code> 只对共享资源 <code>进行读访问</code>，<code>写者</code> 则需要对共享资源 <code>进行写操作</code>，这种锁相对于自旋锁而言，能 <code>提高并发性</code></p><ul><li><p><code>一个读写锁同时只能有一个写者或者多个读者</code>，但不能即有读者又有写者，在读写锁保持期间也是抢占失效的</p></li><li><p>如果 <code>读写锁当前没有读者，也没有写者</code>，那么写者 <code>可以立刻获取</code> 读写锁，<code>否则它必须自旋</code> 在那里，直到没有任何写者或读者，如果读写锁没有写者，那么读者可以 立即获取读写锁</p></li></ul></li></ul><p>其实 <code>基本的锁</code> 就包括三类：<code>自旋锁、互斥锁、读写锁</code>，其他的比如 <code>条件锁、递归锁、信号量</code> 都是 <code>上层的封装和实现</code></p><h2 id="OSSpinLock（自旋锁）"><a href="#OSSpinLock（自旋锁）" class="headerlink" title="OSSpinLock（自旋锁）"></a>OSSpinLock（自旋锁）</h2><p>自从 <code>OSSpinLock</code> 出现安全问题，在iOS10之后就被废弃了，自旋锁之所有不安全，是因为 <code>获取锁后，线程会一直处于忙等待</code>，造成了 <code>任务的优先级反转</code>。</p><p>其中的忙等待机制可能会造成 <code>高优先级任务一直runing等待</code>，占用时间片，而 低优先级的任务无法抢占时间片，会造成一直不能完成，锁未释放的情况</p><p>在 <code>OSSpinLock</code> 被废弃后，其替代方案是内部封装了 <code>os_unfair_lock</code>，而 <code>os_unfair_lock</code> 在加锁时会处于 <code>休眠状态</code>，而不是自旋锁的忙等待状态</p><h2 id="atomic（原子锁）"><a href="#atomic（原子锁）" class="headerlink" title="atomic（原子锁）"></a>atomic（原子锁）</h2><p><code>atomic</code> 适用于OC中属性的修饰符，其 <code>自带一把自旋锁</code>，但是这个一般基本不使用，都是使用的 <code>nonatomic</code></p><p>在前面的文章中，我们提及 <code>setter</code> 方法会根据修饰符调用不同的方法，其中最后会统一调用 <code>reallySetProperty</code> 方法，其中就有 <code>atomic</code> 和 <code>非atomic</code> 的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   id *slot = (id*) ((char*)self + offset);</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    if (!atomic) &#123; // 未加锁</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; else &#123; // 加锁</span><br><span class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，对于 <code>atomic</code> 修饰的属性，进行了 <code>spinlock_t</code> 加锁处理，但是在前文中提到 <code>OSSpinLock</code> 已经废弃了，这里的 <code>spinlock_t</code> 在底层是通过 <code>os_unfair_lock</code> 替代了 <code>OSSpinLock</code> 实现的加锁。同时为了 <code>防止哈希冲突</code>，还是用了 <code>加盐</code> 操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">using spinlock_t = mutex_tt&lt;LOCKDEBUG&gt;;</span><br><span class="line"></span><br><span class="line">class mutex_tt : nocopy_t &#123;</span><br><span class="line">    os_unfair_lock mLock;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getter</code> 方法中对 <code>atomic</code> 的处理，同 <code>setter</code> 是大致相同的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) &#123;</span><br><span class="line">    if (offset == 0) &#123;</span><br><span class="line">        return object_getClass(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Retain release world</span><br><span class="line">    id *slot = (id*) ((char*)self + offset);</span><br><span class="line">    if (!atomic) return *slot;</span><br><span class="line">        </span><br><span class="line">    // Atomic retain release world</span><br><span class="line">    spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock(); // 加锁</span><br><span class="line">    id value = objc_retain(*slot);</span><br><span class="line">    slotlock.unlock(); // 解锁</span><br><span class="line">    </span><br><span class="line">    // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span><br><span class="line">    return objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized-互斥递归锁"><a href="#synchronized-互斥递归锁" class="headerlink" title="synchronized(互斥递归锁)"></a>synchronized(互斥递归锁)</h2><ul><li>开启汇编模式，发现 <code>@synchronized</code> 在执行过程中，会走底层的 <code>objc_sync_enter</code> 和 <code>objc_sync_exit</code> 方法</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162385051-568d26bd-bdca-42b8-bee0-c19df0e24650.jpg"></p><ul><li>也可以通过 <code>clang</code>，查看底层编译代码</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162385128-79078c6e-06eb-4504-81bf-6d9bd853d64e.jpg"></p><ul><li>通过对 <code>objc_sync_enter</code> 方法符号断点，查看底层所在的源码库，通过断点发现在objc源码中，即 <code>libpbjc.A.dylib</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162385206-77e55e7f-a364-4e91-979f-74fe56505b3c.jpg"></p><h3 id="objc-sync-enter-amp-objc-sync-exit-分析"><a href="#objc-sync-enter-amp-objc-sync-exit-分析" class="headerlink" title="objc_sync_enter &amp; objc_sync_exit 分析"></a>objc_sync_enter &amp; objc_sync_exit 分析</h3><ul><li><p>进入 <code>objc_sync_enter</code> 源码实现</p><ul><li>如果obj存在，则通过 <code>id2data</code> 方法获取响应的 <code>SyncData</code>，对 <code>threadCount、lockCount</code> 进行 <code>递增</code> 操作</li><li>如果obj不存在，则调用 <code>objc_sync_nil</code>，通过符号断点得知，这个方法里面什么都没做，直接return了</li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162385270-d991739c-6f16-4117-b269-1de19800106d.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int objc_sync_enter(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    int result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    if (obj) &#123; // 传入不为nil</span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE); // 重点</span><br><span class="line">        ASSERT(data);</span><br><span class="line">        data-&gt;mutex.lock(); // 加锁</span><br><span class="line">    &#125; else &#123; // 传入nil</span><br><span class="line">        // @synchronized(nil) does nothing</span><br><span class="line">        if (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(&quot;NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>进入 <code>objc_sync_exit</code> 源码实现</p><ul><li>如果obj存在，则调用 <code>id2data</code> 方法获取对应的SyncData，对 <code>threadCount、lockCount</code> 进行 <code>递减</code> 操作</li><li>如果obj不存在，什么也不做</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// End synchronizing on &#x27;obj&#x27;. 结束对“ obj”的同步</span><br><span class="line">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span><br><span class="line">int objc_sync_exit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    int result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    if (obj) &#123;//obj不为nil</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); </span><br><span class="line">        if (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            bool okay = data-&gt;mutex.tryUnlock();//解锁</span><br><span class="line">            if (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;//obj为nil时，什么也不做</span><br><span class="line">        // @synchronized(nil) does nothing</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面两个实现逻辑的对比，发现它们有一个共同点，在obj存在时，都会通过 id2data 方法，获取 <code>SyncData</code></p><ul><li>进入 <code>SyncData</code> 的定义，是一个结构体，主要用来表示一个 <code>线程data</code>，类似于 <code>链表结构</code>，有next指向，且封装了 <code>recursive_mutex_t</code> 属性，可以确认 <code>@synchronized</code> 确实是一个 <code>递归互斥锁</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct alignas(CacheLineSize) SyncData &#123;</span><br><span class="line">    struct SyncData* nextData;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object; // 类似链表结构</span><br><span class="line">    int32_t threadCount;  // number of THREADS using this block</span><br><span class="line">    recursive_mutex_t mutex; // 递归锁</span><br><span class="line">&#125; SyncData;</span><br></pre></td></tr></table></figure><ul><li>进入 <code>SyncCache</code> 的定义，也是一个结构体，用于存储线程，其中 <code>list[0]</code> 表示 <code>当前线程的链表data</code>，主要用于存储 <code>SyncData</code> 和 <code>lockCount</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    SyncData *data;</span><br><span class="line">    unsigned int lockCount;  // number of times THIS THREAD locked this block</span><br><span class="line">&#125; SyncCacheItem;</span><br><span class="line"></span><br><span class="line">typedef struct SyncCache &#123;</span><br><span class="line">    unsigned int allocated;</span><br><span class="line">    unsigned int used;</span><br><span class="line">    SyncCacheItem list[0];</span><br><span class="line">&#125; SyncCache;</span><br></pre></td></tr></table></figure><h3 id="id2data-分析"><a href="#id2data-分析" class="headerlink" title="id2data 分析"></a>id2data 分析</h3><ul><li>进入 <code>id2data</code> 源码，从上面的分析，可以看出，这个方法是 <code>加锁和解锁</code> 都复用的方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">static SyncData* id2data(id object, enum usage why)</span><br><span class="line">&#123;</span><br><span class="line">    spinlock_t *lockp = &amp;LOCK_FOR_OBJ(object);</span><br><span class="line">    SyncData **listp = &amp;LIST_FOR_OBJ(object);</span><br><span class="line">    SyncData* result = NULL;</span><br><span class="line"></span><br><span class="line">#if SUPPORT_DIRECT_THREAD_KEYS //tls（Thread Local Storage，本地局部的线程缓存）</span><br><span class="line">    // Check per-thread single-entry fast cache for matching object</span><br><span class="line">    bool fastCacheOccupied = NO;</span><br><span class="line">    //通过KVC方式对线程进行获取 线程绑定的data</span><br><span class="line">    SyncData *data = (SyncData *)tls_get_direct(SYNC_DATA_DIRECT_KEY);</span><br><span class="line">    //如果线程缓存中有data，执行if流程</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        fastCacheOccupied = YES;</span><br><span class="line">        //如果在线程空间找到了data</span><br><span class="line">        if (data-&gt;object == object) &#123;</span><br><span class="line">            // Found a match in fast cache.</span><br><span class="line">            uintptr_t lockCount;</span><br><span class="line"></span><br><span class="line">            result = data;</span><br><span class="line">            //通过KVC获取lockCount，lockCount用来记录 被锁了几次，即 该锁可嵌套</span><br><span class="line">            lockCount = (uintptr_t)tls_get_direct(SYNC_COUNT_DIRECT_KEY);</span><br><span class="line">            if (result-&gt;threadCount &lt;= 0  ||  lockCount &lt;= 0) &#123;</span><br><span class="line">                _objc_fatal(&quot;id2data fastcache is buggy&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            switch(why) &#123;</span><br><span class="line">            case ACQUIRE: &#123;</span><br><span class="line">                //objc_sync_enter走这里，传入的是ACQUIRE -- 获取</span><br><span class="line">                lockCount++;//通过lockCount判断被锁了几次，即表示 可重入（递归锁如果可重入，会死锁）</span><br><span class="line">                tls_set_direct(SYNC_COUNT_DIRECT_KEY, (void*)lockCount);//设置</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case RELEASE:</span><br><span class="line">                //objc_sync_exit走这里，传入的why是RELEASE -- 释放</span><br><span class="line">                lockCount--;</span><br><span class="line">                tls_set_direct(SYNC_COUNT_DIRECT_KEY, (void*)lockCount);</span><br><span class="line">                if (lockCount == 0) &#123;</span><br><span class="line">                    // remove from fast cache</span><br><span class="line">                    tls_set_direct(SYNC_DATA_DIRECT_KEY, NULL);</span><br><span class="line">                    // atomic because may collide with concurrent ACQUIRE</span><br><span class="line">                    OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case CHECK:</span><br><span class="line">                // do nothing</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // Check per-thread cache of already-owned locks for matching object</span><br><span class="line">    SyncCache *cache = fetch_cache(NO);//判断缓存中是否有该线程</span><br><span class="line">    //如果cache中有，方式与线程缓存一致</span><br><span class="line">    if (cache) &#123;</span><br><span class="line">        unsigned int i;</span><br><span class="line">        for (i = 0; i &lt; cache-&gt;used; i++) &#123;//遍历总表</span><br><span class="line">            SyncCacheItem *item = &amp;cache-&gt;list[i];</span><br><span class="line">            if (item-&gt;data-&gt;object != object) continue;</span><br><span class="line"></span><br><span class="line">            // Found a match.</span><br><span class="line">            result = item-&gt;data;</span><br><span class="line">            if (result-&gt;threadCount &lt;= 0  ||  item-&gt;lockCount &lt;= 0) &#123;</span><br><span class="line">                _objc_fatal(&quot;id2data cache is buggy&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            switch(why) &#123;</span><br><span class="line">            case ACQUIRE://加锁</span><br><span class="line">                item-&gt;lockCount++;</span><br><span class="line">                break;</span><br><span class="line">            case RELEASE://解锁</span><br><span class="line">                item-&gt;lockCount--;</span><br><span class="line">                if (item-&gt;lockCount == 0) &#123;</span><br><span class="line">                    // remove from per-thread cache 从cache中清除使用标记</span><br><span class="line">                    cache-&gt;list[i] = cache-&gt;list[--cache-&gt;used];</span><br><span class="line">                    // atomic because may collide with concurrent ACQUIRE</span><br><span class="line">                    OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case CHECK:</span><br><span class="line">                // do nothing</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Thread cache didn&#x27;t find anything.</span><br><span class="line">    // Walk in-use list looking for matching object</span><br><span class="line">    // Spinlock prevents multiple threads from creating multiple </span><br><span class="line">    // locks for the same new object.</span><br><span class="line">    // We could keep the nodes in some hash table if we find that there are</span><br><span class="line">    // more than 20 or so distinct locks active, but we don&#x27;t do that now.</span><br><span class="line">    //第一次进来，所有缓存都找不到</span><br><span class="line">    lockp-&gt;lock();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        SyncData* p;</span><br><span class="line">        SyncData* firstUnused = NULL;</span><br><span class="line">        for (p = *listp; p != NULL; p = p-&gt;nextData) &#123;//cache中已经找到</span><br><span class="line">            if ( p-&gt;object == object ) &#123;//如果不等于空，且与object相似</span><br><span class="line">                result = p;//赋值</span><br><span class="line">                // atomic because may collide with concurrent RELEASE</span><br><span class="line">                OSAtomicIncrement32Barrier(&amp;result-&gt;threadCount);//对threadCount进行++</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">            if ( (firstUnused == NULL) &amp;&amp; (p-&gt;threadCount == 0) )</span><br><span class="line">                firstUnused = p;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // no SyncData currently associated with object 没有与当前对象关联的SyncData</span><br><span class="line">        if ( (why == RELEASE) || (why == CHECK) )</span><br><span class="line">            goto done;</span><br><span class="line">    </span><br><span class="line">        // an unused one was found, use it 第一次进来，没有找到</span><br><span class="line">        if ( firstUnused != NULL ) &#123;</span><br><span class="line">            result = firstUnused;</span><br><span class="line">            result-&gt;object = (objc_object *)object;</span><br><span class="line">            result-&gt;threadCount = 1;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Allocate a new SyncData and add to list.</span><br><span class="line">    // XXX allocating memory with a global lock held is bad practice,</span><br><span class="line">    // might be worth releasing the lock, allocating, and searching again.</span><br><span class="line">    // But since we never free these guys we won&#x27;t be stuck in allocation very often.</span><br><span class="line">    posix_memalign((void **)&amp;result, alignof(SyncData), sizeof(SyncData));//创建赋值</span><br><span class="line">    result-&gt;object = (objc_object *)object;</span><br><span class="line">    result-&gt;threadCount = 1;</span><br><span class="line">    new (&amp;result-&gt;mutex) recursive_mutex_t(fork_unsafe_lock);</span><br><span class="line">    result-&gt;nextData = *listp;</span><br><span class="line">    *listp = result;</span><br><span class="line">    </span><br><span class="line"> done:</span><br><span class="line">    lockp-&gt;unlock();</span><br><span class="line">    if (result) &#123;</span><br><span class="line">        // Only new ACQUIRE should get here.</span><br><span class="line">        // All RELEASE and CHECK and recursive ACQUIRE are </span><br><span class="line">        // handled by the per-thread caches above.</span><br><span class="line">        if (why == RELEASE) &#123;</span><br><span class="line">            // Probably some thread is incorrectly exiting </span><br><span class="line">            // while the object is held by another thread.</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        if (why != ACQUIRE) _objc_fatal(&quot;id2data is buggy&quot;);</span><br><span class="line">        if (result-&gt;object != object) _objc_fatal(&quot;id2data is buggy&quot;);</span><br><span class="line"></span><br><span class="line">#if SUPPORT_DIRECT_THREAD_KEYS</span><br><span class="line">        if (!fastCacheOccupied) &#123; //判断是否支持栈存缓存，支持则通过KVC形式赋值 存入tls</span><br><span class="line">            // Save in fast thread cache</span><br><span class="line">            tls_set_direct(SYNC_DATA_DIRECT_KEY, result);</span><br><span class="line">            tls_set_direct(SYNC_COUNT_DIRECT_KEY, (void*)1);//lockCount = 1</span><br><span class="line">        &#125; else </span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            // Save in thread cache 缓存中存一份</span><br><span class="line">            if (!cache) cache = fetch_cache(YES);//第一次存储时，对线程进行了绑定</span><br><span class="line">            cache-&gt;list[cache-&gt;used].data = result;</span><br><span class="line">            cache-&gt;list[cache-&gt;used].lockCount = 1;</span><br><span class="line">            cache-&gt;used++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>【第一步】首页在 <code>tls</code> 即 <code>线程缓存</code> 中查找</p><ul><li><p>在 <code>tls_get_direct</code> 方法中以 <code>线程为key</code>，通过 <code>KVC</code> 的方式获取与之绑定的 <code>SyncData</code>，即线程 <code>data</code>，其中的 <code>tls()</code>，表示 <code>本地局部的线程缓存</code></p></li><li><p>判断获取的data是否存在，以及判断data中是否能找到对应的objct</p></li><li><p>如果都找到了，在 <code>tls_get_direct</code> 方法中以KVC的方式获取 <code>lockcount</code>，用来记录 <code>对象被锁了几次（即锁的嵌套次数）</code></p></li><li><p>如果data中的 <code>threadCount</code> 小于等于0，或者 <code>lockCount</code> 小于等于0时，则直接崩溃</p></li><li><p>通过传入的 <code>why</code>，判断操作类型</p><ul><li>如果是 <code>ACQUIRE</code>，表示加锁，则进行lockCount++，并保存到tls缓存</li><li>如果是 <code>RELEASE</code>，表示释放，则进行lockCount++，并保存到tls缓存，如果 lockCount <code>等于</code> 0，从tls中 <code>移除</code> 线程data</li><li>如果是 <code>CHECK</code>，则什么也不做</li></ul></li><li><p>【第二步】如果 <code>tls</code> 中没有，则在 <code>cache缓存</code> 中查找</p><ul><li>通过 <code>fetch_cache</code> 方法查找cache缓存中是否有线程</li><li>如果有，则遍历cache总表，读取出线程对应的 <code>SyncCacheItem</code></li><li>从 <code>SyncCacheItem</code> 中取出 <code>data</code>，然后后续步骤与tls的匹配是一致的</li></ul></li><li><p>【第三步】如果cache中也没有，即 <code>第一次进来</code>，则创建 <code>SyncData</code>，并存储到相应缓存中</p><ul><li>如果在cache中找到线程，且与object相等，则进行 <code>赋值</code>、以及 <code>threadCount++</code></li><li>如果在cache中没有找到，则 <code>threadCount</code> 等于 <code>1</code>.</li></ul></li></ul><p>  所以在 <code>id2data</code> 方法中，主要分为三种情况</p><ul><li><p>【第一次进来，没有锁】</p><ul><li>threadCount &#x3D; 1</li><li>lockCount &#x3D; 1</li><li>存储到 <code>tls</code></li></ul></li><li><p>【不是第一次进来，且是同一个线程】</p><ul><li>tls中有数据，则 <code>lockCount++</code></li><li>存储到 <code>tls</code></li></ul></li><li><p>【不是第一次进来，且是不同线程】</p><ul><li>全局线程空间 进行查找线程</li><li>threadCount++</li><li>lockCount++</li><li>存储到 <code>cache</code></li></ul></li></ul><h3 id="tls和cache表结构"><a href="#tls和cache表结构" class="headerlink" title="tls和cache表结构"></a>tls和cache表结构</h3><p>  针对tls和cache缓存，底层的表结构如下所示</p><p>  <img src="https://user-images.githubusercontent.com/25925248/162385336-7498d9db-3f35-4e35-81e0-d499019ca308.jpg"></p></li><li><p><code>哈希表</code> 结构中通过 <code>SyncList</code> 结构来组装 <code>多线程</code> 的情况</p></li><li><p><code>SyncData</code> 通过 <code>链表</code> 的形式组装 <code>当前可重入</code> 的情况</p></li><li><p>下层通过 <code>tls线程缓存、cache缓存</code> 来进行 <code>处理</code></p></li><li><p>底层主要有两个东西：<code>lockCount、threadCount</code>，解决了递归互斥锁，解决了嵌套可重入</p></li></ul><h3 id="synchronized-坑点"><a href="#synchronized-坑点" class="headerlink" title="@synchronized 坑点"></a>@synchronized 坑点</h3><p>下面代码这样写，会有什么问题？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> - (void)zj_testSync&#123;</span><br><span class="line">    _testArray = [NSMutableArray array];</span><br><span class="line">    for (int i = 0; i &lt; 200000; i++) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">            @synchronized (self.testArray) &#123;</span><br><span class="line">                self.testArray = [NSMutableArray array];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果发现，运行就崩溃</p><p><img src="https://user-images.githubusercontent.com/25925248/162385390-988c981b-e27a-4513-96df-eb52ecc624a2.jpg"></p><p>崩溃的主要原因是 <code>testArray</code> 在某一瞬间变成了nil，从@synchronized底层流程可知，如果 <code>加锁的对象成了nil，是锁不住的</code>，相当于下面这种情况，block内部不停的retain、release，会在某一瞬间 <code>上一个未release</code>，<code>下一个已经准备release</code>，这样会导致 <code>野指针</code> 的产生</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)zj_crash&#123;</span><br><span class="line">    _testArray = [NSMutableArray array];</span><br><span class="line">    for (int i = 0; i &lt; 200000; i++) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">            _testArray = [NSMutableArray array];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以根据上面的代码，打开 edit scheme -&gt; run -&gt; Diagnostics 中勾选 Zombie Objects，来查看是否存在僵尸对象，结果如下所示</p><p><img src="https://user-images.githubusercontent.com/25925248/162385433-ed10895f-0a52-44be-9544-79cfb4eae6a0.jpg"></p><p>我们一般使用 <code>@synchronized(self)</code>，主要是因为 <code>_testArray</code> 的持有者是 <code>self</code></p><p><strong>注意：野指针 vs 过度释放</strong></p><ul><li><p>野指针：是指由于过度释放产生的指针还在进行操作</p></li><li><p>过度释放：每次都会 <code>retain</code> 和 <code>release</code></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><code>@synchronized</code> 在底层封装的是一把 <code>递归锁</code>，所以这个锁是 <code>递归互斥锁</code></p></li><li><p><code>@synchronized</code> 的可重入，即可 <code>嵌套</code>，主要是由于 <code>lockCount</code> 和 <code>threadCount</code> 的搭配</p></li><li><p><code>@synchronized</code> 使用 <code>链表</code> 的原因是 <code>链表方便下一个data的插入</code></p></li><li><p>但是由于底层中 <code>链表查询、缓存的查找以及递归</code>，是非常 <code>耗内存</code> 以及 <code>性能</code> 的，导致 <code>性能低</code>，所以在前文中，该锁的排名在最后</p></li><li><p>不能使用 <code>非OC对象</code> 作为加锁对象，因为其 <code>object</code> 的参数为 <code>id</code></p></li><li><p><code>@synchronized(self)</code> 这种适用于 <code>嵌套次数较少</code> 的场景。这里锁住的对象也 <code>并不永远是self</code>，这里需要读者注意</p></li><li><p>如果锁嵌套次数较多，即 <code>锁self过多</code>，会导致底层的查找非常麻烦，因为其底层是链表进行查找，所以会相对比较麻烦，所以此时可以使用 <code>NSLock、信号量</code> 等</p></li></ul><h1 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h1><p><code>NSLock</code> 是对 <code>下层phread_mutex</code> 的封装，使用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSLock *lock = [[NSLock alloc] init];</span><br><span class="line">[lock lock];</span><br><span class="line">[lock unlock];</span><br></pre></td></tr></table></figure><p>直接进入 <code>NSLock</code> 定义查看，其遵循了 <code>NSLocking</code> 协议，下面来探索 <code>NSLock</code> 的底层实现</p><h2 id="NSLock底层分析"><a href="#NSLock底层分析" class="headerlink" title="NSLock底层分析"></a>NSLock底层分析</h2><ul><li>通过加符号断点 <code>lock</code> 分析，发现其源码在 <code>Foundation</code> 框架中</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162385488-881745a9-4c48-47bb-aa64-0d73612e032c.jpg"></p><ul><li>由于OC的 <code>Foundation</code> 框架不开源，所以这里借助 <code>Swift</code> 的开源框架 <code>Foundation</code> 来分析 <code>NSLock</code> 的底层实现，其原理与OC是大致相同的</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162385542-717dcf74-31a0-458c-a917-d88299104e46.jpg"></p><p>通过源码实现可以看出，底层是通过 pthread_mutex 互斥锁实现的，并且在init方法中，还做了一些其他操作，所以在使用NSLock时需要使用init初始化</p><p>回到前文的性能图中，可以看出 <code>NSLock</code> 的性能仅次于 <code>pthread_mutex（互斥锁）</code>，非常接近</p><h2 id="使用弊端"><a href="#使用弊端" class="headerlink" title="使用弊端"></a>使用弊端</h2><p>请问下面block嵌套block的代码中，会有什么问题？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (int i= 0; i&lt;100; i++) &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        static void (^testMethod)(int);</span><br><span class="line">        testMethod = ^(int value)&#123;</span><br><span class="line">            if (value &gt; 0) &#123;</span><br><span class="line">              NSLog(@&quot;current value = %d&quot;,value);</span><br><span class="line">              testMethod(value - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        testMethod(10);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li>在未加锁之前，其中current打印的结果数据混乱，主要原因是多线程导致的</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162385589-9fda7c62-63d9-4eb2-a14a-c3d1a48fe7da.jpg"></p><ul><li>如果像下面这样加锁，会有什么问题？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSLock * lock = [[NSLock alloc] init];</span><br><span class="line">for (int i= 0; i&lt;100; i++) &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        static void (^testMethod)(int);</span><br><span class="line">        testMethod = ^(int value)&#123;</span><br><span class="line">            [lock lock];</span><br><span class="line">            if (value &gt; 0) &#123;</span><br><span class="line">              NSLog(@&quot;current value = %d&quot;,value);</span><br><span class="line">              testMethod(value - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        testMethod(10);</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会出现一直等待的情况，主要是因为 <code>嵌套使用的递归</code>，使用 <code>NSLock</code>（简单的互斥锁，如果没有回来，会一直睡觉等待），即会存在一直加lock，等不到unlock的堵塞情况</p><p>所以，针对这种情况，可以使用以下方式解决</p><ul><li>使用 NSLock</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NSLock * lock = [[NSLock alloc] init];</span><br><span class="line">for (int i= 0; i&lt;100; i++) &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        static void (^testMethod)(int);</span><br><span class="line">        [lock lock];</span><br><span class="line">        testMethod = ^(int value)&#123;</span><br><span class="line">            if (value &gt; 0) &#123;</span><br><span class="line">              NSLog(@&quot;current value = %d&quot;,value);</span><br><span class="line">              testMethod(value - 1);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                [lock unlock];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        testMethod(10);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 <code>@synchronized</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for (int i= 0; i&lt;100; i++) &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        static void (^testMethod)(int);</span><br><span class="line">        testMethod = ^(int value)&#123;</span><br><span class="line">            @synchronized (self) &#123;</span><br><span class="line">                if (value &gt; 0) &#123;</span><br><span class="line">                  NSLog(@&quot;current value = %d&quot;,value);</span><br><span class="line">                  testMethod(value - 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        testMethod(10);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用递归锁 <code>NSRecursiveLock</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSRecursiveLock * lock = [[NSRecursiveLock alloc] init];</span><br><span class="line">for (int i= 0; i&lt;100; i++) &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        static void (^testMethod)(int);</span><br><span class="line">        [lock lock]; // 加锁</span><br><span class="line">        testMethod = ^(int value)&#123;</span><br><span class="line">            if (value &gt; 0) &#123;</span><br><span class="line">              NSLog(@&quot;current value = %d&quot;,value);</span><br><span class="line">              testMethod(value - 1);</span><br><span class="line">            &#125;</span><br><span class="line">            [lock unlock];</span><br><span class="line">        &#125;;</span><br><span class="line">        testMethod(10);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h1><p><code>pthread_mutex</code> 就是 <code>互斥锁本身</code>，当锁被占用，其他线程申请锁时，不会一直忙等待，而是 <code>阻塞线程并睡眠</code></p><p><strong>使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 导入头文件</span><br><span class="line">#import &lt;tphread.j&gt;</span><br><span class="line"></span><br><span class="line">// 全局声明互斥锁</span><br><span class="line">phread_mutex_t _lock;</span><br><span class="line"></span><br><span class="line">// 初始化互斥锁</span><br><span class="line">pthread_mutex_init(&amp;_lock, NULL);</span><br><span class="line"></span><br><span class="line">// 加锁</span><br><span class="line">pthread_mutex_lock(&amp;_lock);</span><br><span class="line"></span><br><span class="line">// 这里需要线程安全操作</span><br><span class="line">// 解锁</span><br><span class="line">pthread_mutex_unlock(&amp;_lock);</span><br><span class="line"></span><br><span class="line">// 释放锁</span><br><span class="line">pthread_mutex_destroy(&amp;_lock);</span><br></pre></td></tr></table></figure><h1 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a>NSRecursiveLock</h1><p><code>NSRecursiveLock</code> 在底层也是对 <code>pthread_mutex</code> 的封装，可以通过 <code>swift</code> 的 <code>Foundation</code> 源码查看</p><p><img src="https://user-images.githubusercontent.com/25925248/162385659-c67c46ec-a724-4195-99bf-7986671d0d14.jpg"></p><p>对比 <code>NSLock</code> 和 <code>NSRecursiveLock</code>，其底层实现几乎一模一样，区别在于init时，<code>NSRecursiveLock</code> 有一个标识 <code>PTHREAD_MUTEX_RECURSIVE</code> ，而 <code>NSLock</code> 是默认的</p><p><img src="https://user-images.githubusercontent.com/25925248/162385711-4cb86066-2d52-45c3-bf7b-de3b71ed1dbc.jpg"></p><p><code>递归锁</code> 主要是用于 <code>解决一些嵌套形式</code>，其中循环嵌套居多</p><h1 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h1><p><code>NSCondition</code> 是一个 <code>条件锁</code>，在日常开发中使用较少，与信号量有点相似：<code>线程1</code> 需要满足条件才会往下走，否则会堵塞等待，直到条件满足，经典模型是 <code>生产消费者模型</code></p><p><code>NSCondition的对象</code> 实际上作为一个 <code>锁</code> 和一个 <code>线程检查器</code></p><ul><li><code>锁</code> 主要为了 <code>当检测条件时保护数据源</code>，<code>执行条件引发的任务</code></li><li><code>线程检查器</code> 主要是 <code>根据条件决定是否继续运行线程</code>，即线程是否被 <code>阻塞</code></li></ul><p><strong>使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">NSCondition *condition = [[NSCondition alloc] init]</span><br><span class="line"></span><br><span class="line">// 一般用于多线程同时访问、修改同一个数据源，保证在同一 时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到 unlock ，才可访问</span><br><span class="line">[condition lock];</span><br><span class="line"></span><br><span class="line">// 与lock 同时使用</span><br><span class="line">[condition unlock];</span><br><span class="line"></span><br><span class="line">// 让当前线程处于等待状态</span><br><span class="line">[condition wait];</span><br><span class="line"></span><br><span class="line">// CPU发信号告诉线程不用在等待，可以继续执行</span><br><span class="line">[condition signal];</span><br></pre></td></tr></table></figure><h2 id="底层分析"><a href="#底层分析" class="headerlink" title="底层分析"></a>底层分析</h2><p>通过swift的Foundation源码查看 <code>NSCondition</code> 的底层实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">open class NSCondition: NSObject, NSLocking &#123;</span><br><span class="line">    internal var mutex = _MutexPointer.allocate(capacity: 1)</span><br><span class="line">    internal var cond = _ConditionVariablePointer.allocate(capacity: 1)</span><br><span class="line">    //初始化</span><br><span class="line">    public override init() &#123;</span><br><span class="line">        pthread_mutex_init(mutex, nil)</span><br><span class="line">        pthread_cond_init(cond, nil)</span><br><span class="line">    &#125;</span><br><span class="line">    //析构</span><br><span class="line">    deinit &#123;</span><br><span class="line">        pthread_mutex_destroy(mutex)</span><br><span class="line">        pthread_cond_destroy(cond)</span><br><span class="line"></span><br><span class="line">        mutex.deinitialize(count: 1)</span><br><span class="line">        cond.deinitialize(count: 1)</span><br><span class="line">        mutex.deallocate()</span><br><span class="line">        cond.deallocate()</span><br><span class="line">    &#125;</span><br><span class="line">    //加锁</span><br><span class="line">    open func lock() &#123;</span><br><span class="line">        pthread_mutex_lock(mutex)</span><br><span class="line">    &#125;</span><br><span class="line">    //解锁</span><br><span class="line">    open func unlock() &#123;</span><br><span class="line">        pthread_mutex_unlock(mutex)</span><br><span class="line">    &#125;</span><br><span class="line">    //等待</span><br><span class="line">    open func wait() &#123;</span><br><span class="line">        pthread_cond_wait(cond, mutex)</span><br><span class="line">    &#125;</span><br><span class="line">    //等待</span><br><span class="line">    open func wait(until limit: Date) -&gt; Bool &#123;</span><br><span class="line">        guard var timeout = timeSpecFrom(date: limit) else &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        return pthread_cond_timedwait(cond, mutex, &amp;timeout) == 0</span><br><span class="line">    &#125;</span><br><span class="line">    //信号，表示等待的可以执行了</span><br><span class="line">    open func signal() &#123;</span><br><span class="line">        pthread_cond_signal(cond)</span><br><span class="line">    &#125;</span><br><span class="line">    //广播</span><br><span class="line">    open func broadcast() &#123;</span><br><span class="line">        // 汇编分析 - 猜 (多看多玩)</span><br><span class="line">        pthread_cond_broadcast(cond) // wait  signal</span><br><span class="line">    &#125;</span><br><span class="line">    open var name: String?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其底层也是对下层 <code>pthread_mutex</code> 的封装</p><ul><li><p><code>NSCondition</code> 是对 <code>mutex</code> 和 <code>cond</code> 的一种封装（cond就是用于访问和操作特定类型数据的指针）</p></li><li><p><code>wait</code> 操作会 <code>阻塞线程</code>，使其进入 <code>休眠状态</code>，直至超时</p></li><li><p><code>signal</code> 操作是 <code>唤醒</code> 一个正在休眠等待的线程</p></li><li><p><code>broadcast</code> 会唤醒所有在等待的线程</p></li></ul><h1 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h1><p><code>NSConditionLock</code> 是条件锁，一旦一个线程获取锁，其他线程一定等待</p><p>相比 <code>NSConditionLock</code> 而言，<code>NSCondition</code> 使用比较麻烦，所以推荐使用 <code>NSConditionLock</code> ,其使用如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">NSConditionLock * conditionLock = [[NSConditionLock alloc] initWithCondition:2];</span><br><span class="line"></span><br><span class="line">// 表示 conditionLock 期待获得锁，如果没有其他线程获得锁(不需要判断内部的 condition) 那它能执行此行以下代码，如果已经有其他线程获得锁(可能是条件锁，或者无条件 锁)，则等待，直至其他线程解锁</span><br><span class="line">[conditionLock lock]; </span><br><span class="line"></span><br><span class="line">// 表示如果没有其他线程获得该锁，但是该锁内部的 condition不等于A条件，它依然不能获得锁，仍然等待。如果内部的condition等于A条件，并且 没有其他线程获得该锁，则进入代码区，同时设置它获得该锁，其他任何线程都将等待它代码的 完成，直至它解锁。</span><br><span class="line">[conditionLock lockWhenCondition:A条件]; </span><br><span class="line"></span><br><span class="line">// 表示释放锁，同时把内部的condition设置为A条件</span><br><span class="line">[conditionLock unlockWithCondition:A条件]; </span><br><span class="line"></span><br><span class="line">// 表示如果被锁定(没获得 锁)，并超过该时间则不再阻塞线程。但是注意:返回的值是NO,它没有改变锁的状态，这个函 数的目的在于可以实现两种状态下的处理</span><br><span class="line">return = [conditionLock lockWhenCondition:A条件 beforeDate:A时间];</span><br><span class="line"></span><br><span class="line">// 其中所谓的condition就是整数，内部通过整数比较条件</span><br></pre></td></tr></table></figure><p><code>NSConditionLock</code> ，其本质就是 <code>NSCondition + Lock</code>，以下是其swift的底层实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">open class NSConditionLock : NSObject, NSLocking &#123;</span><br><span class="line">    internal var _cond = NSCondition()</span><br><span class="line">    internal var _value: Int</span><br><span class="line">    internal var _thread: _swift_CFThreadRef?</span><br><span class="line">    </span><br><span class="line">    public convenience override init() &#123;</span><br><span class="line">        self.init(condition: 0)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public init(condition: Int) &#123;</span><br><span class="line">        _value = condition</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open func lock() &#123;</span><br><span class="line">        let _ = lock(before: Date.distantFuture)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open func unlock() &#123;</span><br><span class="line">        _cond.lock()</span><br><span class="line">        _thread = nil</span><br><span class="line">        _cond.broadcast()</span><br><span class="line">        _cond.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    open var condition: Int &#123;</span><br><span class="line">        return _value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open func lock(whenCondition condition: Int) &#123;</span><br><span class="line">        let _ = lock(whenCondition: condition, before: Date.distantFuture)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open func `try`() -&gt; Bool &#123;</span><br><span class="line">        return lock(before: Date.distantPast)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    open func tryLock(whenCondition condition: Int) -&gt; Bool &#123;</span><br><span class="line">        return lock(whenCondition: condition, before: Date.distantPast)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open func unlock(withCondition condition: Int) &#123;</span><br><span class="line">        _cond.lock()</span><br><span class="line">        _thread = nil</span><br><span class="line">        _value = condition</span><br><span class="line">        _cond.broadcast()</span><br><span class="line">        _cond.unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open func lock(before limit: Date) -&gt; Bool &#123;</span><br><span class="line">        _cond.lock()</span><br><span class="line">        while _thread != nil &#123;</span><br><span class="line">            if !_cond.wait(until: limit) &#123;</span><br><span class="line">                _cond.unlock()</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         _thread = pthread_self()</span><br><span class="line">        _cond.unlock()</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    open func lock(whenCondition condition: Int, before limit: Date) -&gt; Bool &#123;</span><br><span class="line">        _cond.lock()</span><br><span class="line">        while _thread != nil || _value != condition &#123;</span><br><span class="line">            if !_cond.wait(until: limit) &#123;</span><br><span class="line">                _cond.unlock()</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _thread = pthread_self()</span><br><span class="line">        _cond.unlock()</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    open var name: String?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可以看出</p><ul><li><code>NSConditionLock</code> 是 <code>NSCondition</code> 的封装</li><li><code>NSConditionLock</code> 可以 <code>设值锁条件</code>，即 <code>NSCondition</code>值，而 <code>NSCondition</code>只是信号的通知</li></ul><h2 id="调试验证"><a href="#调试验证" class="headerlink" title="调试验证"></a>调试验证</h2><p>以下面的代码为例，调试 <code>NSConditionLock</code> 底层流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)zj_testConditonLock&#123;</span><br><span class="line">    // 信号量</span><br><span class="line">    NSConditionLock * conditionLock = [[NSConditionLock alloc] initWithCondition:2];</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        [conditionLock lockWhenCondition:1]; // conditoion = 1 内部 Condition 匹配</span><br><span class="line">        NSLog(@&quot;线程 1&quot;);</span><br><span class="line">        [conditionLock unlockWithCondition:0];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123;</span><br><span class="line">        [conditionLock lockWhenCondition:2];</span><br><span class="line">        sleep(0.1);</span><br><span class="line">        NSLog(@&quot;线程 2&quot;);</span><br><span class="line">        [conditionLock unlockWithCondition:1]; // _value = 2 -&gt; 1</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">       [conditionLock lock];</span><br><span class="line">       NSLog(@&quot;线程 3&quot;);</span><br><span class="line">       [conditionLock unlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查看打印结果</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/162385782-0d67fa4a-eac2-457a-988f-6dfeebfe6831.jpg"></p><p><strong>打印结果分析</strong></p><ul><li><p><code>线程1</code> 调用 <code>[conditionLock lockWhenCondition:1]</code>，此时因为不满足条件，所以会 <code>进入waiting状态</code>，当进入到waiting时，会释放当前的互斥锁</p></li><li><p>此时当前的 <code>线程3</code> 调用 <code>[conditionLock lock]</code>，本质上是调用 <code>[NSConditionLock lockBeforeDate:]</code>，这里 <code>不需要对比条件值</code>，所以 <code>线程3先打印</code></p></li><li><p>接下来 <code>线程2</code> 执行 <code>[conditionLock lockWhenCondition:2]</code>，因为 <code>满足条件值</code>，所以 <code>线程2会打印</code>，打印完成后调用 <code>[conditionLock unlockWithCondition:1]</code>，这个时候将value设置为 <code>1</code>，并发送boradcast，此时 线程1 接收到当前的信号，唤醒执行并打印</p></li><li><p>自此当前打因为：<code>线程3-&gt;线程2-&gt;线程1</code></p></li><li><p>[<code>conditionLock lockWhenCondition:]</code> 这里会根据传入的 <code>condition值</code> 和 <code>Value值</code>进行对比，如果 <code>不相等</code>，这里 <code>就会阻塞</code>，进入线程池，否则的话就继续代码执行 <code>[conditionLock unlockWithCondition:1]</code> ，这里会 <code>先更改当前的value值</code>，然后进行上市。然后 <code>进行广播</code>，唤醒当前的线程</p></li></ul><h1 id="性能总结"><a href="#性能总结" class="headerlink" title="性能总结"></a>性能总结</h1><ul><li><p><code>OSSpinLock自旋锁</code> 由于安全性问题，在iOS10之后已经被废弃，其底层的实现用 <code>os_unfair_lock</code> 替代</p><ul><li>使用 <code>OSSpinLock</code> 及所示，会处于 <code>忙等待状态</code></li><li>而 <code>os_unfair_lock</code> 是处于 <code>休眠状态</code></li></ul></li><li><p><code>atomic原子锁</code> 自带一把自旋锁，只能保证 <code>setter、getter</code> 时的线程安全，在日常开发中使用更多的还是 <code>nonatomic</code> 修饰属性</p><ul><li><p><code>atomic</code>：当属性在调用 <code>setter、getter</code> 方法时，会加上 <code>自旋锁OSSpinLock</code>，用于保证同一时刻只能有一个线程调用属性的读或写，<code>避免了属性读写不同步的问题</code>，由于是底层编译器自动生成的互斥锁代码，会导致效率相对较低</p></li><li><p><code>nonatomic</code>：当属性在调用 <code>setter、getter</code> 方法时，不会加上自旋锁，即 <code>线程不安全</code>，由于编译器不会自动生成互斥锁代码，可以 <code>提高效率</code></p></li></ul></li><li><p><code>@synchronized</code> 在底层维护了一个 <code>哈希表</code> 进行线程data的存储，通过 <code>链表</code> 表示 <code>可重入</code>（即嵌套）的特性，虽然性能较低，但由于简单好用，使用频率高</p></li><li><p><code>NSLock、NSRecursiveLock</code> 底层是对 <code>pthread_mutex</code> 的封装</p></li><li><p><code>NSCondition</code> 和 <code>NSConditionLock</code> 是条件锁，底层都是对 <code>pthread_mutex</code> 的封装，当满足某一条件时才能进行操作，和信号量 <code>dispatch_semphore</code> 类似</p></li></ul><h1 id="锁的使用场景"><a href="#锁的使用场景" class="headerlink" title="锁的使用场景"></a>锁的使用场景</h1><ul><li><p>如果只是 <code>简单</code> 的使用，例如涉及线程安全，使用 <code>NSLock</code> 即可。</p></li><li><p>如果是 <code>循环嵌套</code>，推荐使用 <code>@synchronized</code> ，主要是因为使用 <code>递归锁</code> 的性能不能使用 <code>@synchronized</code> 的性能（因为在 <code>@synchronized</code> 中无论怎么重入，都没有关系，而 NSRecursiveLock可能会出现崩溃现象）</p></li><li><p>在 <code>循环嵌套</code> 中，如果递归锁掌握的很好，则建议使用 <code>递归锁</code>，因为性能好</p></li><li><p>如果是 <code>循环嵌套</code>，并且还有 <code>多线程影响</code>，例如有等待、死锁现象时，<code>建议</code> 使用 <code>@synchronized</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理28：GCD之底层原理分析</title>
      <link href="/BboyZJ.github.io/2021/04/05/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8628%EF%BC%9AGCD%E4%B9%8B%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/BboyZJ.github.io/2021/04/05/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8628%EF%BC%9AGCD%E4%B9%8B%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理27：GCD之 NSThread &amp; GCD &amp; NSOperation</title>
      <link href="/BboyZJ.github.io/2021/03/23/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8627%EF%BC%9AGCD%E4%B9%8B%20NSThread%20&amp;%20GCD%20&amp;%20NSOperation/"/>
      <url>/BboyZJ.github.io/2021/03/23/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8627%EF%BC%9AGCD%E4%B9%8B%20NSThread%20&amp;%20GCD%20&amp;%20NSOperation/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要目的是介绍 NSThread、GCD、NSOperation 常见的使用方式</p><h1 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h1><p><code>NSThread</code> 是苹果官方提供 <code>面向对象</code> 的线程操作技术，是对 <code>thread</code> 的上层封装，比较偏向于底层，简单方便，可以直接操作线程对象，使用频率较少</p><p><strong>创建线程</strong></p><p>线程的创建方式主要有以下三种方式</p><ul><li><p>通过 <code>init</code> 初始化方式创建，需要手动启动</p></li><li><p>通过 <code>detachNewThreadSelector</code> 构造器方式创建</p></li><li><p>通过 <code>performSelector...</code> 方式创建，主要是用于获取 <code>主线程</code>，以及 <code>后台线程</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)createNSThread&#123;</span><br><span class="line">    </span><br><span class="line">    // 方式一：初始化方式，需要手动启动</span><br><span class="line">    NSString * threadName1 = @&quot;NSThread1&quot;;</span><br><span class="line">    NSThread * thread1 = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:threadName1];</span><br><span class="line">    [thread1 start];</span><br><span class="line">    </span><br><span class="line">    // 方式二：构造器方式，自动启动</span><br><span class="line">    NSString * threadName2 = @&quot;NSThread2&quot;;</span><br><span class="line">    [NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:threadName2];</span><br><span class="line">    </span><br><span class="line">    // 方式三：performSelector...方法创建</span><br><span class="line">    NSString * threadName3 = @&quot;NSThread3&quot;;</span><br><span class="line">    [self performSelectorInBackground:@selector(doSomething:) withObject:threadName3];</span><br><span class="line">    </span><br><span class="line">    // 方式四：在主线程执行</span><br><span class="line">    NSString * threadName4 = @&quot;NSThread4&quot;;</span><br><span class="line">    [self performSelectorOnMainThread:@selector(doSomething:) withObject:threadName4 waitUntilDone:YES];</span><br><span class="line">&#125;</span><br><span class="line">- (void)doSomething:(NSObject *)objc&#123;</span><br><span class="line">    NSLog(@&quot;%@ - %@&quot;, objc, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>属性</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- thread.executing        // 线程是否在执行</span><br><span class="line">- thread.isCancelled      // 线程是否取消</span><br><span class="line">- thread.isFinished       // 线程是否完成</span><br><span class="line">- thread.isMainThread     // 是否是主线程</span><br><span class="line">- thread.threadPriority   // 线程的优先级，取值返回0.0~1.0默认优先级是0.5，1.0便是最高优先级，优先级越高，CPU调度的评率高</span><br></pre></td></tr></table></figure><p><strong>类方法</strong></p><p>常用的类方法有以下几个：</p><ul><li><p>currentThread：获取当前线程</p></li><li><p>sleep…：阻塞线程</p></li><li><p>exit：退出线程</p></li><li><p>mainThread：获取主线程</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)threadClassMethod&#123;</span><br><span class="line">    // 当前线程</span><br><span class="line">    [NSThread currentThread];</span><br><span class="line">    // 如果number = 1，则表示在主线程，否则在子线程</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    // 阻塞休眠</span><br><span class="line">    [NSThread sleepForTimeInterval:2]; // 休眠2s</span><br><span class="line">    [NSThread sleepUntilDate:[NSDate date]]; // 休眠到指定时间</span><br><span class="line">    </span><br><span class="line">    // 其他</span><br><span class="line">    [NSThread exit]; // 退出线程</span><br><span class="line">    [NSThread isMainThread]; // 判断当前线程是否为主线程</span><br><span class="line">    [NSThread isMultiThreaded]; // 判断当前线程是否为多线程</span><br><span class="line">    NSThread * mainThread = [NSThread mainThread]; // 主线程对象</span><br><span class="line">    NSLog(@&quot;%@&quot;,mainThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h1><ol><li>根据若⼲个url异步加载多张图⽚，然后在都下载完成后合成⼀张整图？GCD如何实现？</li></ol><p>dispatch_group_t + dispatch_group_enter + dispatch_group_leave + dispatch_group_notify</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-(void)Btn&#123;</span><br><span class="line">    NSString *str = @&quot;http://www.jianshu.com/p/6930f335adba&quot;;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:str];</span><br><span class="line">    NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">    NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">    // 创建线程组</span><br><span class="line">    dispatch_group_t downloadGroup = dispatch_group_create();</span><br><span class="line">    for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">        // enter</span><br><span class="line">        dispatch_group_enter(downloadGroup);</span><br><span class="line">        // 下载图片</span><br><span class="line">        NSURLSessionDataTask * task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">            </span><br><span class="line">            NSLog(@&quot;%d---%d&quot;,i,i);</span><br><span class="line">            // 离开</span><br><span class="line">            dispatch_group_leave(downloadGroup);</span><br><span class="line">        &#125;];</span><br><span class="line">        [task resume];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>dispatch_group_enter：通知group，下面的任务马上要放到group中执行了。<br>dispatch_group_leave：通知group，任务完成了，该任务要从group中移除了。<br>dispatch_group_notify：通知线程组中的任务都完成了</p><ol start="2"><li>10个网络请求顺序回调?</li></ol><p>dispatch_semaphore_t：信号量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-(void)Btn&#123;</span><br><span class="line">    NSString *str = @&quot;http://www.jianshu.com/p/6930f335adba&quot;;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:str];</span><br><span class="line">    NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">    NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_t sem = dispatch_semaphore_create(0);</span><br><span class="line">    for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">            </span><br><span class="line">            NSLog(@&quot;%d---%d&quot;,i,i);</span><br><span class="line">            dispatch_semaphore_signal(sem);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [task resume];</span><br><span class="line">        // 让循环等待</span><br><span class="line">        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;end&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h1><p><strong>dispatch_after</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)testAfter&#123;</span><br><span class="line">    /*</span><br><span class="line">     dispatch_after表示在某队列中的blcok延迟执行</span><br><span class="line">     应用场景：在主队列上延迟执行一向任务，如viewDidload之后延迟1s，提示一个alertview（是延迟加入到队列，而不是延迟执行）</span><br><span class="line">     */</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;1s后输出&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dispath_once</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)testOnce&#123;</span><br><span class="line">    /*</span><br><span class="line">     dispatch_once保证APP在运行期间，block中的代码只执行有一次</span><br><span class="line">     应用场景：单例、method_swizzling</span><br><span class="line">     */</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        // 创建单例、method swizzled或其他服务</span><br><span class="line">        NSLog(@&quot;创建单例&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dispach_apply</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)testApply&#123;</span><br><span class="line">    /*</span><br><span class="line">        dispatch_apply将指定的block追加到指定的队列中重复执行，并等到全部的处理执行结束 - 相当于线程安全的for循环</span><br><span class="line">        应用场景：用来拉取网络数据后提前算出各个控件的大小，防止绘制时计算，提高表单滑动流畅性</span><br><span class="line">        - 添加到串行队列中 —— 按序执行</span><br><span class="line">        - 添加到主队列中 —— 死锁</span><br><span class="line">        - 添加到并发队列中 —— 乱序执行</span><br><span class="line">        - 添加都全局队列中 —— 乱序执行</span><br><span class="line">     */</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;ZJ&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    NSLog(@&quot;dispatch_apply前&quot;);</span><br><span class="line">    /*</span><br><span class="line">     param1：重复的次数</span><br><span class="line">     param2：追加的队列</span><br><span class="line">     param3：执行任务</span><br><span class="line">     */</span><br><span class="line">    dispatch_apply(10, queue, ^(size_t index) &#123;</span><br><span class="line">        NSLog(@&quot;dispatch_apply 的线程 %zu - %@&quot;, index, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">        </span><br><span class="line">    NSLog(@&quot;dispatch_apply后&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dispatch_group_t</strong></p><p>有以下两种使用方式</p><ul><li>方式一：使用 <code>dispatch_group_t + dispatch_group_notify</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)testGroup1&#123;</span><br><span class="line">    /*</span><br><span class="line">        dispatch_group_t：调度组将任务分组执行，能监听任务组完成，并设置等待时间</span><br><span class="line">        应用场景：多个接口请求之后刷新页面</span><br><span class="line">     */</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(0, 0);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;请求一完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;请求二完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;刷新页面&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ****打印结果****</span><br><span class="line">2022-02-22 14:54:43.783327+0800 NSThread_Demo[4902:3701318] 请求一完成</span><br><span class="line">2022-02-22 14:54:43.783404+0800 NSThread_Demo[4902:3701318] 请求二完成</span><br><span class="line">2022-02-22 14:54:43.783432+0800 NSThread_Demo[4902:3701318] 刷新页面</span><br></pre></td></tr></table></figure><ul><li>【方式二】使用 <code>dispatch_group_enter + dispatch_group_leave + dispatch_group_notify</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)testGroup2&#123;</span><br><span class="line">    /*</span><br><span class="line">        dispatch_group_enter 和 dispatch_group_leave 成对出现，使进出组的逻辑更加清晰</span><br><span class="line">     */</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(0, 0);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;请求一完成&quot;);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;请求二完成&quot;);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;刷新页面&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ****打印结果****</span><br><span class="line">2022-02-22 15:13:39.981715+0800 NSThread_Demo[4906:3707145] 请求一完成</span><br><span class="line">2022-02-22 15:13:39.981788+0800 NSThread_Demo[4906:3707145] 请求二完成</span><br><span class="line">2022-02-22 15:13:39.987105+0800 NSThread_Demo[4906:3707122] 刷新页面</span><br></pre></td></tr></table></figure><ul><li>在方式二的基础上增加超时 dispatch_group_wait</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (void)testGroup3&#123;</span><br><span class="line">    /*</span><br><span class="line">        long dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)</span><br><span class="line">        </span><br><span class="line">        group：需要等待的调度组</span><br><span class="line">        timeout：等待的超时时间（即等多久）</span><br><span class="line">            - 设置为 DISPATCH_TIME_NOW意味着不等待直接判定调度组是否执行完毕</span><br><span class="line">            - 设置为 DISPATCH_TIME_FOREVER则会阻塞当前调度组，直到调度组执行完毕</span><br><span class="line">     </span><br><span class="line">        返回值：为long 类型</span><br><span class="line">            - 返回值为0 —— 在指定时间内调度组完成了任务</span><br><span class="line">            - 返回值不为0 —— 在指定时间内调度组没有按时完成任务</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;请求一完成&quot;);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;请求二完成&quot;);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">//    long timeout = dispatch_group_wait(group, DISPATCH_TIME_NOW); // 立即</span><br><span class="line">//    long timeout = dispatch_group_wait(group, DISPATCH_TIME_FOREVER); // 没限制</span><br><span class="line">    long timeout = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, 1 *NSEC_PER_SEC)); // 1s后</span><br><span class="line">    NSLog(@&quot;timeout = %ld&quot;,timeout);</span><br><span class="line">    if (timeout == 0) &#123;</span><br><span class="line">        NSLog(@&quot;按时完成任务&quot;);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        NSLog(@&quot;超时&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;刷新页面&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ****打印结果****</span><br><span class="line">2022-02-22 15:25:03.528855+0800 NSThread_Demo[4915:3711930] 请求一完成</span><br><span class="line">2022-02-22 15:25:03.528859+0800 NSThread_Demo[4915:3711929] 请求二完成</span><br><span class="line">2022-02-22 15:25:03.528923+0800 NSThread_Demo[4915:3711910] timeout = 0</span><br><span class="line">2022-02-22 15:25:03.528946+0800 NSThread_Demo[4915:3711910] 按时完成任务</span><br><span class="line">2022-02-22 15:25:03.534554+0800 NSThread_Demo[4915:3711910] 刷新页面</span><br></pre></td></tr></table></figure><p><strong>dispatch_barrier_sync &amp; dispatch_barrier_async</strong></p><p>栅栏函数，主要有两种使用场景：串行队列、并发队列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">- (void)testBarrier&#123;</span><br><span class="line">    /*</span><br><span class="line">        dispatch_barrier_sync &amp; dispatch_barrier_async</span><br><span class="line">     </span><br><span class="line">        应用场景：同步锁</span><br><span class="line">     </span><br><span class="line">        等栅栏前追加到队列中的任务执行完毕后，再讲栅栏后的任务追加到队列中</span><br><span class="line">        简而言之，就是先执行栅栏前任务，在执行栅栏任务，最后执行栅栏后任务</span><br><span class="line">     </span><br><span class="line">        - dispatch_barrier_async：前面的任务执行完毕才会来到这里</span><br><span class="line">        - dispatch_barrier_sync：作用相同，但是这个会堵塞线程，影响后面的任务执行</span><br><span class="line">     </span><br><span class="line">        - dispatch_barrier_async：可以控制队列中任务的执行顺序</span><br><span class="line">        - dispatch_barrier_sync：不仅阻塞了队列的执行，也阻塞了线程的执行（尽量少用）</span><br><span class="line">     */</span><br><span class="line">//    [self testBarrier1];</span><br><span class="line">    [self testBarrier2];</span><br><span class="line">&#125;</span><br><span class="line">- (void)testBarrier1&#123;</span><br><span class="line">    // 串行队列使用栅栏函数</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;ZJ&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;开始 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;延迟2s的任务1 - %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;第一次结束 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    // 栅栏函数的作用是讲队列中的任务进行分组，所以我们只要关注任务1、任务2</span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;----------栅栏任务----------%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;栅栏结束 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;延迟2s的任务2 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;第二次结束 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ****打印结果****</span><br><span class="line">2022-02-22 16:27:58.036179+0800 NSThread_Demo[4930:3731173] 开始 - &lt;_NSMainThread: 0x282bfc800&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-02-22 16:27:58.036253+0800 NSThread_Demo[4930:3731173] 第一次结束 - &lt;_NSMainThread: 0x282bfc800&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-02-22 16:27:58.036278+0800 NSThread_Demo[4930:3731173] 栅栏结束 - &lt;_NSMainThread: 0x282bfc800&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-02-22 16:27:58.036303+0800 NSThread_Demo[4930:3731173] 第二次结束 - &lt;_NSMainThread: 0x282bfc800&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-02-22 16:28:00.041655+0800 NSThread_Demo[4930:3731195] 延迟2s的任务1 - &lt;NSThread: 0x282bfaa80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-02-22 16:28:00.042098+0800 NSThread_Demo[4930:3731195] ----------栅栏任务----------&lt;NSThread: 0x282bfaa80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-02-22 16:28:02.047479+0800 NSThread_Demo[4930:3731195] 延迟2s的任务2 - &lt;NSThread: 0x282bfaa80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line"></span><br><span class="line">// testBarrier2</span><br><span class="line">- (void)testBarrier2&#123;</span><br><span class="line">    // 并发队列使用栅栏函数</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;ZJ&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;开始 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;延迟2s的任务1 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;第一次结束 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    // 由于并发队列异步任务时乱序执行完毕的，所以使用栅栏函数可以很好的控制队列内任务执行的顺序</span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;----------栅栏任务----------%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;栅栏结束 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">        NSLog(@&quot;延迟2s的任务2 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;第二次结束 - %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ****打印结果****</span><br><span class="line">2022-02-22 16:24:07.750567+0800 NSThread_Demo[4927:3729822] 开始 - &lt;_NSMainThread: 0x2809c8800&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-02-22 16:24:07.750635+0800 NSThread_Demo[4927:3729822] 第一次结束 - &lt;_NSMainThread: 0x2809c8800&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-02-22 16:24:07.750665+0800 NSThread_Demo[4927:3729822] 栅栏结束 - &lt;_NSMainThread: 0x2809c8800&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-02-22 16:24:07.750685+0800 NSThread_Demo[4927:3729822] 第二次结束 - &lt;_NSMainThread: 0x2809c8800&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-02-22 16:24:09.756044+0800 NSThread_Demo[4927:3729837] 延迟2s的任务1 - &lt;NSThread: 0x2809840c0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-02-22 16:24:09.756553+0800 NSThread_Demo[4927:3729837] ----------栅栏任务----------&lt;NSThread: 0x2809840c0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-02-22 16:24:11.761825+0800 NSThread_Demo[4927:3729837] 延迟2s的任务2 - &lt;NSThread: 0x2809840c0&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure><p><strong>dispatch_semaphore_t</strong></p><p>信号量主要作用于同步锁，用于控制 <code>GCD</code> 最大并发数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)testSemaphore&#123;</span><br><span class="line">    /*</span><br><span class="line">        应用场景：同步锁，控制GCD最大并发数</span><br><span class="line">        </span><br><span class="line">        - dispatch_semphore_create()：创建信号量</span><br><span class="line">        - dispatch_semphore_wait()：等待信号量，信号量减1，当信号量 &lt; 0 时会阻塞当前线程，根据传入的等待时间决定接下来的操作，如果永久等待将等到信号(signal)才能执行下去</span><br><span class="line">        - dispatch_semphore_signal()：释放信号量，信号量加1，当信号量 &gt;= 0 会执行wait之后的代码</span><br><span class="line">     */</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;ZJ&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    for (int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;当前 - %d，线程 - %@&quot;,i,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 利用信号量来改写</span><br><span class="line">    dispatch_semaphore_t sem = dispatch_semaphore_create(0);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;当前 - %d 线程 - %@&quot;,i,[NSThread currentThread]);</span><br><span class="line">            dispatch_semaphore_signal(sem);</span><br><span class="line">        &#125;);</span><br><span class="line">        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由上面的代码可知，在使用信号量之前的打印结果是无序的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2022-02-23 08:59:56.276005+0800 NSThread_Demo[5019:3790181] 当前 - 1，线程 - &lt;NSThread: 0x2825f0c00&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.276005+0800 NSThread_Demo[5019:3790180] 当前 - 0，线程 - &lt;NSThread: 0x2825f0080&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.276048+0800 NSThread_Demo[5019:3790182] 当前 - 3，线程 - &lt;NSThread: 0x2825e5180&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.276079+0800 NSThread_Demo[5019:3790181] 当前 - 4，线程 - &lt;NSThread: 0x2825f0c00&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.276081+0800 NSThread_Demo[5019:3790184] 当前 - 2，线程 - &lt;NSThread: 0x2825eca40&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.276110+0800 NSThread_Demo[5019:3790181] 当前 - 7，线程 - &lt;NSThread: 0x2825f0c00&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.276093+0800 NSThread_Demo[5019:3790182] 当前 - 6，线程 - &lt;NSThread: 0x2825e5180&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.276157+0800 NSThread_Demo[5019:3790182] 当前 - 9，线程 - &lt;NSThread: 0x2825e5180&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.276172+0800 NSThread_Demo[5019:3790185] 当前 - 5，线程 - &lt;NSThread: 0x2825f0440&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.276185+0800 NSThread_Demo[5019:3790181] 当前 - 8，线程 - &lt;NSThread: 0x2825f0c00&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可知，在使用信号量之后，打印的结果是有序的，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2022-02-23 08:59:56.276197+0800 NSThread_Demo[5019:3790186] 当前 - 0 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.276416+0800 NSThread_Demo[5019:3790186] 当前 - 1 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.276572+0800 NSThread_Demo[5019:3790186] 当前 - 2 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.276706+0800 NSThread_Demo[5019:3790186] 当前 - 3 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.276828+0800 NSThread_Demo[5019:3790186] 当前 - 4 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.276934+0800 NSThread_Demo[5019:3790186] 当前 - 5 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.276997+0800 NSThread_Demo[5019:3790186] 当前 - 6 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.277125+0800 NSThread_Demo[5019:3790186] 当前 - 7 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.277179+0800 NSThread_Demo[5019:3790186] 当前 - 8 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2022-02-23 08:59:56.277298+0800 NSThread_Demo[5019:3790186] 当前 - 9 线程 - &lt;NSThread: 0x2825f3880&gt;&#123;number = 8, name = (null)&#125;</span><br></pre></td></tr></table></figure><p><strong>dispatch_source_t</strong></p><p><code>dispatch_source_t</code> 主要用于计时操作，其原因是因为它创建的timer不依赖于Runloop，且计时精准度比 <code>NSTimer</code> 高，<code>dispatch_source_t</code> 有一点必须要设值为属性，否则会被立即释放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (void)testSource&#123;</span><br><span class="line">    /*</span><br><span class="line">        dispatch_source</span><br><span class="line">     </span><br><span class="line">        应用场景：GCDTimer</span><br><span class="line">        在iOS开发中一般使用NSTimer来处理定时逻辑，但NSTimer是依赖Runloop的，而Runloop可以运行在不同的模式下</span><br><span class="line">        如果NSTimer添加在一种模式下，当Runloop运行在其他模式下的时候，定时器就挂机了</span><br><span class="line">     </span><br><span class="line">        dispatch_source是一种基本的数据类型，可以用来监听一些底层的系统事件</span><br><span class="line">            - Timer Dispatch Source：定时器事件源，用来生成周期性的通知或回调</span><br><span class="line">            - Signal Dispatch Source：监听信号事件源，当有UNIX信号发生时会通知</span><br><span class="line">            - Descriptor Dispatch Source：监听文件或socket事件源，当文件或socket数据发生变化时会通知</span><br><span class="line">            - Process Dispatch Source：监听进程事件源，与进程相关的事件通知</span><br><span class="line">            - Mach port Dispatch Source：监听Mach端口事件源</span><br><span class="line">            - Custom Dispatch Source：监听自定义事件源</span><br><span class="line">     </span><br><span class="line">        主要使用的API:</span><br><span class="line">            - dispatch_source_create：创建时间源</span><br><span class="line">            - dispatch_source_set_event_handler：设值数据源回调</span><br><span class="line">            - dispatch_source_merge_data：设值事件源数据</span><br><span class="line">            - dispatch_source_get_data：获取事件源数据</span><br><span class="line">            - dispatch_resume：继续</span><br><span class="line">            - dispatch_suspend：挂起</span><br><span class="line">            - dispatch_cancle：取消</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">    // 创建队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;ZJ&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    // 创建timer</span><br><span class="line">    self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">    // 设置timer首次执行事件，间隔，精确度</span><br><span class="line">    dispatch_source_set_timer(self.timer, dispatch_time(DISPATCH_TIME_NOW, 2.0 * NSEC_PER_SEC), 1.0 * NSEC_PER_SEC, 0);</span><br><span class="line">    // 设置timer回调事件</span><br><span class="line">    dispatch_source_set_event_handler(self.timer, ^&#123;</span><br><span class="line">        NSLog(@&quot;GCDTimer&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    // 默认是挂起状态，需要手动激活</span><br><span class="line">    dispatch_resume(self.timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印结果</span><br><span class="line">2022-02-23 10:01:59.795986+0800 NSThread_Demo[5145:3819354] GCDTimer</span><br><span class="line">2022-02-23 10:02:00.795906+0800 NSThread_Demo[5145:3819354] GCDTimer</span><br><span class="line">2022-02-23 10:02:01.795952+0800 NSThread_Demo[5145:3819354] GCDTimer</span><br><span class="line">2022-02-23 10:02:02.795970+0800 NSThread_Demo[5145:3819354] GCDTimer</span><br><span class="line">2022-02-23 10:02:03.796053+0800 NSThread_Demo[5145:3819354] GCDTimer</span><br><span class="line">2022-02-23 10:02:04.796022+0800 NSThread_Demo[5145:3819354] GCDTimer</span><br><span class="line">2022-02-23 10:02:05.796038+0800 NSThread_Demo[5145:3819354] GCDTimer</span><br><span class="line">2022-02-23 10:02:06.796074+0800 NSThread_Demo[5145:3819354] GCDTimer</span><br><span class="line">2022-02-23 10:02:07.796115+0800 NSThread_Demo[5145:3819354] GCDTimer</span><br><span class="line">2022-02-23 10:02:08.796159+0800 NSThread_Demo[5145:3819355] GCDTimer</span><br><span class="line">2022-02-23 10:02:09.796130+0800 NSThread_Demo[5145:3819355] GCDTimer</span><br><span class="line">2022-02-23 10:02:10.796167+0800 NSThread_Demo[5145:3819355] GCDTimer</span><br><span class="line">2022-02-23 10:02:11.796161+0800 NSThread_Demo[5145:3819355] GCDTimer</span><br><span class="line">2022-02-23 10:02:12.796162+0800 NSThread_Demo[5145:3819355] GCDTimer</span><br><span class="line">2022-02-23 10:02:13.796169+0800 NSThread_Demo[5145:3819355] GCDTimer</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h1><p><code>NSOperation</code> 是基于 <code>GCD</code> 之上的更高一层的封装， <code>NSOpetation</code> 需要配合 <code>NSOpetationQueue</code> 来实现多线程</p><p><code>NSOpetation</code> 实现多线程的步骤如下：</p><ul><li>创建任务：先将需要执行的操作封装到 <code>NSOperation</code> 对象中。</li><li>创建队列：创建 <code>NSOperationQueue</code>。</li><li>将任务加入到队列中：将 <code>NSOperation</code> 对象添加到 <code>NSOperationQueue</code> 中。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)testBaseNSOperation&#123;</span><br><span class="line">    // 处理事务</span><br><span class="line">    NSInvocationOperation * op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(handleInvocation:) object:@&quot;ZJ&quot;];</span><br><span class="line">    // 创建队列</span><br><span class="line">    NSOperationQueue * queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    // 操作加入队列</span><br><span class="line">    [queue addOperation:op];</span><br><span class="line">&#125;</span><br><span class="line">- (void)handleInvocation:(id)operation&#123;</span><br><span class="line">    NSLog(@&quot;%@ - %@&quot;,operation,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>NSOperation</code> 是个抽象类，实际运用时中需要使用它的子类，有三种方式：</p><ul><li>使用子类 <code>NSInvocationOperation</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)createNSOperation&#123;</span><br><span class="line">    // 创建 NSInvocationOperation 对象并关联方法，之后start</span><br><span class="line">    NSInvocationOperation * invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(doSomething:) object:@&quot;ZJ&quot;];</span><br><span class="line">    [invocationOperation start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用子类 <code>NSBlockOperation</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)testBlockOperationExecution&#123;</span><br><span class="line">    // 通过 addExecutionBlock 这个方法可以让 NSBlockOperation 实现多线程</span><br><span class="line">    // NSBlockOperation 创建时 block 中的任务是主线程执行，而运用 addExecutionBlock 加入的任务是在子线程执行的</span><br><span class="line">    NSBlockOperation * blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;main task = &gt;currentThread: %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;task1 = &gt;currentThread: %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;task2 = &gt;currentThread: %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;task3 = &gt;currentThread: %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [blockOperation start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印结果</span><br><span class="line">2022-02-23 13:48:54.022671+0800 NSThread_Demo[5246:3887949] main task = &gt;currentThread: &lt;_NSMainThread: 0x281598800&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-02-23 13:48:54.022688+0800 NSThread_Demo[5246:3887974] task1 = &gt;currentThread: &lt;NSThread: 0x2815c8180&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-02-23 13:48:54.022786+0800 NSThread_Demo[5246:3887971] task2 = &gt;currentThread: &lt;NSThread: 0x2815da480&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-02-23 13:48:54.022786+0800 NSThread_Demo[5246:3887976] task3 = &gt;currentThread: &lt;NSThread: 0x2815dc0c0&gt;&#123;number = 6, name = (null)&#125;</span><br></pre></td></tr></table></figure><ul><li>定义继承自 <code>NSOperation</code> 的子类，通过实现内部相应的方法来封装任务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 自定义继承自NSOperation的子类</span><br><span class="line">@interface ZJOperation : NSOperation</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ZJOperation</span><br><span class="line">- (void)main&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;NSOperation的子类：%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">- (void)testZJOperation&#123;</span><br><span class="line">    // 运用集成自NSOperation的子类，首先我们定义一个集成自NSOperation的类，然后重写它的main方法</span><br><span class="line">    ZJOperation * operation = [[ZJOperation alloc] init];</span><br><span class="line">    [operation start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印结果</span><br><span class="line">2022-02-25 15:16:22.694568+0800 NSThread_Demo[5696:4241286] NSOperation的子类：&lt;_NSMainThread: 0x282180800&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-02-25 15:16:22.694645+0800 NSThread_Demo[5696:4241286] NSOperation的子类：&lt;_NSMainThread: 0x282180800&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-02-25 15:16:22.694670+0800 NSThread_Demo[5696:4241286] NSOperation的子类：&lt;_NSMainThread: 0x282180800&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure><h1 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h1><p><strong>NSOperationQueue添加事务</strong></p><p><code>NSOperationQueue</code> 有两种队列：主队列、其他队列。其他队列包含了 串行和并发。</p><ul><li><p>主队列：<code>主队列</code> 上的任务时在 <code>主线程</code> 执行的</p></li><li><p>其他队列（非主队列）：加入到 <code>非队列</code> 中的任务 <code>默认就是并发</code>，开启多线程</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (void)testNSOperationQueue&#123;</span><br><span class="line">    /*</span><br><span class="line">        NSInvocationOperation 和 NSBlockOperation 两者之间的区别在于：</span><br><span class="line">        - 前者类似target形式</span><br><span class="line">        - 后者类似block形式——函数式编程，业务逻辑代码可读性更高</span><br><span class="line">     </span><br><span class="line">        NSOperationQueue 是异步执行的，所以 任务一、任务二的完成顺序不确定</span><br><span class="line">     */</span><br><span class="line">    // 初始化事务</span><br><span class="line">    NSBlockOperation * bo = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;任务1——%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    // 添加事务</span><br><span class="line">    [bo addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;任务2——%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    // 回调监听</span><br><span class="line">    bo.completionBlock = ^&#123;</span><br><span class="line">        NSLog(@&quot;完成了!!!&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    NSOperationQueue * queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    [queue addOperation:bo];</span><br><span class="line">    NSLog(@&quot;事务添加加进了NSOperationQueue&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印结果</span><br><span class="line">2022-02-25 15:28:17.704473+0800 NSThread_Demo[5720:4246238] 事务添加加进了NSOperationQueue</span><br><span class="line">2022-02-25 15:28:17.704513+0800 NSThread_Demo[5720:4246260] 任务1——&lt;NSThread: 0x282f6c340&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-02-25 15:28:17.704552+0800 NSThread_Demo[5720:4246260] 任务2——&lt;NSThread: 0x282f6c340&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-02-25 15:28:17.704602+0800 NSThread_Demo[5720:4246260] 完成了!!!</span><br></pre></td></tr></table></figure><p><strong>设值执行顺序</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)testQueueSequence&#123;</span><br><span class="line">    NSOperationQueue * queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">        [queue addOperationWithBlock:^&#123;</span><br><span class="line">            NSLog(@&quot;%@ --- %d&quot;,[NSThread currentThread],i);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印结果</span><br><span class="line">2022-03-08 09:11:03.759862+0800 NSThread_Demo[4217:3030339] &lt;NSThread: 0x281b90240&gt;&#123;number = 3, name = (null)&#125; --- 1</span><br><span class="line">2022-03-08 09:11:03.760398+0800 NSThread_Demo[4217:3030384] &lt;NSThread: 0x281be7a80&gt;&#123;number = 7, name = (null)&#125; --- 3</span><br><span class="line">2022-03-08 09:11:03.760526+0800 NSThread_Demo[4217:3030340] &lt;NSThread: 0x281b830c0&gt;&#123;number = 6, name = (null)&#125; --- 2</span><br><span class="line">2022-03-08 09:11:03.760655+0800 NSThread_Demo[4217:3030339] &lt;NSThread: 0x281b90240&gt;&#123;number = 3, name = (null)&#125; --- 4</span><br><span class="line">2022-03-08 09:11:03.760697+0800 NSThread_Demo[4217:3030343] &lt;NSThread: 0x281b84280&gt;&#123;number = 5, name = (null)&#125; --- 0</span><br></pre></td></tr></table></figure><h1 id="设置优先级"><a href="#设置优先级" class="headerlink" title="设置优先级"></a>设置优先级</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">- (void)testOperationQuality&#123;</span><br><span class="line">    /*</span><br><span class="line">        NSOperation设值优先级只会让CPU有更高的几率调用，不是说设值高就一定全部先完成</span><br><span class="line">        - 不适用sleep —— 高优先级的任务先于低优先级的任务</span><br><span class="line">        - 使用sleep进行延时 —— 高优先级的任务慢于低优先级的任务</span><br><span class="line">     */</span><br><span class="line">    NSBlockOperation * bo1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">            // sleep(1);</span><br><span class="line">            NSLog(@&quot;第一个操作 %d --- %@&quot;,i,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    // 设置最高优先级</span><br><span class="line">    bo1.qualityOfService = NSQualityOfServiceUserInteractive;</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation * bo2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">            NSLog(@&quot;第二个操作 %d --- %@&quot;,i,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    // 设置最低优先级</span><br><span class="line">    bo2.qualityOfService = NSQualityOfServiceBackground;</span><br><span class="line">    </span><br><span class="line">    NSOperationQueue * queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    [queue addOperation:bo1];</span><br><span class="line">    [queue addOperation:bo2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不使用sleep的打印结果</span><br><span class="line">2022-03-08 09:23:44.072325+0800 NSThread_Demo[4220:3035578] 第一个操作 0 --- &lt;NSThread: 0x2826ac100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-03-08 09:23:44.072420+0800 NSThread_Demo[4220:3035578] 第一个操作 1 --- &lt;NSThread: 0x2826ac100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-03-08 09:23:44.072448+0800 NSThread_Demo[4220:3035578] 第一个操作 2 --- &lt;NSThread: 0x2826ac100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-03-08 09:23:44.072516+0800 NSThread_Demo[4220:3035578] 第一个操作 3 --- &lt;NSThread: 0x2826ac100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-03-08 09:23:44.072447+0800 NSThread_Demo[4220:3035582] 第二个操作 0 --- &lt;NSThread: 0x2826a8300&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-03-08 09:23:44.072555+0800 NSThread_Demo[4220:3035578] 第一个操作 4 --- &lt;NSThread: 0x2826ac100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-03-08 09:23:44.073242+0800 NSThread_Demo[4220:3035582] 第二个操作 1 --- &lt;NSThread: 0x2826a8300&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-03-08 09:23:44.073345+0800 NSThread_Demo[4220:3035582] 第二个操作 2 --- &lt;NSThread: 0x2826a8300&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-03-08 09:23:44.073484+0800 NSThread_Demo[4220:3035582] 第二个操作 3 --- &lt;NSThread: 0x2826a8300&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-03-08 09:23:44.073546+0800 NSThread_Demo[4220:3035582] 第二个操作 4 --- &lt;NSThread: 0x2826a8300&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line"></span><br><span class="line">// 使用sleep的打印结果</span><br><span class="line">2022-03-08 09:25:01.471850+0800 NSThread_Demo[4223:3036749] 第二个操作 0 --- &lt;NSThread: 0x282c1de40&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-03-08 09:25:01.472242+0800 NSThread_Demo[4223:3036749] 第二个操作 1 --- &lt;NSThread: 0x282c1de40&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-03-08 09:25:01.472334+0800 NSThread_Demo[4223:3036749] 第二个操作 2 --- &lt;NSThread: 0x282c1de40&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-03-08 09:25:01.472867+0800 NSThread_Demo[4223:3036749] 第二个操作 3 --- &lt;NSThread: 0x282c1de40&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-03-08 09:25:01.473057+0800 NSThread_Demo[4223:3036749] 第二个操作 4 --- &lt;NSThread: 0x282c1de40&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-03-08 09:25:02.472831+0800 NSThread_Demo[4223:3036750] 第一个操作 0 --- &lt;NSThread: 0x282c4c080&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-03-08 09:25:03.474228+0800 NSThread_Demo[4223:3036750] 第一个操作 1 --- &lt;NSThread: 0x282c4c080&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-03-08 09:25:04.475736+0800 NSThread_Demo[4223:3036750] 第一个操作 2 --- &lt;NSThread: 0x282c4c080&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-03-08 09:25:05.477191+0800 NSThread_Demo[4223:3036750] 第一个操作 3 --- &lt;NSThread: 0x282c4c080&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-03-08 09:25:06.478576+0800 NSThread_Demo[4223:3036750] 第一个操作 4 --- &lt;NSThread: 0x282c4c080&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure><h1 id="设置并发数"><a href="#设置并发数" class="headerlink" title="设置并发数"></a>设置并发数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)testOperationMaxCount&#123;</span><br><span class="line">    /*</span><br><span class="line">        在GCD中只能使用信号量来设置并发数</span><br><span class="line">        而NSOperation轻易就能设置并发数</span><br><span class="line">        通过设置maxConcurrentOperationCount来控制单次队列去执行的任务数</span><br><span class="line">     */</span><br><span class="line">    NSOperationQueue * queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue.name = @&quot;Felix&quot;;</span><br><span class="line">    queue.maxConcurrentOperationCount = 2;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">        [queue addOperationWithBlock:^&#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;%d -- %@&quot;,i,[NSThread currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查看打印结果</span><br><span class="line">2022-03-08 11:12:55.459322+0800 NSThread_Demo[4293:3074227] 0 -- &lt;NSThread: 0x283260080&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-03-08 11:12:55.459326+0800 NSThread_Demo[4293:3074223] 1 -- &lt;NSThread: 0x283264140&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2022-03-08 11:12:57.463085+0800 NSThread_Demo[4293:3074223] 3 -- &lt;NSThread: 0x283264140&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2022-03-08 11:12:57.464903+0800 NSThread_Demo[4293:3074227] 2 -- &lt;NSThread: 0x283260080&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-03-08 11:12:59.468845+0800 NSThread_Demo[4293:3074225] 4 -- &lt;NSThread: 0x2832724c0&gt;&#123;number = 6, name = (null)&#125;</span><br></pre></td></tr></table></figure><h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)testOperationDependency&#123;</span><br><span class="line">    NSOperationQueue * queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    NSBlockOperation * bo1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:0.5];</span><br><span class="line">        NSLog(@&quot;请求token&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation * bo2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:0.5];</span><br><span class="line">        NSLog(@&quot;拿着token，请求数据1&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation * bo3 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:0.5];</span><br><span class="line">        NSLog(@&quot;拿着数据1，请求数据2&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [bo2 addDependency:bo1];</span><br><span class="line">    [bo3 addDependency:bo2];</span><br><span class="line">    </span><br><span class="line">    [queue addOperations:@[bo1,bo2,bo3] waitUntilFinished:YES];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;执行完成了？我要干其他事情了&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查看打印结果</span><br><span class="line">2022-03-08 11:17:14.425701+0800 NSThread_Demo[4295:3076256] 请求token</span><br><span class="line">2022-03-08 11:17:14.931254+0800 NSThread_Demo[4295:3076255] 拿着token，请求数据1</span><br><span class="line">2022-03-08 11:17:15.436695+0800 NSThread_Demo[4295:3076258] 拿着数据1，请求数据2</span><br><span class="line">2022-03-08 11:17:15.437079+0800 NSThread_Demo[4295:3076238] 执行完成了？我要干其他事情了</span><br></pre></td></tr></table></figure><h1 id="线程间通讯"><a href="#线程间通讯" class="headerlink" title="线程间通讯"></a>线程间通讯</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)testOperationNoti&#123;</span><br><span class="line">    NSOperationQueue * queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue.name = @&quot;Felix&quot;;</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;请求网络%@ -- %@&quot;,[NSOperationQueue currentQueue],[NSThread currentThread]);</span><br><span class="line">        </span><br><span class="line">        [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            NSLog(@&quot;刷新UI%@ -- %@&quot;,[NSOperationQueue currentQueue],[NSThread currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查看打印结果</span><br><span class="line">2022-03-08 11:20:27.970126+0800 NSThread_Demo[4297:3077823] 请求网络&lt;NSOperationQueue: 0x10bd087d0&gt;&#123;name = &#x27;Felix&#x27;&#125; -- &lt;NSThread: 0x28206b140&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-03-08 11:20:27.976293+0800 NSThread_Demo[4297:3077803] 刷新UI&lt;NSOperationQueue: 0x10d005570&gt;&#123;name = &#x27;NSOperationQueue Main Queue&#x27;&#125; -- &lt;_NSMainThread: 0x28206c880&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理26：GCD之函数与队列</title>
      <link href="/BboyZJ.github.io/2021/03/10/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8626%EF%BC%9AGCD%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/BboyZJ.github.io/2021/03/10/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8626%EF%BC%9AGCD%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="GCD简介"><a href="#GCD简介" class="headerlink" title="GCD简介"></a>GCD简介</h1><p>1、什么是GCD？</p><p>全称是 <code>Grand Central Dispatch</code>，纯 <code>C</code> 语言，提供了非常强大的函数</p><p>2、GCD 的优势</p><ul><li>GCD 是苹果公司为多核的并行运算提出的解决方案</li><li>GCD 会自动利用更多的 <code>CPU</code> 内核（比如双核、四核）</li><li>GCD 会自动管理线程的声明周期（创建线程、调度任务、销毁线程）</li><li>程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码</li></ul><p><strong>【重点】</strong>用一句话总结 GCD ： <code>将任务添加到队列，并且指定执行任务的函数。</code></p><h1 id="GCD-核心"><a href="#GCD-核心" class="headerlink" title="GCD 核心"></a>GCD 核心</h1><p>在日常开发中，GCD一般写成下面的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diaptch_async(dispatch_queue_create(&quot;com.zj.Queue&quot;,NULL)), ^&#123;</span><br><span class="line">    NSLog(@&quot;GCD基本使用&quot;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>将上述代码拆分，方便我们来理解 <code>GCD</code> 的 <code>核心</code>，主要是由 <code>任务 + 队列 + 函数</code> 构成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//*****GCD基础写法*****</span><br><span class="line">// 创建任务</span><br><span class="line">dispatch_block_t block= ^&#123;</span><br><span class="line">    NSLog(@&quot;hello GCD&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 创建队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.zj.Queue&quot;,NULL);</span><br><span class="line">// 将任务添加到队列，并指定函数执行</span><br><span class="line">dispatch_async(queue,block);</span><br></pre></td></tr></table></figure><ul><li>dispatch_block_t：创建任务</li><li>dispatch_queue_t：创建队列</li><li>dispatch_async：函数</li></ul><h1 id="函数和队列"><a href="#函数和队列" class="headerlink" title="函数和队列"></a>函数和队列</h1><p>1、在GCD中函数按照执行方式分为 <code>同步函数</code> 和 <code>异步函数</code></p><ul><li><p>同步函数：<code>dispatch_sync</code></p><ul><li>必须等待当前语句执行完毕，才会执行下一条语句</li><li>不会开启线程，即不具备开启新线程的能力</li><li>在当前执行 <code>block</code> 任务</li></ul></li><li><p>异步函数：<code>dispatch_async</code></p><ul><li>会开启新的线程执行 <code>block</code> 任务</li><li>异步是多线程的代名词</li></ul></li></ul><p>综上所述，两种执行方式的 <code>主要区别</code> 有两点：</p><ul><li><code>是否等待</code> 队列的任务执行完毕</li><li><code>是否具备开启新线程</code> 的能力</li></ul><p>2、队列</p><p>在GCD中队列是用来 <code>存放任务</code>，是一种特殊的 <code>线性表</code>，遵循 <code>FIFO（先进先出）</code> 原则，新任务总是被 <code>插入到队尾</code>，而任务的读取是从 <code>队首开始读取</code>，每读一个任务，则队列中释放一个任务，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/149465279-a50d057c-c1c8-43a2-ba81-1d90363a8d30.jpg"></p><p>队列主要分为 <code>串行队列（Serial Dispatch Queue）</code> 和 <code>并发队列(Concurrent Dispatch Queue)</code> 两种，如下图所示</p><p><img src="https://user-images.githubusercontent.com/25925248/149465296-06fbc7d7-d367-47c5-80d9-99a24ff0edcb.jpg"></p><ul><li><p>串行队列：每次 <code>只有一个任务被执行</code>，等待上一个任务执行完毕再执行下一个，即只开启一个线程（通俗理解：同一时刻只调度一个任务执行）</p><ul><li>使用 <code>dispatch_queue_create(&quot;xxx&quot;,DISPATCH_QUEUE_SERIAL)</code> 创建串行队列</li><li>其中 <code>DISPATCH_QUEUE_SERIAL</code> 也可以用 <code>NULL</code> 表示，这两种均表示 默认的串行队列</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 串行队列的获取方法</span><br><span class="line">dispatch_queue_t serialQueue1 = dispatch_queue_create(&quot;com.ZJ.Queue&quot;,DISPATCH_QUQUQ_SERIAL);</span><br><span class="line"></span><br><span class="line">dispatch_quque_t serialQuquq2 = dispatch_ququq_create(&quot;com.ZJ.Queue&quot;,Null);</span><br></pre></td></tr></table></figure><ul><li><p>并发队列：一次可以 <code>并发执行多个任务</code>，即 <code>开启多个线程</code>，并同时执行任务（通俗理解：同意时刻可以调度多个任务执行）</p><ul><li>使用 <code>dispach_queue_create(&quot;xxx&quot;,DISPATCH_QUQUQ_CONCURRENT)</code> 创建并发队列</li><li>注意：<code>并发队列</code> 的并发功能 <code>只有在异步函数下才有效</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 并发队列的获取方法</span><br><span class="line">dispatch_quque_t concurrentQueue = dispatch_quque_create(&quot;com.ZJ.Queue&quot;,DISPATCH_QUQUE_CONCURRENT);  </span><br></pre></td></tr></table></figure><h1 id="主队列-和-全局并发队列"><a href="#主队列-和-全局并发队列" class="headerlink" title="主队列 和 全局并发队列"></a>主队列 和 全局并发队列</h1><p>在GCD中，针对这两种队列，分别提供了 <code>主队列（Main Dispatch Queue）</code> 和 <code>全局并发队列（Global Dispatch Queue）</code></p><ul><li><p><code>主队列（Main Dispatch Queue）</code>：GCD 中提供的 <code>特殊的串行队列</code></p><ul><li>专门用来 <code>在主线程上调度任务的串行队列</code>，依赖于主线程、主Runloop，在main函数调用之前 自动创建</li><li>不会开启线程</li><li>如果当前主线程正在有任务执行，那么无论主队列中当前被添加了什么任务，都不会被调用</li><li>使用 <code>dispatch_get_main_queue()</code> 获得 主队列</li><li>通常在返回 <code>主线程 更新UI</code> 时使用</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 主队列的获取方法</span><br><span class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure><ul><li><p><code>全局并发队列（Global Dispatch Queue）</code>：GCD 提供的默认的 <code>并发队列</code></p><ul><li>为了方便程序员使用，苹果提供了全局队列</li><li>在使用多线程开发时，如果对队列没有特殊要求，<code>在执行异步任务时，可以直接使用全局队列</code></li><li>使用 <code>dispatch_get_global_queue</code> 获取全局并发队列，最简单的是 <code>dispatch_get_global_queue(0,0)</code><ul><li>第一个参数表示 队列优先级，默认优先级未 <code>DISPATCH_QUEUE_PRIORITY_DEFAULT=0</code>，在iOS9之后，已经被 <code>服务质量（quality-of-service）</code> 取代</li><li>第二个参数使用 0</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 全集并发队列的获取方法</span><br><span class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(0,0);</span><br><span class="line"></span><br><span class="line">// 优先级从高到底（对应的服务质量）依次为</span><br><span class="line">- DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED</span><br><span class="line">- DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT</span><br><span class="line">- DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY</span><br><span class="line">- DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND</span><br></pre></td></tr></table></figure><h1 id="全局并发队列-主队列-配合使用"><a href="#全局并发队列-主队列-配合使用" class="headerlink" title="全局并发队列 + 主队列 配合使用"></a>全局并发队列 + 主队列 配合使用</h1><p>在日常开发中， <code>全局队列 + 并发队列</code> 一般是这样配合使用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 主队列 + 全局并发队列 的日常使用</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0,0), ^&#123;</span><br><span class="line">    // 执行耗时操作</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(),^&#123;</span><br><span class="line">        // 回到主线程进行UI操作</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="函数与队列的不同组合"><a href="#函数与队列的不同组合" class="headerlink" title="函数与队列的不同组合"></a>函数与队列的不同组合</h1><ol><li>串行队列 + 同步函数</li></ol><p>【任务 <code>按顺序执行</code>】：任务一个接一个的在当前线程执行，<code>不会开辟新线程</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 串行队列 + 同步函数</span><br><span class="line">- (void)test1&#123;</span><br><span class="line">    NSLog(@&quot;串行 + 同步：%@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">        dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">            NSLog(@&quot;串行 + 同步：%d - %@&quot;,i,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，查看打印结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2022-01-12 15:13:39.595134+0800 GCD之函数和队列[4500:155055] 串行 + 同步：&lt;_NSMainThread: 0x6000025d00c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 15:13:39.595275+0800 GCD之函数和队列[4500:155055] 串行 + 同步：0 - &lt;_NSMainThread: 0x6000025d00c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 15:13:39.595388+0800 GCD之函数和队列[4500:155055] 串行 + 同步：1 - &lt;_NSMainThread: 0x6000025d00c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 15:13:39.595512+0800 GCD之函数和队列[4500:155055] 串行 + 同步：2 - &lt;_NSMainThread: 0x6000025d00c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 15:13:39.595639+0800 GCD之函数和队列[4500:155055] 串行 + 同步：3 - &lt;_NSMainThread: 0x6000025d00c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 15:13:39.595759+0800 GCD之函数和队列[4500:155055] 串行 + 同步：4 - &lt;_NSMainThread: 0x6000025d00c0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>串行队列 + 异步函数</li></ol><p>【任务 <code>按顺序执行</code>】：任务一个接一个的执行，会 <code>开辟新线程</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 串行队列 + 异步函数</span><br><span class="line">- (void)test2&#123;</span><br><span class="line">    NSLog(@&quot;串行 + 异步：%@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, NULL);</span><br><span class="line">    for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">        dispatch_async(serialQueue, ^&#123;</span><br><span class="line">            NSLog(@&quot;串行 + 异步：%d - %@&quot;,i,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，查看打印结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2022-01-12 15:20:12.884840+0800 GCD之函数和队列[4590:160591] 串行 + 异步：&lt;_NSMainThread: 0x600000ee4140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 15:20:12.885010+0800 GCD之函数和队列[4590:160734] 串行 + 异步：0 - &lt;NSThread: 0x600000eb01c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2022-01-12 15:20:12.885136+0800 GCD之函数和队列[4590:160734] 串行 + 异步：1 - &lt;NSThread: 0x600000eb01c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2022-01-12 15:20:12.885262+0800 GCD之函数和队列[4590:160734] 串行 + 异步：2 - &lt;NSThread: 0x600000eb01c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2022-01-12 15:20:12.885392+0800 GCD之函数和队列[4590:160734] 串行 + 异步：3 - &lt;NSThread: 0x600000eb01c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2022-01-12 15:20:12.885538+0800 GCD之函数和队列[4590:160734] 串行 + 异步：4 - &lt;NSThread: 0x600000eb01c0&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>并发队列 + 同步函数</li></ol><p>【任务 <code>按顺序执行</code>】：任务一个接一个的执行，<code>不开辟新线程</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 并发队列 + 同步函数</span><br><span class="line">- (void)test3&#123;</span><br><span class="line">    NSLog(@&quot;并发 + 同步：%@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">        dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">            NSLog(@&quot;并发 + 同步：%d - %@&quot;,i,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，查看打印结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">22-01-12 15:23:15.939687+0800 GCD之函数和队列[4630:163688] 并发 + 同步：&lt;_NSMainThread: 0x600000de8000&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 15:23:15.939830+0800 GCD之函数和队列[4630:163688] 并发 + 同步：0 - &lt;_NSMainThread: 0x600000de8000&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 15:23:15.939922+0800 GCD之函数和队列[4630:163688] 并发 + 同步：1 - &lt;_NSMainThread: 0x600000de8000&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 15:23:15.940014+0800 GCD之函数和队列[4630:163688] 并发 + 同步：2 - &lt;_NSMainThread: 0x600000de8000&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 15:23:15.940102+0800 GCD之函数和队列[4630:163688] 并发 + 同步：3 - &lt;_NSMainThread: 0x600000de8000&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 15:23:15.940217+0800 GCD之函数和队列[4630:163688] 并发 + 同步：4 - &lt;_NSMainThread: 0x600000de8000&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>并发队列 + 异步函数</li></ol><p>【任务 <code>乱序执行</code>】：任务执行无顺序，会 <code>开辟新线程</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 并发队列 + 异步函数</span><br><span class="line">- (void)test4&#123;</span><br><span class="line">    NSLog(@&quot;并发 + 异步：%@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">        dispatch_async(serialQueue, ^&#123;</span><br><span class="line">            NSLog(@&quot;并发 + 异步：%d - %@&quot;,i,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，查看打印结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2022-01-12 15:26:35.249949+0800 GCD之函数和队列[4716:166604] 并发 + 异步：&lt;_NSMainThread: 0x600003344740&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 15:26:35.250144+0800 GCD之函数和队列[4716:166729] 并发 + 异步：0 - &lt;NSThread: 0x60000332c100&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2022-01-12 15:26:35.250153+0800 GCD之函数和队列[4716:166735] 并发 + 异步：1 - &lt;NSThread: 0x600003300d40&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2022-01-12 15:26:35.250174+0800 GCD之函数和队列[4716:166734] 并发 + 异步：3 - &lt;NSThread: 0x60000330f0c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-01-12 15:26:35.250238+0800 GCD之函数和队列[4716:166731] 并发 + 异步：4 - &lt;NSThread: 0x600003328040&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2022-01-12 15:26:35.250277+0800 GCD之函数和队列[4716:166733] 并发 + 异步：2 - &lt;NSThread: 0x600003305c40&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>主队列 + 同步函数</li></ol><p>【造成 <code>死锁</code>】：任务 <code>相互等待</code>，造成 <code>死锁</code></p><p><img src="https://user-images.githubusercontent.com/25925248/149465408-b09b2528-90b4-43d9-87f3-87e136a46d03.jpg"></p><p>造成死锁的原因分析如下：</p><ul><li>主队列有两个任务，顺序为： <code>NSLog任务 - 同步block</code></li><li>执行NSLog任务后，执行同步的block，会将 <code>任务1（即 i=1）</code> 加入到主队列，主队列顺序为 ：<code>NSLog任务 - 同步block - 任务1</code></li><li><code>任务1</code> 的执行需要 <code>等待同步block执行完毕</code> 才会执行，而 <code>同步block</code> 的执行需要 <code>等待任务1执行完毕</code>，所以就造成了 <code>互相等待</code> 的情况，即造成 <code>死锁崩溃</code>。</li></ul><p>【死锁现象】</p><ul><li><code>主线程</code> 因为你 <code>同步函数</code> 的原因 <code>等着先执行任务</code></li><li><code>主队列等着主线程的任务</code> 执行完毕再执行自己的任务</li><li><code>主队列和主线程相互等待</code> 会造成死锁</li></ul><ol start="6"><li>主队列 + 异步函数</li></ol><p>【任务 <code>按顺序执行</code>】：任务一个接一个的执行，不开辟线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 主队列 + 异步函数</span><br><span class="line">- (void)test6&#123;</span><br><span class="line">    NSLog(@&quot;主队列 + 异步：%@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_queue_t mainQueue = dispatch_get_main_queue();</span><br><span class="line">    for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">        dispatch_async(mainQueue, ^&#123;</span><br><span class="line">            NSLog(@&quot;主队列 + 异步：%d - %@&quot;,i,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，查看打印结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2022-01-12 16:27:53.197940+0800 GCD之函数和队列[5926:204672] 主队列 + 异步：&lt;_NSMainThread: 0x600001880000&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 16:27:53.213528+0800 GCD之函数和队列[5926:204672] 主队列 + 异步：0 - &lt;_NSMainThread: 0x600001880000&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 16:27:53.213718+0800 GCD之函数和队列[5926:204672] 主队列 + 异步：1 - &lt;_NSMainThread: 0x600001880000&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 16:27:53.213879+0800 GCD之函数和队列[5926:204672] 主队列 + 异步：2 - &lt;_NSMainThread: 0x600001880000&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 16:27:53.214016+0800 GCD之函数和队列[5926:204672] 主队列 + 异步：3 - &lt;_NSMainThread: 0x600001880000&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 16:27:53.214196+0800 GCD之函数和队列[5926:204672] 主队列 + 异步：4 - &lt;_NSMainThread: 0x600001880000&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>全局并发队列 + 同步函数</li></ol><p>【任务 <code>按顺序执行</code>】：任务一个接一个的执行，不开辟新线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 全局并发队列 + 同步函数</span><br><span class="line">- (void)test7&#123;</span><br><span class="line">    NSLog(@&quot;全局并发 + 同步：%@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0);</span><br><span class="line">    for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">        dispatch_sync(globalQueue, ^&#123;</span><br><span class="line">            NSLog(@&quot;全局并发 + 同步：%d - %@&quot;,i,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，查看打印结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2022-01-12 16:32:08.207844+0800 GCD之函数和队列[6000:209221] 全局并发 + 同步：&lt;_NSMainThread: 0x60000031c140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 16:32:08.207992+0800 GCD之函数和队列[6000:209221] 全局并发 + 同步：0 - &lt;_NSMainThread: 0x60000031c140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 16:32:08.208098+0800 GCD之函数和队列[6000:209221] 全局并发 + 同步：1 - &lt;_NSMainThread: 0x60000031c140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 16:32:08.208280+0800 GCD之函数和队列[6000:209221] 全局并发 + 同步：2 - &lt;_NSMainThread: 0x60000031c140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 16:32:08.208400+0800 GCD之函数和队列[6000:209221] 全局并发 + 同步：3 - &lt;_NSMainThread: 0x60000031c140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 16:32:08.208504+0800 GCD之函数和队列[6000:209221] 全局并发 + 同步：4 - &lt;_NSMainThread: 0x60000031c140&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>全局并发队列 + 异步函数</li></ol><p>【任务 <code>乱序执行</code>】：任务乱序执行，会开辟新线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 全局并发队列 + 异步函数</span><br><span class="line">- (void)test8&#123;</span><br><span class="line">    NSLog(@&quot;全局并发 + 异步：%@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0);</span><br><span class="line">    for (int i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">        dispatch_async(globalQueue, ^&#123;</span><br><span class="line">            NSLog(@&quot;全局并发 + 异步：%d - %@&quot;,i,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，查看打印结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2022-01-12 16:34:18.147614+0800 GCD之函数和队列[6082:211916] 全局并发 + 异步：&lt;_NSMainThread: 0x600002cd8340&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 16:34:18.147839+0800 GCD之函数和队列[6082:212058] 全局并发 + 异步：1 - &lt;NSThread: 0x600002cdcdc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-01-12 16:34:18.147859+0800 GCD之函数和队列[6082:212057] 全局并发 + 异步：0 - &lt;NSThread: 0x600002c97640&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2022-01-12 16:34:18.147880+0800 GCD之函数和队列[6082:212052] 全局并发 + 异步：2 - &lt;NSThread: 0x600002cb9140&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2022-01-12 16:34:18.147880+0800 GCD之函数和队列[6082:212053] 全局并发 + 异步：3 - &lt;NSThread: 0x600002c972c0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-01-12 16:34:18.147892+0800 GCD之函数和队列[6082:212055] 全局并发 + 异步：4 - &lt;NSThread: 0x600002c80000&gt;&#123;number = 8, name = (null)&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th align="center">函数\队列</th><th align="center">串行队列</th><th align="center">并发队列</th><th align="center">主队列</th><th align="center">全局并发队列</th></tr></thead><tbody><tr><td align="center">同步函数</td><td align="center">顺序执行，不开辟新线程</td><td align="center">顺序执行，不开辟新线程</td><td align="center">死锁</td><td align="center">顺序执行，不开辟新线程</td></tr><tr><td align="center">异步函数</td><td align="center">顺序执行，开辟新线程</td><td align="center">乱序执行，开辟新线程</td><td align="center">顺序执行，不开破新线程</td><td align="center">乱序执行，开辟先线程</td></tr></tbody></table><h1 id="相关面试题解析"><a href="#相关面试题解析" class="headerlink" title="相关面试题解析"></a>相关面试题解析</h1><ol><li>【面试题-1】：并行队列 + 异步函数</li></ol><p>下面代码的输出顺序是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)interview01&#123;</span><br><span class="line">    // 并发队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    NSLog(@&quot;1 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    // 耗时</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 %@&quot;,[NSThread currentThread]);</span><br><span class="line">        // 耗时</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;3 %@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;4 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;5 %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，查看打印结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2022-01-12 16:50:01.867461+0800 GCD之函数和队列[6319:225209] 1 &lt;_NSMainThread: 0x6000023f4840&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 16:50:01.867626+0800 GCD之函数和队列[6319:225209] 5 &lt;_NSMainThread: 0x6000023f4840&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 16:50:01.867695+0800 GCD之函数和队列[6319:225342] 2 &lt;NSThread: 0x600002399ec0&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2022-01-12 16:50:01.867840+0800 GCD之函数和队列[6319:225342] 4 &lt;NSThread: 0x600002399ec0&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2022-01-12 16:50:01.867852+0800 GCD之函数和队列[6319:225345] 3 &lt;NSThread: 0x6000023a8b00&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure><ul><li><code>异步函数</code> 并 <code>不会阻塞</code> 主队列，<code>会开辟新线程</code> 执行异步任务</li></ul><p>代码分析：如下图所示，红线表示任务的执行顺序</p><p><img src="https://user-images.githubusercontent.com/25925248/149465493-ce2e9bab-6238-4380-84ac-24d2ce38f36b.jpg"></p><ul><li><code>主线程</code> 的任务队列为：<code>任务1、异步block1、任务5</code>，其中 <code>异步block1</code> 会比较耗费性能，<code>任务1</code> 和 <code>任务5</code> 的任务复杂度是相同的，所以 <code>任务1</code> 和 <code>任务5</code> 优先于 <code>异步block1</code> 执行</li><li>在 <code>异步block1</code> 中，任务队列为：<code>任务2、异步block2、任务4</code>，其中 <code>block2</code> 相对比较耗费性能，<code>任务2</code> 和 <code>任务4</code> 复杂度一样，所以 <code>任务2</code> 和 <code>任务4</code> 优先于 <code>block2</code> 执行</li><li>最后执行 <code>block2</code> 中的 <code>任务3</code></li><li>在极端情况下，可能会出现 <code>任务2</code> 优先 <code>任务1</code> 和 <code>任务5</code> 执行，原因是出现了当前<code>主线程卡顿或者延迟</code> 的情况</li></ul><p>代码修改</p><ul><li>【修改1】：将 <code>并行队列</code> 改成 <code>串行队列</code>，对结果没有任何影响，顺序仍然是 <code>15243</code></li><li>【修改2】：在 <code>任务5</code> 之前，休眠2s，即 <code>sleep(2)</code>，执行的顺序为：<code>12435</code>，原因是因为 I&#x2F;O 的打印，相比于休眠 <code>2s</code>，复杂度更简单，所以 <code>异步block1</code> 会优先于任务5执行。当然如果主队列阻塞，会出现其他的执行顺序。</li></ul><ol start="2"><li>【面试题-2】：并发队列 + 异步函数嵌套同步函数</li></ol><p>下面代码的输出顺序是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)interview2&#123;</span><br><span class="line">    // 并发队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    NSLog(@&quot;1 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    //异步函数</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 %@&quot;,[NSThread currentThread]);</span><br><span class="line">        // 同步函数</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;3 %@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;4 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;5 %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，查看打印结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2022-01-12 17:37:11.034204+0800 GCD之函数和队列[7126:263322] 1 &lt;_NSMainThread: 0x600000074300&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 17:37:11.034340+0800 GCD之函数和队列[7126:263322] 5 &lt;_NSMainThread: 0x600000074300&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-12 17:37:11.034378+0800 GCD之函数和队列[7126:263438] 2 &lt;NSThread: 0x600000039c40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2022-01-12 17:37:11.034494+0800 GCD之函数和队列[7126:263438] 3 &lt;NSThread: 0x600000039c40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2022-01-12 17:37:11.034625+0800 GCD之函数和队列[7126:263438] 4 &lt;NSThread: 0x600000039c40&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><ul><li><code>任务1、block1、任务5</code> 的分析和前面一致，执行顺序为：<code>任务1 任务5 block1</code></li><li>在 <code>异步block1</code> 中，<code>任务2、block2、任务4</code> 的执行顺序，由于 block2 是同步函数会阻塞当前线程，所以 <code>任务4</code> 需要等待 <code>block2</code> 中的 <code>任务3</code> 执行完成后，才能执行，所以异步block中的执行顺序是：<code>任务2、任务3、任务4</code></li></ul><ol start="3"><li>【面试题-3】：串行队列 + 异步函数嵌套同步函数</li></ol><p>下面代码的输出顺序是什么？会出现什么情况？为什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)interview3&#123;</span><br><span class="line">    // 串行队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    NSLog(@&quot;1 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    //异步函数</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 %@&quot;,[NSThread currentThread]);</span><br><span class="line">        // 同步函数</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;3 %@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;4 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;5 %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，查看打印结果如下</p><p><img src="https://user-images.githubusercontent.com/25925248/149465564-efec19c6-d93c-43c1-94be-0cc29c25a752.jpg"></p><p>分析：</p><p>如下图所示，红色代表任务执行顺序，黄色线表示等待</p><p><img src="https://user-images.githubusercontent.com/25925248/149465613-4365fe45-27a5-4dcb-a3b2-cc4203b6e5cb.jpg"></p><ul><li>首先，在主线程上有 <code>任务1、异步block、任务5</code>，首先执行 <code>任务1</code>，由于 <code>异步block</code> 复杂度高于 <code>任务5</code>，因此，执行顺序是 <code>任务1 -&gt; 任务5 -&gt; 异步block</code></li><li>在异步block中，开启了新的线程，执行顺序首先是 <code>任务2</code>，然后是 <code>同步block</code>，<code>同步函数会阻塞当前线程</code>，所以执行 <code>任务4</code> 需要 <code>等待任务3完成</code>，由于 <code>任务3的执行</code>，需要 <code>等待异步block完成</code>，<code>异步block完成</code>需要 <code>等待任务4完成</code>，</li><li>因此就会造成 <code>任务4等待任务3，任务3等待任务4</code>，即 <code>互相等待</code> 的局面，就会造成 <code>死锁</code>，这里有个重点是 <code>关键的堆栈slow</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/149465645-76bcee0b-5ed8-4297-9dea-54a87155dd29.jpg"></p><p>修改</p><p>去掉任务4，执行顺序是什么？</p><ul><li>还是会死锁，因为 <code>任务3等待的是异步block执行完毕，而异步block等待任务3完成</code></li></ul><p>4、【面试题4-新浪】：异步函数 + 同步函数 + 并发队列</p><p>下面代码执行的顺序是什么？（答案是AC）<br>A：1230789<br>B：1237890<br>C：3120798<br>D：2137890</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)interview04&#123;</span><br><span class="line">    // 并发队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123; // 耗时</span><br><span class="line">        NSLog(@&quot;1 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    // 同步</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;3 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;0 %@&quot;,[NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;7 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;8 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;9 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果是： （1、2、3无序） 0 （7、8、9无序），可以确定的 0 一定在 3 之后， 在789之前</p><p>分析：</p><ul><li><code>任务1</code> 和 <code>任务2</code> 是由于 <code>异步函数 + 并发队列</code>，会开启线程，所以没有固定顺序</li><li><code>任务7、任务8、任务9</code>同理，会开启线程，所以没有固定顺序</li><li><code>任务3</code> 是 <code>同步函数 + 并发队列</code>，同步函数会 <code>阻塞主线程</code>，但是也只会阻塞0，所以，可以确定的是 <code>0一定在3之后，在789之前</code></li></ul><p>以下是不同的打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2022-01-14 14:45:42.843292+0800 GCD之函数和队列[18838:775240] 3 &lt;_NSMainThread: 0x600001198a00&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-14 14:45:42.843329+0800 GCD之函数和队列[18838:775341] 1 &lt;NSThread: 0x600001189cc0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-01-14 14:45:42.843361+0800 GCD之函数和队列[18838:775340] 2 &lt;NSThread: 0x600001195a40&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2022-01-14 14:45:42.843415+0800 GCD之函数和队列[18838:775240] 0 &lt;_NSMainThread: 0x600001198a00&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-14 14:45:42.843546+0800 GCD之函数和队列[18838:775340] 7 &lt;NSThread: 0x600001195a40&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2022-01-14 14:45:42.843628+0800 GCD之函数和队列[18838:775341] 8 &lt;NSThread: 0x600001189cc0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-01-14 14:45:42.843653+0800 GCD之函数和队列[18838:775343] 9 &lt;NSThread: 0x60000119ce80&gt;&#123;number = 6, name = (null)&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2022-01-14 14:50:18.831754+0800 GCD之函数和队列[18899:780910] 3 &lt;_NSMainThread: 0x600000054a00&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-14 14:50:18.831835+0800 GCD之函数和队列[18899:781015] 2 &lt;NSThread: 0x600000010e00&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2022-01-14 14:50:18.831801+0800 GCD之函数和队列[18899:781016] 1 &lt;NSThread: 0x600000052340&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-01-14 14:50:18.831887+0800 GCD之函数和队列[18899:780910] 0 &lt;_NSMainThread: 0x600000054a00&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-14 14:50:18.832053+0800 GCD之函数和队列[18899:781016] 7 &lt;NSThread: 0x600000052340&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-01-14 14:50:18.832058+0800 GCD之函数和队列[18899:781015] 8 &lt;NSThread: 0x600000010e00&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2022-01-14 14:50:18.832082+0800 GCD之函数和队列[18899:781019] 9 &lt;NSThread: 0x600000011b80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2022-01-14 14:51:47.433576+0800 GCD之函数和队列[18934:784384] 3 &lt;_NSMainThread: 0x6000030280c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-14 14:51:47.433577+0800 GCD之函数和队列[18934:784516] 2 &lt;NSThread: 0x6000030741c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2022-01-14 14:51:47.433578+0800 GCD之函数和队列[18934:784518] 1 &lt;NSThread: 0x60000304d540&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2022-01-14 14:51:47.433718+0800 GCD之函数和队列[18934:784384] 0 &lt;_NSMainThread: 0x6000030280c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2022-01-14 14:51:47.433880+0800 GCD之函数和队列[18934:784518] 7 &lt;NSThread: 0x60000304d540&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2022-01-14 14:51:47.433890+0800 GCD之函数和队列[18934:784513] 9 &lt;NSThread: 0x600003040000&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2022-01-14 14:51:47.433891+0800 GCD之函数和队列[18934:784516] 8 &lt;NSThread: 0x6000030741c0&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>5、【面试题-5-美团】：下面代码中，队列的类型有几种？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 串行队列 - Serial Dispatch Queue</span><br><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, NULL);</span><br><span class="line">    </span><br><span class="line">// 并发队列 - Concurrent Dispatch Queue</span><br><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.ZJ.Queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">// 主队列 - Main Dispatch Queue</span><br><span class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">// 全局并发队列 - Global Dispatch Queue</span><br><span class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0);</span><br></pre></td></tr></table></figure><p>队列总共有两种：<code>串行队列</code> 和 <code>并发队列</code></p><ul><li>串行队列：serialQueue、mainQueue</li><li>并发队列：concurrentQueue、globalQueue</li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理25：多线程原理探索</title>
      <link href="/BboyZJ.github.io/2021/02/21/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8625%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2021/02/21/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8625%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文的目的在于了解<code>进程、线程、多线程、线程池</code> 等的基本概念及原理</p><h1 id="线程和进程的定义"><a href="#线程和进程的定义" class="headerlink" title="线程和进程的定义"></a>线程和进程的定义</h1><p><strong>线程</strong></p><ul><li><code>线程是进程的基本执行单元，一个进程的所有任务都在线程中执行</code></li><li>进程要想执行任务，必须得有线程，<code>一个进程至少要有一条线程</code></li><li><code>程序启动会默认开启一条线程</code>，这条线程被称为<code>主线程</code> 或者 <code>UI线程</code></li></ul><p><strong>进程</strong></p><ul><li><code>进程</code> 是指在 <code>系统中正在运行的一个应用程序</code></li><li>每个<code>进程之间是独立</code>的，<code>每个进程均运行在其专用的且受保护的内存空间内</code></li><li>通过<code>活动监视器</code>可以查看<code>Mac</code>系统中所开启的线程</li></ul><p>所以，可以简单的理解为：<code>进程是线程的容器，而线程是用来执行任务的</code>。在iOS中是单进程开发，<code>一个进程就是一个APP</code>，<code>进程</code>之间是<code>相互独立的</code>，如：微信、支付宝、qq等，这些都属于不同的进程。</p><h1 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h1><p>进程和线程之间的关系主要涉及两个方面：</p><p><strong>地址空间</strong></p><ul><li>同一个进程的<code>线程共享本进程的地址空间</code></li><li>而<code>进程之间则是独立的地址空间</code></li></ul><p><strong>资源拥有</strong></p><ul><li>同一个进程内<code>线程共享进程的资源</code>，如内存、I&#x2F;O、cpu等</li><li>但是<code>进程之间资源是独立的</code></li></ul><p>进程和线程的关系就相当于<code>工厂和流水线的关系</code>，工厂和工厂之间是相互独立的，而工厂中的流水线是共享工厂的资源的，即<code>进程</code>相当于一个<code>工厂</code>，<code>线程</code>相当于工厂中的一条<code>流水线</code></p><p><strong>针对进程和线程，还有以下几点说明：</strong></p><p>1、多进程要比多线程健壮</p><ul><li>一个进程崩溃后，在保护模式下不会对其他进程产生影响</li><li>而一个线程崩溃后整个进程都死掉</li></ul><p>2、使用场景：频繁切换、并发操作</p><ul><li>进程切换时，小号的资源大、效率高，所以设计到<code>频繁切换</code>时，使用线程要好与进程</li><li>同样，如果要求同时进行并又要共享某些变量的<code>并发操作</code>，<code>只能用线程</code>，不能用进程</li></ul><p>3、执行过程</p><ul><li>每个独立的<code>进程</code>有一个程序<code>运行的入口</code>、<code>顺序执行序列</code>和<code>程序入口</code></li><li>但是<code>线程不能独立执行，必须依赖存在应用程序中</code>，由应用程序提供多个线程来执行控制</li></ul><p>4、<code>线程是处理器调度的基本单元</code>，但<code>进程不是</code></p><p>5、<code>线程没有地址空间，线程包含在进程的地址空间中</code></p><h1 id="线程-和-Runloop-的关系"><a href="#线程-和-Runloop-的关系" class="headerlink" title="线程 和 Runloop 的关系"></a>线程 和 Runloop 的关系</h1><ul><li><p><code>runloop与线程是一一对应的</code>，一个<code>runloop</code>对应一个<code>核心</code>的线程，为什么说<code>核心的</code>，是因为<code>runloop是可以嵌套的，但是核心的只能有一个</code>，他们的关系保存在一个<code>全局的字典里</code></p></li><li><p><code>runloop是用来管理线程的</code>，当线程的<code>runloop</code>被开启后，线程会在执行完任务后进入<code>休眠状态</code>，有了任务就会被唤醒去执行任务。</p></li><li><p><code>runloop</code>在第一次获取时被创建，在线程结束时被销毁</p></li><li><p>对于<code>主线程</code>来说，<code>runloop在程序已启动就默认创建好了</code></p></li><li><p>对于<code>子线程</code>来说，<code>runloop是来加载的，只有当我们使用的时候才会创建</code>，所以<code>在子线程使用定时器</code>要注意，<code>确保子线程的runloop被创建，不然定时器不会回调</code></p></li></ul><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><strong>多线程原理</strong></p><ul><li>对于 <code>单核CPU</code>，同一时间，CPU只能处理一条线程，即只有一条线程在工作</li><li>iOS中的多线程同时执行，其本质是<code>CPU在多个任务间直接进行快速切换</code>，由于CPU调度线程的时间足够快，就造成了<code>多线程同时执行</code>的效果，其中奇幻的时间间隔就是<code>时间片</code></li></ul><p><strong>多线程意义</strong></p><p><strong>优点</strong></p><ul><li>能适当<code>提高程序的执行效率</code></li><li>能适当<code>提高资源的利用率</code>，如CPU、内存</li><li>线程上的任务执行完成后，<code>线程会自动销毁</code></li></ul><p><strong>缺点</strong></p><ul><li><code>开启线程需要占用一定的内存空间</code>，默认情况下，<code>每一个线程占用512KB</code></li><li>如果开启<code>大量线程，会占用大量的内存空间，降低程序的性能</code></li><li><code>线程越多，CPU在调用线程上的开销越大</code></li><li>程序设计更加复杂，比如线程间的通信，多线程的数据共享</li></ul><h1 id="多线程生命周期"><a href="#多线程生命周期" class="headerlink" title="多线程生命周期"></a>多线程生命周期</h1><p>多线程的声明周期主要分为五个部分：<code>新建-就绪-运行-阻塞-死亡</code>，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/126594135-90822202-2525-4dad-9b49-33f883c2717c.png"></p><ul><li><p><code>新建</code>：主要是实例化线程对象</p></li><li><p><code>就绪</code>：线程对象 <code>调用start方法</code>，将线程对象 <code>加入可调度线程池</code>，<code>等待CPU的调用</code>，即 <code>调用start方法，并不会立即执行</code>，进入 <code>就绪状态</code>，需要等待一段时间，<code>经CPU调度后才执行</code>，也就是从就绪状态进入 <code>运行状态</code></p></li><li><p><code>运行</code>：<code>CPU负责调度可调度线程的执行</code>，在线程执行完成之前，其状态可能会在就绪和运行之间来回切换，这个变化是由<code>CPU负责</code>，开发人员不能干预</p></li><li><p><code>阻塞</code>：当满足某个预定条件时，可以 <code>使用休眠、即sleep、或者同步锁</code>，阻塞线程执行，当进入sleep时，会重新将 <code>线程加入就绪</code> 中，下面关于休眠的时间设置，都是 <code>NSThread</code> 的</p><ul><li><code>sleepUnilDate</code> ：阻塞当前线程，直到指定的时间为止，即 &#96;休眠到指定时间</li><li><code>sleepForTimeInerval</code>：在给定的时间间隔内休眠线程，即 <code>指定休眠时长</code></li><li>同步锁：<code>@synchronized(self)</code></li></ul></li><li><p><code>死亡</code>：分为两种情况</p><ul><li><code>正常死亡</code>，即线程执行完毕</li><li><code>非正常死亡</code>，即当满足某个条件后，在线程内部（或主线程中）终止执行（调用exit方法等退出）</li></ul></li><li><p>简要说明：就是处于 <code>运行中的线程</code> 拥有一段可以执行的事件（成为 <code>时间片</code>）</p><ul><li>如果 <code>时间片用尽</code>，线程就会进入 <code>就绪状态队列</code></li><li>如果 <code>时间片没有用尽</code>，且需要开始 <code>等待某事件</code>，就会进入 <code>阻塞状态队列</code></li><li>等待事件发生后，线程又重新进入 <code>就绪状态队列</code></li><li>每当一个 <code>线程离开运行</code>，即执行完毕或者强制退出后，会重新 <code>从就绪状态队列中</code>选择一个线程继续执行</li></ul></li></ul><p>线程的 <code>exit</code> 和 <code>cancel</code> 说明：<br>    <code>exit</code>：一旦强行终止线程，后续的所有代码都不会执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- cancel：取消当前线程，但是不能取消正在执行的线程</span><br></pre></td></tr></table></figure><p><strong>【面试题】线程的优先级越高，是不是意味着任务的执行越快？</strong></p><p>答：<code>并不是</code>，线程执行的快慢，除了要看优先级，还需要查看 <code>资源的大小（即任务的复杂度）</code>、以及 <code>CPU调度</code> 情况，在NSThread中，线程优先级 <code>threadPriority</code> 已经被服务质量 <code>qualityOfService</code> 取代，一下是相关的枚举值：</p><p><img src="https://user-images.githubusercontent.com/25925248/126586258-23cd47ec-33b9-4ad5-a487-33fbb930e763.jpg"></p><h1 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h1><p><img src="https://user-images.githubusercontent.com/25925248/126594080-72c58e2b-27fc-4e42-b884-6657dbba7d02.png"></p><ul><li><p>【第一步】判断核心线程是否都正在执行任务</p><ul><li>返回NO，创建新的工作线程去执行</li><li>返回YES，进入【第二步】</li></ul></li><li><p>【第二步】判断线程池工作队列是否已经饱满</p><ul><li>返回NO，将任务存储到工作队列，等待CPU调度</li><li>返回YES，进入【第三步】</li></ul></li><li><p>【第三步】判断线程池中的线程是否都出于执行状态</p><ul><li>返回NO，安排可调度线程池中空闲的线程去执行任务</li><li>返回YES，进入【第四步】</li></ul></li><li><p>【第四步】交给饱和策略去执行，主要有以下四种（在iOS中并没有找到以下4中策略）</p><ul><li><code>AbortPolicy</code>：直接抛出<code>RejectedExecutionExeception</code>异常来阻止系统正常运行</li><li><code>CallerRunsPolicy</code> ：将任务回退到调用者</li><li><code>DisOldestPolicy</code>：丢掉等待最久的任务</li><li><code>DisCardPolicy</code>：直接丢弃任务</li></ul></li></ul><h1 id="iOS中多线程的实现方案"><a href="#iOS中多线程的实现方案" class="headerlink" title="iOS中多线程的实现方案"></a>iOS中多线程的实现方案</h1><p>iOS中的多线程实现方式，主要有四种：<code>pthread、NSThread、GCD、NSOperation</code>，汇总如图所示：</p><table><thead><tr><th align="center">方案</th><th align="center">简介</th><th align="center">语言</th><th align="center">线程的声明周期</th><th align="center">使用频率</th></tr></thead><tbody><tr><td align="center">Pthread</td><td align="center">1、一套通用的多线程API 2、使用与Unix&#x2F;Linus&#x2F;windows等系统 3、跨平台、可移植 4、使用难度大</td><td align="center">C</td><td align="center">程序员管理</td><td align="center">几乎不用</td></tr><tr><td align="center">NSThread</td><td align="center">1、使用更加面向对象 2、使用简单，可直接操作线程对象</td><td align="center">OC</td><td align="center">程序员管理</td><td align="center">偶尔使用</td></tr><tr><td align="center">GCD</td><td align="center">1、旨在替代GCD等线程技术 2、充分利用设备的多核</td><td align="center">C</td><td align="center">自动管理</td><td align="center">经常使用</td></tr><tr><td align="center">NSOperation</td><td align="center">1、基于GCD（底层是GCD） 2、比GCD多了一些更简单实用的功能 3、使用更加面向对象</td><td align="center">OC</td><td align="center">自动管理</td><td align="center">经常使用</td></tr></tbody></table><p>下面是四种方案的简单示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// *********1: pthread*********</span><br><span class="line">pthread_t threadId = NULL;</span><br><span class="line">//c字符串</span><br><span class="line">char *cString = &quot;HelloCode&quot;;</span><br><span class="line">/**</span><br><span class="line"> pthread_create 创建线程</span><br><span class="line"> 参数：</span><br><span class="line"> 1. pthread_t：要创建线程的结构体指针，通常开发的时候，如果遇到 C 语言的结构体，类型后缀 `_t / Ref` 结尾</span><br><span class="line"> 同时不需要 `*`</span><br><span class="line"> 2. 线程的属性，nil(空对象 - OC 使用的) / NULL(空地址，C 使用的)</span><br><span class="line"> 3. 线程要执行的`函数地址`</span><br><span class="line"> void *: 返回类型，表示指向任意对象的指针，和 OC 中的 id 类似</span><br><span class="line"> (*): 函数名</span><br><span class="line"> (void *): 参数类型，void *</span><br><span class="line"> 4. 传递给第三个参数(函数)的`参数`</span><br><span class="line"> */</span><br><span class="line">int result = pthread_create(&amp;threadId, NULL, pthreadTest, cString);</span><br><span class="line">if (result == 0) &#123;</span><br><span class="line">    NSLog(@&quot;成功&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">//*********2、NSThread*********</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(threadTest) toTarget:self withObject:nil];</span><br><span class="line">    </span><br><span class="line">//*********3、GCD*********</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    [self threadTest];</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">//*********4、NSOperation*********</span><br><span class="line">[[[NSOperationQueue alloc] init] addOperationWithBlock:^&#123;</span><br><span class="line">    [self threadTest];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 函数方法</span><br><span class="line">- (void)threadTest&#123;</span><br><span class="line">    NSLog(@&quot;begin&quot;);</span><br><span class="line">    NSInteger count = 1000 * 100;</span><br><span class="line">    for (NSInteger i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        // 栈区</span><br><span class="line">        NSInteger num = i;</span><br><span class="line">        // 常量区</span><br><span class="line">        NSString *name = @&quot;zhang&quot;;</span><br><span class="line">        // 堆区</span><br><span class="line">        NSString *myName = [NSString stringWithFormat:@&quot;%@ - %zd&quot;, name, num];</span><br><span class="line">        NSLog(@&quot;%@&quot;, myName);</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;over&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *pthreadTest(void *para)&#123;</span><br><span class="line">    // 接 C 语言的字符串</span><br><span class="line">    // NSLog(@&quot;===&gt; %@ %s&quot;, [NSThread currentThread], para);</span><br><span class="line">    // __bridge 将 C 语言的类型桥接到 OC 的类型</span><br><span class="line">    NSString *name = (__bridge NSString *)(para);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;===&gt;%@ %@&quot;, [NSThread currentThread], name);</span><br><span class="line">    </span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-和-OC-的桥接"><a href="#C-和-OC-的桥接" class="headerlink" title="C 和 OC 的桥接"></a>C 和 OC 的桥接</h1><p>其中涉及C与OC的桥接，有以下几点说明</p><ul><li><p><code>__bridge</code>只做类型转换，但是<code>不修改对象（内存）管理权</code></p></li><li><p><code>__bridge_retained</code>(也可以使用<code>CFBridgingRetain</code>)将<code>Object-C的对象</code>转换为<code>Core Foundation的对象</code>，同时将对象（内存）的<code>管理权交给我们</code>，后续<code>需要使用 CFRelease或相关方法来释放对象</code></p></li><li><p><code>__bridge_transfer</code>(也可以使用 <code>CFBridgingRelease</code>)将 <code>Core Foundation</code> 的对象 转换为 <code>Object-C的对象</code>，同时将 <code>对象（内存）的管理权交给ARC</code></p></li></ul><h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><p>当多个线程同时访问一块内存资源时，容易引发数据错乱 和 数据安全问题，有以下两种解决方案：</p><ul><li>互斥锁（即同步锁）：<code>@synchronized</code></li><li>自旋锁</li></ul><p><strong>互斥锁</strong></p><ul><li>用于保护临界区，确保 <code>同一时间，只有一条线程能够执行</code></li><li>如果代码中 <code>只有一个地方需要加锁，大多数都使用 self</code>，这样可以避免单独再创建一个锁对象</li><li>加入互斥锁的代码，当新线程访问时，如果发现其他线程正在执行锁定的代码，新线程就会进入 <code>休眠</code></li></ul><p>针对互斥锁，还需要注意以下几点：</p><ul><li>互斥锁的 <code>锁定范围，应该尽量小</code>，锁定范围越大，效率越差</li><li>能够 <code>加锁的任意 NSObject 对象</code></li><li>锁对象一定要保证所有的线程都能够访问</li></ul><p><strong>自旋锁</strong></p><ul><li><code>自旋锁</code> 与 <code>互斥锁</code> 类似，但它不是通过休眠使线程阻塞，而是 <code>在获取锁之前一直处于忙等（即原地打转，成为自旋）阻塞状态</code></li><li>使用场景：锁持有的时间短，切线程不希望在重新调度上花太多成本时，就需要使用自旋锁，属性修饰符 <code>atomic</code>，本身就有一把 <code>自旋锁</code></li><li>加入了自旋锁，当新线程访问代码时，如果发现有其他线程正在锁定代码，新线程会用 <code>死循环</code> 的方法，一直等待锁定的代码执行完成，即 <code>不停的尝试执行代码，比较消耗性能</code></li></ul><p><strong>【面试题】：自旋锁 vs 互斥锁</strong></p><ul><li><p>同：在同一时间，保证了只有一条线程执行任务，即保证了相应 <code>同步</code> 的功能</p></li><li><p>不同：</p><ul><li><code>互斥锁</code>：发现其他线程执行，当前线程<code>休眠（即就绪状态）</code> ，进入等待执行，即挂起，一直等其他线程打开后，然后唤醒执行</li><li><code>自旋锁</code>：发现其他线程执行，当前线程 <code>一直询问</code>（即一直访问），处于<code>忙等状态，耗费的性能</code>比较高</li></ul></li><li><p>场景：根据任务复杂度区分，使用不同的锁，但判断补全时，更多的是使用<code>互斥锁</code>去处理</p><ul><li>当前的任务状态比较 <code>短小精悍</code>时，用<code>自旋锁</code></li><li>反之的，用互斥锁</li></ul></li></ul><h1 id="atomic-原子锁-amp-nonatomic-非原子锁"><a href="#atomic-原子锁-amp-nonatomic-非原子锁" class="headerlink" title="atomic 原子锁 &amp; nonatomic 非原子锁"></a>atomic 原子锁 &amp; nonatomic 非原子锁</h1><p><code>atomic</code> 和 <code>nonatomic</code> 主要用于属性的修饰，以下是相关的一些说明：</p><ul><li><p><code>atomic</code> 是 <code>原子属性</code>，是为 <code>多线程开发准备</code>的，是默认属性</p><ul><li>仅仅在属性的 <code>setter</code> 方法中，增加了 <code>锁（自旋锁）</code>，能够 <code>保证同一时间，只有一条线程</code> 对属性进行 <code>写</code> 操作</li><li><code>同一时间单（线程）写多（线程）读</code> 的 <code>线程处理技术</code></li><li>Mac开发中常用</li></ul></li><li><p><code>nonatomic</code> 是<code> 非原子属性</code></p><ul><li><code>没有锁</code> ， <code>性能高</code> </li><li>移动端开发常用</li></ul></li></ul><p><strong>【面试题】 atomic 和 nonatmic区别</strong></p><ul><li><p>nonatomic</p><ul><li><code>非原子属性</code> </li><li><code>非线程安全</code>，适合内存小的移动设备</li></ul></li><li><p>atomic</p><ul><li><code>原子属性</code>，<code>线程安全 </code>，针对多线程设计的，默认值</li><li>保证<code>同一时间只有一个线程能够写入</code>，但是同一个时间多个线程都可以取值</li><li>atomic本身就有一把锁（<code>自旋锁</code>），<code>单写多读</code>：单个线程写入，多个线程读取</li><li><code>线程安全</code>，需要<code>消耗大量的资源</code></li></ul></li></ul><h1 id="iOS开发建议"><a href="#iOS开发建议" class="headerlink" title="iOS开发建议"></a>iOS开发建议</h1><ul><li>所有<code>属性</code>都声明为<code>nonatomic</code></li><li>尽量避免多线程抢夺同一块资源，尽量<code>将加锁、资源抢夺的业务逻辑交给服务器处理，减小移动端客户端的压力你</code></li></ul><h1 id="线程间的通讯"><a href="#线程间的通讯" class="headerlink" title="线程间的通讯"></a>线程间的通讯</h1><p>在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/AboutThreads/AboutThreads.html#//apple_ref/doc/uid/10000057i-CH6-SW25">Threading Programming Guide</a>文档中，提及，线程间的通讯有以下几种方式</p><p><img src="https://user-images.githubusercontent.com/25925248/126598157-728dbe2e-6169-4f21-a971-429069245c11.png"></p><ul><li><p><code>直接消息传递</code>：通过<code>performSelector</code>的一系列方法，可以实现由某一线程指定在另外的线程上执行任务，因为任务的执行上下文是目标线程，这种方式发送的消息将会自动的被序列化</p></li><li><p><code>全局变量、共享内存块和对象</code>：在两个线程之间传递信息的另一种简单的方法是使用<code>全局变量</code>，共享对象或共享内存块，尽管共享变量即快速又简单，但是它们比直接消息传递更脆弱，<code>必须使用锁或其他同步机制仔细保护共享变量，以确保代码的正确性</code>，否则可能会导致竞争状况，数据损坏或崩溃。</p></li><li><p><code>条件执行</code>: 条件是一种<code>同步工具</code>，可用于控制线程何时执行代码的特定部分。您可以将条件视为关守，让线程仅在满足指定条件时运行。</p></li><li><p><code>Runloop sources</code>: 一个自定义的 <code>Runloop source</code> 配置可以让一个线程上收到特定的应用程序消息。由于 <code>Runloop source 是事件驱动</code>的，因此在<code>无事可做时，线程会自动进入睡眠状态</code>，从而提高了线程的效率</p></li><li><p><code>Ports and sockets</code>：基于 <code>端口的通信</code> 是在两个线程之间进行通信的一种更为复杂的方法，但它也是一种 <code>非常可靠的技术</code>。更重要的是，端口和套接字可用于与外部实体（例如其他进程和服务）进行通信。为了提高效率，使用 <code>Runloop source 来实现端口</code>，因此当端口上没有数据等待时，线程将进入睡眠状态。需要注意的是，端口通讯需要将端口加入到 <code>主线程的Runloop中</code>，否则不会走到端口回调方法</p></li><li><p><code>消息队列</code>: 传统的多处理服务定义了<code>先进先出（FIFO）</code>队列抽象，用于管理传入和传出数据。尽管消息队列既简单又方便，但是它们不如其他一些通信技术高效</p></li><li><p><code>Cocoa 分布式对象</code>: 分布式对象是一种 Cocoa 技术，可提供基于端口的通信的高级实现。尽管可以将这种技术用于线程间通信，但是强烈建议不要这样做，因为它会产生大量开销。分布式对象更适合与其他进程进行通信，尽管在这些进程之间进行事务的开销也很高</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理24：内存五大区</title>
      <link href="/BboyZJ.github.io/2021/02/14/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8624%EF%BC%9A%E5%86%85%E5%AD%98%E4%BA%94%E5%A4%A7%E5%8C%BA/"/>
      <url>/BboyZJ.github.io/2021/02/14/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8624%EF%BC%9A%E5%86%85%E5%AD%98%E4%BA%94%E5%A4%A7%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在iOS中，内存主要分为 <code>栈区、堆区、全局区、常量区、代码区</code> 五个区域，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/125901732-fa12526a-8600-4a06-b2c5-9052f6ce50c9.jpeg"></p><h1 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h1><p><strong>义</strong></p><ul><li><p>栈是 <code>系统数据结构</code>，其对应的 <code>进程或者线程是唯一的</code></p></li><li><p>栈是 <code>向低地址扩展</code> 的数据结构</p></li><li><p>栈是一块 <code>连续的内存区域</code>，遵循 <code>先进后出（FILO）</code> 原则</p></li><li><p>栈区一般在 <code>运行时</code> 分配</p></li></ul><p><strong>存储</strong></p><p>栈区是由 <code>编译器自动分配并释放</code>的，主要来存储</p><ul><li><p><code>局部变量</code></p></li><li><p><code>函数的参数</code>，例如函数的隐藏参数（id self, SEL _cmd）</p></li></ul><p><strong>优缺点</strong></p><ul><li><p>优点：因为栈是由<code>编译器自动分配并释放</code>的，不会产生内存碎片，所以<code>快速高效</code></p></li><li><p>确定：栈的&#96;内存大小有限制，数据不灵活 </p><ul><li><code>iOS主线程大小是1MB</code></li><li>其他线程是<code>512KB</code></li><li>MAC只有<code>8MB</code></li></ul></li></ul><p>以上内存大小的说明，在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW7">Threading Programming Guide</a>中有相关说明，如下图：</p><p><img src="https://user-images.githubusercontent.com/25925248/125901809-574ffd97-9226-4f40-99d7-0b573935a2a4.ng"></p><h1 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h1><p>*<em>定义</em></p><ul><li><p>堆是<code>向高地址扩展</code>的数据结构</p></li><li><p>堆是<code>不连续的内存区域</code>，类似于<code>链表结构</code>（便于增删，不便于查询），遵循<code>先进先出（FIFO）</code>原则</p></li><li><p>堆的<code>地址空间</code>在iOS中是是动态的</p></li><li><p>堆区的分配一般是以在<code>运行时分配</code></p></li></ul><p>*<em>存储</em></p><p>堆区是<code>由程序员动态分配和释放</code>的，如果程序员不释放，程序结束后，可能由操作系统回收，主要用于存放：</p><ul><li><p><code>OC</code>中使用<code>alloc</code>或者<code>new</code>开辟空间创建<code>对象</code></p></li><li><p><code>C</code>语言中使用<code>malloc、calloc、realloc</code>分配的空间，需要<code>free</code>释放</p></li></ul><p><strong>优缺点</strong></p><ul><li><p>优点：灵活方便，数据适应面广泛</p></li><li><p>缺点：需<code>手动管理、速度慢</code>，容易产生内存碎片</p></li></ul><p>当需要访问堆中数据时，一般需要<code>先通过对象读取到栈区的指针地址</code>，然后通过<code>指针地址访问堆区</code></p><h1 id="全局区（静态区，即-bss-amp-data）"><a href="#全局区（静态区，即-bss-amp-data）" class="headerlink" title="全局区（静态区，即.bss &amp; .data）"></a>全局区（静态区，即.bss &amp; .data）</h1><p>全局区是<code>编译时分配</code>的内存空间，在程序运行过程中，此内存中的数据一直存在，<code>程序结束后由系统释放</code>，主要存：</p><ul><li><p><code>未初始化的全局变量和静态变量</code>，即BSS区（.bss）</p></li><li><p><code>已初始化的全局变量和静态变量</code>，即DATA区（.data）</p></li></ul><p>其中，<code>全局变量</code>是指变量值可以在<code>运行时被动态修改</code>，而<code>静态变量</code>是<code>static</code>修饰的变量，包含<code>静态局部变量</code>和<code>静态全局变量</code></p><h1 id="常量区（即-rodata）"><a href="#常量区（即-rodata）" class="headerlink" title="常量区（即.rodata）"></a>常量区（即.rodata）</h1><p>常量区是<code>编译时分配</code>的内存空间，在<code>程序结束后由系统释放</code>，主要存放：</p><ul><li>已经使用了的，且没有指向的<code>字符串常量</code></li></ul><p>字符串常量因为可能在程序中被多次使用，所以在程序运行之前就会提前分配内存</p><h1 id="代码区（即-text）"><a href="#代码区（即-text）" class="headerlink" title="代码区（即.text）"></a>代码区（即.text）</h1><p>代码区是<code>由编译时分配</code>，主要用于存放<code>程序运行时的代码</code>，代码会被编译成<code>二进制存进内存</code>的</p><h1 id="内存五大区验证"><a href="#内存五大区验证" class="headerlink" title="内存五大区验证"></a>内存五大区验证</h1><p>运行下面的一段代码，看看变量在内存中是如何分配的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a = 10; // 全局区（已初始化的全局变量）</span><br><span class="line">char * b; // 全局区(未初始化的全局变量)</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    NSInteger i = 123; // 栈区（局部变量）</span><br><span class="line">    NSLog(@&quot;i的内存地址：%p&quot;, &amp;i);</span><br><span class="line">    </span><br><span class="line">    NSString *string = @&quot;ZJ&quot;; // 常量区（字符串常量）</span><br><span class="line">    NSLog(@&quot;string的内存地址：%p&quot;, string);</span><br><span class="line">    NSLog(@&quot;&amp;string的内存地址：%p&quot;, &amp;string);</span><br><span class="line">    </span><br><span class="line">    NSObject *obj = [[NSObject alloc] init]; // 堆区（alloc对象）</span><br><span class="line">    NSLog(@&quot;obj的内存地址：%p&quot;, obj);</span><br><span class="line">    NSLog(@&quot;&amp;obj的内存地址：%p&quot;, &amp;obj);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2022-03-11 14:34:25.438913+0800 内存五大区[70321:4340509] i的内存地址：0x16f6f5a18</span><br><span class="line">2022-03-11 14:34:25.438976+0800 内存五大区[70321:4340509] string的内存地址：0x100710098</span><br><span class="line">2022-03-11 14:34:25.438997+0800 内存五大区[70321:4340509] &amp;string的内存地址：0x16f6f5a10</span><br><span class="line">2022-03-11 14:34:25.439014+0800 内存五大区[70321:4340509] obj的内存地址：0x280fa0bc0</span><br><span class="line">2022-03-11 14:34:25.439031+0800 内存五大区[70321:4340509] &amp;obj的内存地址：0x16f6f5a08</span><br></pre></td></tr></table></figure><ul><li><p>对于<code>局部变量i</code>， 存放在栈区</p></li><li><p>对于<code>字符串对象string</code>，分别打印了<code>string得对象地址</code>和<code>string对象的指针地址</code></p><ul><li>string的<code>对象地址</code>是是存放在<code>常量区</code></li><li>string<code>对象的指针地址</code>，是存放在<code>栈区</code></li></ul></li><li><p>对于<code>alloc创建的对象obj</code>，分别打印了<code>obj得对象地址</code>和<code>obj对象的指针地址</code></p><ul><li>obj的<code>对象地址</code>是存放在<code>堆区</code> </li><li>obj<code>对象的指针地址</code>是存放在<code>栈区</code></li></ul></li></ul><h1 id="函数栈"><a href="#函数栈" class="headerlink" title="函数栈"></a>函数栈</h1><ul><li><p><code>函数栈</code> 又称为 <code>栈区</code>，在内存中从高地址往低地址分配，与堆区相对，具体图示请看上面</p></li><li><p><code>栈帧</code> 是指 <code>函数（运行中且未完成）占用的一块独立的连续内存区域</code></p></li><li><p>应用中新创建的 <code>每个线程都有专用的栈空间</code>，栈可以在线程期间自由使用，而线程中有千千万万的函数调用，这些函数 <code>共享</code> 进程的这个 <code>栈空间</code>。<code>每个函数所使用的栈空间是一个栈帧，所有栈帧就组成了这个线程完成的栈</code></p></li><li><p><code>函数调用是发生在栈上</code> 的，每个 <code>函数的相关信息</code>（例如局部变量、调用记录等）都 <code>存储在一个栈帧</code> 中，每执行一次 <code>函数调用</code>，就会生成一个与其相关的栈帧，然后将其 <code>栈帧压入函数栈</code>，而当函数 <code>执行结束</code>，则将此函数对应的 <code>栈帧出栈并释放掉</code></p></li></ul><p>如下图所示，是经典图- <code>ARM的栈帧布局方式</code></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021911717.png"></p><ul><li><p>其中 <code>main stack frame</code> 为调用函数的栈帧</p></li><li><p><code>func1 stack frame</code> 为当前 <code>当前函数（被调用者）的栈帧</code></p></li><li><p><code>栈底</code> 在 <code>高</code> 地址，栈向下增长</p></li><li><p><code>FP</code> 就是 <code>栈基址</code>，它指向函数的 <code>栈帧起始地址</code></p></li><li><p><code>SP</code> 则是函数的 <code>栈指针</code>，它指向 <code>栈顶</code> 的位置</p></li><li><p><code>ARM压栈</code> 的 <code>顺序</code> 很是规则（也比较容易被黑客攻破），依次为 <code>当前函数指针PC</code>、<code>返回指针LR</code>、<code>栈指针SP</code>、<code>栈基址FP</code>、<code>传入参数个数及指针</code>、<code>本地变量</code> 和 <code>临时变量</code>。如果函数准备调用另一个函数，跳转之前临时变量区先要保存另一个函数的参数</p></li><li><p><code>ARM</code> 也可以 <code>用栈基址和栈指针明确标示栈帧的位置</code>，栈指针SP一直移动，ARM的特点是，<code>两个栈空间内的地址（SP+FP）前面，必然有两个代码地址（PC+LP）明确标示着调用函数位置内的某个地址</code></p></li></ul><h1 id="堆栈溢出"><a href="#堆栈溢出" class="headerlink" title="堆栈溢出"></a>堆栈溢出</h1><p>一般情况下应用程序是不需要考虑堆和栈的大小的，但是事实上堆和栈不是无上限的，<code>过多的递归会导致栈溢出</code>，<code>过多的alloc变量会导致堆溢出</code></p><p>所以 <code>预防堆栈溢出</code> 的方法：</p><ul><li><p><code>避免层次过深</code> 的 <code>递归</code> 调用</p></li><li><p><code>不要使用过多的局部变量</code>，控制局部变量的大小</p></li><li><p><code>避免分配</code> 占用空间 <code>太大的对象</code>，并 <code>及时释放</code></p></li><li><p>实在不行，适当的情景下 <code>调用系统API修改线程的堆栈大小</code></p></li></ul><h1 id="栈帧示例"><a href="#栈帧示例" class="headerlink" title="栈帧示例"></a>栈帧示例</h1><p>描述下面代码的栈帧变化</p><p>栈帧程序示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int Add(int x,int y) &#123;</span><br><span class="line">    int z = 0;</span><br><span class="line">    z = x + y;</span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    int ret = Add(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行时，栈区中栈帧的变化如下图所示：</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303021912743.png"></p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理23：KVO底层原理分析</title>
      <link href="/BboyZJ.github.io/2021/01/25/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8623%EF%BC%9AKVO%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/BboyZJ.github.io/2021/01/25/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8623%EF%BC%9AKVO%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>KVO</code> 全称 <code>Key Value Observing</code>，中文名为 <code>键值观察</code>，KVO是一种机制，它 <code>允许将其他对象的指定属性的更改通知给对象</code></p><p>在 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOBasics.html#//apple_ref/doc/uid/20002252-BAJEAIEE">key Value Observing Programming Guide</a> 官方文档中，有这么一句话：<code>理解KVO之前，必须先理解 KVC</code>（即KVO是基于KVC基础之上）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In order to understand key-value observing, you must first understand key-value coding.</span><br><span class="line"></span><br><span class="line">KVC是键值编码，在对象创建完成后，可以动态的给对象属性赋值，而KVO是键值观察，提供了一种监听机制，当指定的对象的属性被修改后，则对象会收到通知，所以可以看出KVO是基于KVC的基础上对属性动态变化的监听</span><br></pre></td></tr></table></figure><p>在iOS日常开发中，经常 <code>使用KVO来监听对象属性的变化</code>，并及时作出响应，即当指定的被观察对象属性被修改后，<code>KVO</code> 会自动通知响应的管擦着，那么 <code>KVO</code> 与 <code>NSNotificationCenter</code> 有什么区别呢？</p><ul><li><p>相同点</p><ul><li>两者的实现原理 <code>都是观察者模式</code>，都是用于 <code>监听</code></li><li>都能 <code>实现一对多</code> 的操作</li></ul></li><li><p>不同点</p><ul><li><code>KVO只能用于监听对象属性的变化</code>，并且属性名都是通过 <code>NSString</code> 来查找，编译器不会帮你检测对错和补全，纯手敲会比较容易出错</li><li><code>NSNotification</code> 的 <code>发送监听（post）</code> 的操作 <code>我们可以控制</code>，<code>KVO由系统控制</code></li><li><code>KVO</code> 可以 <code>记录新旧值变化</code></li></ul></li></ul><h1 id="KVO-使用"><a href="#KVO-使用" class="headerlink" title="KVO 使用"></a>KVO 使用</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>KVO的基本使用主要分为三步：</p><ul><li>注册观察者 <code>addObserver:forKeyPath:option:context</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br></pre></td></tr></table></figure><ul><li>实现KVO回调 <code>observerValueForKeyPath:ofObject:change:context</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;name&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>移除观察者 <code>removeObserver:forKeyPath:context</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.person removeObserver:self forKeyPath:@&quot;name&quot; context:NULL];</span><br></pre></td></tr></table></figure><h2 id="context-使用"><a href="#context-使用" class="headerlink" title="context 使用"></a>context 使用</h2><p>在官方文档中，针对 <code>参数context</code> 有如下说明：</p><p><img src="https://user-images.githubusercontent.com/25925248/160746846-6937a586-15d2-4d2c-ace8-dad2e559d00e.png"></p><p>大致含义就是：<code>addObserver:forKeyPath:option:context:</code> 方法中的 <code>上下文context</code> 指针包含任意数据，这些数据将在响应的更改通知中传递回观察者。可以通过 <code>指定context为NULL</code>，从而 <code>依靠keyPath</code> 即 <code>键路径字符串</code> 传来的确定更改通知的来源，但是这种方法可能导致对象的父类由于不同的原因也观察到相同的键路径而导致问题。所以可以为每个观察到的 <code>keyPath</code> 创建一个不同的 <code>context</code>，从而 <code>完全不需要进行字符串比较</code>，从而可以更有效地进行通知解析</p><p>通俗的讲，<code>context上下文</code> 主要是用于 <code>区分不同对象的同名属性</code>，从而在KVO回调方法中可以 <code>直接使用context进行区分，可以大大提高性能，以及代码的可读性，并且更加安全</code></p><p><strong>context使用总结</strong></p><ul><li>不使用 <code>context</code>，使用 <code>keyPath</code> 区分通知来源</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// context的类型是 nullable void *，应该是NULL，而不是nil</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br></pre></td></tr></table></figure><ul><li>使用 context 区分通知来源</li></ul><p>Person类中增加两个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,copy)NSString * name;</span><br><span class="line">@property (nonatomic,copy)NSString * nick;</span><br></pre></td></tr></table></figure><p>DetailViewController类中代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 定义context</span><br><span class="line">static void * PersonNickContext = &amp;PersonNickContext;</span><br><span class="line">static void * PersonNameContext = &amp;PersonNameContext;</span><br><span class="line"></span><br><span class="line">// 注册观察者</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;nick&quot; options:NSKeyValueObservingOptionNew context:PersonNickContext];</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:PersonNameContext];</span><br><span class="line">    </span><br><span class="line">// KVO回调</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    if (context == PersonNickContext) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;else if (context == PersonNameContext)&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// KVO移除</span><br><span class="line">[self.person removeObserver:self forKeyPath:@&quot;name&quot;];</span><br><span class="line">[self.person removeObserver:self forKeyPath:@&quot;nick&quot;];</span><br></pre></td></tr></table></figure><h2 id="移除KVO通知的必要性"><a href="#移除KVO通知的必要性" class="headerlink" title="移除KVO通知的必要性"></a>移除KVO通知的必要性</h2><p>在官方文档中，针对 <code>KVO移除</code> 有以下几点说明：</p><p><img src="https://user-images.githubusercontent.com/25925248/160746851-ed7e0343-880b-445c-8aff-0c4ab592de47.png"></p><p>删除观察者时，请记住以下几点：</p><ul><li><p>要求被移除为观察者（如果尚未注册为观察者）会导致 <code>NSRangeException</code>，您可以对 <code>removeObserver:forKeyPath:context:</code> 进行一次调用，以对应对 <code>addObserver:forKeyPath:option:context:</code> 的调用，或者如果在您的应用中不可行，则将 <code>removeObserver:forKeyPath:context:</code> 调用在 <code>try/catch块</code> 内处理潜在的异常</p></li><li><p><code>释放后，观察者不会自动将其自身移除</code>。被观察对象继续发送通知，而或略了观察者的状态。但是，与发送到已释放对象的任何其他消息一样，更改通知会触发内存访问异常。因此，您 <code>可以确保观察者在从内存中消失之前将自己移除</code></p></li><li><p>该协议无法询问对象是观察者还是被观察者。构造代码以避免发布相关的错误。一种典型的模式是在观察者初始化期间（例如，<code>在init或viewDidLoad中注册为观察者</code>），并在释放过程中（通常 <code>在dealloc中注销</code>），以确保成对和有序添加和删除观察者，并确保观察者在注册之前被取消注册，从内存中释放出来</p></li></ul><p>所以，总的来说，<code>KVO注册观察者和移除观察者时需要成对出现的</code>，如果 <code>只注册不移除</code>，<code>会出现类似野指针的崩溃（EXC_BAD_ACCESS）</code>，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/160746861-ac7dcc0b-5307-4cf7-bc71-45e0792c0dd3.jpg"></p><p>崩溃的原因是，由于 <code>第一次注册KVO观察者没有移除</code>，再次进入页面，会 <code>第二次注册KVO观察者</code>，导致 <code>KVO观察者的重复注册</code>，而且第一次的通知对象还在内存中，没有进行释放，此时接收到属性值变化的通知，会出现 <code>找不到原有的通知对象，只能找到现有的通知对象</code>，即第二次KVO注册的观察者，所以 <code>导致了类似野指针的崩溃</code>，即一直保持着一个 <code>野通知</code>，且一直在监听</p><p>注：这里的崩溃案例是通过 <code>单例对象</code> 实现（崩溃有很大的几率，不是每次必现），因为单例对象在内存是常驻的，针对一般的类对象，貌似不移除也是可以的，但是为了防止线上意外，建议还是移除比较好</p><h2 id="KVO的自动触发与手动触发"><a href="#KVO的自动触发与手动触发" class="headerlink" title="KVO的自动触发与手动触发"></a>KVO的自动触发与手动触发</h2><p>KVO观察者的 <code>开启和关闭</code> 有两种方式：<code>自动和手动</code></p><ul><li>自动开关，返回 <code>NO</code> 就是监听不到，返回 <code>YES</code> 表示监听</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 自动开关</span><br><span class="line">+ (BOOL) automaticallyNotifiesObserversForKey:(NSString *)key&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自动开关关闭的时候，可以通过 <code>手动开关监听</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 自动关闭时，手动开启</span><br><span class="line">- (void)setName:(NSString *)name&#123;</span><br><span class="line">    // 手动开关</span><br><span class="line">    [self willChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">    _name = name; // 父类的setter方法</span><br><span class="line">    [self didChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查看打印结果</span><br><span class="line">2022-03-09 10:27:56.006156+0800 KVO_Demo[4580:3263311] &#123;</span><br><span class="line">    kind = 1;</span><br><span class="line">    new = &quot;hello world&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用手动开关的好处就是你想监听就监听，不想监听关闭即可，比自动触发更方便灵活</p><h2 id="KVO观察：一对多"><a href="#KVO观察：一对多" class="headerlink" title="KVO观察：一对多"></a>KVO观察：一对多</h2><p>KVO观察中的 <code>一对多</code>，意思是通过 <code>注册一个KVO观察者</code>，可以 <code>监听多个属性的变化</code></p><p>以下载进度为例，比如目前有一个需求，需要根据 <code>总的下载量totalData</code> 和 <code>当前下载量currentData</code> 来计算 <code>当前的下载进度downloadProcess</code>，实现如下：</p><p><strong>【合二为一观察法】：</strong></p><ul><li>分别观察 <code>总的下载量totalData</code> 和 <code>当前下载量currentData</code> 两个属性，当其中一个发生变化 <code>计算当前下载量进度downloadProcess</code>，实现 <code>keyPathsForValueAffectingValueForKey</code> 方法，将两个观察合为一个观察，即 <code>观察当前下载进度currentProcess</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic,copy)NSString * name;</span><br><span class="line">@property (nonatomic,copy)NSString * nick;</span><br><span class="line">@property (nonatomic,assign)double totalData;</span><br><span class="line">@property (nonatomic,assign)double currentData;</span><br><span class="line">@property (nonatomic,copy)NSString * downloadProcess; // 下载进度</span><br><span class="line">@property (nonatomic,strong)NSMutableArray * mArr; // 可变数组</span><br><span class="line">+ (instancetype)shareInstance;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">+ (instancetype)shareInstance&#123;</span><br><span class="line">    static Person * person = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        person = [[Person alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -2.合二为一的观察法</span><br><span class="line">+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key&#123;</span><br><span class="line">    NSSet * keyPaths = [super keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    if ([key isEqualToString:@&quot;downloadProcess&quot;]) &#123;</span><br><span class="line">        NSArray * affectingKeys = @[@&quot;totalData&quot;,@&quot;currentData&quot;];</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    return keyPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>注册KVO观察者，当 <code>currentData改变</code> 时，计算 <code>当前下载进度downloadProcess</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 2.合二为一的观察法</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;downloadProcess&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br><span class="line">    </span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 2.合二为一的观察法</span><br><span class="line">    self.person.currentData += 1;</span><br><span class="line">    self.person.totalData = 100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -KVO回调</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    // 2.合二为一的观察法</span><br><span class="line">    Person * person = (Person *)object;</span><br><span class="line">    NSLog(@&quot;%f&quot;,person.currentData/person.totalData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -delloc</span><br><span class="line">-(void)dealloc&#123;    </span><br><span class="line">    // 2.合二为一的观察法</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;downloadProcess&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KVO观察可变数组"><a href="#KVO观察可变数组" class="headerlink" title="KVO观察可变数组"></a>KVO观察可变数组</h2><p><code>KVO</code> 是 <code>基于KVC</code> 基础 <code>之上</code> 的，所以 <code>可变数组</code> 如果 <code>直接添加数据</code>，是 <code>不会调用setter方法</code> 的，所有 <code>对可变数组的KVO观察</code> 下面这种方式 <code>是不生效</code> 的，即直接通过 <code>[self.person.mArr addObject:@&quot;1&quot;];</code> 像数组添加元素，是 <code>不会触发KVO</code> 通知回调的，如下代码是不会通知回调的：</p><ul><li><code>Person.h</code> 中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic,strong)NSMutableArray * mArr; // 可变数组</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li><code>DetailViewController.m</code> 中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 可变数组</span><br><span class="line">self.person.mArr = [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;mArr&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 可变数组</span><br><span class="line">    [self.person.mArr addObject:@&quot;1&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -KVO回调</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    // 可变数组</span><br><span class="line">    NSLog(@&quot;%@&quot;,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)dealloc&#123;</span><br><span class="line">    // 可变数组</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;mArr&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 KVC官方文档中，针对 <code>可变数组的集合</code> 类型，有如下说明，即访问集合对象需要通过 <code>mutableArrayValueForKey</code> 方法，这样才能 <code>将元素添加到可变数组中</code></p><p><img src="https://user-images.githubusercontent.com/25925248/160746894-fceaad2c-bd75-417a-b9a2-7937ead83d1f.png"></p><p>因此，需要将上面 <code>可变数组</code> 添加元素的方法，改为如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    // 可变数组</span><br><span class="line">    [[self.person mutableArrayValueForKey:@&quot;mArr&quot;] addObject:@&quot;1&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，可以看到，<code>元素被添加到可变数组了</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2022-03-09 10:11:24.697680+0800 KVO_Demo[4557:3255716] &#123;</span><br><span class="line">    indexes = &quot;&lt;_NSCachedIndexSet: 0x2826d91c0&gt;[number of indexes: 1 (in 1 ranges), indexes: (0)]&quot;;</span><br><span class="line">    kind = 2; // 插入</span><br><span class="line">    new =     (</span><br><span class="line">        1</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>kind</code> 表示 <code>键值变化的类型</code>，是一个枚举，主要有以下 <code>4</code> 种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, NSKeyValueChange) &#123;</span><br><span class="line">    NSKeyValueChangeSetting = 1,        // 设值</span><br><span class="line">    NSKeyValueChangeInsertion = 2,      // 插入</span><br><span class="line">    NSKeyValueChangeRemoval = 3,        // 移除</span><br><span class="line">    NSKeyValueChangeReplacement = 4,    // 替换</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般的 <code>属性</code> 与 <code>集合</code> 的KVO观察是由区别的，其 <code>kind不同</code>，以 <code>属性name</code> 和 <code>可变数组</code> 为例</p><ul><li><code>属性</code> 的 <code>kind</code> 一般是 <code>设值</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160746909-b6aff51a-7aee-48b7-aa13-ccd04482ac3c.jpg"></p><ul><li><code>可变数组</code> 的 <code>kind</code> 一般是 <code>插入</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160746915-1745aa00-450c-4ae7-9e1c-c767fbba828e.jpg"></p><h1 id="KVO的底层原理探索"><a href="#KVO的底层原理探索" class="headerlink" title="KVO的底层原理探索"></a>KVO的底层原理探索</h1><p>官方文档说明</p><p>在KVO的官方文档使用指南中，有如下说明</p><p><img src="https://user-images.githubusercontent.com/25925248/160746922-6b230564-1bc2-4a3a-839a-15abde252490.png"></p><ul><li><p><code>KVO</code> 是使用 <code>isa-swizzling</code> 的技术实现的</p></li><li><p>顾名思义，<code>isa指针指向维护分配表的对象的类</code>。该分配表实质上包含指向该类实现的方法的指针以及其他数据</p></li><li><p>当为对象的属性 <code>注册观察者时</code>，将 <code>修改</code> 观察者对象的 <code>isa指针</code>，指向中间类 <code>而不是真实类</code>。结果，<code>isa</code> 指针的值不一定反映实例的实际类</p></li><li><p>你不应该依靠isa指针来确定类的成员变量，相反，你应该 <code>使用class方法来确定对象实例的类</code></p></li></ul><h1 id="代码调式探索"><a href="#代码调式探索" class="headerlink" title="代码调式探索"></a>代码调式探索</h1><h2 id="KVO只对属性观察"><a href="#KVO只对属性观察" class="headerlink" title="KVO只对属性观察"></a>KVO只对属性观察</h2><p>在 <code>ZJPerson</code> 中有一个 <code>成员变量name</code> 和 <code>属性nick</code>，分别注册KVO观察者，触发属性变化时，会有什么现象？</p><ul><li>创建 <code>ZJPerson</code> 类，声明 <code>成员变量name</code> 和 <code>属性nick</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">    NSString * name;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic,copy)NSString * nick;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>分别为 <code>成员变量name</code> 和 <code>属性nick</code> 注册观察者</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = [UIColor orangeColor];</span><br><span class="line">    </span><br><span class="line">    self.person = [[ZJPerson alloc] init];</span><br><span class="line">    </span><br><span class="line">    [self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br><span class="line">    [self.person addObserver:self forKeyPath:@&quot;nick&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>KVO触发通知操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    self.person-&gt;name = @&quot;ZJ&quot;;</span><br><span class="line">    self.person.nick = @&quot;XJ&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>KVO接收通知操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2022-03-09 14:33:59.443356+0800 002--KVO原理探讨[4675:3328750] &#123;</span><br><span class="line">    kind = 1; </span><br><span class="line">    new = XJ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论</strong>：KVO对 <code>成员变量name不观察</code>，只对 <code>属性name观察</code>，属性和成员变量的区别在于 <code>属性多了一个setter方法</code>，而 <code>KVO恰好观察的是setter方法</code></p><h2 id="中间类"><a href="#中间类" class="headerlink" title="中间类"></a>中间类</h2><p>根据官方文档所述，在 <code>注册KVO观察者后，观察者对象的isa指针指向会发生改变</code></p><ul><li>注册观察者之前： <code>实例对象person</code> 的 <code>isa</code> 指针指向 <code>ZJPerson</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160746946-a965acac-9bed-432f-b9d9-6c14a22d17b5.jpg"></p><ul><li>注册观察者之后：<code>实例对象person</code> 的 <code>isa</code> 指针指向 <code>NSKVONotifing_ZJPerson</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160746974-2227abf4-5850-4b8f-a73c-64c2c1856eaa.jpg"></p><p>综上所述，在注册观察者后，<code>实例对象</code> 的 <code>isa</code> 指针 <code>指向</code> 由 <code>ZJPerson类</code> 变为了 <code>NSKVONotifying_ZJPerson中间类</code>，即实例对象的 <code>isa</code> 指针指向发生了变化</p><h2 id="判断中间类是否是-派生类-即-子类？"><a href="#判断中间类是否是-派生类-即-子类？" class="headerlink" title="判断中间类是否是 派生类 即 子类？"></a>判断中间类是否是 <code>派生类</code> 即 子类？</h2><p>那么这个动态生成的中间类 <code>NSKVONotifying_ZJPerson</code> 和 <code>ZJPerson</code> 有什么关系？下面通过代码来验证</p><p>可以通过下面封装的方法，获取ZJPerson的相关类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 添加KVO之前</span><br><span class="line">[self printClasses:[ZJPerson class]];</span><br><span class="line">    </span><br><span class="line">// 添加观察者</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;nick&quot; options:NSKeyValueObservingOptionNew context:NULL];</span><br><span class="line">    </span><br><span class="line">// 添加KVO之后</span><br><span class="line">[self printClasses:[ZJPerson class]];</span><br><span class="line"></span><br><span class="line">#pragma mark -遍历类以及子类</span><br><span class="line">- (void)printClasses:(Class)cls&#123;</span><br><span class="line">    // 注册类的总数</span><br><span class="line">    int count = objc_getClassList(NULL, 0);</span><br><span class="line">    // 创建一个数组， 其中包含给定对象</span><br><span class="line">    NSMutableArray * mArr = [NSMutableArray arrayWithObject:cls];</span><br><span class="line">    // 获取所有已注册的类</span><br><span class="line">    Class * classes = (Class*)malloc(sizeof(Class)*count);</span><br><span class="line">    objc_getClassList(classes, count);</span><br><span class="line">    for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">        if (cls == class_getSuperclass(classes[i])) &#123;</span><br><span class="line">            [mArr addObject:classes[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(classes);</span><br><span class="line">    NSLog(@&quot;classes = %@&quot;, mArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><p><img src="https://user-images.githubusercontent.com/25925248/160747000-ede43dee-9514-4387-aeb3-e73220fffaef.jpg"></p><p>从打印结果可以得出，<code>NSKVONotifying_ZJPerson</code> 是 <code>ZJPerson</code> 的子类</p><h2 id="中间类中有什么？"><a href="#中间类中有什么？" class="headerlink" title="中间类中有什么？"></a>中间类中有什么？</h2><p>可以通过下面的方法获取 <code>NSKVONotifying_ZJPerson</code> 类中的所有方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 遍历方法</span><br><span class="line">[self printClassAllMethod:objc_getClass(&quot;NSKVONotifying_ZJPerson&quot;)];</span><br><span class="line">    </span><br><span class="line">#pragma mark -遍历方法</span><br><span class="line">- (void)printClassAllMethod:(Class)cls&#123;</span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    // 获取一个类中的所有实例方法</span><br><span class="line">    Method * methodList = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">        // 获取单个方法</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        // 方法编号</span><br><span class="line">        SEL sel = method_getName(method);</span><br><span class="line">        // 方法实现</span><br><span class="line">        IMP imp = class_getMethodImplementation(cls, sel);</span><br><span class="line">        NSLog(@&quot;%@ - %p&quot;,NSStringFromSelector(sel),imp);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看打印结果</p><p><img src="https://user-images.githubusercontent.com/25925248/160747013-29f9e86f-4641-4f75-8d7a-4ec033f7c1d7.jpg"></p><p>从结果中可以看出有四个方法，分别是 <code>setNick、class、dealloc、_isKVOA</code>，这些方法是 <code>继承</code> 还是 <code>重写</code>？</p><ul><li>在 <code>ZJStudent(继承自ZJPerson)</code> 中重写 <code>setNick</code> 方法，获取 <code>ZJStudent</code> 类的所有方法</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160747029-cb6389e3-faae-4fb8-b248-67c4ce185378.jpg"></p><p><img src="https://user-images.githubusercontent.com/25925248/160747037-0c297291-98a3-4e8e-bff7-e84db481aafd.jpg"></p><p>由打印结果可知，如果是继承那么 <code>NSKVONotifying_ZJPerson</code> 打印的方法应该与 <code>ZJPerson</code> 打印的结果一致</p><ul><li>获取 <code>ZJPerson</code> 和 <code>NSKVONotifying_ZJPerson</code> 的方法列表进行对比</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160747047-7900c4b7-e62d-40a6-9811-ff63be5ca592.jpg"></p><p><strong>【结论】</strong> 综上所述，有如下结论：</p><ul><li><p><code>NSKVONotifying_ZJPerson</code> 中间类 <code>重写</code> 了 <code>父类ZJPerson</code> 的 <code>setNick</code> 方法</p></li><li><p><code>NSKVONotifying_ZJPerson</code> 中间类 <code>重写</code> 了 <code>基类NSObject</code> 的 <code>class、dealloc、_isKVOA</code> 方法</p><ul><li>其中 <code>dealloc</code> 是释放方法</li><li><code>_isKVOA</code> 判断当前是否是 <code>KVO类</code></li></ul></li></ul><h2 id="dealloc中移除观察者后，isa指向谁，以及中间类是否会销毁？"><a href="#dealloc中移除观察者后，isa指向谁，以及中间类是否会销毁？" class="headerlink" title="dealloc中移除观察者后，isa指向谁，以及中间类是否会销毁？"></a>dealloc中移除观察者后，isa指向谁，以及中间类是否会销毁？</h2><ul><li>移除观察者前：<code>实例对象的isa</code> 指向仍是 <code>NSKVONotifying_ZJPerson中间类</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160747072-cbfc301c-f0e9-448c-a502-999ab225df54.jpg"></p><ul><li>移除观察者之后：实例对象的isa指针指向更改为 <code>ZJPerson类</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160747086-afb0048f-be74-4a27-b1cf-c7f77d426307.jpg"></p><p>所以，在 <code>移除KVO观察者后</code>，<code>isa</code> 的指向由 <code>KSKVONotifying_ZJPerson</code> 变成了 <code>ZJPerson</code></p><h2 id="那么中间类从创建后，到dealloc方法中移除观察者之后，KSKVONotifying-ZJPerson-是否还存在？"><a href="#那么中间类从创建后，到dealloc方法中移除观察者之后，KSKVONotifying-ZJPerson-是否还存在？" class="headerlink" title="那么中间类从创建后，到dealloc方法中移除观察者之后，KSKVONotifying_ZJPerson 是否还存在？"></a>那么中间类从创建后，到dealloc方法中移除观察者之后，KSKVONotifying_ZJPerson 是否还存在？</h2><ul><li>在上一个界面打印 <code>ZJPerson</code> 的子类情况，用于判断中间类是否销毁</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160747103-6f0b7570-53a5-45f7-b76f-f2c7fceb7712.jpg"></p><p>通过子类的打印结果可以看出，中间类一旦生成，没有移除，没有销毁，还在内存中，主要是考虑 <code>重用</code> 的想法，即 <code>中间类注册到内存中，为了考虑后续的重用问题，所以中间类一直存在</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，关于 中间类，有如下说明：</p><ul><li><p><code>实例对象isa</code> 的指向 <code>在注册KVO观察者之后</code>，由 <code>原有类</code> 更改为 <code>中间类</code></p></li><li><p><code>中间类</code> 重写了观察 <code>属性setter方法、class、dealloc、_isKVOA</code> 方法</p></li><li><p><code>dealloc</code> 方法中，<code>移除KVO观察者之后</code>，<code>实例对象isa</code> 指向由 <code>中间类</code> 更改为 <code>原有类</code></p></li><li><p><code>中间类</code> 从创建后，就一直 <code>存在内存中</code>，<code>不会被销毁</code></p></li></ul><h1 id="自定义KVO"><a href="#自定义KVO" class="headerlink" title="自定义KVO"></a>自定义KVO</h1><p>自定义KVO的流程，只是在系统的基础上针对其部分做了一些优化处理。</p><ul><li>模拟系统</li><li>实现 <code>KVO自动销毁机制</code></li><li>将 <code>响应式和函数式</code> 整合</li></ul><p>在系统中，注册观察者和KVO响应属于 <code>响应式编程</code>，是分开写的，在自定义为了代码更好的协调，使用 <code>block</code> 的形式，将注册和回调的逻辑组合在一起，即采用 <code>函数式变成</code> 方式</p><p>那么如何实现自定义KVO呢？分为以下几个步骤：</p><ul><li>注册观察者</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 定义blcock</span><br><span class="line">typedef void(^ZJKVOBlock)(id observer,NSString * keyPath,id oldValue,id newValue);</span><br><span class="line"></span><br><span class="line">// 创建一个 NSObject+ZJKVO的分类，注册观察者</span><br><span class="line">@interface NSObject (ZJKVO)</span><br><span class="line">- (void)zj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath block:(ZJKVOBlock)block;</span><br><span class="line">- (void)zj_removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>KVO监听</li></ul><p>这部分主要是通过 <code>重写setter方法</code>，在中间类的setter方法中，通过 <code>block</code> 方式传递给外部进行响应</p><ul><li>移除观察者</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)zj_removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure><h2 id="注册观察者"><a href="#注册观察者" class="headerlink" title="注册观察者"></a>注册观察者</h2><p>在注册观察者步骤中，主要有以下几步操作：</p><ul><li>1、验证是否存在 <code>setter</code> 方法，目的是 <code>不让实例进来</code></li><li>2、动态生成子类，将需要重写的 <code>class</code> 方法添加到中间类中</li><li>3、 <code>isa</code> 指向原有类，改为 <code>指向中间类</code></li><li>4、 保存信息：这里用的是数组，也可以使用map，需要创建信息的 <code>model模型类</code></li></ul><p><strong>【注意】：</strong></p><p>关于 <code>objc_msgSend</code> 的检查关闭：<code>target -&gt; Build Setting -&gt; Enable Strict Checking of objc_msgsend Calls</code> 设置为 <code>NO</code></p><h2 id="KVO响应"><a href="#KVO响应" class="headerlink" title="KVO响应"></a>KVO响应</h2><ol><li><p>主要是给 <code>子类</code> 动态添加 <code>setter</code> 方法，其目的是为了在 <code>setter方法</code> 中向父类发送消息，告知其属性值的变化</p></li><li><p>通过系统的 <code>objc_msgSendSuper</code> 强制类型转换自定义的消息发送 <code>zj_msgSendSuper</code></p></li><li><p>告知vc去响应：获取信息，通过block传递</p></li></ol><h2 id="移除观察者"><a href="#移除观察者" class="headerlink" title="移除观察者"></a>移除观察者</h2><p>为了避免在外界不断的调用 <code>removeObserver</code> 方法，在自定义 <code>KVO</code> 中实现 <code>自动移除观察者</code></p><ul><li><p>1、实现 <code>zj_removeObserver:forKeyPath:</code> 方法，主要是清空数组，以及 <code>isa</code> 指向更改</p></li><li><p>2、在子类中重写 <code>dealloc</code> 方法，当子类销毁时，会自动调用dealloc方法（在动态生成子类的方法中添加）</p></li></ul><p>其主要原理是：<code>ZJPerson</code> 发送消息释放即 <code>dealloc</code> 了，就会自动走到重写的 <code>zj_dealloc</code> 方法中（原因是person对象的 <code>isa</code> 指向变了），指向中间类，但是实例对象的地址是不变的，所以子类的释放，相当于释放了外界的person，而重写的 <code>zj_dealloc</code> 相当于是 <code>重写了ZJPerson</code> 的 <code>dealloc</code> 方法，所以会走到 <code>zj_dealloc</code> 方法中，达到自动移除观察者的目的。</p><h2 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h2><ul><li><strong>【NSObject+ZJKVO.h】</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^ZJKVOBlock)(id observer,NSString *keyPath,id oldValue,id newValue);</span><br><span class="line"></span><br><span class="line">@interface NSObject (LGKVO)</span><br><span class="line">- (void)zj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath block:(LGKVOBlock)block;</span><br><span class="line">- (void)zj_removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li><strong>【NSObject+ZJKVO.m】</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSObject+ZJKVO.h&quot;</span><br><span class="line">#import &lt;objc/message.h&gt;</span><br><span class="line"></span><br><span class="line">static NSString *const kZJKVOPrefix = @&quot;ZJKVONotifying_&quot;;</span><br><span class="line">static NSString *const kZJKVOAssiociateKey = @&quot;kZJKVO_AssiociateKey&quot;;</span><br><span class="line"></span><br><span class="line">#*****信息model*****</span><br><span class="line">@interface ZJInfo : NSObject</span><br><span class="line">@property (nonatomic,weak)NSObject * observer;</span><br><span class="line">@property (nonatomic,copy)NSString * keyPath;</span><br><span class="line">@property (nonatomic,copy)ZJKVOBlock handleBlock;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJInfo</span><br><span class="line">- (instancetype)initWitObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath handleBlock:(ZJKVOBlock)block&#123;</span><br><span class="line">    if (self=[super init]) &#123;</span><br><span class="line">        _observer = observer;</span><br><span class="line">        _keyPath  = keyPath;</span><br><span class="line">        _handleBlock = block;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSObject (ZJKVO)</span><br><span class="line">- (void)zj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath block:(ZJKVOBlock)block&#123;</span><br><span class="line">    // 1.验证是否存在setter方法：不让实例进来</span><br><span class="line">    [self judgeSetterMethodFromKeyPath:keyPath];</span><br><span class="line">    // 2.动态生成子类</span><br><span class="line">    Class newClass = [self createChildClassWithKeyPath:keyPath];</span><br><span class="line">    // 3.isa的指向 : ZJKVONotifying_ZJPerson</span><br><span class="line">    object_setClass(self, newClass);</span><br><span class="line">    // 4.保存信息</span><br><span class="line">    ZJInfo * info = [[ZJInfo alloc] initWitObserver:observer forKeyPath:keyPath handleBlock:block];</span><br><span class="line">    NSMutableArray * mArray = objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kZJKVOAssiociateKey));</span><br><span class="line">    if (!mArray) &#123;</span><br><span class="line">        mArray = [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">        objc_setAssociatedObject(self, (__bridge const void * _Nonnull)(kZJKVOAssiociateKey), mArray, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    [mArray addObject:info];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -移除观察者</span><br><span class="line">- (void)zj_removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath&#123;</span><br><span class="line">    NSMutableArray *observerArr = objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kZJKVOAssiociateKey));</span><br><span class="line">    if (observerArr.count&lt;=0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (ZJInfo *info in observerArr) &#123;</span><br><span class="line">        if ([info.keyPath isEqualToString:keyPath]) &#123;</span><br><span class="line">            [observerArr removeObject:info];</span><br><span class="line">            objc_setAssociatedObject(self, (__bridge const void * _Nonnull)(kZJKVOAssiociateKey), observerArr, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (observerArr.count&lt;=0) &#123;</span><br><span class="line">        // 指回给父类</span><br><span class="line">        Class superClass = [self class];</span><br><span class="line">        object_setClass(self, superClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 验证是否存在setter方法</span><br><span class="line">- (void)judgeSetterMethodFromKeyPath:(NSString *)keyPath&#123;</span><br><span class="line">    Class superClass    = object_getClass(self); // 获取类Person</span><br><span class="line">    SEL setterSeletor   = NSSelectorFromString(setterForGetter(keyPath));</span><br><span class="line">    Method setterMethod = class_getInstanceMethod(superClass, setterSeletor);</span><br><span class="line">    if (!setterMethod) &#123;</span><br><span class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException reason:[NSString stringWithFormat:@&quot;老铁没有当前%@的setter&quot;,keyPath] userInfo:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -动态生成子类</span><br><span class="line">- (Class)createChildClassWithKeyPath:(NSString *)keyPath&#123;</span><br><span class="line">    // 获取原本的类名（Person）</span><br><span class="line">    NSString * oldClassName = NSStringFromClass([self class]);</span><br><span class="line">    // 拼接子类类名（ZJKVONotifying_Person）</span><br><span class="line">    NSString * newClassName = [NSString stringWithFormat:@&quot;%@%@&quot;,kZJKVOPrefix,oldClassName];</span><br><span class="line">    // 获取子类</span><br><span class="line">    Class newClass = NSClassFromString(newClassName);</span><br><span class="line">    // 防止重复创建生成新类</span><br><span class="line">    if (newClass) return newClass;</span><br><span class="line">    /**</span><br><span class="line">     * 如果内存不存在,创建生成</span><br><span class="line">     * 参数一: 父类</span><br><span class="line">     * 参数二: 新类的名字</span><br><span class="line">     * 参数三: 新类的开辟的额外空间</span><br><span class="line">     */</span><br><span class="line">    // 2.1 : 申请类（ZJKVONotifying_Person）</span><br><span class="line">    newClass = objc_allocateClassPair([self class], newClassName.UTF8String, 0);</span><br><span class="line">    </span><br><span class="line">    // 2.2 : 注册类</span><br><span class="line">    objc_registerClassPair(newClass);</span><br><span class="line">    </span><br><span class="line">    // 2.3.1 : 添加class : class的指向是ZJPerson</span><br><span class="line">    SEL classSEL = NSSelectorFromString(@&quot;class&quot;);</span><br><span class="line">    Method classMethod = class_getInstanceMethod([self class], classSEL);</span><br><span class="line">    const char *classTypes = method_getTypeEncoding(classMethod);</span><br><span class="line">    class_addMethod(newClass, classSEL, (IMP)zj_class, classTypes);</span><br><span class="line">    </span><br><span class="line">    // 2.3.2 : 添加setter</span><br><span class="line">    SEL setterSEL = NSSelectorFromString(setterForGetter(keyPath)); // 获取sel</span><br><span class="line">    Method setterMethod = class_getInstanceMethod([self class], setterSEL); // 获取setter实例方法</span><br><span class="line">    const char *setterTypes = method_getTypeEncoding(setterMethod); // 方法签名</span><br><span class="line">    class_addMethod(newClass, setterSEL, (IMP)zj_setter, setterTypes); // 添加一个setter方法</span><br><span class="line">    </span><br><span class="line">    // 2.3.3 : 添加dealloc</span><br><span class="line">    SEL deallocSEL = NSSelectorFromString(@&quot;dealloc&quot;);</span><br><span class="line">    Method deallocMethod = class_getInstanceMethod([self class], deallocSEL);</span><br><span class="line">    const char *deallocTypes = method_getTypeEncoding(deallocMethod);</span><br><span class="line">    class_addMethod(newClass, deallocSEL, (IMP)zj_dealloc, deallocTypes);</span><br><span class="line">    </span><br><span class="line">    return newClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -重写class方法，为了与系统类对外保持一致</span><br><span class="line">Class zj_class(id self,SEL _cmd)&#123;</span><br><span class="line">    return class_getSuperclass(object_getClass(self));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -添加setter方法</span><br><span class="line">static void zj_setter(id self,SEL _cmd,id newValue)&#123;</span><br><span class="line">    NSString *keyPath = getterForSetter(NSStringFromSelector(_cmd));</span><br><span class="line">    id oldValue = [self valueForKey:keyPath];</span><br><span class="line">    // 4: 消息转发 : 转发给父类</span><br><span class="line">    // 通过系统强制类型转换自定义objc_msgSendSuper</span><br><span class="line">    void (*zj_msgSendSuper)(void *,SEL , id) = (void *)objc_msgSendSuper;</span><br><span class="line">    // 定义一个结构体</span><br><span class="line">    struct objc_super superStruct = &#123;</span><br><span class="line">        .receiver = self, // 消息接收者为当前的self</span><br><span class="line">        .super_class = class_getSuperclass(object_getClass(self)), // 当第一次快捷查找的类为父类</span><br><span class="line">    &#125;;</span><br><span class="line">    // 调用自定义的放消息函数</span><br><span class="line">    zj_msgSendSuper(&amp;superStruct,_cmd,newValue);</span><br><span class="line">    </span><br><span class="line">    // 5: 信息数据回调</span><br><span class="line">    NSMutableArray *mArray = objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kZJKVOAssiociateKey));</span><br><span class="line">    for (ZJInfo *info in mArray) &#123;</span><br><span class="line">        if ([info.keyPath isEqualToString:keyPath] &amp;&amp; info.handleBlock) &#123;</span><br><span class="line">            info.handleBlock(info.observer, keyPath, oldValue, newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 从get方法获取set方法的名称 key -&gt; setKey:</span><br><span class="line">static NSString *setterForGetter(NSString *getter)&#123;</span><br><span class="line">    if (getter.length &lt;= 0) &#123; return nil;&#125;</span><br><span class="line">    NSString *firstString = [[getter substringToIndex:1] uppercaseString];</span><br><span class="line">    NSString *leaveString = [getter substringFromIndex:1];</span><br><span class="line">    </span><br><span class="line">    return [NSString stringWithFormat:@&quot;set%@%@:&quot;,firstString,leaveString];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 从set方法获取getter方法的名称 set&lt;Key&gt;:===&gt; key</span><br><span class="line">static NSString *getterForSetter(NSString *setter)&#123;</span><br><span class="line">    if (setter.length &lt;= 0 || ![setter hasPrefix:@&quot;set&quot;] || ![setter hasSuffix:@&quot;:&quot;]) &#123; return nil;&#125;</span><br><span class="line">    NSRange range = NSMakeRange(3, setter.length-4);</span><br><span class="line">    NSString *getter = [setter substringWithRange:range];</span><br><span class="line">    NSString *firstString = [[getter substringToIndex:1] lowercaseString];</span><br><span class="line">    </span><br><span class="line">    return  [getter stringByReplacingCharactersInRange:NSMakeRange(0, 1) withString:firstString];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -重写dealloc</span><br><span class="line">static void zj_dealloc(id self,SEL _cmd)&#123;</span><br><span class="line">    NSLog(@&quot;[%@ dealloc]&quot;,self);</span><br><span class="line">    Class superClass = [self class];</span><br><span class="line">    object_setClass(self, superClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>综上所述，自定义KVO大致分为一下几步：</p><ul><li><p>注册观察者 &amp; 响应</p><ul><li>验证是否存在 <code>setter</code> 方法</li><li>动态生成子类，需要重写 <code>class、setter</code> 方法</li><li>在子类的setter方法中向父类发消息，即 <code>自定义消息发送</code></li><li>isa原有类指向中间类</li><li>保存信息</li><li>让观察者 <code>响应</code></li></ul></li><li><p>移除观察者</p><ul><li>更改 <code>isa指向</code> 为原有类</li><li>重写子类的 <code>dealloc</code> 方法</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理22：KVC底层原理分析</title>
      <link href="/BboyZJ.github.io/2021/01/17/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8622%EF%BC%9AKVC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/BboyZJ.github.io/2021/01/17/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8622%EF%BC%9AKVC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>KVC</code> 的全称是 <code>Key-Value-Coding</code> ，翻译成中文是 <code>键值编码</code> ，键值编码是由<code>NSKeyValueCoding</code> 非正式协议启动的一种机制，<code>对象采用该协议来间接访问其属性</code>。既可以通过一个 <code>字符串Key来访问某个属性</code>。这种间接访问机制补充了实例变量及其相关的访问器方法所提供的直接访问。</p><h1 id="KVC相关API"><a href="#KVC相关API" class="headerlink" title="KVC相关API"></a>KVC相关API</h1><p><strong>常用方法</strong></p><p>主要有以下四种常用的方法：</p><ul><li>通过 <code>key</code> 设值&#x2F;取值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 通过key来取值</span><br><span class="line">- (nullable id)valueForKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">// 通过key来设值</span><br><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</span><br></pre></td></tr></table></figure><ul><li>通过 <code>keyPath</code>（即<code>路由</code>）设值&#x2F;取值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 通过keyPath来取值</span><br><span class="line">-(nullable id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line"></span><br><span class="line">// 通过keyPath来设值</span><br><span class="line">-(void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure><ul><li>其他方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认返回YES，表示如果没有找到Set&lt;Key&gt;方法的话，会按照_key，_iskey，key，iskey的顺序搜索成员，设置成NO就不这样搜索</span><br><span class="line">是否可以直接访问实例变量</span><br><span class="line">+(BOOL)accessInstanceVariablesDirectly;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KVC提供属性值正确性验证的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。</span><br><span class="line">- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回。</span><br><span class="line">- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果Key不存在，且KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常。</span><br><span class="line">- (nullable id)valueForUndefinedKey:(NSString *)key;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">和上一个方法一样，但这个方法是设值。</span><br><span class="line">- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果你在SetValue方法时面给Value传nil，则会调用这个方法</span><br><span class="line">- (void)setNilValueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入一组key,返回该组key对应的Value，再转成字典返回，用于将Model转到字典。</span><br><span class="line">- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;</span><br></pre></td></tr></table></figure><h1 id="KVC设值底层原理"><a href="#KVC设值底层原理" class="headerlink" title="KVC设值底层原理"></a>KVC设值底层原理</h1><p>在日常开发中，针对对象属性的赋值，一般有以下两种方式</p><ul><li>直接通过 <code>setter</code> 方法赋值</li><li>通过 <code>KVC键值编码</code> 的相关API赋值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZJPerson * person = [[ZJPerson alloc] init];</span><br><span class="line">// 1.一般setter方法</span><br><span class="line">person.name = @&quot;ZJ_哈哈&quot;;</span><br><span class="line">// 2.KVC方法</span><br><span class="line">[person setValue:@&quot;ZJ_嘻嘻&quot; forKey:@&quot;name&quot;];</span><br></pre></td></tr></table></figure><p>下面针对使用最多的KVC设值方法：<code>seValue:forKey</code>，来进行底层原理的探索</p><p>首先进入 <code>seValue:forKey</code> 的声明，发现是在 <code>Foundation</code> 框架中，而<code>Foundation</code> 框架是不开源的，有以下几种方式可以去探索底层：</p><ul><li>通过 <code>Hopper</code> 反汇编，查看伪代码</li><li>通过苹果 <code>官方文档</code></li><li><code>Github</code> 搜索是否有相关的demo</li></ul><p>在这里，我们通过 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1">Key-Value Coding Programming Guide</a> 苹果官方文档来研究，针对设值流程，有如下说明</p><p>当调用 <code>seValue:forKey</code> 设值属性 <code>value</code> 时，其底层的执行流程为：</p><ul><li><p><strong>【第一步】</strong> 首先查找是否有这三种 <code>setter</code> 方法，按照查找顺序为 <code>set&lt;Key&gt; 、_set&lt;Key&gt;、setIs&lt;Key&gt;</code></p><ul><li>如果 <code>有其中任意一个</code> setter方法，则 <code>直接设值属性的value</code>（注意：<code>key是指成功变量名，首字母的大小写需要符合KVC的命名规范</code>） </li><li>如果都 <code>没有</code> ，则进入 <strong>【第二步】</strong></li></ul></li><li><p><strong>【第二步】</strong> 如果没有第一步的三个简单的setter方法，则查找<code>accessInstanceVariablesDirectly</code> 是否返回 <code>YES</code></p><ul><li><p>如果返回 <code>YES</code>，则查找间接访问的实例变量进行赋值，查找顺序为：<code>_&lt;key&gt;、_is&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt;</code></p><ul><li>如果找到其中任意一个实例变量，则赋值</li><li>如果都没有，则进入 <strong>【第三步】</strong></li></ul></li><li><p>如果返回<code>NO</code>，则进入 <strong>【第三步】</strong></p></li></ul></li><li><p><strong>【第三步】</strong> 如果 <code>setter方法</code> 或者 <code>实例变量</code> 都没有找到，系统会执行该对象的<code>seValue:forUnderfinedKey:</code>方法，默认抛出<code>NSUnderfinedKeyException</code>类型的异常</p></li></ul><p>综上所述，KVC通过 <code>seValue:forKey</code> 方法设值的流程，以ZJPerson的对象person的属性name为例，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/126090941-c91a337c-21e4-432c-b027-35d4ef9a73f4.png"></p><h1 id="KVC取值底层原理"><a href="#KVC取值底层原理" class="headerlink" title="KVC取值底层原理"></a>KVC取值底层原理</h1><p>同样的，我们可以通过官方文档分析KVC取值的底层原理</p><p>当调用 <code>valueForKey</code> 时，其底层的执行流程如下：</p><ul><li><p><strong>【第一步】</strong> 首先查找 <code>getter</code> 方法，按照：<code>get&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt;、_&lt;key&gt;</code> 的方法顺序查找</p><ul><li>如果 <code>找到</code> ，则进入 <strong>【第五步】</strong> </li><li>如果 <code>没有找到</code> ，则进入 <strong>【第二步】</strong></li></ul></li><li><p><strong>【第二步】</strong> 如果第一步中的 <code>getter</code> 方法没有找到，KVC会查找：<code>countOf&lt;Key&gt;、objectIn&lt;Key&gt; AtIndex:、&lt;key&gt;AtIndex:</code></p><ul><li><p>如果找到 <code>countOf&lt;Key&gt;</code> 和其他两个中的一个，则会创建一个响应所有 <code>NSArray</code> 方法的 <code>集合代理对象</code>，并返回该对象，即 <code>NSKeyValueArray</code>，是<code>NSArray</code> 的子类。代理对象随后将接收到的所有 <code>NSArray</code> 消息转换为<code>countOf&lt;Key&gt;、objectIn&lt;Key&gt; AtIndex:、&lt;key&gt;AtIndex:</code> 消息的某种组合，用来创建键值编码对象。如果原始对象还实现了一个名为 <code>get&lt;Key&gt;：range：</code>之类的可选方法，则代理对象也将在适当时使用该方法（注意：方法名的命名规则要符合KVC的标准命名方法，包括方法签名。）</p></li><li><p>如果没有找到这三个访问数组，则继续进入 <strong>【第三步】</strong></p></li></ul></li><li><p><strong>【第三步】</strong> 如果没有找到上面的几种方法，则会同时查找 <code>countOf &lt;Key&gt;，enumeratorOf&lt;Key&gt;和memberOf&lt;Key&gt; </code>这三个方法</p><ul><li><p>如果这三个方法都找到，则会创建一个响应 <code>所有NSSet方法的集合代理对象</code> ，并返回<br>该对象，此代理对象随后将其收到的所有 <code>NSSet</code> 消息转换为 <code>countOf&lt;Key&gt;，enumeratorOf&lt;Key&gt;和memberOf&lt;Key&gt;：</code> 消息的某种组合，用于创建它的对象</p></li><li><p>如果还是没有找到，则进入 <strong>【第四步】</strong></p></li></ul></li><li><p><strong>【第四步】</strong>  如果还没有找到，检查类方法 <code>InstanceVariablesDirectly</code> 是否 <code>YES</code>，依次搜索 <code>_&lt;key&gt;，_is&lt;Key&gt;</code>，<code>&lt;key&gt;</code> 或 <code>is&lt;Key&gt;</code> 的实例变量</p><ul><li>如果搜到，<code>直接获取实例变量的值</code>，进入 <strong>【第五步】</strong></li></ul></li><li><p><strong>【第五步】</strong> 根据搜索到的属性值的类型，返回不同的结果</p><ul><li><p>如果是<code>对象指针</code>，则直接返回结果</p></li><li><p>如果是 <code>NSNumber支持</code> 的标量类型，则将其 <code>存储在NSNumber实例</code> 中并返回它</p></li><li><p>如果是是 <code>NSNumber不支持</code> 的标量类型，请 <code>转换为NSValue对象</code> 并返回该对象</p></li></ul></li><li><p><strong>【第六步】</strong> 如果上面5步的方法 <code>均失败</code>，系统会执行该对象的<code>valueForUndefinedKey:</code> 方法，默认抛出 <code>NSUndefinedKeyException</code> 类型的异常</p></li></ul><p>综上所述，<code>KVC通过 valueForKey:</code> 方法取值的流程以设值 <code>ZJPerson</code> 的对象person的属性 <code>name</code> 为例，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/126091940-46a9e40f-7ca7-4b71-8a81-2137826a1683.png"></p><h1 id="自定义KVC"><a href="#自定义KVC" class="headerlink" title="自定义KVC"></a>自定义KVC</h1><p>原理：通过给 <code>NSObject</code> 添加 <code>分类ZJKVC</code>，实现自定义的 <code>zj_setValue：forKey：</code> 和 <code>zj_valueForKey：</code> 方法，根据苹果官方文档提供的查找规则进行实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (ZJKVC)</span><br><span class="line">// 设值</span><br><span class="line">- (void)zj_setValue:(nullable id)value forKey:(NSString *)key;</span><br><span class="line">// 取值</span><br><span class="line">- (nullable id)zj_valueForKey:(NSString *)key;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h1 id="自定义KVC设值"><a href="#自定义KVC设值" class="headerlink" title="自定义KVC设值"></a>自定义KVC设值</h1><p>自定义KVC设值</p><ul><li><p>1、判断 <code>key非空</code></p></li><li><p>2、查找 <code>setter</code> 方法，顺序是：<code>setXXX、_setXXX、setIsXXX</code></p></li><li><p>3、判断是否响应 <code>accessInstanceVariablesDirectly</code> 方法，即间接访问实例变量</p><ul><li>返回 <code>YES</code>，继续下一步设值</li><li>返回 <code>NO</code>，则崩溃</li></ul></li><li><p>4、间接访问变量赋值（只会走一次），顺序是：<code>_key、_isKey、key、isKey</code></p><ul><li>定义一个手机实例变量的可变数组</li><li>通过<code>class_getInstanceVariable</code> 方法，获取响应的ivar</li><li>通过<code>object_setIvar</code>方法，对响应的ivar设值值</li></ul></li><li><p>5、如果找不到相关实例变量，则抛出异常</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSObject (ZJKVC)</span><br><span class="line">// 设值</span><br><span class="line">- (void)zj_setValue:(nullable id)value forKey:(NSString *)key&#123;</span><br><span class="line">    // 1.判断key是否存在</span><br><span class="line">    if (key == nil || key.length == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2.找setter方法，顺序是：setXXX、_setXXX、setIsXXX</span><br><span class="line">    NSString * Key = key.capitalizedString;</span><br><span class="line">    // key 要大写</span><br><span class="line">    NSString * setKey = [NSString stringWithFormat:@&quot;set%@:&quot;, Key];</span><br><span class="line">    NSString * _setKey = [NSString stringWithFormat:@&quot;_set%@:&quot;, Key];</span><br><span class="line">    NSString * setIsKey = [NSString stringWithFormat:@&quot;setIs%@:&quot;, Key];</span><br><span class="line">    </span><br><span class="line">    // 判断是否有方法</span><br><span class="line">    if ([self zj_performSelectorWithMethodName:setKey value:value]) &#123;</span><br><span class="line">        NSLog(@&quot;*************%@*************&quot;, setKey);</span><br><span class="line">        return;</span><br><span class="line">    &#125;else if ([self zj_performSelectorWithMethodName:_setKey value:value]) &#123;</span><br><span class="line">        NSLog(@&quot;*************%@*************&quot;, _setKey);</span><br><span class="line">        return;</span><br><span class="line">    &#125;if([self zj_performSelectorWithMethodName:setIsKey value:value])&#123;</span><br><span class="line">        NSLog(@&quot;*************%@*************&quot;, setIsKey);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 3、判断是否响应accessInstanceVariablesDirectly方法，即间接访问实例变量，返回YES，继续下一步设值，如果是NO，则崩溃</span><br><span class="line">    if (![self.class accessInstanceVariablesDirectly]) &#123;</span><br><span class="line">        @throw [NSException exceptionWithName:@&quot;ZJUnKnownKeyException&quot; reason:[NSString stringWithFormat:@&quot;***[%@ valueForUnderfinedKey:] this class is not key value coding-compliant for the key name.***&quot;] userInfo:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 4.间接访问变量赋值，顺序为：_key、_isKey、key、isKey</span><br><span class="line">    // 4.1 定义一个手机实例变量的可变数组</span><br><span class="line">    NSMutableArray * mArray = [self getIvarListName];</span><br><span class="line">    // _key、_isKey、key、isKey</span><br><span class="line">    NSString * _key = [NSString stringWithFormat:@&quot;_%@:&quot;, Key];</span><br><span class="line">    NSString * _isKey = [NSString stringWithFormat:@&quot;_is%@:&quot;, Key];</span><br><span class="line">    NSString * isKey = [NSString stringWithFormat:@&quot;is%@:&quot;, Key];</span><br><span class="line">    if ([mArray containsObject:_key]) &#123;</span><br><span class="line">        // 4.2 获取响应的 ivar</span><br><span class="line">        Ivar ivar = class_getInstanceVariable([self class], _key.UTF8String);</span><br><span class="line">        // 4.3 对相应的 ivar 设值值</span><br><span class="line">        object_setIvar(self, ivar, value);</span><br><span class="line">        return;</span><br><span class="line">    &#125;else if ([mArray containsObject:_isKey]) &#123;</span><br><span class="line">        Ivar ivar = class_getInstanceVariable([self class], _isKey.UTF8String);</span><br><span class="line">        object_setIvar(self, ivar, value);</span><br><span class="line">        return;</span><br><span class="line">    &#125;else if ([mArray containsObject:key]) &#123;</span><br><span class="line">        Ivar ivar = class_getInstanceVariable([self class], key.UTF8String);</span><br><span class="line">        object_setIvar(self, ivar, value);</span><br><span class="line">        return;</span><br><span class="line">    &#125;else if ([mArray containsObject:isKey]) &#123;</span><br><span class="line">        Ivar ivar = class_getInstanceVariable([self class], isKey.UTF8String);</span><br><span class="line">        object_setIvar(self, ivar, value);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 5.如果找不到则抛出异常</span><br><span class="line">    @throw [NSException exceptionWithName:@&quot;ZJUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ %@]: this class is not key value coding-compliant for the key name.****&quot;,self,NSStringFromSelector(_cmd)] userInfo:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>相关方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 相关方法</span><br><span class="line">- (BOOL)zj_performSelectorWithMethodName:(NSString *)methodName value:(id)value&#123;</span><br><span class="line">    if ([self respondsToSelector:NSSelectorFromString(methodName)]) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">        // 如果你确定不会发生内存泄漏的情况下，可以使用如下的语句来忽略掉这条警告</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">        [self performSelector:NSSelectorFromString(methodName) withObject:value];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)performSelectorWithMethodName:(NSString *)methodName&#123;</span><br><span class="line">    if ([self respondsToSelector:NSSelectorFromString(methodName)]) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">        // 如果你确定不会发生内存泄漏的情况下，可以使用如下的语句来忽略掉这条警告</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">        return [self performSelector:NSSelectorFromString(methodName) ];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>获取成员变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -获取成员变量名</span><br><span class="line">- (NSMutableArray *)getIvarListName&#123;</span><br><span class="line">    // 创建可变数组，用于存储ivar成员变量</span><br><span class="line">    NSMutableArray * mArray = [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    // 获取类的成员变量列表</span><br><span class="line">    Ivar * ivars = class_copyIvarList([self class], &amp;count);</span><br><span class="line">    // 遍历成员变量列表</span><br><span class="line">    for (int i = 0; i&lt;count; i++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        // 获取成员变量名字字符</span><br><span class="line">        const char * ivarNameChar = ivar_getName(ivar);</span><br><span class="line">        // 将字符转换成字符串</span><br><span class="line">        NSString * ivarName = [NSString stringWithUTF8String:ivarNameChar];</span><br><span class="line">        NSLog(@&quot;ivarName == %@&quot;, ivarName);</span><br><span class="line">        // 存入可变数组</span><br><span class="line">        [mArray addObject:ivarName];</span><br><span class="line">    &#125;</span><br><span class="line">    //释放成员变量列表</span><br><span class="line">    free(ivars);</span><br><span class="line">    return mArray;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="自定义KVC取值"><a href="#自定义KVC取值" class="headerlink" title="自定义KVC取值"></a>自定义KVC取值</h1><ul><li><p>1、判断 <code>key非空</code></p></li><li><p>2、查找相应方法，顺序是 <code>get&lt;Key&gt;、&lt;key&gt;、countOf&lt;Key&gt;、objectIn&lt;Key&gt;AtIndex</code></p></li><li><p>3、判断是否能够直接赋值实例变量，即判断是否响应 <code>accessInstanceVariablesDirectly</code> 方法，间接访问实例变量</p><ul><li>返回 <code>YES</code>，继续下一步取值</li><li>返回 <code>NO</code>，则崩溃</li></ul></li><li><p>4、间接访问实例变量，顺序是 <code>_&lt;key&gt;、_is&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt;</code></p><ul><li>定义一个手机实例变量的<code>可变数组</code></li><li>通过<code>class_getInstanceVariable</code>方法，获取相应的ivar</li><li>通过<code>object_getIvar</code>方法，返回相应的ivar的值</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -取值</span><br><span class="line">- (nullable id)zj_valueForKey:(NSString *)key&#123;</span><br><span class="line">    </span><br><span class="line">    // 1、判断非空</span><br><span class="line">    if (key == nil || key.length == 0) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2、找到相关方法：get&lt;Key&gt;、&lt;key&gt;、countOf&lt;Key&gt; 、objectIn&lt;Key&gt;AtIndex</span><br><span class="line">    // key 要大写</span><br><span class="line">    NSString * Key = key.capitalizedString;</span><br><span class="line">    // 拼接方法</span><br><span class="line">    NSString * getKey = [NSString stringWithFormat:@&quot;get%@&quot;,Key];</span><br><span class="line">    NSString * countOfKey = [NSString stringWithFormat:@&quot;countOf%@&quot;,Key];</span><br><span class="line">    NSString * objectInKeyAtIndex = [NSString stringWithFormat:@&quot;objectIn%@AtIndex:&quot;,Key];</span><br><span class="line"></span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">    if ([self respondsToSelector:NSSelectorFromString(getKey)]) &#123;</span><br><span class="line">        return [self performSelector:NSSelectorFromString(getKey)];</span><br><span class="line">    &#125;else if ([self respondsToSelector:NSSelectorFromString(key)])&#123;</span><br><span class="line">        return [self performSelector:NSSelectorFromString(key)];</span><br><span class="line">    &#125;</span><br><span class="line">    // 集合类型</span><br><span class="line">    else if ([self respondsToSelector:NSSelectorFromString(countOfKey)])&#123;</span><br><span class="line">        if ([self respondsToSelector:NSSelectorFromString(objectInKeyAtIndex)]) &#123;</span><br><span class="line">            int num = (int)[self performSelector:NSSelectorFromString(countOfKey)];</span><br><span class="line">            NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">            for (int i = 0; i&lt;num-1; i++) &#123;</span><br><span class="line">                num = (int)[self performSelector:NSSelectorFromString(countOfKey)];</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = 0; j&lt;num; j++) &#123;</span><br><span class="line">                id objc = [self performSelector:NSSelectorFromString(objectInKeyAtIndex) withObject:@(num)];</span><br><span class="line">                [mArray addObject:objc];</span><br><span class="line">            &#125;</span><br><span class="line">            return mArray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    </span><br><span class="line">    // 3、判断是否响应`accessInstanceVariablesDirectly`方法，即间接访问实例变量，返回YES，继续下一步设值，如果是NO，则崩溃</span><br><span class="line">    if (![self.class accessInstanceVariablesDirectly]) &#123;</span><br><span class="line">        @throw [NSException exceptionWithName:@&quot;ZJLUnKnownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ valueForUndefinedKey:]: this class is not key value coding-compliant for the key name.****&quot;,self] userInfo:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 4.找相关实例变量进行赋值，顺序为：_&lt;key&gt;、 _is&lt;Key&gt;、 &lt;key&gt;、 is&lt;Key&gt;</span><br><span class="line">    // 4.1 定义一个收集实例变量的可变数组</span><br><span class="line">    NSMutableArray *mArray = [self getIvarListName];</span><br><span class="line">    // 例如：_name -&gt; _isName -&gt; name -&gt; isName</span><br><span class="line">    NSString * _key = [NSString stringWithFormat:@&quot;_%@&quot;,key];</span><br><span class="line">    NSString * _isKey = [NSString stringWithFormat:@&quot;_is%@&quot;,Key];</span><br><span class="line">    NSString * isKey = [NSString stringWithFormat:@&quot;is%@&quot;,Key];</span><br><span class="line">    if ([mArray containsObject:_key]) &#123;</span><br><span class="line">        Ivar ivar = class_getInstanceVariable([self class], _key.UTF8String);</span><br><span class="line">        return object_getIvar(self, ivar);;</span><br><span class="line">    &#125;else if ([mArray containsObject:_isKey]) &#123;</span><br><span class="line">        Ivar ivar = class_getInstanceVariable([self class], _isKey.UTF8String);</span><br><span class="line">        return object_getIvar(self, ivar);;</span><br><span class="line">    &#125;else if ([mArray containsObject:key]) &#123;</span><br><span class="line">        Ivar ivar = class_getInstanceVariable([self class], key.UTF8String);</span><br><span class="line">        return object_getIvar(self, ivar);;</span><br><span class="line">    &#125;else if ([mArray containsObject:isKey]) &#123;</span><br><span class="line">        Ivar ivar = class_getInstanceVariable([self class], isKey.UTF8String);</span><br><span class="line">        return object_getIvar(self, ivar);;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return @&quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="使用路由访问，即keyPath"><a href="#使用路由访问，即keyPath" class="headerlink" title="使用路由访问，即keyPath"></a>使用路由访问，即keyPath</h1><p>在日常开发中，一个类的成员变量有可能是自定义类或者其他的复杂数据类型，一般的操作是，我们可以先通过KVC获取该属性，然后再通过KVC获取自定义类的属性，就是比较麻烦，还有另一种比较简单的方法，就是使用 <code>KeyPath</code> 即路由，涉及一下两个方法： <code>setValue:forKeyPath:</code> 和 <code>valueForKeyPath:</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通过KeyPath来设值</span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br><span class="line">// 通过KeyPath来取值</span><br><span class="line">- (nullable id)valueForKeyPath:(NSString *)kePath;</span><br></pre></td></tr></table></figure><p>参考如下的案例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// ZJPerson类</span><br><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">@property (nonatomic, copy)   NSString          *age;</span><br><span class="line">@property (nonatomic, strong) ZJStudent         *student;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// ZJStudent类</span><br><span class="line">@interface ZJStudent : NSObject</span><br><span class="line">@property (nonatomic, copy)   NSString          *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        ZJPerson *person = [[ZJPerson alloc] init];</span><br><span class="line">        ZJStudent *student = [ZJStudent alloc];</span><br><span class="line">        student.name    = @&quot;ZJ&quot;;</span><br><span class="line">        person.student     = student;</span><br><span class="line">        //根据kvc - keyPath路由修改student的subject属性的值</span><br><span class="line">        [person setValue:@&quot;嘻嘻&quot; forKeyPath:@&quot;student.name&quot;];</span><br><span class="line">        NSLog(@&quot;%@&quot;,[person valueForKeyPath:@&quot;student.name&quot;]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//*************打印结果*************</span><br><span class="line">2021-5-27 09:55:08.512833+0800 001-KVC简介[58089:6301894] 改变前：ZJ</span><br><span class="line">2021-5-27 09:55:08.512929+0800 001-KVC简介[58089:6301894] 改变后：嘻嘻</span><br></pre></td></tr></table></figure><h1 id="KVC的使用场景"><a href="#KVC的使用场景" class="headerlink" title="KVC的使用场景"></a>KVC的使用场景</h1><ul><li><p>1、动态设值和取值</p><ul><li><p>常用的可以通过 <code>setValue:forKey:</code> 和 <code>valueForKey:</code></p></li><li><p>也可以通过路由的方式 <code>setValue:forKeyPath:</code> 和 <code>valueForKeyPath:</code></p></li></ul></li><li><p>2、通过KVC访问和修改私有变量</p></li></ul><p>在日常开发中，对于类的私有属性，在外部定义的对象，是 <code>无法直接访问私有属性的</code>，但是对于KVC而言，一个对象没有自己的隐私，所以可以 <code>通过KVC修改和访问任何私有属性</code></p><ul><li>3、多值操作（model和字典互转）</li></ul><p>model和字典的转换可以通过下面两个KVC的API实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 字典转模型</span><br><span class="line">- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *, id&gt; *)keyedValues;</span><br><span class="line"></span><br><span class="line">// 模型转字典</span><br><span class="line">- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>4、修改一些系统空间的内部属性</li></ul><p>在日常开发中，我们知道，很多UI控件都是在其内部由多个UI空间组合而成，这些内部控件苹果并没有提供访问的API，但是使用KVC可以解决这个问题，常用的就是 <code>自定义tabbar、个性化UITextField中的placeHolderText</code></p><ul><li>5、用KVC实现高阶消息传递</li></ul><p>在对容器类使用KVC时，<code>valueForKey:</code> 将会被传递给容器中的每一个对象，而不是对容器本身进行操作，结果会被添加到返回的容器中，这样，可以很方便的操作集合 <code>来返回</code> 另一个集合</p><p>如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// KVC实现高阶消息传递</span><br><span class="line">- (void)transmitMsg&#123;</span><br><span class="line">    NSArray *arrStr = @[@&quot;english&quot;, @&quot;franch&quot;, @&quot;chinese&quot;];</span><br><span class="line">    NSArray *arrCapStr = [arrStr valueForKey:@&quot;capitalizedString&quot;];</span><br><span class="line">    </span><br><span class="line">    for (NSString *str in arrCapStr) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSArray *arrCapStrLength = [arrCapStr valueForKeyPath:@&quot;capitalizedString.length&quot;];</span><br><span class="line">    for (NSNumber *length in arrCapStrLength) &#123;</span><br><span class="line">        NSLog(@&quot;%ld&quot;, (long)length.integerValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//********打印结果********</span><br><span class="line">2021-5-27 11:33:43.377672+0800 CJLCustom[60035:6380757] English</span><br><span class="line">2021-5-27 11:33:43.377773+0800 CJLCustom[60035:6380757] Franch</span><br><span class="line">2021-5-27 11:33:43.377860+0800 CJLCustom[60035:6380757] Chinese</span><br><span class="line">2021-5-27 11:33:43.378233+0800 CJLCustom[60035:6380757] 7</span><br><span class="line">2021-5-27 11:33:43.378327+0800 CJLCustom[60035:6380757] 6</span><br><span class="line">2021-5-27 11:33:43.378417+0800 CJLCustom[60035:6380757] 7</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理21：Method-Swizzling方法交换</title>
      <link href="/BboyZJ.github.io/2021/01/10/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8621%EF%BC%9AMethod-Swizzling%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2/"/>
      <url>/BboyZJ.github.io/2021/01/10/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8621%EF%BC%9AMethod-Swizzling%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="method-swizzling-是什么？"><a href="#method-swizzling-是什么？" class="headerlink" title="method-swizzling 是什么？"></a>method-swizzling 是什么？</h1><ul><li><p><code>method-swizzling</code> 的含义是 <code>方法交换</code>，其主要作用是 在<code>运行时将一个方法的实现替换成另一个方法的实现</code>，这就是我们常说的 <code>iOS黑魔法</code></p></li><li><p>在OC中就是 <code>利用method-swizzling实现AOP</code>，其中 <code>AOP</code>(Aspect Oriented Programing，面向切面编程），区别于 <code>OOP</code>（面向对象编程）</p><ul><li><code>OOP</code>和<code>AOP</code>都是一种编程的思想</li><li><code>OOP</code>编程思想更加倾向于对业务模块的封装，划分出更加清晰的逻辑单元</li><li>而<code>AOP</code>是面向切面进行提取封装，提取各个模块中的公共部分，提高模块的复用率，降低业务之间的耦合性</li></ul></li><li><p><code>每个类</code> 都维护者一个 <code>方法列表</code>，即<code> method_list</code>,<code>method_list</code> 中有不同的 <code>方法 </code>即 <code>Method</code>，每个方法中包含了方法的 <code>sel</code> 和 <code>IMP</code>，方法交换就是 <code>将sel和IMP原本的对应断开，并将sel和新的IMP生成对应关系</code></p></li></ul><p>如下图所示，交换前后的 <code>sel</code> 和 <code>IMP</code> 的对应关系：</p><p><img src="/BboyZJ.github.io/assets/16472369628918.jpg"></p><h1 id="method-swizzling-涉及的相关API"><a href="#method-swizzling-涉及的相关API" class="headerlink" title="method-swizzling 涉及的相关API"></a>method-swizzling 涉及的相关API</h1><ul><li><p>通过 <code>sel</code> 获取方法 <code>Method</code></p><ul><li><code>class_getInstanceMethod</code>：获取实例方法</li><li><code>class_getClassMethod</code>：获取类方法</li></ul></li><li><p><code>method_getImplementation</code>：获取一个方法的实现</p></li><li><p><code>method_setImplementation</code>：设置一个方法的实现</p></li><li><p><code>method_getTypeEncoding</code>：获取方法实现的编码类型</p></li><li><p><code>class_addMethod</code>：添加方法实现</p></li><li><p><code>class_replaceMethod</code>：用一个方法的实现，替换另一个方法的实现，即 <code>aIMP</code> 指向 <code>bIMP</code>，但是 <code>bIMP</code> 不一定指向 <code>aIMP</code></p></li><li><p><code>method_exchangeImplementations</code>：交换两个方法的实现，即 <code>aIMP -&gt; bIMP</code>，<code>bIMP -&gt; aIMP</code></p></li></ul><h1 id="坑点1：method-swizzling-使用过程中一次性的问题"><a href="#坑点1：method-swizzling-使用过程中一次性的问题" class="headerlink" title="坑点1：method-swizzling 使用过程中一次性的问题"></a>坑点1：method-swizzling 使用过程中一次性的问题</h1><p>所谓的一次性就是：<code>method-swizzling</code> 写在 <code>load</code> 方法中，而 <code>load</code> 方法会主动调用多次，这样会 <code>导致方法的重复交换</code>，使方法 <code>sel</code> 的指向又恢复成原来的 <code>imp</code> 的问题</p><p><strong>【解决方案】</strong></p><p>可以通过 <code>单例设计</code> 原则，使方法交换 <code>只执行一次</code>，在 <code>OC</code> 中可以通过 <code>dispatch_once</code> 实现单例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        [ZJRuntimeTool zj_methodSwizzlingWithClass:self oriSEL:@selector(helloworld) swizzledSEL:@selector(sayHello)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="坑点2：子类没有实现，父类实现了"><a href="#坑点2：子类没有实现，父类实现了" class="headerlink" title="坑点2：子类没有实现，父类实现了"></a>坑点2：子类没有实现，父类实现了</h1><p>在下面的这段代码中，<code>ZJPerson</code> 中实现了 <code>personInstanceMethod</code>，而 <code>ZJStudent</code> 继承自 <code>ZJPerson</code>，没有实现 <code>personInstanceMethod</code>，运行下面的这段代码会出现什么问题？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// ***ZJPerson类****</span><br><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">- (void)personInstanceMethod;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJPerson</span><br><span class="line">- (void)personInstanceMethod&#123;</span><br><span class="line">    NSLog(@&quot;person对象方法:%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// ******ZJStudent类******</span><br><span class="line">@interface ZJStudent : ZJPerson</span><br><span class="line">- (void)helloword;</span><br><span class="line">+ (void)sayHello;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJStudent</span><br><span class="line">- (void)helloword&#123;</span><br><span class="line">    NSLog(@&quot;student对象方法:%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)sayHello&#123;</span><br><span class="line">    NSLog(@&quot;student类方法:%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//*****VC****</span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    // 黑魔法坑点二：子类没有实现 - 父类实现</span><br><span class="line">    ZJStudent * student = [[ZJStudent alloc] init];</span><br><span class="line">    [student personInstanceMethod];</span><br><span class="line">    </span><br><span class="line">    ZJPerson * person = [[ZJPerson alloc] init];</span><br><span class="line">    [person personInstanceMethod];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>其中，方法交换代码如下，是通过 <code>ZJStudent</code> 的分类 <code>ZJ</code> 实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// ****ZJStudent+ZJ分类*****</span><br><span class="line">@interface ZJStudent (ZJ)</span><br><span class="line">@end</span><br><span class="line">@implementation ZJStudent (ZJ)</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        [ZJRuntimeTool zj_methodSwizzlingWithClass:self oriSEL:@selector(personInstanceMethod) swizzledSEL:@selector(zj_studentInstanceMethod)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// personInstanceMethod 我需要父类的这个方法的一些东西</span><br><span class="line">// 给你加一个personInstanceMethod 方法</span><br><span class="line">// imp</span><br><span class="line">- (void)zj_studentInstanceMethod&#123;</span><br><span class="line">    // 是否会产生递归？ 不会产生递归，原因是zj_studentInstanceMethod 会走 oriIMP,即personInstanceMethod的实现中去</span><br><span class="line">    [self zj_studentInstanceMethod];</span><br><span class="line">    NSLog(@&quot;ZJStudent分类添加的zj对象方法：%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>下面是封装好的 <code>method-swizzling</code> 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJRuntimeTool : NSObject</span><br><span class="line">+ (void)zj_methodSwizzlingWithClass:(Class)cls oriSEL:(SEL)oriSEL swizzledSEL:(SEL)swizzledSEL;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJRuntimeTool</span><br><span class="line">+ (void)zj_methodSwizzlingWithClass:(Class)cls oriSEL:(SEL)oriSEL swizzledSEL:(SEL)swizzledSEL&#123;</span><br><span class="line">    if (!cls) &#123;</span><br><span class="line">        NSLog(@&quot;传入的交换类不能为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Method oriMethod = class_getInstanceMethod(cls, oriSEL);</span><br><span class="line">    Method swiMethod = class_getInstanceMethod(cls, swizzledSEL);</span><br><span class="line">    method_exchangeImplementations(oriMethod, swiMethod);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>通过实际代码的调试，发现会在p调用 <code>personInstanceMethod</code> 方法时崩溃，下面来进行详细说明</p><p><img src="/BboyZJ.github.io/assets/16472399389818.jpg"></p><ul><li><p><code>[student personInstanceMethod];</code> 中不报错是因为 <code>student</code> 中的 <code>imp</code> 交换成了 <code>zj_studentInstanceMethod</code>，而 <code>ZJStudent</code> 中有这个方法（在ZJ分类中），所以不会报错</p></li><li><p>崩溃的点在于 <code>[person personInstanceMethod];</code>，其本质原因：<code>ZJStudent</code> 的<code>分类ZJ</code> 中进行了方法交换，将 <code>person</code> 中的 <code>IMP</code> 交换成了 <code>ZJStudent</code> 中的 <code>zj_studentInstanceMethod</code>，但是 <code>ZJPerson</code> 中没有 <code>zj_studentInstanceMethod</code>方法，即 <code>相关的IMP找不到</code>，所以就崩溃了</p></li></ul><p><strong>【优化：避免imp找不到】</strong></p><p>通过 <code>class_addMethod</code> 尝试添加你要交换的方法</p><ul><li><p>如果 <code>添加成功</code>，即类中没有这个方法，则通过 <code>class_replaceMethod</code> 进行 <code>替换</code>，其内部会调用 <code>class_addMethod</code> 进行添加</p></li><li><p>如果添加不成功，即类中有这个方法，则通过 <code>method_exchangeImplementations</code> 进行 <code>交换</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (void)zj_methodSwizzlingWithClass:(Class)cls oriSEL:(SEL)oriSEL swizzledSEL:(SEL)swizzledSEL&#123;</span><br><span class="line">    if (!cls) &#123;</span><br><span class="line">        NSLog(@&quot;传入的交换类不能为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Method oriMethod = class_getInstanceMethod(cls, oriSEL);</span><br><span class="line">    Method swiMethod = class_getInstanceMethod(cls, swizzledSEL);</span><br><span class="line">    </span><br><span class="line">    // 一般交换方法：交换自己有的方法</span><br><span class="line">    // 交换自己没有实现的方法：</span><br><span class="line">    // 首先：会先尝试给自己添加要交换的方法 - personInstanceMethod(SEL) -&gt; swiMethod(IMP)</span><br><span class="line">    // 然后再将父类的IMP给swizzle personInstanceMethod(IMP) -&gt; swizzledSEL</span><br><span class="line">    BOOL success = class_addMethod(cls, oriSEL, method_getImplementation(swiMethod), method_getTypeEncoding(oriMethod));</span><br><span class="line">    </span><br><span class="line">    if (success) &#123; // 自己没有 - 交换 - 没有父类进行处理（重写一个）</span><br><span class="line">        class_replaceMethod(cls, swizzledSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</span><br><span class="line">    &#125;else &#123; // 自己有</span><br><span class="line">        method_exchangeImplementations(oriMethod, swiMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 <code>class_replaceMethod、class_addMethod、method_exchangeImplementations</code> 的源码实现</p><p><img src="/BboyZJ.github.io/assets/16472413416660.jpg"></p><p><img src="/BboyZJ.github.io/assets/16472413793468.jpg"></p><p><img src="/BboyZJ.github.io/assets/16472412742988.jpg"></p><p>其中 <code>class_replaceMethod</code> 和 <code>class_addMethod</code> 中都调用了 <code>addMethod</code> 方法，区别在于 <code>bool</code> 值的判断，下面是 <code>addMethod</code> 的源码实现。</p><p><img src="/BboyZJ.github.io/assets/16472416423445.jpg"></p><h1 id="坑点3：子类没有实现，父类也没有实现，下面的调用有什么问题？"><a href="#坑点3：子类没有实现，父类也没有实现，下面的调用有什么问题？" class="headerlink" title="坑点3：子类没有实现，父类也没有实现，下面的调用有什么问题？"></a>坑点3：子类没有实现，父类也没有实现，下面的调用有什么问题？</h1><p>在调用 <code>personInstanceMethod</code> 方法时，父类 <code>ZJPerson</code> 中只有声明，没有实现，子类 <code>ZJStudent</code> 中即没有声明，也没有实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将父类 ZJPerson 实现注释</span><br><span class="line">@implementation ZJPerson</span><br><span class="line">//- (void)personInstanceMethod&#123;</span><br><span class="line">//    NSLog(@&quot;person对象方法:%s&quot;,__func__);</span><br><span class="line">//&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>经过调试，发现运行代码会崩溃，报错结果如下所示：</p><p><img src="/BboyZJ.github.io/assets/16472419365115.jpg"></p><p>原因是：<code>栈溢出，递归死循环</code>，那么为什么会发生递归呢？</p><p>主要是因为 <code>personInstanceMethod</code> 没有实现，然后在方法交换后，始终找不到 <code>oriMethod</code>，然后交换了个寂寞，即交换失败，当我们调用 <code>personInstanceMethod(oriMethod)</code>时，也就是 <code>oriMethod</code> 会进入 <code>ZJ</code> 中 <code>zj_studentInstanceMethod</code> 方法，然后这个方法中又调用了 <code>zj_studentInstanceMethod</code>，此时的 <code>zj_studentInstanceMethod</code> 并没有指向 <code>oriMethod</code>，然后导致了 <code>自己调自己</code>，即递归死循环</p><p><strong>【优化：避免递归死循环】</strong></p><ul><li><p>如果 <code>oriMethod</code> 为空，为了避免方法交换没有意义，而被废弃，需要做一些事情</p><ul><li><p>通过 <code>class_addMethod</code> 给 <code>oriSEL</code>  添加 <code>swiMethod</code> 方法</p></li><li><p>通过 <code>method_setImplementation</code> 将 <code>swiMethod</code> 的 <code>IMP</code> 指向 <code>不做任何事的空实现</code></p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+ (void)zj_methodSwizzlingWithClass:(Class)cls oriSEL:(SEL)oriSEL swizzledSEL:(SEL)swizzledSEL&#123;</span><br><span class="line">    if (!cls) &#123;</span><br><span class="line">        NSLog(@&quot;传入的交换类不能为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Method oriMethod = class_getInstanceMethod(cls, oriSEL);</span><br><span class="line">    Method swiMethod = class_getInstanceMethod(cls, swizzledSEL);</span><br><span class="line">    </span><br><span class="line">    // 如果没有 oriMethod</span><br><span class="line">    if (!oriMethod) &#123;</span><br><span class="line">        // 在oriMethod为nil时，替换后将swizzledSEL复制一个不做任何事的空实现</span><br><span class="line">        class_addMethod(cls, oriSEL, method_getImplementation(swiMethod), method_getTypeEncoding(swiMethod));</span><br><span class="line">        method_setImplementation(swiMethod, imp_implementationWithBlock(^(id self,SEL _cmd)&#123;&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 一般交换方法：交换自己有的方法</span><br><span class="line">    // 交换自己没有实现的方法：</span><br><span class="line">    // 首先：会先尝试给自己添加要交换的方法 - personInstanceMethod(SEL) -&gt; swiMethod(IMP)</span><br><span class="line">    // 然后再将父类的IMP给swizzle personInstanceMethod(IMP) -&gt; swizzledSEL</span><br><span class="line">    BOOL success = class_addMethod(cls, oriSEL, method_getImplementation(swiMethod), method_getTypeEncoding(swiMethod));</span><br><span class="line">    </span><br><span class="line">    if (success) &#123; // 自己没有 - 交换 - 没有父类进行处理（重写一个）</span><br><span class="line">        class_replaceMethod(cls, swizzledSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</span><br><span class="line">    &#125;else &#123; // 自己有</span><br><span class="line">        method_exchangeImplementations(oriMethod, swiMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="method-swizzling-类方法"><a href="#method-swizzling-类方法" class="headerlink" title="method-swizzling 类方法"></a>method-swizzling 类方法</h1><p>类方法和实例方法的method-swizzling的原理是类似的，唯一的区别就是类方法存在 元类 中，所以可以做如下操作</p><ul><li><code>ZJStudent</code> 中只有类方法 <code>sayHello</code> 的声明，没有实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJStudent : ZJPerson</span><br><span class="line">+ (void)sayHello;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJStudent</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>在ZJStudent的分类的load方法中实现类方法的交换方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//*****ZJStudent(ZJ)</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        [ZJRuntimeTool zj_bestClassMethodSwizzlingWithClass:self oriSEL:@selector(sayHello) swizzledSEL:@selector(zj_studentClassMethod)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)zj_studentClassMethod&#123;</span><br><span class="line">    NSLog(@&quot;ZJStudent分类添加的lg类方法:%s&quot;,__func__);</span><br><span class="line">    [[self class] zj_studentClassMethod];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>封装的 <code>方法交换</code> 如下：</p><ul><li><p>需要通过 <code>class_getClassMethod</code> 方法 <code>获取类方法</code></p></li><li><p>在调用 <code>class_addMethod</code> 和 <code>class_replaceMethod</code> 方法添加和替换时，需要传入的类是 <code>元类</code>，元类可以通过 <code>object_getClass</code> 方法获取类的元类</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (void)zj_bestClassMethodSwizzlingWithClass:(Class)cls oriSEL:(SEL)oriSEL swizzledSEL:(SEL)swizzledSEL&#123;</span><br><span class="line">    if (!cls) NSLog(@&quot;传入的交换类不能为空&quot;);</span><br><span class="line"></span><br><span class="line">    Method oriMethod = class_getClassMethod([cls class], oriSEL);</span><br><span class="line">    Method swiMethod = class_getClassMethod([cls class], swizzledSEL);</span><br><span class="line">    </span><br><span class="line">    if (!oriMethod) &#123; // 避免动作没有意义</span><br><span class="line">        // 在oriMethod为nil时，替换后将swizzledSEL复制一个不做任何事的空实现,代码如下:</span><br><span class="line">        class_addMethod(object_getClass(cls), oriSEL, method_getImplementation(swiMethod), method_getTypeEncoding(swiMethod));</span><br><span class="line">        method_setImplementation(swiMethod, imp_implementationWithBlock(^(id self, SEL _cmd)&#123;</span><br><span class="line">            NSLog(@&quot;来了一个空的 imp&quot;);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 一般交换方法: 交换自己有的方法 -- 走下面 因为自己有意味添加方法失败</span><br><span class="line">    // 交换自己没有实现的方法:</span><br><span class="line">    //   首先第一步:会先尝试给自己添加要交换的方法 :personInstanceMethod (SEL) -&gt; swiMethod(IMP)</span><br><span class="line">    //   然后再将父类的IMP给swizzle  personInstanceMethod(imp) -&gt; swizzledSEL</span><br><span class="line">    //oriSEL:personInstanceMethod</span><br><span class="line"></span><br><span class="line">    BOOL didAddMethod = class_addMethod(object_getClass(cls), oriSEL, method_getImplementation(swiMethod), method_getTypeEncoding(swiMethod));</span><br><span class="line">    </span><br><span class="line">    if (didAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(object_getClass(cls), swizzledSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        method_exchangeImplementations(oriMethod, swiMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><ul><li>调用如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [ZJStudent sayHello];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果如下，由于符合 <code>方法没有实现</code>，所以或走到 <code>空的imp</code> 中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2022-03-14 15:48:59.225558+0800 Method-Swizzling[5512:3942308] ZJStudent分类添加的lg类方法:+[ZJStudent(ZJ) zj_studentClassMethod]</span><br><span class="line">2022-03-14 15:48:59.225602+0800 Method-Swizzling[5512:3942308] 来了一个空的 imp</span><br></pre></td></tr></table></figure><h1 id="method-swizzling-应用"><a href="#method-swizzling-应用" class="headerlink" title="method-swizzling 应用"></a>method-swizzling 应用</h1><p><code>method-swizzling</code> 最常用到的是 <code>防止崩溃、字典、数组等越界</code>。</p><p>在iOS中，NSNumber、NSArray、NSDictionary 等这些都是类族，一个 NSArray 的实现可能由 多个类组成，所以如果想对 NSArray进行swizzling，必须获取到其“真身”进行swizzling，直接对NSArray进行操作是无效的</p><p>下面列举了 NSArray 和 NSDictionary 本类的类名，可以通过 Runtime 函数来取出本类</p><ul><li>NSArray: <code>__NSArrayI</code></li><li>NSMutableArray: <code>__NSArrayM</code></li><li>NSDictionary: <code>__NSDictionaryI</code></li><li>NSMutableDicionary: <code>__NSDictionaryM</code></li></ul><p>【以NSArray为例】</p><ul><li>创建一个NSArray分类 <code>NSArray+ZJ</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSArray (ZJ)</span><br><span class="line">// Swizzling核心代码</span><br><span class="line">// 须要注意的是，好多同窗反馈下面代码不起做用，形成这个问题的缘由大多都是其调用了super load方法。在下面的load方法中，不该该调用父类的load方法。</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    Method fromMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayI&quot;), @selector(objectAtIndex:));</span><br><span class="line">    Method toMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayI&quot;), @selector(cm_objectAtIndex:));</span><br><span class="line">    method_exchangeImplementations(fromMethod, toMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 为了不和系统的方法冲突，我通常都会在swizzling方法前面加前缀</span><br><span class="line">- (id)cm_objectAtIndex:(NSUInteger)index &#123;</span><br><span class="line">    // 判断下标是否越界，若是越界就进入异常拦截</span><br><span class="line">    if (self.count-1 &lt; index) &#123;</span><br><span class="line">        @try &#123;</span><br><span class="line">            return [self cm_objectAtIndex:index];</span><br><span class="line">        &#125;</span><br><span class="line">        @catch (NSException *exception) &#123;</span><br><span class="line">            // 在崩溃后会打印崩溃信息。若是是线上，能够在这里将崩溃信息发送到服务器</span><br><span class="line">            NSLog(@&quot;---------- %s Crash Because Method %s ----------\n&quot;, class_getName(self.class), __func__);</span><br><span class="line">            NSLog(@&quot;%@&quot;, [exception callStackSymbols]);</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        @finally &#123;&#125;</span><br><span class="line">    &#125; // 若是没有问题，则正常进行方法调用</span><br><span class="line">    else &#123;</span><br><span class="line">        return [self cm_objectAtIndex:index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>打印结果如下，会输出崩溃日志，但是实际不会崩溃</li></ul><p><img src="/BboyZJ.github.io/assets/16473129345262.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理20：OC底层面试题解析</title>
      <link href="/BboyZJ.github.io/2020/12/15/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8620%EF%BC%9AOC%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
      <url>/BboyZJ.github.io/2020/12/15/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8620%EF%BC%9AOC%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="【面试题1】Runtime-Associate-方法关系的对象，需要在dealloc中释放？"><a href="#【面试题1】Runtime-Associate-方法关系的对象，需要在dealloc中释放？" class="headerlink" title="【面试题1】Runtime Associate 方法关系的对象，需要在dealloc中释放？"></a>【面试题1】Runtime Associate 方法关系的对象，需要在dealloc中释放？</h1><p>当我们对象释放时，会调用 <code>dealloc</code></p><ul><li>C++函数释放：<code>objc_cxxDestruce</code></li><li>移除关联属性：<code>_object_remove_associations</code></li><li>将弱引用自动设值nil：<code>weak_clear_no_lock(&amp;table_weak_table。(id)this);</code></li><li>引用计数处理：<code>table_refcnts_erase(this)</code></li><li>销毁对象：<code>free(obj)</code></li></ul><p>所以，关联对象 不需要我们手动移除，会在对象析构即 dealloc 时释放</p><p><strong>dealloc源码</strong></p><p>dealloc的源码查找路径：<code>dealloc -&gt; _objc_rootDealloc -&gt; rootDealloc -&gt; object_dispose（释放对象） -&gt; objc_destructInstance -&gt; _object_remove_assocations</code></p><ul><li>在objc源码中搜索 <code>dealloc</code> 的源码实现</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162377557-e28a616f-a34b-4c09-b06c-8aaf6a61ff08.jpg"></p><ul><li>进入 <code>_objc_rootDealloc</code> 源码实现，主要是对 <code>对象进行析构</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162377575-c3744949-8496-483a-b8ef-ffa1abab80fa.jpg"></p><ul><li>进入 <code>rootDealloc</code> 源码实现，发现其中有 <code>关联属性时设置bool值</code>，当有这些条件时，需要进入else流程</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162377594-b3746f9c-0d94-4eb6-a5f6-dd4f125eb7e6.jpg"></p><ul><li>进入 <code>object_dispose</code> 源码实现，主要是 <code>销毁实例对象</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162377729-89d35e99-4d50-400a-9cd1-0f4359869d30.jpg"></p><ul><li>进入 <code>objc_destructInstance</code> 源码实现，在这里有一处关联属性的方法</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162377776-9445b6f7-0e59-419b-87cf-868e77bfc6e9.jpg"></p><ul><li>进入 <code>_object_remove_assocations</code> 源码，关联属性的移除，主要是 <code>从全局哈希map中招待相关对象的迭代器，然后将迭代器中关联属性，从头到尾的移除</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162379659-64bf6ffb-e1ff-4ecf-bb03-5103fe67d419.jpg"></p><h1 id="【面试2】方法的调用顺序"><a href="#【面试2】方法的调用顺序" class="headerlink" title="【面试2】方法的调用顺序"></a>【面试2】方法的调用顺序</h1><p><code>类的方法</code> 和 <code>分类方法</code> 重名，如果调用，是什么情况？</p><ul><li><p>如果同名方法是 <code>普通方法</code>，包括 <code>initialize</code> – <code>先调用分类方法</code></p><ul><li>因为 <code>分类的方法是在类realize之后attach进去的</code>，插在类的方法的前面，所以 <code>优先调用分类的方法</code>（注意：不是分类覆盖主类！！），所以你看到的只有 <code>类的initialize</code></li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162380062-10fd34b3-8e9a-43ba-91ba-c3ddaa3e8558.jpg"></p><pre><code>* `initialize` 方法什么时候调用？`initialize` 方法也是 `主动调用`，即 `第一次消息时` 调用，为了不影响整个load，可以将需要 `提前加载的数据` 写到 `initialize` 中</code></pre><ul><li><p>如果同名方法是 <code>load</code> 方法 – 先 <code>主类load</code>，后 <code>分类load（分类之间，看编译的顺序）</code></p><ul><li>原因：参考 <a href="">iOS-底层原理18：类的加载（下）</a> 文章中的 <code>load_images</code> 原理分析</li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162380180-8f8de0d9-b2ad-491d-b4d1-d6fe90a573a1.jpg"></p><h1 id="【面试3】Runtime是什么？"><a href="#【面试3】Runtime是什么？" class="headerlink" title="【面试3】Runtime是什么？"></a>【面试3】Runtime是什么？</h1><ul><li><p><code>runtime</code> 是由 <code>C和C++</code> 汇编实现的一套 <code>API</code>，为 <code>OC</code> 语言加入了 <code>面向对象、以及运行时的功能</code></p></li><li><p>运行时是指将 <code>数据类型的确定由编译时推到了运行时</code></p><ul><li>举例：<code>extension</code> 和 <code>category</code> 的区别</li></ul></li><li><p>平时编写的 <code>OC</code> 代码，在程序运行过程中，其实最终会转变成 <code>runtime</code> 的 <code>C语言代码</code>，runtime是OC的幕后工作者</p></li></ul><p><strong>1. category类别、分类</strong></p><ul><li><p><code>专门用来给类添加新的方法</code></p></li><li><p><code>不能给类添加成员变量</code>，添加了成员属性，也无法取到</p></li><li><p>注意：其实 <code>可以通过runtime给分类添加属性</code>，即属性关联，重写setter、getter方法</p></li><li><p>分类中用 <code>@property</code> 定义变量，<code>只会生成</code> 变量的 <code>setter、getter</code> 方法的 <code>声明</code>，<code>不能生成方法实现和带下划线的成员变量</code></p></li></ul><p><strong>2. extension 类扩展</strong></p><ul><li><p>可以说成是 <code>特殊的类</code>，也可以称作 <code>匿名的类</code></p></li><li><p>可以 <code>给类添加成员属性</code>，但是 <code>是私有变量</code></p></li><li><p>可以 <code>给类添加方法</code>，也是 <code>私有方法</code></p></li></ul><h1 id="【面试4】方法的本质，sel是什么？IMP是什么？两者之间的关系又是什么？"><a href="#【面试4】方法的本质，sel是什么？IMP是什么？两者之间的关系又是什么？" class="headerlink" title="【面试4】方法的本质，sel是什么？IMP是什么？两者之间的关系又是什么？"></a>【面试4】方法的本质，sel是什么？IMP是什么？两者之间的关系又是什么？</h1><ul><li><p>方法的本质：<code>发送消息</code>，消息会有以下几个流程</p><ul><li><p>快速查找（<code>objc_msgSend</code>）-&gt; <code>cache_t</code> 缓存消息中查找</p></li><li><p>慢速查找 - <code>递归自己|父类</code> -&gt; <code>lookUpImpOrForward</code></p></li><li><p>查找不到消息 -&gt; <code>动态方法解析</code> - <code>resolveInstanceMethod</code></p></li><li><p>消息快速转发 - <code>forwardingTargetForSelector</code></p></li><li><p>消息慢速转发 - <code>methodSignatureForSelector &amp; forwardInvocation</code></p></li></ul></li><li><p><code>sel</code> 是 <code>方法编号</code> - 在 <code>read_images</code> 期间就编译进了内存，相当于一本书的 <code>目录title</code></p></li><li><p><code>imp</code> 是 <code>函数实现指针</code>，<code>找imp就是找函数的过程</code>，相当于 <code>书本的页码</code></p></li><li><p>查找具体的函数就是想看这本书具体篇章的内容</p><ul><li>首先知道想看什么，即目录 title-sel</li><li>根据目录查找到对应的页码 - imp</li><li>通过页码去翻到具体的内容</li></ul></li></ul><h1 id="【面试5】能否像编译后得到的类中增加实例变量？能否像运行时创建的类中添加实例变量？"><a href="#【面试5】能否像编译后得到的类中增加实例变量？能否像运行时创建的类中添加实例变量？" class="headerlink" title="【面试5】能否像编译后得到的类中增加实例变量？能否像运行时创建的类中添加实例变量？"></a>【面试5】能否像编译后得到的类中增加实例变量？能否像运行时创建的类中添加实例变量？</h1><ul><li><code>不能</code> 像编译后得到的类中增加实例变量</li><li>只要类没有注册到内存还是可以添加的</li><li>可以 <code>添加属性+方法</code></li></ul><p><strong>【原因】</strong> ：编译好的实例变量存储的位置是ro，一旦编译完成，内存结构就完全确定了</p><h1 id="【面试6】-self-class-和-super-class-的区别以及原理分析"><a href="#【面试6】-self-class-和-super-class-的区别以及原理分析" class="headerlink" title="【面试6】[self class] 和 [super class]的区别以及原理分析"></a>【面试6】[self class] 和 [super class]的区别以及原理分析</h1><ul><li><p><code>[self class]</code> 就是发送消息 <code>objc_msgSend</code>，消息接收者是 <code>self</code>，方法编号是 <code>class</code></p></li><li><p><code>[super class]</code> 本质就是 <code>objc_msgSendSuper</code>，消息的接收者还是 <code>self</code>，方法编号 <code>class</code>，在运行时，底层调用的是 <code>_objc_msgSendSuper2</code>【重点!!!】</p></li><li><p>只是 <code>objc_msgSendSuper2</code> 会更快，直接跳过 <code>self</code> 的查找</p></li></ul><p><strong>【代码调试】</strong></p><ul><li><code>ZJPerson</code> 中的 <code>init</code> 方法中打印这两种 <code>class</code> 调用</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162380292-c0c0d0de-49a2-46c4-a159-d680fe757256.jpg"></p><ul><li>进入 <code>[self class]</code> 中的 <code>class</code> 源码</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162380372-75a40bc0-7f57-4491-82df-7b88d27b52d9.jpg"></p><p><img src="https://user-images.githubusercontent.com/25925248/162380382-e87c52a1-84ee-49e2-96f0-99020afd4c5d.jpg"></p><p>其底层是 <code>获取对象的isa</code>，当前的 <code>对象是ZJPerson</code>，其isa是其同名的 <code>ZJPerson</code>，所以 <code>[self class]</code> 打印的是 <code>ZJPerson</code></p><ul><li>[super class]中，其中 <code>super</code> 是语法的 <code>关键字</code>，可以通过 <code>clang</code> 看 <code>super</code> 的本质，这是 <code>编译时</code> 的底层源码，其中第一个参数是消息接收者，是一个 <code>__rw_objc_super</code> 结构</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162380664-12fbb71b-35db-4392-ab56-10b3e26eeff0.jpg"></p><ul><li>底层源码中搜索 <code>__rw_objc_super</code>，是一个中间结构体</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162380723-a9747528-16ea-453b-b96f-38af8819fc1e.jpg"></p><ul><li>objc中搜索 <code>objc_msgSendSuper</code>，查看其隐藏参数</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162380749-2fc387e3-4437-4b5e-b17f-cd1841ca9894.jpg"></p><ul><li>搜索 <code>struct objc_super</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162380764-11202a7a-59cb-4873-894b-90c73e88dcae.jpg"></p><p>通过 <code>clang</code> 的底层编译代码可知，当前 <code>消息的接收者</code> 是 <code>self</code>，而 <code>self</code> 等于 <code>ZJPerson</code>，所以 <code>[super class]</code> 进入 <code>class</code> 方法来源后，其中的 self是init后的实例对象，实例对象的 <code>isa</code> 指向的是本类，即消息接收者是 <code>ZJPerson</code>本类</p><ul><li>我们再来看 <code>[super class]</code> 在运行时是否如上一步的底层编码所示，是 <code>objc_msgSendSuper</code>，打开汇编调试，调试结果如下</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162380786-529d1dff-df61-464e-a748-f520c9518380.jpg"></p><ul><li>搜索 <code>objc_msgSendSuper2</code>，从注释得知，是 <code>从类开始查找的</code>，而不是父类</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162380796-be1207c0-cb4d-4abd-9fbc-11a4be319490.jpg"></p><ul><li>查看 <code>objc_msgSendSuper2</code> 的汇编源码，是从 <code>superclass</code> 中的 <code>cache</code> 中查找方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ENTRY _objc_msgSendSuper2</span><br><span class="line">UNWIND _objc_msgSendSuper2, NoFrame</span><br><span class="line"></span><br><span class="line">ldp p0, p16, [x0]       // p0 = real receiver, p16 = class 取出receiver 和 class</span><br><span class="line">ldr p16, [x16, #SUPERCLASS] // p16 = class-&gt;superclass</span><br><span class="line">CacheLookup NORMAL, _objc_msgSendSuper2//cache中查找--快速查找</span><br><span class="line"></span><br><span class="line">END_ENTRY _objc_msgSendSuper2</span><br></pre></td></tr></table></figure><p><strong>【完成回答】</strong></p><ul><li><p><code>[self class]</code> 方法调用的本质是 <code>发送消息</code>，调用class的消息流程，拿到 <code>元类的类型</code>，在这里是因为类已经加载到内存，所以在读取时是一个字符串类型，这个字符串类型是在 <code>map_images</code> 的 <code>readClass</code> 时已经加入表中，所以打印为 <code>ZJPerson</code></p></li><li><p><code>[super class]</code> 打印的是 <code>ZJPerson</code>，原因是当前的 <code>super</code> 是一个 <code>关键字</code>，在这里只是调用 <code>objc_msgSendSuper2</code>，其实他的消息接收者和[self class]是一模一样的，所以返回的是 <code>ZJPerson</code></p></li></ul><h1 id="【面试7】内存平移问题"><a href="#【面试7】内存平移问题" class="headerlink" title="【面试7】内存平移问题"></a>【面试7】内存平移问题</h1><p>ZJPerson中有一个 <code>属性zj_name</code> 和 <code>实例方法saySomething</code>，通过下面代码这种方式能否调用实例方法？为什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">@property (nonatomic,copy)NSString * zj_name;</span><br><span class="line">- (void)saySomething;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJPerson</span><br><span class="line">- (void)saySomething&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 不一般的调用实例的方法</span><br><span class="line">Class cls = [ZJPerson class];</span><br><span class="line">void *zj = &amp;cls;</span><br><span class="line">[(__bridge id)zj saySomething];</span><br></pre></td></tr></table></figure><p><strong>【代码调试】</strong></p><ul><li>我们在日常开发中的调用方式是下面这种</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 常见的调用实例方法</span><br><span class="line">ZJPerson * person = [[ZJPerson alloc] init];</span><br><span class="line">[person saySomething];</span><br></pre></td></tr></table></figure><ul><li>通过运行发现，是可以执行的，打印结果如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2022-03-16 10:30:27.686250+0800 load+initialize-demo[6296:4626148] -[ZJPerson saySomething]</span><br><span class="line">2022-03-16 10:30:27.686295+0800 load+initialize-demo[6296:4626148] -[ZJPerson saySomething]</span><br></pre></td></tr></table></figure><ul><li><p><code>[person saySomething]</code> 的本质是 <code>对象发送消息</code>，那么当前的 <code>person</code> 是什么？</p><ul><li><code>person</code> 的 <code>isa</code> 指向类 <code>ZJPerson</code>， 即 <code>person</code> 的首地址 <code>指向 ZJPerson</code> 的首地址，我们可以通过 <code>ZJPerson</code> 的内存平移找到 <code>cache</code>，在 <code>cache</code> 中查找方法</li></ul><p>  <img src="https://user-images.githubusercontent.com/25925248/162382656-2558ab5d-46ab-4307-9b83-760e89fd97b5.jpg"></p></li><li><p><code>[(__bridge id)zj saySomething]</code> 中的 <code>zj</code> 是来自于 <code>ZJPerson</code> 这个类，然后有一个指针 <code>zj</code>，将其 <code>指向ZJPerson的首地址</code></p></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162382707-ade1bea8-5eeb-4c96-bf07-c95c622c90e6.jpg"></p><p>所以，<code>person</code> 是指向 <code>ZJPeron</code> 类的结构，<code>zj</code> 也是指向 <code>ZJPerson</code> 类的结构，然后都是在 <code>ZJPerson</code> 中的 <code>methodList</code> 中查找方法</p><p><img src="https://user-images.githubusercontent.com/25925248/162382774-507d97ec-0039-473c-8071-79dae6dfb188.jpg"></p><h1 id="修改：saySomething里面有属性-self-zj-name-的打印"><a href="#修改：saySomething里面有属性-self-zj-name-的打印" class="headerlink" title="修改：saySomething里面有属性 self.zj_name 的打印"></a>修改：saySomething里面有属性 self.zj_name 的打印</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)saySomething&#123;</span><br><span class="line">    NSLog(@&quot;%s - %@&quot;,__func__,self.zj_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 下面这两种方式调用</span><br><span class="line">// 方式一</span><br><span class="line">Class cls = [ZJPerson class];</span><br><span class="line">void *zj = &amp;cls;</span><br><span class="line">[(__bridge id)zj saySomething];</span><br><span class="line">    </span><br><span class="line">// 方式二</span><br><span class="line">ZJPerson * person = [[ZJPerson alloc] init];</span><br><span class="line">[person saySomething];</span><br></pre></td></tr></table></figure><ul><li><p>查看这两种调用方式的打印结果，如下所示</p><ul><li><code>zj</code> 方式的调用打印的 <code>zj_name</code> 是 <code>&lt;ViewController: 0x100e06eb0&gt;</code></li><li>person 方式调用打印的 <code>zj_name</code> 是 <code>(null)</code></li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162382833-6f2cd572-b1bb-47f5-a828-09c6d37fa746.jpg"></p><p>为什么会出现打印不一致的情况？</p><ul><li>其中 <code>person</code> 方式的 <code>zj_name</code> 是由于 <code>self指向person的内部结构</code>，然后通过 <code>内存平移8字节，取出去zj_name</code>，即 <code>self指针首地址平移8字节获取</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162382883-a2754aee-d262-47b4-b87a-52b22bf0e0a4.jpg"></p><ul><li><p>【方式一】其中 <code>zj</code> 指针中没有任何，所以 <code>zj表示8字节指针</code>，<code>self.zj_name</code> 的获取，相当于 <code>zj首地址的指针也需要平移8字节找zj_name</code>，那么此时的zj的指针地址是多少？平移8字节获取的是什么？</p><ul><li><p><code>zj</code> 是一个指针，是存在 <code>栈</code> 中的，栈是一个 <code>先进后出</code> 的结构，参数传入就是一个不断压栈的过程</p><ul><li><p>其中 <code>隐藏参数会压入栈</code>，且每个函数都会有两个隐藏参数 <code>(id self,sel _cmd)</code>，可以通过 <code>clang</code> 查看底层编译</p></li><li><p><code>隐藏参数压栈</code> 的过程，其地址是 <code>递减</code> 的，而 <code>栈是从高地址 -&gt; 低地址分配</code> 的，即 <code>在栈中</code>，<code>参数会从前往后一直压</code></p></li><li><p>super通过clang查看底层的编译，是 <code>objc_msgSendSuper</code>，其第一个参数是一个结构体 <code>__rw_objc_super（self,class_getSuperclass）</code>，那么结构体中的属性时如何压栈的？可以通过自定义一个结构体，判断结构体内部成员的压栈情况</p></li><li><p><code>p &amp;person3</code></p></li><li><p><code>p *(NSNumber **)0x000000016d2f59f0</code></p></li><li><p><code>p *(NSNumber **)0x000000016d2f59f8</code></p></li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct zj_struct&#123;</span><br><span class="line">    NSNumber *num1;</span><br><span class="line">    NSNumber *num2;</span><br><span class="line">&#125;zj_struct;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/25925248/162382938-a08149f5-c911-49b6-aec9-3e97a6d7db95.jpg"></p><p>所以图中可以得到 20先加入，再加入10，因此 <code>结构体内部</code> 的压栈情况是 <code>低地址 -&gt; 高     地址</code>，<code>递增</code> 的，栈中 <code>结构体内部</code> 的成员是 <code>反向</code> 压入栈，即 <code>低地址 -&gt; 高地址</code>，是递增的</p><ul><li><p>所以到目前为止，栈中 从高地址到低地址 的顺序的：<code>self -&gt; _cmd -&gt; (id)class_getSuperclass(objc_getClass(&quot;ViewController&quot;)) -&gt; self -&gt; cls -&gt; zj -&gt; person</code></p><ul><li><p><code>self</code> 和 <code>_cmd</code> 是 <code>viewDidLoad</code> 方法的两个隐藏的参数，是高地址 -&gt; 低地址 <code>正向压栈</code> 的</p></li><li><p><code>class_getSuperClass</code> 和 <code>self</code> 为 <code>objc_msgSendSuper2</code> 中的结构体成员，是从最后一个成员变量，即低地址 -&gt; 高地址 <code>反向压栈</code> 的</p></li></ul></li></ul><p>可以通过下面这段代码打印下栈的存储是否如上面所说</p><p><img src="https://user-images.githubusercontent.com/25925248/162383010-ebde2dc9-5eed-467d-9e48-9583d321c96c.jpg"></p><p>其中为什么 <code>class_getSuperclass</code> 是 <code>viewController</code>，因为 <code>objc_msgSendSuper2</code> 返回的是 <code>当前类</code>，两个self，并不是同一个self，而是栈的指针不同，但是指向同一片内存空间</p><ul><li><p><code>[(__bridge id)zj saySomething]</code> 调用时，此时的 <code>zj</code> 是 <code>ZJPerson：0x16bbc1a08</code> ，所以 <code>saySomething</code> 方法中传入的 <code>self</code> 还是 <code>ZJPerson</code> ，但并不是我们通常认为的 <code>ZJPerson</code>，使我们当前 <code>传入的消息接收者</code>，即 <code>ZJPerson：0x16bbc1a08</code>，是ZJPerson的实例对象，此时操作与普通的ZJPerson是一致的，即 <code>ZJPerson的地址内存平移8字节</code></p><ul><li><p>普通person流程：<code>person -&gt; zj_name -&gt; 内存平移8字节</code></p></li><li><p>zj流程：<code>0x16bbc1a08 + 0x8 - &gt; 0x16bbc1a10</code>，即为 <code>self</code>，指向 <code>&lt;ViewController: 0x10470a370&gt;</code>，如下图所示</p></li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/162383074-969ae651-f2d6-43d5-b6b4-3339f0b2b18d.jpg"></p><p>其中 <code>person</code> 与 <code>ZJPerson</code> 的关系是 <code>person是以ZJPerson为模板实例化对象</code>，即<code>alloc有一个指针地址，指向isa，isa指向ZJPerson</code>，它们之间关联是由一个isa指向</p><p>而zj也是指向ZJPerson的关系，编译器会人为 <code>zj也是ZJPerson的一个实例化对象</code>，即 <code>zj相当于isa，即首地址，指向ZJPerson</code>，具有和person一样的效果，简单来说，我们已经完全将编译器骗过了，即zj也有zj_name，由于 <code>person查找zj_name是通过内存地址平移8字节</code>，所以zj也是通过内存地址平移8字节去查找zj_name。</p><p><strong>哪些东西在栈里？哪些在堆里？</strong></p><ul><li><p><code>alloc</code> 的对象都在 <code>堆</code> 中</p></li><li><p><code>指针、对象</code> 在 <code>栈</code> 中，例如 <code>person指向的空间</code> 在 <code>堆</code> 中，<code>person所在的空间</code>在 <code>栈</code> 中</p></li><li><p><code>临时变量</code> 在 <code>栈</code> 中</p></li><li><p><code>属性值</code> 在 <code>堆</code>，属性随对象是在 <code>栈</code> 中</p></li></ul><p><strong>【注意】</strong></p><ul><li><p><code>堆</code> 是从小到大，即低地址 -&gt; 高地址</p></li><li><p><code>栈</code> 是从大到小，即从高地址 -&gt; 低地址分配</p><ul><li>函数隐藏参数会 <code>从前往后</code> 一直压，即 <code>从高地址 -&gt; 低地址 开始入栈</code>。</li><li>结构体内部成员是 <code>从低地址 -&gt; 高地址</code></li></ul></li><li><p>一般情况下，内存地址有如下规则</p><ul><li><code>0x60</code> 开头表示在 <code>堆</code> 中</li><li><code>0x70</code> 开头的地址表示在 <code>栈</code> 中</li><li><code>0x10</code> 开头的地址表示在 <code>全局区域</code> 中</li></ul></li></ul><h1 id="【面试8】runtime是如何实现weak的，为什么可以自动置为nil？"><a href="#【面试8】runtime是如何实现weak的，为什么可以自动置为nil？" class="headerlink" title="【面试8】runtime是如何实现weak的，为什么可以自动置为nil？"></a>【面试8】runtime是如何实现weak的，为什么可以自动置为nil？</h1><ul><li>通过 <code>sideTable</code> 找到我们的 <code>weak_table</code></li><li><code>weak_table</code> 根据 <code>referent</code> 找到或创建 <code>weak_entry_t</code></li><li>然后 <code>append_referrer（entry,referrer）</code> 将我的新弱引用的对象加进去<code>entry</code></li><li>最后 <code>weak_entry_insert</code>，把 <code>entry</code> 加入到我们的 <code>weak_table</code></li></ul><p>底层源码调用流程如下图所示</p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理19：类扩展与关联对象</title>
      <link href="/BboyZJ.github.io/2020/11/29/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8619%EF%BC%9A%E7%B1%BB%E6%89%A9%E5%B1%95%E4%B8%8E%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"/>
      <url>/BboyZJ.github.io/2020/11/29/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8619%EF%BC%9A%E7%B1%BB%E6%89%A9%E5%B1%95%E4%B8%8E%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理18：类的加载（下）</title>
      <link href="/BboyZJ.github.io/2020/11/19/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8618%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/BboyZJ.github.io/2020/11/19/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8618%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理17：类的加载（上）</title>
      <link href="/BboyZJ.github.io/2020/11/03/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8617%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/BboyZJ.github.io/2020/11/03/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8617%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理16：dyld与objc的关联</title>
      <link href="/BboyZJ.github.io/2020/10/20/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8616%EF%BC%9Adyld%E4%B8%8Eobjc%E7%9A%84%E5%85%B3%E8%81%94/"/>
      <url>/BboyZJ.github.io/2020/10/20/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8616%EF%BC%9Adyld%E4%B8%8Eobjc%E7%9A%84%E5%85%B3%E8%81%94/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文的主要目的是理解 <code>dyld</code> 与 <code>objc</code> 是如何关联的？</p><p>在上两篇文章中，我们梳理了 <code>dyld</code> 的加载流程，下面来详细介绍下 <code>dyld</code> 和 <code>objc</code> 的关联</p><h1 id="objc-init-源码解析"><a href="#objc-init-源码解析" class="headerlink" title="_objc_init 源码解析"></a>_objc_init 源码解析</h1><p>首先，来看下libObjc中的_objc_init方法源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized = false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized = true;</span><br><span class="line">    </span><br><span class="line">    // fixme defer initialization until an objc-using image is found?</span><br><span class="line">    //读取影响运行时的环境变量，如果需要，还可以打开环境变量帮助 export OBJC_HELP = 1</span><br><span class="line">    environ_init();</span><br><span class="line">    //关于线程key的绑定，例如线程数据的析构函数</span><br><span class="line">    tls_init();</span><br><span class="line">    //运行C++静态构造函数，在dyld调用我们的静态析构函数之前，libc会调用_objc_init(),因此我们必须自己做</span><br><span class="line">    static_init();</span><br><span class="line">    //runtime运行时环境初始化，里面主要是unattachedCategories、allocatedClasses -- 分类初始化</span><br><span class="line">    runtime_init();</span><br><span class="line">    //初始化libobjc的异常处理系统</span><br><span class="line">    exception_init();</span><br><span class="line">    //缓存条件初始化</span><br><span class="line">    cache_init();</span><br><span class="line">    //启动回调机制，通常这不会做什么，因为所有的初始化都是惰性的，但是对于某些进程，我们会迫不及待地加载trampolines dylib</span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     _dyld_objc_notify_register -- dyld 注册的地方</span><br><span class="line">     - 仅供objc运行时使用</span><br><span class="line">     - 注册处理程序，以便在映射、取消映射 和初始化objc镜像文件时使用，dyld将使用包含objc_image_info的镜像文件数组，回调 mapped 函数</span><br><span class="line">     </span><br><span class="line">     map_images:dyld将image镜像文件加载进内存时，会触发该函数</span><br><span class="line">     load_images：dyld初始化image会触发该函数</span><br><span class="line">     unmap_image：dyld将image移除时会触发该函数</span><br><span class="line">     */</span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line">#if __OBJC2__</span><br><span class="line">    didCallDyldNotifyRegister = true;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码所知，主要分为以下几部分：</p><ul><li><p>environ_init：初始化一系列环境变量，并读取影响运行时的环境变量</p></li><li><p>tls_init：关于线程key的绑定</p></li><li><p>static_init：运行C++静态构造函数（只会运行系统级别的构造函数），在dyld调用静态析构函数之前，libc会调用_objc_init</p></li><li><p>runtime_init：runtime运行时环境初始化，里面操作是unattachedCategories、allocatedClasses（表的初始化）</p></li><li><p>exception_init：初始化libObjc的异常处理系统</p></li><li><p>cache_init： cache缓存初始化</p></li><li><p>_imp_implementationWithBlock_init ：启动回调机制，通常这不会做什么，因为所有的初始化都是惰性的，但是对于某些进程，我们会迫不及待地加载trampolines dylib</p></li><li><p>_dyld_objc_notify_register： dyld的注册</p></li></ul><p>下面主要针对以上几部分配合源码进行说明</p><h1 id="environ-init方法：环境变量初始化"><a href="#environ-init方法：环境变量初始化" class="headerlink" title="environ_init方法：环境变量初始化"></a>environ_init方法：环境变量初始化</h1><p>environ_init方法的源码如下，其中的关键代码是 for 循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void environ_init(void) </span><br><span class="line">&#123;</span><br><span class="line">    //...省略部分逻辑</span><br><span class="line">if (PrintHelp  ||  PrintOptions) &#123;</span><br><span class="line">        //...省略部分逻辑</span><br><span class="line">        for (size_t i = 0; i &lt; sizeof(Settings)/sizeof(Settings[0]); i++) &#123;</span><br><span class="line">            const option_t *opt = &amp;Settings[i];            </span><br><span class="line">            if (PrintHelp) _objc_inform(&quot;%s: %s&quot;, opt-&gt;env, opt-&gt;help);</span><br><span class="line">            if (PrintOptions &amp;&amp; *opt-&gt;var) _objc_inform(&quot;%s is set&quot;, opt-&gt;env);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有以下两种方式可以打印所有的环境变量</p><ul><li>将for循环单独拿出来，去除所有条件，打印环境变量</li></ul><p><img src="/BboyZJ.github.io/assets/16773579333765.jpg"></p><ul><li>通过终端命令export OBJC_hrlp &#x3D; 1,打印环境变量</li></ul><p><img src="/BboyZJ.github.io/assets/16773579589190.jpg"></p><p>这些环境变量，均可以通过target – Edit Scheme – Run –Arguments – Environment Variables配置，其中常用的环境变量主要有以下几个（环境变量汇总见文末！）：</p><ul><li><p>DYLD_PRINT_STATISTICS：设置 DYLD_PRINT_STATISTICS 为YES，控制台就会打印 App 的加载时长，包括整体加载时长和动态库加载时长，即main函数之前的启动时间（查看pre-main耗时），可以通过设置了解其耗时部分，并对其进行启动优化。</p></li><li><p>OBJC_DISABLE_NONPOINTER_ISA：杜绝生成相应的nonpointer isa（nonpointer isa指针地址 末尾为1 ），生成的都是普通的isa</p></li><li><p>OBJC_PRINT_LOAD_METHODS：打印 Class 及 Category 的 + (void)load 方法的调用信息</p></li><li><p>NSDoubleLocalizedStrings：项目做国际化本地化(Localized)的时候是一个挺耗时的工作，想要检测国际化翻译好的语言文字UI会变成什么样子，可以指定这个启动项。可以设置 NSDoubleLocalizedStrings 为YES。</p></li><li><p>NSShowNonLocalizedStrings：在完成国际化的时候，偶尔会有一些字符串没有做本地化，这时就可以设置NSShowNonLocalizedStrings 为YES，所有没有被本地化的字符串全都会变成大写。</p></li></ul><h1 id="环境变量-OBJC-DISABLE-NONPOINTER-ISA"><a href="#环境变量-OBJC-DISABLE-NONPOINTER-ISA" class="headerlink" title="环境变量 - OBJC_DISABLE_NONPOINTER_ISA"></a>环境变量 - OBJC_DISABLE_NONPOINTER_ISA</h1><p>以OBJC_DISABLE_NONPOINTER_ISA为例，将其设置为YES，如下图所示</p><p><img src="/BboyZJ.github.io/assets/16773580099731.jpg"></p><ul><li>未设置 OBJC_DISABLE_NONPOINTER_ISA前， isa地址的二进制打印，末尾为1</li></ul><p><img src="/BboyZJ.github.io/assets/16773580228270.jpg"></p><ul><li>设置OBJC_DISABLE_NONPOINTER_ISA环境变量后，末尾变成了0</li></ul><p><img src="/BboyZJ.github.io/assets/16773580340549.jpg"></p><p>所以OBJC_DISABLE_NONPOINTER_ISA可以控制isa优化开关，从而优化整个内存结构</p><h1 id="环境变量-OBJC-PRINT-LOAD-METHODS"><a href="#环境变量-OBJC-PRINT-LOAD-METHODS" class="headerlink" title="环境变量 - OBJC_PRINT_LOAD_METHODS"></a>环境变量 - OBJC_PRINT_LOAD_METHODS</h1><ul><li><p>配置打印load 方法的环境变量OBJC_PRINT_LOAD_METHODS，设置为YES</p></li><li><p>在LGPerson类中重写+load函数，运行程序，load函数的打印如下</p></li></ul><p><img src="/BboyZJ.github.io/assets/16773580657204.jpg"></p><p>所以，OBJC_PRINT_LOAD_METHODS可以监控所有的+load方法，从而处理启动优化（后续会总结下启动优化方法）</p><h1 id="tls-init：线程key的绑定"><a href="#tls-init：线程key的绑定" class="headerlink" title="tls_init：线程key的绑定"></a>tls_init：线程key的绑定</h1><p>主要是本地线程池的初始化以及析构，源码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void tls_init(void)</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_DIRECT_THREAD_KEYS//本地线程池，用来进行处理</span><br><span class="line">    pthread_key_init_np(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);//初始init</span><br><span class="line">#else</span><br><span class="line">    _objc_pthread_key = tls_create(&amp;_objc_pthread_destroyspecific);//析构</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="static-init：运行系统级别的C-静态构造函数"><a href="#static-init：运行系统级别的C-静态构造函数" class="headerlink" title="static_init：运行系统级别的C++静态构造函数"></a>static_init：运行系统级别的C++静态构造函数</h1><p>主要是运行系统级别的C++静态构造函数，在dyld调用我们的静态构造函数之前，libc调用_objc_init方法，即系统级别的C++构造函数 先于 自定义的C++构造函数 运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void static_init()</span><br><span class="line">&#123;</span><br><span class="line">    size_t count;</span><br><span class="line">    auto inits = getLibobjcInitializers(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    for (size_t i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        inits[i]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="runtime-init：运行时环境初始化"><a href="#runtime-init：运行时环境初始化" class="headerlink" title="runtime_init：运行时环境初始化"></a>runtime_init：运行时环境初始化</h1><p>主要是运行时的初始化，主要分为两部分：<code>分类初始化、类的表初始化</code>（后续会详细讲解对应的函数）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void runtime_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    objc::unattachedCategories.init(32);</span><br><span class="line">    objc::allocatedClasses.init(); //初始化 -- 开辟的类的表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="exception-init：初始化libobjc的异常处理系统"><a href="#exception-init：初始化libobjc的异常处理系统" class="headerlink" title="exception_init：初始化libobjc的异常处理系统"></a>exception_init：初始化libobjc的异常处理系统</h1><p>主要是初始化libobjc的异常处理系统，注册异常处理的回调，从而监控异常的处理，源码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void exception_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    old_terminate = std::set_terminate(&amp;_objc_terminate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当有crash（crash是指系统发生的不允许的一些指令，然后系统给的一些信号）发生时，会来到_objc_terminate方法，走到uncaught_handler扔出异常</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">* _objc_terminate</span><br><span class="line">* Custom std::terminate handler.</span><br><span class="line">*</span><br><span class="line">* The uncaught exception callback is implemented as a std::terminate handler. </span><br><span class="line">* 1. Check if there&#x27;s an active exception</span><br><span class="line">* 2. If so, check if it&#x27;s an Objective-C exception</span><br><span class="line">* 3. If so, call our registered callback with the object.</span><br><span class="line">* 4. Finally, call the previous terminate handler.</span><br><span class="line">**********************************************************************/</span><br><span class="line">static void (*old_terminate)(void) = nil;</span><br><span class="line">static void _objc_terminate(void)</span><br><span class="line">&#123;</span><br><span class="line">    if (PrintExceptions) &#123;</span><br><span class="line">        _objc_inform(&quot;EXCEPTIONS: terminating&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (! __cxa_current_exception_type()) &#123;</span><br><span class="line">        // No current exception.</span><br><span class="line">        (*old_terminate)();</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // There is a current exception. Check if it&#x27;s an objc exception.</span><br><span class="line">        @try &#123;</span><br><span class="line">            __cxa_rethrow();</span><br><span class="line">        &#125; @catch (id e) &#123;</span><br><span class="line">            // It&#x27;s an objc object. Call Foundation&#x27;s handler, if any.</span><br><span class="line">            (*uncaught_handler)((id)e);//扔出异常</span><br><span class="line">            (*old_terminate)();</span><br><span class="line">        &#125; @catch (...) &#123;</span><br><span class="line">            // It&#x27;s not an objc object. Continue to C++ terminate.</span><br><span class="line">            (*old_terminate)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>搜索uncaught_handler，在app层会传入一个函数用于处理异常，以便于调用函数，然后回到原有的app层中，如下所示，其中fn即为传入的函数，即 uncaught_handler 等于 fn</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objc_uncaught_exception_handler </span><br><span class="line">objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler fn)</span><br><span class="line">&#123;</span><br><span class="line">//    fn为设置的异常句柄 传入的函数，为外界给的</span><br><span class="line">    objc_uncaught_exception_handler result = uncaught_handler;</span><br><span class="line">    uncaught_handler = fn; //赋值</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="crash分类"><a href="#crash分类" class="headerlink" title="crash分类"></a>crash分类</h1><p>crash的主要原因是收到了未处理的信号，主要来源于三个地方：</p><ul><li>kernel 内核</li><li>其他进行</li><li>App本身</li></ul><p>所以相对应的，crash也分为了3种</p><ul><li><p>Mach异常：是指最底层的内核级异常。用户态的开发者可以直接通过Mach API设置thread，task，host的异常端口，来捕获Mach异常。</p></li><li><p>Unix信号：又称BSD 信号，如果开发者没有捕获Mach异常，则会被host层的方法ux_exception()将异常转换为对应的UNIX信号，并通过方法threadsignal()将信号投递到出错线程。可以通过方法signal(x, SignalHandler)来捕获single。</p></li><li><p>NSException 应用级异常：它是未被捕获的Objective-C异常，导致程序向自身发送了SIGABRT信号而崩溃，对于未捕获的Objective-C异常，是可以通过try catch来捕获的，或者通过NSSetUncaughtExceptionHandler()机制来捕获。</p></li></ul><p>针对应用级异常，可以通过注册异常捕获的函数，即NSSetUncaughtExceptionHandler机制,实现线程保活, 收集上传崩溃日志</p><h1 id="应用级crash拦截"><a href="#应用级crash拦截" class="headerlink" title="应用级crash拦截"></a>应用级crash拦截</h1><p>所以在开发中，会针对crash进行拦截处理，即app代码中给一个异常句柄NSSetUncaughtExceptionHandler，传入一个函数给系统，当异常发生后，调用函数（函数中可以线程保活、收集并上传崩溃日志），然后回到原有的app层中，其本质就是一个回调函数，如下图所示</p><p><img src="/BboyZJ.github.io/assets/16773582748130.png"></p><p>上述方式只适合收集应用级异常，我们要做的就是用自定义的函数替代该ExceptionHandler即可</p><h1 id="cache-init：缓存初始化"><a href="#cache-init：缓存初始化" class="headerlink" title="cache_init：缓存初始化"></a>cache_init：缓存初始化</h1><p>主要是缓存初始化，源码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void cache_init()</span><br><span class="line">&#123;</span><br><span class="line">#if HAVE_TASK_RESTARTABLE_RANGES</span><br><span class="line">    mach_msg_type_number_t count = 0;</span><br><span class="line">    kern_return_t kr;</span><br><span class="line"></span><br><span class="line">    while (objc_restartableRanges[count].location) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    //为当前任务注册一组可重新启动的缓存</span><br><span class="line">    kr = task_restartable_ranges_register(mach_task_self(),</span><br><span class="line">                                          objc_restartableRanges, count);</span><br><span class="line">    if (kr == KERN_SUCCESS) return;</span><br><span class="line">    _objc_fatal(&quot;task_restartable_ranges_register failed (result 0x%x: %s)&quot;,</span><br><span class="line">                kr, mach_error_string(kr));</span><br><span class="line">#endif // HAVE_TASK_RESTARTABLE_RANGES</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="imp-implementationWithBlock-init：启动回调机制"><a href="#imp-implementationWithBlock-init：启动回调机制" class="headerlink" title="_imp_implementationWithBlock_init：启动回调机制"></a>_imp_implementationWithBlock_init：启动回调机制</h1><p>该方法主要是启动回调机制，通常这不会做什么，因为所有的初始化都是惰性的，但是对于某些进程，我们会迫不及待地加载libobjc-trampolines.dylib，其源码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_imp_implementationWithBlock_init(void)</span><br><span class="line">&#123;</span><br><span class="line">#if TARGET_OS_OSX</span><br><span class="line">    // Eagerly load libobjc-trampolines.dylib in certain processes. Some</span><br><span class="line">    // programs (most notably QtWebEngineProcess used by older versions of</span><br><span class="line">    // embedded Chromium) enable a highly restrictive sandbox profile which</span><br><span class="line">    // blocks access to that dylib. If anything calls</span><br><span class="line">    // imp_implementationWithBlock (as AppKit has started doing) then we&#x27;ll</span><br><span class="line">    // crash trying to load it. Loading it here sets it up before the sandbox</span><br><span class="line">    // profile is enabled and blocks it.</span><br><span class="line">    // 在某些进程中渴望加载libobjc-trampolines.dylib。一些程序（最著名的是嵌入式Chromium的较早版本使用的QtWebEngineProcess）启用了严格限制的沙箱配置文件，从而阻止了对该dylib的访问。如果有任何调用imp_implementationWithBlock的操作（如AppKit开始执行的操作），那么我们将在尝试加载它时崩溃。将其加载到此处可在启用沙箱配置文件之前对其进行设置并阻止它。</span><br><span class="line">    // This fixes EA Origin (rdar://problem/50813789)</span><br><span class="line">    // and Steam (rdar://problem/55286131)</span><br><span class="line">    if (__progname &amp;&amp;</span><br><span class="line">        (strcmp(__progname, &quot;QtWebEngineProcess&quot;) == 0 ||</span><br><span class="line">         strcmp(__progname, &quot;Steam Helper&quot;) == 0)) &#123;</span><br><span class="line">        Trampolines.Initialize();</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="dyld-objc-notify-register：dyld注册"><a href="#dyld-objc-notify-register：dyld注册" class="headerlink" title="_dyld_objc_notify_register：dyld注册"></a>_dyld_objc_notify_register：dyld注册</h1><p>_dyld_objc_notify_register方法</p><p>这个方法的具体实现在 <a href="">iOS-底层原理 15-1：dyld加载流程</a> 已经有详细说明，其源码实现是在dyld源码中，以下是_dyld_objc_notify_register方法的声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Note: only for use by objc runtime</span><br><span class="line">// Register handlers to be called when objc images are mapped, unmapped, and initialized.</span><br><span class="line">// Dyld will call back the &quot;mapped&quot; function with an array of images that contain an objc-image-info section.</span><br><span class="line">// Those images that are dylibs will have the ref-counts automatically bumped, so objc will no longer need to</span><br><span class="line">// call dlopen() on them to keep them from being unloaded.  During the call to _dyld_objc_notify_register(),</span><br><span class="line">// dyld will call the &quot;mapped&quot; function with already loaded objc images.  During any later dlopen() call,</span><br><span class="line">// dyld will also call the &quot;mapped&quot; function.  Dyld will call the &quot;init&quot; function when dyld would be called</span><br><span class="line">// initializers in that image.  This is when objc calls any +load methods in that image.</span><br><span class="line">//</span><br><span class="line">void _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped);</span><br></pre></td></tr></table></figure><p>从注释中，可以得出：</p><ul><li><p>仅供objc运行时使用</p></li><li><p>注册处理程序，以便在映射、取消映射和初始化objc图像时调用</p></li><li><p>dyld将会通过一个包含objc-image-info的镜像文件的数组回调mapped函数</p></li></ul><p>方法中的三个参数分别表示的含义如下：</p><ul><li><p>map_images：dyld将image（镜像文件）加载进内存时，会触发该函数</p></li><li><p>load_image：dyld初始化image会触发该函数</p></li><li><p>unmap_image：dyld将image移除时，会触发该函数</p></li></ul><h1 id="dyld与Objc的关联"><a href="#dyld与Objc的关联" class="headerlink" title="dyld与Objc的关联"></a>dyld与Objc的关联</h1><p>其方法的源码实现与调用如下，即dyld与Objc的关联可以通过源码体现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">===&gt; dyld源码--具体实现</span><br><span class="line">void _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped)</span><br><span class="line">&#123;</span><br><span class="line">    dyld::registerObjCNotifiers(mapped, init, unmapped);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">🔽</span><br><span class="line">===&gt; libobjc源码中--调用</span><br><span class="line">_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br></pre></td></tr></table></figure><p>从上可以得出</p><ul><li>mapped 等价于 map_images</li><li>init 等价于 load_images</li><li>unmapped 等价于 unmap_image</li></ul><p><a href="">在iOS-底层原理 15-1：dyld加载流程</a> 中，我们知道了load_images是在notifySingle方法中，通过sNotifyObjCInit调用的，如下所示</p><p><img src="/BboyZJ.github.io/assets/16773584642372.jpg"></p><p>然后通过查找sNotifyObjCInit，最终找到了_dyld_objc_notify_register –&gt; registerObjCNotifiers,在该方法中将_dyld_objc_notify_register传入的参数赋值给了3个回调方法</p><p><img src="/BboyZJ.github.io/assets/16773584780090.png"></p><p>所以 有以下等价关系</p><ul><li>sNotifyObjCMapped &#x3D;&#x3D; mapped &#x3D;&#x3D; map_images</li><li>sNotifyObjCInit &#x3D;&#x3D; init &#x3D;&#x3D; load_images</li><li>sNotifyObjCUnmapped &#x3D;&#x3D; unmapped &#x3D;&#x3D; unmap_image</li></ul><p><strong>map_images调用时机</strong></p><p>关于load_images的调用时机已经在dyld加载流程中讲解过了，下面以map_images为例，看看其调用时机</p><ul><li>dyld中全局搜索 sNotifyObjcMapped ：registerObjCNotifiers – notifyBatchPartial – sNotifyObjCMapped</li></ul><p><img src="/BboyZJ.github.io/assets/16773585169000.jpg"></p><ul><li>全局搜索notifyBatchPartial，在registerObjCNotifiers方法中调用</li></ul><p><img src="/BboyZJ.github.io/assets/16773585293740.jpg"></p><p>所以有以下结论：map_images是先于load_images调用，即先map_images ，再load_images</p><h1 id="dyld与Objc关联"><a href="#dyld与Objc关联" class="headerlink" title="dyld与Objc关联"></a>dyld与Objc关联</h1><p>结合dyld加载流程，dyld与Objc的关联如下图所示</p><p><img src="/BboyZJ.github.io/assets/16773585533757.png"></p><ul><li><p>在dyld中注册回调函数，可以理解为 添加观察者</p></li><li><p>在objc中dyld注册，可以理解为发送通知</p></li><li><p>触发回调，可以理解为执行通知selector</p></li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>环境变量汇总</p><p><img src="/BboyZJ.github.io/assets/16773586139259.jpg"><br><img src="/BboyZJ.github.io/assets/16773586302636.jpg"><br><img src="/BboyZJ.github.io/assets/16773586473283.jpg"><br><img src="/BboyZJ.github.io/assets/16773586635126.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理15：dyld源码分析</title>
      <link href="/BboyZJ.github.io/2020/10/10/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8615-1%EF%BC%9Adyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/"/>
      <url>/BboyZJ.github.io/2020/10/10/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8615-1%EF%BC%9Adyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文的目的主要是分析 <code>dyld</code> 的加载流程，了解在 <code>main</code> 函数之前，底层还做了什么</p><h1 id="印子"><a href="#印子" class="headerlink" title="印子"></a>印子</h1><ul><li>创建一个project，在ViewController中重写了 <code>load方法</code>，在main中加了一个 <code>C++方法</code>，即 <code>kcFUnc</code>，请问它们的打印先后顺序是什么？</li></ul><p>VC中代码：</p><p><img src="/BboyZJ.github.io/assets/16773526043566.jpg"></p><p>main.m 中实现：</p><p><img src="/BboyZJ.github.io/assets/16773526784175.jpg"></p><ul><li>运行程序，查看 <code>load、kcFunc、main的打印顺序</code>，下面是打印结果，通过结果可以看出其顺序是 <code>load --&gt; C++方法 --&gt; main</code></li></ul><p><img src="/BboyZJ.github.io/assets/16773527372947.jpg"></p><p>那么问题来了？为什么是这么一个顺序？按照常规的思维理解，main不是入口函数吗？为什么不是main最先执行？</p><p>下面根据这个问题，我们来探索在走到main之前，到底还做了什么。</p><h1 id="编译过程及库"><a href="#编译过程及库" class="headerlink" title="编译过程及库"></a>编译过程及库</h1><p>在分析app启动之前，我们需要先了解iOSapp代码的 <code>编译过程</code>以及 <code>动态库和静态库</code>。</p><h1 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h1><p>其中 <code>编译过程</code> 如下图所示，主要分为以下几步：</p><ul><li><code>源文件</code>：载入.h、.m、.cpp等文件</li><li><code>预处理</code>：替换宏，删除注释，展开头文件，产生.i文件</li><li><code>编译</code>：将.i文件转换为汇编语言，产生.s文件</li><li><code>汇编</code>：将汇编文件转换为机器码文件，产生.o文件</li><li><code>链接</code>：对.o文件中引用其他库的地方进行引用，生成最后的 <code>可执行文件 MachO</code></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-8a18b8027c825c1f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/943"></p><h1 id="静态库-和-动态库"><a href="#静态库-和-动态库" class="headerlink" title="静态库 和 动态库"></a>静态库 和 动态库</h1><ul><li><p><code>静态库</code>：在链接阶段，会将可汇编生成的目标程序与引用的库一起链接打包到可执行文件当中。此时的静态库就不会在改变了，因为它是 <code>编译时被直接拷贝一份，复制到目标程序里的</code></p><ul><li><p><code>好处</code>：编译完成后，库文件实际上就没有作用了，目标程序没有外部依赖，直接就可以运行</p></li><li><p><code>缺点</code>：由于静态库会有两份，所以会导致 <code>目标程序的体积增大</code>，对内存、性能、速度消耗很大</p></li></ul></li><li><p><code>动态库</code>：程序编译时并不会链接到目标程序中，目标程序只会存储指向动态库的引用，在 <code>程序运行时才被载入</code></p><ul><li><p><code>优势</code>：</p><ul><li><p><code>减少打包之后app的大小</code>：因为不需要拷贝至目标程序中，所以不会影响目标程序的体积，与静态库相比，减少了app的体积大小</p></li><li><p>共享内存，节约资源：同一份库可以被多个程序使用</p></li><li><p>通过 <code>更新动态库，达到更新程序</code> 的目的：由于运行时才载入的特性，可以随时对库进行替换，而不需要重新编译代码</p></li></ul></li><li><p><code>缺点</code>：动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境，如果环境缺少了动态库，或者库的版本不正确，就会导致程序无法运行</p></li></ul></li></ul><p>静态库和动态库的图示如图所示:</p><p><img src="https://upload-images.jianshu.io/upload_images/2251862-c74ad3d9bfccfcdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/725"></p><h1 id="dyld加载流程分析"><a href="#dyld加载流程分析" class="headerlink" title="dyld加载流程分析"></a>dyld加载流程分析</h1><p>根据 <code>dyld</code> 源码，以及 <code>libobjc、libSystem、libdispatch</code> 源码协同分析</p><ul><li>什么是dyld？</li></ul><p><code>dyld</code>（the dynamic link editor）是苹果的 <code>动态链接器</code>，是苹果操作系统的重要组成部分，在app被编译打包成可执行文件格式的 <code>Mach-O</code> 文件后，交由 <code>dyld负责连接，加载程序</code></p><p>所以 <code>App</code> 的启动流程图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/2251862-eb35a99515de2d5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/943"></p><h1 id="app启动的起始点"><a href="#app启动的起始点" class="headerlink" title="app启动的起始点"></a>app启动的起始点</h1><ul><li>在前文的demo中，在load方法处加一个断点，通过bt堆栈信息查看app启动是从哪里开始的</li></ul><p><img src="/BboyZJ.github.io/assets/16773536398151.jpg"></p><p>【app启动起点】：通过程序运行发现，是从 <code>dyld</code> 中的 <code>_dyld_start</code> 开始的，所以需要去 <a href="https://github.com/apple-oss-distributions/dyld/tags">OpenSource</a> 下载一份dyld的源码来进行分析</p><ul><li>也可以通过xcode左侧的堆栈信息来找到入口</li></ul><p><img src="/BboyZJ.github.io/assets/16773537621613.jpg"></p><h1 id="dyld-main函数源码分析"><a href="#dyld-main函数源码分析" class="headerlink" title="dyld::_main函数源码分析"></a>dyld::_main函数源码分析</h1><ul><li>在 <code>dyld-750.6</code> 源码中查找 <code>_dyld_start</code>,查找 <code>arm64架构</code> 发现，是由汇编实现，通过汇编注释发现会调用 <code>dyldbootstrap::start(app_mh, argc, argv, dyld_mh, &amp;startGlue)</code> 方法，是一个 <code>C++ </code>方法（以arm64架构为例）</li></ul><p><img src="/BboyZJ.github.io/assets/16773543591801.jpg"></p><ul><li>源码中搜索 <code>dyldbootstrap</code> 找到命名作用空间，再在这个文件中查找 <code>start</code> 方法，其核心是返回值的调用了 <code>dyld的main</code> 函数，其中 <code>macho_header</code> 是 <code>Mach-O</code> 的头部，而 <code>dyld</code> 加载的文件就是 <code>Mach-O</code> 类型的，即 <code>Mach-O</code> 类型是 <code>可执行文件类型</code>，由四部分组成：<code>Mach-O头部、Load Command、section、Other Data</code>，可以通过 <code>MachOView</code> 查看可执行文件信息</li></ul><p><img src="/BboyZJ.github.io/assets/16773545176271.jpg"></p><ul><li><p>进入 <code>dyld::_main</code> 的源码实现，特别长，大约600多行，如果对dyld加载流程不太了解的童鞋，可以根据 <code>_main</code> 函数的返回值进行反推，这里就多作说明。在 <code>_main</code> 函数中主要做了一下几件事情：</p><ul><li>【第一步：<code>环境变量配置</code>】：根据环境变量设置相应的值以及获取当前运行架构</li></ul><p>  <img src="/BboyZJ.github.io/assets/16773547387711.jpg"></p></li></ul><p><img src="/BboyZJ.github.io/assets/16773549811847.jpg"></p><p><img src="/BboyZJ.github.io/assets/16773550169856.jpg"></p><ul><li>【第二步：<code>共享缓存</code>】：检查是否开启了共享缓存，以及共享缓存是否映射到共享区域，例如 <code>UIKit、CoreFoundation</code> 等</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-d718ea23c090a716.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>【第三步：<code>主程序的初始化</code>】：调用 <code>instantiateFromLoadedImage</code> 函数实例化了一个<code>ImageLoader</code> 对象</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-3a5c0cf92a9eba94.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>【第四步：<code>插入动态库</code>】：遍历DYLD_INSERT_LIBRARIES环境变量，调用loadInsertedDylib加载</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-e144ed876b86fddd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>【第五步：<code>link 主程序</code>】</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-4ec20029836b1921.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>【第六步：<code>link 动态库</code>】</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-0f9136822af9abe6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>【第七步：<code>弱符号绑定</code>】</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-a66917606793296f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>【第八步：<code>执行初始化方法</code>】</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-b7c68c0bb73eddb8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>【第九步：<code>寻找主程序入口即main函数</code>】：从Load Command读取LC_MAIN入口，如果没有，就读取LC_UNIXTHREAD，这样就来到了日常开发中熟悉的main函数了</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-14553a73b073cb47.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><h1 id="下面主要分析下【第三步】和【第八步】"><a href="#下面主要分析下【第三步】和【第八步】" class="headerlink" title="下面主要分析下【第三步】和【第八步】"></a>下面主要分析下【第三步】和【第八步】</h1><ul><li><code>sMainExecutable</code> 表示主程序变量，查看其赋值，是通过 <code>instantiateFromLoadedImage</code> 方法初始化</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-de02e1d8ff385665.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>进入 <code>instantiateFromLoadedImage</code> 源码，其中创建 一个<code>ImageLoader</code> 实例对象，通过<code>instantiateMainExecutable</code> 方法创建</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-08f24fbf00245282.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>进入 <code>instantiateMainExecutable</code> 源码，其作用是为主可执行文件创建映像，返回一个<code>ImageLoader</code> 类型的image对象，即主程序。其中 <code>sniffLoadCommands</code> 函数时获取 <code>Mach-O</code> 类型文件的 <code>Load Command</code> 的相关信息，并对其进行各种校验</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-4f9ce223413a7dee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><h1 id="【第八步：执行初始化方法】"><a href="#【第八步：执行初始化方法】" class="headerlink" title="【第八步：执行初始化方法】"></a>【第八步：执行初始化方法】</h1><ul><li>进入 <code>initializeMainExecutable</code> 源码,主要是循环遍历，都会执行runInitializers方法</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-5febb85fb2010441.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>全局搜索 <code>runInitializers</code> (cons,找到如下源码，其核心代码是processInitializers函数的调用</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-f632f008f847362c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>进入 <code>processInitializers</code> 函数的源码实现，其中对镜像列表调用<code>recursiveInitialization</code> 函数进行递归实例化</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-39bcc061763427e7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>全局搜索recursiveInitialization(cons函数,其源码实现如下</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-5d69a52cde129280.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><p>在这里，需要分成两部分探索，一部分是notifySingle函数，一部分是doInitialization函数，首先探索notifySingle函数</p><h1 id="notifySingle-函数"><a href="#notifySingle-函数" class="headerlink" title="notifySingle 函数"></a>notifySingle 函数</h1><ul><li>全局搜索 <code>notifySingle</code>(函数,其重点是(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader());这句</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-ce8b1c6d82898ce0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>全局搜索 <code>sNotifyObjCInit</code>，发现没有找到实现，有赋值操作</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-79f4feb4181fcfb0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>搜索 <code>registerObjCNotifiers</code> 在哪里调用了，发现在 <code>_dyld_objc_notify_register</code> 进行了调用</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-2204bfde72cb324a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><p>注意：<code>_dyld_objc_notify_register</code> 的函数需要在 <code>libobjc</code> 源码中搜索</p><ul><li>在 <code>objc4-781</code> 源码中搜索 <code>_dyld_objc_notify_register</code>，发现在 <code>_objc_init</code> 源码中调用了该方法，并传入了参数，所以 <code>sNotifyObjCInit</code> 的赋值的就是 <code>objc</code> 中的<code>load_images</code>，而 <code>load_images</code> 会调用所有的 <code>+load</code> 方法。所以综上所述，<code>notifySingle</code> 是一个回调函数</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-d6cc44bd5a188b62.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><h1 id="load函数加载"><a href="#load函数加载" class="headerlink" title="load函数加载"></a>load函数加载</h1><p>下面我们进入 <code>load_images</code> 的源码看看其实现，以此来证明 <code>load_images</code> 中调用了所有的load函数</p><ul><li>通过objc源码中_objc_init源码实现，进入load_images的源码实现</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-31c73be771fd482b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>进入 <code>call_load_methods</code> 源码实现，可以发现其核心是通过 <code>do-while </code>循环调用 <code>+load</code> 方法</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-64fd9778a4df202f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>进入 <code>call_class_loads</code> 源码实现，了解到这里调用的 <code>load</code> 方法证实我们前文提及的类的load方法</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-9020a7e5b3d5c824.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><p>所以，<code>load_images</code> 调用了所有的 <code>load</code> 函数，以上的源码分析过程正好对应堆栈的打印信息</p><h1 id="【总结】"><a href="#【总结】" class="headerlink" title="【总结】"></a>【总结】</h1><p>load的源码链为：_dyld_start -&gt; dyldbootstrap::start -&gt; dyld::_main -&gt; dyld::initializeMainExecutable -&gt; ImageLoader::runInitializers -&gt; ImageLoader::processInitializers -&gt; ImageLoader::recursiveInitialization -&gt; dyld::notifySingle(是一个回调处理) -&gt; sNotifyObjCInit –&gt; load_images(libobjc.A.dylib)</p><p>那么问题又来了，<code>_objc_init</code> 是什么时候调用的呢？请接着往下看</p><h1 id="doInitialization-函数"><a href="#doInitialization-函数" class="headerlink" title="doInitialization 函数"></a>doInitialization 函数</h1><ul><li>走到 <code>objc</code> 的 <code>_objc_init</code> 函数，发现走不通了，我们回退到 <code>recursiveInitialization</code> 递归函数的源码实现，发现我们忽略了一个函数 <code>doInitialization</code></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-ec4a30b3e3d64738.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>进入doInitialization函数的源码实现</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-8005f3c8ca8be0ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><p>这里也需要分成两部分，一部分是 <code>doImageInit</code> 函数，一部分是 <code>doModInitFunctions</code> 函数</p><ul><li>进入 <code>doImageInit</code> 源码实现，其核心主要是for循环加载方法的调用，这里需要注意的一点是，libSystem的初始化必须先运行</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-39b5de27cb83e21c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>进入 <code>doModInitFunctions</code> 源码实现，这个方法中加载了所有 <code>Cxx</code> 文件</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-82cbaf86d0ebac6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><p>走到这里，还是没有找到_objc_init的调用？怎么办呢？放弃吗？当然不行，我们还可以通过_objc_init加一个符号断点来查看调用_objc_init前的堆栈信息，</p><ul><li><code>_objc_init</code> 加一个符号断点，运行程序，查看_objc_init断住后的堆栈信息</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-335d0b98450d5303.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>在libsystem中查找libSystem_initializer，查看其中的实现</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2251862-95dda0e83b493618.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200"></p><ul><li>根据前面的堆栈信息，我们发现走的是 <code>libSystem_initializer</code> 中会调用<code>libdispatch_init</code> 函数，而这个函数的源码是在 <code>libdispatch</code> 开源库中的，在libdispatch中搜索libdispatch_init</li></ul><p><img src="/BboyZJ.github.io/assets/16773564815157.jpg"></p><ul><li>进入 <code>_os_object_init</code> 源码实现，其源码实现调用了 <code>_objc_init</code> 函数</li></ul><p><img src="/BboyZJ.github.io/assets/16773565157725.jpg"></p><p>结合上面的分析，从初始化_objc_init注册的_dyld_objc_notify_register的参数2，即load_images，到sNotifySingle –&gt; sNotifyObjCInie&#x3D;参数2 到sNotifyObjcInit()调用，形成了一个闭环</p><p>所以可以简单的理解为sNotifySingle这里是添加通知即addObserver，_objc_init中调用_dyld_objc_notify_register相当于发送通知，即push，而sNotifyObjcInit相当于通知的处理函数，即selector</p><p>【总结】：_objc_init的源码链：_dyld_start –&gt; dyldbootstrap::start –&gt; dyld::_main –&gt; dyld::initializeMainExecutable –&gt; ImageLoader::runInitializers –&gt; ImageLoader::processInitializers –&gt; ImageLoader::recursiveInitialization –&gt; doInitialization –&gt;libSystem_initializer（libSystem.B.dylib） –&gt; _os_object_init（libdispatch.dylib） –&gt; _objc_init(libobjc.A.dylib)</p><h1 id="第九步：寻找主入口函数"><a href="#第九步：寻找主入口函数" class="headerlink" title="第九步：寻找主入口函数"></a>第九步：寻找主入口函数</h1><ul><li>汇编调试，可以看到显示来到 <code>+[ViewController load]</code> 方法</li></ul><p><img src="/BboyZJ.github.io/assets/16773566236678.jpg"></p><ul><li>继续执行，来到 kcFunc 的 <code>C++</code> 函数</li></ul><p><img src="/BboyZJ.github.io/assets/16773566403234.jpg"></p><ul><li>点击stepover,继续往下，跑完了整个流程，会回到 _dyld_start,然后调用main()函数,通过汇编完成main的参数赋值等操作</li></ul><p><img src="/BboyZJ.github.io/assets/16773566525978.jpg"></p><ul><li>dyld汇编源码实现</li></ul><p><img src="/BboyZJ.github.io/assets/16773566686988.jpg"></p><p><img src="/BboyZJ.github.io/assets/16773566739474.jpg"></p><p>所以，综上所述，最终dyld加载流程，如下图所示，图中也诠释了前文中的问题：为什么是load–&gt;Cxx–&gt;main的调用顺序</p><p><img src="/BboyZJ.github.io/assets/16773566869545.png"></p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理14-3：objc_msgSend之动态方法决议 &amp; 消息转发</title>
      <link href="/BboyZJ.github.io/2020/10/06/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8614-3%EF%BC%9Aobjc_msgSend%E4%B9%8B%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E5%86%B3%E8%AE%AE&amp;%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
      <url>/BboyZJ.github.io/2020/10/06/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8614-3%EF%BC%9Aobjc_msgSend%E4%B9%8B%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E5%86%B3%E8%AE%AE&amp;%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>在前面两篇文章中，分别分析了 <code>objc_msgSend</code> 的 <code>快速查找(缓存)</code> 和 <code>慢速查找(方法列表)</code>，其整个流程：</p><ul><li><p>objc_msgSend -&gt; 慢速缓存查找(没有) -&gt; 慢速方法列表二分查找自己(有) -&gt; cache_fill -&gt; objc_msgSend 整个闭环</p></li><li><p>慢速方法列表二分查找没有找到 -&gt; 父类去查找（缓存 -&gt; 方法列表） -&gt; 根类（NSObject）也没找到</p></li></ul></li><li><p>在这两种方法都没找到方法实现的情况下，苹果给了两条建议</p><ul><li><code>动态方法决议</code>：慢速查找流程未能找到，会执行一次动态方法决议</li><li><code>消息转发</code>：如果动态方法决议仍然没有找到实现，则进行消息转发</li></ul></li><li><p>如果这两个建议都没有作出任何操作，就会报我们日常开发中常见的 <code>方法未实现</code> 的 <code>崩溃报错</code>，其步骤如下</p></li><li><p>定义 <code>ZJPerson</code> 类，其中 <code>say666</code> 实例方法 和 <code>sayNB</code> 类方法均没有实现</p></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160738005-3064bf19-52a0-4e72-86ac-b690230edae3.jpg"></p><ul><li>调用类方法 <code>sayNB</code> 的报错结果</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160738017-fab9216b-52d1-4cb9-9807-e96446ad57a5.jpg"></p><h1 id="方法未实现报错源码"><a href="#方法未实现报错源码" class="headerlink" title="方法未实现报错源码"></a>方法未实现报错源码</h1><p>根据 <code>慢速查找</code> 的源码，我们发现，其报错最后都是走到 <code>__objc_msgForward_impcache</code> 方法，本质是调用的 <code>objc_defaultForwardHandler</code> 方法</p><p>下面我们来讲讲如何在崩溃前，防止方法未实现的崩溃</p><h1 id="三次方法查找的挽救机会"><a href="#三次方法查找的挽救机会" class="headerlink" title="三次方法查找的挽救机会"></a>三次方法查找的挽救机会</h1><p>根据苹果建议，我们一共有三次挽救的机会：</p><ul><li><p>【第一次机会】：<code>动态方法决议</code></p></li><li><p>消息转发流程：</p><ul><li>【第二次机会】：<code>快速转发</code></li><li>【第三次机会】：<code>慢速转发</code></li></ul></li></ul><h1 id="【第一次机会】动态方法决议"><a href="#【第一次机会】动态方法决议" class="headerlink" title="【第一次机会】动态方法决议"></a>【第一次机会】动态方法决议</h1><p>在 <code>慢速查找</code> 流程 <code>未找到</code> 方法实现时，首先会 <code>尝试一次动态方法决议</code>，其源码实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static NEVER_INLINE IMP</span><br><span class="line">resolveMethod_locked(id inst, SEL sel, Class cls, int behavior)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line">    // 对象 -&gt; 类</span><br><span class="line">    if (! cls-&gt;isMetaClass()) &#123; // 类不是元类，调用对象的解析方法</span><br><span class="line">        // try [cls resolveInstanceMethod:sel]</span><br><span class="line">        resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123; // 如果是元类，调用类的解析方法，类 -&gt; 元类</span><br><span class="line">        // try [nonMetaClass resolveClassMethod:sel]</span><br><span class="line">        // and [cls resolveInstanceMethod:sel]</span><br><span class="line">        resolveClassMethod(inst, sel, cls);</span><br><span class="line">        // 为什么要有这行代码？ -&gt; 类方法在元类中是对象方法，所以还是需要查询元类中对象方法的动态方法决议</span><br><span class="line">        if (!lookUpImpOrNil(inst, sel, cls)) &#123; // 如果没有找到或者为空，在元类的对象方法解析方法中查找</span><br><span class="line">            resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // chances are that calling the resolver have populated the cache</span><br><span class="line">    // so attempt using it</span><br><span class="line">    // 如果方法解析中奖其实现指向其他方法，则继续走方法查找流程</span><br><span class="line">    return lookUpImpOrForward(inst, sel, cls, behavior | LOOKUP_CACHE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要分为以下几个步骤</strong></p><ul><li><p>判断类是否是元类</p><ul><li>如果是 <code>类</code>，执行 <code>实例方法</code> 的动态方法决议 <code>resolveInstanceMethod</code></li><li>如果是 <code>元类</code>，执行 <code>类方法</code> 的动态方法决议 <code>resolveClassMethod</code>，如果在元类中 <code>没有找到</code> 或者为 <code>空</code>，则在 <code>元类</code> 的 <code>实例方法</code> 的动态方法决议 <code>resolveInstanceMethod</code> 中查找，主要是因为 <code>类方法在元类中是实例方法</code>，所以还需要查找元类中实例方法的动态方法决议</li></ul></li><li><p>如果 <code>动态方法决议</code> 中，将其 <code>实现指向了其他方法</code>，则继续 <code>查找指定的imp</code>，即继续慢速查找 <code>lookupImpOrForward</code></p></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160738052-60f95902-119f-4f7e-a3a0-58db0f42dc52.png"></p><h1 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h1><p>针对 <code>实例方法</code> 调用，在 <code>快速、慢速查找</code> 均没有找到 <code>实例方法</code> 的实现时，我们有一次挽救的机会，即尝试一次 <code>动态方法决议</code>，由于是 <code>实例方法</code>，所以会走到 <code>resolveInstanceMethod</code> 方法，其源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static void resolveInstanceMethod(id inst, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    SEL resolve_sel = @selector(resolveInstanceMethod:);</span><br><span class="line"></span><br><span class="line">    // look的是 resolveInstanceMethod 相当于是发送消息前的容错处理</span><br><span class="line">    if (!lookUpImpOrNil(cls, resolve_sel, cls-&gt;ISA())) &#123;</span><br><span class="line">        // Resolver not implemented.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    bool resolved = msg(cls, resolve_sel, sel); // 发送resolve_sel消息</span><br><span class="line"></span><br><span class="line">    // Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span><br><span class="line">    // +resolveInstanceMethod adds to self a.k.a. cls</span><br><span class="line">    // 查找say666</span><br><span class="line">    IMP imp = lookUpImpOrNil(inst, sel, cls);</span><br><span class="line"></span><br><span class="line">    if (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        if (imp) &#123;</span><br><span class="line">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</span><br><span class="line">                         &quot;dynamically resolved to %p&quot;, </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#x27;+&#x27; : &#x27;-&#x27;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // Method resolver didn&#x27;t add anything?</span><br><span class="line">            _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</span><br><span class="line">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#x27;+&#x27; : &#x27;-&#x27;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要分为以下几个步骤</p><ul><li><p>在 <code>发送resolveInstanceMethod消息</code> 前，需要查找 <code>cls类</code> 中是否有该方法的 <code>实现</code>，即通过 <code>lookupImpOrNil</code> 方法又会进入 <code>lookupImpOrForward</code> 慢速查找流程查找 <code>resolveInstanceMethod</code> 方法</p><ul><li>如果没有，则直接返回</li><li>如果有，则发送 <code>resolveInstanceMethod</code> 消息</li></ul></li><li><p>再次慢速查找实例方法的实现，即通过 <code>lookupImpOrNil</code> 方法又会进入 <code>lookupImpOrForward</code> 慢速查找流程查找 <code>实例方法</code></p></li></ul><p><strong>崩溃修改</strong></p><p>所以，针对 <code>实例方法sya666</code> 未实现的报错崩溃，可以通过在 <code>类</code> 中 <code>重写resolveInstanceMethod类方法</code>，并将其指向其他方法的实现，即在 <code>ZJPerson</code> 中 <code>重写resolveInstanceMethod类方法</code>，将 <code>实例方法sya666</code> 的实现指向 <code>sayMaster</code> 方法实现，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">- (void)say666;</span><br><span class="line">- (void)sayMaster;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ZJPerson</span><br><span class="line">- (void)sayMaster&#123;</span><br><span class="line">    NSLog(@&quot;say666&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 重写resolveInstanceMethod</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    if (sel == @selector(say666)) &#123;</span><br><span class="line">        NSLog(@&quot;%@ 来了&quot;,NSStringFromSelector(sel));</span><br><span class="line">        // 获取sayMaster方法的imp</span><br><span class="line">        IMP imp = class_getMethodImplementation(self, @selector(sayMaster));</span><br><span class="line">        // 获取sayMaster的实例方法</span><br><span class="line">        Method sayMethod = class_getInstanceMethod(self, @selector(sayMaster));</span><br><span class="line">        // 获取sayMaster的丰富签名</span><br><span class="line">        const char * type = method_getTypeEncoding(sayMethod);</span><br><span class="line">        // 将sel的实现指向sayMaster</span><br><span class="line">        return class_addMethod(self, sel, imp, type);</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>重新运行，其打印结果如下：</p><p><img src="https://user-images.githubusercontent.com/25925248/160738074-7ccad015-b3d3-41f4-817e-ad335c4e2763.jpg"></p><h1 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h1><p>针对 <code>类方法</code>，与实例方法类似，同样可以通过重写 <code>resolveClassMethod</code> 类方法来解决前文的崩溃问题，即在 <code>ZJPerson</code> 类中重写该方法，并将 <code>sayNB</code> 类方法的实现 <code>指向类方法zjClassMethod</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">+ (void)sayNB;</span><br><span class="line">+ (void)zjClassMethod;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ZJPerson</span><br><span class="line">+ (void)zjClassMethod&#123;</span><br><span class="line">    NSLog(@&quot;sayNB&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel&#123;</span><br><span class="line">    if (sel == @selector(sayNB)) &#123;</span><br><span class="line">        NSLog(@&quot;%@ 来了&quot;,NSStringFromSelector(sel));</span><br><span class="line">        </span><br><span class="line">        IMP imp = class_getMethodImplementation(objc_getMetaClass(&quot;ZJPerson&quot;), @selector(zjClassMethod));</span><br><span class="line">        Method zjClassMethod = class_getInstanceMethod(objc_getMetaClass(&quot;ZJPerson&quot;), @selector(zjClassMethod));</span><br><span class="line">        const char * type = method_getTypeEncoding(zjClassMethod);</span><br><span class="line">        return class_addMethod(objc_getMetaClass(&quot;ZJPerson&quot;), sel, imp, type);</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>resolveClassMethod</code> 类方法的重写需要注意一点，传入的 <code>cls</code> 不再是类，而是 <code>元类</code>，可以通过 <code>objc_getMetaClass</code> 方法 <code>获取元类</code>，原因是因为 <code>类方法在元类中是实例方法</code></p><p><strong>优化</strong></p><p>上面的这种方式是单独再每个类中重写，有没有更好的，一劳永逸的方法呢？其实通过方法慢速查找流程可以发现其查找路径有两条</p><ul><li>实例方法：<code>类 -&gt; 父类 -&gt; 根类 -&gt; nil</code></li><li>类方法：<code>元类 -&gt; 根元类 -&gt; 根类 -&gt; nil</code></li></ul><p>它们的共同点是如果前面没找到，都会来到 <code>根类即NSObject中查找</code>，所以我们是否可以将上述的两个方法统一整合在一起呢？答案是 <code>可以的</code>，可以通过 <code>NSObject添加分类</code> 的方式来 实现同意处理，而且由于类方法的查找，在其集成链，查找的也是实例方法，所以将 <code>实例方法</code> 和 <code>类方法</code> 的统一处理放在 <code>resolveInstanceMethod</code> 方法中，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (ZJ)</span><br><span class="line">@end</span><br><span class="line">@implementation NSObject (ZJ)</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    if (sel == @selector(say666)) &#123;</span><br><span class="line">        NSLog(@&quot;%@ 来了&quot;,NSStringFromSelector(sel));</span><br><span class="line">        </span><br><span class="line">        IMP imp = class_getMethodImplementation(self, @selector(sayMaster));</span><br><span class="line">        Method sayMethod  = class_getInstanceMethod(self, @selector(sayMaster));</span><br><span class="line">        const char *type = method_getTypeEncoding(sayMethod);</span><br><span class="line">        return class_addMethod(self, sel, imp, type);</span><br><span class="line">    &#125;else if (sel == @selector(sayNB))&#123;</span><br><span class="line">        NSLog(@&quot;%@ 来了&quot;,NSStringFromSelector(sel));</span><br><span class="line">        </span><br><span class="line">        IMP imp = class_getMethodImplementation(objc_getMetaClass(&quot;ZJPerson&quot;), @selector(zjClassMethod));</span><br><span class="line">        Method zjClassMethod = class_getInstanceMethod(objc_getMetaClass(&quot;ZJPerson&quot;), @selector(zjClassMethod));</span><br><span class="line">        const char * type = method_getTypeEncoding(zjClassMethod);</span><br><span class="line">        return class_addMethod(objc_getMetaClass(&quot;ZJPerson&quot;), sel, imp, type);</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这样方式的实现，正好与源码中针对类方法的处理逻辑是一致的，即完美阐述为什么调用了类方法动态方法决议，还要调用对象方法的动态方法决议，其根本原因还是 <code>类方法在元类中的实例方法</code></p><p>当然，上面这种写法还是会有其他问题，比如 <code>系统方法也会被更改</code>，针对这一点，是可以优化的，即我们 <code>可以针对自定义类中方法同意方法名的前缀</code>，根据前缀来判断是否是自定义方法，然后 <code>统一处理自定义方法</code>，例如可以在崩溃前pop到首页，主要是用于 <code>app线上防崩溃的处理</code>，提升用户的体验</p><h1 id="消息转发流程"><a href="#消息转发流程" class="headerlink" title="消息转发流程"></a>消息转发流程</h1><p>在慢速查找的流程中，我们了解到，如果快速+慢速没有找到方法实现，动态方法决议也不行，就使用 <code>消息转发</code>，但是，我们找遍了源码也没有发现消息转发的相关源码，可以通过以下方式来了解，方法调用崩溃前都走了哪些方法</p><ul><li>通过 <code>instrumentObjcMessageSends</code> 方式打印发小消息的日志</li><li>通过 <code>hopper/IDA反编译</code></li></ul><p><strong>通过 <code>instrumentObjcMessageSends</code></strong></p><ul><li><p>通过 <code>lookUpImpOrForward -&gt; log_and_fill_cache -&gt; logMessageSend</code>，在logMessageSend源码下方找到 <code>instrumentObjcMessageSends</code> 的源码实现，在main中调用 <code>instrumentObjcMessageSends</code> 打印方法调用的日志信息，有以下两点准备工作</p><ul><li>打开 <code>objcMsgLogEnabled</code> 开关，即调用 <code>instrumentObjcMessageSends</code> 方法时，传入 <code>YES</code></li><li>在 <code>main</code> 中通过 <code>extern</code> 声明 <code>instrumentObjcMessageSends</code> 方法</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extern void instrumentObjcMessageSends(BOOL flag);</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    NSString * appDelegateClassName;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">        ZJPerson * person = [ZJPerson alloc];</span><br><span class="line">        instrumentObjcMessageSends(YES);</span><br><span class="line">        [person sayHello];</span><br><span class="line">        instrumentObjcMessageSends(NO);</span><br><span class="line">        </span><br><span class="line">        appDelegateClassName = NSStringFromClass([AppDelegate class]);</span><br><span class="line">    &#125;</span><br><span class="line">    return UIApplicationMain(argc, argv, nil, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 <code>logMessageSend</code> 源码，了解到消息发送打印信息存储在 <code>/tmp/msgSends</code> 目录，如下所示：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160738092-a469b37f-7f85-4b49-993e-600fa3af2e36.jpg"></p><ul><li><p>运行代码，并前往 <code>/tmp/msgSends/</code> 目录，发现有 <code>msgSends</code> 开头的日志文件，打开发现崩溃前，执行了以下方法：</p><ul><li>两次 <code>动态方法决议</code>：<code>resolveInstanceMethod</code> 方法</li><li>两次 <code>消息快速转发</code>：<code>forwardingTargetForSelector</code> 方法</li><li>两次 <code>消息慢速转发</code>：<code>methodSignatureForSelector + resolveInvocation</code></li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160738104-4c3db372-a49a-49fd-b0e3-af5ca67be264.jpg"></p><h1 id="通过hopper-x2F-IDA反编译"><a href="#通过hopper-x2F-IDA反编译" class="headerlink" title="通过hopper&#x2F;IDA反编译"></a>通过hopper&#x2F;IDA反编译</h1><p><code>Hopper</code> 和 <code>IDA</code> 是一个可以帮助我们静态分析可视性文件的工具，可以将执行文件反编译成伪代码、控制流程图等，下面以Hopper为例（注：hopper高级版本是一款收费软件，针对比较简单的反汇编需求来说，demo版本足够使用了）</p><ul><li>运行程序崩溃，查看堆栈信息</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160738113-c16458dd-f33c-4c76-b067-3cf03fc08e53.jpg"></p><ul><li><p>发现 <code>__forwarding__</code> 来自 <code>CoreFoundation</code></p></li><li><p>通过 <code>image list</code>，读取整个镜像文件，然后搜索 <code>CoreFoundation</code>，查看其可执行文件的路径</p></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160738122-f3e69bce-b246-42ee-96e5-18be8438f605.jpg"></p><ul><li>通过文件路径，找到 <code>CoreFoundation</code> 的 <code>可执行文件</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160738157-0cacaeef-0424-4d8d-877b-ac1b5e4f33fa.jpg"></p><ul><li>打开hopper，选择<code>Try the Demo</code>，然后将上一步的可执行文件拖入hopper进行反汇编，选择x86(64 bits)</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160738181-472df11c-e67a-4666-85dd-88f32f3ae2b3.png"></p><p><img src="https://user-images.githubusercontent.com/25925248/160738568-0db789cc-0fe2-4dfe-8b4b-3f924cc2b3f3.png"></p><ul><li>以下是反汇编后的界面，主要使用上面的三个功能，分别是 汇编、流程图、伪代码</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160738584-55203118-a8b2-43f9-972e-feeb3e0d62e0.png"></p><ul><li><p>通过左侧的搜索框搜索<code>__forwarding_prep_0___</code>，然后选择伪代码</p><ul><li>以下是<code>__forwarding_prep_0___</code>的汇编伪代码，跳转至<code>___forwarding___</code></li></ul><p>  <img src="https://user-images.githubusercontent.com/25925248/160738593-c966413f-18e4-4b0b-8766-e591b3d81fe3.png"></p></li><li><p>以下是___forwarding___的伪代码实现，首先是查看是否实现forwardingTargetForSelector方法，如果没有响应，跳转至loc_6459b即快速转发没有响应，进入慢速转发流程</p></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160738606-53b208ed-9318-42fe-b6b6-e71a6a3f9409.png"></p><ul><li>跳转至loc_6459b，在其下方判断是否响应methodSignatureForSelector方法</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160738623-d533b9ac-21c7-4a71-880d-002db4f9bdc6.png"></p><ul><li><p>如果没有响应，跳转至loc_6490b，则直接报错</p></li><li><p>如果获取methodSignatureForSelector的方法签名为nil，也是直接报错</p></li><li><p>如果methodSignatureForSelector返回值不为空，则在forwardInvocation方法中对invocation进行处理</p></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/160738647-cc646ab1-c641-473e-9036-123f395753bf.png"></p><p>所以，通过上面两种查找方式可以验证，<code>消息转发</code> 的方法有3个</p><ul><li>【快速转发】<code>forwardingTargetForSelector</code></li><li>【慢速转发】<ul><li><code>methodSignatureForSelector</code></li><li><code>forwardInvocation</code></li></ul></li></ul><p>所以，综上所述，消息转发整体的流程如下</p><p><img src="https://user-images.githubusercontent.com/25925248/160738656-1bafa395-aba4-43a0-a57f-6e3e446b4816.png"></p><p><code>消息转发</code> 的处理主要分为两部分：</p><ul><li><p>【快速转发】当慢速查找以及动态方法决议没有找到实现时，进行消息转发，首先是进行 <code>快速消息转发</code>，即走到 <code>forwardingTargetForSelector</code> 方法</p><ul><li><p>如果返回 <code>消息接收者</code>，在消息接收者中还是没有找到，则进入另一个方法的查找流程</p></li><li><p>如果返回 <code>nil</code>，则进入 <code>慢速消息转发</code></p></li></ul></li><li><p>【慢速转发】执行到 <code>methodSignalForSelector</code> 方法</p><ul><li><p>如果返回的 <code>方法签名</code> 为 <code>nil</code>，则直接 <code>崩溃报错</code></p></li><li><p>如果返回的方法签名 <code>不为nil</code>，走到 <code>forwardInvocation</code> 方法中，对invocation事务进行处理，如果不处理也不会报错</p></li></ul></li></ul><h1 id="【第二次机会】快速转发"><a href="#【第二次机会】快速转发" class="headerlink" title="【第二次机会】快速转发"></a>【第二次机会】快速转发</h1><p>针对前文的崩溃问题，如果 <code>动态方法决议</code> 也没有找到方法实现，则需要在 <code>ZJPerson</code> 中重写 <code>forwardingTargetForSelector</code> 方法，将ZJPerson的实例方法的 <code>接收者指定为ZJStudent</code> 的对象（ZJStudent类中有say666的具体实现），如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// ZJPerson类</span><br><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">- (void)say666;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJPerson</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    NSLog(@&quot;%s - %@&quot;,__func__,NSStringFromSelector(aSelector));</span><br><span class="line">    </span><br><span class="line">    // 将消息接收者指定为ZJStudent，在ZJStudent中查找say666的实现</span><br><span class="line">    return [ZJStudent alloc];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// ZJStudent类</span><br><span class="line">@interface ZJStudent : NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation ZJStudent</span><br><span class="line">- (void)say666&#123;</span><br><span class="line">    NSLog(@&quot;say666&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// main中</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        ZJPerson * person = [ZJPerson new];</span><br><span class="line">        [person say666];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果如下</p><p><img src="https://user-images.githubusercontent.com/25925248/160738861-db408803-b9af-42e0-a65d-bea01d919c16.jpg"></p><p>也可以直接不指定消息接收者，<code>直接调用父类的该方法</code>，如果还是没有找到，则 <code>直接报错</code></p><p><img src="https://user-images.githubusercontent.com/25925248/160738865-5f2391a1-5b6d-49d3-9f26-ee516228812c.jpg"></p><h1 id="【第三次机会】慢速转发"><a href="#【第三次机会】慢速转发" class="headerlink" title="【第三次机会】慢速转发"></a>【第三次机会】慢速转发</h1><p>针对 <code>第二次机会即快速转发</code> 中还是没有找到，则进入最后的一次挽救机会，即在 <code>ZJPerson</code> 中重写 <code>methodSignalForSelector</code>，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 慢速转发</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">    NSLog(@&quot;%s - %@&quot;,__func__,NSStringFromSelector(aSelector));</span><br><span class="line">    </span><br><span class="line">    return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</span><br><span class="line">    NSLog(@&quot;%s - %@&quot;,__func__,anInvocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下，发现 <code>forwardInvocation</code> 方法中不对 <code>invocation</code> 进行处理，也不会崩溃</p><p><img src="https://user-images.githubusercontent.com/25925248/160738890-7671f770-8192-4d6d-9c19-05813459c1cf.jpg"></p><p>也可以 <code>处理invocation</code> 事务，如下所示，修改 <code>invocation</code> 的 <code>target</code> 为 <code>[ZJStudent alloc]</code>，调用 <code>[anInvocation invoke]</code> 触发 <code>即ZJPerson</code> 类的 <code>say666</code> 实例方法的调用会调用 <code>ZJStudent</code> 的 <code>say666</code> 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</span><br><span class="line">    NSLog(@&quot;%s - %@&quot;,__func__,anInvocation);</span><br><span class="line">    anInvocation.target = [ZJStudent alloc];</span><br><span class="line">    [anInvocation invoke];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下</p><p><a href="https://user-images.githubusercontent.com/25925248/160738899-270d3fb2-e047-4f64-a962-23b5278f8ddd.jpg">https://user-images.githubusercontent.com/25925248/160738899-270d3fb2-e047-4f64-a962-23b5278f8ddd.jpg</a></p><p>所以，由上述可知，无论在 <code>forwardInvocation</code> 方法中 <code>是否处理invocation</code> 事务，<code>程序都不会崩溃</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到目前为止，objc_msgSend 发送消息的流程就分析完成了，在这里简单总结下</p><ul><li><p>【快速查找流程】在类的 <code>缓存cache</code> 中查找指定方法的实现</p></li><li><p>【慢速查找流程】如果缓存中 <code>没有找到</code>，则在 <code>类的方法列表</code> 中查找，如果还是没有找到，则去 <code>父类的缓存和方法列表中</code> 查找</p></li><li><p>【动态方法决议】如果慢速查找 <code>还是没有找到</code>，第一次挽救的机会就是 <code>尝试一次动态方法决议</code>，即 <code>重写resolveInstanceMethod/resolveClassMethod</code> 方法</p></li><li><p>【消息转发】如果动态方法决议还是没有找到，则进行 <code>消息转发</code>，消息转发中有 <code>两次挽救几会：快速转发+慢速转发</code></p></li><li><p>如果转发之后也没有，则程序直接报错崩溃 <code>unrecognized selector sent to instance</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理14-2：objc_msgSend方法列表查找(快速查找)汇编分析</title>
      <link href="/BboyZJ.github.io/2020/10/05/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8614-2%EF%BC%9Aobjc_msgSend%E6%96%B9%E6%B3%95%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE(%E6%85%A2%E9%80%9F%E6%9F%A5%E6%89%BE)%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90/"/>
      <url>/BboyZJ.github.io/2020/10/05/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8614-2%EF%BC%9Aobjc_msgSend%E6%96%B9%E6%B3%95%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE(%E6%85%A2%E9%80%9F%E6%9F%A5%E6%89%BE)%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一章我们了解了 <code>objc_msgSend消息发送慢速查找流程</code> 即 <code>缓存CacheLookup查找</code></p><p>这一章我们来学习 <code>objc_msgSend消息发送慢速查找流程</code> 即  <code>MethodTableLookup(即查询方法列表)</code></p><h1 id="方法列表查找汇编分析"><a href="#方法列表查找汇编分析" class="headerlink" title="方法列表查找汇编分析"></a>方法列表查找汇编分析</h1><p>在 <code>缓存CacheLookup查找</code> 过程中，如果没有找到方法实现，无论是走到 <code>CheckMiss</code> 还是 <code>JumpMiss</code>，最终都会走到 <code>__objc_msgSend_uncached</code> 汇编函数</p><ul><li>在 <code>objc-msg-ram64.s</code> 文件中查找 <code>__objc_msgSend_uncached</code> 的汇编实现，其中的核心是 <code>MethodTableLookup(即查询方法列表)</code> ，其源码如下：</li></ul><p><strong>__objc_msgSend_uncached源码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line">// THIS IS NOT A CALLABLE C FUNCTION</span><br><span class="line">// Out-of-band p16 is the class to search</span><br><span class="line"></span><br><span class="line">// 开始查询方法列表</span><br><span class="line">MethodTableLookup </span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure><ul><li>搜索 <code>MethodTableLookup</code> 的汇编实现，其中的核心是 <code>_lookUpImpOrForward</code>，汇编源码实现如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">.macro MethodTableLookup</span><br><span class="line"></span><br><span class="line">// push frame</span><br><span class="line">SignLR</span><br><span class="line">stpfp, lr, [sp, #-16]!</span><br><span class="line">movfp, sp</span><br><span class="line"></span><br><span class="line">// save parameter registers: x0..x8, q0..q7</span><br><span class="line">subsp, sp, #(10*8 + 8*16)</span><br><span class="line">stpq0, q1, [sp, #(0*16)]</span><br><span class="line">stpq2, q3, [sp, #(2*16)]</span><br><span class="line">stpq4, q5, [sp, #(4*16)]</span><br><span class="line">stpq6, q7, [sp, #(6*16)]</span><br><span class="line">stpx0, x1, [sp, #(8*16+0*8)]</span><br><span class="line">stpx2, x3, [sp, #(8*16+2*8)]</span><br><span class="line">stpx4, x5, [sp, #(8*16+4*8)]</span><br><span class="line">stpx6, x7, [sp, #(8*16+6*8)]</span><br><span class="line">strx8,     [sp, #(8*16+8*8)]</span><br><span class="line"></span><br><span class="line">// lookUpImpOrForward(obj, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER)</span><br><span class="line">// receiver and selector already in x0 and x1</span><br><span class="line">movx2, x16</span><br><span class="line">movx3, #3</span><br><span class="line">bl_lookUpImpOrForward // 核心源码</span><br><span class="line"></span><br><span class="line">// IMP in x0</span><br><span class="line">movx17, x0</span><br><span class="line"></span><br><span class="line">// restore registers and return</span><br><span class="line">ldpq0, q1, [sp, #(0*16)]</span><br><span class="line">ldpq2, q3, [sp, #(2*16)]</span><br><span class="line">ldpq4, q5, [sp, #(4*16)]</span><br><span class="line">ldpq6, q7, [sp, #(6*16)]</span><br><span class="line">ldpx0, x1, [sp, #(8*16+0*8)]</span><br><span class="line">ldpx2, x3, [sp, #(8*16+2*8)]</span><br><span class="line">ldpx4, x5, [sp, #(8*16+4*8)]</span><br><span class="line">ldpx6, x7, [sp, #(8*16+6*8)]</span><br><span class="line">ldrx8,     [sp, #(8*16+8*8)]</span><br><span class="line"></span><br><span class="line">movsp, fp</span><br><span class="line">ldpfp, lr, [sp], #16</span><br><span class="line">AuthenticateLR</span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>由汇编源码可知，最终跳转到 <code>bl _lookUpImpOrForward</code> 中</p><p><strong>验证</strong></p><p>上述汇编的过程，可以通过 <code>汇编调式来验证</code></p><ul><li>在 <code>main</code> 中，例如 <code>[person sayNB]</code> 对象方法调用处加一个断点，并且开启汇编调试 <code>Debug -&gt; Debug workflow -&gt; 勾选 Always show Disassembly</code>，运行程序</li></ul><p><img src="/BboyZJ.github.io/assets/16773270692128.jpg"></p><ul><li>汇编中 <code>objc_msgSend</code> 加一个断点，执行断住，按住 <code>control + stepinto</code>，进入 <code>objc_msgSend</code> 的汇编</li></ul><p><img src="/BboyZJ.github.io/assets/16773484995345.jpg"></p><ul><li>在 <code>_objc_msgSend_uncached</code> 加一个断点，执行断住，按住 <code>control + stepinto</code>，进入汇编</li></ul><p><img src="/BboyZJ.github.io/assets/16773485313190.jpg"></p><p>从上面可以看出最后走到的就是 <code>lookUpImpOrForward</code> ，此时并不是汇编实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line">1、C/C++中调用汇编，去查找汇编时，C/C++调用的方法需要 `多加一个下划线`</span><br><span class="line">2、汇编中调用C/C++方法时，去查找C/C++方法，需要将汇编调用的 `方法去掉一个下划线`</span><br></pre></td></tr></table></figure><h1 id="MethodTableLookup-即查询方法列表-慢速查找-C-x2F-C-部分"><a href="#MethodTableLookup-即查询方法列表-慢速查找-C-x2F-C-部分" class="headerlink" title="MethodTableLookup(即查询方法列表)慢速查找 C&#x2F;C++ 部分"></a>MethodTableLookup(即查询方法列表)慢速查找 C&#x2F;C++ 部分</h1><ul><li>根据汇编部分的提示全局搜索 <code>lookUpImpOrForward</code>，最后在 <code>objc-runtime-new.mm </code>文件中找到了源码实现，这是一个 <code>c实现的函数</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)</span><br><span class="line">&#123;</span><br><span class="line">    // 定义的消息转发</span><br><span class="line">    const IMP forward_imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    Class curClass;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     快速查找，如果找到则直接返回imp</span><br><span class="line">     目的：防止多线程操作时，刚好调用函数，此时缓存进来了</span><br><span class="line">     */</span><br><span class="line">    if (fastpath(behavior &amp; LOOKUP_CACHE)) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        if (imp) goto done_nolock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 加锁，目的是保证读取的线程安全</span><br><span class="line">    runtimeLock.lock();</span><br><span class="line"></span><br><span class="line">    // 判断是否是一个已知的类：判断当前类是否已经被认可的类，即已经加载的类</span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line"></span><br><span class="line">    // 判断类是否实现，如果没有，需要先实现，此时的目的是为了确保父类链，方法后续的循环</span><br><span class="line">    if (slowpath(!cls-&gt;isRealized())) &#123;</span><br><span class="line">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断类是否初始化，如果没有，需要先初始化</span><br><span class="line">    if (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</span><br><span class="line">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    curClass = cls;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     查找类的缓存</span><br><span class="line">     unreasonableClassCount 表示类的迭代上限</span><br><span class="line">     猜测这里递归的原因是attempts在第一次循环时做了减一操作，然后再次循环时</span><br><span class="line">     仍在上限范围内，所以可以继续递归</span><br><span class="line">     */</span><br><span class="line">    for (unsigned attempts = unreasonableClassCount();;) &#123;</span><br><span class="line">        // 当前类方法列表（采用二分查找算法），如果找到，则返回，将方法缓存到cache中</span><br><span class="line">        Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        if (meth) &#123;</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">        // 当前类 = 当前类的父类，并判断父类是否为nil</span><br><span class="line">        if (slowpath((curClass = curClass-&gt;superclass) == nil)) &#123;</span><br><span class="line">            // 未找到方法实现，方法解析器也不行，使用转发</span><br><span class="line">            imp = forward_imp;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果父类链中存在循环，则停止</span><br><span class="line">        if (slowpath(--attempts == 0)) &#123;</span><br><span class="line">            _objc_fatal(&quot;Memory corruption in class list.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 父类缓存</span><br><span class="line">        imp = cache_getImp(curClass, sel);</span><br><span class="line">        if (slowpath(imp == forward_imp)) &#123;</span><br><span class="line">            // 如果在父类中找到了forward，则停止查找，且不缓存，首先调用此类的方法解析器</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (fastpath(imp)) &#123;</span><br><span class="line">            // 如果在父类中，找到了此方法，将其存储到cache中</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果没找到方法，尝试一次方法解析</span><br><span class="line">    if (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">        // 动态方法决议的控制条件，便是流程只走一次</span><br><span class="line">        behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">        return resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    // 存储到缓存</span><br><span class="line">    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">    // 解锁</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"> done_nolock:</span><br><span class="line">    if (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其整体的慢速查找流程如下图：</p><p><img src="https://user-images.githubusercontent.com/25925248/160737577-4f61e4bd-e246-4a8f-843d-71f2eb401cfc.png"></p><p>主要有以下几步：</p><ul><li><p>【第一步】<code>cache</code> 缓存中进行查找，即 <code>快速查找</code>，找到则直接返回 <code>imp</code>，反之，则进入【第二步】</p></li><li><p>【第二步】判断 <code>cls</code></p><ul><li><p>是否是 <code>已知类</code>，如果不是，则 <code>报错</code></p></li><li><p>类是否 <code>实现</code>，如果没有，则需要先实现，确定其父类链，此时实例化的目的是为了确定父类链、ro、以及rw等，方法后续数据的读取以及查找的循环</p></li><li><p>是否 <code>初始化</code>，如果没有，则初始化</p></li></ul></li><li><p>【第三步】<code>for</code> 循环，按照 <code>类继承链或者元类继承链</code> 的顺序查找</p><ul><li><p>当前的 <code>cls</code> 的方法列表中使用 <code>二分查找算法</code> 查找方法，如果找到，则 <code>进入cache写入流程</code>（<a href="https://www.bboyzj.cn/2020/09/30/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8613%EF%BC%9Acache-t%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">在OC底层原理13：cache_t底层原理分析</a> 文章中已经详述过），并 <code>返回imp</code>，如果 没有找到，则返回 <code>nil</code></p></li><li><p><code>当前cls</code> 被赋值为 <code>父类</code>，如果父类 <code>等于nil</code>，则 <code>imp = 消息转发</code>，并终止递归，进入【第四步】</p></li><li><p>如果 <code>父类链</code> 中存在循环，则报错，<code>终止循环</code></p></li><li><p><code>父类缓存</code> 中查找方法</p><ul><li><p>如果 <code>未找到</code>，则直接返回 <code>nil</code>，继续 <code>循环查找</code></p></li><li><p>如果 <code>找到</code>，则直接 <code>返回imp</code>，执行 <code>cache写入流程</code></p></li></ul></li><li><p>【第四步】判断 <code>是否执行过</code> 动态方法解析</p><ul><li><p>如果 <code>没有</code>，执行 <code>动态方法解析</code></p></li><li><p>如果 <code>执行过</code> 一次动态方法解析，则走到 <code>消息转发流程</code></p></li></ul></li></ul><p>  以上就是方法的 <code>慢速查找流程</code>，下面在分别详细解释 <code>二分查找原理</code>，以及 <code>父类缓存查找</code> </p><p>  详细步骤</p></li></ul><h1 id="getMethodNoSuper-nolock-方法：二分查找方法流程"><a href="#getMethodNoSuper-nolock-方法：二分查找方法流程" class="headerlink" title="getMethodNoSuper_nolock 方法：二分查找方法流程"></a>getMethodNoSuper_nolock 方法：二分查找方法流程</h1><p>查找方法列表流程：</p><p><img src="https://user-images.githubusercontent.com/25925248/160737643-28c5dd1a-ecf2-40eb-8cc2-0ad59276f9e0.png"></p><p>其 <code>二分查找</code> 核心的源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE static method_t *</span><br><span class="line">findMethodInSortedMethodList(SEL key, const method_list_t *list)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(list);</span><br><span class="line"></span><br><span class="line">    const method_t * const first = &amp;list-&gt;first;</span><br><span class="line">    const method_t *base = first;</span><br><span class="line">    const method_t *probe;</span><br><span class="line">    uintptr_t keyValue = (uintptr_t)key; // key 等于 say666</span><br><span class="line">    uint32_t count;</span><br><span class="line">    // base相当于low，count是max了，probe是middle，这就是二分</span><br><span class="line">    for (count = list-&gt;count; count != 0; count &gt;&gt;= 1) &#123;</span><br><span class="line">        // 从首地址+下标 -&gt; 移动到中间位置（count &gt;&gt; 1 右移1位 count/2 = 4）</span><br><span class="line">        probe = base + (count &gt;&gt; 1);</span><br><span class="line">        </span><br><span class="line">        uintptr_t probeValue = (uintptr_t)probe-&gt;name;</span><br><span class="line">        </span><br><span class="line">        // 如果查找的key是keyVal 等于中间位置（probe）的probeValue，则直接返回中间位置</span><br><span class="line">        if (keyValue == probeValue) &#123;</span><br><span class="line">            // while 平移 排除分类重名方法</span><br><span class="line">            while (probe &gt; first &amp;&amp; keyValue == (uintptr_t)probe[-1].name) &#123;</span><br><span class="line">                /*</span><br><span class="line">                 排除分类重名方法（方法的存储是先存储方法，再存储分类，按照先进后出的原则，分类方法最先出，</span><br><span class="line">                 而我们要取的类方法，所以需要先排除分类方法</span><br><span class="line">                 如果是两个分类，就看谁先进行加载）</span><br><span class="line">                 */</span><br><span class="line">                probe--;</span><br><span class="line">            &#125;</span><br><span class="line">            return (method_t *)probe;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果keyValue 大于 probeValue，就往probe即中间位置的右边查找</span><br><span class="line">        if (keyValue &gt; probeValue) &#123;</span><br><span class="line">            base = probe + 1;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>算法原理</code> 简述：从第一次查找开始，每次都取 <code>中间位置</code>，与想查找的 <code>key的value的值</code> 作比较，如果 <code>相等</code>，则需要 <code>排除分类方法</code>，然后将查询到的位置的方法实现返回，如果 <code>不相等</code>，则需要 <code>继续二分查找</code>，如果循环至 <code>count=0</code> 还是 <code>没有找到</code>，则直接返回 <code>nil</code>，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/160737692-aebad7b7-fecc-46ef-951d-2d23b9fdf8a9.png"></p><p>以查找 <code>ZJPerson</code> 类的 <code>sayNB实例方法</code> 为例，其二分查找过程如下：</p><p><img src="https://user-images.githubusercontent.com/25925248/160737702-6e1a43b0-3784-49c2-8732-de92c29f0c87.png"></p><h1 id="cache-getImp方法：父类缓存查找"><a href="#cache-getImp方法：父类缓存查找" class="headerlink" title="cache_getImp方法：父类缓存查找"></a>cache_getImp方法：父类缓存查找</h1><p><code>cache_getImp</code> 方法是通过 <code>汇编_cache_getImp实现</code>，传入 <code>$0</code> 是 <code>GETIMP</code>，如下所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/160737716-c79325bc-e5fd-41ee-9105-c7939757c7b5.png"></p><ul><li><p>如果 <code>父类缓存</code> 中找到了方法实现，则跳转至 <code>CacheHit</code> 即命中，则直接 <code>返回imp</code></p></li><li><p>如果在 <code>父类缓存</code> 中，没有找到 <code>方法实现</code>，则跳转至 <code>CheckMiss</code> 或者 <code>JumpMiss</code>，通过判断 <code>$0</code> 跳转至 <code>LGetImpMiss</code>，直接返回 <code>nil</code></p></li></ul><p><strong>总结</strong></p><ul><li><p>对于 <code>对象方法（即实例方法）</code>，即在 <code>类中查找</code>，其慢速查找的 <code>父类链</code> 是：<code>类 -&gt; 父类 -&gt; 根类 -&gt; nil</code></p></li><li><p>对于 <code>类方法</code>，即在 <code>元类中查找</code>，其慢速查找的 <code>父类链</code> 是：<code>元类 -&gt; 根元类 -&gt; 根类 -&gt; nil</code></p></li><li><p>如果 <code>快速查找、慢速查找</code> 也 <code>没有找到</code> 方法实现，则尝试 <code>动态方法决议</code></p></li><li><p>如果 <code>动态方法决议</code> 仍然没有找到，则进行 <code>消息转发</code></p></li></ul><h1 id="常见方法未实现报错源码"><a href="#常见方法未实现报错源码" class="headerlink" title="常见方法未实现报错源码"></a>常见方法未实现报错源码</h1><p>如果在 <code>快速查找、慢速查找、方法解析流程中</code>，均没有找到方法实现，则使用消息转发，其流程如下：</p><p><img src="https://user-images.githubusercontent.com/25925248/160737730-2203f52c-5019-4974-8126-84a91d462f2a.png"></p><p><strong>消息转发的实现</strong></p><ul><li>其中 <code>_objc_msgForward_impcache</code> 是汇编实现，会跳转至 <code>__objc_msgForward</code>，其核心是 <code>__objc_forward_handler</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line">// No stret specialization.</span><br><span class="line">b__objc_msgForward</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENTRY __objc_msgForward</span><br><span class="line"></span><br><span class="line">adrpx17, __objc_forward_handler@PAGE</span><br><span class="line">ldrp17, [x17, __objc_forward_handler@PAGEOFF]</span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward</span><br></pre></td></tr></table></figure><ul><li>汇编实现中查找 <code>__objc_forward_handler</code> ，并没有找到，在源码中去掉一个下划线进行全局搜索 <code>_objc_forward_handler</code> ,有如下实现，本质是调用的 <code>objc_defaultForwardHandler</code> 方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Default forward handler halts the process.</span><br><span class="line">__attribute__((noreturn, cold)) void</span><br><span class="line">objc_defaultForwardHandler(id self, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</span><br><span class="line">                &quot;(no message forward handler is installed)&quot;, </span><br><span class="line">                class_isMetaClass(object_getClass(self)) ? &#x27;+&#x27; : &#x27;-&#x27;, </span><br><span class="line">                object_getClassName(self), sel_getName(sel), self);</span><br><span class="line">&#125;</span><br><span class="line">void *_objc_forward_handler = (void*)objc_defaultForwardHandler;</span><br></pre></td></tr></table></figure><ul><li>看着 <code>objc_defaultForwardHandler</code> 有没有很眼熟，这就是我们日常开发中最常见的错误：<code>没有实现函数，运行程序，崩溃时的报错提示</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理13：cache_t底层原理分析</title>
      <link href="/BboyZJ.github.io/2020/09/30/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8613%EF%BC%9Acache-t%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/BboyZJ.github.io/2020/09/30/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8613%EF%BC%9Acache-t%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在前面的 <a href="https://www.bboyzj.cn/2020/09/24/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8610%EF%BC%9A%E7%B1%BB%20&%20%E7%B1%BB%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">OC底层原理10：类 &amp; 类结构分析</a> 中<br>得知 <code>类</code> 都是以 <code>objc_class</code> 模板创建的，而 <code>objc_class</code> 中包含许多属性，如 <code>Class ISA、Class superclass、cache_t cache、class_data_bits_t bits</code>，并分析了 <code>ISA、superclass、bits</code>，本文主要分析 <code>cache_t</code> 中的 <code>cache</code> 属性。</p><h1 id="cache-t-结构分析"><a href="#cache-t-结构分析" class="headerlink" title="cache_t 结构分析"></a>cache_t 结构分析</h1><p> 通过 <a href="https://opensource.apple.com/tarballs/">objc4-781源码</a> ，查看 <code>cache_t</code> 的源码结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// cache 存的是什么？ 怎么存的？</span><br><span class="line">// cache 用来缓存</span><br><span class="line">struct cache_t &#123;</span><br><span class="line">#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED  // MacOS 或 模拟器 -- 主要作为架构的区分</span><br><span class="line">    // explicit_atomic 显示原子性，目的是为了能够 增删改查时 保证线程的安全性</span><br><span class="line">    // 等价于 struct bucket_t * _buckets;</span><br><span class="line">    // _buckets 中放的是 sel imp</span><br><span class="line">    // _buckets的读取 有提供相应名称的方法 buckets()</span><br><span class="line">    explicit_atomic&lt;struct bucket_t *&gt; _buckets;</span><br><span class="line">    // _mask 掩码，即面具 -- 类似于isa的掩码，即位域</span><br><span class="line">    explicit_atomic&lt;mask_t&gt; _mask;</span><br><span class="line">    </span><br><span class="line">#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16 // 真机 &amp; 64位</span><br><span class="line">    // _maskAndBuckets 把原来的两个结构 _buckets 和 _mask 写成一个了，作用 为了优化</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _maskAndBuckets;</span><br><span class="line">    // 苹果没有写完</span><br><span class="line">    mask_t _mask_unused;</span><br><span class="line">    </span><br><span class="line">    // 静态的省略...</span><br><span class="line">        </span><br><span class="line">#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4 // 真机 不是64位的</span><br><span class="line">    </span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _maskAndBuckets;</span><br><span class="line">    mask_t _mask_unused;</span><br><span class="line"></span><br><span class="line">    // 静态的省略...</span><br><span class="line">    </span><br><span class="line">#else</span><br><span class="line">#error Unknown cache mask storage type.</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">#if __LP64__</span><br><span class="line">    // 位置标记</span><br><span class="line">    uint16_t _flags;</span><br><span class="line">#endif</span><br><span class="line">    // 占位</span><br><span class="line">    uint16_t _occupied;</span><br><span class="line"></span><br><span class="line">    //其他方法省略.....</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分析 <code>cache_t</code> 的结构：</p><ul><li><p>首先我们需要了解一下苹果设备的不同的 <code>架构</code>，如下：</p><ul><li><code>MacOS</code> 架构：<code>i386</code></li><li><code>真机</code> 架构：<code>arm64</code></li><li><code>模拟器</code> 架构：<code>x86</code></li></ul></li><li><p>通过上面的 <code>cache_t</code> 源码可知，分为 <code>3</code> 个架构处理：</p><ul><li><code>CACHE_MASK_STORAGE_OUTLINED</code>：表示运行的环境是 <code>MacOS</code> 或者 <code>模拟器</code></li><li><code>CACHE_MASK_STORAGE_HIGH_16</code>：表示运行的环境是 <code>64位</code> 的 <code>真机</code></li><li><code>CACHE_MASK_STORAGE_LOW_4</code>：表示运行的环境是 <code>非64位</code> 的 <code>真机</code></li></ul></li></ul><p>我们可以点进 <code>CACHE_MASK_STORAGE</code> 中查看具体的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define CACHE_MASK_STORAGE_OUTLINED 1 </span><br><span class="line">#define CACHE_MASK_STORAGE_HIGH_16 2</span><br><span class="line">#define CACHE_MASK_STORAGE_LOW_4 3</span><br><span class="line"></span><br><span class="line">#if defined(__arm64__) &amp;&amp; __LP64__ // 真机 &amp; 64位</span><br><span class="line">#define CACHE_MASK_STORAGE CACHE_MASK_STORAGE_HIGH_16</span><br><span class="line">#elif defined(__arm64__) &amp;&amp; !__LP64__ // 真机 &amp; 非64位</span><br><span class="line">#define CACHE_MASK_STORAGE CACHE_MASK_STORAGE_LOW_4</span><br><span class="line">#else // MacOS 或 模拟器</span><br><span class="line">#define CACHE_MASK_STORAGE CACHE_MASK_STORAGE_OUTLINED</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><code>explicit_atomic</code>：表示 <code>显示原子性</code>，目的是为了能够保证 <code>增删改查</code>时 <code>线程的安全性</code></p></li><li><p><code>_buckets</code>：是一个 <code>struct bucket_t</code> 的结构体，其内部源码如下：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line">    // IMP-first is better for arm64e ptrauth and no worse for arm64.</span><br><span class="line">    // SEL-first is better for armv7* and i386 and x86_64.</span><br><span class="line">#if __arm64__ // 真机 64位</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _imp;</span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class="line">#else // 非真机</span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _imp;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>由 <code>bucket_t</code> 源码可知，其内部保存的是 <code>SEL</code> 和 <code>IMP</code></p><ul><li><p><code>_mask</code>：是 <code>masK_t</code> 结构，<code>掩码</code>，即面具，类似于 isa中的掩码即 <code>位域</code></p><ul><li><code>真机</code> 环境： <code>uint32_t</code> 类型的</li><li><code>其他</code> 环境：<code>uint16_t</code> 类型的</li></ul></li></ul><p><code>masK_t</code> 的内部结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if __LP64__</span><br><span class="line">typedef uint32_t mask_t;  // x86_64 &amp; arm64 asm are less efficient with 16-bits</span><br><span class="line">#else</span><br><span class="line">typedef uint16_t mask_t;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><ul><li><code>_maskAndBuckets</code>： <code>真机</code> 环境把原来的两个结构 <code>_buckets</code> 和 <code>_mask</code> 写成一个了，作用是 <code>为了优化</code></li></ul><p><strong>【总结】</strong></p><p>通过上面几个结构体分析，我们可以得出一个如下的结构图：</p><p><img src="https://user-images.githubusercontent.com/25925248/96363367-6db75580-1166-11eb-9331-a1daecd5fb9c.png" alt="w250"></p><h1 id="【补充知识】sel-amp-imp-的关系"><a href="#【补充知识】sel-amp-imp-的关系" class="headerlink" title="【补充知识】sel &amp; imp 的关系"></a>【补充知识】sel &amp; imp 的关系</h1><p>我们知道，每一个方法都有一个 <code>sel</code> 和 <code>imp</code>，<code>sel</code> 就是 <code>方法编号</code>，<code>imp</code> 就是 <code>函数指针(方法实现)</code>，我们在查找方法的时候是一个非常漫长的过程，<code>oc</code> 的 <code>函数实现</code> 是通过 <code>下层c/c++</code> 来实现的，<code>oc上层</code> 的 <code>sel</code> 和 <code>imp</code> 起始是 <code>对下层</code> 的 <code>封装</code></p><p><strong>【方法的组成】:</strong></p><ul><li><code>SEL</code>：<code>方法编号</code></li><li><code>IMP</code>：<code>函数指针地址</code></li></ul><p><strong>【用通俗易懂的方式解释】：</strong></p><p><code>SEL</code>：相当于书本目录的名称<br><code>IMP</code>：相当于书本目录的页码</p><ul><li>首先明白我们要找到书本的什么内容（<code>sel</code>目录里面的名称）</li><li>通过名称找到对应的书本页码（<code>imp</code>）</li><li>通过页码去定位具体的内容</li></ul><p>下面用一张图表示：</p><p><img src="https://user-images.githubusercontent.com/25925248/95676103-5ae4d400-0bee-11eb-9762-59f6497c62f5.png" alt="w250"></p><h1 id="cache中查找sel-imp"><a href="#cache中查找sel-imp" class="headerlink" title="cache中查找sel-imp"></a>cache中查找sel-imp</h1><p><code>cache_t</code> 中查找存储的 <code>sel-imp</code>，有以下两种方式</p><ul><li>通过源码查找</li><li>脱离源码在项目中查找</li></ul><p><strong>【准备工作】</strong></p><ul><li>自定义一个 <code>ZJPerson</code> 类，并定义 <code>2个属性</code> 和 <code>5个实例方法</code> 及其 <code>实现</code></li></ul><p><code>ZJPerson.h</code> 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *zjName;</span><br><span class="line">@property (nonatomic, strong) NSString *nickName;</span><br><span class="line"></span><br><span class="line">- (void)sayHello;</span><br><span class="line"></span><br><span class="line">- (void)sayCode;</span><br><span class="line"></span><br><span class="line">- (void)sayMaster;</span><br><span class="line"></span><br><span class="line">- (void)sayNB;</span><br><span class="line"></span><br><span class="line">+ (void)sayHappy;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>ZJPerson.m</code> 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@implementation ZJPerson</span><br><span class="line">- (void)sayHello&#123;</span><br><span class="line">    NSLog(@&quot;ZJPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sayCode&#123;</span><br><span class="line">    NSLog(@&quot;ZJPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sayMaster&#123;</span><br><span class="line">    NSLog(@&quot;ZJPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sayNB&#123;</span><br><span class="line">    NSLog(@&quot;ZJPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)sayHappy&#123;</span><br><span class="line">    NSLog(@&quot;ZJPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>在 <code>main.m</code> 中定义 <code>ZJPerson</code> 类的 <code>对象p</code>，并调用其中的 <code>3个实例方法</code>，在第一个方法处加两个 <code>断点</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/96364523-955dec00-116d-11eb-9eb9-c57c7c6fa8ed.png" alt="w250"></p><p><code>【通过源码查找】</code></p><ul><li>运行执行，断在 <code>[p sayHello];</code> 部分，此时执行以下lldb调试流程：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/96365462-4f0b8b80-1173-11eb-8594-4baa031fae9f.png" alt="w250"></p><p>由上面的调式流程可知：</p><ul><li><p><code>cache属性</code> 的获取，需要通过 <code>pClass</code> 的 <code>首地址平移16字节</code>，即 <code>首地址 + 0x10</code> 获取 <code>cache的地址</code></p></li><li><p><code>_buckets属性</code> 的获取，在 <code>cache_t</code> 结构体中提供了获取 <code>_buckets</code> 属性的方法 <code>buckets()</code>，在 <code>_buckets</code> 属性中（目前处于macOS环境）缓存着 <code>sel-imp</code></p></li><li><p><code>sel</code> 和 <code>imp</code> 的获取，在 <code>_buckets</code> 中提供了 <code>sel()</code> 和 <code>imp(pClass)</code> 方法获取 <code>sel 和 imp</code></p></li></ul><p>由上图可知，在没有执行方法调用之前，此时 <code>cache</code> 是没有缓存的，执行调用了一次之后，<code>cache</code> 中就 <code>缓存</code> 了 <code>一次</code>，即调用一次方法就会缓存一次。</p><p>我们在前面了解了如何获取 <code>cache</code> 中 <code>sel-imp</code>，那么如何验证打印的<code>sel-imp</code> 就是我们调用的呢？可以通过 <code>machoView</code> 打开 <code>target</code> 的可执行文件，在方法列表中查看其 <code>imp</code> 的值 <code>是否是一致</code> 的，如下所示，发现是一致的，所以打印的这个 <code>sel-imp</code> 就是 <code>ZJPerson</code> 的实例方法：</p><p><strong>【machoView图】：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/96365694-0e147680-1175-11eb-96a8-2118cc073e87.png" alt="w250"></p><p><strong>【imp截图：】</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/96365715-2b494500-1175-11eb-8a60-1f4cf17407d3.png" alt="w250"></p><ul><li>接着上面的 <code>LLDB</code> 调试步骤，我们再调一个方法，其 <code>LLDB</code> 调试如下图：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/96365992-4452f580-1177-11eb-9496-57b30db5353c.png" alt="w250"></p><p>第一个调用方法的存储获取很简单，直接通过 <code>_buckets</code> 的 <code>首地址</code> 调用对应的方法即可，那么获取第二个呢？在之前的 <a href="https://www.bboyzj.cn/2020/09/24/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8610%EF%BC%9A%E7%B1%BB%20&%20%E7%B1%BB%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">OC底层原理10：类 &amp; 类结构分析</a> 文章中，曾提及过一个概念 <code>指针偏移</code>，所以我们这里可以通过 <code>_buckets</code> 属性的 <code>首地址偏移</code>，即 <code>p *($9+1)</code> 即可获取第二个方法的 <code>sel 和 imp</code></p><p>如果有多个方法需要获取，以此类推，例如 <code>p *($9+i)</code></p><p><strong>【脱离源码通过项目查找】</strong></p><p>脱离源码环境，就是将所需的 <code>源码</code> 的部分 <code>拷贝至项目</code> 中，其完整代码如下：</p><p>【ZJPerson类】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//*********.h********</span><br><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *zjName;</span><br><span class="line">@property (nonatomic, strong) NSString *nickName;</span><br><span class="line">- (void)say1;</span><br><span class="line">- (void)say2;</span><br><span class="line">- (void)say3;</span><br><span class="line">- (void)say4;</span><br><span class="line">- (void)say5;</span><br><span class="line">- (void)say6;</span><br><span class="line">- (void)say7;</span><br><span class="line">+ (void)sayHappy;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//*********.m********</span><br><span class="line">@implementation ZJPerson</span><br><span class="line">- (void)say1&#123;</span><br><span class="line">    NSLog(@&quot;ZJPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (void)say2&#123;</span><br><span class="line">    NSLog(@&quot;ZJPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (void)say3&#123;</span><br><span class="line">    NSLog(@&quot;ZJPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (void)say4&#123;</span><br><span class="line">    NSLog(@&quot;ZJPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (void)say5&#123;</span><br><span class="line">    NSLog(@&quot;ZJPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (void)say6&#123;</span><br><span class="line">    NSLog(@&quot;ZJPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (void)say7&#123;</span><br><span class="line">    NSLog(@&quot;ZJPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)sayHappy&#123;</span><br><span class="line">    NSLog(@&quot;ZJPerson say : %s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong>【main中代码】</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;ZJPerson.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">typedef uint32_t mask_t;  // x86_64 &amp; arm64 asm are less efficient with 16-bits</span><br><span class="line"></span><br><span class="line">struct zj_bucket_t &#123;</span><br><span class="line">    SEL _sel;</span><br><span class="line">    IMP _imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct zj_cache_t &#123;</span><br><span class="line">    struct zj_bucket_t * _buckets;</span><br><span class="line">    mask_t _mask;</span><br><span class="line">    uint16_t _flags;</span><br><span class="line">    uint16_t _occupied;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct zj_class_data_bits_t &#123;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct zj_objc_class &#123;</span><br><span class="line">    Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    struct zj_cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    struct zj_class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        ZJPerson *p  = [ZJPerson alloc];</span><br><span class="line">        Class pClass = [ZJPerson class];  // objc_clas</span><br><span class="line">        [p say1];</span><br><span class="line">        [p say2];</span><br><span class="line">        [p say3];</span><br><span class="line">        [p say4];</span><br><span class="line">         </span><br><span class="line">        // _occupied  _mask 是什么  cup - 1</span><br><span class="line">        // 会变化 2-3 -&gt; 2-7</span><br><span class="line">        // bucket 会有丢失  重新申请</span><br><span class="line">        // 顺序有点问题  哈希</span><br><span class="line">        </span><br><span class="line">        // cache_t 底层原理</span><br><span class="line">        // 线索 :</span><br><span class="line">        </span><br><span class="line">        struct zj_objc_class *zj_pClass = (__bridge struct zj_objc_class *)(pClass);</span><br><span class="line">        NSLog(@&quot;%hu - %u&quot;,zj_pClass-&gt;cache._occupied,zj_pClass-&gt;cache._mask);</span><br><span class="line">        for (mask_t i = 0; i&lt;zj_pClass-&gt;cache._mask; i++) &#123;</span><br><span class="line">            // 打印获取的 bucket</span><br><span class="line">            struct zj_bucket_t bucket = zj_pClass-&gt;cache._buckets[i];</span><br><span class="line">            NSLog(@&quot;%@ - %p&quot;,NSStringFromSelector(bucket._sel),bucket._imp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这里有个问题需要注意，在源码中，<code>objc_class</code> 的 <code>ISA</code> 属性时继承自 <code>objc_object</code> 的，但在我们将其拷贝过来时，去掉了 <code>objc_class</code> 的继承关系，需要将这个属性明确，否则打印的结果是有问题的，如下图所示：</li></ul><p><img src="/BboyZJ.github.io/assets/16506161124201.jpg"></p><ul><li>加上 <code>ISA</code> 属性后，其正确的打印结果如下：</li></ul><p><img src="/BboyZJ.github.io/assets/16506161617054.jpg"></p><p>针对上面的打印结果，有以下几个疑问？</p><ul><li><code>_mask</code> 是什么？</li><li><code>_occupied</code> 是什么？</li><li>为什么随着方法调用的增多，其打印的 <code>occupied</code> 和 <code>mask</code> 会变化？</li><li><code>bucket</code> 数据为什么会有 <code>丢失的情况</code>？例如 <code>2-7中</code>，只有say3、say4方法有函数指针？</li><li>2-7中say3、say4的打印顺序为什么是say4先打印，say3后打印，且还不是挨着的，即 <code>顺序有问题</code>？</li><li>打印的 <code>cache_t</code> 中的 <code>_occupied</code> 为什么是从 <code>2</code> 开始？</li></ul><p>带着上述的这些疑问，下面来进行 <code>cache</code> 底层原理的探索</p><h1 id="cache-t-底层原理分析"><a href="#cache-t-底层原理分析" class="headerlink" title="cache_t 底层原理分析"></a>cache_t 底层原理分析</h1><ul><li>首先，从 <code>cache_t</code> 中的 <code>_mask</code> 属性开始分析，找 <code>cache_t</code> 中引起变化的函数，发现了 <code>incrementOccupied()</code> 函数</li></ul><p><img src="/BboyZJ.github.io/assets/16506175409306.jpg"></p><p>该函数的具体实现为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void incrementOccupied(); //Occupied自增</span><br><span class="line"></span><br><span class="line">//👇具体实现</span><br><span class="line">void cache_t::incrementOccupied() </span><br><span class="line">&#123;</span><br><span class="line">    _occupied++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>源码中，全局搜索 <code>incrementOccupied()</code> 函数，发现只在 <code>cache_t</code> 的 <code>insert</code> 方法有调用</li></ul><p><img src="/BboyZJ.github.io/assets/16506176699882.png"></p><ul><li><code>insert</code> 方法，理解为 <code>cache_t</code> 的插入，而 <code>cache</code> 中存储的就是 <code>sel-imp</code>，所以 <code>cache</code> 的原理从 <code>insert</code> 方法开始分析，以下是 <code>cache</code> 原理分析的流程图</li></ul><p><img src="/BboyZJ.github.io/assets/16506177129298.png"></p><ul><li>全局搜索 <code>insert(</code> 方法，发现只有 <code>cache_fill</code> 方法中的调用符合</li></ul><p><img src="/BboyZJ.github.io/assets/16506177819433.png"></p><ul><li>全局搜索 <code>cache_fill</code>，发现在写入之前，还有一步操作，即 <code>cache</code> 读取，即查找 <code>sel-imp</code>，如下所示</li></ul><p><img src="/BboyZJ.github.io/assets/16506178147151.png"></p><p>但本文的重点还是分析 <code>cache</code> 存储的原理，接下来根据 <code>cache_t</code> 写入的流程图，着重分析 <code>insert</code> 方法</p><h1 id="insert-方法分析"><a href="#insert-方法分析" class="headerlink" title="insert 方法分析"></a>insert 方法分析</h1><p>在 <code>insert</code> 方法中，其源码实现如下</p><p><img src="/BboyZJ.github.io/assets/16506178813685.png"></p><p>主要分为以下几部分：</p><ul><li>【第一步】<code>计算</code> 出当前的 <code>缓存占用量</code></li><li>【第二步】根基 <code>缓存占用量判断</code> 执行的 <code>操作</code></li><li>【第三步】针对需要存储的 <code>bucket</code> 进行内部 <code>imp和set赋值</code></li></ul><p><strong>1、【第一步】计算出当前的缓存占用量</strong></p><p>根据 <code>occupied</code> 的值计算出当前的缓存占用量，当 <code>属性未赋值及无法调用时</code>，此时的 <code>occupied()为0</code> ，而 <code>newOccupied为1</code> ，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mask_t newOccupied = occupied() + 1;</span><br></pre></td></tr></table></figure><p>关于缓存占用量的计算，有以下几点说明：</p><ul><li><p><code>alloc</code> 申请空间时，此时的 <code>对象已经创建</code>，如果再调用 <code>init</code> 方法，<code>occupied也会+1</code></p></li><li><p>当 <code>有属性赋值</code> 时，会隐式调用 <code>set</code> 方法，<code>occupied</code> 也会增加，即 <code>有几个属性赋值，occupied就会在原有的基础上加几个</code></p></li><li><p>当 <code>有方法调用</code> 时，<code>occupied</code> 也会增加，即 <code>有几次调用，occupied就会在原有的基础上加几个</code></p></li></ul><p><strong>2、【第二步】根据缓存占用量判断执行的操作</strong></p><ul><li>如果是 <code>第一次创建</code>，则默认开辟4个</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (slowpath(isConstantEmptyCache())) &#123; //小概率发生的 即当 occupied() = 0时，即创建缓存，创建属于小概率事件</span><br><span class="line">    // Cache is read-only. Replace it.</span><br><span class="line">    if (!capacity) capacity = INIT_CACHE_SIZE; //初始化时，capacity = 4（1&lt;&lt;2 -- 100）</span><br><span class="line">    reallocate(oldCapacity, capacity, /* freeOld */false); //开辟空间</span><br><span class="line">    //到目前为止，if的流程的操作都是初始化创建</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果缓存占用量 <code>小于等于3/4</code>，则不作任何处理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">else if (fastpath(newOccupied + CACHE_END_MARKER &lt;= capacity / 4 * 3)) &#123; </span><br><span class="line">    // Cache is less than 3/4 full. Use it as-is.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果缓存占用量 <code>超过3/4</code>，则需要进行 <code>两倍扩容</code> 以及 <code>重新开辟空间</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">else &#123; //如果超出了3/4，则需要扩容（两倍扩容）</span><br><span class="line">    // 扩容算法： 有cap时，扩容两倍，没有cap就初始化为4</span><br><span class="line">    capacity = capacity ? capacity * 2 : INIT_CACHE_SIZE;  // 扩容两倍 2*4 = 8</span><br><span class="line">    if (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">        capacity = MAX_CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    // 走到这里表示 曾经有，但是已经满了，需要重新梳理</span><br><span class="line">    reallocate(oldCapacity, capacity, true);</span><br><span class="line">    // 内存 扩容完毕</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【realloc方法：开辟空间】</strong></p><p>该方法，在 <code>第一次创建</code> 以及 <code>两倍扩容</code> 时，都会使用，其源码实现如图所示</p><p><img src="/BboyZJ.github.io/assets/16506185309016.png"></p><p>主要有以下几步：</p><ul><li><p><code>allocateBuckets</code> 方法：向系统 <code>申请开辟内存</code>，即开辟 <code>bucket</code>，此时的bucket只是一个临时变量</p></li><li><p><code>setBucketsAndMask</code> 方法：将 <code>临时</code> 的 <code>bucket</code> 存入缓存中，此时的存储分为两种情况：</p><ul><li>如果是 <code>真机</code>，根据 <code>bucket和mask的位置存储</code>，并将 <code>occupied</code> 占用设置为 <code>0</code></li></ul></li></ul><p><img src="/BboyZJ.github.io/assets/16506186391406.png"></p><ul><li>如果 <code>不是真机</code>，<code>正常存储bucket和mask</code>，并将 <code>occupied</code> 占用设置为 <code>0</code></li></ul><p><img src="/BboyZJ.github.io/assets/16506186864056.png"></p><ul><li>如果有旧的buckets，需要清理之前的缓存，即调用 <code>cache_collect_free</code> 方法，其源码实现如下</li></ul><p><img src="/BboyZJ.github.io/assets/16506187036345.png"></p><p>该方法的实现主要有以下几步：</p><ul><li><code>_garbage_make_room</code> 方法：创建垃圾回收空间</li></ul><p><img src="/BboyZJ.github.io/assets/16506187497909.png"></p><ul><li><p>如果是 <code>第一次</code>，需要 <code>分配回收空间</code></p></li><li><p>如果 <code>不是第一次</code>，则将内存段加大，即 <code>原有内存*2</code></p></li><li><p>记录 <code>存储</code> 这次的 <code>bucket</code></p></li><li><p><code>cache_collect</code> 方法：垃圾回收，清理旧的bucket</p></li></ul><p><img src="/BboyZJ.github.io/assets/16506187497909.png"></p><p><strong>【第三步】针对需要存贮的bucket进行内部imp和sel赋值</strong></p><p>这部分主要是根据 <code>cache_hash</code> 方法，即 <code>哈希算法</code> ，计算 <code>sel-imp</code> 存储的 <code>哈希下标</code>，分为以下三种情况：</p><ul><li><p>如果哈希下标的位置 <code>未存储sel</code>，即该下标位置 <code>获取sel等于0</code>，此时将 <code>sel-imp存储</code> 进去，并将 <code>occupied</code> 占用大小 <code>加1</code></p></li><li><p>如果当前哈希下标存储的sel <code>等于</code> 即将插入的sel，则直接返回</p></li><li><p>如果当前哈希下标存储的sel <code>不等于</code> 即将插入的sel，则重新经过 <code>cache_next方法</code> 即哈希冲突算法，重新进行哈希计算，得到新的下标，再去对比进行存储</p></li></ul><p>其中涉及的两种哈希算法，其源码如下：</p><ul><li><code>cache_hash</code>：哈希算法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline mask_t cache_hash(SEL sel, mask_t mask) </span><br><span class="line">&#123;</span><br><span class="line">    return (mask_t)(uintptr_t)sel &amp; mask; // 通过sel &amp; mask（mask = cap -1）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>cache_next</code>：哈希冲突算法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#if __arm__  ||  __x86_64__  ||  __i386__</span><br><span class="line">// objc_msgSend has few registers available.</span><br><span class="line">// Cache scan increments and wraps at special end-marking bucket.</span><br><span class="line">#define CACHE_END_MARKER 1</span><br><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return (i+1) &amp; mask; //（将当前的哈希下标 +1） &amp; mask，重新进行哈希计算，得到一个新的下标</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#elif __arm64__</span><br><span class="line">// objc_msgSend has lots of registers available.</span><br><span class="line">// Cache scan decrements. No end marker needed.</span><br><span class="line">#define CACHE_END_MARKER 0</span><br><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return i ? i-1 : mask; //如果i是空，则为mask，mask = cap -1，如果不为空，则 i-1，向前插入sel-imp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，cache_t的原理基本分析完成了，然后前文提及的几个问题，我们现在就有答案了</p><h1 id="疑问解答"><a href="#疑问解答" class="headerlink" title="疑问解答"></a>疑问解答</h1><p><strong>1、<code>_mask</code> 是什么？</strong></p><p><code>_mask</code> 是指 <code>掩码数据</code>，用于在 <code>哈希算法或者哈希冲突算法</code> 中 <code>计算哈希下标</code>，其中<code>mask</code> 等于 <code>capacity - 1</code></p><p><strong>2、<code>_occupied</code> 是什么？</strong></p><p><code>_occupied</code> 表示哈希表中 <code>sel-imp</code> 的占用大小 (即可以理解为分配的内存中已经存储了sel-imp的的个数)</p><ul><li><p><code>init</code> 会导致occupied变化</p></li><li><p><code>属性赋值</code>，也会隐式调用，导致occupied变化</p></li><li><p><code>方法调用</code>，导致occupied变化</p></li></ul><p><strong>3、为什么随着方法调用的增多，其打印的 <code>occupied</code> 和 <code>mask</code> 会变化？</strong></p><p>因为在 <code>cache</code> 初始化时，分配的空间是 <code>4</code> 个，随着方法调用的增多，当存储的 <code>sel-imp个数</code>，即 <code>newOccupied + CACHE_END_MARKER（等于1）的和 超过 总容量的3/4</code>,例如有 <code>4</code> 个时，当occupied等于2时，就需要对cache的内存进行两倍扩容</p><p><strong>4、<code>bucket</code> 数据为什么会有 <code>丢失的情况</code>？例如 <code>2-7中</code>，只有say3、say4方法有函数指针？</strong></p><p>原因是在 <code>扩容</code> 时，是将 <code>原有的内存全部清除</code> 了，再 <code>重新申请 </code>了内存 <code>导致</code> 的</p><p><strong>5、2-7中say3、say4的打印顺序为什么是say4先打印，say3后打印，且还不是挨着的，即 <code>顺序有问题</code>？</strong></p><p>因为sel-imp的存储是通过哈希算法计算下标的，其计算的下标有可能已经存储了sel，所以 又需要通过哈希冲突算法重新计算哈希下标，所以导致 <code>下标是随机</code>的，并不是固定的</p><p><strong>6、打印的 <code>cache_t</code> 中的 <code>_occupied</code> 为什么是从 <code>2</code> 开始？</strong></p><p>这里是因为 <code>ZJPerson</code> 通过alloc创建的对象，并 <code>对其两个属性赋值的原因</code>，属性赋值，会隐式调用set方法，<code>set方法</code> 的调用也会导致 <code>occupied变化</code></p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理12：copy &amp; strong &amp; weak底层分析</title>
      <link href="/BboyZJ.github.io/2020/09/28/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8612%EF%BC%9Acopy-strong-weak%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/"/>
      <url>/BboyZJ.github.io/2020/09/28/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8612%EF%BC%9Acopy-strong-weak%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>属性</code> 通过 <code>clang</code> 编译的 <code>cpp</code> 文件中可以发现 <code>copy &amp; strong &amp; weak </code> 修饰， 在编译的底层代码中是有区别的</p><h1 id="【补充知识】：Type-Encoding-amp-Property-Type-String"><a href="#【补充知识】：Type-Encoding-amp-Property-Type-String" class="headerlink" title="【补充知识】：Type Encoding &amp; Property Type String"></a>【补充知识】：Type Encoding &amp; Property Type String</h1><p><strong>【Type encoding】：编码类型</strong></p><p>获取 <code>Type encoding</code> 有两种方式：</p><p><strong>【方式一】</strong>：通过 <code>代码</code> 获取</p><p>在 <code>main.m</code> 中添加添加函数方法：</p><ul><li><code>ZJLog</code>：打印结果描述</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">#define ZJLog(format, ...) printf(&quot;%s\n&quot;, [[NSString stringWithFormat:format, ## __VA_ARGS__] UTF8String]);</span><br><span class="line">#else</span><br><span class="line">#define ZJLog(format, ...);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><ul><li><code>zjTypes</code> 函数：打印各种类型编码函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 各种类型编码</span><br><span class="line">void zjTypes()&#123;</span><br><span class="line">    NSLog(@&quot;char --&gt; %s&quot;,@encode(char));</span><br><span class="line">    NSLog(@&quot;int --&gt; %s&quot;,@encode(int));</span><br><span class="line">    NSLog(@&quot;short --&gt; %s&quot;,@encode(short));</span><br><span class="line">    NSLog(@&quot;long --&gt; %s&quot;,@encode(long));</span><br><span class="line">    NSLog(@&quot;long long --&gt; %s&quot;,@encode(long long));</span><br><span class="line">    NSLog(@&quot;unsigned char --&gt; %s&quot;,@encode(unsigned char));</span><br><span class="line">    NSLog(@&quot;unsigned int --&gt; %s&quot;,@encode(unsigned int));</span><br><span class="line">    NSLog(@&quot;unsigned short --&gt; %s&quot;,@encode(unsigned short));</span><br><span class="line">    NSLog(@&quot;unsigned long --&gt; %s&quot;,@encode(unsigned long long));</span><br><span class="line">    NSLog(@&quot;float --&gt; %s&quot;,@encode(float));</span><br><span class="line">    NSLog(@&quot;bool --&gt; %s&quot;,@encode(bool));</span><br><span class="line">    NSLog(@&quot;void --&gt; %s&quot;,@encode(void));</span><br><span class="line">    NSLog(@&quot;char * --&gt; %s&quot;,@encode(char *));</span><br><span class="line">    NSLog(@&quot;id --&gt; %s&quot;,@encode(id));</span><br><span class="line">    NSLog(@&quot;Class --&gt; %s&quot;,@encode(Class));</span><br><span class="line">    NSLog(@&quot;SEL --&gt; %s&quot;,@encode(SEL));</span><br><span class="line">    int array[] = &#123;1,2,3&#125;;</span><br><span class="line">    NSLog(@&quot;int[] --&gt; %s&quot;,@encode(typeof(array)));</span><br><span class="line">    typedef struct person&#123;</span><br><span class="line">        char *name;</span><br><span class="line">        int age;</span><br><span class="line">    &#125;Person;</span><br><span class="line">    NSLog(@&quot;struct --&gt; %s&quot;,@encode(Person));</span><br><span class="line">    </span><br><span class="line">    typedef union union_type&#123;</span><br><span class="line">        char *name;</span><br><span class="line">        int a;</span><br><span class="line">    &#125;Union;</span><br><span class="line">    NSLog(@&quot;union --&gt; %s&quot;,@encode(Union));</span><br><span class="line"></span><br><span class="line">    int a = 2;</span><br><span class="line">    int *b = &#123;&amp;a&#125;;</span><br><span class="line">    NSLog(@&quot;int[] --&gt; %s&quot;,@encode(typeof(b)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 <code>main.m</code> 函数中调用上面的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        zjTypes();</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看输出的打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">2020-10-17 14:45:23.857263+0800 001-类的属性与变量[24305:733568] char --&gt; c</span><br><span class="line">2020-10-17 14:45:23.857725+0800 001-类的属性与变量[24305:733568] int --&gt; i</span><br><span class="line">2020-10-17 14:45:23.857763+0800 001-类的属性与变量[24305:733568] short --&gt; s</span><br><span class="line">2020-10-17 14:45:23.857818+0800 001-类的属性与变量[24305:733568] long --&gt; q</span><br><span class="line">2020-10-17 14:45:23.857887+0800 001-类的属性与变量[24305:733568] long long --&gt; q</span><br><span class="line">2020-10-17 14:45:23.857936+0800 001-类的属性与变量[24305:733568] unsigned char --&gt; C</span><br><span class="line">2020-10-17 14:45:23.857965+0800 001-类的属性与变量[24305:733568] unsigned int --&gt; I</span><br><span class="line">2020-10-17 14:45:23.857989+0800 001-类的属性与变量[24305:733568] unsigned short --&gt; S</span><br><span class="line">2020-10-17 14:45:23.858012+0800 001-类的属性与变量[24305:733568] unsigned long --&gt; Q</span><br><span class="line">2020-10-17 14:45:23.858065+0800 001-类的属性与变量[24305:733568] float --&gt; f</span><br><span class="line">2020-10-17 14:45:23.858105+0800 001-类的属性与变量[24305:733568] bool --&gt; B</span><br><span class="line">2020-10-17 14:45:23.858143+0800 001-类的属性与变量[24305:733568] void --&gt; v</span><br><span class="line">2020-10-17 14:45:23.858172+0800 001-类的属性与变量[24305:733568] char * --&gt; *</span><br><span class="line">2020-10-17 14:45:23.858196+0800 001-类的属性与变量[24305:733568] id --&gt; @</span><br><span class="line">2020-10-17 14:45:23.858222+0800 001-类的属性与变量[24305:733568] Class --&gt; #</span><br><span class="line">2020-10-17 14:45:23.862415+0800 001-类的属性与变量[24305:733568] SEL --&gt; :</span><br><span class="line">2020-10-17 14:45:23.862459+0800 001-类的属性与变量[24305:733568] int[] --&gt; [3i]</span><br><span class="line">2020-10-17 14:45:23.862516+0800 001-类的属性与变量[24305:733568] struct --&gt; &#123;person=*i&#125;</span><br><span class="line">2020-10-17 14:45:23.862591+0800 001-类的属性与变量[24305:733568] union --&gt; (union_type=*i)</span><br><span class="line">2020-10-17 14:45:23.862647+0800 001-类的属性与变量[24305:733568] int[] --&gt; ^i</span><br></pre></td></tr></table></figure><p><strong>【方式二】</strong>：查看官方文档</p><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encoding-官方文档</a></p><p><strong>【结论】：</strong></p><p>由上面的结果我们可知：</p><ul><li>每一个 <code>变量类型</code> 都对应一个 <code>编码类型</code>，如 <code>char -&gt; c</code> 等等。</li></ul><p><strong>【Property Type String】：属性类型编码</strong></p><p>属性类型编码可以通过下面的官方文档学习：</p><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW1">Property Type String-官方文档</a></p><p>我们前面学习了，<code>属性</code> 通过 <code>clang</code> 编译 <code>cpp</code> 后，会生成对应的 <code>成员变量</code>、<code>方法列表 </code>、<code>属性列表</code>，如下:</p><p><strong>【方法列表】：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/96331241-57d66180-108e-11eb-93f9-dd45e4fa8fb1.png"></p><p><strong>【属性列表】：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/96331255-7177a900-108e-11eb-9f12-0df2c5c5c3a1.png"></p><p><strong>【成员变量列表】：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/96331267-85230f80-108e-11eb-93d9-76e25e80ec8e.png"></p><p>方法列表中<code>@16@0:8</code> 到底是什么意思？</p><ul><li><p>以 <code>@16@0:8</code> 为例:</p><ul><li>第一个参数<code>@</code>：返回值</li><li>第二个参数<code>16</code>：共用16字节</li><li>第三个参数<code>@</code>：第一个参数</li><li>第四个参数<code>0</code>：从0开始（0~8）</li><li>第五个参数 <code>：</code>号：sel 从 8 号位置开始</li><li>第六个参数<code>8</code>：从8开始（8~16）</li></ul></li></ul><p>属性列表中 <code>&quot;name&quot;,&quot;T@\&quot;NSString\&quot;,&amp;,N,V_name&quot;</code> 是什么意思？</p><ul><li><p>以 <code>&quot;name&quot;,&quot;T@\&quot;NSString\&quot;,&amp;,N,V_name&quot;</code> 为例：</p><ul><li><code>T</code> 表示 <code>type</code></li><li><code>@</code> 表示 <code>变量类型</code></li><li><code>C</code> 表示 <code>copy</code></li><li><code>N</code> 表示 <code>nonatomic</code></li><li><code>V</code> 表示 <code>variable</code> 变量，即下划线变量 <code>_nickName</code></li></ul></li></ul><h1 id="copy-amp-strong-amp-weak-底层分析"><a href="#copy-amp-strong-amp-weak-底层分析" class="headerlink" title="copy &amp; strong &amp; weak 底层分析"></a>copy &amp; strong &amp; weak 底层分析</h1><ul><li>在 <code>ZJPerson</code> 中声明两个属性 <code>nickName</code> 和 <code>name</code> ,分别用 <code>copy</code> 和 <code>strong</code> 修饰</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *nickName;</span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>通过 <code>clang</code> 将 <code>main.m</code> 文件编译成 <code>main.cpp</code>,然后发现 <code>copy</code> 和 <code>strong</code> 修饰的属性的 <code>set方法</code> 是有区别的，如下图：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/96333015-08962e00-109a-11eb-98bc-1acfe13e2edd.png"></p><p>这里就有了疑问，为什么 <code>copy</code> 修饰的 <code>nickName属性</code> 使用了 <code>objc_setProperty</code> ，而 <code>strong</code> 的没有？</p><p>想要分析 <code>copy</code> 和 <code>strong</code> 在底层是如何实现的，需要分析 <a href="https://github.com/apple/llvm-project">LLVM源码</a></p><p>下载好 <code>LLVM源码</code> 后，在 <code>LLVM</code> 中搜索 <code>objc_setProperty</code> ，找到如下所示的 <code>getOptimizedSetPropertyFn</code> 方法中：</p><p><img src="https://user-images.githubusercontent.com/25925248/96333463-a4c13480-109c-11eb-8d42-838c1c089a4f.png"></p><p>由上图可以看出:</p><ul><li><p>如果是 <code>atomic &amp; copy</code> 修饰，<code>name</code> 为 <code>objc_setProperty_atomic_copy</code></p></li><li><p>如果是 <code>atomic &amp; !copy</code> 修饰，<code>name</code> 为 <code>objc_setProperty_atomic</code></p></li><li><p>如果是 <code>nonatomic &amp; copy</code> 修饰，<code>name</code> 为 <code>objc_setProperty_nonatomic_copy</code></p></li><li><p>其他剩余的组合，即 <code>nonatomic、nonatomic &amp; strong、nonatomic &amp; weak</code> 等，<code>name</code> 为 <code>objc_setProperty_nonatomic</code></p></li></ul><p>我们可以通过 <code>汇编调试</code> 查看最终到底会执行哪个命令：</p><p><img src="https://user-images.githubusercontent.com/25925248/96334036-40a06f80-10a0-11eb-9be7-921e4d4336b3.png"></p><p>我们发现 不管是 <code>copy修饰</code> 还是 <code>strong修饰</code> 还是 <code>weak修饰</code> 的属性，最终都会执行 <code>objc_storeStrong</code></p><ul><li><code>objc4源码</code> 中搜索 <code>objc_storeStrong</code>，如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">objc_storeStrong(id *location, id obj)</span><br><span class="line">&#123;</span><br><span class="line">    id prev = *location;</span><br><span class="line">    if (obj == prev) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    objc_retain(obj); // retain新值</span><br><span class="line">    *location = obj;</span><br><span class="line">    objc_release(prev); // release旧值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要也是 <code>retain新值，release旧值</code></p><ul><li>回到 <code>LLVM</code> 源码中搜索 <code>objc_storeStrong</code>，我们发现其底层调用的是 <code>EmitARCStoreStrongCall</code> ，如下图：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/96334522-0638d180-10a4-11eb-859c-47b065ce2c46.png"></p><ul><li>LLVM 中搜索 <code>EmitARCStoreStrongCall</code> 方法，在<code>GenerateCopyHelperFunction</code> 方法有调用，然后在这里发现了 <code>strong</code> 和 <code>weak</code> 的不同处理</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/96334647-de963900-10a4-11eb-9486-8f68bcdbda08.png"></p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC三方框架03：FDFullscreenPopGesture探索</title>
      <link href="/BboyZJ.github.io/2020/09/28/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B603%EF%BC%9AFDFullscreenPopGesture%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/09/28/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B603%EF%BC%9AFDFullscreenPopGesture%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>1.什么是侧滑？<br><code>侧滑</code>本身是系统自带的，但是是<code>左边缘触发</code>的侧滑；</p><p>2.是什么<code>导致</code>了<code>自带</code>的实现<code>不起作用</code>的？原因有:<br>（1）<code>隐藏了系统右上角返回的按钮</code>，系统会自动关掉左滑返回的功能；<br>（2）<code>禁用侧滑功能</code>；<br>（3）<code>自定义返回键或者导航栏</code>后，侧滑失灵；</p><p>3.怎么解决？</p><ul><li><p>使用 <code>FDFullscreenPopGesture</code> 可以解决<br>一个支持<code>全屏侧</code>滑的 <code>UINavigationController</code>的类目。</p></li><li><p><code>FDFullscreenPopGesture</code>的这个类目：<code>UINavigation+FDFullscreenPopGesture</code>，扩展了iOS7+的侧滑返回功能。取代从左边缘滑起的是，我们可以从屏幕的任意位置滑动，并且伴随着返回上个界面的过渡动画也可以正常流畅。</p></li></ul><h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><p>1.<code>自动支持全屏侧滑</code><br>2.<code>禁用导航/控制器的侧滑功能</code></p><h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><p>1.在 <code>UINavigationController</code> 的分类 <code>UINavigationController + FDFullscreenPopGesture</code>中，<br>暴露给用户的属性有:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface UINavigationController (FDFullscreenPopGesture)</span><br><span class="line"></span><br><span class="line">// 这个滑动手势，处理用户的侧滑弹出操作</span><br><span class="line">@property (nonatomic, strong, readonly) UIPanGestureRecognizer *fd_fullscreenPopGestureRecognizer;</span><br><span class="line"></span><br><span class="line">// 判断fd_viewControllerBasedNavigationBarAppearanceEnabled属性，视图控制器可以自己控制，而不是全局的方式控制，导航栏的外观。，默认是YES。</span><br><span class="line">@property (nonatomic, assign) BOOL fd_viewControllerBasedNavigationBarAppearanceEnabled;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>2.在 <code>UIViewController</code> 的分类 <code>UIViewController + FDFullscreenPopGesture</code>中，允许视图控制器禁用用户弹出手势，比如某些情况下，视图控制器需要自己处理滑动手势。<br>其中，暴露给用户的属性有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//当处于导航控制栈中时，是否禁用用户弹出手势；</span><br><span class="line">@property (nonatomic, assign) BOOL fd_interactivePopDisabled;</span><br><span class="line"></span><br><span class="line">//通过检查基于导航栏的视图控制器是否可用，来指明视图控制器的导航栏隐藏与否。默认是NO，一般导航栏是展示的。</span><br><span class="line">@property (nonatomic, assign) BOOL fd_prefersNavigationBarHidden;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>具体集成过程就不再讲解，如果有不知道的，看我<a href="">iOS-OC三方库01：SDCycleScrollView基本使用</a>集成过程，下面来看看具体使用：</p><p>1.把这个框架的<code>.h</code>文件添加到<code>全局的宏</code>中，所有的<code>导航控制器</code>都将<code>自动会支持全屏侧滑</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// FDFullscreenPopGesture(全屏侧滑)</span><br><span class="line">#import &lt;UINavigationController+FDFullscreenPopGesture.h&gt;</span><br></pre></td></tr></table></figure><p>2.禁用手势</p><ul><li>禁用导航控制器的侧滑功能:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.navigationController.fd_fullscreenPopGestureRecognizer.enabled = NO;</span><br></pre></td></tr></table></figure><ul><li>禁用当前viewcontroller的侧滑功能：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self = YES;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OC-三方框架探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理11：类 &amp; isa 底层面试题分析</title>
      <link href="/BboyZJ.github.io/2020/09/26/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8611%EF%BC%9A%E7%B1%BB%20&amp;%20isa%20%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
      <url>/BboyZJ.github.io/2020/09/26/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8611%EF%BC%9A%E7%B1%BB%20&amp;%20isa%20%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文的面试题主要涉及 <code>isa走位 &amp; 继承关系 &amp; 类结构 </code> 相关的面试题以及针对面试题的分析</p><h1 id="【面试题】类存在几份？"><a href="#【面试题】类存在几份？" class="headerlink" title="【面试题】类存在几份？"></a>【面试题】类存在几份？</h1><p>由于 <code>类的信息</code> 在内存中永远 <code>只存在一份</code>，所以 <code>类对象只有一份</code></p><h1 id="【百度面试题】objc-object-与-对象-的关系？"><a href="#【百度面试题】objc-object-与-对象-的关系？" class="headerlink" title="【百度面试题】objc_object 与 对象 的关系？"></a>【百度面试题】<code>objc_object</code> 与 <code>对象</code> 的关系？</h1><ul><li><p>所有的 <code>对象</code> 都是以 <code>objc_object</code> 为模板 <code>继承</code> 过来的</p></li><li><p>所有的 <code>对象</code> 都是 <code>来自NSObject(来自于OC端)</code>，但是真正到 <code>底层</code> 是一个 <code>objc_object（C/C++）</code> 结构体 <code>类型的</code></p></li></ul><p><strong>【总结】</strong>：<code>objc_object</code> 与 <code>对象</code> 的关系是 <code>继承</code> 关系</p><h1 id="【面试题】什么是-属性-amp-成员变量-amp-实例变量-？"><a href="#【面试题】什么是-属性-amp-成员变量-amp-实例变量-？" class="headerlink" title="【面试题】什么是 属性 &amp; 成员变量 &amp; 实例变量 ？"></a>【面试题】什么是 <code>属性 &amp; 成员变量 &amp; 实例变量</code> ？</h1><ul><li><p><code>属性(property)</code>：在 <code>OC</code> 中是通过 <code>@property</code> 开头 <code>定义</code>，且是 <code>带下划线成员变量 + setter + getter方法</code> 的变量</p></li><li><p><code>成员变量(ivar)</code>：在 <code>OC</code> 类的 <code>&#123;&#125;</code> 中定义的，且 <code>没有下划线的变量</code></p></li><li><p><code>实例变量</code>：通过当前对象类型，<code>具备实例化的变量</code>，是一种 <code>特殊的成员变量</code>，例如  <code>NSObject、UILabel、UIButton</code> 等</p></li></ul><h1 id="【面试题】元类-中为什么会有-类对象-的-类方法？"><a href="#【面试题】元类-中为什么会有-类对象-的-类方法？" class="headerlink" title="【面试题】元类 中为什么会有 类对象 的 类方法？"></a>【面试题】<code>元类</code> 中为什么会有 <code>类对象</code> 的 <code>类方法</code>？</h1><p>在上一章 <a href="https://www.bboyzj.cn/2020/09/24/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8610%EF%BC%9A%E7%B1%BB%20&%20%E7%B1%BB%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">OC底层原理10：类 &amp; 类结构分析</a> 中，我们知道了 <code>实例方法存储在类中</code>，<code>类方法存储在元类中</code></p><p>为了探索我们的面试题现象，定义了以下几个方法，来探索方法的归属问题</p><ul><li>在ZJPerson中定义一个实例方法和一个类方法，并实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">- (void)sayHello;</span><br><span class="line">+ (void)sayHappy;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ZJPerson</span><br><span class="line">- (void)sayHello&#123;</span><br><span class="line">    NSLog(@&quot;ZJPerson say : Hello!!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)sayHappy&#123;</span><br><span class="line">    NSLog(@&quot;ZJPerson say : Happy!!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>在 <code>main</code> 主函数，调用自定义的方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        ZJPerson * p = [ZJPerson alloc];</span><br><span class="line">        Class pClass = object_getClass(p);</span><br><span class="line">        // 获取类的方法</span><br><span class="line">        zjObjc_copyMethodList(pClass);</span><br><span class="line">        // 获取类和元类的实例方法</span><br><span class="line">        zjInstanceMethod_classToMetaclass(pClass);</span><br><span class="line">        // 获取类和元类的类方法</span><br><span class="line">        zjClassMethod_classToMetaclass(pClass);</span><br><span class="line">        // 获取类和元类的方法实现</span><br><span class="line">        zjIMP_classToMetaclass(pClass);</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>zjObjc_copyMethodList</code> ：用于获取 <code>类的方法列表</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 获取类的方法列表</span><br><span class="line">void zjObjc_copyMethodList(Class pClass)&#123;</span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    Method *methods = class_copyMethodList(pClass, &amp;count);</span><br><span class="line">    for (unsigned int i=0; i &lt; count; i++) &#123;</span><br><span class="line">        Method const method = methods[i];</span><br><span class="line">        //获取方法名</span><br><span class="line">        NSString *key = NSStringFromSelector(method_getName(method));</span><br><span class="line">        </span><br><span class="line">        ZJLog(@&quot;Method, name: %@&quot;, key);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看一下打印结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method, name: sayHello</span><br></pre></td></tr></table></figure><p>下面我们来分析一下打印结果:</p><p><strong>【zjObjc_copyMethodList函数】</strong></p><p>这个函数的主要作用是打印 <code>类</code> 中存在的 <code>方法</code>，由前面所知，<code>实例方法</code> 存储在 <code>类中</code>，因此打印结果只有 <code>Method, name: sayHello</code></p><ul><li><code>zjInstanceMethod_classToMetaclass</code> ：用于获取 <code>类和元类</code> 的 <code>实例方法</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void zjInstanceMethod_classToMetaclass(Class pClass)&#123;</span><br><span class="line">    </span><br><span class="line">    const char *className = class_getName(pClass);</span><br><span class="line">    Class metaClass = objc_getMetaClass(className);</span><br><span class="line">    </span><br><span class="line">    Method method1 = class_getInstanceMethod(pClass, @selector(sayHello));</span><br><span class="line">    Method method2 = class_getInstanceMethod(metaClass, @selector(sayHello));</span><br><span class="line"></span><br><span class="line">    Method method3 = class_getInstanceMethod(pClass, @selector(sayHappy));</span><br><span class="line">    Method method4 = class_getInstanceMethod(metaClass, @selector(sayHappy));</span><br><span class="line">    </span><br><span class="line">    ZJLog(@&quot;%s - %p-%p-%p-%p&quot;,__func__,method1,method2,method3,method4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看一下打印结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zjInstanceMethod_classToMetaclass - 0x100003100-0x0-0x0-0x100003098</span><br></pre></td></tr></table></figure><p>下面我们来分析一下打印结果:</p><p><strong>【zjInstanceMethod_classToMetaclass函数】</strong>:用于获取 <code>类和元类</code> 的 <code>类方法</code></p><p>在分析前先了解一下函数 <code>class_getInstanceMethod</code> :作用是获取实例方法，根据官方文档的解释:</p><p><img src="https://user-images.githubusercontent.com/25925248/95673850-da6aa700-0bde-11eb-93b1-c67694683310.png"></p><p>其大致含义就是：<code>如果在传入的类或者类的父类中没有找到指定的实例方法，则返回NULL</code></p><p>从上面的代码可知传入的 <code>pClass</code> 是 <code>ZJPerson 类</code>，metaClass 是 <code>ZJPerson元类</code>,函数中4个打印结果分别是：</p><ul><li><p><code>method1</code>的地址：<code>0x100003100</code><br>  传入的 <code>pClass</code> 是 <code>ZJPerson</code>，查找的方法是<code>sayHello实例方法</code>，由于ZJPerson中有该方法，所以返回的地址是 <code>0x100003100</code></p></li><li><p><code>method2</code>的地址：<code>0x0</code><br> 传入的 <code>metaClass</code> 是 <code>ZJPerson元类</code>，查找的方法是<code>sayHello实例方法</code>，由于ZJPerson中没有该方法，所以返回的地址是 <code>0x0</code></p></li><li><p><code>method3</code>的地址：<code>0x0</code><br> 传入的 <code>pClass</code> 是 <code>ZJPerson</code>，查找的方法是<code>sayHappy实例方法</code>，由于ZJPerson中没有该方法，所以返回的地址是 <code>0x0</code></p></li><li><p><code>method4</code>的地址：<code>0x100003098</code><br> 传入的 <code>metaClass</code> 是 <code>ZJPerson元类</code>，查找的方法是<code>sayHappy实例方法</code>，由于类ZJPerson中<code>类方法sayHappys</code>是以 <code>实例方法</code> 存储在 <code>元类中</code>的，因此<code>元类ZJPerson</code> 中有该方法，所以返回的地址是 <code>0x100003098</code></p></li><li><p><code>zjClassMethod_classToMetaclass</code>函数：获取类或类的父类中的类方法</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 类和元类-类方法</span><br><span class="line">void zjClassMethod_classToMetaclass(Class pClass)&#123;</span><br><span class="line">    </span><br><span class="line">    const char *className = class_getName(pClass);</span><br><span class="line">    Class metaClass = objc_getMetaClass(className);</span><br><span class="line">    </span><br><span class="line">    Method method1 = class_getClassMethod(pClass, @selector(sayHello));</span><br><span class="line">    Method method2 = class_getClassMethod(metaClass, @selector(sayHello));</span><br><span class="line"></span><br><span class="line">    Method method3 = class_getClassMethod(pClass, @selector(sayHappy));</span><br><span class="line">    // 元类 为什么有 sayHappy 类方法 0 1</span><br><span class="line">    //</span><br><span class="line">    Method method4 = class_getClassMethod(metaClass, @selector(sayHappy));</span><br><span class="line">    </span><br><span class="line">    ZJLog(@&quot;%s-%p-%p-%p-%p&quot;,__func__,method1,method2,method3,method4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看一下打印结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zjClassMethod_classToMetaclass-0x0-0x0-0x100003098-0x100003098</span><br></pre></td></tr></table></figure><p>下面我们来分析一下打印结果:</p><p><code>class_getClassMethod</code>：用于获取 <code>类或类的父类</code> 的 <code>类方法</code>，根据官方文档的解释:</p><p><img src="https://user-images.githubusercontent.com/25925248/95673759-3f71cd00-0bde-11eb-9f7c-2d74ade4a3d0.png"></p><p>其大致含义就是：<code>如果在传入的类或者类的父类中没有找到指定的类方法，则返回NULL</code></p><p>从上面的代码可知传入的 <code>pClass</code> 是 <code>ZJPerson 类</code>，<code>metaClass</code> 是 <code>ZJPerson元类</code>,函数中4个打印结果分别是：</p><ul><li><p><code>method1</code> 的地址：<code>0x0</code> 传入的 <code>pClass</code> 是 <code>ZJPerson</code>，查找的方法是<code>sayHello类方法</code>，由于ZJPerson中没有该方法，所以返回的地址是 <code>0x0</code></p></li><li><p><code>method2</code> 的地址：<code>0x0</code> 传入的 <code>metaClass</code> 是 <code>ZJPerson元类</code>，查找的方法是<code>sayHello类方法</code>，由于 <code>ZJPerson元类</code>中没有该方法，所以返回的地址是 <code>0x0</code></p></li><li><p><code>method3</code> 的地址：<code>0x100003098</code> 传入的 <code>pClass</code> 是 <code>ZJPerson</code>，查找的方法是 <code>sayHappy类方法</code>，由于ZJPerson中有该方法，所以返回的地址是 <code>0x100003098</code></p></li><li><p><code>method4</code>的地址：<code>0x100003098</code> 传入的 <code>metaClass</code> 是 <code>ZJPerson元类</code>，查找的方法是 <code>sayHappy类方法</code>，由于类ZJPerson中 <code>类方法sayHappys</code> 是以 <code>实例方法</code> 存储在 <code>元类中</code>的，因此 <code>元类ZJPerson</code> 中有该 <code>实例方法</code>，那么为什么会返回 <code>类方法sayHappy</code> 的地址呢？</p></li></ul><p><strong>【问题】</strong>：<code>ZJPerson元类</code> 为什么会有 <code>类方法sayHappy</code>？</p><p>我们查看一下源码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//获取类方法</span><br><span class="line">Method class_getClassMethod(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls  ||  !sel) return nil;</span><br><span class="line"></span><br><span class="line">    return class_getInstanceMethod(cls-&gt;getMeta(), sel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">⬇️</span><br><span class="line">//获取元类</span><br><span class="line"> // NOT identical to this-&gt;ISA when this is a metaclass 判断是否是元类，是元类就直接返回，反之，继续找isa指向</span><br><span class="line">Class getMeta() &#123;</span><br><span class="line">    if (isMetaClass()) return (Class)this;</span><br><span class="line">    else return this-&gt;ISA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可知：<code>class_getClassMethod</code> 的实现是获取类的类方法，其本质就是 <code>获取元类的实例方法</code>，最终还是会走到 <code>class_getInstanceMethod</code>，但是在这里需要注意的一点是，在 <code>getMeta</code> 源码中，如果判断出 <code>cls</code> 是 <code>元类</code>，那么就 <code>不会</code> 再继续往下 <code>递归查找</code>，会直接返回 <code>this</code> ，其目的是为了 <code>防止元类的无限递归查找</code></p><p><strong>【结论】</strong><br>由源码可知：</p><ul><li><p>获取元类的类方法，本质是 <code>获取元类的实例方法</code></p></li><li><p>方法method4：是会返回地址的</p></li><li><p><code>zjIMP_classToMetaclass</code> 函数：用于获取 <code>类和元类</code> 中的方法实现</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void zjIMP_classToMetaclass(Class pClass)&#123;</span><br><span class="line">    </span><br><span class="line">    const char *className = class_getName(pClass);</span><br><span class="line">    Class metaClass = objc_getMetaClass(className);</span><br><span class="line"></span><br><span class="line">    // - (void)sayHello;</span><br><span class="line">    // + (void)sayHappy;</span><br><span class="line">    IMP imp1 = class_getMethodImplementation(pClass, @selector(sayHello));</span><br><span class="line">    IMP imp2 = class_getMethodImplementation(metaClass, @selector(sayHello));</span><br><span class="line"></span><br><span class="line">    IMP imp3 = class_getMethodImplementation(pClass, @selector(sayHappy));</span><br><span class="line">    IMP imp4 = class_getMethodImplementation(metaClass, @selector(sayHappy));</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%p-%p-%p-%p&quot;,imp1,imp2,imp3,imp4);</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看一下打印结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x1000017c0-0x7fff72080580-0x7fff72080580-0x1000017f0</span><br></pre></td></tr></table></figure><p>下面我们来分析一下打印结果:</p><p><code>class_getMethodImplementation</code> ：用于获取 <code>类或类的父类</code> 的 <code>方法实现</code>，根据官方文档的解释:</p><p><img src="https://user-images.githubusercontent.com/25925248/95673682-785d7200-0bdd-11eb-9d80-94b19d82a1c9.png"></p><p>其大致含义就是：该函数在向类实例发送消息时会被调用，并返回一个指向 <code>方法实现函数的指针</code>。这个函数会比 <code>method_getImplementation(class_getInstanceMethod(cls, name))</code> 更快。返回的函数指针可能是一个指向 <code>runtime内部的函数</code>，而不一定是方法的实际实现。如果类实例无法响应 <code>selector</code> ，则返回的函数指针将是运行时 <code>消息转发机制</code> 的一部分</p><p>下面我们也可以通过这个方法的源码来印证上面的这个说法，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">IMP class_getMethodImplementation(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp;</span><br><span class="line"></span><br><span class="line">    if (!cls  ||  !sel) return nil;</span><br><span class="line"></span><br><span class="line">    //查找方法实现</span><br><span class="line">    imp = lookUpImpOrNil(nil, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER);</span><br><span class="line"></span><br><span class="line">    //如果没有找到，则进行消息转发</span><br><span class="line">    if (!imp) &#123;</span><br><span class="line">        return _objc_msgForward;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可知传入的 <code>pClass</code> 是 <code>ZJPerson 类</code>，<code>metaClass</code> 是 <code>ZJPerson元类</code>,函数中4个打印结果分别是：</p><ul><li><p><code>imp1</code>的地址：<code>0x1000017c0</code> 传入的 <code>pClass</code> 是 <code>ZJPerson</code>，查找的是<code>sayHello函数指针</code>，由于ZJPerson中有该函数指针，所以返回的地址是 <code>0x1000017c0</code></p></li><li><p><code>imp2</code>的地址：<code>0x7fff72080580</code> 传入的 <code>metaClass</code> 是 <code>ZJPerson元类</code>，查找的方法是 <code>sayHello类方法</code>，根据 <code>类方法存储在元类中</code> 可知，<code>sayHello</code>是一个实例方法，并不存储在元类中，也没有其任何实现，所以进行了 <code>消息转发</code></p></li><li><p><code>imp3</code>的地址：<code>0x7fff72080580</code> 传入的 <code>pClass</code> 是 <code>ZJPerson</code>，查找的方法是 <code>sayHappy类方法</code>，<code>sayHappy</code> 是一个类方法，并不存储在类中，也没有其任何实现，所以进行了 <code>消息转发</code></p></li><li><p><code>imp4</code>的地址：<code>0x1000017f0</code> 传入的 <code>metaClass</code> 是 <code>ZJPerson元类</code>，查找的方法是 <code>sayHappy类方法</code>，根据 <code>类方法存储在元类中</code>，可以在元类中查找到<code>sayHappy</code> 的具体实现，所以返回一个 <code>imp函数指针的地址</code></p></li></ul><p><strong>【总结】</strong></p><ul><li><p><code>class_getInstanceMethod</code>：获取 <code>实例方法</code>，如果指定的 <code>类或其父类</code> 不包含带有指定选择器的实例方法，则为NULL</p></li><li><p><code>class_getClassMethod</code>：获取 <code>类方法</code>，如果指定的类或其父类不包含具有指定选择器的类方法，则为NULL。</p></li><li><p><code>class_getMethodImplementation</code>：获取方法的具体实现，如果未查找到，则进行 <code>消息转发</code></p></li></ul><h1 id="【面试题】iskindOfClass-amp-isMemberOfClass-的理解"><a href="#【面试题】iskindOfClass-amp-isMemberOfClass-的理解" class="headerlink" title="【面试题】iskindOfClass &amp; isMemberOfClass 的理解"></a>【面试题】iskindOfClass &amp; isMemberOfClass 的理解</h1><ul><li><code>iskindOfClass &amp; isMemberOfClass</code> 类方法调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL re1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];       </span><br><span class="line">BOOL re2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];</span><br><span class="line">BOOL re3 = [(id)[ZJPerson class] isKindOfClass:[ZJPerson class]];</span><br><span class="line">BOOL re4 = [(id)[ZJPerson class] isMemberOfClass:[ZJPerson class]];</span><br><span class="line">NSLog(@&quot; re1 :%hhd\n re2 :%hhd\n re3 :%hhd\n re4 :%hhd\n&quot;,re1,re2,re3,re4);</span><br></pre></td></tr></table></figure><p>查看打印结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2020-09-16 23:45:31.732090+0800 KCObjc[41895:1261834]  re1 :1</span><br><span class="line"> re2 :0</span><br><span class="line"> re3 :0</span><br><span class="line"> re4 :0</span><br></pre></td></tr></table></figure><ul><li><code>iskindOfClass &amp; isMemberOfClass</code> 实例方法调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL re5 = [(id)[NSObject alloc] isKindOfClass:[NSObject class]];       </span><br><span class="line">BOOL re6 = [(id)[NSObject alloc] isMemberOfClass:[NSObject class]];     </span><br><span class="line">BOOL re7 = [(id)[ZJPerson alloc] isKindOfClass:[ZJPerson class]];      </span><br><span class="line">BOOL re8 = [(id)[ZJPerson alloc] isMemberOfClass:[ZJPerson class]];     </span><br><span class="line"></span><br><span class="line">NSLog(@&quot; re5 :%hhd\n re6 :%hhd\n re7 :%hhd\n re8 :%hhd\n&quot;,re5,re6,re7,re8);</span><br></pre></td></tr></table></figure><p>查看打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-09-16 23:45:31.733480+0800 KCObjc[41895:1261834]  re5 :1</span><br><span class="line"> re6 :1</span><br><span class="line"> re7 :1</span><br><span class="line"> re8 :1</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure><p><strong>【问题】</strong>：那么是为什么呢？接下来我们通过 <code>objc4</code> 源码来分析一下：</p><ul><li>要想分析源码，我们需要深入理解 <code>isa</code> 流程图，如下：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/94944488-e930ca00-050b-11eb-80ca-e204a449909c.png"></p><p><strong>注：NSObject类 和 NSObject根元类 不相等</strong></p><ul><li><p>接下来我们查一下 <code>isKindOfClass</code> 调用的源码:</p><ul><li>查看 <code>类</code> 调用的源码：</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls = self-&gt;ISA(); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls == cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看 <code>实例对象</code> 调用的源码:</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls == cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们再查看一下 <code>isMemberOfClass</code> 调用的源码：</p><ul><li>查看 <code>类</code> 调用的源码：</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return self-&gt;ISA() == cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看 <code>实例对象</code> 调用的源码:</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return [self class] == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><strong>【源码分析总结】</strong></p><ul><li><p><code>isKindOfClass</code></p><ul><li><p>类方法：<code>元类（isa） --&gt; 根元类（父类） --&gt; 根类（父类） --&gt; nil（父类）</code> 与 <code>传入类的对比</code></p></li><li><p>实例方法：<code>对象的类 --&gt; 父类 --&gt; 根类 --&gt; nil</code> 与 <code>传入类的对比</code></p></li></ul></li><li><p><code>isMemberOfClass</code></p><ul><li><p>类方法： <code>类的元类</code> 与 <code>传入类</code> 对比</p></li><li><p>实例方法：<code>对象的父类</code> 与 <code>传入类</code> 对比</p></li></ul></li></ul><p>由上面的源码我们知道了具体调用的源码，由此我们来具体分析为什么打印<code>1000 1111</code>这个结果:</p><p><strong>【使用类方法结果分析】</strong></p><ul><li><p>re1：1，是 <code>NSObject</code> 和 <code>NSObject</code> 的对比，使用 <code>+isKindOfClass</code></p><ul><li>NSObject（传入类，即 <code>根类</code>）vs NSObject的元类（即 <code>根元类</code>） 相比 – <code>不相等</code></li><li>NSObject（传入类，即 <code>根类</code>）vs 根元类的父类（即 <code>根类</code>）相比 – <code>相等</code></li></ul></li></ul><p><code>[NSObject class] isKindOfClass:[NSObject class]]</code> 内部调用分析图：</p><p><img src="https://user-images.githubusercontent.com/25925248/95671775-43e1ba00-0bcd-11eb-8697-64d59be5c414.png"></p><p>由上面的分析图可知：打印结果为 <code>1</code></p><ul><li><p>re2：0，是 <code>NSObject</code> 和 <code>NSObject</code> 的对比，使用 <code>+isMemberOfClass</code></p><ul><li>NSObject （传入类，即 <code>根类</code>） vs NSObject的元类（即 <code>根元类</code>）对比 – <code>不相等</code></li></ul></li></ul><p><code>[NSObject class] isMemberOfClass:[NSObject class]</code> 内部调用分析图：</p><p><img src="https://user-images.githubusercontent.com/25925248/95671830-b8b4f400-0bcd-11eb-8c87-1aa969615eb2.png"></p><ul><li><p>re3：0，是 <code>ZJPerson</code> 与 <code>ZJPerson</code> 的对比，使用 <code>+isKindOfClass</code></p><ul><li>ZJPerson（传入 <code>类</code>）vs ZJPerson的元类（即 <code>元类ZJPerson</code>） 对比 – <code>不相等</code></li><li>ZJPerson（传入 <code>类</code>）vs 元类ZJPerson的父类（即 <code>根元类</code>） 对比 – <code>不相等</code></li><li>ZJPerson（传入 <code>类</code>）vs 根元类的父类（即 <code>根类</code>） 对比 – <code>不相等</code></li><li>ZJPerson（传入 <code>类</code>）vs 根类的父类（即 <code>nil</code>） 对比 – <code>不相等</code></li></ul></li></ul><p><code>[ZJPerson class] isKindOfClass:[ZJPerson class]</code> 内部调用分析图：</p><p><img src="https://user-images.githubusercontent.com/25925248/95671878-3d077700-0bce-11eb-904d-35fd090a71f5.png"></p><ul><li><p>re4：0，是 <code>ZJPerson</code> 与 <code>ZJPerson</code> 的对比，使用 <code>+isMemberOfClass</code></p><ul><li>ZJPerson（传入 <code>类</code>）vs <code>元类</code> 对比 – <code>不相等</code></li></ul></li></ul><p><code>[ZJPerson class] isMemberOfClass:[ZJPerson class]</code> 内部调用分析图：</p><p><img src="https://user-images.githubusercontent.com/25925248/95671897-7fc94f00-0bce-11eb-8360-b07aca28d359.png"></p><p><strong>【使用实例方法结果分析】</strong></p><ul><li><p>re5：1，是 <code>NSObject对象</code> 和 <code>NSObject</code> 的对比，使用 <code>-isKindOfClass</code></p><ul><li>NSObject（传入 <code>根类</code>）vs 对象的 <code>isa</code>（即 <code>NSObject根类</code>） 对比 – <code>相等</code></li></ul></li></ul><p><code>[NSObject alloc] isKindOfClass:[NSObject class]</code> 内部调用分析图：</p><p><img src="https://user-images.githubusercontent.com/25925248/95671973-4e9d4e80-0bcf-11eb-9cc9-154398a78df7.png"></p><ul><li><p>re6：1，是 <code>NSObject对象</code> 和 <code>NSObject</code> 的对比，使用 <code>-isMemberOfClass</code></p><ul><li>NSObject（传入 <code>根类</code>）vs 对象的类（即 <code>NSObject根类</code>） 对比 – <code>相等</code></li></ul></li></ul><p><code>[NSObject alloc] isMemberOfClass:[NSObject class]</code>内部调用分析图：</p><p><img src="https://user-images.githubusercontent.com/25925248/95672004-8906eb80-0bcf-11eb-980d-6440b23696d3.png"></p><ul><li><p>re7：1，是 <code>ZJPerson对象</code> 和 <code>ZJPerson</code> 的对比，使用 <code>-isKindOfClass</code></p><ul><li>ZJPerson（传入 <code>类</code>）vs 对象的 <code>isa</code> （即 <code>ZJPerson</code>） 对比 – <code>相等</code></li></ul></li></ul><p><code>[ZJPerson alloc] isKindOfClass:[ZJPerson class]</code>内部调用分析图：</p><p><img src="https://user-images.githubusercontent.com/25925248/95672086-66290700-0bd0-11eb-8506-b6d6a914f54e.png"></p><ul><li><p>re8：1，是 <code>ZJPerson对象</code> 和 <code>ZJPerson</code> 的对比，使用 <code>-isMemberOfClass</code></p><ul><li>ZJPerson（传入 <code>类</code>）vs 对象的类（即 <code>ZJPerson</code>） 对比 – <code>相等</code></li></ul></li></ul><p><code>[ZJPerson alloc] isMemberOfClass:[ZJPerson class]</code> </p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理10：类 &amp; 类结构分析</title>
      <link href="/BboyZJ.github.io/2020/09/24/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8610%EF%BC%9A%E7%B1%BB%20&amp;%20%E7%B1%BB%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>/BboyZJ.github.io/2020/09/24/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8610%EF%BC%9A%E7%B1%BB%20&amp;%20%E7%B1%BB%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章主要的目的是分析 <code>类</code> 和 <code>类结构</code> </p><h1 id="objc-class-和-objc-object"><a href="#objc-class-和-objc-object" class="headerlink" title="objc_class 和 objc_object"></a>objc_class 和 objc_object</h1><p><strong>为什么 <code>对象</code> 和 <code>类</code> 都有 <code>isa指针</code>？</strong></p><p>在 <a href="https://www.bboyzj.cn/2020/09/20/iOS-OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8608%EF%BC%9Aisa%E5%92%8C%E7%B1%BB%E5%85%B3%E8%81%94%E6%8E%A2%E7%B4%A2/">iOS-OC底层原理08：isa和类关联探索</a> 中，使用 <code>clang</code> 编译过 <code>main.m</code> 文件，从编译后的 <code>main.cpp</code> 文件中,我们分析了 <code>对象</code> 的 <code>本质</code> 是 <code>结构体</code>，如下:</p><ul><li><code>NSObject</code> 的底层编译是 <code>struct objc_object</code> 结构体</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object NSObject;</span><br><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa __attribute__((deprecated));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>由编译后的 c++ 源码可知：</strong></p><ul><li><p><code>NSObject</code> 底层被编译成结构体 <code>struct objc_object</code> 类型，因此 <code>对象</code> 的本质是 <code>结构体</code></p></li><li><p><code>isa指针</code> 是 <code>Class</code> 类型的，是由 <code>struct objc_calss</code> 结构体定义的类型，所有的 <code>Class</code> 都是以 <code>objc_class</code> 为模板创建的</p></li><li><p><code>objc_object</code> 结构体内部有 <code>objc_class</code> 这个结构体，那么问题来了</p></li></ul><p><strong>【问题】<code>objec_class</code> 和 <code>objc_object</code> 有什么关系呢？</strong></p><p>我们通过查看 <code>objc4源码</code> 找到 <code>objc_class</code> 和 <code>objc_object</code> 的定义，来分析一下两者之间的关系：</p><ul><li><p>在<code>objc4</code>源码中搜索 <code>objc_class</code>，其源码定义如下:</p><ul><li>一个位于 <code>runtime.h</code> 文件中，已经被废弃了</li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/94989132-01085c80-05a5-11eb-9bc2-f9f47d1f2bc8.png"></p><ul><li>一个位于 <code>objc-runtime-new.h</code> 文件中，是可用的</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/94989263-f4d0cf00-05a5-11eb-8bba-635273f846ff.png"></p><ul><li><p>在 <code>objc4</code> 源码中搜索 <code>objc_object</code>，其源码定义如下：</p><ul><li>位于 <code>objc.h</code> 文件中</li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/94989053-5728d000-05a4-11eb-9117-4a82b7fd49c5.png"></p><p>通过上述查找源码和其定义，可总结出以下几点内容：</p><ul><li><p>结构体类型 <code>objc_class</code> 继承自 <code>objc_object</code> 类型，其中 <code>objc_object</code> 也是一个结构体，且有一个 <code>isa</code> 属性，所以 <code>objc_class</code> 也拥有了 <code>isa</code> 属性</p></li><li><p><code>mian.cpp</code> 底层编译文件中，<code>NSObject</code> 中的 <code>isa</code> 在底层是由 <code>Class</code> 定义的，其中 <code>class</code> 的底层编码来自 <code>objc_class</code> 类型，所以 <code>NSObject</code> 也拥有了 <code>isa</code>属性</p></li><li><p><code>NSObject</code> 是一个类，用它初始化一个实例对象 <code>objc</code>，<code>objc</code> 满足 <code>objc_object</code> 的特性（即有isa属性），主要是因为 <code>isa</code> 是由 <code>NSObject</code> 从<code>objc_class</code> 继承过来的，而 <code>objc_class</code> 继承自 <code>objc_object</code>，<code>objc_object</code> 有isa属性。所以 <code>对象</code> 都 <code>有</code> 一个 <code>isa</code>，isa表示指向，来自于当前的 <code>objc_object</code></p></li><li><p><code>objc_object（结构体</code>） 是 <code>当前的</code> 根对象，所有的 <code>对象</code> 都有这样一个特性 <code>objc_object</code>，即拥有 <code>isa属性</code></p></li></ul><p><strong>【百度面试题】objc_object 与 对象的关系?</strong></p><ul><li><p>所有的 <code>对象</code> 都是 <code>来自NSObject(来自于OC端)</code>，但是真正到<code>底层</code>是一个 <code>objc_object（C/c++）</code> 结构体 <code>类型的</code></p></li><li><p>所有的 <code>对象</code> 都是 <code>以objc_object</code> 模板 <code>继承</code>过来的</p></li></ul><p><strong>【总结】：</strong></p><ul><li><p>所有的 <code>对象 + 类 + 元类</code> 都有 <code>isa</code></p></li><li><p>所有的 <code>对象</code> 都是由 <code>objc_object继承</code> 来的</p></li><li><p>简单概括就是 <code>万物皆对象</code>，万物皆来源于 <code>objc_object</code>，有以下两点结论：</p><ul><li>所有以 <code>objc_object</code> 为模板 创建的 <code>对象</code>，都有 <code>isa属性</code></li><li>所有以 <code>objc_class</code> 为模板，创建的 <code>类</code>，都有 <code>isa属性</code></li></ul></li><li><p>在结构层面可以通俗的理解为 <code>上层OC</code> 与 <code>底层</code> 的对接：</p><ul><li>底层是通过 <code>结构体</code> 定义的 <code>模板</code>，例如 <code>objc_class、objc_object</code></li><li><code>上层</code> 是通过底层的模板创建的 一些类型，例如ZJPerson</li></ul></li></ul><h1 id="补充知识-内存偏移"><a href="#补充知识-内存偏移" class="headerlink" title="补充知识-内存偏移"></a>补充知识-内存偏移</h1><p>在分析 <code>类信息</code> 中存储哪些信息之前，需要先 <code>了解内存偏移</code>，因为分析 <code>类信息</code> 需要用到内存偏移</p><p><strong>1、【普通指针】</strong></p><p>定义一个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 普通指针</span><br><span class="line">void testOffset1()&#123;</span><br><span class="line">    // a/b : 变量  10 ： 值</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 10;</span><br><span class="line">    // a/b : 打印得值 &amp;a/&amp;b : 取a的地址指针</span><br><span class="line">    NSLog(@&quot;%d---%p&quot;,a,&amp;a);</span><br><span class="line">    NSLog(@&quot;%d---%p&quot;,b,&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在mian.m调用，查看打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-10-04 13:41:07.378260+0800 KCObjc[23781:838866] 10---0x7ffeefbff4a8</span><br><span class="line">2020-10-04 13:41:07.378948+0800 KCObjc[23781:838866] 10---0x7ffeefbff4ac</span><br></pre></td></tr></table></figure><p>由上述的打印结果可知：</p><ul><li><p><code>a、b</code> 都是 <code>常量型变量</code>，<code>a、b</code> 的 <code>地址指针不一样</code>，分别指向 <code>值10</code>，在内存中 <code>10</code> 是通过 <code>值拷贝</code>，分别赋值给 <code>a、b</code></p></li><li><p><code>a</code> 的地址是 <code>0x7ffeefbff4a8</code>，<code>b</code> 的地址是 <code>0x7ffeefbff4ac</code>，他们相差 <code>4字节</code>，这是由 <code>a/b</code> 本身类型(<code>Int占4个字节</code>) 决定的</p></li></ul><p>其地址指针指向如图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/95008850-eccd6980-064f-11eb-808f-c105ff5497e5.png"></p><p><strong>2、【对象指针】</strong></p><p>定义一个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 对象指针</span><br><span class="line">void testOffset2()&#123;</span><br><span class="line">    // p1：指针</span><br><span class="line">    ZJPerson * p1 = [ZJPerson alloc];</span><br><span class="line">    ZJPerson * p2 = [ZJPerson alloc];</span><br><span class="line">    NSLog(@&quot;%@---%p&quot;,p1,&amp;p1);</span><br><span class="line">    NSLog(@&quot;%@---%p&quot;,p2,&amp;p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mian.m调用，查看打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-10-04 14:14:59.341733+0800 KCObjc[24079:859357] &lt;ZJPerson: 0x101035830&gt;---0x7ffeefbff4a0</span><br><span class="line">2020-10-04 14:14:59.341901+0800 KCObjc[24079:859357] &lt;ZJPerson: 0x101035980&gt;---0x7ffeefbff4a8</span><br></pre></td></tr></table></figure><p>由上述的打印结果可知：</p><ul><li><p><code>p1、p2</code> 是 <code>一级地址指针</code>，<code>p1、p2</code> 是指向 <code>[ZJPerson alloc]</code> 申请内存空间</p></li><li><p><code>&amp;p1、&amp;p2</code> 是 <code>二级指针</code>， <code>&amp;p1、&amp;p2</code> 指向 <code>p1、p2</code> 对象的 <code>一级地址指针</code></p></li></ul><p>其地址指针指向如图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/95008855-f48d0e00-064f-11eb-9c05-f68f7302e56c.png"></p><p><strong>3、【数组指针】</strong></p><p>定义一个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 数组指针</span><br><span class="line">void testOffset3()&#123;</span><br><span class="line">    int c[4] = &#123;1,2,3,4&#125;;</span><br><span class="line">    int *d = c;</span><br><span class="line">    NSLog(@&quot;%p -- %p - %p&quot;, &amp;c, &amp;c[0], &amp;c[1]);</span><br><span class="line">    NSLog(@&quot;%p -- %p - %p&quot;, d, d+1, d+2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在mian.m调用，查看打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-10-04 14:38:14.720430+0800 KCObjc[24171:872712] 0x7ffeefbff490 -- 0x7ffeefbff490 - 0x7ffeefbff494</span><br><span class="line">2020-10-04 14:38:14.720522+0800 KCObjc[24171:872712] 0x7ffeefbff490 -- 0x7ffeefbff494 - 0x7ffeefbff498</span><br></pre></td></tr></table></figure><p>由上述的打印结果可知：</p><ul><li><p><code>&amp;c</code> 和 <code>&amp;c[0]</code> 都是取 <code>首地址</code>，即数组名等于首地址</p></li><li><p><code>&amp;c</code> 与 <code>&amp;c[1]</code> 相差 <code>4个字节</code>，地址之间相差的字节数，主要 <code>取决于</code> 存储的 <code>数据类型</code></p></li><li><p><code>*d</code> 代表取 <code>c</code> 的地址，可以通过 <code>lldb</code> 调试 <code>p *(d+1)、*(d+2) </code> 获取 地址 所对应的值 <code>2、4</code></p><p>  <img src="https://user-images.githubusercontent.com/25925248/95009188-aa595c00-0652-11eb-8f0b-1eeb58de6e28.png"></p></li><li><p>可以通过 <code>首地址+偏移量</code> 取出数组中的其他元素，其中偏移量 <code>是</code> 数组的 <code>下标</code>，内存中首地址实际移动的 <code>字节数</code> 等于 <code>偏移量 * 数据类型字节数</code></p></li></ul><p>其地址指针指向如图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/95009477-fd341300-0654-11eb-8fc1-2d2282ff5109.png"></p><h1 id="探索类信息中都有哪些内容"><a href="#探索类信息中都有哪些内容" class="headerlink" title="探索类信息中都有哪些内容"></a>探索类信息中都有哪些内容</h1><p>由前文可知，所有的 <code>类</code> 都是以 <code>objc_class</code> 模板创建的，通过 <code>objc4</code> 源码可知，<code>objc_class</code> 中包含许多属性，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA; // 继承自objc_object 的isa指针</span><br><span class="line">    Class superclass; // Class 类型的 superclass</span><br><span class="line">    cache_t cache; // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags</span><br><span class="line"></span><br><span class="line">    // 获取data</span><br><span class="line">    class_rw_t *data() const &#123;</span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //...此处省略许多方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【这些属性的定义】：</strong></p><ul><li><p><code>isa</code> 属性：继承自 <code>objc_object</code> 的isa，占 <code>8</code> 字节</p></li><li><p><code>superclass</code> 属性：<code>Class</code> 类型，Class是由 <code>objc_object</code> 定义的，是一个指针，占 <code>8</code> 字节</p></li><li><p><code>cache</code> 属性：简单从类型 <code>class_data_bits_t</code> 目前无法得知，而<code>class_data_bits_t</code> 是一个结构体类型，结构体的 <code>内存大小</code> 需要根据 <code>内部的属性</code> 来确定，而 <code>结构体指针才是8字节</code></p></li><li><p><code>bits</code>属性：只有 <code>首地址</code> 经过上面 <code>3个属性</code> 的 <code>内存大小总和</code> 的 <code>平移</code>，才能获取到 <code>bits</code></p></li></ul><p><strong>我们知道了 <code>objc_class</code> 中 <code>存储</code> 了 <code>类</code> 的 <code>信息</code>，那么如何去验证呢?</strong></p><p>【验证方法】lldb 调试验证：</p><ul><li>自定义一个ZJPerson类，继承自NSObject</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation ZJPerson</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>在 <code>main.m</code> 中初始化 <code>ZJPerson</code> 类和 <code>NSObject</code> 类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // insert code here...</span><br><span class="line">        </span><br><span class="line">        NSObject * obj = [NSObject alloc];</span><br><span class="line">        ZJPerson * p = [ZJPerson alloc];</span><br><span class="line">        NSLog(@&quot;Hello, World! %@ - %@&quot;,obj,p);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下断点到 <code>NSObject...</code> 行，通过 <code>lldb</code> 调试，过程如下：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/94992863-679a7400-05bf-11eb-994d-f208a825779a.png"></p><h1 id="计算cache-t的内存大小"><a href="#计算cache-t的内存大小" class="headerlink" title="计算cache_t的内存大小"></a>计算cache_t的内存大小</h1><p>由上面的分析，我们知道了 <code>cache_t</code> 内存大小 和 <code>内部属性</code> 有关，因此我们需要进入 <code>objc4-781新版本</code> 内部源码去分析</p><p>进入 <code>cache</code> 类 <code>cache_t</code> 的定义（只贴出了结构体中 <code>非static</code> 修饰的 <code>属性</code>，主要是因为 <code>static类型</code> 的属性 <code>不存在结构体</code> 的内存中），有如下几个属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED</span><br><span class="line">     // 是一个结构体指针类型，占8字节</span><br><span class="line">    explicit_atomic&lt;struct bucket_t *&gt; _buckets;</span><br><span class="line">    // 是mask_t 类型，而 mask_t 是 unsigned int 的别名，占4字节</span><br><span class="line">    explicit_atomic&lt;mask_t&gt; _mask;</span><br><span class="line">#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16</span><br><span class="line">    </span><br><span class="line">    ...此处省略</span><br><span class="line">    </span><br><span class="line">#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4    </span><br><span class="line"></span><br><span class="line">    ...此处省略</span><br><span class="line">    </span><br><span class="line">#else</span><br><span class="line">#error Unknown cache mask storage type.</span><br><span class="line">#endif   </span><br><span class="line"></span><br><span class="line">#if __LP64__</span><br><span class="line">    // 内部是 unsigned short 类型的 2字节</span><br><span class="line">    uint16_t _flags; // 2</span><br><span class="line">#endif</span><br><span class="line">    // 内部是 unsigned short 类型的 2字节</span><br><span class="line">    uint16_t _occupied; // 2</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算 <code>cache_t</code> 内部属性的大小，最后的内存大小总和都是 <code>16</code> 字节</p><ul><li><p><code>_buckets</code> 类型是 <code>struct bucket_t *</code>，是结构体指针类型，<code>占8字节</code></p></li><li><p><code>mask</code> 是 <code>mask_t</code> 类型，而 <code>mask_t</code> 是 <code>unsigned int</code> 的类型，<code>占4字节</code></p></li><li><p><code>_flags</code> 是 <code>uint16_t</code> 类型，<code>uint16_t</code>是 <code>unsigned short</code> 的类型，占 <code>2个字节</code></p></li><li><p><code>_occupied</code> 是 <code>uint16_t</code> 类型，<code>uint16_t</code>是 <code>unsigned short</code> 的类型，占 <code>2个字节</code></p></li></ul><p>总结：所以最后计算出 <code>cache_t</code> 类的内存大小 <code>= 8 + 4 + 2 + 2 = 16字节</code></p><h1 id="获取bits"><a href="#获取bits" class="headerlink" title="获取bits"></a>获取bits</h1><p>由上述计算 <code>Class类型 ISA 是 8字节</code>、<code>Class superclass 是 8 字节</code>、<code>cache_t cache 是 16字节;</code> 可知，想要获取 <code>bits</code> 的中的内容，只需通过 类的 首地址平移 <code>32字节（8 + 8 + 16）</code> 即可</p><p><strong>【验证】：通过lldb命令调试</strong></p><p>自定义两个类 <code>ZJPerson</code> 和继承自ZJPerson的 <code>ZJStudent</code> 类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">// 名字</span><br><span class="line">@property (nonatomic,copy)NSString * name;</span><br><span class="line">// 方法</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJPerson</span><br><span class="line">// 方法</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    NSLog(@&quot;来了!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface ZJStudent : ZJPerson</span><br><span class="line">@end</span><br><span class="line">@implementation ZJStudent</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>main.m中定义两个类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZJPerson * person = [ZJPerson alloc];</span><br><span class="line">ZJStudent * student = [ZJStudent alloc];</span><br><span class="line">// class_data_bits_t</span><br><span class="line">NSLog(@&quot;hello world :%@ %@&quot;,person,student);</span><br></pre></td></tr></table></figure><p>下断点到 <code>NSLog</code>，<code>lldb</code> 命令调试 <code>bits</code> 流程如下:</p><p><img src="https://user-images.githubusercontent.com/25925248/95011125-12af3a00-0661-11eb-97b7-e4098214b1f7.png"></p><p>由调试结果可知:</p><ul><li><p>通过 <code>p/x ZJPerson.class</code> 获类的信息，即 <code>首地址</code> 信息</p></li><li><p>通过 <code>x/4gx 0x0000000100002188</code> 拿到 首地址 <code>0x100002188</code>，经过 <code>32位平移</code> 得到 <code>bits</code> 地址 <code>0x1000021a8</code></p></li><li><p>通过 <code>p (class_data_bits_t *)0x1000021a8</code> 获取 <code>bits</code> </p></li><li><p>通过 <code>p $1-&gt;data()</code> 获取 <code>class_rw_t</code></p><ul><li>如果 <code>class_data_bits_t *</code> 是 <code>*</code> 号，说明是对象，访问对象用 <code>-&gt;</code></li><li>如果 <code>class_data_bits_t</code> 是 <code>结构体</code>，用 <code>.</code> 号</li></ul></li><li><p>通过 <code>p *$2</code> 打印 <code>bits</code> 中 <code>class_rw_t</code> 内部信息，<code>firstSubclass = ZJStudent</code>,表示第一个继承子类 <code>ZJStudent</code></p></li></ul><h1 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h1><p>通过查看 <code>class_rw_t</code> 定义的源码发现，结构体中有提供相应的方法去获取 <code>属性列表</code>、<code>方法列表</code> 等，如下所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/95011518-c9acb500-0663-11eb-8627-00c68bee909d.png"></p><h1 id="属性列表（property-list）"><a href="#属性列表（property-list）" class="headerlink" title="属性列表（property_list）"></a>属性列表（property_list）</h1><p><strong>【准备工作】</strong>：在ZJPerson中增加一个 <code>属性</code> 和一个 <code>成员变量</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString * sex; // 性别</span><br><span class="line">&#125;</span><br><span class="line">// 名字</span><br><span class="line">@property (nonatomic,copy)NSString * name;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJPerson</span><br></pre></td></tr></table></figure><p><strong>【探索】</strong> 由上图可知 <code>properties</code> 是 <code>property_array_t</code> 类型的，其内部源码如下：</p><p><img src="https://user-images.githubusercontent.com/25925248/95011600-58b9cd00-0664-11eb-8ed0-f811182a0604.png"></p><p>我们通过 <code>lldb</code> 调试属性列表，如下:</p><p><img src="https://user-images.githubusercontent.com/25925248/95012094-31fd9580-0668-11eb-9c08-0327d9da41b2.png"></p><p>由lldb调试可知:</p><ul><li><p><code>p $3.properties()</code> 命令中的 <code>propertoes</code> 方法是由 <code>class_rw_t</code> 提供的,方法中返回的实际类型为 <code>property_array_t</code></p></li><li><p>由于 <code>list</code> 的类型是 <code>property_list_t</code> ，是一个指针，所以通过 <code>p *$4</code> 获取内存中的信息，同时也证明 <code>bits</code> 中存储了 <code>property_list</code>，即属性列表</p></li><li><p><code>p $6.get(0)</code>，获取<code>ZJPerson</code>中的第一个属性 <code>name</code></p></li><li><p><code>p $6.get(1)</code>，想要获取 <code>ZJPerson</code> 中的成员变量 <code>sex</code>， 发现会报错，提示数组越界了，说明 <code>property_list</code> 中只有 一个属性 <code>name</code></p></li></ul><p><strong>【问题】探索成员变量的存储</strong></p><p>由此可得出 <code>property_list</code> 中只有 <code>属性</code>，没有 <code>成员变量</code> ，属性与成员变量的区别就是有没有set、get方法，如果有，则是属性，如果没有，则是成员变量。</p><p>那么问题来了，<code>成员变量</code> 存储在哪里？为什么会有这种情况？请移至文末的分析与探索</p><h1 id="方法列表（methods-list）"><a href="#方法列表（methods-list）" class="headerlink" title="方法列表（methods_list）"></a>方法列表（methods_list）</h1><p><strong>【准备工作】</strong> 在ZJPerson中增加两个方法，一个对象方法和一个类方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">- (void)sayHello;</span><br><span class="line">+ (void)sayBye;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJPerson</span><br><span class="line">- (void)sayHello&#123;</span><br><span class="line">    NSLog(@&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)sayBye&#123;</span><br><span class="line">    NSLog(@&quot;bye&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>【开始探索】通过 <code>lldb</code> 调试来获取方法列表，步骤如图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/95045583-ea811300-0714-11eb-83dd-1b842741344b.png"></p><p><strong>由lldb调试可知:</strong></p><ul><li><p>系统在编译的时候自动帮你生成</p></li><li><p>通过 <code>p $4.methods()</code> 获得具体的方法列表的list结构，其中 <code>methods</code> 也是<code>class_rw_t</code> 提供的方法</p></li><li><p>通过 <code>p *$6.</code> 打印的 <code>count = 4</code> 可知，存储了 <code>4</code> 个方法，其中 <code>syaHello</code> 是 <code>自己</code> 声明的方法，<code>cxx_destruct、name、setName:</code> 是 <code>系统</code> 生成的方法</p></li><li><p>可以通过<code>p $7.get(i)内存偏移</code> 的方式获取单个方法,<code>i</code> 的范围是 <code>0-3</code></p></li><li><p>如果在打印 <code>p $7.get(4)</code>，获取第五个方法，也会报错，提示 <code>数组越界</code></p></li></ul><h1 id="补充知识-属性、成员变量、实例变量"><a href="#补充知识-属性、成员变量、实例变量" class="headerlink" title="补充知识-属性、成员变量、实例变量"></a>补充知识-属性、成员变量、实例变量</h1><p>我们通常都知道 <code>@property</code> 是 <code>属性</code> 的意思，但是什么是 <code>成员变量</code> 和 <code>实例变量</code> 呢？我们探索一下：</p><p><strong>1、首先我们自定义一个类 <code>ZJPerson</code>，放在 <code>main.m</code> 中：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 成员变量 vs 属性</span><br><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString *hobby;</span><br><span class="line">    NSObject *objc;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, copy) NSString *nickName;</span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line">@end</span><br><span class="line">@implementation ZJPerson</span><br><span class="line">@end</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        // 属性&amp;成员变量&amp;实例变量</span><br><span class="line">        ZJPerson * P = [ZJPerson alloc];        </span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、我们通过 <code>clang</code> 编译一下这个 <code>main.m</code> 为 <code>main.cpp</code> ,来查看 <code>C</code> 的底层实现，步骤如下：</strong></p><p>1）我们打开终端，cd到你要编译文件的文件夹下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@192 ~ % cd /Users/mac/Desktop/逻辑教育/LG-OC底层大师班上课资料/20200914-大师班第5天-类原理分析-资料/01--课堂代码/001-类的属性与变量/001-类的属性与变量</span><br></pre></td></tr></table></figure><p>2）输入编译命令<code>clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk xxxx.m</code>编译你的目标文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mac@192 001-类的属性与变量 % clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk main.m</span><br></pre></td></tr></table></figure><p>3）然后你目录下就会重写一个 <code>cpp</code> 文件，内容比较多你可以搜索关键类 <code>ZJPerson</code> 对照查看：</p><p><img src="https://user-images.githubusercontent.com/25925248/93217433-a5179880-f79b-11ea-9324-1ea74f21998b.png"></p><p>3.我们打开 <code>main.cpp</code> 查找 <code>ZJPerson</code> 来查看一下：</p><p><img src="https://user-images.githubusercontent.com/25925248/93218809-376c6c00-f79d-11ea-9518-025708a64dde.png"></p><ul><li><code>hobby</code> 和 <code>objc</code> 没有下划线 <code>_</code>，是 <code>成员变量</code></li><li><code>nickName</code> 和 <code>name</code> 有下划线 <code>_</code>，是 <code>属性</code></li></ul><p>继续往下看：</p><p><img src="https://user-images.githubusercontent.com/25925248/93222275-5f5dce80-f7a1-11ea-9b57-877ed9861bbd.png"></p><ul><li><code>hobby</code> 和 <code>objc</code> 没有没有生成 <code>setter</code> 和 <code>getter</code> 方法，是 <code>成员变量</code></li><li><code>nickName</code> 和 <code>name</code> 有生成 <code>setter</code> 和 <code>getter</code> 方法，是 <code>属性</code></li></ul><p><strong>4、由上面我们知道了什么是成员变量和属性，那么实例变量呢？</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93219787-4ef82480-f79e-11ea-95b5-2cf401e6f7fb.png"></p><ul><li><p><code>hobby</code> 不能进行实例化，是 <code>成员变量</code></p></li><li><p><code>objc</code> 能进行实例化，是 <code>实例变量</code> ，也可以称特殊的成员变量,如: <code>objc = [NSObject alloc]</code> ;</p></li></ul><p><strong>5、我们用一下图表示 <code>成员变量&amp;实例变量&amp;属性</code> 的关系：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93222061-1574e880-f7a1-11ea-8d89-72bab64db0d3.png"></p><p><strong>6、由上面的分析我们得知了，什么是 <code>属性、成员变量和实例变量</code></strong></p><p>由上面的探索我们了解了什么是 <code>属性</code> 和 <code>成员变量</code>，我们也可以通过下面的方法来验证一下属性列表和成员变量列表是不是正确的，如下：</p><ul><li><code>zjObjc_copyIvar_copyProperies</code> 函数：打印 <code>变量</code> 和 <code>属性</code> 名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void zjObjc_copyIvar_copyProperies(Class pClass)&#123;</span><br><span class="line">    </span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    Ivar *ivars = class_copyIvarList(pClass, &amp;count);</span><br><span class="line">    for (unsigned int i=0; i &lt; count; i++) &#123;</span><br><span class="line">        Ivar const ivar = ivars[i];</span><br><span class="line">        // 获取实例变量名</span><br><span class="line">        const char*cName = ivar_getName(ivar);</span><br><span class="line">        NSString *ivarName = [NSString stringWithUTF8String:cName];</span><br><span class="line">        ZJLog(@&quot;class_copyIvarList:%@&quot;,ivarName);</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivars);</span><br><span class="line"></span><br><span class="line">    unsigned int pCount = 0;</span><br><span class="line">    objc_property_t *properties = class_copyPropertyList(pClass, &amp;pCount);</span><br><span class="line">    for (unsigned int i=0; i &lt; pCount; i++) &#123;</span><br><span class="line">        objc_property_t const property = properties[i];</span><br><span class="line">        // 获取属性名</span><br><span class="line">        NSString *propertyName = [NSString stringWithUTF8String:property_getName(property)];</span><br><span class="line">        // 获取属性值</span><br><span class="line">        ZJLog(@&quot;class_copyProperiesList:%@&quot;,propertyName);</span><br><span class="line">    &#125;</span><br><span class="line">    free(properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main.m中调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        //属性&amp;成员变量&amp;实例变量</span><br><span class="line">        ZJPerson * P = [ZJPerson alloc];</span><br><span class="line">        // 打印</span><br><span class="line">        Class pClass     = object_getClass(P);</span><br><span class="line">        zjTypes();</span><br><span class="line">        zjObjc_copyIvar_copyProperies(pClass);</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class_copyIvarList:hobby</span><br><span class="line">class_copyIvarList:objc</span><br><span class="line">class_copyIvarList:_nickName</span><br><span class="line">class_copyIvarList:_name</span><br><span class="line">class_copyProperiesList:nickName</span><br><span class="line">class_copyProperiesList:name</span><br></pre></td></tr></table></figure><p>由结果可知：</p><ul><li>成员变量列表有4个：<code>hobby、objc、_nickName、_name</code> 。</li><li>属性列表有2个： <code>nickName、name</code>。</li></ul><h1 id="成员变量的存储（ivars）"><a href="#成员变量的存储（ivars）" class="headerlink" title="成员变量的存储（ivars）"></a>成员变量的存储（ivars）</h1><p>由上面的属性列表分析可得出 <code>property_list</code> 中只有 <code>属性</code>，没有 <code>成员变量</code>，那么问题来了，成员变量 <code>存储在哪里</code> ？为什么会有这种情况？</p><p>通过 <code>objc4-781最新源码</code> 查看 <code>objc_class</code> 中 <code>bits属性</code> 中存储数据的类 <code>class_rw_t</code> 的结构发现，除了 <code>methods、properties、protocols</code> 方法，还有一个 <code>ro</code> 方法，其返回类型是 <code>class_ro_t</code> ，如下图所示:</p><p><img src="https://user-images.githubusercontent.com/25925248/95050773-b6125480-071e-11eb-8fa3-615a44917b47.png"></p><p>点击进去查看 <code>class_ro_t</code> 定义，<br>如下图：</p><p><img src="https://user-images.githubusercontent.com/25925248/95051059-333dc980-071f-11eb-8a1e-f9d7f1e88e91.png"></p><p>发现其中有一个  <code>ivars属性</code> ，我们可以做如下猜测：是否成员变量就存储在这个  <code>ivar_list_t</code> 类型的 <code>ivars</code> 属性中呢？</p><p>下面我们通过 <code>lldb</code> 的调试来验证一下：</p><p><img src="https://user-images.githubusercontent.com/25925248/95055265-9fbbc700-0725-11eb-934c-b467d8b27acb.png"></p><p>由上图lld调试可知：</p><ul><li><p>通过 <code>p *$7</code> 打印成员变量列表，<code>count = 2</code>，我们知道 <code>class_ro_t</code> 中包含两个 成员变量 <code>sex</code> 和 <code>name</code></p></li><li><p>通过 <code>bits --&gt; data() --&gt;ro() --&gt; ivars</code> 获取 <code>成员变量</code> 列表，除了包括成员变量，还包括 <code>属性</code> 定义的 <code>成员变量</code></p></li><li><p>通过 <code>@property</code> 定义的属性，也会存储在 <code>bits</code> 属性中，通过 <code>bits --&gt; data() --&gt; properties() --&gt; list</code> 获取属性列表，其中只存储 <code>属性</code></p></li></ul><h1 id="类方法的存储"><a href="#类方法的存储" class="headerlink" title="类方法的存储"></a>类方法的存储</h1><p>我们由前文探索方法列表可知，在 <code>method_list</code> 中 <code>没有类方法</code>，<code>只有实例方法</code>，那么问题来了，类方法存储在哪里？为什么会有这种情况？下面我们来仔细分析下</p><p>我们在 <a href="https://www.bboyzj.cn/2020/09/22/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8609%EF%BC%9Aisa%E8%B5%B0%E5%90%91&%E7%BB%A7%E6%89%BF%E5%88%86%E6%9E%90/">OC底层原理09：isa走向&amp;继承分析</a> 中，曾提及了 <code>元类</code>，类对象的 <code>isa</code> 指向就是 <code>元类</code>，元类是用来 <code>存储类</code> 的 <code>相关信息</code> 的，所以我们猜测：是否 <code>类方法</code>  是否存储在 <code>源类bits方法</code> 中呢？可以通过 <code>lldb</code> 命令来验证我们的猜测。下图是 <code>lldb</code> 命令的调试流程：</p><p><img src="https://user-images.githubusercontent.com/25925248/95059246-32ab3000-072b-11eb-93c3-8e3ae8302a88.png"></p><p>由上图lld调试可知：</p><ul><li><p>类的 <code>实例方法</code> 存储在 <code>类的bits属性</code> 中，通过 <code>bits --&gt; methods() --&gt; list</code> 获取实例方法列表，例如 <code>ZJPerson类</code> 的 实例方法 <code>sayHello</code> 就存储在<code>ZJPerson类</code> 的 <code>bits属性</code> 中，类中的方法列表除了 <code>包括实例方法</code>，还包括系统自动生成的 <code>属性</code> 的 <code>set方法</code> 、 <code>get方法</code> 和 <code>cxx_destruct</code>方法，</p></li><li><p>类的 <code>类方法</code> 存储 <code>在元类</code> 的 <code>bits属性</code> 中，通过元类 <code>bits --&gt; methods() --&gt; list</code> 获取类方法列表，例如ZJPerson中的类方法 <code>sayBye</code> 就存储在ZJPerson类的 <code>元类</code>（名称也是ZJPerson）的 <code>bits属性</code> 中</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理09：isa走向&amp;继承分析</title>
      <link href="/BboyZJ.github.io/2020/09/22/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8609%EF%BC%9Aisa%E8%B5%B0%E5%90%91&amp;%E7%BB%A7%E6%89%BF%E5%88%86%E6%9E%90/"/>
      <url>/BboyZJ.github.io/2020/09/22/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8609%EF%BC%9Aisa%E8%B5%B0%E5%90%91&amp;%E7%BB%A7%E6%89%BF%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>本文的主要目的是分析 <code>isa走向</code> 和 <code>继承</code> 的分析</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>定义两个类 :</p><ul><li>继承自 <code>NSObject</code> 的 <code>ZJPerson</code> 类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation ZJPerson</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>继承自 <code>ZJPerson</code> 的 <code>ZJStudent</code> 类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJStudent : ZJPerson</span><br><span class="line">@end</span><br><span class="line">@implementation ZJStudent</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>在 <code>main.m</code> 中 分别创建两个对象：<code>person &amp; student</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // ISA_MASK  0x00007ffffffffff8ULL</span><br><span class="line">        ZJPerson * person = [ZJPerson alloc];</span><br><span class="line">        ZJStudent * student = [ZJStudent alloc];</span><br><span class="line">        NSLog(@&quot;Hello World:%@ - %@&quot;,person,student);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h1><p>首先，我们先通过一个案例的 <code>lldb</code> 调试引入 <code>元类</code> 概念</p><p>在 <code>main</code> 中 <code>NSLog(@&quot;Hello World:%@ - %@&quot;,person,student);</code> 处下一个 <code>断点</code>，运行程序，开启 <code>lldb</code> 调试，调试的过程如下图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/94885178-22345480-04a2-11eb-99ce-97d34625106a.png"></p><ul><li><p><code>x/4gx person</code> ：查看 <code>person</code> 的内存分布情况，拿到 <code>isa</code> 的指针地址 <code>0x001d8001000021d1</code></p></li><li><p><code>p/x person</code> ：拿到 <code>0x0000000101159370</code> 地址，这个地址首先代表 <code>首地址</code>，其次代表 <code>当前对象</code>，也代表 <code>isa</code>，</p><p>  <strong>那么为什么即代表当前对象，又代表 isa 呢？</strong></p><ul><li>任何自定义的类，如<code>ZJPerson</code>，均继承自<code>NSObject</code>，<code>NSObject</code> 默认第一个参数为 <code>Class isa</code>，所以首地址会指向 <code>isa</code>，<code>isa</code> 又代表当前的类</li></ul></li><li><p><code>p/x 0x001d8001000021d1 &amp; 0x00007ffffffffff8ULL</code>：获取 <code>类ZJPerson</code>  的指针地址 <code>0x00000001000021d0</code></p></li><li><p><code>po 0x00000001000021d0</code>：根据 <code>类</code> 的指针地址 <code>0x00000001000021d0</code> 打印 <code>类信息</code>，<code>得到</code> 类 <code>ZJPerson</code></p></li><li><p>查看类的<code>内存分布</code>有三种方式：</p><ul><li>通过 <code>类</code> 的 <code>指针地址</code>: <code>x 0x00000001000021d0</code></li><li>通过 <code>class</code> 的 API: <code>x ZJPerson.class</code>    </li><li>通过 <code>runtime</code> 的 API: <code>x object_getClass(person)</code></li></ul></li><li><p><code>x/4gx 0x00000001000021d0</code>：查看 <code>类ZJPerson</code> 的 <code>内存分布</code> 情况，拿到 <code>isa</code> 指针地址 <code>0x00000001000021a8</code></p></li><li><p><code>po 0x00000001000021a8</code>：打印<code>ZJPerson类</code>的<code>isa</code>指针指向的内容，即 <code>元类</code>，其元类也是<code>ZJPerson</code></p></li><li><p><code>p/x 0x00000001000021a8 &amp; 0x00007ffffffffff8ULL</code>：通过 <code>类isa &amp; mask </code>获取<code>元类</code>的isa指针地址<code>0x00000001000021a8</code></p></li><li><p><code>po 0x00000001000021a8</code>：打印 <code>元类</code> 的指针信息，拿到 <code>ZJPerson</code></p></li></ul><p>根据调试过程，我们产生了一个疑问：为什么图中的 <code>p/x 0x001d8001000021d1 &amp; 0x00007ffffffffff8ULL</code> 与 <code>p/x 0x00000001000021a8 &amp; 0x00007ffffffffff8ULL</code> 中的类信息打印出来都是 <code>ZJPerson</code>？</p><ul><li><p><code>0x001d8001000021d1</code> 是 <code>person对象的</code> isa指针地址，其 <code>&amp; mask</code> 后得到的结果是获取对象 <code>person</code> 的 <code>类ZJPerson</code></p></li><li><p><code>0x00000001000021a8</code> 是 <code>元类的isa指针地址</code>，即 <code>ZJPerson类的类</code> 的isa指针地址，在Apple中，我们简称 <code>ZJPerson类的类</code> 为 <code>元类</code></p></li><li><p>所以，两个打印都是 <code>ZJPerson</code> 的根本原因就是因为 <code>元类</code> 导致的</p></li></ul><p><strong>元类的说明:</strong></p><p>下面来解释什么是元类，主要有以下几点说明：</p><ul><li><p>我们知道 <code>对象的isa</code> 是 <code>指向类</code>，<code>类</code> 其实 <code>也是</code> 一个 <code>对象</code>，可以称为 <code>类对象</code>，其 <code>isa</code> 的位域 <code>指向</code> 苹果定义的 <code>元类</code></p></li><li><p><code>元类</code> 是 <code>系统生成</code> 的，其定义和创建都是由编译器完成，在这个过程中，<code>类</code> 的归属 <code>来自</code> 于 <code>元类</code></p></li><li><p><code>元类</code> 是 <code>类对象</code> 的 <code>类</code>，每个类都有一个独一无二的元类用来存储 类方法的相关信息。</p></li><li><p>元类本身是没有名称的，由于与类相关联，所以使用了同类名一样的名称</p></li></ul><h1 id="isa走向"><a href="#isa走向" class="headerlink" title="isa走向"></a>isa走向</h1><p>下面通过 <code>lldb</code> 命令来探索isa指针的走向，如下图所示:</p><p><img src="https://user-images.githubusercontent.com/25925248/94929091-335b8080-04f7-11eb-85f5-1c3f710f9019.png"></p><p>由上图 <code>lldb</code> 探索可以得出一个关系链：<code>对象 --&gt; 类 --&gt; 元类 --&gt; NSobject --&gt; 指向自己</code></p><p>下面用一张图表示 isa走向 流程：</p><p><img src="https://user-images.githubusercontent.com/25925248/94932912-445ac080-04fc-11eb-8f04-02e10bc53b8d.png"></p><p>由上面的分析结果我们可知：</p><ul><li><code>实例对象</code> 的 <code>isa</code> 指针指向 <code>类</code></li><li><code>类对象</code> 的 <code>isa</code> 指针指向 <code>元</code> 类</li><li><code>元类</code> 的 <code>isa</code> 指针指向 <code>根元类</code></li><li><code>根元类</code> 的 <code>isa</code> 指针指向 <code>自己</code></li></ul><h1 id="NSObject到底有几个？"><a href="#NSObject到底有几个？" class="headerlink" title="NSObject到底有几个？"></a>NSObject到底有几个？</h1><p>由上图可知，最后的根元类是NSObject，这和我们日常开发中所知道的NSObject是同一个吗？</p><p>有以下两种验证方式</p><ul><li>【方法一】lldb命令验证</li><li>【方法二】代码验证</li></ul><p>【方法一】lldb命令验证</p><p><img src="https://user-images.githubusercontent.com/25925248/94935738-fd6eca00-04ff-11eb-89d7-c8a00645f1b2.png"></p><p>从图中可以看出，由实例对象 <code>person</code> 最终 <code>isa</code> 找到的根源个 <code>NSObject</code>，与下面 开发中使用的 <code>NSobject</code> 相同，所以可以得出一个结论：<code>内存中只存在一份根元类NSObject</code>，根元类的元类是指向它自己</p><p>【方法二】代码验证</p><p>通过三种不同的方式获取类，看他们打印的地址是否相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// MARK: -分析类对象在内存中存在几份</span><br><span class="line">void testClassNum()&#123;</span><br><span class="line">    Class class1 = [ZJPerson class];</span><br><span class="line">    Class class2 = [ZJPerson alloc].class;</span><br><span class="line">    Class class3 = object_getClass([ZJPerson alloc]);</span><br><span class="line">    NSLog(@&quot;\n%p-\n%p-\n%p&quot;, class1, class2, class3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的运行结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2020-10-02 22:46:53.183944+0800 ZJObjc[21320:623345] </span><br><span class="line">0x100002190-</span><br><span class="line">0x100002190-</span><br><span class="line">0x100002190</span><br></pre></td></tr></table></figure><p>从打印结果中可以看出，打印的 <code>地址</code> 都是 <code>同一个</code> ，所以 <code>类对象</code> 在内存中 <code>只存在一份</code>。</p><p><strong>【面试题】</strong></p><p><strong>问：类对象在内存中存在几份？</strong></p><p>答：由于类信息在内存中只存在一份，所以 <code>类对象只存在一份</code></p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>下面我们通过两道面试题来了解一下继承关系</p><p><strong>1、【面试题1】：</strong></p><p>我们知道 <code>类ZJTeacher</code> 继承自 <code>类ZJPerson</code> ，那么 <code>实例对象tearher</code> 和 <code>实例对象person</code> 有关系么？</p><p>答：<code>没有关系</code></p><p><strong>分析：</strong></p><ul><li>继承关系之来源与 <code>类</code></li><li>实例对象没有关系</li></ul><p><strong>2、【面试题2】：</strong></p><p><code>ZJTearher</code> 继承自 <code>ZJPerson</code>，<code>ZJPerson</code> 继承自 <code>NSObject</code>,那么 <code>NSObject</code> 继承自谁呢？</p><p>答：<code>NSObject</code> 继承自 <code>nil</code></p><p>用一张图来总结一下继承关系:</p><p><img src="https://user-images.githubusercontent.com/25925248/94942562-0fa13600-0509-11eb-998d-27656ba81a74.png"></p><h1 id="ZJTeacher-和-NSObject-isa-走位图"><a href="#ZJTeacher-和-NSObject-isa-走位图" class="headerlink" title="ZJTeacher 和 NSObject isa 走位图"></a>ZJTeacher 和 NSObject isa 走位图</h1><p>由上面 <code>继承</code> 和 <code>isa走位图</code> 分析，我们可以得出 <code>ZJTeacher</code> 和 <code>NSObject</code> 的 <code>isa走位</code> 图：</p><p><img src="https://user-images.githubusercontent.com/25925248/94943543-72df9800-050a-11eb-857a-f9b0988c705d.png"></p><h1 id="继承-和-isa走位图"><a href="#继承-和-isa走位图" class="headerlink" title="继承 和 isa走位图"></a>继承 和 isa走位图</h1><p>根据上面的探索以及各种验证，我们可以得到著名的 <code>继承 &amp; isa走位图</code>：</p><p><img src="https://user-images.githubusercontent.com/25925248/94944488-e930ca00-050b-11eb-80ca-e204a449909c.png"></p><p><strong>isa走位链三条：</strong></p><ul><li><p><code>teacher（实例对象） -&gt; ZJTeacher（类） -&gt; ZJTeacher（元类）-&gt; NSObject（根元类）-&gt; NSObject（根根元类）</code></p></li><li><p><code>person（实例对象） -&gt; ZJPerson（类） -&gt; ZJPerson（元类）-&gt; NSObject（根元类）-&gt; NSObject（根根元类）</code></p></li><li><p><code>object（实例对象） -&gt; NSObject（类） -&gt; NSObject（元类）-&gt; NSObject（根元类）-&gt; NSObject（根根元类）</code></p></li></ul><p><strong>继承链两条：</strong></p><ul><li><p><code>ZJTeacher（子类）-&gt; ZJPerson（父类）-&gt; NSObject(根类) -&gt; nil</code></p></li><li><p><code>ZJTeacher（子元类）-&gt; ZJPerson（父元类）-&gt; NSObject(根元类) -&gt; NSObject（根类）-&gt; nil</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理08：isa和类关联探索</title>
      <link href="/BboyZJ.github.io/2020/09/18/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8608%EF%BC%9Aisa%E5%92%8C%E7%B1%BB%E5%85%B3%E8%81%94%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/09/18/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8608%EF%BC%9Aisa%E5%92%8C%E7%B1%BB%E5%85%B3%E8%81%94%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文的主要目的是理解 <code>类与isa</code> 是如何 <code>关联</code> 的</p><p>在介绍正文之前，首先需要理解一个概念：<code>OC对象</code> 的 <code>本质</code> 是什么？</p><p>在探索oc对象本质前，先了解一个编译器：<code>clang</code></p><h1 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a>Clang</h1><p><strong>1、介绍</strong></p><p><code>Clang</code> 是⼀个由 <code>Apple</code> 主导编写，基于 <code>LLVM的C/C++/Objective-C</code> 编译器</p><p>主要是用于 <code>底层编译</code>，将一些文件输出成 <code>c++</code> 文件，例如 <code>main.m</code> 输出成 <code>main.cpp</code>，其目的是为了更好的观察 <code>底层</code> 的一些 <code>结构</code> 及 <code>实现</code> 的逻辑，方便理解底层原理。</p><p><strong>2、 常用编译命令：</strong></p><p>把⽬标⽂件编译成 <code>c++</code> ⽂件，终端输入</p><p><code>clang -rewrite-objc main.m -o main.cpp</code></p><p><strong>3、 xcode安装的时候顺带安装了 <code>xcrun</code> 命令，<code>xcrun</code> 命令在 <code>clang</code> 的基础上进⾏了<br>⼀些封装，要更好⽤⼀些：</strong></p><p><code>xcrun -sdk iphonesimulator clang -arch arm64 -rewrite-objc main.m -o  main-arm64.cpp (模拟器) </code></p><p><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o mainarm64.cpp (⼿机) </code></p><h1 id="对象的本质"><a href="#对象的本质" class="headerlink" title="对象的本质"></a>对象的本质</h1><p>**1、 第一步：自定义一个 <code>ZJPerson</code> 类，添加一个属性 <code>name</code> **</p><p><img src="https://user-images.githubusercontent.com/25925248/164404898-af819f31-5102-43a6-a75d-60e502569e63.jpg"></p><p><strong>2、 通过终端，利用 <code>clang</code> 将 <code>main.m</code> 编译成 <code>main.cpp</code>，有以下几种编译命令，这里使用的是第一种:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1、将 main.m 编译成 main.cpp</span><br><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br><span class="line"></span><br><span class="line">// 2、将 main.m 编译成  main.cpp</span><br><span class="line">clang -rewrite-objc -fobjc-arc -fobjc-runtime=ios-13.0.0 -isysroot / /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator13.7.sdk main.m</span><br><span class="line"></span><br><span class="line">// 以下两种方式是通过指定架构模式的命令行，使用xcode工具 xcrun</span><br><span class="line">// 3、模拟器文件编译</span><br><span class="line">xcrun -sdk iphonesimulator clang -arch arm64 -rewrite-objc main.m -o </span><br><span class="line">main-arm64.cpp </span><br><span class="line"></span><br><span class="line">// 4、真机文件编译</span><br><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o mainarm64.cpp </span><br></pre></td></tr></table></figure><p><strong>3、打开编译好的 <code>main.cpp</code>，找到 <code>ZJPerson</code> 的定义，发现 <code>ZJPerson</code> 在底层会被编译成 <code>struct</code> 结构体:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 👇NSObject的定义</span><br><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 👇NSObject的底层编译</span><br><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 👇ZJPerson的底层编译</span><br><span class="line">struct ZJPerson_IMPL &#123;</span><br><span class="line">    // NSObject_IVARS是isa</span><br><span class="line">    // 结构体在c/c++可以继承的，继承自NSObject_IMPL</span><br><span class="line">struct NSObject_IMPL NSObject_IVARS; </span><br><span class="line">NSString *_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如下图：<br><img src="https://user-images.githubusercontent.com/25925248/93706748-1c627900-fb5c-11ea-969c-fccbde897f72.png"></p><ul><li><p><code>ZJPerson</code> 继承自 <code>NSObject</code>，属于 <code>伪继承</code> ，<code>伪继承</code> 的方式是直接将<code>NSObject</code> 结构体定义为 <code>ZJPerson</code> 中的第一个属性，意味着 <code>ZJPerson</code> 拥有 <code>NSObject</code> 中的所有 <code>成员变量</code>。</p></li><li><p><code>ZJPerson</code> 中的第一个属性就是 <code>Class isa</code>。</p></li></ul><p><strong>4、 总结</strong></p><ul><li><p><code>OC对象</code> 的 <code>本质</code> 其实就是 <code>结构体</code></p></li><li><p><code>ZJPerson</code> 中的 <code>isa</code> 是 <code>继承</code> 自 <code>NSObject</code> 中的 <code>isa</code></p></li></ul><h1 id="objc-setProperty"><a href="#objc-setProperty" class="headerlink" title="objc_setProperty"></a>objc_setProperty</h1><p>由上面可知 <code>ZJPerson</code> 被编译成 <code>结构体</code>，属性 <code>name</code> 被编译成对应的 <code>set</code> 和 <code>get</code> 方法，其中 <code>set</code> 方法的实现是依赖 <code>runtime API objc_setProperty</code> 实现的。</p><p><strong>1、我们可以通过查找 <code>objc4</code> 源码来查看 <code>objc_setProperty</code> 底层的进一步实现：</strong></p><p>1）全局搜索 <code>objc_setProperty</code>，查找所在位置</p><p><img src="https://user-images.githubusercontent.com/25925248/93706832-e2de3d80-fb5c-11ea-8d4d-464e291864ec.png"></p><p>2）点击进入 <code>objc_setProperty</code> 内部查看源码实现</p><p><img src="https://user-images.githubusercontent.com/25925248/93707006-f4741500-fb5d-11ea-9a0d-0fc9238afa45.png"></p><p>3）点击 <code>reallySetProperty</code> 查看内部源码实现</p><p><img src="https://user-images.githubusercontent.com/25925248/93706916-5d0ec200-fb5d-11ea-94d5-7e1769231df1.png"></p><p><strong>2、总结</strong></p><p>通过对 <code>objc_setProperty</code> 底层源码探索，我们可得出以下几个结论：</p><ul><li><p><code>所有</code> 的 <code>set</code> 方法最终都将会 <code>找到objc_setProperty</code> LLVM中间 <code>隔离层</code> 函数去 <code>调用</code></p></li><li><p><code>objc_setProperty</code> 用于 <code>关联上层</code> 的 <code>set</code> 方法 和 <code>下层</code> 的<code>reallySetProperty</code> 的一个 <code>接口隔离层</code> 函数</p></li><li><p>这么设计的原因是，如果上层有 <code>很多set</code> 方法，如果你直接调用 <code>下层</code> 的 <code>LLVM</code> 方法，会 <code>产生很多中间层变量</code>，非常恶心，<code>很难</code> 去处理（很难<code>找</code>）</p></li><li><p>那么如何区分呢，系统根据 <code>cmd</code> 去查找，就是说无论你 <code>上层</code> 怎么<code>变化</code>，我下层<code>reallySetProperty</code> 都 <code>不用变化</code>，你 <code>下层</code> 怎么 <code>变化</code> ，<code>上层</code> 都 <code>不会被影响</code></p></li></ul><p><strong>3、上层、隔离层、底层之间的关系图：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93707549-50d93380-fb62-11ea-840e-66b9aa0d47d5.png"></p><h1 id="联合体和结构体"><a href="#联合体和结构体" class="headerlink" title="联合体和结构体"></a>联合体和结构体</h1><p>在 <a href="https://www.bboyzj.cn/2020/09/07/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8603%EF%BC%9Aalloc&init&new%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">iOS-OC底层原理03：alloc&amp;init&amp;new探索</a> 和 <a href="https://www.bboyzj.cn/2020/09/16/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8607%EF%BC%9Amalloc%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2/">iOS-OC底层原理07：malloc源码探索</a> 中我们分<br>别探索了alloc核心源码中的前两个，分别是 <code>cls-&gt;instanceSize</code> 和 <code>calloc</code> ，今天我们来探索最后一个 <code>obj-&gt;initInstanceIsa</code></p><p>在此之前我们需要先了解什么是 <code>联合体</code>，它和 <code>结构体</code> 的区别？</p><p><strong>1、构造数据类型的方式有以下两种：</strong></p><ul><li><p><code>结构体</code>（struct）</p></li><li><p><code>联合体</code>（union，也称为共用体）</p></li></ul><p><strong>2、 <code>结构体</code>和<code>联合体</code> 写法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 结构体:s表示结构体类型名</span><br><span class="line">struct s</span><br><span class="line">&#123;</span><br><span class="line">    // a,b,c表示结构体成员名</span><br><span class="line">    char a;  //占1个字节 （0）</span><br><span class="line">    int b;   //占4个字节 （4，5，6，7）</span><br><span class="line">    short c; //占2个字节 （8，9）</span><br><span class="line">&#125;s1;</span><br><span class="line">// s1表示结构体变量名</span><br><span class="line">// 访问该结构体内部成员时可以采用s1.a=1;其中&quot;点&quot;表示结构体成员运算符</span><br><span class="line"></span><br><span class="line">// 联合体</span><br><span class="line">// u1表示联合体类型名</span><br><span class="line">union u1</span><br><span class="line">&#123;</span><br><span class="line">    // a,b,c表示联合体成员名</span><br><span class="line">    char a; //占1个字节</span><br><span class="line">    int b;  //占4个字节</span><br><span class="line">    short c;//占2个字节</span><br><span class="line">&#125;u1;</span><br></pre></td></tr></table></figure><p>在main.m中打印一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        printf(&quot;%lu\n&quot;,sizeof(s1));</span><br><span class="line">        printf(&quot;%lu\n&quot;,sizeof(u1));</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">******查看打印结果******</span><br><span class="line">12</span><br><span class="line">4</span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure><p>由结果可知：</p><ul><li><code>结构体</code> 的大小为 <code>12</code> ，最大成员变量的倍数 <code>4*3 = 12</code></li><li><code>联合体</code> 的大小为 <code>4</code> ，最大成员变量 <code>4</code></li></ul><p><strong>3、结构体（struct）</strong></p><p><code>结构体</code>：各成员各自拥有 <code>自己的内存</code>，各自使用 <code>互不干涉</code>，同时存在的，遵循 <code>内存对齐</code> 原则。一个 <code>struct</code> 变量的 <code>总长度</code> 等于 <code>所有成员</code> 的 <code>长度之和</code>。</p><ul><li><p>缺点：所有属性都分配内存，比较浪费内存，假设有 <code>4个int</code> 成员，一共分配了 <code>4*4=16</code> 字节的内存，但是在使用时，你只使用了4字节，剩余的12字节就是属于内存的浪费</p></li><li><p>优点：存储容量较大，包容性强，且成员之间不会相互影响</p></li></ul><p><strong>4、联合体（union）</strong></p><p><code>联合体</code>：各成员 <code>共用</code> 一块 <code>内存空间</code>，并且同时只有一个成员可以得到这块内存的 <code>使用权(对该内存的读写)</code>，各变量 <code>共用一个内存</code> 首地址。因而，联合体比结构体更 <code>节约内存</code>。一个 <code>union</code> 变量的总长度至少能容纳 <code>最大</code> 的成员变量，而且要满足是所有 <code>成员变量</code> 类型大小的 <code>整数倍</code>。</p><ul><li><p>缺点：，包容性弱</p></li><li><p>优点：所有成员共用一段内存，使内存的使用更为精细灵活，同时也节约内存</p></li></ul><p><strong>5、两者的区别</strong></p><p>1）<code>内存占用</code>情况</p><ul><li><p><code>结构体</code> 的各个成员会 <code>占用不同</code> 的 <code>内存</code> ，互相之间没有影响</p></li><li><p><code>共用体</code> 的所有成员 <code>占用同一段</code> 内存，修改一个成员会影响其余所有成员</p></li></ul><p>2）<code>内存分配</code>大小</p><ul><li><p><code>结构体</code> 内存 &gt;&#x3D; 所有成员占用的内存总和（成员之间可能会有缝隙）</p></li><li><p><code>共用体</code>占用的内存等于最大的成员占用的内存</p></li></ul><h1 id="isa的类型"><a href="#isa的类型" class="headerlink" title="isa的类型"></a>isa的类型</h1><p><strong>1、我们知道 <code>isa</code> 的类型是 <code>isa_t</code> 的 <code>联合体</code> ，<code>isa_t</code> 类型使用 <code>联合体</code> 的<code>原因</code> 也是基于 <code>内存优化</code> 的考虑；这里的内存优化是指在 <code>isa</code> 指针中通过 <code>char + 位域</code>（即二进制中每一位均可表示不同的信息）的原理实现。通常来说，<code>isa</code> 指针占用的<code>内存</code> 大小是 <code>8</code> 字节(1字节&#x3D;8位)，即 <code>8*8=64</code> 位，已经足够存储很多的信息了，这样可以极大的 <code>节省内存</code>，以 <code>提高性能</code>。</strong></p><p><code>isa_t源码</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 联合体</span><br><span class="line">union isa_t &#123;</span><br><span class="line">    // isa的两种初始化方法</span><br><span class="line">    isa_t() &#123; &#125; </span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    // 提供了 cls 和 bits ，两者是互斥关系</span><br><span class="line">    Class cls; // 存储cls信息</span><br><span class="line">    uintptr_t bits; // 存储多位的信息</span><br><span class="line">#if defined(ISA_BITFIELD)</span><br><span class="line">    struct &#123;</span><br><span class="line">        ISA_BITFIELD;  // defined in isa.h</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2、从 <code>isa_t</code> 的定义中可以看出：</strong></p><p>提供了两个成员，<code>cls</code> 和 <code>bits</code>，由联合体的定义所知，这两个成员是<code>互斥</code>的，也就意味着，当初始化<code>isa</code>指针时，有两种初始化方式：</p><ul><li>如果不是 <code>nonpointer</code>，通过 <code>isa_t(uintptr_t value) : bits(value) &#123; &#125;</code>实现初始化</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 如果不是nonpointer,初始化isa，返回cls信息</span><br><span class="line">if (!nonpointer) &#123;</span><br><span class="line">    // 初始化isa</span><br><span class="line">    isa = isa_t((uintptr_t)cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果是 <code>nonpointer</code> ,通过 <code>isa_t()</code> 初始化</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 如果是nonpointer的初始化方式</span><br><span class="line">else &#123;</span><br><span class="line">    ASSERT(!DisableNonpointerIsa);</span><br><span class="line">    ASSERT(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line">    </span><br><span class="line">    // 初始化isa</span><br><span class="line">    isa_t newisa(0);</span><br><span class="line">    </span><br><span class="line">// 返回0</span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">    ASSERT(cls-&gt;classArrayIndex() &gt; 0);</span><br><span class="line">    newisa.bits = ISA_INDEX_MAGIC_VALUE;</span><br><span class="line">    // isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">    // isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">    newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">    newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();</span><br><span class="line">    </span><br><span class="line">// 64位走这个地方</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">    // 赋值bits</span><br><span class="line">    newisa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">    </span><br><span class="line">    // 赋值cxx</span><br><span class="line">    newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">    </span><br><span class="line">    // 赋值类信息</span><br><span class="line">    newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    // 赋值isa</span><br><span class="line">    isa = newisa;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、<code>SUPPORT_INDEXED_ISA</code> ：表示 <code>isa_t</code> 中存放的 <code>Class</code> 信息是 <code>Class</code> 的地址，还是一个<code>索引</code>(根据该 <code>索引</code> 可在 <code>类信息表</code> 中查找该类结构地址)。目前接触到的iOS的设备上 <code>SUPPORT_INDEXED_ISA</code> 为 <code>0</code> ，如下代码:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 如果不是64位</span><br><span class="line">#if __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)</span><br><span class="line">#   define SUPPORT_INDEXED_ISA 1</span><br><span class="line"></span><br><span class="line">// 如果是64位</span><br><span class="line">#else</span><br><span class="line">#   define SUPPORT_INDEXED_ISA 0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><strong>4、<code>isa_t</code> 还提供了一个结构体定义的<code> 位域</code> ，用于存储类信息及其他信息，结构体的成员 <code>ISA_BITFIELD</code> ，这是一个宏定义，有两个 <code>架构__arm64__（真机）</code> 和 <code>__x86_64__（macOS/模拟器）</code>，以下是它们的一些宏定义，如下图所示：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93747410-40d85700-fc29-11ea-9156-b7230e9f215e.png"></p><ul><li><p><code>nonpointer</code>：表示是否对 <code>isa</code> 指针 <code>开启指针优化</code></p><ul><li><code>0</code>：如果没有 <code>nonpointer</code> 就是<code>纯isa指针</code></li><li><code>1</code>：如果有 <code>nonpointer</code>，不⽌有 <code>类对象地址</code> ,isa 中包含了 <code>类信息</code>、对象的 <code>引⽤计数</code> 等</li></ul></li><li><p><code>has_assoc</code>：<code>关联对象标志位</code></p><ul><li><code>0没有</code></li><li><code>1存在</code></li></ul></li><li><p><code>has_cxx_dtor</code>：该对象是否有<code>C++</code>或者<code> Objc</code> 的<code>析构器</code>,如果有析构函数,则需要做析构逻辑, 如果没有,则可以更快的释放对象</p></li><li><p><code>shiftcls</code>: <code>存储类指针的值</code>。开启指针优化的情况下：</p><ul><li>在 <code>__arm64__</code> 架构中有 <code>33</code> 位⽤来存储 <code>类指针</code>、<code>dealloc</code> 函数</li><li>在 <code>__x86_64__</code> 架构中有 <code>44</code> 位用来存储类指针。</li></ul></li><li><p><code>magic</code>：⽤于调试器判断当前对象是 <code>真的对象</code> 还是 <code>没有初始化</code> 的 <code>空间</code></p></li><li><p><code>weakly_referenced</code>：指对象是否被 <code>指向</code> 或者 <code>曾经指向</code> ⼀个 <code>ARC</code> 的弱变量</p><ul><li>如果 <code>有</code>，则在调用 <code>delloc</code> 进行 <code>释放</code></li><li>如果 <code>没有</code>，弱引⽤的对象可以 <code>更快释放</code>。</li></ul></li><li><p><code>deallocating</code>：标志对象是否 <code>正在释放</code> 内存</p></li><li><p><code>has_sidetable_rc</code>：当对象 <code>引⽤计数⼤于 10 </code>时，则需要借⽤该变量 <code>存储进位</code></p></li><li><p><code>extra_rc</code>：当表示该对象的 <code>引⽤计数值</code>，实际上是引⽤计数值 <code>减 1</code></p><ul><li>如果对象的引⽤计数为 <code>10</code>，那么 <code>extra_rc</code> 为 <code>9</code>。</li><li>如果引⽤计数⼤于 <code>10</code>，则需要使⽤到 <code>上⾯</code> 的 <code>has_sidetable_rc</code>。</li></ul></li></ul><p>针对两种不同平台，其<code>isa</code>的<code>存储情况</code>如图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/93747391-3ae27600-fc29-11ea-85b0-3c8e25a21340.png"></p><p>由上面的分析得出，大部分 <code>自定义的类</code> 都是属于 <code>nonpointer_isa</code>，不光存储了<code>isa</code>，还存储了其他一些 <code>信息</code>。</p><h1 id="dealloc释放"><a href="#dealloc释放" class="headerlink" title="dealloc释放"></a>dealloc释放</h1><p>我们通过 <code>dealloc释</code> 查看 <code>通过</code> 中 <code>dealloc</code> 释放流程：</p><p><strong>1、<code>dealloc</code>调用<code>_objc_rootDealloc</code>：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Replaced by NSZombies</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、<code>_objc_rootDealloc</code>调用<code>rootDealloc</code>:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_objc_rootDealloc(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3、<code>rootDealloc</code>内部进行一些判断，释放 <code>isa</code> 相关信息：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return;  // fixme necessary?</span><br><span class="line">    // isa有nonpointer，更快释放</span><br><span class="line">    if (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        free(this);</span><br><span class="line">    &#125;</span><br><span class="line">    // 没有nonpointer,调用object_dispose</span><br><span class="line">    else &#123;</span><br><span class="line">        object_dispose((id)this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4、<code>object_dispose</code>内部调用<code>objc_destructInstance</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">object_dispose(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return nil;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);    </span><br><span class="line">    free(obj);</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、<code>objc_destructInstance</code> 内部调用 <code>clearDeallocating</code> 清除</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        // Read all of the flags at once for performance.</span><br><span class="line">        // 是否有c++/oc析构函数</span><br><span class="line">        bool cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        // 是否有关联对象</span><br><span class="line">        bool assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        // This order is important.</span><br><span class="line">        // 析构函数</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        // 移除关联对象</span><br><span class="line">        if (assoc) _object_remove_assocations(obj);</span><br><span class="line">        // 清除</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体细节待完善…</p><h1 id="isa-和-类关联"><a href="#isa-和-类关联" class="headerlink" title="isa 和 类关联"></a>isa 和 类关联</h1><p><code>isa</code> 与 <code>cls</code> 关联 <code>原理</code> 就是 <code>isa</code> 指针中的 <code>shiftcls位域中存储了类信息</code> ，其中 <code>initInstanceIsa</code> 的过程是将 <code>calloc</code> 指针和当前的 <code>类cls</code> 关联起来，有以下几种验证方式：</p><ul><li><p>【方式一】通过 <code>initIsa</code> 方法中的 <code>newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3</code>验证</p></li><li><p>【方式二】通过 <code>isa指针</code> 地址与 <code>ISA_MSAK</code> 的值 <code>&amp;</code> 来验证</p></li><li><p>【方式三】通过 <code>runtime</code> 的方法 <code>object_getClass</code> 验证</p></li><li><p>【方式四】通过 <code>位运算</code> 验证</p></li></ul><h1 id="【方法一】通过-initIsa-方法中的-newisa-shiftcls-uintptr-t-cls-gt-gt-3验证"><a href="#【方法一】通过-initIsa-方法中的-newisa-shiftcls-uintptr-t-cls-gt-gt-3验证" class="headerlink" title="【方法一】通过 initIsa 方法中的 newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3验证"></a>【方法一】通过 <code>initIsa</code> 方法中的 <code>newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3</code>验证</h1><p><strong>1、首先通过<code>main</code>中的<code>ZJPerson</code> 断点 –&gt; <code>initInstanceIsa</code> –&gt; <code>initIsa</code> –&gt; 走到<code>else</code>中的 <code>newisa.bits = ISA_MAGIC_VALUE</code>这一行:</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93882232-7f960c00-fd12-11ea-863b-9e22f5da1944.png"></p><p><strong>2、 通过lldb调试打印 <code>p newisa</code> 初始化的信息:</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93882733-372b1e00-fd13-11ea-8d8d-e14f2263b78c.png"></p><p>这时 <code>isa</code> 通过 <code>newisa</code> 进行了初始化，但是还未被赋值</p><p><strong>3、往下走一步，走到下一行<code>newisa.has_cxx_dtor = hasCxxDtor</code> ：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/94141425-48089a80-fe9f-11ea-9269-e67c8a19b92b.png"></p><p>继续断点调试，在上一行 <code>newisa.bits = ISA_MAGIC_VALUE</code> 已经为 <code>isa</code> 的 <code>bits</code> 成员赋值，执行lldb命令 <code>p newisa</code>，得到的结果如下:</p><p><img src="https://user-images.githubusercontent.com/25925248/93885662-ffbe7080-fd16-11ea-8657-1060179cf68e.png"></p><p>通过与前一个 <code>newisa</code> 对比我们发现，<code>isa</code> 指针中有一些变化，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/25925248/93886549-27fa9f00-fd18-11ea-9e8b-7ab57c77e1f1.png"></p><ul><li><p>赋值 <code>bits</code> 会对 <code>cls</code> 进行追加 <code>0x001d800000000001</code> 默认值</p></li><li><p>赋值 <code>bits</code> 里面的 <code>ISA_BITFIELD</code> 宏中所有的信息】</p><ul><li><code>nonpointer = 1</code>，代表<code>是nonpointer</code></li><li><code>magic = 59</code> ，为什么呢？往下看</li></ul></li></ul><p><strong>4、打开 <code>计算器</code> 我们查看一下 <code>16</code> 进制 <code>0x001d800000000001</code> 转化为 <code>二进制</code>，和 <code>10</code>进制<code>59</code> 转化为<code>二进制</code>，进行对比一下：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93888490-a6f0d700-fd1a-11ea-9a85-960b7940af05.png"></p><p>由对比可知，<code>0x001d800000000001</code>转化为<code>二进制</code> ，从 <code>47（因为前面有4个位域，共占用46位）</code> 位开始往后数6位是 <code>110111</code>； 和 <code>10</code> 进制 <code> magic = 59</code>  转换成<code>二进制</code>，从 <code>0</code> 开始 往后数 <code>6</code> 位的 值相等；</p><p><strong>5、继续往下执行断点到<code>newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3</code>：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/94139362-18a45e80-fe9c-11ea-9107-b29a29e5ed73.png"></p><ul><li><p><code>shiftcls</code> 存的是 <code>类的信息</code></p></li><li><p><code>cls</code> 是 <code>ZJPerson</code> 进行 <code>编码</code> 之后往 <code>右移3位</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (uintptr_t)cls</span><br><span class="line">(uintptr_t) $2 = 4294975720</span><br><span class="line">(lldb) p $2 &gt;&gt; 3</span><br><span class="line">(uintptr_t) $3 = 536871965</span><br></pre></td></tr></table></figure><p><strong>6、继续往下走一到 执行断点到<code>isa = newisa</code>：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/94141778-daa93980-fe9f-11ea-88c6-cf175241db39.png"></p><p>我们通过 <code>lldb</code> 调试一下 <code>newisa</code>：</p><p><img src="https://user-images.githubusercontent.com/25925248/93890441-eae4db80-fd1c-11ea-9253-2105c3cb2568.png"></p><p>我们看到 <code>cls = ZJPerson</code>，而 <code>shiftcls = 536871965</code> 与 上面的 <code>$3 = 536871965</code> 刚好吻合</p><p><strong>7、最后用一张图来表示一下具体流程:</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/94142549-0bd63980-fea1-11ea-8b1b-dbf4e8f3a1e4.png"></p><p><strong>8、为什么在<code>shiftcls</code>赋值时需要类型强转？</strong></p><p>因为内存的存储不能存储字符串，<code>机器码</code> 只能识别 <code>0 、1</code> 这两种数字，所以需要将其转换为 <code>uintptr_t</code> 数据类型，这样 <code>shiftcls</code> 中存储的类信息才能被 <code>机器码理解</code>， 其中 <code>uintptr_t</code> 是<code>long</code></p><p><strong>9、为什么需要右移3位？</strong></p><p>主要是由于 <code>shiftcls</code> 处于 <code>isa</code> 指针地址的 <code>中间</code> 部分，前面还有 <code>3</code> 个位域，为了不影响前面的3个位域的数据，需要 <code>右移</code> 将其 <code>抹零</code>。</p><h1 id="【方法二】：通过-isa-指针地址与-ISA-MSAK-的值-amp-来验证"><a href="#【方法二】：通过-isa-指针地址与-ISA-MSAK-的值-amp-来验证" class="headerlink" title="【方法二】：通过 isa 指针地址与 ISA_MSAK 的值 &amp; 来验证"></a>【方法二】：通过 <code>isa</code> 指针地址与 <code>ISA_MSAK</code> 的值 &amp; 来验证</h1><p><strong>1、在方法一执行完后，回到 <code>_class_createInstanceFromZone</code><br>中，此时 <code>isa</code> 与 <code>cls</code> 已经关联完成，我们走到下面这个方法，打上断点：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/94143104-eeee3600-fea1-11ea-9ba8-938dfe11bc9b.png"></p><p><strong>2、执行 <code>po obj</code>,输出对应的值，再执行 <code>x/4gx 0x10181ba70</code> 得到 <code>isa</code> 指针的地址 <code>0x001d8001000020e9</code>,将 <code>isa</code> 指针地址 <code>&amp;</code> <code>ISA_MASK</code> ，即 <code>po 0x001d8001000020e9 &amp; 0x0000000ffffffff8ULL</code> 或 <code>po 0x001d8001000020e9 &amp; 0x00007ffffffffff8ULL</code> ，得出 <code>ZJPerson</code></strong></p><p><img src="https://user-images.githubusercontent.com/25925248/94144541-d7b04800-fea3-11ea-955d-d08df3ea1d02.png"></p><ul><li><p><code>__arm64__</code>中，<code>ISA_MASK</code> 宏定义的值为 <code>0x0000000ffffffff8ULL</code></p></li><li><p><code>__x86_64__</code>中，<code>ISA_MASK</code> 宏定义的值为 <code>0x00007ffffffffff8ULL</code></p></li></ul><h1 id="【方法三】：通过-object-getClass"><a href="#【方法三】：通过-object-getClass" class="headerlink" title="【方法三】：通过 object_getClass"></a>【方法三】：通过 <code>object_getClass</code></h1><p>通过查看 <code>object_getClass</code> 的源码实现，同样可以验证 <code>isa</code> 与 <code>类</code> 关联的原理，有以下几步：</p><p><strong>1、<code>main</code>中导入<code>#import &lt;objc/runtime.h&gt;</code></strong></p><p><strong>2、通过 <code>runtime</code> 的 <code>api</code>，即 <code>object_getClass</code> 函数获取类信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object_getClass(&lt;#id  _Nullable obj#&gt;)</span><br></pre></td></tr></table></figure><p><strong>3、查看<code>object_getClass</code>函数 源码的实现</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/94144862-442b4700-fea4-11ea-8456-eb0ac8ec5c22.png"></p><p><strong>4、点击进入<code>object_getClass</code> 底层实现</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93893110-db1ac680-fd1f-11ea-80d9-6fb4a94546b0.png"></p><p><strong>5、点击<code>getIsa</code> 进入查看底层实现:</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93893085-d35b2200-fd1f-11ea-9264-9e7757207ac4.png"></p><p><strong>6、点击 <code>ISA</code> 进入查看底层实现，可以看到如果是 <code>SUPPORT_INDEXED_ISA</code> 类型，执行 <code>if</code> 流程，反之 执行的是 <code>else</code> 流程，我们这里走的是 <code>else</code>:</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93892997-b888ad80-fd1f-11ea-800c-5eeb56a59ef9.png"></p><ul><li><p>在else流程中，拿到 <code>isa</code> 的 <code>bits</code> 这个位，再 &amp; <code>ISA_MASK</code>，这与方式二中的原理是一致的，获得当前的类信息</p></li><li><p>从这里也可以得出 <code>isa</code> 与 <code>cls</code> 已经完美关联</p></li></ul><h1 id="【方法四】：通过位运算"><a href="#【方法四】：通过位运算" class="headerlink" title="【方法四】：通过位运算"></a>【方法四】：通过位运算</h1><p><strong>1、回到 <code>_class_createInstanceFromZone</code> 方法。通过 <code>x/4gx obj</code> 得到 <code>obj</code>的 <code>内存分布情况</code> ，当前类的信息存储在 <code>isa</code> 指针中，且 <code>isa</code> 中的 <code>shiftcls</code> 此时占 <code>44</code> 位（因为处于<code>macOS</code>环境）</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/94145805-ab95c680-fea5-11ea-9705-1c4842aa69c9.png"></p><p><strong>2、想要读取中间的 <code>44</code> 位 <code>类信息(shiftcls)</code>，就需要经过 <code>位运算</code> ，将 <code>右边3位</code>，和 <code>左边17</code> 位 <code>除去</code>，<code>44位以外</code> 的部分都 <code>抹零</code>，其 <code>相对位置是不变的</code>。其位运算过程如图所示，其中<code>shiftcls</code>即为需要读取的类信息：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/94149075-05988b00-feaa-11ea-9ee8-67a09d21e33f.png"></p><p>**3、将isa地址右移3位：<code>p/x 0x001d8001000020e9 &gt;&gt; 3</code> ，得到<code>0x0003b0002000041d</code> **</p><ul><li><p>在将得到的 <code>0x0003b0002000041d</code> 左移20位：<code>p/x 0x0003b0002000041d &lt;&lt; 20</code> ,得到 <code>0x0002000041d00000</code></p></li><li><p>为什么是左移20位？因为先右移了3位，相当于向右偏移了3位，而左边需要抹零的位数有17位，所以一共需要移动20位</p></li><li><p>将得到的<code>0x0002000041d00000</code> 再右移17位：<code>p/x 0x0002000041d00000 &gt;&gt; 17</code> 得到新的<code>0x00000001000020e8</code></p></li><li><p>获取cls的地址 与 上面的进行验证 ：<code>p/x cls</code> 也得出<code>0x00000001000020e8</code>，所以由此可以证明 <code>isa</code> 与 <code>cls</code> 是关联的</p></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/94148177-de8d8980-fea8-11ea-85fb-8fa5d802266a.png"></p><p><strong>4、为什么右移3位，左移20位，再右移17位？</strong></p><p>因为 <code>initIsa（初始化isa）</code> 传入的是 <code>cls（即ZJPerson）</code>，只有中间 <code>shiftcls</code> 才 <code>存储着类的信息</code> ，在 <code>__x86_64__</code> 架构是 <code>44</code> 位，在 <code>__arm64__</code> 架构是 <code>33</code> 位，只有在 <code>33位/44位</code> 才存 <code>储着类信息</code>，当右移3位，左移20位，再右移17位，相当于复位，不足64位 <code>系统</code> 自动帮我们 <code>用0补全</code>。</p><h1 id="isa返回Class类型的验证"><a href="#isa返回Class类型的验证" class="headerlink" title="isa返回Class类型的验证"></a>isa返回Class类型的验证</h1><p><strong>1、我们在前面探索了 <code>对象</code> 的 <code>本质</code> 是 <code>结构体</code>，它的第一个 <code>属性</code> 是 <code>继承</code> 自 <code>NSObject</code> 的 <code>isa</code> 是 <code>Class</code> 类型的，而后面我们通过【方法三】<code>object_getClass</code> 验证 <code>isa</code> 与 <code>cls</code> 关联流程得知， <code>isa</code> 是 <code>isa_t</code> 类型的:</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/94153411-55c61c00-feaf-11ea-8cd1-5b98abf576c7.png"></p><p><strong>2、那么为什么我们在 <code>外层</code> 得到的是 <code>Class</code> 的 <code>isa</code> 呢?</strong></p><p>我们其实在上面的【方法三】，已经验证了其原因，看源码 <code>return (Class)(isa.bits &amp; ISA_MASK);</code> 这一句代码将其 <code>强转</code> 为 <code>Class</code> 类型提供给外层使用。</p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理07：malloc源码探索</title>
      <link href="/BboyZJ.github.io/2020/09/16/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8607%EF%BC%9Amalloc%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/09/16/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8607%EF%BC%9Amalloc%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在 <a href="https://www.bboyzj.cn/2020/09/07/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8603%EF%BC%9Aalloc&init&new%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">OC底层原理03：alloc&amp;init&amp;new探索</a> 文章中，分别得知<code>alloc</code>最核心的三个操作：</p><ul><li><p>第一个核心方法：<code>cls-&gt;instanceSize</code>,我们得知是申请内存大小，系统默认是 <code>16</code> 字节对齐。</p></li><li><p>第二个核心方法：<code>calloc</code>，即申请内存，即今天要 <code>探索</code> 的内容，其实探索的本质也是为了验证ios中对象中实际的对齐方式是 <code>8</code> 字节对齐</p></li></ul><h1 id="objc4中分析calloc-源码"><a href="#objc4中分析calloc-源码" class="headerlink" title="objc4中分析calloc 源码"></a>objc4中分析calloc 源码</h1><p>由 <a href="https://www.bboyzj.cn/2020/09/07/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8603%EF%BC%9Aalloc&init&new%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">OC底层原理03：alloc&amp;init&amp;new探索</a> 文章中可知，<code>obj = (id)calloc(1, size)</code>调用的源码不在<code>objc4</code>中，如下图：</p><p><img src="https://user-images.githubusercontent.com/25925248/93694091-4d31b680-fb3a-11ea-8372-b710adf7cf40.png"></p><p>实际上 <code>calloc</code> 的源码需要查看 <code>libmalloc源码</code> 中，可以在 <a href="https://opensource.apple.com/tarballs/libmalloc/">这里</a> 下载最新版，然后去探索</p><h1 id="libmalloc中分析calloc源码"><a href="#libmalloc中分析calloc源码" class="headerlink" title="libmalloc中分析calloc源码"></a>libmalloc中分析calloc源码</h1><p><strong>1、第一步:在main中使用 <code>calloc</code> 创建一个指针</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93694311-ae5a8980-fb3c-11ea-8383-47588eb1e6ee.png"></p><p><strong>2、第二步：进入 <code>calloc</code> 的源码实现，其中的关键代码是 <code>malloc_zone_calloc</code></strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93694360-5cfeca00-fb3d-11ea-8343-9cd16c37b775.png"></p><p>其中 <code>default_zone</code> 是 <code>malloc_zone_t</code> 类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static malloc_zone_t *default_zone = &amp;virtual_default_zone.malloc_zone;</span><br></pre></td></tr></table></figure><p><strong>3、第三步:进入 <code>malloc_zone_calloc</code> 的源码实现，其中关键代码是 <code>zone-&gt;calloc</code></strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93694383-ab13cd80-fb3d-11ea-8158-e8df38d52b70.png"></p><p>到这里，我们点击 <code>calloc</code> 发现，找不到下面要执行的源码了，我们通过终端 <code>p zone-&gt;calloc</code> 去查看一下底层调用：</p><p><img src="https://user-images.githubusercontent.com/25925248/93694691-67bb5e00-fb41-11ea-8c54-cc5159474bca.png"></p><p>由此可发现，内部起始调用的是 <code>default_zone_calloc</code></p><p><strong>4、第四步:断点调试查看 <code>default_zone_calloc</code> 内部源码</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93694716-c5e84100-fb41-11ea-9520-a9cb0905763f.png"></p><p>与上面一样，终端 <code>p zone-&gt;calloc</code> 去查看一下底层调用：</p><p><img src="https://user-images.githubusercontent.com/25925248/93694740-18296200-fb42-11ea-9490-421f0b594c93.png"></p><p>由此可发现，内部起始调用的是 <code>nano_calloc</code></p><p><strong>5、第五步:断点调试查看 <code>nano_calloc</code> 内部源码</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93694840-2461ef00-fb43-11ea-91c8-207590777276.png"></p><ul><li><p>如果要开辟的空间小于 <code>NANO_MAX_SIZE</code> 则进行，我们通过断点调试，发现执行的是这个流程</p></li><li><p>否则就进行 <code>helper_zone</code> 的流程</p></li></ul><p><strong>6、第六步:点进 <code>_nano_malloc_check_clear</code> 查看内部源码</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93695122-d995a680-fb45-11ea-90d2-53200650d09a.png"></p><p><strong>7、第七步：点进关键代码 <code>segregated_size_to_fit</code> 查看源码</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93695156-385b2000-fb46-11ea-9684-3c291d796c56.png"></p><p><img src="https://user-images.githubusercontent.com/25925248/93695645-9d634580-fb47-11ea-8945-cf221ca8a268.png"></p><p>由上面的图，我们可以得知 <code>size</code> 为传入 <code>24</code> ，但是最后返回的 <code>slot_bytes</code> 实际上是 <code>32</code>，说明是 <code>16</code> 位的倍数，计算方法图上已经说明</p><p><strong>8、第八步：如果是第一次调用 <code>segregated_next_block</code> 函数，<code>band</code> 不存在，缓存也不会存在，所以会调用<code>segregated_band_grow</code>。来开辟新的 <code>band</code></strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93701986-a48b5300-fb49-11ea-87a6-3a761341ef9e.png"></p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理06：内存对齐探索</title>
      <link href="/BboyZJ.github.io/2020/09/14/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8606%EF%BC%9A%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/09/14/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8606%EF%BC%9A%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="查看内存地址的方法"><a href="#查看内存地址的方法" class="headerlink" title="查看内存地址的方法"></a>查看内存地址的方法</h1><p><strong>1、【方法一】：<code>Debug-&gt;Debug Workflow-&gt;Alway View Memory</code></strong></p><p><strong>2、【方法二】：<code>x 地址</code>&#x2F;<code>x 对象</code></strong></p><p>1）下面我们通过代码具体查看一下使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 内存对齐</span><br><span class="line">ZJPerson * p = [ZJPerson alloc];</span><br><span class="line">p.name = @&quot;ZJ&quot;;  // NSString</span><br><span class="line">p.age = 30; // int</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;%@&quot;,p);</span><br></pre></td></tr></table></figure><p>2）通过LLDB编译命令查看内存情况：</p><p><img src="https://user-images.githubusercontent.com/25925248/92987563-16362200-f4f6-11ea-8f34-49785fab2912.png"></p><ul><li><code>x 0x100867a60</code> ：以16进制打印当前地址的内存情况，查看不方便</li><li><code>x/4gx 0x100867a60</code>：以16进制形式打印4个地址，查看方便</li><li><code>0x100867a60</code> ： 内存地址</li><li><code>0x001d80010000220d</code>：isa</li><li><code>0x000000000000001e</code>：30</li><li><code>0x0000000100001010</code>：ZJ</li></ul><p>3）那么 <code>0x100867a60、0x102038770</code> 和 <code>0x001d80010000220d 0x000000000000001e 0x0000000100001010 0x0000000000000000</code><br>有什么关系呢？我们用一张图来表示一下：</p><p><img src="https://user-images.githubusercontent.com/25925248/92987594-82b12100-f4f6-11ea-89cc-c106d7d79318.png"></p><p>4）如果有一个 <code>double/float</code> 类型的 <code>height</code> 呢？</p><p>我们来分析一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) double height;</span><br><span class="line"></span><br><span class="line">p.height = 170; // double</span><br></pre></td></tr></table></figure><p>通过 <code>x/4gx p</code> 查看打印的结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po 0x4065400000000000</span><br><span class="line">4640185359819341824</span><br></pre></td></tr></table></figure><p>我们发现竟然没有打印170，这是为什么呢？</p><p>原因：<code>16进制和double/float类型的转换</code><br>验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x (double)170</span><br><span class="line">(double) $7 = 0x4065400000000000</span><br></pre></td></tr></table></figure><p>我们可以得到和上面的地址一抹抹一样样，<code>还有谁?</code></p><p>5）从打印结果我们可以看出一个问题，两个属性占用内存不是按照定义属性的顺序，这是为什么呢？其实这就是 <code>iOS中的内存字节对齐现象</code></p><h1 id="内存对齐的原因"><a href="#内存对齐的原因" class="headerlink" title="内存对齐的原因"></a>内存对齐的原因</h1><p>对于大部分程序员来说，<code>内存对齐</code> 对他们来说都应该是 <code>透明的</code>。</p><ul><li><p><code>平台原因(移植原因)</code>：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p></li><li><p><code>性能原因：</code>数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问 <code>未对齐</code> 的内存，处理器需要作 <code>两次</code> 内存访问；而 <code>对齐</code> 的内存 <code>访问</code> 仅需要 <code>一次</code> 访问。</p></li></ul><h1 id="内存对齐三大原则"><a href="#内存对齐三大原则" class="headerlink" title="内存对齐三大原则"></a>内存对齐三大原则</h1><p>每个特定平台上的编译器都有自己的默认 <code>“对齐系数”(也叫对齐模数)</code>。程序员可以通过预编译命令#pragma pack(n)，n&#x3D;1,2,4,8,16来改变这一系数，其中的n就是你要指定的 “对齐系数”。在 <code>ios</code> 中，Xcode默认为 #pragma pack(8)，即 <code>8字节对齐 </code></p><ul><li><p>数据成员对齐规则：结构(<code>struct</code>)或联合(<code>union</code>)的数据成员，第一个数据成员放在<code>offset</code> 为0的地方，以后每个数据成员存储的起始位置要从该成员的大小或子成员大小的整数倍开始存储（比如 <code>int 为4字节</code>，那么他的起始位置则为 <code>4*n</code> ）</p></li><li><p>结构体作为成员:如果⼀个结构⾥有某些结构体成员,则结构体成员要从其内部最⼤元素⼤⼩的整数倍地址开始存储.(<code>struct a</code> ⾥存有 <code>struct b</code> ,<code>b</code> ⾥有<code>char,int ,double</code>等元素,那 <code>b</code> 应该从 <code>8</code> 的整数倍开始存储.)</p></li><li><p>结构体总体大小，必须是其内部最大成员的整数倍，不足要补齐</p></li></ul><h1 id="数据类型所占字节"><a href="#数据类型所占字节" class="headerlink" title="数据类型所占字节"></a>数据类型所占字节</h1><p><img src="https://user-images.githubusercontent.com/25925248/92480517-94a17400-f217-11ea-9dc4-8b27214158a2.png"></p><h1 id="获取内存的三个方法"><a href="#获取内存的三个方法" class="headerlink" title="获取内存的三个方法"></a>获取内存的三个方法</h1><ul><li><p><code>sizeof</code> 是运算符，编译的时候就替换为常数，返回的是 <code>一个类型所占内存的大小</code></p></li><li><p><code>class_getInstanceSize</code> 传入一个类对象，返回 <code>一个对象的实例至少需要多少内存</code>,它等价于<code>sizeof</code>，需要导入<code>#import &lt;objc/runtime.h&gt;</code></p></li><li><p><code>malloc_size</code>返回 <code>系统实际分配的内存大小</code>，需要导入<code>#import &lt;malloc/malloc.h&gt;</code></p></li></ul><h1 id="对象属性内存对齐"><a href="#对象属性内存对齐" class="headerlink" title="对象属性内存对齐"></a>对象属性内存对齐</h1><p><strong>1、首先通过一个类的内存段来分析</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/92477729-af71e980-f213-11ea-8ab4-4e3438dca409.png"></p><p><strong>2、然后我们下断点，分析一下对象的内存情况</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/92478059-31faa900-f214-11ea-9936-65f3dfb689a0.png"></p><ul><li><p><code>po p</code>：查看当前的对象信息&lt;ZJPerson: 0x60000072f870&gt;</p><ul><li>ZJPerson为当前的类，<code>0x60000072f870</code> 为当前对象的 <code>首地址</code></li></ul></li><li><p>iOS为 <code>小端</code> 模式,内存要 <code>倒着读</code>，即 0x0000 0001 0950 2730,不足16位要补0，而 <code>0x0000 000109502730</code> 是指针 <code>isa</code> ，指向内存的首地址 <code>0x60000072f870</code></p></li><li><p><code>x p</code>：意思是查看这个地址的内存情况，即内存段</p></li><li><p>由于小端模式不好读取，所以我们用一个命令自动帮我们整理好 <code>x/6gx</code> 等等</p><ul><li><code>x/6xg p</code>：意思就是按照16进制,以6整段打印当前p对象</li></ul></li><li><p>我们发现OC为我们做了一些优化,我们发现0x0000001200006261这个内存段存储了<code>age,char1,char2</code>,三个属性</p><ul><li>我们 <code>po 0x00000012 </code> 打印 <code>30</code>,也就是我们的 <code>age</code> 属性值</li><li><code>po 0x61 0x62</code> 打印的分别为 <code>97 98</code> 也就是我们 <code>a和b对应的ASCII</code> 码</li></ul></li></ul><p><strong>3、为什么 <code>age、c1、c2</code> 三个属性放在一个 <code>8字节</code> 内存中呢?</strong></p><p>iOS系统不是对每一个属性都开辟8个字节内存空间，如果每一个属性都开辟8个字节，会造成内存浪费<br>iOS系统通过内存对齐方式，对 <code>属性重排，内存优化</code> ，</p><h1 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h1><ul><li>结构体指针的内存大小8</li><li>结构体大小根据内部大小来计算</li></ul><p>我们都知道 <code>对象</code> 的 <code>本质</code> 是 <code>结构体</code> ，因此 <code>对象</code> 的 <code>内存对齐</code> 来自 <code>结构体</code> ，因此接下来我们分析一下机构体是如何内存对齐的：</p><p><strong>1、struct1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 普通结构体</span><br><span class="line">struct ZJStruct1 &#123;</span><br><span class="line">    double a;   // 占8个字节 起始位置(0-7)</span><br><span class="line">    char b;     // 占1个字节 8是1的整数倍[8 1] 起始位置(8)</span><br><span class="line">    int c;      // 占4个字节 9不是4的整数倍，往下找[9 4] 9 10 11 起始位置(12 13 14 15)</span><br><span class="line">    short d;    // 占2个字节 16是2的整数倍[16 2] 起始位置(16 17)</span><br><span class="line">&#125;struct1;</span><br><span class="line">// 内部需要的大小为: 17个字节</span><br><span class="line">// 最大属性 : 8个字节</span><br><span class="line">// 结构体整数倍: 最大成员的整数倍 8*3 = 24个字节</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们通过图来分析一下struct1的内存存储情况：</p><p><img src="https://user-images.githubusercontent.com/25925248/92988578-4f26c480-f4ff-11ea-8d8d-ea99fcc5534a.png"></p><p>根据内存对齐规则，分析ZJStruct1的内存计算：</p><ul><li><code>变量a</code>：占<code>8</code>个字节，从<code>0</code>开始，此时 <code>0</code> 存储 <code>a</code></li><li><code>变量b</code>：占<code>1</code>个字节，从<code>8</code>开始，此时<code>8</code>可以整除<code>8</code>，即 <code>8-15</code> 存储 <code>b</code></li><li><code>变量c</code>：占<code>4</code>个字节，从<code>9</code>开始，此时<code>9</code>不可以整除<code>8</code>，往后移动到<code>12</code>，<code>12</code>可以整除<code>4</code>，即 <code>12-15</code> 存储 <code>c</code></li><li><code>变量d</code>：占<code>2</code>个字节，从<code>16</code>开始，此时<code>16</code>可以整除<code>2</code>，即 <code>16-17</code> 存储 <code>d</code></li></ul><p>因此ZJStruct1的需要的内存大小为 <code>18</code> 字节，而ZJStruct1中最大变量的字节数为 <code>8</code>，所以 ZJStruct1 实际的内存大小必须是 <code>8</code> 的整数倍，<code>18</code> 向上取整到 <code>24</code>，主要是因为 <code>24</code> 是 <code>8</code> 的整数倍，所以 <code>sizeof(ZJStruct1)</code> 的结果是 <code>24</code></p><p><strong>2、struct2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 普通结构体</span><br><span class="line">struct ZJStruct2 &#123;</span><br><span class="line">    char a;     //占1个字节 起始位置(0)</span><br><span class="line">    int b;      //占4个字节 1不是4的整数倍 起始位置(4~7)</span><br><span class="line">    short c;    //占2个字节 8是2的倍数，起始位置(8 9)</span><br><span class="line">    double c;     //占8个字节 10不是8的倍数 起始位置(16~23)</span><br><span class="line">    </span><br><span class="line">&#125;struct2;</span><br><span class="line">// 内部需要的大小为：23个字节</span><br><span class="line">// 最大属性：8个字节</span><br><span class="line">// 结构体整数倍：8*3 = 24个字节</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们通过图来分析一下struct1的内存存储情况：</p><p><img src="https://user-images.githubusercontent.com/25925248/92989153-b09d6200-f504-11ea-9d85-f13a43580f5e.png"></p><p>根据内存对齐规则，分析ZJStruct2的内存计算：</p><ul><li><code>变量a</code>：占<code>1</code>个字节，从<code>0</code>开始，此时 <code>0</code> 存储 <code>a</code></li><li><code>变量b</code>：占<code>4</code>个字节，从<code>1</code>开始，此时<code>1</code>不可以整除<code>4</code>，往后移动到<code>4</code>，此时<code>4</code>可以整除<code>4</code>，即 <code>4-7</code> 存储 <code>b</code></li><li><code>变量c</code>：占<code>2</code>个字节，从<code>8</code>开始，此时<code>8</code>可以整除<code>2</code>，即 <code>8-9</code> 存储 <code>c</code></li><li><code>变量d</code>：占<code>8</code>个字节，从<code>10</code>开始，此时<code>10</code>不可以整除<code>2</code>，往后移动到<code>16</code>，<code>16</code>可以整除<code>8</code>，即 <code>16-23</code> 存储 <code>d</code></li></ul><p>因此 <code>ZJStruct2</code> 的需要的内存大小为 <code>24</code> 字节，而ZJStruct1中最大变量的字节数为 <code>8</code>，所以 <code>ZJStruct1</code> 实际的内存大小必须是 <code>8</code> 的整数倍，<code>24</code> 向上取整到 <code>24</code>，主要是因为 <code>24</code> 是 <code>8</code> 的整数倍，所以 <code>sizeof(ZJStruct2)</code> 的结果是 <code>24</code></p><p><code>3、struct3</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 嵌套结构体</span><br><span class="line">struct ZJStruct3 &#123;</span><br><span class="line">    char a; //占1个字节</span><br><span class="line">    int b; //占4个字节</span><br><span class="line">    short c; //占2个字节</span><br><span class="line">&#125;struct3;</span><br><span class="line">struct ZJStruct4 &#123;</span><br><span class="line">    double a; //占8个字节 起始位置(0~7)</span><br><span class="line">    int b; //占4个字节 8是4的整数倍[8 4] 起始位置(8 9 10 11)</span><br><span class="line">    struct ZJStruct3 s3; // char(12) int(16,17,18,19) short(20,21) 结构体内部要对齐（4*3=12）补22,23</span><br><span class="line">    short c; //占2个字节 24是2的整数倍 (24,25)</span><br><span class="line">&#125;struct4;</span><br><span class="line">// 内部需要的大小：25个字节</span><br><span class="line">// 最大属性：8个字节</span><br><span class="line">// 结构体整数倍：8*4 = 32个字节</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们通过图来分析一下struct3的内存存储情况：</p><p><img src="https://user-images.githubusercontent.com/25925248/93211572-02a7e700-f794-11ea-8d12-56396f3f238a.png"></p><p>根据内存对齐规则，分析ZJStruct3的内存计算：</p><ul><li><code>变量a</code>：占<code>8</code>个字节，从<code>0</code>开始，此时 <code>0-7</code> 存储 <code>a</code></li><li><code>变量b</code>：占<code>4</code>个字节，从<code>8</code>开始，此时<code>8</code>可以整除<code>4</code>，即 <code>8-11</code> 存储 <code>b</code></li><li>结构体成员<code>s1</code>：<code>s1</code>是一个结构体，根据内存<code>对齐原则二</code>，结构体成员要从其内部<code>最大成员</code>大小的整数倍开始存储，而ZJStruct3中最大的成员大小为<code>4</code>，所以<code>s3</code>要从<code>4</code>的整数倍开始，当前是从<code>12</code>开始，所以符合要求，<code>12</code>是<code>4</code>的整数倍，符合内存对齐原则，所以 <code>12</code>开始<ul><li><code>变量a</code>：占<code>1</code>个字节，从<code>12</code>开始，此时<code>12</code>可以整除<code>4</code>，即 <code>12</code> 存储 <code>a</code></li><li><code>变量b</code>：占<code>4</code>个字节，从<code>13</code>开始，此时<code>13</code>不可以整除<code>4</code>，往后移动到<code>16</code>，此时<code>16</code>可以整除<code>4</code>，即 <code>16-19</code> 存储 <code>b</code></li><li><code>变量c</code>：占<code>2</code>个字节，从<code>20</code>开始，<code>20</code>可以整除<code>2</code>，即 <code>20-21</code> 存储 <code>c</code></li><li>由于结构体内部的字节对齐原则<code>4</code>的整数倍，后面要补上<code>22，23</code>，此时<code>12-23</code>正好是<code>4</code>的整数倍，即<code>4*3</code></li></ul></li><li><code>变量c</code>：占<code>2</code>个字节，从<code>24</code>开始，<code>24</code>可以整除<code>2</code>，即 <code>24-25</code> 存储 <code>c</code></li></ul><p>因此ZJStruct4的需要的内存大小为 <code>26</code> 字节，而ZJStruct4中最大变量的字节数为 <code>8</code>，所以 ZJStruct4 实际的内存大小必须是 <code>8</code> 的整数倍，<code>26</code> 向上取整到 <code>32</code>，主要是因为 <code>32</code> 是 <code>8</code> 的整数倍，所以 <code>sizeof(ZJStruct4)</code> 的结果是 <code>32</code></p><p><strong>4、我们通过上面的分析来实际验证一下结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 打印结构体内存大小</span><br><span class="line">NSLog(@&quot;%lu-%lu-%lu-%lu&quot;,sizeof(struct1),sizeof(struct2),sizeof(struct4),sizeof(struct4.s3));</span><br><span class="line">        </span><br><span class="line">*******打印结果******</span><br><span class="line">2020-09-15 20:23:52.275929+0800 001-内存对齐原则[25197:515659] 24-16-32-12</span><br></pre></td></tr></table></figure><p>结果显示我们分析的结果是正确的</p><h1 id="内存优化（属性重排）"><a href="#内存优化（属性重排）" class="headerlink" title="内存优化（属性重排）"></a>内存优化（属性重排）</h1><ul><li><p>如果是结构体中数据成员是根据内存 <code>从小到大的顺序定义</code> 的，根据内存对齐规则来计算结构体内存大小，需要增加有较大的内存padding即内存占位符，才能满足内存对齐规则，比较 <code>浪费内存</code></p></li><li><p>如果是结构体中数据成员是根据内存 <code>从大到小的顺序定义</code> 的，根据内存对齐规则来计算结构体内存大小，我们只需要补齐少量内存padding即可满足堆存对齐规则，这种方式就是苹果中采用的，利用 <code>空间换时间</code> ，将类中的属性进行重排，来达到优化内存的目的</p></li></ul><p>以下面这个例子来进行说明 苹果中属性重排，即内存优化：</p><p><strong>1、我们通过自定义一个类ZJPerson，并定义几个属性，来分析一下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString * name;</span><br><span class="line">@property (nonatomic, copy) NSString *nickName;</span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line">@property (nonatomic, assign) long height;</span><br><span class="line">@property (nonatomic) char c1;</span><br><span class="line">@property (nonatomic) char c2;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong>2、在main中创建ZJPerson的实例对象，并对其中的几个属性赋值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &lt;malloc/malloc.h&gt;</span><br><span class="line">#import &quot;ZJPerson.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // insert code here...</span><br><span class="line">        </span><br><span class="line">        // 对象的内存对齐 - 对象的内存对齐来自结构体</span><br><span class="line">        ZJPerson * p = [ZJPerson alloc]; //占8字节</span><br><span class="line">        p.name       = @&quot;ZJ&quot;; //占8个字节</span><br><span class="line">        p.nickName   = @&quot;小J&quot;; //占8个字节</span><br><span class="line">        p.age        = 30;  //占4个字节</span><br><span class="line">        p.c1        = &#x27;a&#x27;;  //占1个字节</span><br><span class="line">        p.c2        = &#x27;b&#x27;;  //占1个字节</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;%@ - %lu - %lu - %lu&quot;,p,sizeof(p),class_getInstanceSize([p class]),malloc_size((__bridge const void *)(p)));</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">********打印结果******</span><br><span class="line">2020-09-13 23:48:30.357717+0800 KCObjc[84742:2078708] &lt;ZJPerson: 0x100660120&gt; - 8 - 40 - 48</span><br></pre></td></tr></table></figure><p><strong>3、断点调试p，根据ZJPerson的对象地址，查找出属性的值：</strong></p><ul><li>当我们向通过 <code>0x0000001e00006261</code> 地址找出 <code>age</code> 等数据时，发现是 <code>乱码</code>，这里无法找出值的原因是苹果中针对 <code>age、c1、c2</code> 属性的内存进行了重排，因为 <code>age</code> 类型占 <code>4</code> 个字节，<code>c1</code> 和 <code>c2</code> 类型 <code>char</code> 分别占 <code>1</code> 个字节，通过 <code>4+1+1</code> 的方式，按照 <code>8</code> 字节对齐，不足补齐的方式存储在同一块内存中</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/93021660-6dcbaf00-f616-11ea-9aae-8dd7c500cd7f.png"></p><ul><li>我们通过<code>po 0x000000010d671058</code>找出<code>name</code>的值<code>ZJ</code>，通过<code>po 0x000000010d671078</code>找出<code>nickName</code>的值<code>小J</code><br><img src="/BboyZJ.github.io/!%5B%5D(https:/user-images.githubusercontent.com/25925248/92991523-f2cf9f00-f516-11ea-8432-44c60ec6b516.png"></li></ul><p><strong>4、所以，这里可以总结下苹果中的内存对齐思想：</strong></p><p>大部分的内存都是通过固定的内存块进行读取，尽管我们在内存中采用了内存对齐的方式，但并不是所有的内存都可以进行浪费的，苹果会自动 <code>对属性进行重排</code>，以此来 <code>优化内存</code></p><h1 id="字节对齐到底采用多少字节对齐？"><a href="#字节对齐到底采用多少字节对齐？" class="headerlink" title="字节对齐到底采用多少字节对齐？"></a>字节对齐到底采用多少字节对齐？</h1><p>到目前为止，我们在前文既提到了 <code>8</code> 字节对齐，也提及了 <code>16</code> 字节对齐，那我们到底采用哪种字节对齐呢？</p><p>我们可以通过 <code>objc4</code> 中的源码来进行分析</p><p><strong>1、<code>实例对象</code>开辟内存的流程如下：</strong></p><p>1）<code>class_getInstanceSize</code>内部实现如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * Returns the size of instances of a class.</span><br><span class="line"> * </span><br><span class="line"> * @param cls A class object.</span><br><span class="line"> * </span><br><span class="line"> * @return The size in bytes of instances of the class \e cls, or \c 0 if \e cls is \c Nil.</span><br><span class="line"> */</span><br><span class="line">OBJC_EXPORT size_t</span><br><span class="line">class_getInstanceSize(Class _Nullable cls) </span><br><span class="line">    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><code>class_getInstanceSize</code>内部调用<code>alignedInstanceSize</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Class&#x27;s ivar size rounded up to a pointer-size boundary.</span><br><span class="line">    uint32_t alignedInstanceSize() const &#123;</span><br><span class="line">        return word_align(unalignedInstanceSize());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>word_align</code>内部调用如下：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __LP64__</span><br><span class="line">#   define WORD_SHIFT 3UL</span><br><span class="line">#   define WORD_MASK 7UL</span><br><span class="line">#   define WORD_BITS 64</span><br><span class="line">#else</span><br><span class="line">#   define WORD_SHIFT 2UL</span><br><span class="line">#   define WORD_MASK 3UL</span><br><span class="line">#   define WORD_BITS 32</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">static inline uint32_t word_align(uint32_t x) &#123;</span><br><span class="line">    return (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可知：<code>(x + WORD_MASK) &amp; ~WORD_MASK</code>是一个运算，代表 <code>8</code> 字节对齐</p><p><strong>2、为什么对象真正开辟内存是8字节对齐？系统为对象开辟的是16字节对齐?</strong></p><p>apple系统为了 <code>防止一切的容错</code>，采用的是 <code>16</code> 字节对齐的内存，主要是因为采用 <code>8</code> 字节对齐时，两个对象的内存会紧挨着，显得 <code>比较紧凑</code>，而 <code>16</code> 字节 <code>比较宽松</code>，利于苹果以后的扩展。</p><h1 id="8字节内存计算"><a href="#8字节内存计算" class="headerlink" title="8字节内存计算"></a>8字节内存计算</h1><p>由断点可知此时的x为40，WORD_MASK为7，我们来计算一下：<code>(x + WORD_MASK) &amp; ~WORD_MASK</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2^5 = 32 2^4 = 16 2^3 = 8 2^2 = 4 2^1 = 2 2^0 = 1</span><br><span class="line"></span><br><span class="line">40 + 7 = 47 = 32 + 8 + 4 + 2 + 1 16进制表示</span><br><span class="line">0000 0000 0010 1111</span><br><span class="line"> </span><br><span class="line">7</span><br><span class="line">0000 0000 0000 0111</span><br><span class="line">7取反</span><br><span class="line">~1111 1111 1111 1000</span><br><span class="line"> </span><br><span class="line">47 &amp; ~7</span><br><span class="line">0000 0000 0010 1111</span><br><span class="line">1111 1111 1111 1000</span><br><span class="line">-----------------------</span><br><span class="line">0000 0000 0010 1000 = 40</span><br></pre></td></tr></table></figure><p>由结果<code>40</code>可知，与<code>class_getInstanceSize</code>获取实例对象的大小<code>40</code>如何吻合，还有谁？</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>class_getInstanceSize</code>：是采用 <code>8</code> 字节对齐，参照的对象的属性内存大小</li><li><code>malloc_size</code>：采用 <code>16</code> 字节对齐，参照的整个对象的内存大小，对象实际分配的内存大小必须是 <code>16</code> 的整数倍</li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理05：objc_alloc探索</title>
      <link href="/BboyZJ.github.io/2020/09/12/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8605%EF%BC%9Aobjc-alloc%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/09/12/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8605%EF%BC%9Aobjc-alloc%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章主要探索继承自 <code>NSObject</code> 的类 <code>ZJPerson</code> 和 <code>NSObject</code> 调用 <code>alloc</code> 的区别</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p><strong>1、下载<a href="https://opensource.apple.com/tarballs/">objc4-781</a>源码。</strong></p><p><strong>2、编译源码，可参考<a href="https://www.bboyzj.cn/2020/09/04/iOS-OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8602%EF%BC%9AObjc4%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/">iOS-OC底层原理02：Objc4源码编译</a></strong></p><h1 id="NSObject调用alloc探索"><a href="#NSObject调用alloc探索" class="headerlink" title="NSObject调用alloc探索"></a>NSObject调用alloc探索</h1><p><strong>1、第一步：在main函数中实现下面的代码，并下断点：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/92984910-7c17af00-f4e0-11ea-9be5-bb9c4127e431.png"></p><p><strong>2、第二步：到源码下断点到 <code>+ (id)alloc</code>，先 <code>取消断点</code>，等程序运行到目标行在去<code>跟踪断点</code>，原因在前面<a href="https://www.bboyzj.cn/2020/09/12/iOS-OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8601-%E6%9F%A5%E6%89%BE%E6%BA%90%E7%A0%81%E6%9C%89%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/">查找源码</a>已经讲过，在此不在说明：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/92984974-0fe97b00-f4e1-11ea-9633-e48599470125.png"></p><p>我们发现并没有进来，我滴天呐，说明调用的不是 <code>alloc</code></p><p><strong>3、第三步：我们换一种方式去查看源码，打开<code>Debug-&gt;Debug WorkFlow-&gt;Debug-&gt;Debug Workflow-&gt;Alway Show Disassembly</code>查看汇编：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/92985022-75d60280-f4e1-11ea-88b1-098d6072e648.png"></p><p>我们发现底层源码调用的是 <code>objc_alloc</code> ，到底是不是呢？接下来我们 <code>二次验证</code> 一下</p><p>**4、第四步:二次验证-&gt;先取消Debug查看方式，到源码中下断点到 <code>objc_alloc</code> **</p><p><img src="https://user-images.githubusercontent.com/25925248/92985110-33f98c00-f4e2-11ea-8820-44a33b9de454.png"></p><p>我们发现 <code>Class cls</code> 这个类确实是 <code>NSObject</code> ,验证了我们上面的调用过程</p><p><strong>5、第五步：继续往下走，<code>callAlloc</code> 内部调用流程</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/92985464-41fcdc00-f4e5-11ea-80c8-44297ed31268.png"></p><p>我们发现 <code>callAlloc</code> 内部最终调用的是 <code>_objc_rootAllocWithZone</code></p><p>最终和<a href="https://www.bboyzj.cn/2020/09/12/iOS-OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8603%EF%BC%9Aalloc&init&new%E6%8E%A2%E7%B4%A2/">iOS-OC底层原理03：alloc&amp;init&amp;new探索</a>alloc调用流程不谋而合</p><p><strong>6、结论：我们用流程图去表达一下调用流程</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/92985929-af127080-f4e9-11ea-99c2-b8a21e321e72.png"></p><h1 id="继承类ZPerson调用alloc真实调用流程"><a href="#继承类ZPerson调用alloc真实调用流程" class="headerlink" title="继承类ZPerson调用alloc真实调用流程"></a>继承类ZPerson调用alloc真实调用流程</h1><p><strong>1、第一步：在 <code>main</code> 函数中实现 <code>ZJPerson</code> 类的 <code>alloc</code> 方法进入alloc方法，并下断点：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93693180-d04d0f80-fb2e-11ea-9574-846fe98b654b.png"></p><p><strong>2、第二步：打开 <code>Debug-&gt;Debug WorkFlow-&gt;Debug-&gt;Debug Workflow-&gt;Alway Show Disassembly</code> 查看汇编：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/93693170-b01d5080-fb2e-11ea-9e35-41902386346a.png"></p><p><strong>3、第三步：通过在源码中下断点 <code>objc_alloc</code> 和 <code>alloc</code> 去跟踪具体先执行过程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">跳转至objc_alloc的源码实现</span><br><span class="line">// Calls [cls alloc].</span><br><span class="line">id</span><br><span class="line">objc_alloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, true/*checkNil*/, false/*allocWithZone*/);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、第四步：跳转至 <code>callAlloc</code> 的源码实现</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span><br><span class="line">// shortcutting optimizations.</span><br><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone=false)</span><br><span class="line">&#123;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">    // checkNil:true</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        // cls NSObject</span><br><span class="line">        return _objc_rootAllocWithZone(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // No shortcuts available.</span><br><span class="line">    // allocWithZone : false</span><br><span class="line">    if (allocWithZone) &#123;</span><br><span class="line">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>5、第五步：跳转至 <code>return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));</code> 的内部源码实现</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(void /* id self, SEL op, ... */ )</span><br><span class="line">    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);</span><br></pre></td></tr></table></figure><p>系统通过特殊消息发送：<code>sel - imp</code> 做了一层处理，最终执行到 <code>alloc</code>，根本就是系统通过LLVM特殊消息发送做的处理，有兴趣的小伙伴可以通过LLVM源码去探索一下</p><p><strong>6、第六步：跳转至 <code>alloc</code> 源码实现</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)alloc &#123;</span><br><span class="line">    return _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7、第七步：跳转至 <code>_objc_rootAlloc</code> 源码实现，我们可以验证 <code>cls</code> 是<code>ZJPerson</code></strong></p><p><img src="https://user-images.githubusercontent.com/25925248/92986292-074a7200-f4ec-11ea-9876-1aaddc3c3269.png"></p><p><strong>8、第八步：跳转至 <code>_objc_rootAllocWithZone</code> 源码实现</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span><br><span class="line">// shortcutting optimizations.</span><br><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone=false)</span><br><span class="line">&#123;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">    // checkNil:true</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        // cls NSObject</span><br><span class="line">        return _objc_rootAllocWithZone(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // No shortcuts available.</span><br><span class="line">    // allocWithZone : false</span><br><span class="line">    if (allocWithZone) &#123;</span><br><span class="line">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9、第九步：跳转至 <code>_class_createInstanceFromZone</code> 源码实现</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE</span><br><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)</span><br><span class="line">&#123;</span><br><span class="line">    // allocWithZone under __OBJC2__ ignores the zone parameter</span><br><span class="line">    return _class_createInstanceFromZone(cls, 0, nil,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>10、第十步：内部调用 <code>cls-&gt;instanceSize、calloc、obj-&gt;initInstanceIsa(cls, hasCxxDtor)、return obj</code> 方法返回对象，具体流程不再赘述</strong></p><p><strong>11、总结:ZJPerson的alloc调用流程图:</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/92986898-a2dde180-f4f0-11ea-8d07-670fde84cff2.png"></p><h1 id="ZJPerson的alloc和NSObject的alloc区别"><a href="#ZJPerson的alloc和NSObject的alloc区别" class="headerlink" title="ZJPerson的alloc和NSObject的alloc区别"></a>ZJPerson的alloc和NSObject的alloc区别</h1><ul><li><p><code>ZJPerson</code> 会走两次 <code>objc_alloc -&gt; alloc</code></p></li><li><p><code>NSObject</code> 只走一次 <code>objc_alloc</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理04：Optimization-Level-优化等级</title>
      <link href="/BboyZJ.github.io/2020/09/09/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8604%EF%BC%9AOptimization-Level-%E4%BC%98%E5%8C%96%E7%AD%89%E7%BA%A7/"/>
      <url>/BboyZJ.github.io/2020/09/09/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8604%EF%BC%9AOptimization-Level-%E4%BC%98%E5%8C%96%E7%AD%89%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Optimization Level</code> 是编译器的优化程度。比较早期的时候，硬件资源是比较缺乏的。为了 <code>提高性能</code>，开发编译器的大师们，都会对编译器(从c到汇编的编译过程)加上一定的优化策略。优化后的代码效率比较高，但是可读性比较差，且编译时间更长。 </p><h1 id="Optimization-Level"><a href="#Optimization-Level" class="headerlink" title="Optimization Level"></a>Optimization Level</h1><p><strong>下面我用一张截图表示设置的位置</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/92318184-34ee7180-f03b-11ea-98ee-25539ea20ec2.png"></p><ul><li>编译器优化设置在<code>target-&gt;Build Settings-&gt;Optimization Level</code>下,如图:</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/92305169-37a78300-efb7-11ea-811b-dc5b422c6d1a.png"></p><p>1）主要有两种模式<code>Debug</code>和<code>Release</code></p><ul><li>Debug下默认是关闭</li></ul><p>默认是 <code>None[-O0]</code></p><ul><li>Release模式下，编译器也会自动优化一些代码,这样生成的程序性能是最优的。默认是 <code>Fastest,Smallest[-Os]</code></li></ul><p>2）<code>Optimization Level</code>可以设置代码的优化等级。</p><ul><li><p><code>None：不优化</code>。[-O0]与此设置,编译器的目标是降低成本的编译和调试产生预期的结果。语句是独立的:如果你停止程序语句之间有一个断点,然后您可以指定一个新值的任何变量或任何其他声明改变程序计数器的功能和得到你期望的结果从源代码。</p></li><li><p><code>Fast</code>：优化编译需要更多的时间,和更多的内存大的功能。[-O,O1]与此设置,编译器试图减少代码大小和执行时间,没有执行任何优化,需要大量的编译时间。在苹果的编译器,严格的混叠,阻挡重新排序,并内嵌调度优化时默认是禁用的。</p></li><li><p><code>Faster</code>：编译器执行几乎所有支持优化,不涉及space-speed权衡。[-O2]与此设置,编译器不执行循环展开或内联函数,或寄存器重命名。相比“快速”的设置,该设置增加编译时间和生成的代码的性能。</p></li><li><p><code>Fastest</code>：打开 <code>更快</code> 指定的优化设置,也取决于函数内联和寄存器重命名选项。此设置可能会导致一个更大的二进制。</p></li><li><p><code>Fastest [-O3]</code>：最小的优化尺寸。这个设置允许所有 <code>更快</code> 的优化通常不增加代码大小。它还旨在减少代码的大小进行进一步的优化。</p></li></ul><h1 id="通过下面的代码我们来探索一下"><a href="#通过下面的代码我们来探索一下" class="headerlink" title="通过下面的代码我们来探索一下"></a>通过下面的代码我们来探索一下</h1><p><img src="https://user-images.githubusercontent.com/25925248/92318235-c9f16a80-f03b-11ea-9741-bd929707be58.png"></p><p><strong>我们可以通过下图方式去切换Debug和Release模式运行在真机：</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/92318373-15a51380-f03e-11ea-91be-a470cdcee40e.png"></p><p><strong>1、在真机Debug模式下运行，查看堆栈信息</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/92318360-e2628480-f03d-11ea-857a-6f151f7962e6.png"></p><p>注:x代表的是arm64操作系统，w代表的是arm32位操作系统，为了节省资源，所以在真机下用的是arm32为w来存储数据</p><p>我们通过LLDB调试具体打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">warning: failed to set breakpoint site at 0x104336290 for breakpoint 3.1: error: 0 sending the breakpoint request</span><br><span class="line">(lldb) po 0xa</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">(lldb) po 0x14</span><br><span class="line">20</span><br><span class="line"></span><br><span class="line">(lldb) register read w8</span><br><span class="line">      w8 = 0x0000001e</span><br><span class="line">(lldb) po 0x0000001e</span><br><span class="line">30</span><br><span class="line"></span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure><ul><li><p><code>po(print object)</code>: 常用于查看对象信息</p></li><li><p><code>register read</code>：读取所有寄存器值</p></li></ul><p><strong>2、在真机Release模式下运行，查看堆栈信息</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/92318421-aa0f7600-f03e-11ea-883f-944288c6d718.png"></p><p>我们来读取一下寄存器中的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read w8</span><br><span class="line">      w8 = 0x0000001e</span><br><span class="line">(lldb) po 0x0000001e</span><br><span class="line">30</span><br><span class="line"></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p><strong>3、Debug和Release的区别：</strong></p><ul><li><p>行数上看，debug是28行，release是14行，差距很大,这当然是编译器优化的结果。</p></li><li><p>debug版在0x104a725b8在调用NSLog之前做了好多多余动作，往返访问xmm寄存器。而release版都是立即数，没有做多余的动作。</p></li></ul><p><strong>4、编译器优化作用</strong></p><p><code>将变量存储到寄存器中，提高读取速度，进而提高性能。</code></p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理03：alloc&amp;init&amp;new探索</title>
      <link href="/BboyZJ.github.io/2020/09/07/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8603%EF%BC%9Aalloc&amp;init&amp;new%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/BboyZJ.github.io/2020/09/07/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8603%EF%BC%9Aalloc&amp;init&amp;new%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>在分析<code>alloc&amp;init&amp;new</code>源码之前，我们先来看看下面的代码：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    // 熟悉的入手 - 对象</span><br><span class="line">    // alloc 做了什么？</span><br><span class="line">    // init 做了什么？</span><br><span class="line">    </span><br><span class="line">    ZJPerson *p1 = [ZJPerson alloc];</span><br><span class="line">    ZJPerson *p2 = [p1 init];</span><br><span class="line">    ZJPerson *p3 = [p1 init];</span><br><span class="line">    ZJNSLog(@&quot;%@ - %p - %p&quot;,p1,p1,&amp;p1);</span><br><span class="line">    ZJNSLog(@&quot;%@ - %p - %p&quot;,p2,p2,&amp;p2);</span><br><span class="line">    ZJNSLog(@&quot;%@ - %p - %p&quot;,p3,p3,&amp;p3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看打印结果，分别输出3个对象的<code>内容、内存地址、指针地址</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ZJPerson: 0x600001316130&gt; - 0x600001316130 - 0x7ffee10e6188</span><br><span class="line">&lt;ZJPerson: 0x600001316130&gt; - 0x600001316130 - 0x7ffee10e6180</span><br><span class="line">&lt;ZJPerson: 0x600001316130&gt; - 0x600001316130 - 0x7ffee10e6178</span><br></pre></td></tr></table></figure><p>由上述打印结果，我们可以知道：</p><ul><li><p><code>p1,p2,p3对象</code> 的 <code>内存地址</code> 是相同的</p></li><li><p>返回的 <code>指针变量p1,p2,p3</code> 指向对象的 <code>内存地址</code> 也是相同的</p></li><li><p>而 <code>指针p的地址&amp;p</code> 是不同的</p></li></ul><p><strong>结论：</strong></p><ul><li><p>说明 <code>alloc开辟了内存空间</code>，而 <code>init没有开辟内存空间</code></p></li><li><p>p1,p2,p3指针变量指向了同一个内存空间ZJPerson</p></li></ul><p>下面用一张图说明一下:</p><p><img src="https://user-images.githubusercontent.com/25925248/92304048-2194c500-efad-11ea-8c04-1dfe9c27f0d9.png"></p><p>这就是本文需要探索的内容，alloc做了什么？init做了什么？，alloc&amp;init&amp;new到底干了什么?</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p><strong>1、下载 <a href="https://opensource.apple.com/tarballs/">objc4-781</a> 源码</strong></p><p><strong>2、编译源码，可参考<a href="https://www.bboyzj.cn/2020/09/04/iOS-OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8602%EF%BC%9AObjc4%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/">iOS-OC底层原理02：Objc4源码编译</a></strong></p><h1 id="alloc源码探索"><a href="#alloc源码探索" class="headerlink" title="alloc源码探索"></a>alloc源码探索</h1><p><strong>1、 创建一个ZJPerson自定义类，来分析一下底层调用流程</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/92318957-ed211780-f045-11ea-9502-88fa2100f133.png"></p><p><strong>2、跟踪alloc调用流程</strong></p><ul><li>通过断点调试<code>alloc</code>调用<code>_objc_rootAlloc</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)alloc &#123;</span><br><span class="line">    return _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过断点调试<code>_objc_rootAlloc</code>调用<code>callAlloc</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过断点调试<code>callAlloc</code>调用<code>_objc_rootAllocWithZone</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone=false)// alloc 源码 第三步</span><br><span class="line">&#123;</span><br><span class="line">#if __OBJC2__ //有可用的编译器优化</span><br><span class="line">    // checkNil 为false，!cls 也为false ，所以slowpath 为 false，假值判断不会走到if里面，即不会返回nil</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line">    </span><br><span class="line">    //hasCustomAWZ实际意义是hasCustomAllocWithZone——这里表示有没有alloc / allocWithZone的实现</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        //继承自NSObject/NSProxy的类才能走到这里，在oc中基本都继承自这两个类  </span><br><span class="line">        return _objc_rootAllocWithZone(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // No shortcuts available. // 没有可用的编译器优化</span><br><span class="line">    if (allocWithZone) &#123;</span><br><span class="line">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里补充一下<code>cls-&gt;ISA()-&gt;hasCustomAWZ()</code>是什么意思呢？</strong></p><p>其中fastpath中的 <code>cls-&gt;ISA()-&gt;hasCustomAWZ()</code> 这里表示hasCustomAWZ实际意义是hasCustomAllocWithZone——这里表示有没有alloc &#x2F; allocWithZone的实现（只有不是继承NSObject&#x2F;NSProxy的类才为true），这里通过断点调试，是没有自定义的实现，所以会执行到 <code>if</code> 里面的代码，即走到 <code>_objc_rootAllocWithZone</code></p><p><strong>这里补充一下 <code>slowpath &amp; fastpath</code> 是什么？</strong></p><p>其中关于slowpath和fastpath这里需要简要说明下，这两个都是objc源码中定义的宏，其定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// x很可能为真， fastpath 可以简称为 真值判断</span><br><span class="line">#define fastpath(x) (__builtin_expect(bool(x), 1)) </span><br><span class="line">// x很可能为假，slowpath 可以简称为 假值判断</span><br><span class="line">#define slowpath(x) (__builtin_expect(bool(x), 0)) </span><br></pre></td></tr></table></figure><p>其中的<code>__builtin_expect</code>指令是由<code>gcc</code>引入的，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">目的：编译器可以对代码进行优化，以减少指令跳转带来的性能下降。即性能优化</span><br><span class="line"></span><br><span class="line">作用：允许程序员将最有可能执行的分支告诉编译器。</span><br><span class="line"></span><br><span class="line">指令的写法为：`__builtin_expect(EXP, N)`。表示 EXP==N的概率很大。</span><br><span class="line"></span><br><span class="line">fastpath定义中__builtin_expect((x),1)表示 x 的值为真的可能性更大；即 执行if 里面语句的机会更大</span><br><span class="line"></span><br><span class="line">slowpath定义中的__builtin_expect((x),0)表示 x 的值为假的可能性更大。即执行 else 里面语句的机会更大</span><br><span class="line"></span><br><span class="line">在日常的开发中，也可以通过设置来优化编译器，达到性能优化的目的，设置的路径为：`Build Setting --&gt; Optimization Level --&gt; Debug --&gt;` 将None 改为 fastest 或者 smallest，即编译器优化</span><br></pre></td></tr></table></figure><ul><li>通过断点调试<code>_objc_rootAllocWithZone</code>调用<code>_class_createInstanceFromZone</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)</span><br><span class="line">&#123;</span><br><span class="line">    // allocWithZone under __OBJC2__ ignores the zone parameter</span><br><span class="line">    return _class_createInstanceFromZone(cls, 0, nil,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过断点调试<code>_class_createInstanceFromZone</code>内部调用<code>cls-&gt;instanceSize、calloc、obj-&gt;initInstanceIsa</code>，最后返回对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</span><br><span class="line">                              int construct_flags = OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              bool cxxConstruct = true,</span><br><span class="line">                              size_t *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    // Read class&#x27;s info bits all at once for performance</span><br><span class="line">    // hasCxxCtor()是判断当前class或者superclass是否有.cxx_construct 构造方法的实现</span><br><span class="line">    bool hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();</span><br><span class="line">    // hasCxxDtor()是判断判断当前class或者superclass是否有.cxx_destruct 析构方法的实现</span><br><span class="line">    bool hasCxxDtor = cls-&gt;hasCxxDtor();</span><br><span class="line">    // canAllocNonpointer()是具体标记某个类是否支持优化的isa</span><br><span class="line">    bool fast = cls-&gt;canAllocNonpointer();</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">    //1.返回开辟内存大小</span><br><span class="line">    size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    if (zone) &#123;</span><br><span class="line">        obj = (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //2.开辟内存</span><br><span class="line">        obj = (id)calloc(1, size);</span><br><span class="line">    &#125;</span><br><span class="line">    if (slowpath(!obj)) &#123;</span><br><span class="line">        if (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">            return _objc_callBadAllocHandler(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.初始化指针关联到相应的类</span><br><span class="line">    if (!zone &amp;&amp; fast) &#123;</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Use raw pointer isa on the assumption that they might be</span><br><span class="line">        // doing something weird with the zone or RR.</span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4.编译器优化返回对象</span><br><span class="line">    if (fastpath(!hasCxxCtor)) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    return object_cxxConstructFromClass(obj, cls, construct_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用的流程图</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/125250394-c4824200-e328-11eb-8ec6-5796d1c9ab5d.png"></p><p><strong>3、<code>cls-&gt;instanceSize</code> 实例对象返回开辟内存的大小？</strong></p><p>点击instanceSize跟踪断点去看源码来分析：</p><p><img src="https://user-images.githubusercontent.com/25925248/92319850-2742e700-f04f-11ea-8fdc-87eb196fb866.png"></p><p>1）调用的是下面两个函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size_t size = _flags &amp; FAST_CACHE_ALLOC_MASK;</span><br><span class="line">// remove the FAST_CACHE_ALLOC_DELTA16 that was added</span><br><span class="line">// by setFastInstanceSize</span><br><span class="line">return align16(size + extra - FAST_CACHE_ALLOC_DELTA16);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define FAST_CACHE_ALLOC_MASK         0x1ff8</span><br><span class="line">#define FAST_CACHE_ALLOC_MASK16       0x1ff0</span><br><span class="line">#define FAST_CACHE_ALLOC_DELTA16      0x0008</span><br></pre></td></tr></table></figure><ul><li><code>size</code>得到的值是<code>16</code></li><li><code>extra</code>得到的值是<code>0</code></li><li><code>FAST_CACHE_ALLOC_DELTA16</code>得到的值为 <code>= 16 - 0 - 8 = 8</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po 0x0008</span><br><span class="line">8</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）然后我们计算一下 <code>16</code> 字节对齐 <code>align16</code> 到底返回多少字节？</p><p><img src="https://user-images.githubusercontent.com/25925248/92319823-e519a580-f04e-11ea-8d33-34b67297b371.png"></p><p>计算一下(x + size_t(15))) &amp; ~size_t(15)的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">8 + 15 = 23</span><br><span class="line">0000 0000 0001 0111</span><br><span class="line"> </span><br><span class="line">15</span><br><span class="line">0000 0000 0000 1111</span><br><span class="line">~1111 1111 1111 0000</span><br><span class="line"> </span><br><span class="line">23 &amp; ~15</span><br><span class="line">0000 0000 0001 0111</span><br><span class="line">1111 1111 1111 0000</span><br><span class="line">-----------------------</span><br><span class="line">0000 0000 0001 0000</span><br><span class="line"> </span><br><span class="line">最后的值为16</span><br><span class="line">0000 0000 0001 0000</span><br></pre></td></tr></table></figure><p>结论：留下了16的倍数，<code>系统返回了16字节的内存</code></p><p>3）为什么是16字节的对齐？</p><ul><li>方便快捷</li><li>16字节更加安全</li><li>看起来不像 <code>8字节</code> 那么紧凑，并满足以后发展</li></ul><p><strong>4、calloc</strong></p><p>1）调用下面的方法去开辟内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//开辟内存</span><br><span class="line">obj = (id)calloc(1, size);</span><br></pre></td></tr></table></figure><p>2)下断点到obj &#x3D; (id)calloc(1, size);在这个地方打印po：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po obj</span><br><span class="line">0x000000010241e660</span><br></pre></td></tr></table></figure><p>打印的是指针变量的地址，没有打印出对象，说明这个地方还没有返回对象</p><p><strong>5、obj-&gt;initInstanceIsa</strong></p><p>1）断点查看下面的源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 3.初始化指针关联到相应的类</span><br><span class="line">if (!zone &amp;&amp; fast) &#123;</span><br><span class="line">    obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // Use raw pointer isa on the assumption that they might be</span><br><span class="line">    // doing something weird with the zone or RR.</span><br><span class="line">    obj-&gt;initIsa(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）下断点到 <code>obj-&gt;initInstanceIsa(cls, hasCxxDtor);</code> 到这行打印 <code>po</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po obj</span><br><span class="line">&lt;ZJPerson: 0x10241e660&gt;</span><br><span class="line"></span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure><p>说明在这个位置才是 <code>将初始化的指针关联到对象</code></p><p>3）返回对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 4.编译器优化返回对象</span><br><span class="line">if (fastpath(!hasCxxCtor)) &#123;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象开辟内存的影响因素"><a href="#对象开辟内存的影响因素" class="headerlink" title="对象开辟内存的影响因素"></a>对象开辟内存的影响因素</h2><p><strong>1、给对象添加属性</strong></p><p>ZJPerson.h文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface ZJPerson : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>main.h文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // insert code here...</span><br><span class="line">        </span><br><span class="line">        ZJPerson * p = [ZJPerson alloc];</span><br><span class="line">        p.name = @&quot;zj&quot;; //8</span><br><span class="line">        p.age = 30;     //4</span><br><span class="line">        NSLog(@&quot;申请内存大小为：%lu——-系统开辟内存大小为：%lu&quot;,class_getInstanceSize([p class]),malloc_size((__bridge const void *)(p)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、分析结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">分析结果：</span><br><span class="line">1. 成员变量应该分配内存：8字节 + 4字节 = 12字节</span><br><span class="line">2. 再加上isa的8字节 = 20字节</span><br><span class="line">3. 根据对象8字节对齐原则最大8字节，所以20往大走补充到24字节</span><br><span class="line">4. 所以内存空间应该分配24字节</span><br><span class="line">5. 注意：对象开辟空间的时候成员变量就会编译进来，所以成员变量未赋值也会分配内存</span><br><span class="line">6. 系统由于是16字节对齐原则，所以系统开辟的内存大小为16的倍数 = 16 * 2 = 32,而24大于16小于32，所以为32字节</span><br><span class="line"></span><br><span class="line">实际打印结果 : </span><br><span class="line">2020-09-06 15:28:31.072150+0800 ZJObjc[15774:988136] 申请内存大小为：24——-系统开辟内存大小为：32</span><br></pre></td></tr></table></figure><p><strong>3、分析内存情况</strong></p><p>1）打断点在 <code>ZJPerson * p = [ZJPerson alloc];</code> 行，终端输入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x p</span><br><span class="line">0x1006414b0: 35 22 00 00 01 80 1d 00 00 00 00 00 00 00 00 00  5&quot;..............</span><br><span class="line">0x1006414c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure><p><code>0x1006414b0</code> 为首地址，在iOS中内存是小端模式，由于没有赋值name和age所以 <code>35 22 00 00 01 80 1d 00</code> 后面的<code>00 00 00 00 00 00 00 00</code>是没值的</p><p>2）当我们打断点在NSLog(@”申请内存大小为…行时，终端输入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/4gx p</span><br><span class="line">0x1006414b0: 0x001d800100002235 0x000000000000001e</span><br><span class="line">0x1006414c0: 0x0000000100001018 0x0000000000000000</span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure><p>此时，我们看到<code>0x000000000000001e</code>和<code>0x0000000100001018</code>是有值的，分别代表<code>age=30</code>和<code>name=zj</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po 0x000000000000001e</span><br><span class="line">30</span><br><span class="line">(lldb) po 0x0000000100001018</span><br><span class="line">zj</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="init探索"><a href="#init探索" class="headerlink" title="init探索"></a>init探索</h1><p><strong>1、查看源码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    return _objc_rootInit(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_objc_rootInit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    // In practice, it will be hard to rely on this function.</span><br><span class="line">    // Many classes do not properly chain -init calls.</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由源码可知：init什么都没做，只是调用了 <code>_objc_rootInit</code> 重写 <code>init</code>，即构造方法，给用户提供入口去实现工厂设计。</p><h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><p>查看源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)new &#123;</span><br><span class="line">    return [callAlloc(self, false/*checkNil*/) init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现 和 <code>alloc</code> 调用 <code>callAlloc</code> 是一个流程，即等同于 <code>new = alloc + init</code>，但是有一点区别没有自定义的构造方法，所以一般自定义的类会用alloc init，系统的类用new。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本人小白，很多细节问题待补充，希望多多指点。</p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理02：Objc4源码编译</title>
      <link href="/BboyZJ.github.io/2020/09/05/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8602%EF%BC%9AObjc4%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
      <url>/BboyZJ.github.io/2020/09/05/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8602%EF%BC%9AObjc4%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>OC的一个主要特性Runtime运行时特性，在日常开发中我们使用到的都是不可见的，还好官方提供了 <code>Runtime（objc4）</code> 源码供开发者研究，我是 <code>ZJ</code>，下面就开始迈出源码探索的第一步，源码编译。</p><h1 id="下载objc4-781"><a href="#下载objc4-781" class="headerlink" title="下载objc4-781"></a>下载objc4-781</h1><ul><li>进入源码区</li></ul><p>打开<a href="https://opensource.apple.com/releases/">源码链接</a></p><ul><li>选择 <code>macOS</code> ，搜索 <code>objc4-</code> ，然后下载到桌面</li></ul><p><img src="/BboyZJ.github.io/assets/16773292357979.jpg"></p><h1 id="首先编译-target-objc"><a href="#首先编译-target-objc" class="headerlink" title="首先编译 target objc"></a>首先编译 target objc</h1><ul><li>unable to find sdk ‘macosx.internal’</li></ul><p><img src="/BboyZJ.github.io/assets/16773293171073.png"></p><p><strong>解决办法：</strong></p><p><code>PROJECTS –&gt; objc –&gt; Build Settings, 将 Base SDK 改成 macOS</code></p><p><code>TARGETS –&gt; objc –&gt; Build Settings, 将 Base SDK 改成 macOS</code></p><ul><li>‘sys&#x2F;reason.h’ file not found</li></ul><p><img src="/BboyZJ.github.io/assets/16773294876980.jpg"></p><p>解决办法：</p><p>还是在 <code>macOS</code> 目录下，下载 <code>xnu-8020.101.41</code>, 把 <code>xnu-8020.101.41/bsd/sys/reason.h</code> 文件复制到桌面创建的新文件夹 <code>comm_ifl/sys</code> 目录下</p><p><img src="/BboyZJ.github.io/assets/16773301435385.jpg"></p><p><img src="/BboyZJ.github.io/assets/16773307879721.jpg"></p><h1 id="将文件-ZJCommon-放在工程根目录下，并在工程设置文件的索引路径"><a href="#将文件-ZJCommon-放在工程根目录下，并在工程设置文件的索引路径" class="headerlink" title="将文件 ZJCommon 放在工程根目录下，并在工程设置文件的索引路径"></a>将文件 ZJCommon 放在工程根目录下，并在工程设置文件的索引路径</h1><ul><li>target -&gt; objc -&gt; Build Settings -&gt; Header Search Paths -&gt; 添加 <code>$(SRCROOT)/ZJCommon</code></li></ul><p><img src="/BboyZJ.github.io/assets/16773317251386.jpg"></p><h1 id="注释错误-可以最后再弄"><a href="#注释错误-可以最后再弄" class="headerlink" title="注释错误 可以最后再弄"></a>注释错误 可以最后再弄</h1><h2 id="Unknown-type-name-‘uint32-t’"><a href="#Unknown-type-name-‘uint32-t’" class="headerlink" title="Unknown type name ‘uint32_t’"></a>Unknown type name ‘uint32_t’</h2><ul><li>添加 #include &lt;stdint.h&gt;</li></ul><h2 id="‘mach-o-x2F-dyld-priv-h’-file-not-found"><a href="#‘mach-o-x2F-dyld-priv-h’-file-not-found" class="headerlink" title="‘mach-o&#x2F;dyld_priv.h’ file not found"></a>‘mach-o&#x2F;dyld_priv.h’ file not found</h2><ul><li>原理同上，下载 <code>dyld-960</code> 文件，将 <code>dyld_priv.h</code> 文件，拷贝到 <code>comm_ifl/mach-o/dyld_priv.h</code> 下</li></ul><h2 id="‘os-x2F-lock-private-h’-file-not-found"><a href="#‘os-x2F-lock-private-h’-file-not-found" class="headerlink" title="‘os&#x2F;lock_private.h’ file not found"></a>‘os&#x2F;lock_private.h’ file not found</h2><ul><li>原理同上，下载 <code>libplatform-273.100.5</code> 文件，将 <code>libplatform-273.100.5/private/os/lock_private.h</code> 中 <code>lock_private.h</code> 文件，拷贝到 <code>comm_ifl/os/lock_private.h</code> 下</li></ul><h2 id="extern-dyld-platform-t-dyld-get-active-platform-void-API-AVAILABLE-macos-10-14-ios-12-0-watchos-5-0-tvos-12-0-bridgeos-3-0-—-报错-Expected-‘-’"><a href="#extern-dyld-platform-t-dyld-get-active-platform-void-API-AVAILABLE-macos-10-14-ios-12-0-watchos-5-0-tvos-12-0-bridgeos-3-0-—-报错-Expected-‘-’" class="headerlink" title="extern dyld_platform_t dyld_get_active_platform(void) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); —- 报错 Expected ‘,’"></a>extern dyld_platform_t dyld_get_active_platform(void) __API_AVAILABLE(macos(10.14), ios(12.0), watchos(5.0), tvos(12.0), bridgeos(3.0)); —- 报错 Expected ‘,’</h2><ul><li><p>由于调试主要基于 <code>macos</code>，删除 <code>, bridgeos(3.0)</code></p></li><li><p>批量同上均删除 <code>, bridgeos(3.0)</code></p></li></ul><h2 id="bridgeos-4-0-问题"><a href="#bridgeos-4-0-问题" class="headerlink" title="bridgeos(4.0) 问题"></a>bridgeos(4.0) 问题</h2><ul><li>去除 <code>, bridgeos(4.0)</code></li></ul><h2 id="‘os-x2F-base-private-h’-file-not-found"><a href="#‘os-x2F-base-private-h’-file-not-found" class="headerlink" title="‘os&#x2F;base_private.h’ file not found"></a>‘os&#x2F;base_private.h’ file not found</h2><ul><li>在 <code>xnu-8020.101.41/libken/os/base_private.h</code> 中， 把 <code>base_private.h</code> 文件， 拷贝到 <code>comm_ifl/os/base_private.h</code></li></ul><h2 id="‘pthread-x2F-tsd-private-h’-file-not-found"><a href="#‘pthread-x2F-tsd-private-h’-file-not-found" class="headerlink" title="‘pthread&#x2F;tsd_private.h’ file not found"></a>‘pthread&#x2F;tsd_private.h’ file not found</h2><ul><li>下载 <code>libpthread-libpthread-486.100.11</code> 文件，将 <code>libpthread-libpthread-486.100.11/private/pthread/tsd_private.h</code> 拷贝到 <code>comm_ifl/pthread/tsd_private.h</code></li></ul><h2 id="‘os-x2F-feature-private-h’-file-not-found"><a href="#‘os-x2F-feature-private-h’-file-not-found" class="headerlink" title="‘os&#x2F;feature_private.h’ file not found"></a>‘os&#x2F;feature_private.h’ file not found</h2><ul><li>注释掉</li></ul><h2 id="‘os-x2F-variant-private-h’-file-not-found"><a href="#‘os-x2F-variant-private-h’-file-not-found" class="headerlink" title="‘os&#x2F;variant_private.h’ file not found"></a>‘os&#x2F;variant_private.h’ file not found</h2><ul><li>拷贝 <code>Libc-Libc-1507.100.9/os/variant_private.h</code> 至 <code>comm_ifl/os/variant_private.h</code></li></ul><h2 id="‘os-x2F-tsd-h’-file-not-found"><a href="#‘os-x2F-tsd-h’-file-not-found" class="headerlink" title="‘os&#x2F;tsd.h’ file not found"></a>‘os&#x2F;tsd.h’ file not found</h2><ul><li>拷贝 <code>xnu-xnu-8020.101.4/libsyscall/os/tsd.h</code> 至 <code>comm_ifl/os/tsd.h</code></li></ul><h2 id="‘pthread-x2F-spinlock-private-h’-file-not-found"><a href="#‘pthread-x2F-spinlock-private-h’-file-not-found" class="headerlink" title="‘pthread&#x2F;spinlock_private.h’ file not found"></a>‘pthread&#x2F;spinlock_private.h’ file not found</h2><ul><li>拷贝 <code>libpthread-libpthread-486.100.11/private/pthread/spinlock_private.h</code> 至 <code>comm_ifl/pthread/spinlock_private.h</code></li></ul><h2 id="Expected-function-body-after-function-declarator"><a href="#Expected-function-body-after-function-declarator" class="headerlink" title="Expected function body after function declarator"></a>Expected function body after function declarator</h2><p><img src="/BboyZJ.github.io/assets/16773436729137.jpg"></p><h2 id="‘System-x2F-pthread-machdep-h’-file-not-found"><a href="#‘System-x2F-pthread-machdep-h’-file-not-found" class="headerlink" title="‘System&#x2F;pthread_machdep.h’ file not found"></a>‘System&#x2F;pthread_machdep.h’ file not found</h2><p>‘System&#x2F;pthread_machdep.h’文件只有在Libc-825.40.1及以下版本才有</p><ul><li>在 <a href="https://opensource.apple.com/source/Libc/Libc-583/pthreads/">https://opensource.apple.com/source/Libc/Libc-583/pthreads/</a> 上下载  <code>pthread_machdep.h</code>，拷贝 <code>pthread_machdep.h</code> 至 <code>comm_ifl/System/pthread_machdep.h</code></li></ul><h2 id="‘CrashReporterClient-h’-file-not-found"><a href="#‘CrashReporterClient-h’-file-not-found" class="headerlink" title="‘CrashReporterClient.h’ file not found"></a>‘CrashReporterClient.h’ file not found</h2><ul><li>在 <a href="https://opensource.apple.com/source/Libc/Libc-997.90.3/include/CrashReporterClient.h.auto.html">这里下载</a> 拷贝 <code>CrashReporterClient.h</code> 至 <code>comm_ifl/CrashReporterClient.h</code></li></ul><p>#include_next&lt;CrashReporterClient.h&gt; 改为<br>#include &lt;CrashReporterClient.h&gt;</p><p>依然报错：在 Build Settings -&gt; Preprocessor Macros 中加入: <code>LIBC_NO_LIBCRASHREPORTERCLIENT</code></p><h2 id="Typedef-redefinition-with-different-types-‘int’-vs-‘volatile-OSSpinLock’-aka-‘volatile-int’"><a href="#Typedef-redefinition-with-different-types-‘int’-vs-‘volatile-OSSpinLock’-aka-‘volatile-int’" class="headerlink" title="Typedef redefinition with different types (‘int’ vs ‘volatile OSSpinLock’ (aka ‘volatile int’))"></a>Typedef redefinition with different types (‘int’ vs ‘volatile OSSpinLock’ (aka ‘volatile int’))</h2><ul><li>注释掉</li></ul><p><img src="/BboyZJ.github.io/assets/16773372999335.jpg"></p><p><img src="/BboyZJ.github.io/assets/16773374928022.jpg"></p><h2 id="Unexpected-character-lt-U-1F92F-gt"><a href="#Unexpected-character-lt-U-1F92F-gt" class="headerlink" title="Unexpected character &lt;U+1F92F&gt;"></a>Unexpected character &lt;U+1F92F&gt;</h2><p><img src="/BboyZJ.github.io/assets/16773376550893.jpg"></p><ul><li>注释掉</li></ul><h2 id="Use-of-undeclared-identifier-‘dyld-platform-version-macOS-10-13’"><a href="#Use-of-undeclared-identifier-‘dyld-platform-version-macOS-10-13’" class="headerlink" title="Use of undeclared identifier ‘dyld_platform_version_macOS_10_13’"></a>Use of undeclared identifier ‘dyld_platform_version_macOS_10_13’</h2><p><img src="/BboyZJ.github.io/assets/16773379899115.png"></p><ul><li>注释掉</li></ul><p><img src="/BboyZJ.github.io/assets/16773379966106.png"></p><h2 id="‘os-x2F-reason-private-h’-file-not-found"><a href="#‘os-x2F-reason-private-h’-file-not-found" class="headerlink" title="‘os&#x2F;reason_private.h’ file not found"></a>‘os&#x2F;reason_private.h’ file not found</h2><ul><li>拷贝 <code>xnu-xnu-8020.101.4/libkern/os/reason_private.h</code> 至 <code>comm_ifl/os/reason_private.h</code></li></ul><h2 id="‘os-x2F-bsd-h’-file-not-found"><a href="#‘os-x2F-bsd-h’-file-not-found" class="headerlink" title="‘os&#x2F;bsd.h’ file not found"></a>‘os&#x2F;bsd.h’ file not found</h2><ul><li>直接注释</li></ul><h2 id="‘objc-shared-cache-h’-file-not-found"><a href="#‘objc-shared-cache-h’-file-not-found" class="headerlink" title="‘objc-shared-cache.h’ file not found"></a>‘objc-shared-cache.h’ file not found</h2><ul><li>拷贝 <code>dyld-dyld-960/include/objc-shared-cache.h</code> 至 <code>comm_ifl/objc-shared-cache.h</code></li></ul><h2 id="‘os-x2F-linker-set-h’-file-not-found"><a href="#‘os-x2F-linker-set-h’-file-not-found" class="headerlink" title="‘os&#x2F;linker_set.h’ file not found"></a>‘os&#x2F;linker_set.h’ file not found</h2><ul><li>拷贝 <code>Libc-Libc-1507.100.9/os/linker_set.h</code> 至 <code>comm_ifl/os/linker_set.h</code></li></ul><h2 id="‘-simple-h’-file-not-found"><a href="#‘-simple-h’-file-not-found" class="headerlink" title="‘_simple.h’ file not found"></a>‘_simple.h’ file not found</h2><ul><li>全局搜索 <code>_simple.h</code> 拷贝至 <code>comm_ifl/_simple.h</code></li></ul><h2 id="Use-of-undeclared-identifier-‘dyld-fall-2020-os-versions’"><a href="#Use-of-undeclared-identifier-‘dyld-fall-2020-os-versions’" class="headerlink" title="Use of undeclared identifier ‘dyld_fall_2020_os_versions’"></a>Use of undeclared identifier ‘dyld_fall_2020_os_versions’</h2><ul><li>注释掉</li></ul><p><img src="/BboyZJ.github.io/assets/16773457312254.jpg"></p><h2 id="Use-of-undeclared-identifier-‘objc4’"><a href="#Use-of-undeclared-identifier-‘objc4’" class="headerlink" title="Use of undeclared identifier ‘objc4’"></a>Use of undeclared identifier ‘objc4’</h2><ul><li>注释掉</li></ul><h2 id="Use-of-undeclared-identifier-‘preoptimizedCaches’"><a href="#Use-of-undeclared-identifier-‘preoptimizedCaches’" class="headerlink" title="Use of undeclared identifier ‘preoptimizedCaches’"></a>Use of undeclared identifier ‘preoptimizedCaches’</h2><ul><li>注释掉</li></ul><h2 id="Use-of-undeclared-identifier-‘CRGetCrashLogMessage’"><a href="#Use-of-undeclared-identifier-‘CRGetCrashLogMessage’" class="headerlink" title="Use of undeclared identifier ‘CRGetCrashLogMessage’"></a>Use of undeclared identifier ‘CRGetCrashLogMessage’</h2><p><img src="/BboyZJ.github.io/assets/16773460165267.jpg"></p><ul><li>注释掉</li></ul><p><img src="/BboyZJ.github.io/assets/16773460340596.jpg"></p><h2 id="‘Cambria-x2F-Traps-h’-file-not-found-和-‘Cambria-x2F-Cambria-h’-file-not-found"><a href="#‘Cambria-x2F-Traps-h’-file-not-found-和-‘Cambria-x2F-Cambria-h’-file-not-found" class="headerlink" title="‘Cambria&#x2F;Traps.h’ file not found  和 ‘Cambria&#x2F;Cambria.h’ file not found"></a>‘Cambria&#x2F;Traps.h’ file not found  和 ‘Cambria&#x2F;Cambria.h’ file not found</h2><ul><li>注释掉</li></ul><p><img src="/BboyZJ.github.io/assets/16773461026505.jpg"></p><h2 id="Use-of-undeclared-identifier-‘objc-thread-get-rip’"><a href="#Use-of-undeclared-identifier-‘objc-thread-get-rip’" class="headerlink" title="Use of undeclared identifier ‘objc_thread_get_rip’"></a>Use of undeclared identifier ‘objc_thread_get_rip’</h2><p><img src="/BboyZJ.github.io/assets/16773392011798.png"></p><h2 id="‘kern-x2F-restartable-h’-file-not-found"><a href="#‘kern-x2F-restartable-h’-file-not-found" class="headerlink" title="‘kern&#x2F;restartable.h’ file not found"></a>‘kern&#x2F;restartable.h’ file not found</h2><ul><li><code>xnu-xnu-8020.101.4/osfmk/kern/restartable.h</code> 拷贝到 <code>comm_ifl/kern/restartable.h</code></li></ul><h2 id="Use-of-undeclared-identifier-‘oah-is-current-process-translated’"><a href="#Use-of-undeclared-identifier-‘oah-is-current-process-translated’" class="headerlink" title="Use of undeclared identifier ‘oah_is_current_process_translated’"></a>Use of undeclared identifier ‘oah_is_current_process_translated’</h2><ul><li>注释掉</li></ul><p><img src="/BboyZJ.github.io/assets/16773392011798.png"></p><h2 id="‘Block-private-h’-file-not-found"><a href="#‘Block-private-h’-file-not-found" class="headerlink" title="‘Block_private.h’ file not found"></a>‘Block_private.h’ file not found</h2><ul><li><code>libclosure-libclosure-79.1/Block_private.h</code> 拷贝到 <code>comm_ifl/Block_private.h</code></li></ul><h2 id="Use-of-undeclared-identifier-‘os-parse-boot-arg-string’"><a href="#Use-of-undeclared-identifier-‘os-parse-boot-arg-string’" class="headerlink" title="Use of undeclared identifier ‘os_parse_boot_arg_string’"></a>Use of undeclared identifier ‘os_parse_boot_arg_string’</h2><ul><li>注释掉</li></ul><h2 id="Use-of-undeclared-identifier-‘dyld-platform-version-macOS-10-11’"><a href="#Use-of-undeclared-identifier-‘dyld-platform-version-macOS-10-11’" class="headerlink" title="Use of undeclared identifier ‘dyld_platform_version_macOS_10_11’"></a>Use of undeclared identifier ‘dyld_platform_version_macOS_10_11’</h2><ul><li>注释掉</li></ul><p><img src="/BboyZJ.github.io/assets/16773458965347.png"></p><h2 id="Use-of-undeclared-identifier-‘dyld-fall-2018-os-versions’"><a href="#Use-of-undeclared-identifier-‘dyld-fall-2018-os-versions’" class="headerlink" title="Use of undeclared identifier ‘dyld_fall_2018_os_versions’"></a>Use of undeclared identifier ‘dyld_fall_2018_os_versions’</h2><p><img src="/BboyZJ.github.io/assets/16773332431137.png"></p><h2 id="Use-of-undeclared-identifier-‘dyld-platform-version-macOS-10-12’"><a href="#Use-of-undeclared-identifier-‘dyld-platform-version-macOS-10-12’" class="headerlink" title="Use of undeclared identifier ‘dyld_platform_version_macOS_10_12’"></a>Use of undeclared identifier ‘dyld_platform_version_macOS_10_12’</h2><p><img src="/BboyZJ.github.io/assets/16773332365388.png"></p><h2 id="‘-static-assert’-declared-as-an-array-with-a-negative-size"><a href="#‘-static-assert’-declared-as-an-array-with-a-negative-size" class="headerlink" title="‘_static_assert’ declared as an array with a negative size"></a>‘_static_assert’ declared as an array with a negative size</h2><p><img src="/BboyZJ.github.io/assets/16773332596335.png"></p><ul><li>注释掉</li></ul><p><img src="/BboyZJ.github.io/assets/16773463751255.jpg"></p><h1 id="最后这几步很重要"><a href="#最后这几步很重要" class="headerlink" title="最后这几步很重要"></a>最后这几步很重要</h1><h2 id="在-dyld-priv-h-文件顶部加入宏"><a href="#在-dyld-priv-h-文件顶部加入宏" class="headerlink" title="在 dyld_priv.h 文件顶部加入宏"></a>在 dyld_priv.h 文件顶部加入宏</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define DYLD_MACOSX_VERSION_10_11 0x000A0B00</span><br><span class="line">#define DYLD_MACOSX_VERSION_10_12 0x000A0C00</span><br><span class="line">#define DYLD_MACOSX_VERSION_10_13 0x000A0D00</span><br><span class="line">#define DYLD_MACOSX_VERSION_10_14 0x000A0E00</span><br></pre></td></tr></table></figure><h2 id="CrashReporterClient异常"><a href="#CrashReporterClient异常" class="headerlink" title="CrashReporterClient异常"></a>CrashReporterClient异常</h2><p><img src="/BboyZJ.github.io/assets/16773333284666.png"></p><h2 id="library-not-found-for-loah"><a href="#library-not-found-for-loah" class="headerlink" title="library not found for -loah"></a>library not found for -loah</h2><p><img src="/BboyZJ.github.io/assets/16773396503792.png"></p><p><img src="/BboyZJ.github.io/assets/16773396598676.png"></p><p><img src="/BboyZJ.github.io/assets/16773396987117.png"></p><h2 id="‘macosx-internal’-cannot-be-located"><a href="#‘macosx-internal’-cannot-be-located" class="headerlink" title="‘macosx.internal’ cannot be located."></a>‘macosx.internal’ cannot be located.</h2><p><img src="/BboyZJ.github.io/assets/16773406324319.png"></p><h1 id="接下来objc进行编译调试"><a href="#接下来objc进行编译调试" class="headerlink" title="接下来objc进行编译调试"></a>接下来objc进行编译调试</h1><h2 id="新建target-：ZJDemo"><a href="#新建target-：ZJDemo" class="headerlink" title="新建target ：ZJDemo"></a>新建target ：ZJDemo</h2><p><img src="/BboyZJ.github.io/assets/16773407167741.png"></p><p><img src="/BboyZJ.github.io/assets/16773408161186.jpg"></p><h2 id="建立依赖"><a href="#建立依赖" class="headerlink" title="建立依赖"></a>建立依赖</h2><p><img src="/BboyZJ.github.io/assets/16773408930734.jpg"></p><p><img src="/BboyZJ.github.io/assets/16773415702933.jpg"></p><h2 id="创建一个macOS类ZJPerson"><a href="#创建一个macOS类ZJPerson" class="headerlink" title="创建一个macOS类ZJPerson"></a>创建一个macOS类ZJPerson</h2><p><img src="/BboyZJ.github.io/assets/16773479618460.jpg"></p><h2 id="绑定到ZJDemo的target上"><a href="#绑定到ZJDemo的target上" class="headerlink" title="绑定到ZJDemo的target上"></a>绑定到ZJDemo的target上</h2><p><img src="/BboyZJ.github.io/assets/16773479995999.jpg"></p><h2 id="注释文件执行顺序"><a href="#注释文件执行顺序" class="headerlink" title="注释文件执行顺序"></a>注释文件执行顺序</h2><p><img src="/BboyZJ.github.io/assets/16773480639277.jpg"></p><h2 id="编译调试target"><a href="#编译调试target" class="headerlink" title="编译调试target"></a>编译调试target</h2><p><img src="/BboyZJ.github.io/assets/16773410034010.jpg"></p><h2 id="下符号调试"><a href="#下符号调试" class="headerlink" title="下符号调试"></a>下符号调试</h2><p><img src="/BboyZJ.github.io/assets/16773481552089.jpg"></p><p><img src="/BboyZJ.github.io/assets/16773481863099.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理01：查找源码有三种方式</title>
      <link href="/BboyZJ.github.io/2020/09/03/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8601%EF%BC%9A%E6%9F%A5%E6%89%BE%E6%BA%90%E7%A0%81%E6%9C%89%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/BboyZJ.github.io/2020/09/03/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8601%EF%BC%9A%E6%9F%A5%E6%89%BE%E6%BA%90%E7%A0%81%E6%9C%89%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要介绍下源码探索的三种方法：</p><ul><li><p>1、符号断点直接跟流程</p></li><li><p>2、通过按住 control+step into</p></li><li><p>3、汇编跟流程</p></li></ul><h1 id="下符号断点的形式直接跟流程"><a href="#下符号断点的形式直接跟流程" class="headerlink" title="下符号断点的形式直接跟流程"></a>下符号断点的形式直接跟流程</h1><ul><li>切换到<code>Show the breakpoing navigator</code>栏，打击左下角<code>“+”</code>号<code>create a breakpoint</code>创建一个断点</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/92352926-c16b6380-f111-11ea-8ff8-f158720acda2.png"></p><ul><li>添加要查看的符号<code>alloc</code></li></ul><p><img src="https://user-images.githubusercontent.com/25925248/92304230-ab915d80-efae-11ea-8056-9986dcb49533.png"></p><ul><li>设置地址断点，并取消之前设置的符号断点4，以便执行目标行，因为系统调用alloc的方法有很多，你不知道什么时候能执行到目标位置</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/92304239-b9df7980-efae-11ea-8cd8-e79c2e7cd1f7.png"><br><img src="https://user-images.githubusercontent.com/25925248/92304284-1e023d80-efaf-11ea-96bf-a731ca00a9d2.png"></p><ul><li><code>command + R</code>编译并运行工程，当代码执行到3时，将符号断点4选中，查看执行的底层源码</li></ul><h1 id="通过摁住control-step-into"><a href="#通过摁住control-step-into" class="headerlink" title="通过摁住control - step into"></a>通过摁住control - step into</h1><ul><li><code>command + R</code>编译并运行工程，代码执行到目标行，按住<code>control + step into</code>单步运行箭头</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/92304458-a7663f80-efb0-11ea-895e-27b122dba353.png"></p><ul><li>按上面的方式，进入汇编可得下图：</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/92304462-b816b580-efb0-11ea-9f89-f98b56299b7d.png"></p><p><strong>注:jmpq是设么意思？<br>jmpq 就是jmp 指令。q是gnu汇编的用法。q表示跳转到64位地址。l表示32位地址。</strong></p><ul><li>然后打一个<code>objc_alloc</code>的符号断点，跳转到汇编代码可得下图:</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/92304530-64589c00-efb1-11ea-9a3d-16bcef0ab0f9.png"></p><p>由上图可知<code>objc_alloc</code>是在<code>libobjc.A.dylib</code>这个动态链接库上<br><strong>注：.dylib是OSX上的动态库扩展</strong></p><h1 id="查看运行时的汇编代码"><a href="#查看运行时的汇编代码" class="headerlink" title="查看运行时的汇编代码"></a>查看运行时的汇编代码</h1><ul><li><code>Xcode</code>点击<code>Debug-&gt;Debug Workflow-&gt;Alway Show Disassembly</code>查看运行时的汇编代码</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/92304607-2019cb80-efb2-11ea-8e66-b264b8b2c0ed.png"></p><ul><li>运行成功后的汇编代码如下</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/92304687-bea62c80-efb2-11ea-9bf0-4b6d367ea83c.png"></p><p>可知底层调用的方法是<code>objc_alloc</code></p><p><strong>注：callq：调用函数的意思，即调用函数时的压栈出栈</strong></p><ul><li>在下一个符号断点<code>objc_alloc</code>,继续执行和上面的就一样了</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由上面的方法我们可知 <code>alloc</code> 底层调用的是 <code>objc_alloc</code>，所在的位置是<code>libobjc.A.dylib</code> 这个动态链接库，用一张流程图总结：</p><p><img src="https://user-images.githubusercontent.com/25925248/92955249-65009f00-f497-11ea-9d4a-f3dac0712e5e.png"></p>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理00：LLDB常用命令</title>
      <link href="/BboyZJ.github.io/2020/09/01/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8600%EF%BC%9ALLDB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/BboyZJ.github.io/2020/09/01/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8600%EF%BC%9ALLDB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="x-对象：以-16-进制，打印对象的内存分布，位数为-16"><a href="#x-对象：以-16-进制，打印对象的内存分布，位数为-16" class="headerlink" title="x 对象：以 16 进制，打印对象的内存分布，位数为 16"></a><code>x 对象</code>：以 <code>16</code> 进制，打印对象的内存分布，位数为 <code>16</code></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x p</span><br><span class="line">0x100792110: 75 32 00 00 01 80 1d 00 00 00 00 00 00 00 00 00  u2..............</span><br><span class="line">0x100792120: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure><h1 id="memory-read-对象：以-16-进制，打印对象的内存分布，和1一样，位数为-16"><a href="#memory-read-对象：以-16-进制，打印对象的内存分布，和1一样，位数为-16" class="headerlink" title="memory read 对象：以 16 进制，打印对象的内存分布，和1一样，位数为 16"></a><code>memory read 对象</code>：以 <code>16</code> 进制，打印对象的内存分布，和1一样，位数为 <code>16</code></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read p</span><br><span class="line">0x100792110: 75 32 00 00 01 80 1d 00 00 00 00 00 00 00 00 00  u2..............</span><br><span class="line">0x100792120: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure><h1 id="x-4gx-对象：以16进制，打印4段对象的内存分布情况，位数为16"><a href="#x-4gx-对象：以16进制，打印4段对象的内存分布情况，位数为16" class="headerlink" title="x/4gx 对象：以16进制，打印4段对象的内存分布情况，位数为16"></a><code>x/4gx 对象</code>：以<code>16</code>进制，打印<code>4段</code>对象的内存分布情况，位数为<code>16</code></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/4gx p</span><br><span class="line">0x100792110: 0x001d800100003275 0x0000000000000000</span><br><span class="line">0x100792120: 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure><h1 id="x-4gw-对象：以16进制，打印4段对象的内存分布情况，位数为16"><a href="#x-4gw-对象：以16进制，打印4段对象的内存分布情况，位数为16" class="headerlink" title="x/4gw 对象：以16进制，打印4段对象的内存分布情况，位数为16"></a><code>x/4gw 对象</code>：以<code>16</code>进制，打印<code>4段</code>对象的内存分布情况，位数为<code>16</code></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/4gw p</span><br><span class="line">0x100792110: 0x00003275 0x001d8001 0x00000000 0x00000000</span><br></pre></td></tr></table></figure><h1 id="po-对象：输出对应的值"><a href="#po-对象：输出对应的值" class="headerlink" title="po 对象：输出对应的值"></a><code>po 对象</code>：输出对应的值</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po p</span><br><span class="line">&lt;LGPerson: 0x100792110&gt;</span><br></pre></td></tr></table></figure><h1 id="p-对象：返回值的类型以及命令结果的引用名，将地址0x0000000100792110放到寄存器-5中"><a href="#p-对象：返回值的类型以及命令结果的引用名，将地址0x0000000100792110放到寄存器-5中" class="headerlink" title="p 对象：返回值的类型以及命令结果的引用名，将地址0x0000000100792110放到寄存器$5中"></a><code>p 对象</code>：返回值的类型以及命令结果的引用名，将地址<code>0x0000000100792110</code>放到<code>寄存器$5</code>中</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p p</span><br><span class="line">(LGPerson *) $5 = 0x0000000100792110</span><br></pre></td></tr></table></figure><h1 id="p-x：以16进制的形式，打印类信息"><a href="#p-x：以16进制的形式，打印类信息" class="headerlink" title="p/x：以16进制的形式，打印类信息"></a><code>p/x</code>：以16进制的形式，打印类信息</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x p</span><br><span class="line">(LGPerson *) $6 = 0x0000000100792110</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发者账号03：苹果开发者证书创建</title>
      <link href="/BboyZJ.github.io/2020/08/29/%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B/iOS%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B703%EF%BC%9A%E8%8B%B9%E6%9E%9C%E5%BC%80%E5%8F%91%E8%80%85%E8%AF%81%E4%B9%A6%E5%88%9B%E5%BB%BA/"/>
      <url>/BboyZJ.github.io/2020/08/29/%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B/iOS%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B703%EF%BC%9A%E8%8B%B9%E6%9E%9C%E5%BC%80%E5%8F%91%E8%80%85%E8%AF%81%E4%B9%A6%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <code>Certificates, Identifiers &amp; Profiles</code> 中，有几个选项，而前面四个是苹果开发者账号证书配置分为四个部分：</p><ul><li><p>申请 <code>Identifiers</code>：即 <code>APP IDs</code> ,设备唯一标识</p></li><li><p>创建证书 <code>Certificates</code> ：开发、发布证书(包括推送证书)</p></li><li><p><code>Devices</code>：测试设备注册</p></li><li><p><code>Profiles</code>：应用描述配置</p></li></ul><h1 id="申请Identifiers"><a href="#申请Identifiers" class="headerlink" title="申请Identifiers"></a>申请Identifiers</h1><ol><li>选择 <code>APP IDs</code> ，点击 <code>Continue</code>，进入下一个页面</li></ol><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150618991.png"></p><ol start="2"><li>来到 <code>Select a type</code>，默认选中 <code>App</code> ，点击 <code>Continue</code> 继续往下个页面走</li></ol><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150618903.png"></p><ol start="3"><li>来到设置 <code>Budle ID</code> 的页面，填写 <code>描述信息和Budle id</code> 填写：</li></ol><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150618347.png"></p><ul><li><p><code>Description</code>： <code>填写APP 描述</code></p></li><li><p><code>Bundle ID</code>：公司网址颠倒 + APP名字，例如 <code>epod.cn.xxxx</code>。 </p><ul><li><code>Explocit</code>：显示的，默认选中。</li><li><code>Wildcard</code>：通配符样式</li></ul></li></ul><ol start="4"><li>Capabilities : 在下面还有一些可选功能</li></ol><ul><li>根据APP需求，勾选需要的权限，一般推送，内购买。</li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150618348.png"></p><ol start="5"><li>点击Register</li></ol><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150618502.png"></p><ol start="6"><li>得到的 <code>Idenifiers</code> 如下：</li></ol><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150619037.jpg"></p><h1 id="Mac生成CSR"><a href="#Mac生成CSR" class="headerlink" title="Mac生成CSR"></a>Mac生成CSR</h1><ol><li>打开钥匙串-&gt;证书助理-&gt;从证书颁发机构请求证书</li></ol><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150619354.png"></p><p>注：不管是申请 <code>开发(Development)证书</code> 还是 <code>发布(Distribution)证书</code> ，都需要使用 <code>证书请求(.certSigningRequest)文件</code> 打开Mac上的钥匙串，从证书助手那里请求证书。</p><ol start="2"><li>填写证书信息</li></ol><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150620406.png"></p><ol start="3"><li>点击继续保存到你要保存的位置</li></ol><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150620805.png"></p><h1 id="证书配置"><a href="#证书配置" class="headerlink" title="证书配置"></a>证书配置</h1><ol><li><code>Software</code> 下证书分类两种:</li></ol><ul><li><code>iOS App Development</code>： 为开发证书，用于真机测试。</li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150620578.jpg"></p><ul><li><code>iOS Distribution (App Store and Ad Hoc)</code>：为 <code>APP发布证书</code>，用于上架APP到 <code>APP Store</code> 或者 <code>Ad Hoc</code> 上传包到<code>蒲公英</code>。</li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150620164.png"></p><ol start="2"><li><code>Services</code> 下推送证书也分为两种：</li></ol><ul><li><p><code>Apple Push Notification service SSL (Sandbox)</code> ：开发环境下的推送证书</p></li><li><p><code>Apple Push Notification service SSL (Sandbox &amp; Production)</code>：生产环境的推送证书</p></li></ul><ol start="3"><li>开发证书<code>iOS App Development</code>的创建流程:</li></ol><ul><li>选中 <code>Software</code> 下的 <code>iOS App Development</code> 和 <code>Services</code> 下的 <code>Apple Push Notification service SSL (Sandbox)</code>，然后点击 <code>continue</code></li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150621531.png"></p><ul><li>来到 <code>Creat New Certificate</code> 页面，需要上传 <code>CSR</code> 文件</li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150621898.png"></p><p>由上图可知，上传证书签名请求，您需要Mac上的证书签名请求<code>（CSR）</code>文件，要手动生成证书。</p><ul><li>点击 <code>Choose file</code> 导入 <code>CSR</code> 文件</li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150621680.png"></p><ul><li>点击 <code>download</code> 并 <code>双击</code> 运行到项目中</li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150621696.jpg"></p><ol start="4"><li>接下来就是配置开发环境的 <code>推送证书</code></li></ol><ul><li>按序号操作，进入</li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150621400.png"></p><ul><li>找到 <code>Services</code> 点击 <code>Continue</code></li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150622250.png"></p><ul><li>按下面的序号依次操作</li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150622278.png"></p><ul><li>之后还是配置CSR文件</li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150622497.png"></p><ul><li>下载推送证书</li></ul><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150622695.png"></p><ol start="5"><li><p><code>生产环境证书</code> 和 <code>生产环境推送证书</code> 类似于 <code>开发环境</code>，就不一一介绍了</p></li><li><p>最后生产四种类型的证书</p></li></ol><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150622797.png"></p><h1 id="项目中使用"><a href="#项目中使用" class="headerlink" title="项目中使用"></a>项目中使用</h1><ol><li>项目中选择TARGET，添加一个账户 Add an Account:</li></ol><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150622984.png"></p><ol start="2"><li>输入你的 <code>Apple ID</code> 账号</li></ol><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150622229.png"></p><ol start="3"><li>发送给自己手机验证码</li></ol><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150623916.png"></p><ol start="4"><li>选中你添加的账号名</li></ol><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150623563.png"></p><ol start="5"><li>确保Bundle ID 和 你开发者账号上的一致</li></ol><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150623116.png"></p>]]></content>
      
      
      <categories>
          
          <category> iOS-开发者账号探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发者账号02：开发者账号发票修改抬头流程</title>
      <link href="/BboyZJ.github.io/2020/08/29/%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B/iOS%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B702%EF%BC%9A%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E5%8F%91%E7%A5%A8%E4%BF%AE%E6%94%B9%E6%8A%AC%E5%A4%B4%E6%B5%81%E7%A8%8B/"/>
      <url>/BboyZJ.github.io/2020/08/29/%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B/iOS%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B702%EF%BC%9A%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E5%8F%91%E7%A5%A8%E4%BF%AE%E6%94%B9%E6%8A%AC%E5%A4%B4%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于公司之前有人注册过开发者账号，但是已经很久很久没有用了，所以免去了我从头注册的麻烦，我只要用 <code>visa卡</code> 去续费就可以了</p><h1 id="发票填写错误处理流程"><a href="#发票填写错误处理流程" class="headerlink" title="发票填写错误处理流程"></a>发票填写错误处理流程</h1><ol><li>登录 <a href="https://developer.apple.com/cn">开发者网站</a>，点击 <code>Account</code></li></ol><p><img src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303150618842.png"></p><ol start="2"><li><p>登录账号，点击续费，具体流程很简单，按照提示走就行了，唯一需要注意的是，开发票，选择 <code>企业发票</code>，需要填写 <code>公司抬头</code> 和 <code>纳税人识别号</code>。我就是在这个地方把公司的抬头填写错的。</p></li><li><p>续费方法有两种：</p></li></ol><ul><li><code>APP内购</code> 续费：下载 <code>Developer</code>， 通过APP去付费</li><li><code>网页</code> 续费：一般订单号以 <code>W开头</code> 后加 <code>9位数字</code></li></ul><ol start="4"><li>如何解决 <code>发票</code> 问题：</li></ol><ul><li><p><code>APP内购买</code> 续费：通过 <code>开发者网站 -&gt; 联系我们 -&gt; 会员资格和账户 -&gt; 计划购买和续订 -&gt; 电话</code></p></li><li><p><code>网页</code> 续费：通过拨打 <code>400-666-8800</code> 按提示音 -&gt; 找到 <code>账户购买技术支持</code>，去解决，我是废了好长时间才弄明白，因为我的订单号是 <code>W</code> 开头的，不能走 <code>内购买</code> 流程。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS-开发者账号 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发者账号01：开发者账号介绍</title>
      <link href="/BboyZJ.github.io/2020/08/29/%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B/iOS%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B701%EF%BC%9A%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E4%BB%8B%E7%BB%8D/"/>
      <url>/BboyZJ.github.io/2020/08/29/%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B/iOS%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B701%EF%BC%9A%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="开发者账号"><a href="#开发者账号" class="headerlink" title="开发者账号"></a>开发者账号</h1><p>苹果开发者账号可分为三种类型：<code>个人、公司、企业</code>，且三者的费用以及权限等不尽相同。</p><ul><li><code>个人账号</code></li></ul><blockquote><p>费用：99 美元&#x2F;年<br>协作人数：仅限开发者自己<br>不需要填写公司的邓百氏编码（ D-U-N-S Number）<br>支持账号下的 <code>app</code> 上线 <code>App Store</code><br>需要创建 <code>Apple ID</code></p></blockquote><ul><li><code>公司账号</code></li></ul><blockquote><p>费用：99 美元&#x2F;年<br>允许多个开发者协作开发<br>需要填写公司的邓百氏编码（ D-U-N-S Number）<br>该账号下的 app 可上线至 App Store<br>需要创建 Apple ID</p></blockquote><ul><li><code>苹果企业开发者账号</code></li></ul><blockquote><p>费用：299 美元&#x2F;年<br>允许多个开发者协作开发<br>需要填写公司的邓百氏编码（ D-U-N-S Number）<br>该账号下的 app 不能发布到 App Store 中<br>需要创建 Apple ID</p></blockquote><h1 id="开发者账号付款方式"><a href="#开发者账号付款方式" class="headerlink" title="开发者账号付款方式"></a>开发者账号付款方式</h1><p>苹果公司只接受2种付款方式，一种就是 <code>VISA</code> 卡，另外一种是 <code>万事达卡（MasterCard）</code>，都可以在国内银行办理</p><ul><li>介于我本人去办理VISA卡的流成：</li></ul><blockquote><p>带着自己的身份证，知道公司地址、公司座机电话，这三个最主要，其他的根据银行办卡要求去填写。</p><p>办卡选择<code>中美双汇币VISA卡</code>，具体你去银行办理就知道了。</p></blockquote><h1 id="MasterCard-与-VISA-卡的区别有："><a href="#MasterCard-与-VISA-卡的区别有：" class="headerlink" title="MasterCard 与 VISA 卡的区别有："></a><code>MasterCard</code> 与 <code>VISA</code> 卡的区别有：</h1><ul><li><p>目前国际上有六大信用卡品牌，分别是 <code>威士国际组织（VISA International）</code> 及 <code>万事达卡国际组织（MasterCard International）</code> 两大组织及 <code>美国运通国际股份有限公司（America Express）</code>、<code>中国银联股份有限公司（China UnionPay Co.,Ltd.）</code>、<code>大来信用卡有限公司（Diners Club）</code>、<code>JCB日本国际信用卡公司（JCB）四家专业信用卡公司</code>。</p></li><li><p><code>VISA(威士卡</code>）、<code>Mastercard（万事达卡）</code>、<code>China UnionPay（银联卡）</code>在全球范围构建了一个刷卡消费的联盟，国内银行与他们合作以后，国内银行发行的信用卡就能在他们联盟范围内刷卡消费，在部分国家地区甚至可以持银联卡直接消费。你可以在申请信用卡的时候选择申请VISA(威士）信用卡还是Mastercard（万事达）信用卡。</p></li><li><p>就目前来讲两家国际组织在国内区别不大，区别比较大的是银联卡，选择哪一个完全可以凭自己的喜好。如果你经常在 <code>亚洲、澳大利亚旅游</code> 或者 <code>刷卡消费的话</code>，那么建议你选择 <code>VISA</code>，因为VISA在亚洲和澳大利亚受理的商户数量比较多，使用起来更方便。</p></li><li><p><code>Mastercard</code>的优势在于 <code>欧洲</code> 和 <code>北美</code>。经常去这欧洲和美洲的朋友可以选择 <code>Mastercard（万事达）</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS-开发者账号 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC数据结构02：二叉树探索</title>
      <link href="/BboyZJ.github.io/2020/08/26/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/26/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h1><p>树形结构，<code>两个节点</code> 以内均称为 <code>二叉树</code>，分为 <code>左子树</code> 和 <code>右子树</code>，有顺序，不能颠倒；比如把人看做树：头是树根，左右是坐子树，右手是右子树。</p><h1 id="二叉树遍历类型"><a href="#二叉树遍历类型" class="headerlink" title="二叉树遍历类型"></a>二叉树遍历类型</h1><ol><li>深度优先遍历：<code>采用栈</code></li></ol><ul><li>先序遍历：对任一子树，先访问根，然后遍历左子树，最后遍历其右子树</li><li>中序遍历：对任一子树，先遍历左子树，然后访问根，最后遍历其右子树</li><li>后序遍历：对任一子树，先遍历其左子树，然后遍历其右子树，最后访问根</li></ul><ol start="2"><li>广度优先遍历：<code>采用队列</code></li></ol><p>层次遍历，<code>从上往下</code> 对每一层依次访问，每一层从 <code>左往右（或从右往左）访问节点</code>，访问完一层就进入下一层，直到没有节点可以访问为止。</p><ol start="3"><li>区别：</li></ol><ul><li><p>深度优先算法：不全部保留节点，占用空间小，有回溯操作，<code>运行速度慢</code>，<code>用时间换空间</code></p></li><li><p>广度优先算法：保留全部节点，占用空间大，无回溯操作，<code>运行速度快</code>，<code>用空间换时间</code></p></li></ul><h1 id="二叉排序树的好处？"><a href="#二叉排序树的好处？" class="headerlink" title="二叉排序树的好处？"></a>二叉排序树的好处？</h1><p>二叉树是一种比较折中的方案；数组的搜索比较方便，可以直接用下标，但删除或插入比较耗时；<br>链表与之相反，删除或插入很快，但查找很慢；二叉排序树既有链表的好处，也有数组的好处，在处理大批量的动态数据是比较有用的</p><h1 id="二叉排序树节点定义"><a href="#二叉排序树节点定义" class="headerlink" title="二叉排序树节点定义"></a>二叉排序树节点定义</h1><p>采用单项链表的形式，只从根节点指向孩子节点，不保存父节点。</p><p>对于二叉搜索树这种数据类型，用简单的数组来表示是不适合的。所以要建立一个模型：</p><ul><li>值：就用最简单的整数来表示，实际使用中，这个整型值也是必不可少的，可以当做key来用，这是二叉搜索树排序的凭证。</li><li>左子树：用一个同类型的指针表示</li><li>右子树：用一个同类型的指针表示</li></ul><p>以上3个是二叉搜索树必不可少的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 二叉排序树节点</span><br><span class="line">@interface BinaryTreeNode : NSObject</span><br><span class="line">// 值</span><br><span class="line">@property (nonatomic, assign) NSInteger value;</span><br><span class="line">// 左节点</span><br><span class="line">@property (nonatomic, strong) BinaryTreeNode *leftNode;</span><br><span class="line">// 右节点</span><br><span class="line">@property (nonatomic, strong) BinaryTreeNode *rightNode;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h1 id="如何验证两个二叉树是完全相等的？"><a href="#如何验证两个二叉树是完全相等的？" class="headerlink" title="如何验证两个二叉树是完全相等的？"></a>如何验证两个二叉树是完全相等的？</h1><p><code>递归</code> 去判断每个节点的 <code>值</code> 是否相等，如果均相等，则两个二叉树完全相等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)isSameTree:(TreeNode *)root1 tree:(TreeNode *)root2&#123;</span><br><span class="line">   if (root1 == null &amp;&amp; root2 == null) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">if ((root1 == null &amp;&amp; root2 != null) || (root1 != null &amp;&amp; root2 == null))&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if (root1.val != root2.val) &#123; // 判断每个节点的值是否相等，如果去除此判断，则判断两个二叉树是否结构相等</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return [self isSameTree:root1.left tree:root2.left] &amp;&amp; [self isSameTree:root1.right tree:root2.right];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建二叉排序树"><a href="#创建二叉排序树" class="headerlink" title="创建二叉排序树"></a>创建二叉排序树</h1><ol><li>二叉树中左右节点值本身没有大小之分，所以如果要创建二叉树，就需要考虑如何处理某个节点是左节点还是右节点，如何终止某个子树而切换到另一个子树。 因此我选择了 <code>二叉排序树</code>，二叉排序树中对于左右节点有明确的要求，程序可以自动根据键值大小自动选择是左节点还是右节点。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  创建二叉排序树</span><br><span class="line"> *  二叉排序树：左节点值全部小于根节点值，右节点值全部大于根节点值</span><br><span class="line"> *  @param values 数组</span><br><span class="line"> *  @return 二叉树根节点</span><br><span class="line"> */</span><br><span class="line">+ (BinaryTreeNode *)createTreeWithValues:(NSArray *)values &#123;</span><br><span class="line">    BinaryTreeNode *root = nil;</span><br><span class="line">    for (NSInteger i=0; i&lt;values.count; i++) &#123;</span><br><span class="line">        NSInteger value = [(NSNumber *)[values objectAtIndex:i] integerValue];</span><br><span class="line">        root = [BinaryTree addTreeNode:root value:value];</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  向二叉排序树节点添加一个节点</span><br><span class="line"> *</span><br><span class="line"> *  @param treeNode 根节点</span><br><span class="line"> *  @param value    值</span><br><span class="line"> *</span><br><span class="line"> *  @return 根节点</span><br><span class="line"> */</span><br><span class="line">+ (BinaryTreeNode *)addTreeNode:(BinaryTreeNode *)treeNode value:(NSInteger)value &#123;</span><br><span class="line">    //根节点不存在，创建节点</span><br><span class="line">    if (!treeNode) &#123;</span><br><span class="line">        treeNode = [BinaryTreeNode new];</span><br><span class="line">        treeNode.value = value;</span><br><span class="line">        NSLog(@&quot;node:%@&quot;, @(value));</span><br><span class="line">    &#125;</span><br><span class="line">    else if (value &lt;= treeNode.value) &#123;</span><br><span class="line">        NSLog(@&quot;to left&quot;);</span><br><span class="line">        // 值小于根节点，则插入到左子树</span><br><span class="line">        treeNode.leftNode = [BinaryTree addTreeNode:treeNode.leftNode value:value];</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        NSLog(@&quot;to right&quot;);</span><br><span class="line">        // 值大于根节点，则插入到右子树</span><br><span class="line">        treeNode.rightNode = [BinaryTree addTreeNode:treeNode.rightNode value:value];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return treeNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>实际使用</li></ol><p>1）创建一个二叉树类BinaryTreeNode，在类中实现如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface BinaryTreeNode : NSObject</span><br><span class="line">// 值：当做key来用，是排序用的凭证</span><br><span class="line">@property (nonatomic,assign)NSInteger value;</span><br><span class="line">// 左子树</span><br><span class="line">@property (nonatomic,strong)BinaryTreeNode * leftChild;</span><br><span class="line">// 右子树</span><br><span class="line">@property (nonatomic,strong)BinaryTreeNode * rightChild;</span><br><span class="line"></span><br><span class="line">// 创建二叉排序树</span><br><span class="line">+ (BinaryTreeNode *)createBinaryTreeWithValues:(NSArray *)values;</span><br><span class="line">// 向二叉排序树中添加一个节点</span><br><span class="line">+ (BinaryTreeNode *)addNode:(BinaryTreeNode *)rootNode value:(NSInteger)value;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 创建二叉排序树</span><br><span class="line"> 二叉排序树：左节点值全部小于根节点值，右节点值全部大于根节点值</span><br><span class="line"> @param values：数组</span><br><span class="line"> @return 二叉排序树根节点</span><br><span class="line"> */</span><br><span class="line">+ (BinaryTreeNode *)createBinaryTreeWithValues:(NSArray *)values&#123;</span><br><span class="line">    BinaryTreeNode * rootNode = nil;</span><br><span class="line">    for (NSNumber * number in values) &#123;</span><br><span class="line">        NSInteger value = [number integerValue];</span><br><span class="line">        rootNode = [BinaryTreeNode addNode:rootNode value:value];</span><br><span class="line">    &#125;</span><br><span class="line">    return rootNode;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> 向二叉排序树节点添加一个节点</span><br><span class="line"> @param rootNode 根节点</span><br><span class="line"> @param value    值</span><br><span class="line"> </span><br><span class="line"> @return 根节点</span><br><span class="line"> */</span><br><span class="line">+ (BinaryTreeNode *)addNode:(BinaryTreeNode *)rootNode value:(NSInteger)value&#123;</span><br><span class="line">    // 根节点不存在，创建节点</span><br><span class="line">    if (rootNode == nil) &#123;</span><br><span class="line">        rootNode = [[BinaryTreeNode alloc] init];</span><br><span class="line">        rootNode.value = value;</span><br><span class="line">        NSLog(@&quot;node:%@&quot;,@(value));</span><br><span class="line">    &#125;else if (value &lt;= rootNode.value) &#123;</span><br><span class="line">        NSLog(@&quot;to left&quot;);</span><br><span class="line">        // 值小于根节点，则插入到左子树；这是递归，左子树将做同样的事儿</span><br><span class="line">        rootNode.leftChild = [self addNode:rootNode.leftChild value:value];</span><br><span class="line">    &#125;else if (value &gt; rootNode.value) &#123;</span><br><span class="line">        NSLog(@&quot;to right&quot;);</span><br><span class="line">        // 值大于根节点，则插入到右子树；这是递归，右子树将做同样的事儿</span><br><span class="line">        rootNode.rightChild = [self addNode:rootNode.rightChild value:value];</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        NSLog(@&quot;二叉排序树没有键值相等的节点，值%@已存在，不能插入&quot;,@(value));</span><br><span class="line">    &#125;</span><br><span class="line">    return rootNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）在controller中，用一个属性持有这个二叉搜索树。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">//二叉树</span><br><span class="line">#import &quot;BinaryTreeNode.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">// 二叉搜索树的根节点，代表一棵树</span><br><span class="line">@property (strong, nonatomic) BinaryTreeNode *rootNode;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>输入用一串值，得到一颗二叉搜索树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //创建一个二叉树</span><br><span class="line">    NSArray *values = @[@200, @23, @456, @89, @23, @670, @5674, @15];</span><br><span class="line">    self.rootNode = [BinaryTreeNode createBinaryTreeWithValues:values];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）用断点，查看“链式”结构，同时通过log可以看出创建过程。</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061815766.png"></p><p>4）生成的二叉树图</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061815334.png"></p><h1 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h1><ol><li>先访问根，再遍历左子树，再遍历右子树。典型的递归思想。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  先序遍历</span><br><span class="line"> *  先访问根，再遍历左子树，再遍历右子树</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *  @param handler  访问节点处理函数</span><br><span class="line"> */</span><br><span class="line">+ (void)preOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123;</span><br><span class="line">    if (rootNode) &#123; // 先根</span><br><span class="line">        if (handler) &#123;</span><br><span class="line">            handler(rootNode);</span><br><span class="line">        &#125;</span><br><span class="line">        // 再左</span><br><span class="line">        [self preOrderTraverseTree:rootNode.leftNode handler:handler];</span><br><span class="line">        // 最后右</span><br><span class="line">        [self preOrderTraverseTree:rootNode.rightNode handler:handler];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>实际使用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 先序遍历</span><br><span class="line">- (void)preOrderTraverse&#123;</span><br><span class="line">    NSMutableArray * preArr = [NSMutableArray array];</span><br><span class="line">    [BinaryTreeNode preOrderTraverseTree:self.rootNode handler:^(BinaryTreeNode * _Nonnull treeNode) &#123;</span><br><span class="line">        [preArr addObject:[NSNumber numberWithInteger:treeNode.value]];</span><br><span class="line">    &#125;];</span><br><span class="line">    NSLog(@&quot;先序遍历：%@&quot;, preArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2020-08-26 22:45:09.310234+0800 OC-二叉树[50561:2829401] 先序遍历：(</span><br><span class="line">    200,</span><br><span class="line">    23,</span><br><span class="line">    15,</span><br><span class="line">    89,</span><br><span class="line">    456,</span><br><span class="line">    670,</span><br><span class="line">    5674</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><ol><li>先遍历左子树，再访问根，再遍历右子树。<br>对于二叉排序树来说，中序遍历得到的序列是一个从小到大排序好的序列。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  中序遍历</span><br><span class="line"> *  先遍历左子树，再访问根，再遍历右子树</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *  @param handler  访问节点处理函数</span><br><span class="line"> */</span><br><span class="line">+ (void)inOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123;</span><br><span class="line">    if (rootNode) &#123;</span><br><span class="line">        [self inOrderTraverseTree:rootNode.leftNode handler:handler];</span><br><span class="line">        if (handler) &#123;</span><br><span class="line">            handler(rootNode);</span><br><span class="line">        &#125;</span><br><span class="line">        [self inOrderTraverseTree:rootNode.rightNode handler:handler];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>实际使用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//中序遍历</span><br><span class="line">- (void)inOrderTraverse&#123;</span><br><span class="line">    NSMutableArray * inArr = [NSMutableArray array];</span><br><span class="line">    [BinaryTreeNode inOrderTraverseTree:self.rootNode handler:^(BinaryTreeNode * _Nonnull treeNode) &#123;</span><br><span class="line">        [inArr addObject:[NSNumber numberWithInteger:treeNode.value]];</span><br><span class="line">    &#125;];</span><br><span class="line">    NSLog(@&quot;中序遍历：%@&quot;, inArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2020-08-26 22:49:26.310344+0800 OC-二叉树[50591:2832806] 中序遍历：(</span><br><span class="line">    15,</span><br><span class="line">    23,</span><br><span class="line">    89,</span><br><span class="line">    200,</span><br><span class="line">    456,</span><br><span class="line">    670,</span><br><span class="line">    5674</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h1><ol><li>先遍历左子树，再遍历右子树，再访问根</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  后序遍历</span><br><span class="line"> *  先遍历左子树，再遍历右子树，再访问根</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *  @param handler  访问节点处理函数</span><br><span class="line"> */</span><br><span class="line">+ (void)afterOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler &#123;</span><br><span class="line">    if (rootNode) &#123;</span><br><span class="line">        [self afterOrderTraverseTree:rootNode.leftNode handler:handler];</span><br><span class="line">        [self afterOrderTraverseTree:rootNode.rightNode handler:handler];</span><br><span class="line">        if (handler) &#123;</span><br><span class="line">            handler(rootNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>实际使用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//后序遍历</span><br><span class="line">- (void)afterOrderTraverse&#123;</span><br><span class="line">    NSMutableArray * afterArr = [NSMutableArray array];</span><br><span class="line">    [BinaryTreeNode afterOrderTraverseTree:self.rootNode handler:^(BinaryTreeNode * _Nonnull treeNode) &#123;</span><br><span class="line">        [afterArr addObject:[NSNumber numberWithInteger:treeNode.value]];</span><br><span class="line">    &#125;];</span><br><span class="line">    NSLog(@&quot;后序遍历：%@&quot;, afterArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2020-08-26 22:51:50.637367+0800 OC-二叉树[50628:2835309] 后序遍历：(</span><br><span class="line">    15,</span><br><span class="line">    89,</span><br><span class="line">    23,</span><br><span class="line">    5674,</span><br><span class="line">    670,</span><br><span class="line">    456,</span><br><span class="line">    200</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><ol><li>你会翻转二叉树吗？如果不会，那对不起，我们不会录用你！</li></ol><p>翻转二叉树，又叫求二叉树的镜像，就是把二叉树的左右子树对调（当然是递归的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 翻转二叉树（又叫：二叉树的镜像）</span><br><span class="line"> @param rootNode 根节点</span><br><span class="line"> @return 翻转后的树根节点（其实就是原二叉树的根节点）</span><br><span class="line"> */</span><br><span class="line">// 翻转二叉树</span><br><span class="line">+ (BinaryTreeNode *)flipBinaryTree:(BinaryTreeNode *)rootNode&#123;</span><br><span class="line">    // 判空</span><br><span class="line">    if(!rootNode)&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 没有子节点</span><br><span class="line">    if(!rootNode.leftNode &amp;&amp; !rootNode.rightNode)&#123;</span><br><span class="line">        return rootNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 左右子树递归</span><br><span class="line">    [self flipBinaryTree:rootNode.leftNode];</span><br><span class="line">    [self flipBinaryTree:rootNode.rightNode];</span><br><span class="line">    </span><br><span class="line">    // 左右节点交换</span><br><span class="line">    BinaryTreeNode * tempNode = rootNode.leftNode;</span><br><span class="line">    rootNode.leftNode = rootNode.rightNode;</span><br><span class="line">    rootNode.rightNode = tempNode.leftNode;</span><br><span class="line">    </span><br><span class="line">    return rootNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>实际使用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 翻转二叉树</span><br><span class="line">- (void)invertBinaryTree&#123;</span><br><span class="line">    self.rootNode = [BinaryTreeNode invertBinaryTree:self.rootNode];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看打印结果</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061815476.png"></p><p>生成二叉树的图</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061815862.png"></p><h1 id="查找二叉树中某个位置的结点"><a href="#查找二叉树中某个位置的结点" class="headerlink" title="查找二叉树中某个位置的结点"></a>查找二叉树中某个位置的结点</h1><p>类似索引操作，按 <code>层次</code> 遍历，位置从0开始算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 查找二叉树某个位置的结点</span><br><span class="line"> @param index 按层次便利树是的位置（从0开始）</span><br><span class="line"> @param rootNode 树根结点</span><br><span class="line"> @return 结点</span><br><span class="line"> */</span><br><span class="line">// 指定位置查找节点</span><br><span class="line">+ (BinaryTreeNode *)findTreeNodeAtIndex:(int)index withRootTree:(BinaryTreeNode *)rootNode&#123;</span><br><span class="line">    // 如果节点不存在，查找位置不符合规范</span><br><span class="line">    if (!rootNode || index &lt; 0)&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray * queueArr = [NSMutableArray arrayWithCapacity:0];</span><br><span class="line">    // 压入根节点</span><br><span class="line">    [queueArr addObject:rootNode];</span><br><span class="line">    while (queueArr.count &gt; 0) &#123;</span><br><span class="line">        BinaryTreeNode * node = [queueArr firstObject];</span><br><span class="line">        // 如果是根节点，则直接返回</span><br><span class="line">        if(index == 0)&#123;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        // 仿照队列先进先出FIFO，移除最前面的节点</span><br><span class="line">        [queueArr removeObjectAtIndex:0];</span><br><span class="line">        index --;</span><br><span class="line">        </span><br><span class="line">        // 按照从左往右依次压入节点</span><br><span class="line">        if(node.leftNode)&#123;</span><br><span class="line">            [queueArr addObject:node.leftNode];</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.rightNode)&#123;</span><br><span class="line">            [queueArr addObject:node.rightNode];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 遍历完，还没有找到位置，返回nil</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在controller中调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 查找某个位置的节点</span><br><span class="line">- (void)searchNode&#123;</span><br><span class="line">    BinaryTreeNode * node = [BinaryTreeNode findTreeNodeAtIndex:4 withTree:self.rootNode];</span><br><span class="line">    NSLog(@&quot;node-------%@&quot;,[NSNumber numberWithInteger:node.value]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">********打印结果******</span><br><span class="line">2020-08-27 11:29:47.724120+0800 OC-二叉树[51450:2892148] node-------89</span><br></pre></td></tr></table></figure><h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h1><ol><li><p>按照从上到下、从左到右的次序进行遍历。先遍历完一层，再遍历下一层，因此又叫广度优先遍历。需要用到队列，在OC里可以用可变数组来实现。</p><p>根改了：NSArray *values &#x3D; @[@100, @23, @45, @89, @23, @67, @54, @15];</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">层次遍历（广度优先）</span><br><span class="line"></span><br><span class="line">@param rootNode 树根节点</span><br><span class="line">@param handler 访问节点处理函数</span><br><span class="line">*/</span><br><span class="line">// 层次遍历</span><br><span class="line">+ (void)levelTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *))handler&#123;</span><br><span class="line">    // 空节点</span><br><span class="line">    if(!rootNode)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 数组当成队列</span><br><span class="line">    NSMutableArray * queueArr = [NSMutableArray array];</span><br><span class="line">    // 压入根节点</span><br><span class="line">    [queueArr addObject:rootNode];</span><br><span class="line">    // 当队列有数据的时候去遍历</span><br><span class="line">    while (queueArr.count &gt; 0) &#123;</span><br><span class="line">        BinaryTreeNode * node = [queueArr firstObject];</span><br><span class="line">        if (handler)&#123;</span><br><span class="line">            handler(node);</span><br><span class="line">        &#125;</span><br><span class="line">        // 仿照队列先进先出FIFO，移除最前面的节点</span><br><span class="line">        [queueArr removeObjectAtIndex:0];</span><br><span class="line">        </span><br><span class="line">        // 按照从左往右依次压入节点</span><br><span class="line">        if(node.leftNode)&#123;</span><br><span class="line">            [queueArr addObject:node.leftNode];</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.rightNode)&#123;</span><br><span class="line">            [queueArr addObject:node.rightNode];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>在controller中调用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//层次遍历</span><br><span class="line">- (void)levelTraverse&#123;</span><br><span class="line">    NSMutableArray * levelArr = [NSMutableArray array];</span><br><span class="line">    [BinaryTreeNode levelTraverseTree:self.rootNode handler:^(BinaryTreeNode * _Nonnull treeNode) &#123;</span><br><span class="line">        NSLog(@&quot;value:%ld&quot;,treeNode.value);</span><br><span class="line">        [levelArr addObject:treeNode];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>次遍历：查看打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2020-08-31 17:18:50.185983+0800 OC-二叉树[59736:4179500] value:100</span><br><span class="line">2020-08-31 17:18:50.186414+0800 OC-二叉树[59736:4179500] value:23</span><br><span class="line">2020-08-31 17:18:50.186896+0800 OC-二叉树[59736:4179500] value:15</span><br><span class="line">2020-08-31 17:18:50.187158+0800 OC-二叉树[59736:4179500] value:45</span><br><span class="line">2020-08-31 17:18:50.187479+0800 OC-二叉树[59736:4179500] value:89</span><br><span class="line">2020-08-31 17:18:50.187753+0800 OC-二叉树[59736:4179500] value:67</span><br><span class="line">2020-08-31 17:18:50.188040+0800 OC-二叉树[59736:4179500] value:54</span><br></pre></td></tr></table></figure><h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><ol><li>二叉树的深度定义为：从根节点到叶子结点依次经过的结点形成树的一条路径,最长路径的长度为树的深度。<br>1）如果根节点为空，则深度为0；<br>2）如果左右节点都是空，则深度为1；<br>3）递归思想：二叉树的深度&#x3D;max（左子树的深度，右子树的深度）+ 1</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 二叉树的深度</span><br><span class="line"> @param rootNode 二叉树根节点</span><br><span class="line"> @return 二叉树的深度</span><br><span class="line"> */</span><br><span class="line">// 二叉树的深度</span><br><span class="line">+ (NSInteger)depthOfTree:(BinaryTreeNode *)rootNode&#123;</span><br><span class="line">    if (!rootNode)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 左子树深度</span><br><span class="line">    NSInteger leftDepth = [self depthOfTree:rootNode.leftNode];</span><br><span class="line">    // 右子树深度</span><br><span class="line">    NSInteger rightDepth = [self depthOfTree:rootNode.rightNode];</span><br><span class="line">    // 二叉树深度</span><br><span class="line">    NSInteger totalDepth = MAX(leftDepth, rightDepth) + 1;</span><br><span class="line">    </span><br><span class="line">    return totalDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在controller中调用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//树的深度</span><br><span class="line">- (void)depthTree&#123;</span><br><span class="line">    NSInteger depth = [BinaryTreeNode depthOfTree:self.rootNode];</span><br><span class="line">    NSLog(@&quot;depth:%ld&quot;,depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-08-31 17:29:49.989752+0800 OC-二叉树[59816:4186549] depth:6</span><br></pre></td></tr></table></figure><h1 id="二叉树的宽度"><a href="#二叉树的宽度" class="headerlink" title="二叉树的宽度"></a>二叉树的宽度</h1><p>二叉树的 <code>宽度</code> 定义为各层节点数的最大值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树的宽度</span><br><span class="line"> *  @param rootNode 二叉树根节点</span><br><span class="line"> *  @return 二叉树宽度</span><br><span class="line"> */</span><br><span class="line">+ (NSInteger)widthOfTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray * queueArray = [NSMutableArray array]; </span><br><span class="line">    [queueArray addObject:rootNode]; // 压入根节点</span><br><span class="line">    NSInteger maxWidth = 1; // 最大的宽度，初始化为1（因为已经有根节点）</span><br><span class="line">    NSInteger curWidth = 0; // 当前层的宽度</span><br><span class="line">    </span><br><span class="line">    while (queueArray.count &gt; 0) &#123;</span><br><span class="line">        curWidth = queueArray.count;</span><br><span class="line">        //依次弹出当前层的节点</span><br><span class="line">        for (NSInteger i=0; i&lt;curWidth; i++) &#123;</span><br><span class="line">            BinaryTreeNode * node = [queueArray firstObject];</span><br><span class="line">             // 弹出最前面的节点，仿照队列先进先出原则</span><br><span class="line">            [queueArray removeObjectAtIndex:0];</span><br><span class="line">            // 压入左子数</span><br><span class="line">            if (node.leftNode) &#123;</span><br><span class="line">                [queueArray addObject:node.leftNode];</span><br><span class="line">            &#125;</span><br><span class="line">            // 压入右子树</span><br><span class="line">            if (node.rightNode) &#123;</span><br><span class="line">                [queueArray addObject:node.rightNode];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 宽度 = 当前层节点数</span><br><span class="line">        maxWidth = MAX(maxWidth, queueArray.count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return maxWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vc实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 二叉树宽度</span><br><span class="line">NSInteger width = [BinaryTreeNode widthOfTree:self.rootNode];</span><br><span class="line">NSLog(@&quot;width-%ld&quot;,width);</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-26 16:21:36.767352+0800 二叉树[4523:170689] width-2</span><br></pre></td></tr></table></figure><h1 id="二叉树的所有节点数"><a href="#二叉树的所有节点数" class="headerlink" title="二叉树的所有节点数"></a>二叉树的所有节点数</h1><p>递归思想：二叉树所有节点数 &#x3D; 左子树节点数 + 右子树节点数 + 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树的所有节点数</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 所有节点数</span><br><span class="line"> */</span><br><span class="line">// 二叉树所有节点数</span><br><span class="line">+ (NSInteger)numberOfNodesInTree:(BinaryTreeNode *)rootNode&#123;</span><br><span class="line">    if (!rootNode)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 总节点数 = 左子树节点数 + 右子树节点数 + 1</span><br><span class="line">    NSInteger totalNode = [self numberOfNodesInTree:rootNode.leftNode] + [self numberOfNodesInTree:rootNode.rightNode] + 1;</span><br><span class="line">    </span><br><span class="line">    return totalNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vc实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 二叉树节点数</span><br><span class="line">NSInteger totalNode = [BinaryTreeNode numberOfNodesInTree:self.rootNode];</span><br><span class="line">NSLog(@&quot;totalNode-%ld&quot;,totalNode);</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-26 16:10:38.371816+0800 二叉树[4369:160462] totalNode-5</span><br></pre></td></tr></table></figure><h1 id="二叉树某层中的节点数"><a href="#二叉树某层中的节点数" class="headerlink" title="二叉树某层中的节点数"></a>二叉树某层中的节点数</h1><p>1）根节点为空，则节点数为0；</p><p>2）层为1，则节点数为1（即根节点）</p><p>3）递归思想：二叉树第k层节点数 &#x3D; 左子树第k-1层节点数 + 右子树第k-1层节点数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树某层中的节点数</span><br><span class="line"> *</span><br><span class="line"> *  @param level    层</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 层中的节点数</span><br><span class="line"> */</span><br><span class="line">// 二叉树某层中的节点数</span><br><span class="line">+ (NSInteger)numberOfNodesOnLevel:(NSInteger)level inTree:(BinaryTreeNode *)rootNode&#123;</span><br><span class="line">    // 根节点不存在 或 level &lt; 0</span><br><span class="line">    if (!rootNode || level &lt; 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // level = 1，返回1（根节点）</span><br><span class="line">        if (level == 1) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 递归：level层节点数 = 左子树level-1层节点数 + 右子树level-1层节点数</span><br><span class="line">        NSInteger levelNode = [self numberOfNodesOnLevel:level-1 inTree:rootNode.leftNode] + [self numberOfNodesOnLevel:level-1 inTree:rootNode.rightNode];</span><br><span class="line">        return levelNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vc实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 某层节点数</span><br><span class="line">NSInteger levelNode = [BinaryTreeNode numberOfNodesOnLevel:1 inTree:self.rootNode];</span><br><span class="line">NSLog(@&quot;levelNode-%ld&quot;,levelNode);</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-26 16:27:02.360866+0800 二叉树[4593:175705] levelNode-1</span><br></pre></td></tr></table></figure><h1 id="二叉树叶子节点数"><a href="#二叉树叶子节点数" class="headerlink" title="二叉树叶子节点数"></a>二叉树叶子节点数</h1><p>叶子节点，又叫终端节点，是左右子树都是空的节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树叶子节点数</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 叶子节点数</span><br><span class="line"> */</span><br><span class="line">+ (NSInteger)numberOfLeafsInTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 左子树和右子树都是空，说明是叶子节点</span><br><span class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归：叶子数 = 左子树叶子数 + 右子树叶子数</span><br><span class="line">    return [self numberOfLeafsInTree:rootNode.leftNode] + [self numberOfLeafsInTree:rootNode.rightNode];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树最大距离（二叉树的直径）"><a href="#二叉树最大距离（二叉树的直径）" class="headerlink" title="二叉树最大距离（二叉树的直径）"></a>二叉树最大距离（二叉树的直径）</h1><p>二叉树中任意两个节点都有且仅有一条路径，这个路径的长度叫这两个节点的距离。二叉树中所有节点之间的距离的最大值就是二叉树的直径。</p><p>有一种解法，把这个最大距离划分了3种情况：</p><p>1）这2个节点分别在根节点的左子树和右子树上，他们之间的路径肯定经过根节点，而且他们肯定是根节点左右子树上最远的叶子节点（他们到根节点的距离&#x3D;左右子树的深度）。</p><p>2）这2个节点都在左子树上</p><p>3）这2个节点都在右子树上</p><p>综上，只要取这3种情况中的最大值，就是二叉树的直径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树最大距离（直径）</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 最大距离</span><br><span class="line"> */</span><br><span class="line">+ (NSInteger)maxDistanceOfTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">//    方案一：（递归次数较多，效率较低）</span><br><span class="line">    //分3种情况：</span><br><span class="line">    //1、最远距离经过根节点：距离 = 左子树深度 + 右子树深度</span><br><span class="line">    NSInteger distance = [self depthOfTree:rootNode.leftNode] + [self depthOfTree:rootNode.rightNode];</span><br><span class="line">    //2、最远距离在根节点左子树上，即计算左子树最远距离</span><br><span class="line">    NSInteger disLeft = [self maxDistanceOfTree:rootNode.leftNode];</span><br><span class="line">    //3、最远距离在根节点右子树上，即计算右子树最远距离</span><br><span class="line">    NSInteger disRight = [self maxDistanceOfTree:rootNode.rightNode];</span><br><span class="line">    </span><br><span class="line">    return MAX(MAX(disLeft, disRight), distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方案效率较低，因为计算子树的深度和最远距离是分开递归的，存在重复递归遍历的情况。其实一次递归，就可以分别计算出深度和最远距离，于是有了第二种方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树最大距离（直径）</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 最大距离</span><br><span class="line"> */</span><br><span class="line">+ (NSInteger)maxDistanceOfTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">// 方案2：将计算节点深度和最大距离放到一次递归中计算，方案一是分别单独递归计算深度和最远距离</span><br><span class="line">    TreeNodeProperty *p = [self propertyOfTreeNode:rootNode];</span><br><span class="line">    return p.distance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  计算树节点的最大深度和最大距离</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return TreeNodeProperty</span><br><span class="line"> */</span><br><span class="line">+ (TreeNodeProperty *)propertyOfTreeNode:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    </span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNodeProperty *left = [self propertyOfTreeNode:rootNode.leftNode];</span><br><span class="line">    TreeNodeProperty *right = [self propertyOfTreeNode:rootNode.rightNode];</span><br><span class="line">    TreeNodeProperty *p = [TreeNodeProperty new];</span><br><span class="line">    //节点的深度depth = 左子树深度、右子树深度中最大值+1（+1是因为根节点占了1个depth）</span><br><span class="line">    p.depth = MAX(left.depth, right.depth) + 1;</span><br><span class="line">    //最远距离 = 左子树最远距离、右子树最远距离和横跨左右子树最远距离中最大值</span><br><span class="line">    p.distance = MAX(MAX(left.distance, right.distance), left.depth+right.depth);</span><br><span class="line">    </span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树中某个节点到根节点的路径"><a href="#二叉树中某个节点到根节点的路径" class="headerlink" title="二叉树中某个节点到根节点的路径"></a>二叉树中某个节点到根节点的路径</h1><p>既是寻路问题，又是查找节点问题。</p><p>定义一个存放路径的栈（不是队列了，但是还是用可变数组来实现的）</p><p>1）压入根节点，再从左子树中查找（递归进行的），如果未找到，再从右子树中查找，如果也未找到，则弹出根节点，再遍历栈中上一个节点。</p><p>2）如果找到，则栈中存放的节点就是路径所经过的节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树中某个节点到根节点的路径</span><br><span class="line"> *</span><br><span class="line"> *  @param treeNode 节点</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 存放路径节点的数组</span><br><span class="line"> */</span><br><span class="line">+ (NSArray *)pathOfTreeNode:(BinaryTreeNode *)treeNode inTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    NSMutableArray *pathArray = [NSMutableArray array];</span><br><span class="line">    [self isFoundTreeNode:treeNode inTree:rootNode routePath:pathArray];</span><br><span class="line">    return pathArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  查找某个节点是否在树中</span><br><span class="line"> *</span><br><span class="line"> *  @param treeNode 待查找的节点</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *  @param path  根节点到待查找节点的路径</span><br><span class="line"> *</span><br><span class="line"> *  @return YES：找到，NO：未找到</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)isFoundTreeNode:(BinaryTreeNode *)treeNode inTree:(BinaryTreeNode *)rootNode routePath:(NSMutableArray *)path &#123;</span><br><span class="line">    </span><br><span class="line">    if (!rootNode || !treeNode) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //找到节点</span><br><span class="line">    if (rootNode == treeNode) &#123;</span><br><span class="line">        [path addObject:rootNode];</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    //压入根节点，进行递归</span><br><span class="line">    [path addObject:rootNode];</span><br><span class="line">    //先从左子树中查找</span><br><span class="line">    BOOL find = [self isFoundTreeNode:treeNode inTree:rootNode.leftNode routePath:path];</span><br><span class="line">    //未找到，再从右子树查找</span><br><span class="line">    if (!find) &#123;</span><br><span class="line">        find = [self isFoundTreeNode:treeNode inTree:rootNode.rightNode routePath:path];</span><br><span class="line">    &#125;</span><br><span class="line">    //如果2边都没查找到，则弹出此根节点</span><br><span class="line">    if (!find) &#123;</span><br><span class="line">        [path removeLastObject];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return find;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树中两个节点最近的公共父节点"><a href="#二叉树中两个节点最近的公共父节点" class="headerlink" title="二叉树中两个节点最近的公共父节点"></a>二叉树中两个节点最近的公共父节点</h1><p>首先需要明白，根节点肯定是二叉树中任意两个节点的公共父节点（不一定是最近的），因此二叉树中2个节点的最近公共父节点一定在从根节点到这个节点的路径上。因此我们可以先分别找到从根节点到这2个节点的路径，再从这两个路径中找到最近的公共父节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树中两个节点最近的公共父节点</span><br><span class="line"> *</span><br><span class="line"> *  @param nodeA    第一个节点</span><br><span class="line"> *  @param nodeB    第二个节点</span><br><span class="line"> *  @param rootNode 二叉树根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 最近的公共父节点</span><br><span class="line"> */</span><br><span class="line">+ (BinaryTreeNode *)parentOfNode:(BinaryTreeNode *)nodeA andNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode || !nodeA || !nodeB) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nodeA == nodeB) &#123;</span><br><span class="line">        return nodeA;</span><br><span class="line">    &#125;</span><br><span class="line">    //从根节点到节点A的路径</span><br><span class="line">    NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode];</span><br><span class="line">    //从根节点到节点B的路径</span><br><span class="line">    NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode];</span><br><span class="line">    //其中一个节点不在树中，则没有公共父节点</span><br><span class="line">    if (pathA.count == 0 || pathB == 0) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //从后往前推，查找第一个出现的公共节点</span><br><span class="line">    for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123;</span><br><span class="line">        for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123;</span><br><span class="line">            if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123;</span><br><span class="line">                //找到</span><br><span class="line">                return [pathA objectAtIndex:i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树中两个节点之间的路径"><a href="#二叉树中两个节点之间的路径" class="headerlink" title="二叉树中两个节点之间的路径"></a>二叉树中两个节点之间的路径</h1><p>从查找最近公共父节点衍生出来的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树中两个节点之间的路径</span><br><span class="line"> *</span><br><span class="line"> *  @param nodeA    第一个节点</span><br><span class="line"> *  @param nodeB    第二个节点</span><br><span class="line"> *  @param rootNode 二叉树根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 两个节点间的路径</span><br><span class="line"> */</span><br><span class="line">+ (NSArray *)pathFromNode:(BinaryTreeNode *)nodeA toNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode || !nodeA || !nodeB) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    NSMutableArray *path = [NSMutableArray array];</span><br><span class="line">    if (nodeA == nodeB) &#123;</span><br><span class="line">        [path addObject:nodeA];</span><br><span class="line">        [path addObject:nodeB];</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line">    //从根节点到节点A的路径</span><br><span class="line">    NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode];</span><br><span class="line">    //从根节点到节点B的路径</span><br><span class="line">    NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode];</span><br><span class="line">    //其中一个节点不在树中，则没有路径</span><br><span class="line">    if (pathA.count == 0 || pathB == 0) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //从后往前推，查找第一个出现的公共节点</span><br><span class="line">    for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123;</span><br><span class="line">        [path addObject:[pathA objectAtIndex:i]];</span><br><span class="line">        for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123;</span><br><span class="line">            //找到公共父节点，则将pathB中后面的节点压入path</span><br><span class="line">            if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123;</span><br><span class="line">                j++; //j++是为了避开公共父节点</span><br><span class="line">                while (j&lt;pathB.count) &#123;</span><br><span class="line">                    [path addObject:[pathB objectAtIndex:j]];</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                return path;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树两个节点之间的距离"><a href="#二叉树两个节点之间的距离" class="headerlink" title="二叉树两个节点之间的距离"></a>二叉树两个节点之间的距离</h1><p>可以从两个节点之间的路径衍生出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  二叉树两个节点之间的距离</span><br><span class="line"> *</span><br><span class="line"> *  @param nodeA    第一个节点</span><br><span class="line"> *  @param nodeB    第二个节点</span><br><span class="line"> *  @param rootNode 二叉树根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 两个节点间的距离（-1：表示没有找到路径）</span><br><span class="line"> */</span><br><span class="line">+ (NSInteger)distanceFromNode:(BinaryTreeNode *)nodeA toNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode || !nodeA || !nodeB) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nodeA == nodeB) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //从根节点到节点A的路径</span><br><span class="line">    NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode];</span><br><span class="line">    //从根节点到节点B的路径</span><br><span class="line">    NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode];</span><br><span class="line">    //其中一个节点不在树中，则没有路径</span><br><span class="line">    if (pathA.count == 0 || pathB == 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //从后往前推，查找第一个出现的公共节点</span><br><span class="line">    for (NSInteger i = pathA.count-1; i&gt;=0; i--) &#123;</span><br><span class="line">        for (NSInteger j = pathB.count - 1; j&gt;=0; j--) &#123;</span><br><span class="line">            //找到公共父节点</span><br><span class="line">            if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) &#123;</span><br><span class="line">                //距离=路径节点数-1 （这里要-2，因为公共父节点重复了一次）</span><br><span class="line">                return (pathA.count - i) + (pathB.count - j) - 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="判断二叉树是否完全二叉树"><a href="#判断二叉树是否完全二叉树" class="headerlink" title="判断二叉树是否完全二叉树"></a>判断二叉树是否完全二叉树</h1><p>完全二叉树定义为：若设二叉树的高度为h，除第h层外，其它各层的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布。</p><p>完全二叉树必须满足2个条件：</p><p>1）如果某个节点的右子树不为空，则它的左子树必须不为空</p><p>2）如果某个节点的右子树为空，则排在它后面的节点必须没有孩子节点</p><p>这里还需要理解“排在它后面的节点”，回头看看层次遍历算法，我们就能知道在层次遍历时，是从上到下从左到右遍历的，先将根节点弹出队列，再压入孩子节点，因此“排在它后面的节点”有2种情况：</p><p>1）同层次的后面的节点</p><p>2）同层次的前面的节点的孩子节点（因为遍历前面的节点时，会弹出节点，同时将孩子节点压入队列）</p><p>通过上面的分析，我们可以设置一个标志位flag，当子树满足完全二叉树时，设置flag&#x3D;YES。当flag&#x3D;YES而节点又破坏了完全二叉树的条件，那么它就不是完全二叉树。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  是否完全二叉树</span><br><span class="line"> *  完全二叉树：若设二叉树的高度为h，除第h层外，其它各层的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return YES：是完全二叉树，NO：不是完全二叉树</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)isCompleteBinaryTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    //左子树和右子树都是空，则是完全二叉树</span><br><span class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    //左子树是空，右子树不是空，则不是完全二叉树</span><br><span class="line">    if (!rootNode.leftNode &amp;&amp; rootNode.rightNode) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //按层次遍历节点，找到满足完全二叉树的条件：</span><br><span class="line">    //条件1：如果某个节点的右子树不为空，则它的左子树必须不为空</span><br><span class="line">    //条件2：如果某个节点的右子树为空，则排在它后面的节点必须没有孩子节点</span><br><span class="line">    //排在该节点后面的节点有2种：1）同层次的后面的节点 2）同层次的前面的节点的孩子节点（因为遍历前面的节点的时候，会将节点从队列里pop，同时把它的孩子节点push到队列里）</span><br><span class="line">    NSMutableArray *queue = [NSMutableArray array];</span><br><span class="line">    [queue addObject:rootNode];</span><br><span class="line">    BOOL isComplete = NO; //是否已经满足完全二叉树</span><br><span class="line">    while (queue.count &gt; 0) &#123;</span><br><span class="line">        BinaryTreeNode *node = [queue firstObject];</span><br><span class="line">        [queue removeObjectAtIndex:0];</span><br><span class="line">        </span><br><span class="line">        //左子树为空且右子树不为空，则不是完全二叉树</span><br><span class="line">        if (!node.leftNode &amp;&amp; node.rightNode) &#123;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">        if (isComplete &amp;&amp; (node.leftNode || node.rightNode)) &#123;</span><br><span class="line">            //前面的节点已满足完全二叉树,如果还有孩子节点，则不是完全二叉树</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //右子树为空，则已经满足完全二叉树</span><br><span class="line">        if (!node.rightNode) &#123;</span><br><span class="line">            isComplete = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //压入</span><br><span class="line">        if (node.leftNode) &#123;</span><br><span class="line">            [queue addObject:node.leftNode];</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.rightNode) &#123;</span><br><span class="line">            [queue addObject:node.rightNode];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isComplete;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="判断二叉树是否满二叉树"><a href="#判断二叉树是否满二叉树" class="headerlink" title="判断二叉树是否满二叉树"></a>判断二叉树是否满二叉树</h1><p> 满二叉树定义为：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树</p><p> 满二叉树的一个特性是：叶子数&#x3D;2^(深度-1)，因此我们可以根据这个特性来判断二叉树是否是满二叉树。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  是否满二叉树</span><br><span class="line"> *  满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return YES：满二叉树，NO：非满二叉树</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)isFullBinaryTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //二叉树深度</span><br><span class="line">    NSInteger depth = [self depthOfTree:rootNode];</span><br><span class="line">    //二叉树叶子节点数</span><br><span class="line">    NSInteger leafNum = [self numberOfLeafsInTree:rootNode];</span><br><span class="line">    </span><br><span class="line">    //满二叉树特性：叶子数=2^(深度-1)</span><br><span class="line">    if (leafNum == pow(2, (depth - 1))) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="判断二叉树是否平衡二叉树"><a href="#判断二叉树是否平衡二叉树" class="headerlink" title="判断二叉树是否平衡二叉树"></a>判断二叉树是否平衡二叉树</h1><p>平衡二叉树定义为：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树又叫AVL树。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  是否平衡二叉树</span><br><span class="line"> *  平衡二叉树：即AVL树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</span><br><span class="line"> *</span><br><span class="line"> *  @param rootNode 根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return YES：平衡二叉树，NO：非平衡二叉树</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)isAVLBinaryTree:(BinaryTreeNode *)rootNode &#123;</span><br><span class="line">    static NSInteger height;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        height = 0;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</span><br><span class="line">        height = 1;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    BOOL isAVLLeft = [self isAVLBinaryTree:rootNode.leftNode];</span><br><span class="line">    NSInteger heightLeft = height;</span><br><span class="line">    BOOL isAVLRight = [self isAVLBinaryTree:rootNode.rightNode];</span><br><span class="line">    NSInteger heightRight = height;</span><br><span class="line">    </span><br><span class="line">    height = MAX(heightLeft, heightRight)+1;</span><br><span class="line">    </span><br><span class="line">    if (isAVLLeft &amp;&amp; isAVLRight &amp;&amp; ABS(heightLeft-heightRight) &lt;= 1) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 以上就是我目前整理的一些二叉树相关的算法，算法资料和思想都来源于网络，如有错误，欢迎指正！后续如果有新的算法，我也会更新进去。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-数据结构探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC算法04：二分查找探索</title>
      <link href="/BboyZJ.github.io/2020/08/26/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9504%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/26/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9504%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><ol><li>简介</li></ol><p>二分查找(也称折半查找)是很常见的一种在数组中查找数据的算法,作为一名程序员是应该必须会的。</p><ol start="2"><li>基本思想</li></ol><p>获取数组的中间值，将数组分割成两份，利用查找的值跟中间值进行比较，如果查找的值大于中间值，就在数组的右边进行查找；如果查找的值小于中间值，就在数组的左边进行查找。如此循环的执行下去，最终找到符合的值。</p><ol start="3"><li>优缺点</li></ol><p>1）优点：</p><ul><li>速度快 </li><li>比较次数少 </li><li>性能好</li></ul><p>2）缺点：</p><ul><li>必须是一个有序的数组（升序或者降序）</li><li>适用范围：适用不经常变动的数组</li></ul><ol start="4"><li>复杂度</li></ol><p>时间复杂度就变成了O(logN)</p><ol start="5"><li>具体代码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSArray * arr = @[@1,@3,@5,@6,@8,@15,@20];</span><br><span class="line">    NSInteger result = [self binarySearchTarget:@1 inArray:arr];</span><br><span class="line">    NSLog(@&quot;%ld&quot;,(long)result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在某个数组中搜索目标</span><br><span class="line">- (NSInteger)binarySearchTarget:(NSNumber *)target inArray:(NSArray *)arr&#123;</span><br><span class="line">    //如果数组无元素，则返回</span><br><span class="line">    if (arr.count &lt; 1) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果数组有元素</span><br><span class="line">    //定义三个变量 第一个值下标、最后一个值下标、中间值下标</span><br><span class="line">    NSInteger start = 0;</span><br><span class="line">    NSInteger end = arr.count - 1;</span><br><span class="line">    NSInteger mid = 0;</span><br><span class="line">    //如果开始和结束中间还有元素，则循环</span><br><span class="line">    while (start &lt; end - 1) &#123;</span><br><span class="line">        //会有一些朋友看到有些人是( start + end ) / 2这样写的,但是这样写有一点不好,就是start+end会出现整数溢出的情况,如果存在溢出,你再除以2也是没有用的,所以不能这么写</span><br><span class="line">        mid = start + (end - start) / 2;</span><br><span class="line">        //如果中间值大于目标值</span><br><span class="line">        if ([arr[mid] intValue] &gt; [target intValue]) &#123;</span><br><span class="line">            //中间值做为最后一个值，在前半段再进行相同的搜索</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果中间值小于或等于目标值</span><br><span class="line">        else &#123;</span><br><span class="line">            start = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //考虑到边界问题，所以下面这俩个必须写</span><br><span class="line">    //如果第一个值和目标值相等则获取第一个值的下标</span><br><span class="line">    if ([arr[start] intValue] == [target intValue]) &#123;</span><br><span class="line">        return start;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果最后一个值和目标值相等则获取最后一个值的下标</span><br><span class="line">    if ([arr[end] intValue] == [target intValue]) &#123;</span><br><span class="line">        return end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-08-26 18:06:44.754180+0800 iOS-OC之二分查找[49535:2738585] 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-算法探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC算法05：选择排序探索</title>
      <link href="/BboyZJ.github.io/2020/08/26/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9505%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/26/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9505%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><ol><li><p>基本思路：<code>选择排序</code>（Selection sort）是最基本的 O(n^2) 的排序算法，它的原理是每一次从待排序的数据元素中 <code>选出最小或最大</code> 的一个元素，存放在序列的起始位置，然后，再从 <code>剩余未排序的元素当中继续寻找最小或大的元素</code>， 然后放到未排序的末尾，以此类推，直到全部待排序的数据元素排完。</p></li><li><p>稳定性</p></li></ol><p>选择排序是不稳定的排序方法。</p><ol start="3"><li>主要流程：从小到大</li></ol><ul><li><p>第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换；</p></li><li><p>第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换；</p></li><li><p>以此类推，第i趟在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，使有序序列不断增长直到全部排序完毕。</p></li></ul><ol start="4"><li>具体代码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [self selectionSortWithArr:[NSMutableArray arrayWithArray:@[@3,@1,@2,@5,@4]]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 选择排序</span><br><span class="line">- (void)selectionSortWithArr:(NSMutableArray *)arr&#123;</span><br><span class="line">    // 开始时间</span><br><span class="line">    double startTime = CFAbsoluteTimeGetCurrent();</span><br><span class="line">    // 外层遍历</span><br><span class="line">    for (int i = 0; i&lt; arr.count; i++) &#123;</span><br><span class="line">        int minIndex = i;</span><br><span class="line">        // 内层遍历</span><br><span class="line">        for (int j = i + 1; j &lt; arr.count; j++) &#123;</span><br><span class="line">            // 获取最小下标</span><br><span class="line">            if ([arr[j] intValue]&lt; [arr[minIndex] intValue]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //交换位置</span><br><span class="line">        [arr exchangeObjectAtIndex:i withObjectAtIndex:minIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    double endTime = CFAbsoluteTimeGetCurrent();</span><br><span class="line">    NSLog(@&quot;%@&quot;,arr);</span><br><span class="line">    NSLog(@&quot;选择排序用时:%f s&quot;,endTime - startTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2020-08-26 17:11:21.653476+0800 OC-选择排序[48845:2694230] (</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5</span><br><span class="line">)</span><br><span class="line">2020-08-26 17:11:21.653672+0800 OC-选择排序[48845:2694230] 选择排序用时:0.000003 s</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-算法探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：OC项目引入swift</title>
      <link href="/BboyZJ.github.io/2020/08/22/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9AOC%E9%A1%B9%E7%9B%AE%E5%BC%95%E5%85%A5swift/"/>
      <url>/BboyZJ.github.io/2020/08/22/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9AOC%E9%A1%B9%E7%9B%AE%E5%BC%95%E5%85%A5swift/</url>
      
        <content type="html"><![CDATA[<p>在项目开发中，多人合作时，有可能遇到同事是主 <code>swift</code> 开发，而自己是主 <code>OC</code> 开发，这时如果是以 <code>OC</code> 语言为主，<code>swift</code> 语言为辅，那么就需要了解如何让 <code>OC</code> 引入 <code>swift</code></p><h1 id="创建桥接文件"><a href="#创建桥接文件" class="headerlink" title="创建桥接文件"></a>创建桥接文件</h1><ul><li>注：在项目中我们第一次创建 <code>swift</code> 文件时，<code>xcode</code> 会提示我们创建，点击创建即可</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090613514.png"></p><p>此时，我们可以把 swift file 文件删掉，然后创建自己需要的文件，</p><ul><li>此时我们看列表，发现桥接文件 <code>项目名-Bridging-Header.h</code></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090614777.png"></p><h1 id="配置-builder-setting"><a href="#配置-builder-setting" class="headerlink" title="配置 builder setting"></a>配置 builder setting</h1><ul><li>除了上述桥接文件，还有一个隐藏文件 <code>项目名-Swift</code>，在 <code>OC</code> 调用 <code>swift</code> 的时候会用到，在列表中不显示</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090614025.png"></p><p>注：这个名字可以改写成自己想要的 <code>Swift.h</code></p><h1 id="创建swift文件，供OC调用"><a href="#创建swift文件，供OC调用" class="headerlink" title="创建swift文件，供OC调用"></a>创建swift文件，供OC调用</h1><ul><li>创建swift文件，Test继承NSObject 和 TestViewController继承UIViewController</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090615064.png"></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090615603.png"></p><ul><li>分别添加一个方法，在swift文件中，方法前要加上 <code>@objc</code>，不然 <code>OC</code> 无法调用</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090615604.png"></p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090616437.png"></p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>在 <code>OC</code> 的 <code>pch</code> 文件下，导入隐藏生成的 <code>swift.h</code>，这样就可以全局使用，不需要每次都导入</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090616893.png"></p><ul><li>在 <code>ViewController</code> 中使用</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303090616617.png"></p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习00：简介</title>
      <link href="/BboyZJ.github.io/2020/08/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A000%EF%BC%9A%E7%AE%80%E4%BB%8B/"/>
      <url>/BboyZJ.github.io/2020/08/22/Swift%E8%AF%BE%E7%A8%8B/Swift%E5%AD%A6%E4%B9%A000%EF%BC%9A%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Swift介绍"><a href="#Swift介绍" class="headerlink" title="Swift介绍"></a>Swift介绍</h1><p>Swift是Apple在2014年6月WWDC发布的全新的编程语言。</p><p>Swift是一种高性能系统编程语言，提供了对现有C和OC代码框架的无缝访问，并且是内存安全的。</p><p>Swift语言更加简洁，是一门类型安全的语言。</p><h1 id="Swift和OC的区别"><a href="#Swift和OC的区别" class="headerlink" title="Swift和OC的区别"></a>Swift和OC的区别</h1><ol><li>编程范式</li></ol><ul><li>Swift可以 <code>面试协议编程、函数式编程和面向对象编程</code></li><li>OC以 <code>面向对象编程</code> 为主，当然你可以引入 <code>Reactive Cocoa</code> 的类库来进行函数式编程</li></ul><ol start="2"><li>类型安全</li></ol><ul><li>Swift是一门 <code>类型安全的语言</code>。鼓励程序员在代码中清楚明确值的类型。如果代码中使用一个字符串String，那么你不能错误地传递一个整型Int给它。因为Swift是类型安全的，它会在代码编译的时候做类型检查，并且把所有不匹配的类型作为一个错误标记出来。这样使得程序员在开发中尽可能早地发现和修正错误。</li><li>而OC则 <code>不是类型安全的语言</code>，你声明一个NSString变量，仍然可以传递一个NSNumber给它，尽管编译器会抱怨，但是你仍然可以作为NSNumber来使用它。</li></ul><ol start="3"><li>值类型的增强</li></ol><ul><li>在Swift中，典型的有 <code>struct、enum</code> 以及 <code>元祖tuple</code> 都是值类型。而平时使用的Int、Double、Float 、String 、Array 、Dictionary、Set其实都是用结构体实现的，也是 <code>值类型</code>。</li><li>OC中，NSNumber、NSString以及集合类对象都是指针类型。</li></ul><ol start="4"><li>枚举增强</li></ol><ul><li>Swift的枚举可以使用 <code>整型、浮点型、字符串等</code>，还能拥有 <code>属性和方法</code>，甚至支持 <code>泛型、协议、扩展等</code>。</li><li>OC里面的枚举则鸡肋很多。</li></ul><ol start="5"><li>泛型</li></ol><ul><li>Swift中 <code>支持泛型</code>，也支持泛型的类型约束等特性</li><li>苹果推出了Swift2.0版本，为了让开发者从OC更好的国度到Swift上，苹果也为OC带来了Gennerics泛型支持，不过OC的泛型约束也仅停留在编译器警告阶段。</li></ul><ol start="6"><li>协议和扩展</li></ol><ul><li>Swift对协议的支持更加丰富，配合扩展（extension）、泛型、关联类型等可以实现面向协议编程，从而大大提高代码的灵活性。同时swift中的protocol还可以用于值类型，如结构体和枚举</li><li>OC的协议却反强约束，提供optional特性往往成为很多问题得来源，而如果放弃optional又会让实现代价过大。</li></ul><ol start="7"><li>函数和闭包</li></ol><ul><li>Swift函数是一等公民，可以直接定义函数类型变量，可以作为其他函数参数传递，可以作为函数的返回值类型。</li><li>OC里面函数仍然是次等公民，需要selector封装或者使用block才能模拟Swift中类似的效果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-课程篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OCRuntime04：Runtime实际应用</title>
      <link href="/BboyZJ.github.io/2020/08/18/OCRuntime&amp;Runloop/OCRuntime04%EF%BC%9ARuntime%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
      <url>/BboyZJ.github.io/2020/08/18/OCRuntime&amp;Runloop/OCRuntime04%EF%BC%9ARuntime%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Runtime实际应用"><a href="#Runtime实际应用" class="headerlink" title="Runtime实际应用"></a>Runtime实际应用</h1><h2 id="1-runtime交换方法"><a href="#1-runtime交换方法" class="headerlink" title="1.runtime交换方法"></a>1.runtime交换方法</h2><p>场景：当第三方框架或者系统原生的方法不满足需求的时候，可以在不改动原有方法的基础上，添加额外的功能。</p><p>方式：利用 <code>OC</code> 的 <code>runtime</code> 机制</p><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UIImage+A.h&quot;</span><br><span class="line">#import &quot;objc/runtime.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation UIImage (A)</span><br><span class="line">/*</span><br><span class="line"> 作用：把类加载进内存的时候调用,只会调用一次</span><br><span class="line"> 调用：方法应先交换，再去调用</span><br><span class="line"> */</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    //1.获取image方法地址</span><br><span class="line">    Method originMethod = class_getClassMethod(self, @selector(imageNamed:));</span><br><span class="line">    //2.获取zl_imageNamed方法地址</span><br><span class="line">    Method newMethod = class_getClassMethod(self, @selector(zj_imageNamed:));</span><br><span class="line">    //3.交换方法地址</span><br><span class="line">    method_exchangeImplementations(originMethod, newMethod);</span><br><span class="line">&#125;</span><br><span class="line">// 加载图片 且 带判断是否加载成功</span><br><span class="line">+ (UIImage *)zj_imageNamed:(NSString *)name&#123;</span><br><span class="line">    UIImage * img = [UIImage zj_imageNamed:name];</span><br><span class="line">    if (img) &#123;</span><br><span class="line">        NSLog(@&quot;runtime交互方法 -&gt; 图片加载成功&quot;);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        NSLog(@&quot;runtime交互方法 -&gt; 图片加载失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return img;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="2-Runtime给分类添加属性"><a href="#2-Runtime给分类添加属性" class="headerlink" title="2.Runtime给分类添加属性"></a>2.Runtime给分类添加属性</h2><p>场景：给系统的类添加额外属性的时候</p><p>原理：利用 <code>OC</code> 的 runtime机制。</p><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@interface Person (A)</span><br><span class="line">@property (nonatomic,copy)NSString * name;</span><br><span class="line">@property (nonatomic,assign)int age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;Person+A.h&quot;</span><br><span class="line">#import &quot;objc/runtime.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person (A)</span><br><span class="line">// 1.String类型</span><br><span class="line">// 我们需要在.m里声明这个key</span><br><span class="line">static void * name_key = &amp;name_key;</span><br><span class="line">- (void)setName:(NSString *)name&#123;</span><br><span class="line">    objc_setAssociatedObject(self, name_key, name, OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)name&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, name_key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.Int型</span><br><span class="line">// 我们需要在.m里声明这个key</span><br><span class="line">static void * age_key = &amp;age_key;</span><br><span class="line">- (void)setAge:(int)age&#123;</span><br><span class="line">    objc_setAssociatedObject(self, age_key, @(age), OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">&#125;</span><br><span class="line">- (int)age&#123;</span><br><span class="line">    NSNumber * number = objc_getAssociatedObject(self, age_key);</span><br><span class="line">    return [number intValue];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="3-动态添加方法"><a href="#3-动态添加方法" class="headerlink" title="3.动态添加方法"></a>3.动态添加方法</h2><p>场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。</p><p>原理：利用 <code>OC</code> 的 runtime机制，使用 <code>performSelector</code> 添加方法，相当于懒加载机制</p><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJPerson.h&quot;</span><br><span class="line">#import &quot;objc/runtime.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZJPerson</span><br><span class="line">// 当一个方法没有实现，但是又调用了，就会调用调用下面的方法</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    if (sel == @selector(eat))&#123;</span><br><span class="line">        /**</span><br><span class="line">         class 给哪个类添加方法</span><br><span class="line">         SEL 方法编码</span><br><span class="line">         IMP 方法实现，就是一个函数指针</span><br><span class="line">         type 方法类型，苹果官方文档可以查看</span><br><span class="line">         */</span><br><span class="line">        class_addMethod([ZJPerson class], sel, (IMP)eat, &quot;v@:&quot;);</span><br><span class="line">    &#125;else if (sel == @selector(play:))&#123;</span><br><span class="line">        class_addMethod([ZJPerson class], sel, (IMP)play, &quot;v@:@&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">// 定义函数</span><br><span class="line">/*</span><br><span class="line"> 一个方法默认都有两个参数：self _cmd(隐士参数)</span><br><span class="line"> self：方法调用者</span><br><span class="line"> _cmd：调用方法的编号</span><br><span class="line"> */</span><br><span class="line">void eat(id self, SEL _cmd) &#123;</span><br><span class="line">    NSLog(@&quot;调用了%@的%@方法&quot;,self,NSStringFromSelector(_cmd));</span><br><span class="line">&#125;</span><br><span class="line">void play(id self, SEL _cmd, id objc) &#123;</span><br><span class="line">    NSLog(@&quot;调用了%@的%@方法 Play%@&quot;,self,NSStringFromSelector(_cmd),objc);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-Runtime字典转模型"><a href="#4-Runtime字典转模型" class="headerlink" title="4.Runtime字典转模型"></a>4.Runtime字典转模型</h2><p>思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值（从提醒：字典中取值，不一定要全部取出来）；提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类实现字典转模型。</p><p>考虑情况：<br>1.当字典的key和模型的属性匹配不上。<br>2.模型中嵌套模型（模型属性是另外一个模型对象）。<br>3.数组中装着模型（模型的属性是一个数组，数组中是一个个模型对象）。</p><h2 id="5-实现NSCoding的归档接档"><a href="#5-实现NSCoding的归档接档" class="headerlink" title="5.实现NSCoding的归档接档"></a>5.实现NSCoding的归档接档</h2><p>原理描述：用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。<br>核心方法：在Model的基类中重写方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        unsigned int outCount;</span><br><span class="line">        Ivar * ivars = class_copyIvarList([self class], &amp;outCount);</span><br><span class="line">        for (int i = 0; i &lt; outCount; i ++) &#123;</span><br><span class="line">            Ivar ivar = ivars[i];</span><br><span class="line">            NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">            [self setValue:[aDecoder decodeObjectForKey:key] forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivars);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</span><br><span class="line">    unsigned int outCount;</span><br><span class="line">    Ivar * ivars = class_copyIvarList([self class], &amp;outCount);</span><br><span class="line">    for (int i = 0; i &lt; outCount; i ++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">        [aCoder encodeObject:[self valueForKey:key] forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OC-Runloop探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS-OC之性能检测工具Network探索</title>
      <link href="/BboyZJ.github.io/2020/08/14/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604%EF%BC%9ANetwork%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/14/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604%EF%BC%9ANetwork%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="弱网优化"><a href="#弱网优化" class="headerlink" title="弱网优化"></a>弱网优化</h1><ul><li><p>所谓弱网络，指在网络不好的情况下使用APP，如 2G、3G网络，用户的网络速度基本在 <code>10k/s~60k/s</code>。</p></li><li><p>考虑海外应用的话，就必须考虑弱网优化的方案了。</p></li><li><p>苹果建议，使用苹果内置的 <code>Network Link Conditioner</code> 来模拟网络环境处理 <code>APP</code> 的体验问题，在Xcode 和 手机都可以开启</p></li></ul><p>Xcode：系统偏好设置<br>iPhone：开发者 -&gt; Network Link Conditioner</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> OC-性能优化探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS-OC之Energy Log探索</title>
      <link href="/BboyZJ.github.io/2020/08/14/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603%EF%BC%9AEnergy-Log%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/14/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603%EF%BC%9AEnergy-Log%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>所有应用程序在执行网络操作、更新用户界面或在CPU上运行代码时都会消耗能量。随着用户越来越多地依赖电池电量，以及应用程序的激增，能效已成为用户体验中不可或缺的一部分。</p><h1 id="电池寿命"><a href="#电池寿命" class="headerlink" title="电池寿命"></a>电池寿命</h1><p>随着能源效率的下降，电池的寿命也会下降。同时消耗过多的资源会导致界面滞后，对用户输入的响应会很慢。随着越来越多的应用程序使用越来越多的资源，系统工作起来越来越努力，速度也越来越快，设备的物理温度也在逐渐升高。当这种情况发生时，系统会采取措施将温度降低到更容易接受的水平。</p><h1 id="能量消耗的因素"><a href="#能量消耗的因素" class="headerlink" title="能量消耗的因素"></a>能量消耗的因素</h1><p>1.CPU: CPU是能源的主要消耗者。高CPU使用周期会迅速耗尽用户的电池。 CPU使用率超过20%就会快速耗干电池电量——建议只在必要时通过批处理、调度和优先级排序来完成工作。</p><p>2.Network：大多数iOS应用程序执行网络操作。当联网发生时，蜂窝无线电和Wi-Fi等组件就会启动并消耗能量。通过批量处理和减少事务、压缩数据和适当处理错误，您的应用程序可以为节能做出重大贡献。</p><p>3.GPU: 图形处理器(显卡的处理器),乱使用GPU会导致交互差,并且降低电池寿命。</p><p>4.Location: 许多应用程序发出位置请求是为了记录用户的物理活动或提供基于环境的警报。能量消耗随着精确度的提高和位置请求的延长而增加。你的应用应该尽可能减少定位活动的准确性和持续时间。当不再需要时停止位置请求。</p><p>5.Background: 后台状态App仍会消耗电量,App要按需执行后台操作,并使用延迟APNS来保证系统运算高效执行.另外,在app进入后台状态是,立即减少动作,并且通知系统一次这些动作已经完成.</p><p>6.Bluetooth: 长时间的蓝牙活动会耗尽iOS设备和蓝牙设备的电池。只要可能，批处理和缓冲蓝牙活动，并减少对数据的轮询。</p><p>7.Device wakes：iOS设备依靠睡眠来延长电池寿命。无论设备何时唤醒，都会有很高的开销成本，因为必须为屏幕和其他资源提供电源。你的应用程序，尤其是在后台操作时，应该尽可能空闲，除非绝对必要，避免用推送通知或其他活动唤醒设备</p><h1 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h1><p>1.Time Profile:时间分析器分析模板。使用此模板对正在运行的进程执行低开销的基于时间的采样。Time Profiler 监视应用程序中正在运行的线程，并定期采样。为每个样本收集完整的回溯，允许您深入查看样本，以准确找到代码中花费大量时间的位置。</p><p>2.Core Animation:核心动画分析模板。使用此模板可以测量图形性能和CPU使用率。启用模板 Core Animation 的Flash Updated Regions 设置，以查看应用中发生的每个屏幕更新，并观察不必要或意外的更新。</p><p>3.Activity Monitor: 活动监视器分析模板。使用此模板可以监视整体CPU，磁盘I&#x2F;O和网络使用情况。</p><h1 id="Energy-log调试和演示"><a href="#Energy-log调试和演示" class="headerlink" title="Energy log调试和演示"></a>Energy log调试和演示</h1><p>1.检查第一步，是通过xcode开发工具的energy impact来整体查看app的耗电情况。<br><img src="https://user-images.githubusercontent.com/25925248/90361066-de22f700-e08f-11ea-8c0d-c4d4a022ce37.png"></p><p>Overhead：表示开销,包括CPU的唤起,无线电模组(蓝牙&amp;WiFi),和其他系统资源的调用等。</p><p>2.检查第二步：通过instrument工具的energy log来检测具体的耗电模块。<br><img src="https://user-images.githubusercontent.com/25925248/90362291-db75d100-e092-11ea-9f6e-213ce6cf0924.png"></p><p>3.降低能量消耗举例<br>1）CPU</p><ul><li>Timer的时间间隔不宜太短,满足需求即可</li><li>线程适量,不宜过多,不要阻塞主线程</li><li>优化算法,减少循环次数</li><li>适当使用多线程</li><li>避免庞大的xib,storyBoard,尽量使用纯代码开发</li></ul><p>2）网络请求</p><ul><li>识别：确保不重复做同一个操作；</li><li>优化：使用后台会话</li><li>合并：批处理事务</li><li>减少：最小化重试，缓存结构优化等等</li></ul><p>3)GPU</p><ul><li>减少视图刷新：确保必要的时候才刷新，能刷新1行cell最好只刷新一行；</li><li>审查模糊用法：避免将模糊放在更新元素上，尽量少使用圆角和透明度；</li><li>尽量减少使用离散GPU除非动画效果需要，或功能不能支持的情况下</li></ul><p>4)Location, Bluetooth, Background</p><ul><li>定位和蓝牙按需取用,定位之后要关闭或降低定位频率，进入后台关闭定位，停止定时器运行等</li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-性能优化探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS-OC之性能检测工具Animation Hitches探索</title>
      <link href="/BboyZJ.github.io/2020/08/14/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602%EF%BC%9AAnimation%20Hitches%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/14/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602%EF%BC%9AAnimation%20Hitches%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Animation-Hitches-前言"><a href="#Animation-Hitches-前言" class="headerlink" title="Animation Hitches 前言"></a>Animation Hitches 前言</h1><p><code>Instrument</code> 新增 <code>Animation Hieches</code> 监测类型用于监测 <code>卡顿</code>，去掉了 <code>Core Animation</code> 检测方式。</p><h1 id="Animation-Hitches-简介"><a href="#Animation-Hitches-简介" class="headerlink" title="Animation Hitches 简介"></a>Animation Hitches 简介</h1><p><code>卡顿时间比</code>(Hitch Time Ratio) 的概念用于替代 <code>FPS</code>，iPhone13Pro之前屏幕刷最高刷新率仍为60HZ，iPhone13Pro及以上帧率调整到120HZ</p><h1 id="调试页面渲染性能"><a href="#调试页面渲染性能" class="headerlink" title="调试页面渲染性能"></a>调试页面渲染性能</h1><p>所以，现在可以不用打开Instruments也可以。</p><p><img src="https://user-images.githubusercontent.com/25925248/90330340-a5771500-dfde-11ea-9233-c71ad6785a47.png"></p><ol><li><code>Color Blended Layer</code> 图层混合</li></ol><p>什么是图层混合：界面都是由多个UI控件 <code>叠加</code> 的，如果有 <code>透明或半透明</code> 的控件，GPU会计算显示颜色，损耗GPU资源。</p><p>解决办法：打开 <code>color Blended Layer</code> 选项，显示 <code>红色则出现图层混合</code>；我们调试的目的就是把红色区域消减的越少越好，只要 <code>设置控件不透明</code> 即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label.background = [UIColor whiteColor];</span><br><span class="line">label.layer.masksToBounds = YES;</span><br></pre></td></tr></table></figure><ol start="2"><li>Color Hits Green and Misses Red（光栅化）</li></ol><p>检测是否正确的使用 <code>layer</code> 的 <code>shouldRasterize</code> 属性，shouldRasterize &#x3D; YES开启光栅化。</p><ul><li>什么是光栅化？</li></ul><p>光栅化是将一个layer预先渲染成 <code>位图(bitmap)</code>，再加入到缓存中，成功被缓存的layer会标注为绿色,没有成功缓存的会标注为 <code>红色</code>，正确使用光栅化可以得到一定程度的性能提升。</p><ul><li><p>适用情况：一般在图像内容不变的情况下才使用光栅化，例如设置阴影耗费资源比较多的 <code>静态内容</code>，如果 <code>使用光栅化</code> 对性能的提升有一定帮助。</p></li><li><p>非适用情况：如果 <code>内容会经常变动</code>,这个时候不要开启,否则会造成性能的浪费。 例如我们在使用<code>tableViewCell</code>中，一般 <code>不要用光栅化</code>，因为tableViewCell的绘制非常频繁，内容在不断的变化，如果使用了光栅化，会造成大量的离屏渲染降低性能。</p></li></ul><ol start="3"><li>Color Copied Images（图片颜色格式）</li></ol><p>拷贝给CPU进行转化的图片显示为绿：GPU不支持当前图片的颜色格式，那么就会将图片交给CPU预先进行格式转化，并且这张图片标记为蓝色</p><ol start="4"><li>Color Misaligned Images(图片大小)</li></ol><p><code>图片大小</code> 和 <code>imageView size</code> 不匹配，会出现 <code>黄色</code>，消耗资源压缩图片</p><ol start="5"><li>Color Offscreen-Rendered Yellow（离屏渲染）</li></ol><p>触发离屏渲染的操作：</p><ul><li>drawRect</li><li>layer.shadow</li><li>layer.shouldRasterize</li><li>layer.mask</li><li>layer.masksToBounds 和 layer.cornerRadius 同时使用等</li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-性能优化探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS-OC之Time Profiler探索</title>
      <link href="/BboyZJ.github.io/2020/08/14/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605%EF%BC%9ATime-Profiler%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/14/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605%EF%BC%9ATime-Profiler%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Time-Profiler简介"><a href="#Time-Profiler简介" class="headerlink" title="Time Profiler简介"></a>Time Profiler简介</h1><p>Time Profiler见名知意：CPU分析工具-时间分析工具，它会按照设定的时间间隔（默认1毫秒）来跟踪每一线程的堆栈信息（stacktrace），并通过比较时间间隔之间的堆栈状态，来推算出某个方法执行了多久，给出一个近似值。</p><h1 id="Time-Profiler使用须知"><a href="#Time-Profiler使用须知" class="headerlink" title="Time Profiler使用须知"></a>Time Profiler使用须知</h1><p>当点击Time Profiler应用程序开始运行后.就能获取到整个应用程序运行消耗时间分布和百分比.为了保证数据分析在统一使用场景真实行有如下点需要注意:</p><ul><li><p>在开始进行应用程序性能分析的时候,一定要使用真机,模拟器运行在Mac上，然而Mac上的CPU往往比iOS设备要快。相反，Mac上的GPU和iOS设备的完全不一样，模拟器不得已要在软件层面（CPU）模拟设备的GPU，这意味着GPU相关的操作在模拟器上运行的更慢，尤其是使用CAEAGLLayer来写一些OpenGL的代码时候. 这就导致模拟器性能数据和用户真机使用性能数据相去甚运.</p></li><li><p>另外在开始性能分析前另外一件重要的事情是，应用程序运行一定要Release版本 而不是Debug版本.</p></li><li><p>在发布环境打包的时候，编译器会引入一系列提高性能的优化，例如去掉调试符号或者移除并重新组织代码.另iOS引入一种”Watch Dog”[看门狗]机制.不同的场景下，“看门狗”会监测应用的性能。如果超出了该场景所规定的运行时间，“看门狗”就会强制终结这个应用的进程.开发者可以crashlog看到对应的日志.但Xcode在调试配置下会禁用”Watch Dog”。</p></li></ul><h1 id="Time-Profiler的使用"><a href="#Time-Profiler的使用" class="headerlink" title="Time Profiler的使用"></a>Time Profiler的使用</h1><ol><li><p>首先用Xcode打开你的项目。比如我的项目FJReading。</p></li><li><p>修改Edit Scheme为Release版本如下:</p></li></ol><p><img src="https://user-images.githubusercontent.com/25925248/90216257-9b171880-de30-11ea-99c2-dad43f1cef5d.png"></p><p>因为Release环境下的才是正确的配置：</p><p><img src="https://user-images.githubusercontent.com/25925248/90216456-1d9fd800-de31-11ea-8a41-c8ec6862d861.png"></p><ol start="3"><li>打开Instrument -&gt; Time Profiler</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/90214670-d8c57280-de2b-11ea-94b1-681955120491.png"></p><ol start="4"><li>界面的整体如下:</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/90213624-d877a800-de28-11ea-9c25-112091fd9ee4.png"></p><ul><li>weight: 整体运行时长和比例</li><li>self weight:自己代码的运行时长和比例</li><li>Symbol Name:被调用函数的符号信息,可以切换为实际调用的方法</li></ul><ol start="5"><li>选择真机和你要调试的App</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/90214784-2f32b100-de2c-11ea-9c1f-8b32d9f1cabe.png"></p><ol start="6"><li><p>点击Start按钮，Time Profiler就开始记录App的运行情况<br><img src="https://user-images.githubusercontent.com/25925248/90214870-77ea6a00-de2c-11ea-8644-a622607fb8ec.png"></p></li><li><p>可以看到在CPU使用过高的位置对应的具体调用栈</p></li></ol><p>打开Time Profiler调试工具进入到调试界面,选择你的真机和项目，点击左上角红色原点（启动程序按钮）之后便可以看到如下图的时间消耗：</p><p><img src="https://user-images.githubusercontent.com/25925248/90213624-d877a800-de28-11ea-9c25-112091fd9ee4.png"></p><ol start="8"><li>CallTree选项介绍</li></ol><p>但是我们发现这些信息只能显示到底层的线程Runloop耗时，并不能帮助我们定位到具体的代码中去，下面介绍CallTree选项的勾选操作以及含义。这些选项默认是不选的，但把它们勾选上可以帮你更快定位到关键的代码上，往往这也是问题的源头。</p><ul><li><p>Separate by Thread（建议选择）：按线程分开做分析，这样更容易揪出那些吃资源的问题线程。特别是对于主线程，它要处理和渲染所有的接口数据，一旦受到阻塞，程序必然卡顿或停止响应。</p></li><li><p>Invert Call Tree（建议选择）：反向输出调用树。把调用层级最深的方法显示在最上面，更容易找到最耗时的操作。</p></li><li><p>Hide Missing Symbols（建议选择）：隐藏缺失符号。如果dSYM文件或其他系统架构缺失，列表中会出现很多奇怪的十六进制的数值，用此选项把这些干扰元素屏蔽掉，让列表回归清爽。</p></li><li><p>Hide System Libraries（建议选择）：隐藏系统库文件。过滤掉各种系统调用，只显示自己的代码调用。</p></li><li><p>Flattern Recursion（一般不选）：拼合递归。将同一递归函数产生的多条堆栈（因为递归函数会调用自己）合并为一条。</p></li><li><p>Top Functions（可选）：找到最耗时的函数或方法。</p></li></ul><ol start="9"><li>根据这些时间对应代码便可以做一些优化，减少重复的耗时逻辑优化CPU。我用上面的流程查看了我写的代码基本上是没有太耗时的操作，perfect。</li></ol><h1 id="写一个demo具体定位耗时"><a href="#写一个demo具体定位耗时" class="headerlink" title="写一个demo具体定位耗时"></a>写一个demo具体定位耗时</h1><ol><li>创建一个demo项目，写如下代码：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    //单元测试</span><br><span class="line">    NSDate * startDate = [NSDate date];</span><br><span class="line">    for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">        NSString *string = @&quot;123&quot;;</span><br><span class="line">        string = [string stringByAppendingString:@&quot;abc&quot;];</span><br><span class="line">        NSLog(@&quot;%@&quot;, string);</span><br><span class="line">    &#125;</span><br><span class="line">    NSDate *endDate = [NSDate date];</span><br><span class="line">    NSTimeInterval interval = [endDate timeIntervalSinceDate:startDate];</span><br><span class="line">    NSLog(@&quot;time = %f&quot;,interval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>我们查看一下CPU耗时操作：</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/90218587-c866c500-de36-11ea-8878-f62558db7eb4.png"></p><p>可以看到ViewController中占用大量的时间763ms，双击函数调用进入里面看看：</p><p><img src="https://user-images.githubusercontent.com/25925248/90218962-a3268680-de37-11ea-99db-062fb316b2a0.png"></p><ol start="3"><li>我们注释掉打印重新跑一遍代码看看效果</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSString *string = @&quot;123&quot;;</span><br><span class="line">        string = [string stringByAppendingString:@&quot;abc&quot;];</span><br><span class="line">//            NSLog(@&quot;%@&quot;, string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看结果如下:</p><p><img src="https://user-images.githubusercontent.com/25925248/90219276-3e1f6080-de38-11ea-8a03-52d974460550.png"></p><p>结论:由此可见，耗时操作明显下降了。</p>]]></content>
      
      
      <categories>
          
          <category> OC-性能优化探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS-OC性能优化之Instruments工具初探</title>
      <link href="/BboyZJ.github.io/2020/08/14/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601%EF%BC%9AInstruments%E5%B7%A5%E5%85%B7%E5%88%9D%E6%8E%A2/"/>
      <url>/BboyZJ.github.io/2020/08/14/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601%EF%BC%9AInstruments%E5%B7%A5%E5%85%B7%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Xcode自带的检测调试工具Instruments"><a href="#Xcode自带的检测调试工具Instruments" class="headerlink" title="Xcode自带的检测调试工具Instruments"></a>Xcode自带的检测调试工具Instruments</h1><p>Instruments提供了很多功能，我会重点介绍一下我最常用的几类：</p><p>1.Time Profiler：CPU分析工具分析代码的执行时间。</p><p>2.Core Animation：离屏渲染，图层混合等GPU耗时。</p><p>3.Leaks：内存检测，内存泄漏检测工具。但是不方便；使用MLeaksFinder三方库最好。</p><p>4.Energy Log：耗电检测工具。</p><p>5.Network：流量检测工具。</p><h1 id="调试工具打开方式"><a href="#调试工具打开方式" class="headerlink" title="调试工具打开方式"></a>调试工具打开方式</h1><p>使用XCode自带的Instruments工具，可以通过如下的方式打开:<br>方式一：<br><img src="https://user-images.githubusercontent.com/25925248/90212710-93527680-de26-11ea-84ff-d4bb7fb928bd.png"></p><p>方式二：<br><img src="https://user-images.githubusercontent.com/25925248/90212811-d6144e80-de26-11ea-9b7e-5960eab9ba8a.png"></p><p>最终看到如下的调试工具:<br><img src="https://user-images.githubusercontent.com/25925248/90212856-ef1cff80-de26-11ea-9d1f-3f5e93a88378.png"></p>]]></content>
      
      
      <categories>
          
          <category> OC-性能优化探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC：Charles探索</title>
      <link href="/BboyZJ.github.io/2020/08/13/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A018%EF%BC%9ACharles/"/>
      <url>/BboyZJ.github.io/2020/08/13/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A018%EF%BC%9ACharles/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Charles</code> 是一款非常优秀的抓包工具，<code>Charles</code> 不仅可以帮助我们 <code>抓取服务器返回的数据</code>，还可以修改请求参数，修改响应体，还能模拟弱网络环境</p><h1 id="应用一：Charles抓包iPhone上的HTTP"><a href="#应用一：Charles抓包iPhone上的HTTP" class="headerlink" title="应用一：Charles抓包iPhone上的HTTP"></a>应用一：Charles抓包iPhone上的HTTP</h1><ol><li><code>Charles</code> 上的设置</li></ol><p>点击 <code>Proxy</code> -&gt; <code>Proxy Setting</code> -&gt; 端口Port填写 <code>8888</code> -&gt; 勾选 <code>Enable transparent HTTP proxying</code>，如下图所示：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172049028.png"                                     ></p><ol start="2"><li>iPhone 上的设置</li></ol><ul><li>1、WIFI一致：保证你的 <code>iPhone</code> 和 <code>Mac</code> 上的 <code>WiFi</code> 要一致。</li><li>2、配置 <code>HTTP</code> 代理：找到你链接的 <code>WiFi</code>，划到底部，配置 <code>HTTP</code> 代理，选择 <code>手动</code></li><li>3、填写 <code>服务器IP 和 端口号</code>：<code>服务器IP(Mac面板-&gt;系统偏好设置-&gt;网络-&gt;状态下192.168.1.245)</code> 和 <code>端口号（上面配置的8888）</code></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172053090.png"                                     ></p><ol start="3"><li>链接IP地址</li></ol><ul><li><p>首先，打开Mac上的 <code>Charles</code>，<code>iPhone</code> 上打开任意联网的 <code>APP</code></p></li><li><p>其次，Charles就会弹出iPhone请求链接的确认弹窗，点击 <code>Allow</code> 即可完成设置,如下图：</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172053282.png"                                     ></p><ol start="4"><li>查看Charles上你要截取的数据</li></ol><ul><li><p>首先，打开 <code>Charles</code>，找到 <code>Filter：输入过滤条件8888</code></p></li><li><p>其次，点击 <code>Contents</code>，找到你要截取的数据，如下图：</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172056796.png"                                     ></p><h1 id="应用二：Charles抓包HTTPS"><a href="#应用二：Charles抓包HTTPS" class="headerlink" title="应用二：Charles抓包HTTPS"></a>应用二：Charles抓包HTTPS</h1><ol><li>Charles上的设置</li></ol><p>抓取 <code>HTTPS</code> 需要 <code>Mac</code> 和 <code>iPhone</code> 安装证书（<code>Help -&gt; SSL Proxying</code>）</p><ul><li>首先，打开Charles，找到 <code>Help -&gt; SSL Proxying</code>，然后按照下图在 <code>Mac</code> 和 <code>iPhone</code> 上安装证书：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172056316.png"                                     ></p><ul><li>电脑上安装证书很简单，直接点击 <code>Install Charles Root Certificate -&gt; 输入钥匙串密码</code> 即可。</li></ul><blockquote><p>注：一般系统默认不信任 <code>Charles Proxy CA</code> 证书，打开 <code>钥匙串-&gt; Charles Proxy CA -&gt; 始终信任</code>，如下图：</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172057189.png"                                     ></p><ul><li>手机上安装证书，点击上图的 <code>Install Charles Root Certificate on a Mobile Device or Remote Browser</code>，会给我们提示：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172057059.png"                                     ></p><p>上面的提示框的意思是，在手机设置好代理 <code>（192.168.1.245）</code> 和 端口号（ <code>8888</code> ）后，在手机浏览器中访问 <code>chls.pro/ssl</code> 下载并安装证书，证书文件名是：<code>charles-proxy-CA</code>，证书下载完成后，在手机上安装该证书，打开phone手机：<code>手机设置 -&gt; 通用 -&gt; 描述文件与设备管理 -&gt; Charles Proxy CA -&gt; 安装</code>，并在 <code>设置 -&gt; 关于手机 -&gt; 证书信任设值 -&gt; 开启完全信任</code></p><ol start="2"><li>电脑和手机上证书都安装完毕后，最后再设置一下 <code>SSL Proxy -&gt; SSL Proxying Settings</code>，就可以利用 <code>Charles</code> 抓包 <code>https</code> 请求了</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172058986.png"                                     ></p><blockquote><p>注：<br>Host（主机地址）： <code>* </code>代表全部的主机地址；<br>Port（端口号）：默认 <code>403</code></p></blockquote><h1 id="应用三、Charles模拟慢网速"><a href="#应用三、Charles模拟慢网速" class="headerlink" title="应用三、Charles模拟慢网速"></a>应用三、Charles模拟慢网速</h1><ol><li>首先，打开 <code>Charles -&gt; Proxy -&gt; Throttle Setting</code>，进行设置，如下图：</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303172059341.png"                                     ></p><ol start="2"><li>其次，如果只想模拟指定网站的慢速网络，再勾选 <code>only for selected hosts</code> 项，然后在对话框的下部分设置中 <code>add</code> 指定的 <code>hosts</code> 项即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OCRunloop02：runtime初探</title>
      <link href="/BboyZJ.github.io/2020/08/11/OCRuntime&amp;Runloop/OCRuntime01%EF%BC%9Aruntime%E5%88%9D%E6%8E%A2/"/>
      <url>/BboyZJ.github.io/2020/08/11/OCRuntime&amp;Runloop/OCRuntime01%EF%BC%9Aruntime%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Runtime简介"><a href="#Runtime简介" class="headerlink" title="Runtime简介"></a>Runtime简介</h1><p><code>Object_C</code> 是一门动态语言，所以它总是想办法把一些决定工作 <code>从编译器推迟到运行时</code>。也就是说只有编译器是不够的，还需要一个运行时系统 (runtime system) 来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个Objc运行框架的一块基石。</p><h1 id="什么是Runtime？"><a href="#什么是Runtime？" class="headerlink" title="什么是Runtime？"></a>什么是Runtime？</h1><ul><li><p>我们都知道，将源代码转换为可执行的程序，通常要经过四个步骤：<code>预处理、编译、汇编、链接</code>。不同的编译语言，在这四个步骤中所进行的操作又有些不同。</p></li><li><p><code>C/C++</code> 是 <code>静态语言</code> 的代表，它们在编译阶段就已经确定好了要调用的函数，以及函数的实现，如果函数未实现就会编译报错。</p></li><li><p><code>Runtime</code> 又叫 <code>运行时</code>，是一套底层C语言的API，OC就是运行时机制，其中最主要的是 <code>消息机制</code> 。对于OC的函数，属于动态调用过程，在 <code>编译</code> 的时候并不能决定真正调用哪个函数，只有在真正 <code>运行</code> 的时候才会根据函数的名称找到对应的函数来调用。</p></li></ul><h1 id="运行时概念？"><a href="#运行时概念？" class="headerlink" title="运行时概念？"></a>运行时概念？</h1><p>运行时：把函数的调用从 <code>编译阶段</code> 推迟到 <code>运行时阶段</code> 的能力</p><h1 id="多态概念"><a href="#多态概念" class="headerlink" title="多态概念?"></a>多态概念?</h1><p>多态：不同对象以自己的方式响应相同的消息的能力叫做多态。</p><h1 id="消息机制的基本原理"><a href="#消息机制的基本原理" class="headerlink" title="消息机制的基本原理"></a>消息机制的基本原理</h1><p>OC的方法调用都是类似 <code>[receiver selector]</code> 的形式，其实每次都是一个运行时消息发送过程。</p><ol><li>编译阶段：[receiver selector]方法被编译器转化：</li></ol><ul><li>objc_msgSend(receiver，selector)（不带参数）</li><li>objc_msgSend(recevier，selector，org1，org2，…)（带参数）</li></ul><ol start="2"><li>运行时阶段：消息接收者 recever 寻找对应的 selector：</li></ol><ul><li>recever能找到对应的selector，直接执行接收receiver对象的selector方法。</li><li>recever找不到对应的selector，消息被转发或者临时向recever添加这个selector对应的实现内容，否则崩溃。</li></ul><h1 id="Runtime中的数据结构"><a href="#Runtime中的数据结构" class="headerlink" title="Runtime中的数据结构"></a>Runtime中的数据结构</h1><p>Runtime代码如何查看呢，我们可以通过下面的方式：我们也可以通过组合键 [Cmd + Shift + O ] ，搜索相关文件进入查看。</p><ol><li>objc_msgSend</li></ol><p>Objective-C方法调用在编译时都会转化为对应C函数的调用：objc_msgSend(receiver，selector)。</p><ol start="2"><li>Object（实例）</li></ol><p>objc.h中，我们来看一下Object（对象），是如何定义的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/// Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure><p>我们知道 <code>id</code> 是一种通用的对象类型，它可以指向属于任何类的对象。在这里id被定义为一个指向 objc_object结构体的指针。</p><p>而 <code>objc_object结构体</code> 只包含一个 <code>Class</code> 类型的 <code>isa指针</code>，也就是说，一个Object（对象）唯一 <code>保存</code> 的就是它所属 <code>Class（类）</code> 的 <code>地址</code>。下面我们看一下Class是如何定义的。</p><ol start="3"><li>Class（类）</li></ol><p>在objc&#x2F;objc.h中，可以看到Class是一个指向objc_class结构体的指针：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents an Objective-C class.</span><br><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure><p>在objc&#x2F;runtime.h中，是objc_object结构体的具体定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">        Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">    #if !__OBJC2__</span><br><span class="line">        Class _Nullable super_class // 指向父类的指针;</span><br><span class="line">        const char * _Nonnull name  // 类名;</span><br><span class="line">        long version                // 类的版本信息，默认为 0;</span><br><span class="line">        long info                   // 类的信息，供运行期使用的一些位标识;</span><br><span class="line">        long instance_size          // 该类的实例变量大小;</span><br><span class="line">        struct objc_ivar_list * _Nullable ivars  // 该类的实例变量列表;</span><br><span class="line">        struct objc_method_list * _Nullable * _Nullable methodLists // 方法定义列表 ;</span><br><span class="line">        struct objc_cache * _Nonnull cache  // 方法缓存;</span><br><span class="line">        struct objc_protocol_list * _Nullable protocols  // 遵守的协议列表;</span><br><span class="line">    #endif</span><br><span class="line"></span><br><span class="line">    &#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>我们可以看到 <code>objc_class结构体</code> 中定义了很多的 <code>成员变量</code>：<code>指向父类的指针、类的名字、版本、实例大小、实例变量列表、方法列表、缓存、遵守的协议列表等</code>。这个结构体存放的数据称为元数据(metadata)。</p><p>我们还能注意到 <code>objc_class</code> 结构体中也有一个 <code>isa指</code>针。这就说明了Class本身其实也是一个对象，因此我们称之为 <code>类对象</code>，类对象在编译期产生，<code>用于创建实例对象</code>，是单例。</p><ol start="4"><li>元类(Meta Class)：</li></ol><ul><li><p>我们可以发现 <code>实例对象和类对象结构体中</code> 都拥有一个 <code>isa指针</code>，<code>实例对象的isa指针指向他所属的类（Class）</code>，那么类对象的isa指针指向哪儿里呢？</p></li><li><p><code>类对象的isa指针指向了元类</code>，元类(Meta Class)是一个类对象的类。在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。</p></li><li><p>为了调用类方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念，元类中保存了创建类对象以及类方法所需的所有信息。</p></li></ul><ol start="5"><li>实例对象、类、元类之间的关系</li></ol><p>们已经了解了 <code>实例对象（Object）、类（Class）、Meta Class（元类）</code> 的基本概念。</p><p>下面，我们通过一张图，来清晰的了解下它们之间的继承关系，以及isa的指向关系：</p><p><img src="https://user-images.githubusercontent.com/25925248/90475834-e005bc80-e15a-11ea-8d41-f546d1d1e2d8.png"></p><p>isa指针指向：</p><ul><li>实例对象的isa指针指向了对应的类对象，而类对象的isa指针指向了对应的元类。</li><li>所有元类的isa指针最终指向了NSObject元类，因此NSObject元类也被称为根元类。根元类的isa指针又指向了自己。</li></ul><p>super_class指针指向：</p><ul><li>类对象的super_class指针指向了父类对象，父类对象又指向了根类对象，根类对象最终指向了nil。</li><li>元类的super_class指针指向了父元类。父元类又指向了根元类。而根元类的super_class指针指向了根类对象，最终指向了nil。</li></ul><ol start="6"><li>Method（方法）</li></ol><p>object_class 中 methodLists（方法列表）存放的元素就是Method（方法）。</p><p>在objc&#x2F;runtime.h中，看下定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents a method in a class definition.</span><br><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name                    // 方法名;</span><br><span class="line">    char * _Nullable method_types               // 方法类型;</span><br><span class="line">    IMP _Nonnull method_imp                     // 方法实现;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）SEL（方法名）</p><p><code>SEL是一个指向objc_selector结构体的指针</code>，然而我们并不能在Runtime中找到它的结构体的详细定义。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。</p><p>2）IMP（方法实现）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// A pointer to the function of a method implementation. </span><br><span class="line">#if !OBJC_OLD_DISPATCH_PROTOTYPES</span><br><span class="line">typedef void (*IMP)(void /* id, SEL, ... */ ); </span><br><span class="line">#else</span><br><span class="line">typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><code>IMP</code> 的实质是一个 <code>函数指针</code>，它指向了方法实现的首地址。IMP用来找到函数地址，然后执行函数。</p><p>3）char * method_types （方法类型）</p><p>方法类型method_types是个字符串，用来 <code>存储方法的参数类型和返回值类型</code>。</p><p>总结：</p><p>到这里，Method的结构就已经很清楚了，Method将SEL（方法名） 和IMP（函数指针）关联起来，当对一个对象发送消息时，会通过给出的SEL（方法名）去找到IMP（函数指针），然后执行。</p><ol start="7"><li>类缓存(objc_cache)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_cache *Cache                             OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">struct objc_cache &#123;</span><br><span class="line">    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;</span><br><span class="line">    unsigned int occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method _Nullable buckets[1]                              OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>objc_cache用于缓存最近使用的方法。一个类只有一部分方法是常用的，每次调用一个方法之后，这个方法就被缓存到objc_cache中，下次调用时runtime会先在objc_cache中查找，如果objc_cache中没有，才会去methodList中查找。相比直接在类的方法列表中遍历查找，效率更高。</p><h1 id="深入理解Rutime消息发送"><a href="#深入理解Rutime消息发送" class="headerlink" title="深入理解Rutime消息发送"></a>深入理解Rutime消息发送</h1><ol><li>我们在分析了OC语言对应的底层C结构之后，现在可以进一步理解运行时的消息发送机制。先前讲到，OC调用方法被编译转化为如下的形式：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id _Nullable objc_msgSend(id _Nullable self, SEL _Nonnull op, ...)</span><br></pre></td></tr></table></figure><p>最后一步中我们提到：若找不到对应的selector，消息被转发或者临时向recevier添加这个selector应的实现方法，否则就会发生崩溃。</p><ol start="2"><li>当一个方法找不到的时候，Runtime提供了 <code>动态方法决议、消息快速转发、消息慢速转发</code> 三种方法来处理，这三种方法的调用关系如下图：</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/90476386-01b37380-e15c-11ea-90a4-165aeaed408d.png"></p><ul><li>动态方法决议 (Dynamic Method Resolution)</li></ul><p>所谓动态方法决议，我们可以理解为通过 <code>cache和方法列表没有找到方法</code> 时，Runtime为我们提供一次 <code>动态添加方法实现</code> 的机会，主要用到的方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// OC方法：</span><br><span class="line">// 类方法未找到时调起，可于此添加类方法实现</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel</span><br><span class="line">// 实例方法未找到时调起，可于此添加实例方法实现</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line"></span><br><span class="line">// Runtime方法：</span><br><span class="line">/**</span><br><span class="line"> 运行时方法：向指定类中添加特定方法实现的操作</span><br><span class="line"> @param cls 被添加方法的类</span><br><span class="line"> @param name selector方法名</span><br><span class="line"> @param imp 指向实现方法的函数指针</span><br><span class="line"> @param types imp函数实现的返回值与参数类型</span><br><span class="line"> @return 添加方法是否成功</span><br><span class="line"> */</span><br><span class="line">BOOL class_addMethod(Class _Nullable cls,</span><br><span class="line">                     SEL _Nonnull name,</span><br><span class="line">                     IMP _Nonnull imp,</span><br><span class="line">                     const char * _Nullable types)</span><br></pre></td></tr></table></figure><p>下面使用一个示例来说明动态解析：ViewController类中声明方法却未添加实现，我们通过Runtime动态方法解析的操作为其添加方法实现，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    //实例方法</span><br><span class="line">    [self performSelector:@selector(run)];</span><br><span class="line">    </span><br><span class="line">    //类方法</span><br><span class="line">    [[self class] performSelector:@selector(walk)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//重写父类方法：处理实例方法</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    if (sel == @selector(run)) &#123;</span><br><span class="line">        class_addMethod([self class], sel, class_getMethodImplementation([self class], @selector(zj_run)), &quot;v@&quot;);</span><br><span class="line">        //添加函数实现，返回YES</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//重写父类方法：处理类方法</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel&#123;</span><br><span class="line">    if (sel == @selector(walk)) &#123;</span><br><span class="line">        class_addMethod(object_getClass(self), sel, class_getMethodImplementation(object_getClass(self), @selector(zj_walk)), &quot;v@&quot;);</span><br><span class="line">        //添加函数实现，返回YES</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [class_getSuperclass(self) resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)zj_run&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)zj_walk&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>代码没有崩溃，并打印如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-08-18 14:32:15.894246+0800 iOS-OC之Runtime初探[7151:292311] -[ViewController zj_run]</span><br><span class="line">2020-08-18 14:32:15.894530+0800 iOS-OC之Runtime初探[7151:292311] +[ViewController zj_walk]</span><br></pre></td></tr></table></figure><p>class_addMethod 方法中的特殊参数“v@”，具体可参考官方文档中关于 Type Encodings 的说明：<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100">点击查看</a></p><p>这里+resolveInstanceMethod:或者 +resolveClassMethod:无论是返回YES，还是返回NO，只要其中没有添加其他函数实现，Runtime都会进行下一步：消息接受者重定向。</p><ul><li>消息快速转发</li></ul><p>这一步会调用下面两个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 重定向类方法的消息接收者，返回一个类</span><br><span class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line"></span><br><span class="line">//重定向实例方法的消息接受者，返回一个实例对象</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure><p>如果当前对象实现了这两个方法，Runtime就会调用这两个方法，允许我们将消息的接受者转发给其他对象。</p><p>下面使用一个示例来说明快速消息转发：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong)Person * person;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    //实例方法</span><br><span class="line">    [self performSelector:@selector(run)];</span><br><span class="line">    </span><br><span class="line">    //类方法</span><br><span class="line">    [[self class] performSelector:@selector(walk)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -快速消息转发</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    if (aSelector == @selector(run)) &#123;</span><br><span class="line">        return self.person;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">//重定向类方法：返回一个类对象</span><br><span class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector == @selector(walk)) &#123;</span><br><span class="line">        return [Person class];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Person *)person&#123;</span><br><span class="line">    if (!_person) &#123;</span><br><span class="line">        _person = [Person new];</span><br><span class="line">    &#125;</span><br><span class="line">    return _person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码没有崩溃，并打印如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-08-18 14:51:50.445418+0800 iOS-OC之Runtime初探[7662:318157] -[Person run]</span><br><span class="line">2020-08-18 14:51:50.455564+0800 iOS-OC之Runtime初探[7662:318157] +[Person walk]</span><br></pre></td></tr></table></figure><p>动态方法解析阶段无效时，我们可以通过forwardingTargetForSelector修改消息的接收者，该方法返回参数是一个对象，如果这个对象是非nil，非self，系统会将运行的消息转发给这个对象执行。否则，进行下一步：完成消息转发。</p><p><strong>3）慢速消息转发机制</strong><br>1）这一步中首先会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil ，Runtime则会发出-doesNotRecognizeSelector: 消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送 -forwardInvocation:消息给目标对象。</p><p>2）作用：</p><ul><li>methodSignatureForSelector函数签名的作用：<em>必须重新这个方法，消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象</em></li><li>forwardInvocation：除了发送消息给目标对象外，还可以防止崩溃</li></ul><p>3）看下方法的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 获取类方法函数的参数和返回值类型，返回签名</span><br><span class="line">+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line"></span><br><span class="line">// 类方法消息重定向</span><br><span class="line">+ (void)forwardInvocation:(NSInvocation *)anInvocation；</span><br><span class="line"></span><br><span class="line">// 获取对象方法函数的参数和返回值类型，返回签名</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line"></span><br><span class="line">// 对象方法消息重定向</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation；</span><br></pre></td></tr></table></figure><p>4)下面使用一个示例来说明慢速消息转发:<br>person</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (void)run&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)walk&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ViewController</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong)Person * person;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    //实例方法</span><br><span class="line">    [self performSelector:@selector(run)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//动态方法解析</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    return YES;// 返回YES，进入下一步转发</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//快速消息转发</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    return nil;// 返回nil，进入下一步转发</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取函数的参数和返回值类型，返回签名</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;run&quot;]) &#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];// 签名，进入forwardInvocation</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消息重定向</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    SEL sel = anInvocation.selector;// 从anInvocation中获取消息</span><br><span class="line">    Person *p = [Person new];</span><br><span class="line">    if([p respondsToSelector:sel]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:p];// 将消息转发给其他对象处理</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        [self doesNotRecognizeSelector:sel];// 报错，代码崩溃</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Person *)person&#123;</span><br><span class="line">    if (!_person) &#123;</span><br><span class="line">        _person = [Person new];</span><br><span class="line">    &#125;</span><br><span class="line">    return _person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>代码没有崩溃，并打印如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-08-18 15:01:42.400956+0800 iOS-OC之Runtime初探[7714:323673] -[Person run]</span><br></pre></td></tr></table></figure><p>这一步中，通过签名，Runtime生成了一个对象anInvocation，发送给了forwardInvocation，我们在forwardInvocation方法里面让Person对象去执行了walk函数。</p><p>以上就是Runtime的三次转发流程。</p><h1 id="消息发送流程总结"><a href="#消息发送流程总结" class="headerlink" title="消息发送流程总结"></a>消息发送流程总结</h1><p>调用[receiver selector]后，进行的流程：</p><p>1.编译阶段：[receiver selector]方法被编译器转化：</p><ul><li>objc_msgSend(receiver，selector)（不带参数）。</li><li>objc_msgSend(recevier，selector，org1，org2，…)（带参数）。</li></ul><p>2.运行时阶段：recevier寻找对应的selector：</p><ul><li>通过recevier的isa指针找到recevier的class（类）。</li><li>在Class（类）的cache（方法缓存）中寻找对应的selector。</li><li>如果在cache（方法缓存）中没有找到对应的 selector ，就继续在Class（类）的methodList（方法列表）中查找，如果找到，缓存到cache 中，并返回selector。</li><li>如果在class（类）中没有找到这个selector，就继续在它的superclass（父类）中寻找。</li><li>一旦找到selector，直接执行相关联的IMP（方法实现）。</li><li>若找不到对应的selector，Runtime系统进入消息转发阶段。</li></ul><p>3.消息转发阶段：</p><ul><li><p>动态解析：通过重写+resolveInstanceMethod: 或者+resolveClassMethod:方法，利用 class_addMethod方法添加其他函数实现。</p></li><li><p>快速转发阶段：如果上一步没有添加其他函数实现，可在当前对象中利用 forwardingTargetForSelector:方法将消息的接受者转发给其他对象。</p></li><li><p>慢速转发阶段：如果上一步返回值为nil，则利用 methodSignatureForSelector:方法获取函数的参数和返回值类型。</p></li><li><p>如果methodSignatureForSelector:返回nil。则 Runtime系统会发出doesNotRecognizeSelector:消息，程序也就崩溃了。</p></li><li><p>如果methodSignatureForSelector:返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送-forwardInvocation:消息给目标对象。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-Runloop探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC：多线程探索</title>
      <link href="/BboyZJ.github.io/2020/08/11/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A016%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/BboyZJ.github.io/2020/08/11/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A016%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol><li>进程</li></ol><ul><li>在系统中正在运行的一个应用程序</li><li>每个进程之间是独立的,它们均运行在其专用且受保护的内存空间内.若你此时打开了微信,又打开了QQ音乐,则系统会分别启动两个进程.</li><li>iOS开发都是单进程,安卓可以支持多进程</li><li>进程可以控制很多条线程来执行相应的任务</li><li>进程至少要有一条线程,用来执行任务</li></ul><ol start="2"><li>线程</li></ol><ul><li>是进程的基本执行单元,1个进程若想执行任务,至少要有一个线程</li><li>系统会默认开启一条线程,称为主线程或UI线程</li><li>线程上的任务执行完毕后,线程会自动销毁</li><li>但是开辟线程要耗费一定的内存空间,会耗时,异步不会堵塞线程,会先执行下面的语句,就是因为辟线程耗时了</li><li>我们开辟线程时有时会给他们命名,这样是为了打断点调试时能看到调用的堆栈信息</li></ul><ol start="3"><li>主线程</li></ol><p>处理UI，所有更新UI的操作都必须在主线程上执行。不要把耗时操作放在主线程，界面会卡。</p><ol start="4"><li>多线程</li></ol><p>在同一时刻，一个CPU只能处理1条线程，但CPU可以在多条线程之间快速的切换，只要切换的足够快，就造成了多线程一同执行的假象。</p><ol start="5"><li>同步和异步</li></ol><ul><li>同步：在当前线程中执行任务，不具备开启新线程的能力；</li><li>异步：在新的线程中执行任务,具备开启新线程的能力；</li><li>同步函数(dispatch中的sync函数)：<ul><li>在当前线程中执行队列里面的任务，不具备开启线程的能力；</li><li>立马在当前线程执行任务，执行完毕后才能继续往下执行</li><li>阻塞当前线程，即同步函数内的任务不执行完，该函数就会卡住，不会继续往下执行；</li></ul></li><li>异步函数(dispatch中的async函数)：<ul><li>在新的线程中执行队列里面的任务，具备开启线程的能力；</li><li>不阻塞当前线程，不用管当前的任务是否完成，都会往下执行；</li><li>会有一段时间去执行线程中的任务，因此后面的任务可能会在它之前执行；</li></ul></li></ul><ol start="6"><li>串行和并发</li></ol><ul><li>串行队列(DISPATCH_QUEUE_SERIAL )：一个任务执行完成后,再执行下一个任务。</li><li>并发队列(DISPATCH_QUEUE_CONCURRENT)：多个任务并发(同时)执行；</li></ul><h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><ol><li><p>地址空间<br>  进程之间是独立的地址空间,但同一进程的线程共享本进程的地址空间</p></li><li><p>资源拥有<br> 进程之间的资源是独立的,但同一进程的线程共享本进程的资源(如内存,I&#x2F;O,cpu等)</p></li><li><p>线程是处理器调度的基本单位,但进程不是,意思是CPU调度是调度线程</p></li><li><p>执行过程<br>进程可以独立执行,每个独立的进程都有一个程序运行的入口<br>线程不能独立执行,必须存活在应用程序中</p></li><li><p>崩溃<br>  进程崩溃时,对其他进程没有影响<br>  线程崩溃时,整个进程就死掉了<br>  多进程比多线程健壮</p></li></ol><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ol><li><p>多线程的原理：<br>CPU在单位时间片里快速的在各个线程之间切换</p></li><li><p>多线程的意义：</p></li></ol><p>优点： </p><ul><li>提高执行效率</li><li>提高资源(CPU,内存)利用率</li><li>线程执行完任务后,会自动销毁</li></ul><p>缺点：</p><ul><li>开启线程需要占用一定的内存空间,进行耗时</li><li>线程越多,耗时越多,会降低程序的性能,也会增大CPU在调用线程上的开销</li><li>程序设计会更加复杂,比如线程间的通信,多线程的数据共享</li></ul><h1 id="实现多线程的几种方式"><a href="#实现多线程的几种方式" class="headerlink" title="实现多线程的几种方式"></a>实现多线程的几种方式</h1><ol><li>NSThread</li><li>GCD</li><li>NSOperation</li></ol><h1 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h1><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li>优点：NSThread比其他两个轻量级；</li><li>缺点：需要自己管理线程的生命周期，线程同步，线程同步时对数据的加锁会有一定的系统开销。</li></ul><h2 id="NSThread的使用"><a href="#NSThread的使用" class="headerlink" title="NSThread的使用"></a>NSThread的使用</h2><p>优点：NSThread比其他两个轻量级；<br>缺点：需要自己管理线程的生命周期，线程同步，线程同步时对数据的加锁会有一定的系统开销。</p><ol><li>实例方法创建NSThread</li></ol><ul><li>实例方法创建的NSThread对象，我们需要手动调用方法[thread start]来启动线程，实际上都是开辟了一个子线程。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo&#123;</span><br><span class="line">    //第一种方法：block方式</span><br><span class="line">    NSThread * thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">    [thread start];</span><br><span class="line">    </span><br><span class="line">    //第二种方法：SEL方式</span><br><span class="line">    NSThread * thread1 = [[NSThread alloc] initWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [thread1 start];</span><br><span class="line">&#125;</span><br><span class="line">- (void)run&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*********打印结果********</span><br><span class="line">2020-08-13 15:19:24.874162+0800 OC-多线程之NSThread[43983:2668593] &lt;NSThread: 0x600002269a80&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-13 15:19:24.874219+0800 OC-多线程之NSThread[43983:2668594] &lt;NSThread: 0x600002269800&gt;&#123;number = 7, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>2.类方法创建NSThread</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//类方法创建</span><br><span class="line">- (void)demo1&#123;</span><br><span class="line">    //block</span><br><span class="line">    [NSThread detachNewThreadWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //SEL</span><br><span class="line">    [NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*********打印结果********</span><br><span class="line">2020-08-13 15:24:21.931115+0800 OC-多线程之NSThread[44042:2672229] &lt;NSThread: 0x600001314480&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-13 15:24:21.931220+0800 OC-多线程之NSThread[44042:2672230] &lt;NSThread: 0x600001308a80&gt;&#123;number = 6, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>3.NSThread的其他方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//获取当前线程</span><br><span class="line">@property (class, readonly, strong) NSThread *currentThread;</span><br><span class="line"></span><br><span class="line">设置线程沉睡到指定日期</span><br><span class="line">+ (void)sleepUntilDate:(NSDate *)date;</span><br><span class="line">  </span><br><span class="line">线程沉睡时间间隔，这个方法在设置启动页间隔的时候比较常见</span><br><span class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)ti;</span><br><span class="line">  </span><br><span class="line">线程退出，当执行到某一个特殊情况下的时候你可以退出当前的线程，注意不要在主线程随便调用</span><br><span class="line">+ (void)exit;</span><br><span class="line">  </span><br><span class="line">线程的优先级</span><br><span class="line">+ (double)threadPriority;</span><br><span class="line">  </span><br><span class="line">设置线程的优先级：取值范围0~1，值越大，执行越早</span><br><span class="line">+ (BOOL)setThreadPriority:(double)p;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h2 id="NSObject分类中创建线程的方法"><a href="#NSObject分类中创建线程的方法" class="headerlink" title="NSObject分类中创建线程的方法"></a>NSObject分类中创建线程的方法</h2><p>除了上面的两种方式创建线程外，@interface NSObject (NSThreadPerformAdditions)这个NSObject分类别中也有一些创建线程的方法：<br>1）主线程执行任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">在主线程执行任务</span><br><span class="line">aSelector：一个选择器, 指定要调用的方法</span><br><span class="line">arg：需要传递给调用方法的参数，如果没有需要的参数,传入nil</span><br><span class="line">waitUntilDone：一个布尔值，指定是否阻塞当前线程直到指定选择器在主线程中执行完毕。选择YES会阻塞这个线程；选择NO，本方法会立刻返回。</span><br><span class="line">modes：RunLoop的运行的类型</span><br><span class="line">*/</span><br><span class="line">[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES modes:nil];</span><br><span class="line">[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];</span><br></pre></td></tr></table></figure><p>2)实际使用<br>例子1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    [self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">- (void)run&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*******打印结果******</span><br><span class="line">2020-08-13 23:11:39.640250+0800 OC-多线程之NSThread[45345:2800240] 1</span><br><span class="line">2020-08-13 23:11:39.662218+0800 OC-多线程之NSThread[45345:2800240] &lt;NSThread: 0x600001114480&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结论：waitUntilDone设置为NO，没有堵塞主线程，先打印1，后打印[NSThread currentThread]。</p><p>例子2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES];</span><br></pre></td></tr></table></figure><p>如果将waitUntilDone设置为YES，堵塞主线程，先打印[NSThread currentThread]后打印1</p><p>2.指定线程执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self performSelector:@selector(run) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</span><br><span class="line">[self  performSelector:@selector(run) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO modes:nil];</span><br></pre></td></tr></table></figure><p>3.指定后台执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//后台执行</span><br><span class="line">[self performSelectorInBackground:@selector(run) withObject:nil];</span><br></pre></td></tr></table></figure><p>开启了一个新的线程去执行任务</p><h1 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h1><h2 id="什么是GCD？"><a href="#什么是GCD？" class="headerlink" title="什么是GCD？"></a>什么是GCD？</h2><p>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。</p><h2 id="GCD的优点"><a href="#GCD的优点" class="headerlink" title="GCD的优点?"></a>GCD的优点?</h2><ul><li>GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li><li>GCD更接近底层，性能较高</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h1><h2 id="NSOperation介绍"><a href="#NSOperation介绍" class="headerlink" title="NSOperation介绍"></a>NSOperation介绍</h2><ul><li><p>NSOperation是基于GCD开发的，是GCD更高一层的封装，比GCD拥有更强的可控性和代码可读性。</p></li><li><p>NSOperation是一个抽象基类，表示一个独立的计算单元，可以为子类提供有用且线程安全的建立状态，优先级，依赖和取消等操作。</p></li><li><p>我们使用比较多的就是它的子类NSInvocationOperation和NSBlockOperation。不过我们更多的使用是自己继承并定制自己的操作。</p></li></ul><h2 id="为什么要使用-NSOperation？"><a href="#为什么要使用-NSOperation？" class="headerlink" title="为什么要使用 NSOperation？"></a>为什么要使用 NSOperation？</h2><ul><li>可添加完成的代码块，在操作完成后执行。</li><li>添加操作之间的依赖关系，方便的控制执行顺序。</li><li>设定操作执行的优先级。</li><li>可以很方便的取消一个操作的执行。</li><li>使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。</li></ul><h2 id="NSOperation、NSOperationQueue-操作和操作队列"><a href="#NSOperation、NSOperationQueue-操作和操作队列" class="headerlink" title="NSOperation、NSOperationQueue 操作和操作队列"></a>NSOperation、NSOperationQueue 操作和操作队列</h2><p>既然是基于 GCD 的更高一层的封装。那么，GCD 中的一些概念同样适用于 NSOperation、NSOperationQueue。在 NSOperation、NSOperationQueue 中也有类似的任务（操作）和队列（操作队列）的概念。</p><p>1.操作（Operation）</p><ul><li>执行操作的意思，换句话说就是你在线程中执行的那段代码。</li><li>在 GCD 中是放在 block 中的。在 NSOperation 中，我们使用 NSOperation 子类 NSInvocationOperation、NSBlockOperation，或者自定义子类来封装操作。</li></ul><p>2.操作队列（Operation Queues）：</p><ul><li>这里的队列指操作队列，即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</li><li>操作队列通过设置最大并发操作数（maxConcurrentOperationCount）来控制并发、串行。</li><li>NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。</li></ul><h2 id="NSOperation、NSOperationQueue-使用介绍"><a href="#NSOperation、NSOperationQueue-使用介绍" class="headerlink" title="NSOperation、NSOperationQueue 使用介绍"></a>NSOperation、NSOperationQueue 使用介绍</h2><ul><li><p>NSOperation 需要配合 NSOperationQueue 来实现多线程。因为默认情况下，NSOperation 单独使用时系统同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行。</p></li><li><p>NSOperation 实现多线程的使用步骤分为三步：</p><ul><li>创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。</li><li>创建队列：创建 NSOperationQueue 对象。</li><li>将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。</li></ul></li><li><p>之后呢，系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。</p></li></ul><h2 id="NSOperation的基本使用"><a href="#NSOperation的基本使用" class="headerlink" title="NSOperation的基本使用"></a>NSOperation的基本使用</h2><p><strong>1.使用子类 NSInvocationOperation</strong></p><ul><li>在主线程执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo&#123;</span><br><span class="line">    //1.创建NSInvocationOperation 对象</span><br><span class="line">    NSInvocationOperation * operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">    //2.调用 start 方法开始执行操作</span><br><span class="line">    [operation start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**********打印结果**********</span><br><span class="line">2020-08-16 11:59:20.701876+0800 OC-NSOperation[1670:53602] &lt;NSThread: 0x600003f28d40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到：在没有使用 NSOperationQueue、在主线程中单独使用使用子类 NSInvocationOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。</p><ul><li>在子线程执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo&#123;</span><br><span class="line">    //3.在其他线程使用</span><br><span class="line">    [NSThread detachNewThreadWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        //1.创建NSInvocationOperation 对象</span><br><span class="line">        NSInvocationOperation * operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">        //2.调用 start 方法开始执行操作</span><br><span class="line">        [operation start];</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run&#123;</span><br><span class="line">    NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**********打印结果**********</span><br><span class="line">2020-08-16 12:06:20.454733+0800 OC-NSOperation[1782:60475] 1---&lt;NSThread: 0x600000cfe200&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 12:06:20.455356+0800 OC-NSOperation[1782:60475] 2---&lt;NSThread: 0x600000cfe200&gt;&#123;number = 6, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>可以看到：在其他线程中单独使用子类 NSInvocationOperation，操作是在当前调用的其他线程执行的，并没有开启新线程。</p><p><strong>2.使用子类 NSBlockOperation</strong></p><ul><li>在主线程使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo1&#123;</span><br><span class="line">    //1.创建 NSBlockOperation 对象</span><br><span class="line">    NSBlockOperation * operation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        //打印当前线程</span><br><span class="line">        NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    //2.调用 start 方法开始执行操作</span><br><span class="line">    [operation start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*********打印结果**********</span><br><span class="line">2020-08-16 12:09:47.030187+0800 OC-NSOperation[1837:63421] &lt;NSThread: 0x6000034b0380&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure><p>可以看到：在没有使用 NSOperationQueue、在主线程中单独使用 NSBlockOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。</p><p>注意：和上边 NSInvocationOperation 使用一样。因为代码是在主线程中调用的，所以打印结果为主线程。如果在其他线程中执行操作，则打印结果为其他线程。</p><p>但是，NSBlockOperation 还提供了一个方法 addExecutionBlock:，通过 addExecutionBlock: 就可以为 NSBlockOperation 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中同时（并发）执行。只有当所有相关的操作已经完成执行时，才视为完成。</p><p>如果添加的操作多的话，blockOperationWithBlock: 中的操作也可能会在其他线程（非当前线程）中执行，这是由系统决定的，并不是说添加到 blockOperationWithBlock: 中的操作一定会在当前线程中执行。（可以使用 addExecutionBlock: 多添加几个操作试试）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo1&#123;</span><br><span class="line">    //1.创建 NSBlockOperation 对象</span><br><span class="line">    NSBlockOperation * operation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        //打印当前线程</span><br><span class="line">        NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //2.添加额外的操作</span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">        //打印当前线程</span><br><span class="line">        NSLog(@&quot;1-%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">        //打印当前线程</span><br><span class="line">        NSLog(@&quot;2-%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">        //打印当前线程</span><br><span class="line">        NSLog(@&quot;3-%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">        //打印当前线程</span><br><span class="line">        NSLog(@&quot;4-%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //调用 start 方法开始执行操作</span><br><span class="line">    [operation start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**********打印结果********</span><br><span class="line">2020-08-16 12:13:40.905153+0800 OC-NSOperation[1926:67565] 1-&lt;NSThread: 0x6000032c4f80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 12:13:40.905162+0800 OC-NSOperation[1926:67564] 2-&lt;NSThread: 0x6000032be140&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 12:13:40.905168+0800 OC-NSOperation[1926:67563] 3-&lt;NSThread: 0x6000032cd180&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-16 12:13:40.905186+0800 OC-NSOperation[1926:67504] &lt;NSThread: 0x60000328c240&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-08-16 12:13:40.905385+0800 OC-NSOperation[1926:67565] 4-&lt;NSThread: 0x6000032c4f80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出：使用子类 NSBlockOperation，并调用方法 AddExecutionBlock: 的情况下，blockOperationWithBlock:方法中的操作 和 addExecutionBlock: 中的操作是在不同的线程中并发执行的。而且，这次执行结果中 blockOperationWithBlock:方法中的操作也不是在当前线程（主线程）中执行的。从而印证了blockOperationWithBlock: 中的操作也可能会在其他线程（非当前线程）中执行。</p><p>一般情况下，如果一个 NSBlockOperation 对象封装了多个操作。NSBlockOperation 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。</p><p><strong>3.使用自定义继承自 NSOperation 的子类</strong><br>如果使用子类 NSInvocationOperation、NSBlockOperation 不能满足日常需求，我们可以使用自定义继承自 NSOperation 的子类。可以通过重写 main 或者 start 方法 来定义自己的 NSOperation 对象。重写main方法比较简单，我们不需要管理操作的状态属性 isExecuting 和 isFinished。当 main 执行完返回的时候，这个操作就结束了。</p><ul><li>在主线程中使用<br>先定义一个继承自 NSOperation 的子类，重写main方法。<br>.h文件中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface ZJOperation : NSOperation</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>.m文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJOperation.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZJOperation</span><br><span class="line">- (void)main&#123;</span><br><span class="line">    if (!self.cancelled) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;ZJ---%@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在其他类中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo2&#123;</span><br><span class="line">    //1.创建ZJOperation对象</span><br><span class="line">    ZJOperation * operation = [[ZJOperation alloc] init];</span><br><span class="line">    //2.调用 start 方法开始执行操作</span><br><span class="line">    [operation start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*******打印结果******</span><br><span class="line">2020-08-16 12:24:16.940268+0800 OC-NSOperation[2093:75334] ZJ---&lt;NSThread: 0x600001994380&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-08-16 12:24:18.941867+0800 OC-NSOperation[2093:75334] ZJ---&lt;NSThread: 0x600001994380&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure><p>可以看出：在没有使用 NSOperationQueue、在主线程单独使用自定义继承自 NSOperation 的子类的情况下，是在主线程执行操作，并没有开启新线程。</p><ul><li>在子线程中使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo2&#123;</span><br><span class="line">    //1.在子线程中使用</span><br><span class="line">    [NSThread detachNewThreadWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        //1.创建ZJOperation对象</span><br><span class="line">        ZJOperation * operation = [[ZJOperation alloc] init];</span><br><span class="line">        //2.调用 start 方法开始执行操作</span><br><span class="line">        [operation start];</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*******打印结果******</span><br><span class="line">2020-08-16 12:26:04.684475+0800 OC-NSOperation[2117:76849] 1---&lt;NSThread: 0x600003fd6900&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 12:26:06.689546+0800 OC-NSOperation[2117:76849] ZJ---&lt;NSThread: 0x600003fd6900&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 12:26:08.694929+0800 OC-NSOperation[2117:76849] ZJ---&lt;NSThread: 0x600003fd6900&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出：在没有使用 NSOperationQueue、在子线程单独使用自定义继承自 NSOperation 的子类的情况下，是在子线程执行操作，没有开启新线程。</p><h2 id="NSOperationQueue的基本使用"><a href="#NSOperationQueue的基本使用" class="headerlink" title="NSOperationQueue的基本使用"></a>NSOperationQueue的基本使用</h2><p>NSOperationQueue 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。下边是主队列、自定义队列的基本创建方法和特点。</p><ul><li>主队列：凡是添加到主队列中的操作，都会放到主线程中执行（注：不包括操作使用addExecutionBlock:添加的额外操作，额外操作可能在其他线程执行，感谢指正）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 主队列获取方法</span><br><span class="line">NSOperationQueue *queue = [NSOperationQueue mainQueue];</span><br></pre></td></tr></table></figure><ul><li>自定义队列（非主队列）：添加到这种队列中的操作，就会自动放到子线程中执行。同时包含了：串行、并发功能。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 自定义队列创建方法</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br></pre></td></tr></table></figure><p><strong>1.将操作加入到队列中</strong><br>上边我们说到 NSOperation 需要配合 NSOperationQueue 来实现多线程。</p><p>那么我们需要将创建好的操作加入到队列中去。总共有两种方法：</p><p>1)- (void)addOperation:(NSOperation *)op;<br>需要先创建操作，再将创建好的操作加入到创建好的队列中去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo3&#123;</span><br><span class="line">    //1.创建队列</span><br><span class="line">    NSOperationQueue * queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    </span><br><span class="line">    // 2.创建操作</span><br><span class="line">    // 使用 NSInvocationOperation 创建操作1</span><br><span class="line">    NSInvocationOperation * op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line"></span><br><span class="line">    // 使用 NSBlockOperation 创建操作3</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        // 打印当前线程</span><br><span class="line">        NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [op2 addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 3.使用 addOperation: 添加所有操作到队列中</span><br><span class="line">    [queue addOperation:op1]; // [op1 start]</span><br><span class="line">    [queue addOperation:op2]; // [op2 start]</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run&#123;</span><br><span class="line">    NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*********打印操作*******</span><br><span class="line">2020-08-16 12:37:09.954238+0800 OC-NSOperation[2180:82843] 2---&lt;NSThread: 0x600002018d40&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2020-08-16 12:37:09.954238+0800 OC-NSOperation[2180:82848] 3---&lt;NSThread: 0x60000201db40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2020-08-16 12:37:09.954271+0800 OC-NSOperation[2180:82845] 1---&lt;NSThread: 0x600002062d40&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出：使用 NSOperation 子类创建操作，并使用 addOperation: 将操作加入到操作队列后能够开启新线程，进行并发执行。</p><p>2)- (void)addOperationWithBlock:(void (^)(void))block;<br>无需先创建操作，在 block 中添加操作，直接将包含操作的 block 加入到队列中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo4&#123;</span><br><span class="line">    //1.创建队列</span><br><span class="line">    NSOperationQueue * queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    //2.使用 addOperationWithBlock: 添加操作到队列中</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*********打印操作*******</span><br><span class="line">2020-08-16 12:40:45.166909+0800 OC-NSOperation[2238:85786] 2---&lt;NSThread: 0x60000291a680&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2020-08-16 12:40:45.166909+0800 OC-NSOperation[2238:85788] 1---&lt;NSThread: 0x600002965400&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2020-08-16 12:40:45.166921+0800 OC-NSOperation[2238:85784] 3---&lt;NSThread: 0x600002965540&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出：使用 addOperationWithBlock: 将操作加入到操作队列后能够开启新线程，进行并发执行。</p><p><strong>2.NSOperationQueue 控制串行执行、并发执行</strong></p><p>之前我们说过，NSOperationQueue 创建的自定义队列同时具有串行、并发功能，上边我们演示了并发功能，那么他的串行功能是如何实现的？</p><p>这里有个关键属性 maxConcurrentOperationCount，叫做最大并发操作数。用来控制一个特定队列中可以有多少个操作同时参与并发执行。</p><p><code>注意：这里 maxConcurrentOperationCount 控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。</code></p><ul><li>最大并发操作数：maxConcurrentOperationCount<br>maxConcurrentOperationCount <ul><li>默认情况下为-1，表示不进行限制，可进行并发执行。</li><li>maxConcurrentOperationCount 为1时，队列为串行队列。只能串行执行。</li><li>maxConcurrentOperationCount 大于1时，队列为并发队列。操作并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为 min{自己设定的值，系统设定的默认最大值}。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo5&#123;</span><br><span class="line">    /*</span><br><span class="line">     设置 MaxConcurrentOperationCount（最大并发操作数）</span><br><span class="line">     */</span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue * queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 2.设置最大并发操作数</span><br><span class="line">//    queue.maxConcurrentOperationCount = 1; // 串行队列</span><br><span class="line">// queue.maxConcurrentOperationCount = 2; // 并发队列</span><br><span class="line"> queue.maxConcurrentOperationCount = 8; // 并发队列</span><br><span class="line"></span><br><span class="line">    // 3.添加操作</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最大并发操作数为1 输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-08-16 12:48:09.090860+0800 OC-NSOperation[2324:91784] 1---&lt;NSThread: 0x600002a2e780&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 12:48:09.091107+0800 OC-NSOperation[2324:91784] 2---&lt;NSThread: 0x600002a2e780&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 12:48:09.091296+0800 OC-NSOperation[2324:91784] 3---&lt;NSThread: 0x600002a2e780&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 12:48:09.091446+0800 OC-NSOperation[2324:91784] 4---&lt;NSThread: 0x600002a2e780&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最大并发操作数为2 输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-08-16 12:48:24.421434+0800 OC-NSOperation[2338:92272] 2---&lt;NSThread: 0x600001106780&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 12:48:24.421437+0800 OC-NSOperation[2338:92269] 1---&lt;NSThread: 0x6000011066c0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2020-08-16 12:48:24.421724+0800 OC-NSOperation[2338:92269] 4---&lt;NSThread: 0x6000011066c0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2020-08-16 12:48:24.421733+0800 OC-NSOperation[2338:92272] 3---&lt;NSThread: 0x600001106780&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最大并发操作数为8 输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*******打印结果******8</span><br><span class="line">2020-08-16 12:46:22.158690+0800 OC-NSOperation[2307:90480] 2---&lt;NSThread: 0x6000024003c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 12:46:22.158727+0800 OC-NSOperation[2307:90478] 4---&lt;NSThread: 0x60000240bb00&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-16 12:46:22.158737+0800 OC-NSOperation[2307:90482] 1---&lt;NSThread: 0x600002408ac0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2020-08-16 12:46:22.158760+0800 OC-NSOperation[2307:90485] 3---&lt;NSThread: 0x600002418ac0&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出：当最大并发操作数为1时，操作是按顺序串行执行的，并且一个操作完成之后，下一个操作才开始执行。当最大操作并发数为2时，操作是并发执行的，可以同时执行两个操作。而开启线程数量是由系统决定的，不需要我们来管理。</p><p><strong>3.NSOperationQueue 操作依赖</strong><br>NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。NSOperation 提供了3个接口供我们管理和查看依赖。</p><ul><li>(void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。</li><li>(void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。<br>@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。<br>当然，我们经常用到的还是添加依赖操作。现在考虑这样的需求，比如说有 A、B 两个操作，其中 A 执行完操作，B 才能执行操作。</li></ul><p>如果使用依赖来处理的话，那么就需要让操作 B 依赖于操作 A。具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo5&#123;</span><br><span class="line">    /*</span><br><span class="line">     设置 MaxConcurrentOperationCount（最大并发操作数）</span><br><span class="line">     */</span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue * queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 2.设置最大并发操作数</span><br><span class="line">//    queue.maxConcurrentOperationCount = 1; // 串行队列</span><br><span class="line"> queue.maxConcurrentOperationCount = 2; // 并发队列</span><br><span class="line">// queue.maxConcurrentOperationCount = 8; // 并发队列</span><br><span class="line"></span><br><span class="line">    // 3.添加操作</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)demo6&#123;</span><br><span class="line">    /*</span><br><span class="line">        操作依赖</span><br><span class="line">        使用方法：addDependency:</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 2.创建操作</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 3.添加依赖</span><br><span class="line">    [op2 addDependency:op1]; // 让op2 依赖于 op1，则先执行op1，在执行op2</span><br><span class="line"></span><br><span class="line">    // 4.添加操作到队列中</span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">******打印结果*****</span><br><span class="line">2020-08-16 12:52:02.556360+0800 OC-NSOperation[2376:94789] 1---&lt;NSThread: 0x6000017fe000&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2020-08-16 12:52:02.556627+0800 OC-NSOperation[2376:94792] 2---&lt;NSThread: 0x6000017f4ac0&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到：通过添加操作依赖，无论运行几次，其结果都是 op1 先执行，op2 后执行。</p><p><strong>4.NSOperationQueue 优先级</strong><br>NSOperation 提供了queuePriority（优先级）属性，queuePriority属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是NSOperationQueuePriorityNormal。但是我们可以通过setQueuePriority:方法来改变当前操作在同一队列中的执行优先级。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 优先级的取值</span><br><span class="line">typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123;</span><br><span class="line">    NSOperationQueuePriorityVeryLow = -8L,</span><br><span class="line">    NSOperationQueuePriorityLow = -4L,</span><br><span class="line">    NSOperationQueuePriorityNormal = 0,</span><br><span class="line">    NSOperationQueuePriorityHigh = 4,</span><br><span class="line">    NSOperationQueuePriorityVeryHigh = 8</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上边我们说过：对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</p><p><strong>那么，什么样的操作才是进入就绪状态的操作呢？</strong></p><ul><li><p>当一个操作的所有依赖都已经完成时，操作对象通常会进入准备就绪状态，等待执行。<br>举个例子，现在有4个优先级都是 NSOperationQueuePriorityNormal（默认级别）的操作：op1，op2，op3，op4。其中 op3 依赖于 op2，op2 依赖于 op1，即 op3 -&gt; op2 -&gt; op1。现在将这4个操作添加到队列中并发执行。</p></li><li><p>因为 op1 和 op4 都没有需要依赖的操作，所以在 op1，op4 执行之前，就是处于准备就绪状态的操作。<br>而 op3 和 op2 都有依赖的操作（op3 依赖于 op2，op2 依赖于 op1），所以 op3 和 op2 都不是准备就绪状态下的操作。<br>理解了进入就绪状态的操作，那么我们就理解了queuePriority 属性的作用对象。</p></li><li><p>queuePriority 属性决定了进入准备就绪状态下的操作之间的开始执行顺序。并且，优先级不能取代依赖关系。<br>如果一个队列中既包含高优先级操作，又包含低优先级操作，并且两个操作都已经准备就绪，那么队列先执行高优先级操作。比如上例中，如果 op1 和 op4 是不同优先级的操作，那么就会先执行优先级高的操作。<br>如果，一个队列中既包含了准备就绪状态的操作，又包含了未准备就绪的操作，未准备就绪的操作优先级比准备就绪的操作优先级高。那么，虽然准备就绪的操作优先级低，也会优先执行。优先级不能取代依赖关系。如果要控制操作间的启动顺序，则必须使用依赖关系。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo6&#123;</span><br><span class="line">    /*</span><br><span class="line">        操作依赖</span><br><span class="line">        使用方法：addDependency:</span><br><span class="line">        优先级：setQueuePriority</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 2.创建操作</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [op1 setQueuePriority:NSOperationQueuePriorityLow];</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [op2 setQueuePriority:NSOperationQueuePriorityVeryHigh];</span><br><span class="line"></span><br><span class="line">    NSBlockOperation * op3 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [op3 setQueuePriority:NSOperationQueuePriorityHigh];</span><br><span class="line">    </span><br><span class="line">    // 3.添加依赖</span><br><span class="line">    [op2 addDependency:op1]; // 让op2 依赖于 op1，则先执行op1，在执行op2</span><br><span class="line"></span><br><span class="line">    // 4.添加操作到队列中</span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">    [queue addOperation:op3];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">********打印结果*******</span><br><span class="line">2020-08-16 13:38:09.628886+0800 OC-NSOperation[2556:109314] 3---&lt;NSThread: 0x6000039d1880&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2020-08-16 13:38:09.628901+0800 OC-NSOperation[2556:109318] 1---&lt;NSThread: 0x6000039dcd80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2020-08-16 13:38:09.629143+0800 OC-NSOperation[2556:109318] 2---&lt;NSThread: 0x6000039dcd80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由打印结果可知：优先级高的限制性，再执行优先级低的，再执行依赖关系的</p><h2 id="NSOperation、NSOperationQueue-线程间的通信"><a href="#NSOperation、NSOperationQueue-线程间的通信" class="headerlink" title="NSOperation、NSOperationQueue 线程间的通信"></a>NSOperation、NSOperationQueue 线程间的通信</h2><p>在 iOS 开发过程中，我们一般在主线程里边进行 UI 刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 线程间通信</span><br><span class="line"> */</span><br><span class="line">- (void)demo7 &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc]init];</span><br><span class="line"></span><br><span class="line">    // 2.添加操作</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        // 异步进行耗时操作</span><br><span class="line">        NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line"></span><br><span class="line">        // 回到主线程</span><br><span class="line">        [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            // 进行一些 UI 刷新等操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">   &#125;];</span><br><span class="line">&#125;</span><br><span class="line">***********打印结果********</span><br><span class="line">2020-08-16 13:43:39.078799+0800 OC-NSOperation[2631:113017] 1---&lt;NSThread: 0x60000328d940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2020-08-16 13:43:39.097297+0800 OC-NSOperation[2631:112960] 2---&lt;NSThread: 0x6000032c8e80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到：通过线程间的通信，先在其他线程中执行操作，等操作执行完了之后再回到主线程执行主线程的相应操作</p><h2 id="NSOperation、NSOperationQueue-线程同步和线程安全"><a href="#NSOperation、NSOperationQueue-线程同步和线程安全" class="headerlink" title="NSOperation、NSOperationQueue 线程同步和线程安全"></a>NSOperation、NSOperationQueue 线程同步和线程安全</h2><ul><li><p>线程安全：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。<br>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。</p></li><li><p>线程同步：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。</p></li></ul><p>举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。</p><p>1.例子:下面，我们模拟火车票售卖的方式，实现 NSOperation 线程安全和解决线程同步问题。<br>场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。</p><p>1）先来看看不考虑线程安全的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 非线程安全：不使用 NSLock</span><br><span class="line">* 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票</span><br><span class="line">*/</span><br><span class="line">- (void)demo8&#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程</span><br><span class="line">    </span><br><span class="line">    //总票数</span><br><span class="line">    self.ticketSurplusCount = 10;</span><br><span class="line"></span><br><span class="line">    // 1.创建 queue1,queue1 代表北京火车票售卖窗口</span><br><span class="line">    NSOperationQueue * queue1 = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue1.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    // 2.创建 queue2,queue2 代表上海火车票售卖窗口</span><br><span class="line">    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue2.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    // 3.创建卖票操作 op1</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">       [self saleTicketNotSafe];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 4.创建卖票操作 op2</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">       [self saleTicketNotSafe];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 5.添加操作，开始卖票</span><br><span class="line">    [queue1 addOperation:op1];</span><br><span class="line">    [queue2 addOperation:op2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 售卖火车票(非线程安全)</span><br><span class="line"> */</span><br><span class="line">- (void)saleTicketNotSafe &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        if (self.ticketSurplusCount &gt; 0) &#123;</span><br><span class="line">            //如果还有票，继续售卖</span><br><span class="line">            self.ticketSurplusCount--;</span><br><span class="line">            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%ld 窗口:%@&quot;, (long)self.ticketSurplusCount, [NSThread currentThread]]);</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSLog(@&quot;所有火车票均已售完&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2020-08-16 13:51:15.967134+0800 OC-NSOperation[2709:117554] currentThread---&lt;NSThread: 0x600000170d40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-08-16 13:51:15.970381+0800 OC-NSOperation[2709:117657] 剩余票数:9 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:15.971286+0800 OC-NSOperation[2709:117652] 剩余票数:8 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.171627+0800 OC-NSOperation[2709:117657] 剩余票数:7 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.171722+0800 OC-NSOperation[2709:117652] 剩余票数:6 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.374218+0800 OC-NSOperation[2709:117657] 剩余票数:5 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.374490+0800 OC-NSOperation[2709:117652] 剩余票数:4 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.574756+0800 OC-NSOperation[2709:117657] 剩余票数:3 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.574900+0800 OC-NSOperation[2709:117652] 剩余票数:2 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.778734+0800 OC-NSOperation[2709:117652] 剩余票数:1 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.778655+0800 OC-NSOperation[2709:117657] 剩余票数:1 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.980112+0800 OC-NSOperation[2709:117657] 剩余票数:0 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.980114+0800 OC-NSOperation[2709:117652] 剩余票数:0 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:17.183727+0800 OC-NSOperation[2709:117657] 所有火车票均已售完</span><br><span class="line">2020-08-16 13:51:17.183727+0800 OC-NSOperation[2709:117652] 所有火车票均已售完</span><br></pre></td></tr></table></figure><p>可以看到：在不考虑线程安全，不使用 NSLock 情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。</p><p>2）再来看看考虑线程安全的代码:<br>线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set&#x2F;get等等各种方式。这里我们使用 NSLock 对象来解决线程同步问题。NSLock 对象可以通过进入锁时调用 lock 方法，解锁时调用 unlock 方法来保证线程安全。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程安全：使用 NSLock 加锁</span><br><span class="line"> * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)demo9 &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程</span><br><span class="line">    </span><br><span class="line">    // 总票数</span><br><span class="line">    self.ticketSurplusCount = 10;</span><br><span class="line"></span><br><span class="line">    // 初始化 NSLock 对象</span><br><span class="line">    self.lock = [[NSLock alloc] init];</span><br><span class="line"></span><br><span class="line">    // 1.创建 queue1,queue1 代表北京火车票售卖窗口</span><br><span class="line">    NSOperationQueue *queue1 = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue1.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    // 2.创建 queue2,queue2 代表上海火车票售卖窗口</span><br><span class="line">    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue2.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    // 3.创建卖票操作 op1</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [self saleTicketSafe];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 4.创建卖票操作 op2</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [self saleTicketSafe];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 5.添加操作，开始卖票</span><br><span class="line">    [queue1 addOperation:op1];</span><br><span class="line">    [queue2 addOperation:op2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 售卖火车票(线程安全)</span><br><span class="line"> */</span><br><span class="line">- (void)saleTicketSafe &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line"></span><br><span class="line">        // 加锁</span><br><span class="line">        [self.lock lock];</span><br><span class="line"></span><br><span class="line">        if (self.ticketSurplusCount &gt; 0) &#123;</span><br><span class="line">            //如果还有票，继续售卖</span><br><span class="line">            self.ticketSurplusCount--;</span><br><span class="line">            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%ld 窗口:%@&quot;, (long)self.ticketSurplusCount, [NSThread currentThread]]);</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 解锁</span><br><span class="line">        [self.lock unlock];</span><br><span class="line"></span><br><span class="line">        if (self.ticketSurplusCount &lt;= 0) &#123;</span><br><span class="line">            NSLog(@&quot;所有火车票均已售完&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2020-08-16 13:56:47.871368+0800 OC-NSOperation[2745:120698] currentThread---&lt;NSThread: 0x6000035a8440&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-08-16 13:56:47.872873+0800 OC-NSOperation[2745:120803] 剩余票数:9 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:48.075868+0800 OC-NSOperation[2745:120803] 剩余票数:8 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:48.276917+0800 OC-NSOperation[2745:120803] 剩余票数:7 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:48.477632+0800 OC-NSOperation[2745:120803] 剩余票数:6 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:48.683070+0800 OC-NSOperation[2745:120803] 剩余票数:5 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:48.887849+0800 OC-NSOperation[2745:120803] 剩余票数:4 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:49.093434+0800 OC-NSOperation[2745:120803] 剩余票数:3 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:49.295885+0800 OC-NSOperation[2745:120803] 剩余票数:2 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:49.501106+0800 OC-NSOperation[2745:120803] 剩余票数:1 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:49.704799+0800 OC-NSOperation[2745:120803] 剩余票数:0 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:49.909619+0800 OC-NSOperation[2745:120804] 所有火车票均已售完</span><br><span class="line">2020-08-16 13:56:49.909621+0800 OC-NSOperation[2745:120803] 所有火车票均已售完</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出：在考虑了线程安全，使用 NSLock 加锁、解锁机制的情况下，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。</p><h2 id="NSOperation、NSOperationQueue-常用属性和方法归纳"><a href="#NSOperation、NSOperationQueue-常用属性和方法归纳" class="headerlink" title="NSOperation、NSOperationQueue 常用属性和方法归纳"></a>NSOperation、NSOperationQueue 常用属性和方法归纳</h2><p>1.NSOperation 常用属性和方法</p><ul><li>取消操作方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancel; 可取消操作，实质是标记 isCancelled 状态。</span><br><span class="line">判断操作状态方法</span><br><span class="line">- (BOOL)isFinished; 判断操作是否已经结束。</span><br><span class="line">- (BOOL)isCancelled; 判断操作是否已经标记为取消。</span><br><span class="line">- (BOOL)isExecuting; 判断操作是否正在在运行。</span><br><span class="line">- (BOOL)isReady; 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。</span><br></pre></td></tr></table></figure><ul><li>操作同步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)waitUntilFinished; 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。</span><br><span class="line">- (void)setCompletionBlock:(void (^)(void))block; completionBlock 会在当前操作执行完毕时执行 completionBlock。</span><br><span class="line">- (void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。</span><br><span class="line">- (void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。</span><br><span class="line">@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.NSOperationQueue 常用属性和方法</p><ul><li>取消&#x2F;暂停&#x2F;恢复操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancelAllOperations; 可以取消队列的所有操作。</span><br><span class="line">- (BOOL)isSuspended; 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。</span><br><span class="line">- (void)setSuspended:(BOOL)b; 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>操作同步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)waitUntilAllOperationsAreFinished; 阻塞当前线程，直到队列中的操作全部执行完毕。</span><br></pre></td></tr></table></figure><ul><li>添加&#x2F;获取操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)addOperationWithBlock:(void (^)(void))block; 向队列中添加一个 NSBlockOperation 类型操作对象。</span><br><span class="line">- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束</span><br><span class="line">- (NSArray *)operations; 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。</span><br><span class="line">- (NSUInteger)operationCount; 当前队列中的操作数。</span><br><span class="line"></span><br><span class="line">作者：行走少年郎</span><br><span class="line">链接：https://www.jianshu.com/p/4b1d77054b35</span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><ul><li>获取队列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (id)currentQueue; 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。</span><br><span class="line">+ (id)mainQueue; 获取主队列。</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p></blockquote><blockquote><p>这里的暂停和取消（包括操作的取消和队列的取消）并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。<br>暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift学习：Snapkit使用探索</title>
      <link href="/BboyZJ.github.io/2020/08/11/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9ASnapkit%E4%BD%BF%E7%94%A8%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/11/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9ASnapkit%E4%BD%BF%E7%94%A8%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Snapkit简介"><a href="#Snapkit简介" class="headerlink" title="Snapkit简介"></a>Snapkit简介</h1><p>SnapKit是一个优秀的 <code>第三方自适应布局库</code>，它可以让iOS、OS X应用更简单地实现自动布局</p><h1 id="SnapKit集成"><a href="#SnapKit集成" class="headerlink" title="SnapKit集成"></a>SnapKit集成</h1><p>使用pods方式引入类库，<code>pod &#39;SnapKit&#39;</code></p><p>引入头文件 <code>import SnapKit</code></p><h1 id="Snapkit使用方法"><a href="#Snapkit使用方法" class="headerlink" title="Snapkit使用方法"></a>Snapkit使用方法</h1><ul><li><p>通过 <code>snp.makeConstraints</code> 方法给 <code>view</code> 添加约束，约束有几种，分别是 <code>边距、宽、高、左上右下 </code></p></li><li><p>添加约束后修正 <code>offet、inset、multipliedBy</code></p></li><li><p>语法一般为： </p><p>  make.equalTo：等于<br>  make.lessThanOrEqualTo：小于等于<br>  make.greaterThanOrEqaulTo：大于等于</p></li></ul><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><ul><li>场景1：宽高200</li></ul><p><code>make.width.height.equal(200)</code></p><ul><li>场景2：距离box1 30</li></ul><p><code>make.top.equalTo(box1.snp.top).offset(30)</code></p><ul><li>场景3：一半</li></ul><p><code>make.size.equalTo(box1).multipliedBy(0.5)</code></p><ul><li>场景4：边距</li></ul><p><code>make.edges.equalTo(box1).inset(UIEdgeInsets(10,20,30,40))</code></p><h1 id="SnapKit注意"><a href="#SnapKit注意" class="headerlink" title="SnapKit注意"></a>SnapKit注意</h1><ul><li>使用SnapKit添加约束之前，需要在addSubview之后才能使用，否则会导致崩溃</li><li>在添加约束时常会出现一些错误，约束出现问题的原因一般就是两种：约束冲突和缺少约束。对于这两种问题，可以通过调试和log排查</li></ul>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC算法01：冒泡排序探索</title>
      <link href="/BboyZJ.github.io/2020/08/10/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9501%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/10/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9501%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><ol><li>基本思路：</li></ol><p>重复地走访要排序的元素列，<code>依次比较两个相邻的元素</code>，如果他们的 <code>顺序错误就把他们交换过来</code>。</p><ol start="2"><li>算法思想：</li></ol><p>1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>2）对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>3）针对所有的元素重复以上的步骤，除了最后一个。<br>4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><ol start="3"><li>主要流程：</li></ol><p>首先我们需要 <code>双层循环</code>，<code>外层循环控制排序趟数</code>，<code>内存循环控制每趟比较次数以及是否需要交换位置</code>，我们先不关心是否交换位置，我们内层循环每次比较都是取 <code>array[j]</code> 和 <code>array[j+1]</code> 相比较，根据比较结果来判断是否交换位置。</p><ol start="4"><li>时间复杂度</li></ol><ul><li><p>最好的情况：冒泡排序中最好的情况是数组本身就是正序排列的，并不需要交换，例如：@[1,2,3,4,5]; 当正序数组放入冒泡排序中的时候，只会进行4次比较，分别是1和2，2和3，3和4，4和5。比较完后发现没有任何数需要交换，那么说明数组已经排序正确，不要在进行最外层循环。当正序数组中有 <code>N</code> 个数的时候，那么只需要 <code>N-1</code> 次比较。 而正序数组在冒泡排序中的时间复杂度为O(n)，因为n-1中，在n的基数很大的情况，比如n为1000时，1其实可以忽略不计。所以 冒泡排序中最短的时间**复杂度为O(n)**。</p></li><li><p>冒泡排序中最坏的情况是数组本身就是逆序排列的，需要每两个数都进行交换，例如：@[5,4,3,2,1]；当逆序数组放入冒泡排序中，最外层的每一次循环都要进行n-1次比较，而逆序数组需要进行n次最外层循环才能正确排序，最终比较次数为(n-1)n&#x2F;2，所以冒泡排序中最长的时间**复杂度为(n²)**，因为当n基数很大时，(n-1)n&#x2F;2 &#x3D; (n² - n)&#x2F;2； n²与n、1&#x2F;2的差距越大，n与1&#x2F;2可以忽略不计。</p></li></ul><h1 id="冒泡排序-1"><a href="#冒泡排序-1" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>例子：元数据：@[@”1”,@”3”,@”2”,@”5”,@”4”]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;1&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;5&quot;,@&quot;4&quot;]];</span><br><span class="line">    // 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">    for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序</span><br><span class="line">        for (int j = 0; j &lt; arr.count - i - 1; j++) &#123;</span><br><span class="line">            // 相邻元素比较，若逆序则交换</span><br><span class="line">            if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123;</span><br><span class="line">                [arr exchangeObjectAtIndex:j withObjectAtIndex:j + 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2020-08-10 20:29:10.492517+0800 OC冒泡排序[27771:1528609] (</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="有序数组冒泡排序的优化"><a href="#有序数组冒泡排序的优化" class="headerlink" title="有序数组冒泡排序的优化"></a>有序数组冒泡排序的优化</h1><p>如果数据是有序的：</p><ul><li>第一种优化方式是设置一个标记位来标记是否发生了交换，如果没有发生交换就提前结束；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@&quot;5&quot;,@&quot;4&quot;,@&quot;3&quot;,@&quot;2&quot;,@&quot;1&quot;]];</span><br><span class="line">    int flag = 0;</span><br><span class="line">    // 外循环控制排序趟数,进行 array.count-1 趟</span><br><span class="line">    for (int i = 0; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        // 记录是否进行了交换，如果没有交换，数组顺序为顺序，则直接跳出外层循环结束排序</span><br><span class="line">        for (int j = 0; j &lt; arr.count - i - 1; j++) &#123;</span><br><span class="line">            //相邻元素比较，若逆序则交换</span><br><span class="line">            if ([arr[j] intValue] &gt; [arr[j + 1] intValue]) &#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                id temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+1];</span><br><span class="line">                arr[j+1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag == 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,arr);</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2020-08-10 20:45:33.770139+0800 OC冒泡排序[28047:1546936] (</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    5</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="两个数组合并成一个数据，并排序"><a href="#两个数组合并成一个数据，并排序" class="headerlink" title="两个数组合并成一个数据，并排序"></a>两个数组合并成一个数据，并排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSArray * ary1 = @[@1,@3,@4,@5,@9];</span><br><span class="line">NSArray * ary2 = @[@2,@4,@6,@8];</span><br><span class="line">NSMutableArray * res = [NSMutableArray arrayWithCapacity:[ary1 count] + [ary2 count]];</span><br><span class="line">    </span><br><span class="line">    int i = 0, j = 0; // i 表示ary1的下标  j表示ary2的下标</span><br><span class="line">    </span><br><span class="line">    while (i &lt; ary1.count  &amp;&amp;  j &lt; ary2.count) &#123;</span><br><span class="line">        int a1 = [ary1[i] intValue];</span><br><span class="line">        int a2 = [ary2[j] intValue];</span><br><span class="line">        if (a1 &lt;= a2) &#123;</span><br><span class="line">            [res addObject:ary1[i++]];</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            [res addObject:ary2[j++]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;,res);</span><br></pre></td></tr></table></figure><p>打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2020-08-10 21:11:11.311203+0800 OC冒泡排序[28372:1568516] (</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3,</span><br><span class="line">    4,</span><br><span class="line">    4,</span><br><span class="line">    5,</span><br><span class="line">    6,</span><br><span class="line">    8</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-算法探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC数据结构01：链表的探索</title>
      <link href="/BboyZJ.github.io/2020/08/09/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/09/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8401%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><ul><li>举个例子，数组：1-2-3-4-5-6-7-8-9-10，这个就是一个顺序存储结构，存储是按顺序的。</li><li>比如 <code>栈，先进后出</code>，比如 <code>hello world</code> 在栈里面是从 <code>栈底到栈顶的逻辑</code>，依次是 <code>h-e-l-l-o-w-o-r-l-d</code> 这个顺序存储</li><li>再比如 <code>队列，先进先出</code>，从头到尾 <code>h-e-l-l-o-w-o-r-l-d</code> 这个顺序排序</li></ul><h2 id="链式存储结构-链表"><a href="#链式存储结构-链表" class="headerlink" title="链式存储结构-链表"></a>链式存储结构-链表</h2><p>链表是一种 <code>物里存储单元上非连续、非顺序的存储结构</code>，数据元素的顺序是通过链表中的 <code>指针</code> 链接次序实现的。链表由 <code>一系列节点组成</code>，在 <code>运行时动态生成</code>。每个节点包括两部分：一个是 <code>数据域</code>，一个是 <code>指针域</code>。</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表的组成"><a href="#链表的组成" class="headerlink" title="链表的组成"></a>链表的组成</h2><ol><li>链表的数据元素的组成部分：<code>指针域</code> 和 <code>数据域</code></li><li><code>指针域</code> 用来存放指示数据元素之间的逻辑关系的指针。</li><li><code>数据域</code> 用来存放数据信息。</li><li>数据元素这种特殊的存储方式称之为 <code>结点（Node）</code>。</li></ol><h2 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h2><p><strong>链表分为4类：</strong></p><ul><li><p>单链表：一个数据域data、一个后继指针域next。也即：上一个节点指向下一个节点，尾节点next指向nil，首节点pre指向nil。</p></li><li><p>双向链表：一个数据域data、一个前驱指针域previous、一个后继指针域next。也即：上一个节点和下一个节点互相指向，尾节点next指向nil，首节点pre指向nil。</p></li><li><p>循环链表：一个数据域data、一个后继指针域next。也即：上一个节点指向下一个节点，尾节点next指向首节点。</p></li><li><p>双向循环链表：一个数据域data、一个前驱指针域previous、一个后继指针域next。也即：上一个节点和下一个节点互相指向，尾节点和首节点也互相指向。</p></li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061814176.png"></p><h2 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h2><ol><li>数组：</li></ol><p>我们知道，用数组存放数据时，必须事先定义固定的长度（即元素个数）。如果事先难以确定元素个数，则必须把数组定义的足够大，以便存放，显然这样会浪费内存。</p><ol start="2"><li>而链表可根据需要开辟内存单元，不会浪费内存。</li></ol><h1 id="数组-和-链表-的区别？"><a href="#数组-和-链表-的区别？" class="headerlink" title="数组 和 链表 的区别？"></a>数组 和 链表 的区别？</h1><ul><li><p>数组：数组 <code>静态分配</code> 内存；数组元素在内存上是连续的，可以通过下标查找元素；插入、删除需要移动大量元素，比较使用元素很少变化的情况；数组插入删除操作时间复杂度是 O(n)，数组查询操作时间复杂度是 O(1)</p></li><li><p>链表：链表 <code>动态分配</code> 内存；链表元素在内存中不是顺序存储的，查找慢；插入、删除只需要对元素指针重新赋值，效率高；链表插入删除操作时间复杂度是 O(1)，链表查询操作时间复杂度是 O(n)</p></li></ul><h1 id="如何检测单链表中是否有环？"><a href="#如何检测单链表中是否有环？" class="headerlink" title="如何检测单链表中是否有环？"></a>如何检测单链表中是否有环？</h1><ul><li>穷举遍历</li></ul><p>首先从头节点开始，依次遍历每个节点，每遍历到一个新节点，就从头节点重新遍历新节点之前的所有节点，当 <code>新节点的ID</code> 和 <code>此节点之前的所有节点ID</code> 依次比较，如果发现 <code>ID相同</code>，则证明链表有环。</p><ul><li>哈希表缓存</li></ul><p>首先创建一个以 <code>节点ID为键</code> 的HashSet集合，用来存储曾经遍历过的节点。然后同样是从头节点开始，依次遍历每一个节点，当新节点和HashSet集合当中存储的节点ID相同，则说明链表右环。</p><ul><li>快慢指针</li></ul><p>首先创建两个指针，指针1和指针2，同时指向这个头节点，指针1每次向下移动一个节点，指针2向下移动2个节点，比较节点是否相同，如果相同则说明链表有环。如果不同执行下一次循环。</p><h1 id="单向链表代码实现"><a href="#单向链表代码实现" class="headerlink" title="单向链表代码实现"></a>单向链表代码实现</h1><ol><li>定义节点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 单链表节点</span><br><span class="line">@interface SingleLinkNode : NSObject</span><br><span class="line">@property (nonatomic,strong)id data; // 数据域</span><br><span class="line">@property (nonatomic,strong,nullable)SingleLinkNode * next; // 后继指针域</span><br><span class="line">+ (instancetype)constructNodeWithData:(id)data;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface SingleLinkNode ()</span><br><span class="line">@end</span><br><span class="line">@implementation SingleLinkNode</span><br><span class="line">+ (instancetype)constructNodeWithData:(id)data&#123;</span><br><span class="line">    SingleLinkNode * node = [[SingleLinkNode alloc] init];</span><br><span class="line">    node.data = data;</span><br><span class="line">    node.next = nil;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>构建链表</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 构建一个单链表</span><br><span class="line">SingleLinkNode * headNode = [[SingleLinkNode alloc] init];</span><br></pre></td></tr></table></figure><ol start="3"><li>对外接口类</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@interface LinkInterface : NSObject</span><br><span class="line">// 单链表：在头部插入节点</span><br><span class="line">+ (void)insertNewNodeToHead:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode;</span><br><span class="line">// 单链表：在尾部插入节点</span><br><span class="line">+ (void)insertNewNodeToTail:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode;</span><br><span class="line">// 单链表：在指定位置插入节点</span><br><span class="line">+ (void)insertNodeAtIndex:(int)index node:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode;</span><br><span class="line">// 单链表：删除指定位置节点</span><br><span class="line">+ (void)deleteNodeAtIndex:(int)index headNode:(SingleLinkNode *)headNode;</span><br><span class="line">// 单链表：查询指定位置节点</span><br><span class="line">+ (SingleLinkNode *)queryNodeAtIndex:(int)index headNode:(SingleLinkNode *)headNode;</span><br><span class="line">// 单链表：正序遍历链表</span><br><span class="line">+ (NSArray *)printFromHeadWithNode:(SingleLinkNode *)headNode printPrefixText:(NSString *)text;</span><br><span class="line">// 单链表：倒叙遍历链表</span><br><span class="line">+ (NSMutableArray *)printFromTailWithNode:(SingleLinkNode *)headNode;</span><br><span class="line">// 单链表：反转链表</span><br><span class="line">+ (SingleLinkNode *)reverseWithNode:(SingleLinkNode *)headNode;</span><br><span class="line">// 单链表：两个有序链表合并成一个新的有序链表</span><br><span class="line">+ (SingleLinkNode *)combineWithNode:(SingleLinkNode *)headNode otherNode:(SingleLinkNode *)otherNode;</span><br><span class="line">// 单链表：判断两个链表是否相交</span><br><span class="line">+ (BOOL)intersectWithNode:(SingleLinkNode *)headNode otherNode:(SingleLinkNode *)otherNode;</span><br><span class="line">// 单链表：判断链表是否构成环，如果成环，求出环的入口节点</span><br><span class="line">+ (SingleLinkNode *)circleWithNode:(SingleLinkNode *)headNode;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ol start="4"><li>插入节点</li></ol><ul><li>在头部插入节点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 在头部插入节点</span><br><span class="line">+ (void)insertNewNodeToHead:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if (!headNode)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 先把新节点指向头节点的下一个节点，再让头结点指向新节点（比较常用）</span><br><span class="line">    if (headNode.next == nil) &#123;</span><br><span class="line">        headNode.next = newNode;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        // 将下一个节点赋值给新节点</span><br><span class="line">        newNode.next = headNode.next;</span><br><span class="line">        // 再将头节点指向新节点</span><br><span class="line">        headNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vc实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 插入节点到头部</span><br><span class="line">SingleLinkNode * newHeadNode = [SingleLinkNode constructNodeWithData:@1];</span><br><span class="line">[LinkInterface insertNewNodeToHead:newHeadNode headNode:headNode];</span><br><span class="line">// 正序打印节点</span><br><span class="line">[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;构造单链表为：&quot;];</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-23 16:44:46.140163+0800 单链表[39792:20769651] 单链表为:1</span><br></pre></td></tr></table></figure><ul><li>在尾部插入节点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 在尾部插入节点</span><br><span class="line">+ (void)insertNewNodeToTail:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果头节点就是尾节点</span><br><span class="line">    if(headNode.next == nil) &#123;</span><br><span class="line">        headNode.next = newNode;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        // 设置中间变量</span><br><span class="line">        SingleLinkNode * pNode = headNode;</span><br><span class="line">        while (pNode.next != nil) &#123; // 未遍历到尾节点</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vc实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 插入节点到尾部</span><br><span class="line">SingleLinkNode * newTailNode = [SingleLinkNode constructNodeWithData:@2];</span><br><span class="line">SingleLinkNode * newTailNode1 = [SingleLinkNode constructNodeWithData:@3];</span><br><span class="line">SingleLinkNode * newTailNode2 = [SingleLinkNode constructNodeWithData:@5];</span><br><span class="line">[LinkInterface insertNewNodeToTail:newTailNode headNode:headNode];</span><br><span class="line">[LinkInterface insertNewNodeToTail:newTailNode1 headNode:headNode];</span><br><span class="line">[LinkInterface insertNewNodeToTail:newTailNode2 headNode:headNode];</span><br><span class="line">// 正序打印节点</span><br><span class="line">[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;];</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-23 16:46:42.287876+0800 单链表[39960:20772937] 单链表为:1-&gt;2-&gt;3-&gt;5</span><br></pre></td></tr></table></figure><ul><li>在指定位置插入</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 单链表：在指定位置插入节点</span><br><span class="line">+ (void)insertNodeAtIndex:(int)index node:(SingleLinkNode *)newNode headNode:(SingleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果头节点即尾节点</span><br><span class="line">    if (headNode.next == nil)&#123;</span><br><span class="line">        headNode.next = newNode;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        SingleLinkNode * pNode = headNode;</span><br><span class="line">        int i = 1;</span><br><span class="line">        while (i &lt; index &amp;&amp; pNode.next != nil) &#123;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode.next = pNode.next;</span><br><span class="line">        pNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vc实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 插入指定位置节点</span><br><span class="line">SingleLinkNode * newIndexNode = [SingleLinkNode constructNodeWithData:@4];</span><br><span class="line">[LinkInterface insertNodeAtIndex:4 node:newIndexNode headNode:headNode];</span><br><span class="line">// 正序打印节点</span><br><span class="line">[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;];</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-23 16:47:38.507939+0800 单链表[40048:20774861] 构造单链表为：:1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><ol start="5"><li>删除节点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 单链表：删除指定位置节点</span><br><span class="line">+ (void)deleteNodeAtIndex:(int)index headNode:(SingleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(headNode == nil || !headNode.next || index &lt;= 0)&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;没有要删除的第%d个节点&quot;,index]);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SingleLinkNode * pNode = headNode;</span><br><span class="line">    SingleLinkNode * p = pNode; // 移动指针</span><br><span class="line">    int i = 0;</span><br><span class="line">    while (i &lt; index &amp;&amp; pNode.next != nil) &#123;</span><br><span class="line">        p = pNode;</span><br><span class="line">        pNode = pNode.next;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(pNode != nil)&#123;</span><br><span class="line">        p.next = p.next.next;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;没有要删除的第%d个节点&quot;,index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vc实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 删除指定位置的节点</span><br><span class="line">[LinkInterface deleteNodeAtIndex:1 headNode:headNode];</span><br><span class="line">// 正序打印节点</span><br><span class="line">[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;];</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-23 16:50:48.638460+0800 单链表[40345:20779532] 单链表为:2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><ol start="6"><li>查询节点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 单链表：查询指定位置节点</span><br><span class="line">+ (SingleLinkNode *)queryNodeAtIndex:(int)index headNode:(SingleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if (!headNode || !headNode.next) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;没有查询到的第%d个节点&quot;,index]);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    SingleLinkNode * pNode = headNode.next;</span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i &lt; index &amp;&amp; pNode != nil) &#123;</span><br><span class="line">        pNode = pNode.next;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(pNode != nil)&#123;</span><br><span class="line">        return pNode;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;没有查询到的第%d个节点&quot;,index]);</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vc实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 查询指定位置的节点</span><br><span class="line">[LinkInterface queryNodeAtIndex:3 headNode:headNode];</span><br><span class="line">// 正序打印节点</span><br><span class="line">[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;];</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-23 16:55:10.563221+0800 单链表[40694:20785389] 单链表为:2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><ol start="7"><li>遍历链表</li></ol><ul><li>正向遍历</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 正序遍历链表</span><br><span class="line">+ (NSArray *)printFromHeadWithNode:(SingleLinkNode *)headNode printPrefixText:(NSString *)text&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if (!headNode || !headNode.next) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 设置偏移指针</span><br><span class="line">    SingleLinkNode * pNode = headNode.next;</span><br><span class="line">    NSMutableArray * dataArr = [NSMutableArray array];</span><br><span class="line">    while (pNode != nil) &#123;</span><br><span class="line">        [dataArr addObject:pNode.data];</span><br><span class="line">        pNode = pNode.next; // 指向下一个节点</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@:%@&quot;,text,[dataArr componentsJoinedByString:@&quot;-&gt;&quot;]);</span><br><span class="line">    return dataArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vc实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 正序打印节点</span><br><span class="line">[LinkInterface printFromHeadWithNode:headNode printPrefixText:@&quot;单链表为&quot;];</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-23 16:55:10.563221+0800 单链表[40694:20785389] 单链表为:2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><ul><li>反向遍历</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 单链表：倒叙遍历链表</span><br><span class="line">+ (NSMutableArray *)printFromTailWithNode:(SingleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode || !headNode.next)&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 遍历指针偏移，每次遍历完一次后，要记录最后一个节点，然后将遍历指针移动到开头重新开始，与记录的最后一个节点作比较</span><br><span class="line">    NSMutableArray * items = [NSMutableArray array];</span><br><span class="line">    SingleLinkNode * pNode = headNode;</span><br><span class="line">    SingleLinkNode * lastNode = nil;</span><br><span class="line">    while (pNode != nil &amp;&amp; lastNode != pNode) &#123;</span><br><span class="line">        pNode = pNode.next;</span><br><span class="line">        if (pNode.next == nil || pNode.next == lastNode) &#123;</span><br><span class="line">            lastNode = pNode;</span><br><span class="line">            pNode = headNode;</span><br><span class="line">            [items addObject:lastNode.data];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return items;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vc实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 倒叙打印节点</span><br><span class="line">NSMutableArray * tailArr = [LinkInterface printFromTailWithNode:headNode];</span><br><span class="line">NSLog(@&quot;tail:%@&quot;,tailArr);</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2022-11-23 17:00:09.521947+0800 单链表[41100:20791055] tail:(</span><br><span class="line">    5,</span><br><span class="line">    4,</span><br><span class="line">    3,</span><br><span class="line">    2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="8"><li>反转链表</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 单链表：反转链表</span><br><span class="line">+ (SingleLinkNode *)reverseWithNode:(SingleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode|| !headNode.next)&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 采用头节点插入的方式反转</span><br><span class="line">    // 定义遍历指针</span><br><span class="line">    SingleLinkNode * p = headNode.next;</span><br><span class="line">    // 定义反转后头节点</span><br><span class="line">    SingleLinkNode * newHead = [[SingleLinkNode alloc] init];</span><br><span class="line">    while (p != nil) &#123;</span><br><span class="line">        // 记录下一个节点用来往下循环</span><br><span class="line">        SingleLinkNode * temp = p.next;</span><br><span class="line">        </span><br><span class="line">        // 替换当前节点的next为新头next</span><br><span class="line">        p.next = newHead.next;</span><br><span class="line">        // 更新新头节点指向当前节点即可反转</span><br><span class="line">        newHead.next = p;</span><br><span class="line">        </span><br><span class="line">        // 移动p指针</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vc实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 反转链表</span><br><span class="line">SingleLinkNode * reverseNode = [LinkInterface reverseWithNode:headNode];</span><br></pre></td></tr></table></figure><ol start="9"><li>合并有序链表（有问题，排序不对）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 两个有序链表合并成一个新的有序链表</span><br><span class="line">+ (SingleLinkNode *)combineWithNode:(SingleLinkNode *)headNode otherNode:(SingleLinkNode *)otherNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode || !headNode.next)&#123;</span><br><span class="line">        return otherNode;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!otherNode || !otherNode.next)&#123;</span><br><span class="line">        return headNode;</span><br><span class="line">    &#125;</span><br><span class="line">    // 一起遍历</span><br><span class="line">    SingleLinkNode * p1 = headNode.next;</span><br><span class="line">    SingleLinkNode * p2 = otherNode.next;</span><br><span class="line">    // 定义一个新头节点</span><br><span class="line">    SingleLinkNode * newHead = [[SingleLinkNode alloc] init];</span><br><span class="line">    while (p1 != nil &amp;&amp; p2 != nil) &#123;</span><br><span class="line">        if([p1.data integerValue] &gt; [p2.data integerValue])&#123;</span><br><span class="line">            // 移动otherNode节点指向otherNode当前节点的下一个节点</span><br><span class="line">            otherNode.next = p2.next;</span><br><span class="line">            // 将当前otherNode节点链表断掉</span><br><span class="line">            p2.next = nil;</span><br><span class="line">            // 将当前otherNode节点插入到新节点newHead链表的尾部</span><br><span class="line">            [self insertNewNodeToTail:p2 headNode:newHead];</span><br><span class="line">            // 获取otherNode链表的下一个节点</span><br><span class="line">            p2 = otherNode.next;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            headNode.next = p1.next;</span><br><span class="line">            p1.next = nil;</span><br><span class="line">            [self insertNewNodeToTail:p1 headNode:newHead];</span><br><span class="line">            p1 = headNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理没扫描结束的链表</span><br><span class="line">    while (p1 != nil) &#123;</span><br><span class="line">        headNode.next = p1.next;</span><br><span class="line">        p1.next = nil;</span><br><span class="line">        [self insertNewNodeToTail:p1 headNode:newHead];</span><br><span class="line">        p1 = headNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (p2 != nil) &#123;</span><br><span class="line">        otherNode.next = p2.next;</span><br><span class="line">        p2.next = nil;</span><br><span class="line">        [self insertNewNodeToTail:p2 headNode:newHead];</span><br><span class="line">        p2 = otherNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="10"><li>判断两个链表是否相交</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 单链表：判断两个链表是否相交</span><br><span class="line">+ (BOOL)intersectWithNode:(SingleLinkNode *)headNode otherNode:(SingleLinkNode *)otherNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode || !headNode.next || !otherNode || !otherNode.next)&#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    // 思路：分别获取两个链表的长度，判断谁的链表更长，链表更长的先走完相差的步数，然后再齐步走</span><br><span class="line">    SingleLinkNode * p1 = headNode.next;</span><br><span class="line">    SingleLinkNode * p2 = otherNode.next;</span><br><span class="line">    </span><br><span class="line">    int L1 = 1;</span><br><span class="line">    int L2 = 1;</span><br><span class="line">    while (p1 != nil) &#123;</span><br><span class="line">        L1 ++;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while (p2 != nil) &#123;</span><br><span class="line">        L2 ++;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p1 = headNode.next; // 将p1遍历指针移动到首节点</span><br><span class="line">    p2 = headNode.next; // 将p2遍历指针移动到首节点</span><br><span class="line">    </span><br><span class="line">    int i = 0;</span><br><span class="line">    if (L1 &gt; L2) &#123;</span><br><span class="line">        while (i &lt; L1 - L2 &amp;&amp; p1 != nil) &#123; // p1先走</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        while (i &lt; L2 - L1 &amp;&amp; p2 != nil) &#123; // p2先走</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // p1、p2齐步走</span><br><span class="line">    if(i == ABS(L1 - L2))&#123;</span><br><span class="line">        while (p1 != nil &amp;&amp; p2 != nil) &#123;</span><br><span class="line">            if(p1.next == p2.next) return YES;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="11"><li>判断链表是否头程还，如果成环，求出环的入口节点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 单链表：判断链表是否构成环，如果成环，求出环的入口节点</span><br><span class="line">+ (SingleLinkNode *)circleWithNode:(SingleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode || !headNode.next)&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 思路：采用快慢指针</span><br><span class="line">    // 快指针先走两步，满指针走一步，如果成环，必然重合。</span><br><span class="line">    // 走到第一次重合的地点后，重新设置一个指针p指向头节点，并与慢节点同步伐齐步走</span><br><span class="line">    // 走到第二次相遇的地方，即为构成环的节点</span><br><span class="line">    SingleLinkNode * quick = headNode.next;</span><br><span class="line">    SingleLinkNode * slow = headNode.next;</span><br><span class="line">    SingleLinkNode * p = headNode.next;</span><br><span class="line">    while (quick != nil &amp;&amp; slow != nil) &#123;</span><br><span class="line">        quick = quick.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        if (quick == slow) &#123; // 第一次重合，结束循环</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (p != nil &amp;&amp; slow != nil) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        if (p == slow) &#123; // 第二次重合，找到成环的入口节点</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>双向链表：每一个节点前后指针域都和他的上一个节点互相指向，尾节点的next指向nil，首节点的pre指向nil</p><ol><li>定义节点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface DoubleLinkNode : NSObject</span><br><span class="line">@property (nonatomic,strong)id data; // 数据域</span><br><span class="line">@property (nonatomic,weak,nullable)DoubleLinkNode * pre; // 前驱指针域（防止循环引用）</span><br><span class="line">@property (nonatomic,strong,nullable)DoubleLinkNode * next; // 后继指针域</span><br><span class="line">+ (instancetype)constructNodeWithData:(id)data;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation DoubleLinkNode</span><br><span class="line">+ (instancetype)constructNodeWithData:(id)data&#123;</span><br><span class="line">    DoubleLinkNode * node = [[DoubleLinkNode alloc] init];</span><br><span class="line">    node.data = data;</span><br><span class="line">    node.pre = nil;</span><br><span class="line">    node.next = nil;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ol start="2"><li>构建一个双向链表</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 构造一个双向链表</span><br><span class="line">DoubleLinkNode * head = [[DoubleLinkNode alloc] init];</span><br><span class="line">DoubleLinkNode * node1 = [DoubleLinkNode constructNodeWithData:@1];</span><br><span class="line">DoubleLinkNode * node2 = [DoubleLinkNode constructNodeWithData:@2];</span><br><span class="line">head.next = node1;</span><br><span class="line">node1.pre = head;</span><br><span class="line">node1.next = node2;</span><br><span class="line">node2.pre = node1;</span><br><span class="line">[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双链表为&quot;];</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-24 13:38:50.045234+0800 单链表[50291:20937675] 双链表为:1⇄2</span><br></pre></td></tr></table></figure><ol start="3"><li>在头部插入节点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 双向链表：向头部插入节点</span><br><span class="line">+ (void)insertDoubleNewNodeToHead:(DoubleLinkNode *)newNode headNode:(DoubleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果只有一个头节点</span><br><span class="line">    if(headNode.next == nil)&#123;</span><br><span class="line">        headNode.next = newNode;</span><br><span class="line">        newNode.pre = headNode;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        newNode.next = headNode.next; // 当前节点的后继指向头节点的后继</span><br><span class="line">        headNode.next.pre = newNode; // 头结点后继的前驱指向当前节点</span><br><span class="line">        </span><br><span class="line">        newNode.pre = headNode; // 当前节点的前驱指向头结点</span><br><span class="line">        headNode.next = newNode; // 头结点的后继指向当前节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vc实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在头部插入节点</span><br><span class="line">DoubleLinkNode * node0 = [DoubleLinkNode constructNodeWithData:@0];</span><br><span class="line">[LinkInterface insertDoubleNewNodeToHead:node0 headNode:head];</span><br><span class="line">[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双链表为&quot;];</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-24 13:53:01.240605+0800 单链表[51484:20953802] 双链表为:0⇄1⇄2</span><br></pre></td></tr></table></figure><ol start="4"><li>在尾部插入节点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 双向链表：向尾部插入节点</span><br><span class="line">+ (void)insertDoubleNewNodeToTail:(DoubleLinkNode *)newNode headNode:(DoubleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置偏移指针</span><br><span class="line">    DoubleLinkNode * pNode = headNode.next;</span><br><span class="line">    while (pNode.next != nil) &#123;</span><br><span class="line">        pNode = pNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pNode.next = newNode;</span><br><span class="line">    newNode.pre = pNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vc实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在尾部插入节点</span><br><span class="line">DoubleLinkNode * node4 = [DoubleLinkNode constructNodeWithData:@4];</span><br><span class="line">[LinkInterface insertDoubleNewNodeToTail:node4 headNode:head];</span><br><span class="line">[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双向链表为&quot;];</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-24 13:59:04.853558+0800 单链表[52038:20962187] 双向链表为:0⇄1⇄2⇄4</span><br></pre></td></tr></table></figure><ol start="5"><li>在指定位置插入节点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 双向链表：在指定位置插入节点</span><br><span class="line">+(void)insertDoubleNewNodeToIndex:(int)index newNode:(DoubleLinkNode *)newNode headNode:(DoubleLinkNode *)headNode&#123;</span><br><span class="line">    if(!headNode)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果头结点即尾节点</span><br><span class="line">    if (headNode.next == nil)&#123;</span><br><span class="line">        headNode.next = newNode;</span><br><span class="line">        newNode.pre = headNode;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    // 如果头节点即尾节点</span><br><span class="line">    if (headNode.next == nil)&#123;</span><br><span class="line">        headNode.next = newNode;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        // 设置偏移指针</span><br><span class="line">        DoubleLinkNode * pNode = headNode.next;</span><br><span class="line">        int i = 1;</span><br><span class="line">        while (i &lt; index &amp;&amp; pNode.next != nil) &#123;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode.next = pNode.next;</span><br><span class="line">        pNode.next.pre = newNode;</span><br><span class="line">        newNode.pre = pNode;</span><br><span class="line">        pNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vc实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在指定位置插入节点</span><br><span class="line">DoubleLinkNode * node3 = [DoubleLinkNode constructNodeWithData:@3];</span><br><span class="line">[LinkInterface insertDoubleNewNodeToIndex:3 newNode:node3 headNode:head];</span><br><span class="line">[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双向链表为&quot;];</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-24 14:08:41.539116+0800 单链表[52850:20973592] 双向链表为:0⇄1⇄2⇄3⇄4</span><br></pre></td></tr></table></figure><ol start="6"><li>删除指定位置节点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 双向链表：删除指定位置节点</span><br><span class="line">+ (DoubleLinkNode *)deleteDoubleNodeAtIndex:(int)index headNode:(DoubleLinkNode *)headNode&#123;</span><br><span class="line">    // 判空处理</span><br><span class="line">    if(!headNode)&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置偏移指针</span><br><span class="line">    DoubleLinkNode * pNode = headNode.next;</span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i &lt; index &amp;&amp; pNode.next != nil) &#123;</span><br><span class="line">        pNode = pNode.next;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i == index)&#123;</span><br><span class="line">        pNode.pre.next = pNode.next;</span><br><span class="line">        pNode.next.pre = pNode.pre;</span><br><span class="line">        return pNode;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vc实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 删除指定位置节点</span><br><span class="line">[LinkInterface deleteDoubleNodeAtIndex:1 headNode:head];</span><br><span class="line">[LinkInterface printDoubleFromHeadWithNode:head printPrefixText:@&quot;双向链表为&quot;];</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022-11-24 14:15:01.766124+0800 单链表[53365:20980542] 双向链表为:1⇄2⇄3⇄4</span><br></pre></td></tr></table></figure><ol start="7"><li>遍历并打印链表</li></ol><pre><code>// 双向链表：遍历并打印链表+ (void)printDoubleFromHeadWithNode:(DoubleLinkNode *)headNode printPrefixText:(NSString *)text&#123;    if(!headNode)&#123;        return;    &#125;    DoubleLinkNode * pNode = headNode.next;    NSMutableArray * items = [NSMutableArray array];    while (pNode != nil) &#123;        [items addObject:pNode.data];        pNode = pNode.next;    &#125;    NSLog(@&quot;%@:%@&quot;,text,[items componentsJoinedByString:@&quot;⇄&quot;]);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-数据结构探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC算法03：斐波那契数列探索</title>
      <link href="/BboyZJ.github.io/2020/08/09/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9503%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/09/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9503%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>斐波那契数列</code>（Fibonacci sequence），又称黄金分割数列、因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为<code>“兔子数列”</code>，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(1)&#x3D;1，F(2)&#x3D;1, F(n)&#x3D;F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*），用文字来说，就是斐波那契数列由 0 和 1 开始，之后的斐波那契数列系数就由 之前的两数相加。</p><h1 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h1><p>问：有一段楼梯有10级台阶，规定每一步只能跨一级或两级，要登上第 10 级台阶有几种不同的走法?</p><p>分析：这就是一个斐波那契数列：登上第一级台阶有一种登法；登上两级台阶，有两种登法；登上三级台阶，有三种登法；登上四级台阶，有五种登法……<br>1，2，3，5，8，13…… 所以，登上十级，有 89 种走法。</p><p>答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo&#123;</span><br><span class="line">    // 有10级台阶</span><br><span class="line">    NSInteger tjNum = 10;</span><br><span class="line">    </span><br><span class="line">    NSInteger total = [self getTotalNumOfMethods:tjNum];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;total:%ld&quot;,total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)getTotalNumOfMethods:(NSInteger)num&#123;</span><br><span class="line">    if (num == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (num == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (num == 2) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return [self getTotalNumOfMethods:num-1] + [self getTotalNumOfMethods:num - 2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：89</p><h1 id="兔子繁殖问题"><a href="#兔子繁殖问题" class="headerlink" title="兔子繁殖问题"></a>兔子繁殖问题</h1><p>斐波那契数列又因数学家莱昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为“兔子数列”。</p><p>问：一般而言，兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。如果所有兔子都不死，那么一年以后可以繁殖多少对兔子？</p><p>分析：我们不妨拿新出生的一对小兔子分析一下：<br>第一个月小兔子没有繁殖能力，所以还是一对  </p><p>两个月后，生下一对小兔对数共有两对</p><p>三个月以后，老兔子又生下一对，因为小兔子还没有繁殖能力，所以一共是三对<br>－－－－－－<br>依次类推可以列出下表：</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061844080.png"></p><p>幼仔对数&#x3D;前月成兔对数<br>成兔对数&#x3D;前月成兔对数+前月幼仔对数<br>总体对数&#x3D;本月成兔对数+本月幼仔对数<br>可以看出幼仔对数、成兔对数、总体对数都构成了一个数列。这个数列有关十分明显的特点，那是：前面相邻两项之和，构成了后一项。</p><p>答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo1&#123;</span><br><span class="line">    NSInteger month = 12;</span><br><span class="line">    </span><br><span class="line">    NSInteger tuTotal = [self getTuTotalNum:month];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;tuTotal:%ld&quot;,tuTotal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)getTuTotalNum:(NSInteger)month&#123;</span><br><span class="line">    if (month == 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (month == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (month == 2) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return [self getTuTotalNum:month-1] + [self getTuTotalNum:month - 2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：233</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-算法探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC算法02：插入排序探索</title>
      <link href="/BboyZJ.github.io/2020/08/07/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9502%EF%BC%9A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/07/OC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/OC%E7%AE%97%E6%B3%9502%EF%BC%9A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，直到全部对象都插入为止。即边插入边排序，保证子序列中随时都是排好序的。</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>有序插入</p><ul><li><p>在有序列序列中插入一个元素，保持序列有序，有序长度不断增加。</p></li><li><p>可以插入在中间、最前面和最后面</p></li></ul><h1 id="插入排序种类"><a href="#插入排序种类" class="headerlink" title="插入排序种类"></a>插入排序种类</h1><ol><li><p>顺序法定位插入位置 – <code>直接插入排序</code></p></li><li><p>缩小增量多遍插入排序 – <code>希尔排序</code></p></li></ol><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><ol><li><p>基本思路：每轮排序把数组分为2部分，一部分为已排序好的数组，一部分为还未排序好的数组。每次取出还未排序好的数组中首元素与已排序好的数组从右往左比较。如果发现从未排序中取出的元素比从已排序中取出的元素大，就把该未排序的元素插入到从已排序中取出元素的后面。这样每一轮就能确定一个未排序元素在已排序数组中的准确位置</p></li><li><p>算法思想</p></li></ol><ul><li><p>从第一个元素开始，该元素可以认为已经被排序</p></li><li><p>取出下一个元素，在已经排序的元素序列中从后向前扫描</p></li><li><p>如果该元素（已排序）大于新元素，将该元素移到下一位置</p></li><li><p>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</p></li><li><p>将新元素插入到下一位置中</p></li><li><p>重复步骤2~5</p></li></ul><ol start="3"><li>直接插入排序的流程演示</li></ol><p>流程举例: 红色的为已排序部分，蓝色的为未排序部分</p><p>1）原始数据：首先把原数组从下坐标1开始拆分为2部分， 已排序部分(红色)，未排序部分(蓝色)。默认原数组首元素为已排序元素。</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061833441.png"></p><p>2）第一轮：接着用后面未排序部分的第一个元素与已排序部分的最后一个元素进行比较，这里发现已排序最末尾元素5小于未排序元素第一个元素9.且元素5余元素9的位置是相邻的。不发生插入。把元素9列入已排序数组中。此时已排序好的元素多了一个。</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061833527.png"></p><p>3）第二轮：然后接着用后面未排序部分的第一个元素与已排序部分的最后一个元素进行比较，这里发现已排序最末尾元素9大于未排序元素第一个元素2。并且9不是已排序元素最前面一个元素，所以忽略本次操作，让元素2与已排序元素从右往左的下一个元素进行比较，此时发现已排序元素5大于元素2，但发现元素5是已排序元素中首个元素。则直接把元素2插入到元素5前面。</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061833540.png"></p><p>4）第三轮排序：用后面未排序部分的第一个元素与已排序部分的最后一个元素进行比较，这里发现已排序最末尾元素9小于未排序元素第一个元素15。且两个元素相邻。不发生插入，把元素15加入已排序部分。</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061833930.png"></p><p>5）第四轮排序：用后面未排序部分的第一个元素与已排序部分的最后一个元素进行比较，这里发现已排序最末尾元素15小于未排序元素第一个元素46。且两个元素相邻。不发生插入，把元素46加入已排序部分。</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061835372.png"></p><p>6）最后：依次按照上面的方式递归排序。直到所有元素排序完成。</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061834433.png"></p><ol start="4"><li>列子:</li></ol><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@15,@2,@5,@10,@20]];</span><br><span class="line">    </span><br><span class="line">    // 插入排序的原理：始终定义第一个元素为有序的，将元素逐个插入到有序的排列中</span><br><span class="line">    // 其特点是：不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去</span><br><span class="line">    for (int i = 0 ; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        // temp为待排元素i为其位置</span><br><span class="line">        NSNumber * temp = arr[i];</span><br><span class="line">        // j为已排元素最后一个元素的位置</span><br><span class="line">        int j = i - 1;</span><br><span class="line">        // 当j&gt;=0时，i为第一个待排元素，取已排元素和待排元素比较，在已经排好序中从后向前扫描</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; [arr[j] integerValue] &gt; [temp integerValue]) &#123;</span><br><span class="line">            // 如果已经排好序的序列中元素大于新元素，则将该元素往右移动一个位置</span><br><span class="line">            [arr replaceObjectAtIndex:j+1 withObject:arr[j]];</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        // 跳出循环时，j已排元素小于或等于i的元素（待排元素）。插入新元素a[j+1] = temp，即空出来的位置插入待排序的值</span><br><span class="line">        [arr replaceObjectAtIndex:j+1 withObject:temp];</span><br><span class="line">        NSLog(@&quot;插入排序排序中:%@&quot;,[self getArrayStr:arr]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 将数组中的元素拼接成字符串 - 方便打印</span><br><span class="line">- (NSString *)getArrayStr:(NSArray *)array &#123;</span><br><span class="line">    NSMutableString *strM = [NSMutableString string];</span><br><span class="line">    for (NSNumber *num in array) &#123;</span><br><span class="line">        [strM appendString:[NSString stringWithFormat:@&quot;%@,&quot;,num]];</span><br><span class="line">    &#125;</span><br><span class="line">    return strM.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-08-07 21:30:38.316438+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:15,2,5,10,20,</span><br><span class="line">2020-08-07 21:30:38.316483+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:2,15,5,10,20,</span><br><span class="line">2020-08-07 21:30:38.316502+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:2,5,15,10,20,</span><br><span class="line">2020-08-07 21:30:38.316519+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:2,5,10,15,20,</span><br><span class="line">2020-08-07 21:30:38.316535+0800 C-直接插入排序算法[3671:1382925] 插入排序排序中:2,5,10,15,20,</span><br></pre></td></tr></table></figure><ol start="5"><li>算法分析</li></ol><ul><li>直接插入排序的算法性能</li></ul><p><img src="https://user-images.githubusercontent.com/25925248/89651355-62d67e00-d8f6-11ea-8a41-5245460356d6.png"></p><ul><li>时间复杂度</li></ul><p><strong>最好的情况（关键字在记录中<em>顺序有序</em>）：</strong></p><ol><li>当元素的初始序列为正序时，仅外循环要进行n-1趟排序且每一趟只进行一次比较，没有进入if语句不存在元素之间的交换(移动)。此时比较次数(Cmin)和移动次数(Mmin)达到最小值。 此时时间复杂度为O(n)。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比较次数：Cmin = n-1;</span><br><span class="line">移动次数：Mmin = 0;</span><br></pre></td></tr></table></figure><ol start="2"><li>举例：</li></ol><p>如：1 2 3 4 5<br>比较：                         次数      移动<br>第2个元素和第一个元素比较          1        0<br>第3个元素和第二个元素比较          1        0<br>…<br>第n个元素和第n-1个元素比较         1       0<br>比较的次数：n-1<br>移动的次数：0</p><p><strong>最坏的情况（关键字在记录序列中<em>逆序有序</em>）：</strong></p><ol><li>最差就是逆序。每趟排序中待插入的元素都要和[0,i-1]中的i个元素进行比较且要将这i个元素后移，i个元素后移移动次数当然也就为i了，再加上temp &#x3D; arr[i]与arr[j+1] &#x3D; temp的两次移动，每趟移动的次数为i+2,此时比较次数(Cmin)和移动次数(Mmin)达到最小值。 此时时间复杂度为O(n2)。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cmax = 1+2+...+(n-1) = n*(n-1)/2 = O(n2)</span><br><span class="line">Mmax = (1+2)+(2+2)+...+(n-1+2) = (n-1)*(n+4)/2 = O(n2)  (i取值范围1~n-1)</span><br></pre></td></tr></table></figure><ol start="2"><li>例子：</li></ol><p>如：5 4 3 2 1<br>比较：                                 次数       移动<br>第2个元素和第1个元素比较                   1        1+2<br>第3个元素和前2个元素比较                   2        2+2<br>…<br>第n个元素和前n-1个比较                    n-1      n-1+2<br>最后： 把1+2+…+n-1加起来求平均值<br>比较的次数：1+2+…+n-1 &#x3D; (n+2)(n-1)&#x2F;2<br>移动的次数：(1+2)+(2+2)+…+(n-1+2) &#x3D; (n-1)*(n+4)&#x2F;2 &#x3D; O(n2)  (i取值范围1~n-1)</p><p><strong>事件复杂度结论：原始数据越接近有序，排序速度越快</strong></p><p>1）最好的情况下（顺序有序）：O(n)<br>2）最坏的情况下（逆序有序）：O(n^2)<br>3）平均情况下，耗时差不多是最坏情况的一般：O(n^2)<br>4）要提高查找速度</p><p>减少元素的比较次数<br>减少元素的移动次数</p><ul><li>空间复杂度</li></ul><p>由直接插入排序算法可知，我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 O(1) 。</p><ul><li>算法稳定性</li></ul><p>直接插入排序的过程中，不需要改变相等数值元素的位置，所以它是稳定的算法。</p><ul><li>插入排序和选择排序的区别</li></ul><ol><li><p>插入排序和选择排序都有两层循环，外循环遍历整个数组</p></li><li><p>内循环稍有区别：</p><ul><li>选择排序的内循环是遍历一组未排过序的数组。</li><li>插入排序的内循环是遍历一组已排过序的数组。</li></ul></li></ol><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><ol><li><p>简介</p><p>希尔排序(Shell Sort)，一听这名字就知道是一个叫希尔的外国人发明的排序。没错，他就是唐纳德 <code>希尔</code>（Donald Shell），一位美国的计算机科学家，他于1959年发明的希尔排序算法。</p></li><li><p>希尔排序思路</p></li></ol><ul><li><p>希尔排序相当于 <code>直接插入排序的加强版</code>，在直接插入排序的概念之上加入了 <code>增量</code> 这个概念。</p></li><li><p>什么是增量？<br>  插入排序只能与相邻的元素进行比较，而希尔排序则是进行 <code>跳跃</code> 比较，而 <code>增量</code> 就是 跳跃的 <code>间隔数</code>。<br>  所谓增量即是把数组按照一定间隔数分组成不同的数组。例如:@{1,2,3,4,5,6,7},一共有6个元素，假设把数组按照增量3进行分组，那么就是@{1,4,7},@{2,5},@{3,6}各分为一组。因为增量是3，所以每间隔3个下坐标为一组。</p></li><li><p>按照增量分组后，把每一组的元素按照插入排序进行排序。当按照一个增量分组完成并每组数据按照插入排序完成后，将增量设为原本的二分之一，然后重复上面的步骤进行插入排序。直到增量为1，按照增量为1的最后一次进行分组插入排序。即完成了排序。</p></li></ul><ol start="3"><li>希尔排序的流程演示</li></ol><ul><li>原始数据：@[@(11),@(10),@(9),@(8),@(7),@(6),@(5),@(4),@(3),@(2),@(1)]</li></ul><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061837614.png"></p><ol><li>第一次分组：</li></ol><p>第一步，数组中有11个元素，把数组除以二，得到5(11&#x2F;2实际是等于5余1，由于取正所以为5，由于有余数，所以按照增量取出来的数组的 <code>组数</code> 有 <code>增量+1</code> 即 <code>5 + 1 = 6组</code>。如果没有余数则组数就是增量数。)，以5为增量，从数组第一个元素开始，每间隔5个数取出来的所有元素分为一组，分为6组，分别是：<br>@{11,7}、@{10,4}、@{9,3}、@{8,2}、@{5,1}、@{6}</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061837549.png"></p><p>第一次排序：每种颜色为一组。接着对每组进行插入排序(具体比较过程就不说了，看过上面插入排序的应该懂)，排序结果为下图(共交换5次):<br>@{7,11}、@{4,10}、@{3,9}、@{2,8}、@{1,5}、@{6}</p><p><img src="https://gitee.com/bboy-zhang-jian/picgo/raw/master/img/202303061838511.png"></p><p>2)第二次分组：将增量5再次除以2，得到2(实际5&#x2F;2是等于2余1，有余数所以组数为3)。分为3组分别是:<br>@{7,2,11,8}、@{4,1,10,5}、@{3,6,9}</p><p><img src="/BboyZJ.github.io/assets/16780991255622.jpg"></p><p>第二次排序：每种颜色为一组，对每组元素进行插入排序。排序结果为(共交换4次)<br>@{2,7,8,11}、@{1,4,5,10}、@{3,6,9}</p><p><img src="/BboyZJ.github.io/assets/16780991388627.jpg"></p><p>3)第三次分组：将增量2再次除以1，得到1(实际2&#x2F;2等1，没有余数，所以分为1组)。分组后是<br>@{2,1,3,7,4,6,8,5,9,11,10}</p><p><img src="/BboyZJ.github.io/assets/16780991560782.jpg"></p><p>第三次排序：最后对整组数组进行插入排序，排序结果为(共交换7次)：</p><p><img src="/BboyZJ.github.io/assets/16780991704280.jpg"></p><ol start="4"><li>希尔排序的特点</li></ol><p>1）一次移动，移动位置比较大，跳跃式地接近排序后的最终位置<br>2）最后一次只需要少量移动<br>3）增量序列必须是递减的，最后一个必须是1<br>4）增量序列应该是互质的</p><ol start="5"><li>实例</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSMutableArray * arr = [NSMutableArray arrayWithArray:@[@(9),@(3),@(8),@(5),@(2),@(4),@(7),@(6),@(1)]];</span><br><span class="line">    [self shellSort:arr];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)shellSort:(NSMutableArray *)list&#123;</span><br><span class="line">    // 起始间隔值gap设置为总数的一半</span><br><span class="line">    int gap = (int)list.count / 2;</span><br><span class="line">    // 直到gap==1结束</span><br><span class="line">    while (gap &gt;= 1) &#123;</span><br><span class="line">        //i为待排元素，以步距gap从后向前扫描</span><br><span class="line">        for(int i = gap ; i &lt; [list count]; i++)&#123;</span><br><span class="line">            //temp为待排元素i为其位置</span><br><span class="line">            NSInteger temp = [[list objectAtIndex:i] intValue];</span><br><span class="line">            //获取当前位置</span><br><span class="line">            int j = i;</span><br><span class="line">            //然后将此位置之前的元素，按照增量进行跳跃式比较</span><br><span class="line">            while (j &gt;= gap &amp;&amp; temp &lt; [[list objectAtIndex:(j - gap)] intValue]) &#123;</span><br><span class="line">                [list replaceObjectAtIndex:j withObject:[list objectAtIndex:j-gap]];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            //跳出循环时，j元素小于i的元素（待排元素）。插入新元素a[j] = temp，即空出来的位置插入待排序的值</span><br><span class="line">            [list replaceObjectAtIndex:j withObject:[NSNumber numberWithInteger:temp]];</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;步长：%d --- 希尔排序:%@&quot;,gap,[self getArrayStr:list]);</span><br><span class="line">        //步长</span><br><span class="line">        gap = gap / 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将数组中的元素拼接成字符串 - 方便打印</span><br><span class="line">- (NSString *)getArrayStr:(NSArray *)array &#123;</span><br><span class="line">    NSMutableString *strM = [NSMutableString string];</span><br><span class="line">    for (NSNumber *num in array) &#123;</span><br><span class="line">        [strM appendString:[NSString stringWithFormat:@&quot;%@,&quot;,num]];</span><br><span class="line">    &#125;</span><br><span class="line">    return strM.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-08-09 22:02:14.160098+0800 OC-哈希排序[23997:1116332] 步长：4 --- 希尔排序:1,3,7,5,2,4,8,6,9,</span><br><span class="line">2020-08-09 22:02:14.160373+0800 OC-哈希排序[23997:1116332] 步长：2 --- 希尔排序:1,3,2,4,7,5,8,6,9,</span><br><span class="line">2020-08-09 22:02:14.160620+0800 OC-哈希排序[23997:1116332] 步长：1 --- 希尔排序:1,2,3,4,5,6,7,8,9,</span><br></pre></td></tr></table></figure><ol start="6"><li>希尔排序算法分析：</li></ol><p>1）希尔排序的时间复杂度与增量的选取有关。例如，当增量为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为O(N²)，而Hibbard增量的希尔排序的时间复杂度为O(N3&#x2F;2)。<br>2）空间复杂度：<br>O(1)<br>3）是一种不稳定的排序算法：</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-算法探索篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC三方框架05：MLeaksFinder内存泄露探索</title>
      <link href="/BboyZJ.github.io/2020/08/05/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601.1%EF%BC%9AMLeaksFinder%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B/"/>
      <url>/BboyZJ.github.io/2020/08/05/OC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601.1%EF%BC%9AMLeaksFinder%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>腾讯开源了业界首创 iOS自动内存泄露检测工具 <code>MLeaksFinder</code>，MLeaksFinder 是 <code>iOS</code> 平台的自动内存泄漏检测工具，引进MLeaksFinder 后，就可以在日常的开发，调试业务逻辑的过程中自动地发现并警告内存泄漏。</p></li><li><p>平常我们都会用 <code>Instrument</code> 的 <code>Leaks / Allocations</code> 或其他一些开源库进行内存泄露的排查，但它们都存在各种问题和不便，我们逐个来看这些工具的使用和存在的问题。</p></li><li><p>无需修改任何业务逻辑代码，而且只在 <code>debug</code> 下开启，完全不影响你的 <code>release</code> 包。</p></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>MLeaksFinder</code> 是 <code>iOS</code> 平台的自动内存泄漏检测工具，引进 <code>MLeaksFinder</code> 后，就可以在日常的开发，调试业务逻辑的过程中自动地发现并警告内存泄漏。开发者无需打开 instrument 等工具，也无需为了找内存泄漏而去跑额外的流程。并且，由于开发者是在修改代码之后一跑业务逻辑就能发现内存泄漏的，这使得开发者能很快地意识到是哪里的代码写得问题。这种及时的内存泄漏的发现在很大的程度上降低了修复内存泄漏的成本。</p><h1 id="Leaks"><a href="#Leaks" class="headerlink" title="Leaks"></a>Leaks</h1><p>先看看 <code>Leaks</code>，从苹果的开发者文档里可以看到，一个 <code>app</code> 的内存分三类：</p><ul><li>Leaked memory: Memory unreferenced by your application that cannot be used again or freed (also detectable by using the Leaks instrument).</li></ul><p>真正的内存泄漏:在第一次 pop 的时候报 Memory Leak，在之后的重复 push 并 pop 同一个 ViewController 过程中，不报 Object Deallocated，但每次 pop 之后又报 Memory Leak。这种情况下每回进入并退出一个页面后，就报有新的内存泄漏，同时被报泄漏的对象又从来没有释放过，可以确定是真正的内存泄漏。</p><ul><li>Abandoned memory: Memory still referenced by your application that has no useful purpose.</li></ul><p>释放不及时：在第一次 pop 的时候报 Memory Leak，在之后的重复 push 并 pop 同一个 ViewController 过程中，对于同一个类不断地报 Object Deallocated 和 Memory Leak。这种情况属于释放不及时的情况。</p><ul><li>Cached memory: Memory still referenced by your application that might be used again for better performance.</li></ul><p>单例或者被 cache 起来复用：在第一次 pop 的时候报 Memory Leak，在之后的重复 push 并 pop 同一个 ViewController 过程中，即不报 Object Deallocated，也不报 Memory Leak。这种情况下我们可以确定该对象被设计成单例或者 cache 起来了。</p><ul><li>总结：其中 Leaked memory 和 Abandoned memory 都属于<strong>应该释放而没释放的内存</strong>，都是内存泄露，而 Leaks 工具只负责检测 Leaked memory，而不管 Abandoned memory。在 MRC 时代 Leaked memory 很常见，因为很容易<strong>忘了调用 release</strong>，但在 ARC 时代更常见的内存泄露是<strong>循环引用</strong>导致的 Abandoned memory，Leaks 工具查不出这类内存泄露，应用有限。</li></ul><h1 id="Allocations"><a href="#Allocations" class="headerlink" title="Allocations"></a>Allocations</h1><p>对于 Abandoned memory，可以用 Instrument 的 Allocations 检测出来。检测方法是用 Mark Generation 的方式，当你每次点击 Mark Generation 时，Allocations 会生成当前 App 的内存快照，而且 Allocations 会记录从上回内存快照到这次内存快照这个时间段内，新分配的内存信息。举一个最简单的例子：</p><p>我们可以不断重复 push 和 pop 同一个 UIViewController，理论上来说，push 之前跟 pop 之后，app 会回到相同的状态。因此，在 push 过程中新分配的内存，在 pop 之后应该被 dealloc 掉，除了前几次 push 可能有预热数据和 cache 数据的情况。如果在数次 push 跟 pop 之后，内存还不断增长，则有内存泄露。因此，我们在每回 push 之前跟 pop 之后，都 Mark Generation 一下，以此观察内存是不是无限制增长。</p><p>用这种方法来发现内存泄露还是很不方便的：</p><ul><li>首先，你得打开 Allocations</li><li>其次，你得一个个场景去重复的操作</li><li>无法及时得知泄露，得专门做一遍上述操作，十分繁琐</li></ul><h1 id="MLeaksFinder介绍"><a href="#MLeaksFinder介绍" class="headerlink" title="MLeaksFinder介绍"></a>MLeaksFinder介绍</h1><p>MLeaksFinder 提供了内存泄露检测更好的解决方案。只需要引入 MLeaksFinder，就可以自动在 App 运行过程检测到内存泄露的对象并立即提醒，无需打开额外的工具，也无需为了检测内存泄露而一个个场景去重复地操作。MLeaksFinder 目前能自动检测 UIViewController 和 UIView 对象的内存泄露，而且也可以扩展以检测其它类型的对象。</p><p>当发生内存泄露时，MLeaksFinder 会中断言，并准确的告诉你哪个对象泄露了。这里设计为中断言而不是打日志让程序继续跑，是因为很多人不会去看日志，断言则能强制开发者注意到并去修改，而不是犯拖延症。</p><p>中断言时，控制台会有如下提示，View-ViewController stack 从上往下看，该 stack 告诉你，MyTableViewController 的 UITableView 的 subview UITableViewWrapperView 的 subview MyTableViewCell 没被释放。而且，这里我们可以肯定的是 MyTableViewController，UITableView，UITableViewWrapperView 这三个已经成功释放了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Terminating app due to uncaught exception &#x27;NSInternalInconsistencyException&#x27;, reason: &#x27;Possibly Memory Leak.</span><br><span class="line">In case that MyTableViewCell should not be dealloced, override -willDealloc in MyTableViewCell by returning NO.</span><br><span class="line">View-ViewController stack: (</span><br><span class="line">    MyTableViewController,</span><br><span class="line">    UITableView,</span><br><span class="line">    UITableViewWrapperView,</span><br><span class="line">    MyTableViewCell</span><br><span class="line">)&#x27;</span><br></pre></td></tr></table></figure><h1 id="MLeaksFinder-的优点："><a href="#MLeaksFinder-的优点：" class="headerlink" title="MLeaksFinder 的优点："></a>MLeaksFinder 的优点：</h1><ul><li>使用简单，不侵入业务逻辑代码，不用打开 Instrument</li><li>不需要额外的操作，你只需开发你的业务逻辑，在你运行调试时就能帮你检测</li><li>内存泄露发现及时，更改完代码后一运行即能发现（这点很重要，你马上就能意识到哪里写错了）</li><li>精准，能准确地告诉你哪个对象没被释放</li></ul><h1 id="MLeaksFinder流程"><a href="#MLeaksFinder流程" class="headerlink" title="MLeaksFinder流程"></a>MLeaksFinder流程</h1><ol><li>先通过 <code>MLeaksFinder</code> 找到内存泄漏的对象。</li></ol><p>做法：MLeaksFinder 一开始从 UIViewController 入手。我们知道，当一个 UIViewController 被 pop 或 dismiss 后，该 UIViewController 包括它的 view，view 的 subviews 等等将很快被释放（除非你把它设计成单例，或者持有它的强引用，但一般很少这样做）。于是，我们只需在一个 ViewController 被 pop 或 dismiss 一小段时间后，看看该 UIViewController，它的 </p><ol start="2"><li>然后再过 <code>FBRetainCycleDetector</code> 检测该对象有没有循环引用。</li></ol><p>做法:当传入内存中的任意一个 <code>OC</code> 对象，FBRetainCycleDetector 会递归遍历该对象的所有强引用的对象，以检测以该对象为根结点的强引用树有没有循环引用。</p><h1 id="MLeaksFinder原理"><a href="#MLeaksFinder原理" class="headerlink" title="MLeaksFinder原理"></a>MLeaksFinder原理</h1><p>原理：</p><p><strong>为基类 NSObject 添加一个方法 -willDealloc 方法，该方法的作用是，先用一个弱指针指向 self，并在一小段时间(3秒)后，通过这个弱指针调用 -assertNotDealloc，而 -assertNotDealloc 主要作用是直接中断言。<br>当一个 UIViewController 被 pop 或 dismiss 时（我们认为它应该要被释放了），我们遍历该 UIViewController 上的所有 view，依次调 -willDealloc，若3秒后没被释放，就会中断言。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)willDealloc &#123;</span><br><span class="line">    __weak id weakSelf = self;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [weakSelf assertNotDealloc];</span><br><span class="line">    &#125;);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">- (void)assertNotDealloc &#123;</span><br><span class="line">     NSAssert(NO, @“”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，有几个问题需要解决：</p><ul><li><p>不入侵开发代码<br>这里使用了 AOP 技术，hook 掉 UIViewController 和 UINavigationController 的 pop 跟 dismiss 方法。</p></li><li><p>遍历相关对象<br>在实际项目中，我们发现有时候一个 UIViewController 被释放了，但它的 view 没被释放，或者一个 UIView 被释放了，但它的某个 subview 没被释放。这种内存泄露的情况很常见，因此，我们有必要遍历基于 UIViewController 的整棵 View-ViewController 树。我们通过 UIViewController 的 presentedViewController 和 view 属性，UIView 的 subviews 属性等递归遍历。对于某些 ViewController，如 UINavigationController，UISplitViewController 等，我们还需要遍历 viewControllers 属性。</p></li><li><p>构建堆栈信息<br>需要构建 View-ViewController stack 信息以告诉开发者是哪个对象没被释放。在递归遍历 View-ViewController 树时，子节点的 stack 信息由父节点的 stack 信息加上子结点信息即可。</p></li><li><p>例外机制<br>对于有些 ViewController，在被 pop 或 dismiss 后，不会被释放（比如单例），因此需要提供机制让开发者指定哪个对象不会被释放，这里可以通过重载上面的 -willDealloc 方法，直接 return NO 即可。</p></li><li><p>特殊情况<br>对于某些特殊情况，释放的时机不大一样（比如系统手势返回时，在划到一半时 hold 住，虽然已被 pop，但这时还不会被释放，ViewController 要等到完全 disappear 后才释放），需要做特殊处理，具体的特殊处理视具体情况而定。</p></li><li><p>系统View<br>某些系统的私有 View，不会被释放（可能是系统 bug 或者是系统出于某些原因故意这样做的，这里就不去深究了），因此需要建立白名单</p></li><li><p>手动扩展<br>MLeaksFinder目前只检测 ViewController 跟 View 对象。为此，MLeaksFinder 提供了一个手动扩展的机制，你可以从 UIViewController 跟 UIView 出发，去检测其它类型的对象的内存泄露。如下所示，我们可以检测 UIViewController 底下的 View Model：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)willDealloc &#123;</span><br><span class="line">    if (![super willDealloc]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    MLCheck(self.viewModel);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的原理跟上面的是一样的，宏 MLCheck() 做的事就是为传进来的对象建立 View-ViewController stack 信息，并对传进来的对象调用 -willDealloc 方法。</p><h1 id="MLeaksFinder源码"><a href="#MLeaksFinder源码" class="headerlink" title="MLeaksFinder源码"></a>MLeaksFinder源码</h1><p>1、MLeaksFinder.h<br>MLeaksFinder.h定义了MLeaksFinder中使用的宏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#ifdef MEMORY_LEAKS_FINDER_ENABLED</span><br><span class="line"> </span><br><span class="line">//_INTERNAL_MLF_ENABLED 宏用来控制 MLLeaksFinder库 </span><br><span class="line">//什么时候开启检测，可以自定义这个时机，默认则是在DEBUG模式下会启动，RELEASE模式下不启动</span><br><span class="line">//它是通过预编译来实现的</span><br><span class="line">#define _INTERNAL_MLF_ENABLED MEMORY_LEAKS_FINDER_ENABLED</span><br><span class="line"> </span><br><span class="line">#else</span><br><span class="line"> </span><br><span class="line">#define _INTERNAL_MLF_ENABLED DEBUG</span><br><span class="line"> </span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">//_INTERNAL_MLF_RC_ENABLED 宏用来控制 是否开启循环引用的检测</span><br><span class="line">#ifdef MEMORY_LEAKS_FINDER_RETAIN_CYCLE_ENABLED</span><br><span class="line"> </span><br><span class="line">#define _INTERNAL_MLF_RC_ENABLED MEMORY_LEAKS_FINDER_RETAIN_CYCLE_ENABLED</span><br><span class="line"> </span><br><span class="line">//COCOAPODS 因为MLLeaksFinder引用了第三库用来检查循环引用，所以必须是当前项目中使用了COCOAPODS，才能使用这个功能。</span><br><span class="line">#elif COCOAPODS</span><br><span class="line"> </span><br><span class="line">#define _INTERNAL_MLF_RC_ENABLED COCOAPODS</span><br><span class="line"> </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>2.MLeakedObjectProxy<br>MLeakedObjectProxy用来对泄漏对象检查循环引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">//用来检查当前泄漏对象是否已经添加到泄漏对象集合中，如果是，就不再添加也不再提示开发者</span><br><span class="line">+ (BOOL)isAnyObjectLeakedAtPtrs:(NSSet *)ptrs</span><br><span class="line">&#123;</span><br><span class="line">    NSAssert([NSThread isMainThread], @&quot;Must be in main thread.&quot;);</span><br><span class="line">  </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        //全局用于保存泄漏对象的集合</span><br><span class="line">        leakedObjectPtrs = [[NSMutableSet alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    if (!ptrs.count) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    //NSSet求交集</span><br><span class="line">    if ([leakedObjectPtrs intersectsSet:ptrs]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">+ (void)addLeakedObject:(id)object &#123;</span><br><span class="line"> </span><br><span class="line">    NSAssert([NSThread isMainThread], @&quot;Must be in main thread.&quot;);</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    //创建用于检查循环引用的objectProxy对象</span><br><span class="line">    MLeakedObjectProxy *proxy = [[MLeakedObjectProxy alloc] init];</span><br><span class="line"> </span><br><span class="line">    proxy.object = object;</span><br><span class="line"> </span><br><span class="line">    proxy.objectPtr = @((uintptr_t)object);</span><br><span class="line"> </span><br><span class="line">    proxy.viewStack = [object viewStack];</span><br><span class="line"> </span><br><span class="line">    static const void *const kLeakedObjectProxyKey = &amp;kLeakedObjectProxyKey;</span><br><span class="line"> </span><br><span class="line">    objc_setAssociatedObject(object, kLeakedObjectProxyKey, proxy, </span><br><span class="line">        OBJC_ASSOCIATION_RETAIN);</span><br><span class="line"> </span><br><span class="line">    [leakedObjectPtrs addObject:proxy.objectPtr];</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">#if _INTERNAL_MLF_RC_ENABLED</span><br><span class="line">    //带有循环引用检查功能的提示框</span><br><span class="line">    [MLeaksMessenger alertWithTitle:@&quot;Memory Leak&quot;</span><br><span class="line"> </span><br><span class="line">                            message:[NSString stringWithFormat:@&quot;%@&quot;, proxy.</span><br><span class="line">                            viewStack]</span><br><span class="line"> </span><br><span class="line">                           delegate:proxy</span><br><span class="line"> </span><br><span class="line">              additionalButtonTitle:@&quot;Retain Cycle&quot;];</span><br><span class="line"> </span><br><span class="line">#else</span><br><span class="line">    //普通提示框</span><br><span class="line">    [MLeaksMessenger alertWithTitle:@&quot;Memory Leak&quot;</span><br><span class="line"> </span><br><span class="line">                            message:[NSString stringWithFormat:@&quot;%@&quot;, proxy.</span><br><span class="line">                            viewStack]];</span><br><span class="line"> </span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)</span><br><span class="line">buttonIndex &#123;</span><br><span class="line"> </span><br><span class="line">#if _INTERNAL_MLF_RC_ENABLED</span><br><span class="line"> </span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line"> </span><br><span class="line">        FBRetainCycleDetector *detector = [FBRetainCycleDetector new];</span><br><span class="line"> </span><br><span class="line">        [detector addCandidate:self.object];</span><br><span class="line"> </span><br><span class="line">        NSSet *retainCycles = [detector findRetainCyclesWithMaxCycleLength:20];</span><br><span class="line"> </span><br><span class="line">        BOOL hasFound = NO;</span><br><span class="line"> </span><br><span class="line">        //retainCycles中是找到的所有循环引用的链</span><br><span class="line">        for (NSArray *retainCycle in retainCycles) &#123;</span><br><span class="line"> </span><br><span class="line">            NSInteger index = 0;</span><br><span class="line"> </span><br><span class="line">            for (FBObjectiveCGraphElement *element in retainCycle) &#123;</span><br><span class="line">                //找到当前内存泄漏对象所在的循环引用的链</span><br><span class="line">                if (element.object == object) &#123;</span><br><span class="line">                 //把当前对象调整到第一个的位置，方便查看</span><br><span class="line">                    NSArray *shiftedRetainCycle = [self shiftArray:retainCycle </span><br><span class="line">                    toIndex:index];</span><br><span class="line">                   </span><br><span class="line">                    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> </span><br><span class="line">                        [MLeaksMessenger alertWithTitle:@&quot;Retain Cycle&quot;</span><br><span class="line"> </span><br><span class="line">                                                message:[NSString </span><br><span class="line">                                                stringWithFormat:@&quot;%@&quot;, </span><br><span class="line">                                                shiftedRetainCycle]];</span><br><span class="line"> </span><br><span class="line">                    &#125;);</span><br><span class="line"> </span><br><span class="line">                    hasFound = YES;</span><br><span class="line"> </span><br><span class="line">                    break;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            if (hasFound) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if (!hasFound) &#123;</span><br><span class="line"> </span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> </span><br><span class="line">                [MLeaksMessenger alertWithTitle:@&quot;Retain Cycle&quot;</span><br><span class="line"> </span><br><span class="line">                                        message:@&quot;Fail to find a retain cycle&quot;];</span><br><span class="line"> </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.NSObject+MemoryLeak</p><p>NSObject+MemoryLeak主要功能存储对象的父子节点的树形结构，method swizzle逻辑 ，白名单以及判断对象是否发生内存泄漏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)willDealloc &#123;</span><br><span class="line"> </span><br><span class="line">    NSString *className = NSStringFromClass([self class]);</span><br><span class="line">    //通过白名单可以配置哪些对象不纳入检查，例如一些单例</span><br><span class="line">    if ([[NSObject classNamesInWhiteList] containsObject:className])</span><br><span class="line"> </span><br><span class="line">        return NO;</span><br><span class="line"> </span><br><span class="line">    NSNumber *senderPtr = objc_getAssociatedObject([UIApplication sharedApplication], kLatestSenderKey);</span><br><span class="line"> </span><br><span class="line">    if ([senderPtr isEqualToNumber:@((uintptr_t)self)])</span><br><span class="line"> </span><br><span class="line">        return NO;</span><br><span class="line"> </span><br><span class="line">    __weak id weakSelf = self;</span><br><span class="line">    //在特定时间检查对象是否已经发生内存泄漏</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)</span><br><span class="line">    ), dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> </span><br><span class="line">        __strong id strongSelf = weakSelf;</span><br><span class="line">        //如果对象已经被释放，strongSelf为nil 调用该方法什么也不发生</span><br><span class="line">        [strongSelf assertNotDealloc];</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    return YES;</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">//改方法被调用说明改对象已经发生内存泄漏</span><br><span class="line">- (void)assertNotDealloc &#123;</span><br><span class="line">    //检查是否已经记录，如果是，不再提示用户</span><br><span class="line">    if ([MLeakedObjectProxy isAnyObjectLeakedAtPtrs:[self parentPtrs]]) &#123;</span><br><span class="line"> </span><br><span class="line">        return;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    [MLeakedObjectProxy addLeakedObject:self];</span><br><span class="line"> </span><br><span class="line">    NSString *className = NSStringFromClass([self class]);</span><br><span class="line"> </span><br><span class="line">    NSLog(@&quot;Possibly Memory Leak.\nIn case that %@ should not be dealloced, </span><br><span class="line">    override -willDealloc in %@ by returning NO.\nView-ViewController stack: %@</span><br><span class="line">    &quot;, className, className, [self viewStack]);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//主要通过递归来记录每个节点在树形结构中的位置，以及父子节点的指针</span><br><span class="line">- (void)willReleaseChildren:(NSArray *)children &#123;</span><br><span class="line"> </span><br><span class="line">    NSArray *viewStack = [self viewStack];</span><br><span class="line"> </span><br><span class="line">    NSSet *parentPtrs = [self parentPtrs];</span><br><span class="line"> </span><br><span class="line">    for (id child in children) &#123;</span><br><span class="line"> </span><br><span class="line">        NSString *className = NSStringFromClass([child class]);</span><br><span class="line"> </span><br><span class="line">        [child setViewStack:[viewStack arrayByAddingObject:className]];</span><br><span class="line"> </span><br><span class="line">        [child setParentPtrs:[parentPtrs setByAddingObject:@((uintptr_t)child)]];</span><br><span class="line"> </span><br><span class="line">        [child willDealloc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">+ (void)swizzleSEL:(SEL)originalSEL withSEL:(SEL)swizzledSEL &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//通过预编译控制是否hook方法</span><br><span class="line">#if _INTERNAL_MLF_ENABLED</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">//通过预编译控制是否检查循环引用</span><br><span class="line">#if _INTERNAL_MLF_RC_ENABLED</span><br><span class="line">     // Just find a place to set up FBRetainCycleDetector.</span><br><span class="line">     static dispatch_once_t onceToken;</span><br><span class="line">     dispatch_once(&amp;onceToken, ^&#123;        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> </span><br><span class="line">            [FBAssociationManager hook];</span><br><span class="line"> </span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">#endif</span><br><span class="line">     Class class = [self class];</span><br><span class="line">     Method originalMethod = class_getInstanceMethod(class, originalSEL);</span><br><span class="line"> </span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(class, swizzledSEL);</span><br><span class="line"> </span><br><span class="line">    BOOL didAddMethod =</span><br><span class="line">    //class_addMethod主要是用来给某个类添加一个方法，originalSEL相当于是方法名称,method_getIm</span><br><span class="line">    //plementtation是方法实现, 它返回一个BOOL类型的值</span><br><span class="line">    //在当前class中没有叫originalSEL的方法(</span><br><span class="line">    //具体不是看interface里没有没有声明，而是看implementaion文件里有没有方法实现)，</span><br><span class="line">    // 并且有swizzledMethod方法的实现</span><br><span class="line">    //这个时候该函数会返回true，其他情况均返回false</span><br><span class="line">    class_addMethod(class,</span><br><span class="line"> </span><br><span class="line">                    originalSEL,</span><br><span class="line">                  method_getImplementation(swizzledMethod),</span><br><span class="line">                 method_getTypeEncoding(swizzledMethod));</span><br><span class="line"> </span><br><span class="line">    if (didAddMethod) &#123;</span><br><span class="line">        //didAddMethod为true 说明swizzledMethod之前不存在，通过class_addMethod函数添加了一个名字叫origninalSEL，实现是swizzledMoethod函数。</span><br><span class="line">        class_replaceMethod(class,</span><br><span class="line"> </span><br><span class="line">                            swizzledSEL,</span><br><span class="line"> </span><br><span class="line">                            method_getImplementation(originalMethod),</span><br><span class="line"> </span><br><span class="line">                            method_getTypeEncoding(originalMethod));</span><br><span class="line"> </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //didAddMethod为false 说明swizzledMethod方法已经存在，直接交换二者实现</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.UINavigationController + MemoryLeak</p><p>UINavigationController + MemoryLeak 主要是通过UINavigationController的方法去检测子UIViewController页面的生命周期，UIViewController的生命周期由UINavigationController的方法和UIViewController自身的一些方法共同决定的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//现在在具体的类型中添加方法hook，加载load中并且调用dspatch_once来保证只初始化一次，load是必然会调用的，并且category的load方法调用和类自身的load方法调用是分开的，互不干扰。</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">     dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">         [self swizzleSEL:@selector(pushViewController:animated:) withSEL:@</span><br><span class="line">        selector(swizzled_pushViewController:animated:)];</span><br><span class="line"> </span><br><span class="line">        [self swizzleSEL:@selector(popViewControllerAnimated:) withSEL:@</span><br><span class="line">        selector(swizzled_popViewControllerAnimated:)];</span><br><span class="line"> </span><br><span class="line">        [self swizzleSEL:@selector(popToViewController:animated:) withSEL:@</span><br><span class="line">        selector(swizzled_popToViewController:animated:)];</span><br><span class="line"> </span><br><span class="line">        [self swizzleSEL:@selector(popToRootViewControllerAnimated:) withSEL:@</span><br><span class="line">        selector(swizzled_popToRootViewControllerAnimated:)];</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">- (void)swizzled_pushViewController:(UIViewController *)viewController</span><br><span class="line"> animated:(BOOL)animated &#123;</span><br><span class="line"> </span><br><span class="line">    if (self.splitViewController) &#123;</span><br><span class="line">          //这里主要是考虑到app中有使用splitViewController的情况的时候，下一个根页面push之后，</span><br><span class="line">        //之前被pop的根页面才会回收</span><br><span class="line">        id detailViewController = objc_getAssociatedObject(self, </span><br><span class="line">            kPoppedDetailVCKey);</span><br><span class="line"> </span><br><span class="line">        if ([detailViewController isKindOfClass:[UIViewController class]]) &#123;</span><br><span class="line">    //回收之前被pop的根页面</span><br><span class="line">            [detailViewController willDealloc];</span><br><span class="line"> </span><br><span class="line">            objc_setAssociatedObject(self, kPoppedDetailVCKey, nil, </span><br><span class="line">                OBJC_ASSOCIATION_RETAIN);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    [self swizzled_pushViewController:viewController animated:animated];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">- (UIViewController *)swizzled_popViewControllerAnimated:(BOOL)animated &#123;</span><br><span class="line"> </span><br><span class="line">    UIViewController *poppedViewController = [self swizzled_popViewControllerAnimated:animated];</span><br><span class="line"> </span><br><span class="line">    if (!poppedViewController) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //当前页面是spliteViewController根页面</span><br><span class="line">    if (self.splitViewController &amp;&amp;</span><br><span class="line"> </span><br><span class="line">        self.splitViewController.viewControllers.firstObject == self &amp;&amp;</span><br><span class="line"> </span><br><span class="line">        self.splitViewController == poppedViewController.splitViewController) &#123;</span><br><span class="line"> </span><br><span class="line">        objc_setAssociatedObject(self, kPoppedDetailVCKey, poppedViewController</span><br><span class="line">            , OBJC_ASSOCIATION_RETAIN);</span><br><span class="line"> </span><br><span class="line">        return poppedViewController;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    // VC is not dealloced until disappear when popped using a left-edge swipe gesture</span><br><span class="line"> </span><br><span class="line">    extern const void *const kHasBeenPoppedKey;</span><br><span class="line"> </span><br><span class="line">objc_setAssociatedObject(poppedViewController, kHasBeenPoppedKey, @(YES), </span><br><span class="line">    OBJC_ASSOCIATION_RETAIN);</span><br><span class="line"> </span><br><span class="line">    return poppedViewController;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">- (NSArray&lt;UIViewController *&gt; *)swizzled_popToViewController:(</span><br><span class="line">    UIViewController *)viewController animated:(BOOL)animated &#123;</span><br><span class="line"> </span><br><span class="line">    NSArray&lt;UIViewController *&gt; *poppedViewControllers = [self </span><br><span class="line">    swizzled_popToViewController:viewController animated:animated];</span><br><span class="line">     </span><br><span class="line">    //一次性pop多个页面的时候，这些页面的viewDidDisappear估计都没有被调用，直接回收了</span><br><span class="line">    for (UIViewController *viewController in poppedViewControllers) &#123;</span><br><span class="line"> </span><br><span class="line">        [viewController willDealloc];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return poppedViewControllers;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5.UIViewController + MemoryLeak</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)swizzled_viewDidDisappear:(BOOL)animated &#123;</span><br><span class="line">    [self swizzled_viewDidDisappear:animated];</span><br><span class="line">    //仅仅当是pop引起viewDidDisappear的时候才释放(当被挡住之后也会调用ViewDidDisappear)</span><br><span class="line">    if ([objc_getAssociatedObject(self, kHasBeenPoppedKey) boolValue]) &#123;</span><br><span class="line"> </span><br><span class="line">        [self willDealloc];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">- (void)swizzled_dismissViewControllerAnimated:(BOOL)flag </span><br><span class="line">completion:(void (^)(void))completion &#123;</span><br><span class="line"> </span><br><span class="line">    [self swizzled_dismissViewControllerAnimated:flag completion:completion];</span><br><span class="line"> </span><br><span class="line">     //dismiss掉presentedViewController，释放它 (但是什么时候当前viewController被释放呢)</span><br><span class="line">    UIViewController *dismissedViewController = self.presentedViewController;</span><br><span class="line"> </span><br><span class="line">    if (!dismissedViewController &amp;&amp; self.presentingViewController) &#123;</span><br><span class="line">        //释放自己</span><br><span class="line">        dismissedViewController = self;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (!dismissedViewController) return;</span><br><span class="line">       //以present出来的viewcontroller，不通过DidDisappear去判断是否释放了</span><br><span class="line">    [dismissedViewController willDealloc];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="实际项目中使用"><a href="#实际项目中使用" class="headerlink" title="实际项目中使用"></a>实际项目中使用</h1><p>cocoapods集成<br>只需要在podfile文件中加入相关库即可。<br><code>pod &#39;MLeaksFinder&#39;</code></p>]]></content>
      
      
      <categories>
          
          <category> OC-三方框架探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC三方框架04：HDCollectionView探索</title>
      <link href="/BboyZJ.github.io/2020/08/04/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B604%EF%BC%9AHDCollectionView%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/04/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B604%EF%BC%9AHDCollectionView%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>1.HDCollectionView 初始化 (配置的参数优先级高于默认值)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> HDCollectionView 初始化 (配置的参数优先级高于默认值)</span><br><span class="line"> */</span><br><span class="line">+ (__kindof HDCollectionView*)hd_makeHDCollectionView:(void(^ _Nullable)(HDCollectionViewMaker*maker))maker;</span><br></pre></td></tr></table></figure><p>2.刷新colletionView</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 刷新colletionView</span><br><span class="line"> */</span><br><span class="line">- (void)hd_reloadData;</span><br></pre></td></tr></table></figure><p>3.一次性初始化所有数据 (完成后会回调 dataChangeFinishedCallBack)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 一次性初始化所有数据 (完成后会回调 dataChangeFinishedCallBack)</span><br><span class="line"> */</span><br><span class="line">- (void)hd_setAllDataArr:(NSArray&lt;id&lt;HDSectionModelProtocol&gt;&gt;* _Nullable)dataArr;</span><br></pre></td></tr></table></figure><p>4.包含所有数据改变相关方法完成后的回调（即setAll&#x2F;append&#x2F;delete&#x2F;change相关的函数完成后都会在此回调）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">包含所有数据改变相关方法完成后的回调（即setAll/append/delete/change相关的函数完成后都会在此回调）</span><br><span class="line"> */</span><br><span class="line">- (void)hd_dataChangeFinishedCallBack:(void(^)(HDDataChangeType changeType))finishCallback;</span><br></pre></td></tr></table></figure><p>5.直接添加一个新的secModel (完成后会回调 dataChangeFinishedCallBack)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">直接添加一个新的secModel (完成后会回调 dataChangeFinishedCallBack)</span><br><span class="line"> */</span><br><span class="line">- (void)hd_appendDataWithSecModel:(id&lt;HDSectionModelProtocol&gt;)secModel animated:(BOOL)animated;</span><br></pre></td></tr></table></figure><p>6.插入一个secModel到指定位置<br> index &lt;&#x3D; 0 插入到首段<br> index &gt;&#x3D; allDataArr.count 添加到最后一段<br> 0 &lt; index &lt; allDataArr.count 插入到index段的前面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">插入一个secModel到指定位置</span><br><span class="line"> index &lt;= 0 插入到首段</span><br><span class="line"> index &gt;= allDataArr.count 添加到最后一段</span><br><span class="line"> 0 &lt; index &lt; allDataArr.count 插入到index段的前面</span><br><span class="line"> */</span><br><span class="line">- (void)hd_insertDataWithSecModel:(id&lt;HDSectionModelProtocol&gt;)secModel atIndex:(NSInteger)index animated:(BOOL)animated;</span><br></pre></td></tr></table></figure><p>7.向某个段内增加cell&#x2F;默认的sectionKey是第几段<br> 该方法目前对于瀑布流元素的增加，内部计算是增量计算的。但对于HDYogaFlowLayout会对该段整体重新计算<br> 如果想增量计算HDYogaFlowLayout，使用hd_appendDataWithSecModel，新增一个新的段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 向某个段内增加cell/默认的sectionKey是第几段</span><br><span class="line"> 该方法目前对于瀑布流元素的增加，内部计算是增量计算的。但对于HDYogaFlowLayout会对该段整体重新计算</span><br><span class="line"> 如果想增量计算HDYogaFlowLayout，使用hd_appendDataWithSecModel，新增一个新的段。</span><br><span class="line"> */</span><br><span class="line">- (void)hd_appendDataWithCellModelArr:(NSArray&lt;id&lt;HDCellModelProtocol&gt;&gt;*)itemArr sectionKey:(NSString*)sectionKey animated:(BOOL)animated animationFinishCallback:(void(^ _Nullable)(void))animationFinish;</span><br><span class="line">- (void)hd_appendDataWithCellModelArr:(NSArray&lt;id&lt;HDCellModelProtocol&gt;&gt;*)itemArr sectionKey:(NSString*)sectionKey animated:(BOOL)animated;</span><br></pre></td></tr></table></figure><p>8.如果仅仅是向secModel新增cellModel，使用 hd_appendDataWithCellModelArr方法<br> 该方法改变已有的某个section内的数据，比如对sectionDataArr增删<br> 如果设置了SectionModel的sectionKey，则可以通过sectionKey来获取secModel。默认的sectionKey是当前段数<br> 想要刷新一个或几个cell的UI时，调用此方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 如果仅仅是向secModel新增cellModel，使用 hd_appendDataWithCellModelArr方法</span><br><span class="line"> 该方法改变已有的某个section内的数据，比如对sectionDataArr增删</span><br><span class="line"> 如果设置了SectionModel的sectionKey，则可以通过sectionKey来获取secModel。默认的sectionKey是当前段数</span><br><span class="line"> 想要刷新一个或几个cell的UI时，调用此方法</span><br><span class="line"> */</span><br><span class="line">- (void)hd_changeSectionModelWithKey:(nullable NSString*)sectionKey animated:(BOOL)animated changingIn:(void(^)(id&lt;HDSectionModelProtocol&gt; secModel))changeBlock animationFinishCallback:(void(^ _Nullable)(void))animationFinish;</span><br><span class="line">- (void)hd_changeSectionModelWithKey:(nullable NSString*)sectionKey animated:(BOOL)animated changingIn:(void(^)(id&lt;HDSectionModelProtocol&gt; secModel))changeBlock;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>9.删除某段的所有内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 删除某段的所有内容</span><br><span class="line"> */</span><br><span class="line">- (void)hd_deleteSectionWithKey:(nullable NSString*)sectionKey animated:(BOOL)animated animationFinishCallback:(void(^ _Nullable)(void))animationFinish;</span><br><span class="line">- (void)hd_deleteSectionWithKey:(nullable NSString*)sectionKey animated:(BOOL)animated;</span><br></pre></td></tr></table></figure><p>10.某个key的sectionModel是否存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 某个key的sectionModel是否存在</span><br><span class="line"> */</span><br><span class="line">- (BOOL)hd_sectionModelExist:(NSString*)sectionKey;</span><br></pre></td></tr></table></figure><p>11.删除某段的所有内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 删除某段的所有内容</span><br><span class="line"> */</span><br><span class="line">- (void)hd_deleteSectionWithKey:(nullable NSString*)sectionKey animated:(BOOL)animated animationFinishCallback:(void(^ _Nullable)(void))animationFinish;</span><br><span class="line">- (void)hd_deleteSectionWithKey:(nullable NSString*)sectionKey animated:(BOOL)animated;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OC-三方框架探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC三方框架02：SDCycleScrollView探索</title>
      <link href="/BboyZJ.github.io/2020/08/03/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B602%EF%BC%9ASDCycleScrollView%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/03/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B602%EF%BC%9ASDCycleScrollView%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><code>SDSycleScrollView</code> 的 <code>原理</code> 是基于 <code>UICollectionView</code> 的 <code>重用机制</code> 和 <code>循环滚动</code>的方式实现图片的轮播滚动功能。</p><h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><p>1.简单易用的图片无限轮播<br>2.支持横向、竖向两种滑动方式<br>3.支持轮播自定义cell的代理方<br>法<br>4.增加禁止拖动手势api</p><h1 id="集成-SDSyscleScrollView"><a href="#集成-SDSyscleScrollView" class="headerlink" title="集成 SDSyscleScrollView"></a>集成 SDSyscleScrollView</h1><p>现在的主流集成方式都是基于依赖管理工具<code>Cocoapods</code>来集成<code>SDSyscleScrollView</code>的，而 <code>SDSyscleScrollView</code> 是依赖 <code>SDWebImage</code> 显示<code>网络数据</code>的，但是这个框架不用我们自己去集成，当你集成 <code>SDSyscleScrollView</code> 时，会自动集成依赖的<code>SDWebImage</code> 库，具体集成流程如下：</p><ol><li><p>首先，保证你的项目是基于<code>Cocoapods</code>依赖管理工具集成的项目，具体的集成文档自行百度。</p></li><li><p>在终端输入 <code>pod search SDSyscleScrollView</code> 查看这个库的信息：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@MacdeMBP ~ % pod search SDCycleScrollView</span><br><span class="line">/System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0/universal-darwin19/rbconfig.rb:229: warning: Insecure world writable dir /usr/local/sbin in PATH, mode 040777</span><br></pre></td></tr></table></figure><p>稍等一会，你会看到下面的列表信息：</p><p><img src="https://user-images.githubusercontent.com/25925248/94383795-9a81d980-0173-11eb-8b6b-df2e3fa7f139.png"></p><p>由列表信息我们知道当前的 <code>SDSyscleScrollView</code> 的版本是 <code>1.80</code>， 且 适配 <code>SDWebImage 5.0.0</code>版本。</p><p>3.<code>复制</code>上面的 <code>pod &#39;SDCycleScrollView</code> , 在底部 <code>:</code> 号后面输入 <code>wq</code>，保存并退出，此时你可以到项目中的<code>Podfile</code>文件下 <code>粘贴</code> 你的复制的内容：</p><p><img src="https://user-images.githubusercontent.com/25925248/94384327-e719e480-0174-11eb-9a54-797a578b4a3a.png"></p><p>注：</p><ul><li><code>pod &#39;SDCycleScrollView</code>：意味着你只安装最新的版本</li><li><code>pod &#39;SDCycleScrollView&#39;, &#39;~&gt; 1.80</code>‘：意味着你安装的是固定版本 <code>1.80</code></li></ul><ol start="4"><li>cd 到工程主目录下，终端输入 <code>pod install</code> 命令，等待安装完成：</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/94384868-3c0a2a80-0176-11eb-958c-054e19244d4e.png"></p><h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><ol><li>在 <code>SDSyscleScrollView</code> 类中可以看到初始化方式有四种：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/** 初始轮播图（推荐使用） */</span><br><span class="line">+ (instancetype)cycleScrollViewWithFrame:(CGRect)frame delegate:(id&lt;SDCycleScrollViewDelegate&gt;)delegate placeholderImage:(UIImage *)placeholderImage;</span><br><span class="line"></span><br><span class="line">+ (instancetype)cycleScrollViewWithFrame:(CGRect)frame imageURLStringsGroup:(NSArray *)imageURLStringsGroup;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/** 本地图片轮播初始化方式 */</span><br><span class="line">+ (instancetype)cycleScrollViewWithFrame:(CGRect)frame imageNamesGroup:(NSArray *)imageNamesGroup;</span><br><span class="line"></span><br><span class="line">/** 本地图片轮播初始化方式2,infiniteLoop:是否无限循环 */</span><br><span class="line">+ (instancetype)cycleScrollViewWithFrame:(CGRect)frame shouldInfiniteLoop:(BOOL)infiniteLoop imageNamesGroup:(NSArray *)imageNamesGroup;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>数据源</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//////////////////////  数据源API //////////////////////</span><br><span class="line"></span><br><span class="line">/** 网络图片 url string 数组 */</span><br><span class="line">@property (nonatomic, strong) NSArray *imageURLStringsGroup;</span><br><span class="line"></span><br><span class="line">/** 每张图片对应要显示的文字数组 */</span><br><span class="line">@property (nonatomic, strong) NSArray *titlesGroup;</span><br><span class="line"></span><br><span class="line">/** 本地图片数组 */</span><br><span class="line">@property (nonatomic, strong) NSArray *localizationImageNamesGroup;</span><br></pre></td></tr></table></figure><ol start="3"><li>滚动控制API</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//////////////////////  滚动控制API //////////////////////</span><br><span class="line"></span><br><span class="line">/** 自动滚动间隔时间,默认2s */</span><br><span class="line">@property (nonatomic, assign) CGFloat autoScrollTimeInterval;</span><br><span class="line"></span><br><span class="line">/** 是否无限循环,默认Yes */</span><br><span class="line">@property (nonatomic,assign) BOOL infiniteLoop;</span><br><span class="line"></span><br><span class="line">/** 是否自动滚动,默认Yes */</span><br><span class="line">@property (nonatomic,assign) BOOL autoScroll;</span><br><span class="line"></span><br><span class="line">/** 图片滚动方向，默认为水平滚动 */</span><br><span class="line">@property (nonatomic, assign) UICollectionViewScrollDirection scrollDirection;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id&lt;SDCycleScrollViewDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">/** block方式监听点击 */</span><br><span class="line">@property (nonatomic, copy) void (^clickItemOperationBlock)(NSInteger currentIndex);</span><br><span class="line"></span><br><span class="line">/** block方式监听滚动 */</span><br><span class="line">@property (nonatomic, copy) void (^itemDidScrollOperationBlock)(NSInteger currentIndex);</span><br><span class="line"></span><br><span class="line">/** 可以调用此方法手动控制滚动到哪一个index */</span><br><span class="line">- (void)makeScrollViewScrollToIndex:(NSInteger)index;</span><br><span class="line"></span><br><span class="line">/** 解决viewWillAppear时出现时轮播图卡在一半的问题，在控制器viewWillAppear时调用此方法 */</span><br><span class="line">- (void)adjustWhenControllerViewWillAppera;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>自定义样式API</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">//////////////////////  自定义样式API  //////////////////////</span><br><span class="line"></span><br><span class="line">/** 轮播图片的ContentMode，默认为 UIViewContentModeScaleToFill */</span><br><span class="line">@property (nonatomic, assign) UIViewContentMode bannerImageViewContentMode;</span><br><span class="line"></span><br><span class="line">/** 占位图，用于网络未加载到图片时 */</span><br><span class="line">@property (nonatomic, strong) UIImage *placeholderImage;</span><br><span class="line"></span><br><span class="line">/** 是否显示分页控件 */</span><br><span class="line">@property (nonatomic, assign) BOOL showPageControl;</span><br><span class="line"></span><br><span class="line">/** 是否在只有一张图时隐藏pagecontrol，默认为YES */</span><br><span class="line">@property(nonatomic) BOOL hidesForSinglePage;</span><br><span class="line"></span><br><span class="line">/** 只展示文字轮播 */</span><br><span class="line">@property (nonatomic, assign) BOOL onlyDisplayText;</span><br><span class="line"></span><br><span class="line">/** pagecontrol 样式，默认为动画样式 */</span><br><span class="line">@property (nonatomic, assign) SDCycleScrollViewPageContolStyle pageControlStyle;</span><br><span class="line"></span><br><span class="line">/** 分页控件位置 */</span><br><span class="line">@property (nonatomic, assign) SDCycleScrollViewPageContolAliment pageControlAliment;</span><br><span class="line"></span><br><span class="line">/** 分页控件距离轮播图的底部间距（在默认间距基础上）的偏移量 */</span><br><span class="line">@property (nonatomic, assign) CGFloat pageControlBottomOffset;</span><br><span class="line"></span><br><span class="line">/** 分页控件距离轮播图的右边间距（在默认间距基础上）的偏移量 */</span><br><span class="line">@property (nonatomic, assign) CGFloat pageControlRightOffset;</span><br><span class="line"></span><br><span class="line">/** 分页控件小圆标大小 */</span><br><span class="line">@property (nonatomic, assign) CGSize pageControlDotSize;</span><br><span class="line"></span><br><span class="line">/** 当前分页控件小圆标颜色 */</span><br><span class="line">@property (nonatomic, strong) UIColor *currentPageDotColor;</span><br><span class="line"></span><br><span class="line">/** 其他分页控件小圆标颜色 */</span><br><span class="line">@property (nonatomic, strong) UIColor *pageDotColor;</span><br><span class="line"></span><br><span class="line">/** 当前分页控件小圆标图片 */</span><br><span class="line">@property (nonatomic, strong) UIImage *currentPageDotImage;</span><br><span class="line"></span><br><span class="line">/** 其他分页控件小圆标图片 */</span><br><span class="line">@property (nonatomic, strong) UIImage *pageDotImage;</span><br><span class="line"></span><br><span class="line">/** 轮播文字label字体颜色 */</span><br><span class="line">@property (nonatomic, strong) UIColor *titleLabelTextColor;</span><br><span class="line"></span><br><span class="line">/** 轮播文字label字体大小 */</span><br><span class="line">@property (nonatomic, strong) UIFont  *titleLabelTextFont;</span><br><span class="line"></span><br><span class="line">/** 轮播文字label背景颜色 */</span><br><span class="line">@property (nonatomic, strong) UIColor *titleLabelBackgroundColor;</span><br><span class="line"></span><br><span class="line">/** 轮播文字label高度 */</span><br><span class="line">@property (nonatomic, assign) CGFloat titleLabelHeight;</span><br><span class="line"></span><br><span class="line">/** 轮播文字label对齐方式 */</span><br><span class="line">@property (nonatomic, assign) NSTextAlignment titleLabelTextAlignment;</span><br><span class="line"></span><br><span class="line">/** 滚动手势禁用（文字轮播较实用） */</span><br><span class="line">- (void)disableScrollGesture;</span><br></pre></td></tr></table></figure><ol start="5"><li>缓存</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//////////////////////  清除缓存API  //////////////////////</span><br><span class="line"></span><br><span class="line">/** 清除图片缓存（此次升级后统一使用SDWebImage管理图片加载和缓存）  */</span><br><span class="line">+ (void)clearImagesCache;</span><br><span class="line"></span><br><span class="line">/** 清除图片缓存（兼容旧版本方法） */</span><br><span class="line">- (void)clearCache;</span><br></pre></td></tr></table></figure><ol start="6"><li>代理</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@protocol SDCycleScrollViewDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line"></span><br><span class="line">/** 点击图片回调 */</span><br><span class="line">- (void)cycleScrollView:(SDCycleScrollView *)cycleScrollView didSelectItemAtIndex:(NSInteger)index;</span><br><span class="line"></span><br><span class="line">/** 图片滚动回调 */</span><br><span class="line">- (void)cycleScrollView:(SDCycleScrollView *)cycleScrollView didScrollToIndex:(NSInteger)index;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 不需要自定义轮播cell的请忽略以下两个的代理方法</span><br><span class="line"></span><br><span class="line">// ========== 轮播自定义cell ==========</span><br><span class="line"></span><br><span class="line">/** 如果你需要自定义cell样式，请在实现此代理方法返回你的自定义cell的class。 */</span><br><span class="line">- (Class)customCollectionViewCellClassForCycleScrollView:(SDCycleScrollView *)view;</span><br><span class="line"></span><br><span class="line">/** 如果你需要自定义cell样式，请在实现此代理方法返回你的自定义cell的Nib。 */</span><br><span class="line">- (UINib *)customCollectionViewCellNibForCycleScrollView:(SDCycleScrollView *)view;</span><br><span class="line"></span><br><span class="line">/** 如果你自定义了cell样式，请在实现此代理方法为你的cell填充数据以及其它一系列设置 */</span><br><span class="line">- (void)setupCustomCell:(UICollectionViewCell *)cell forIndex:(NSInteger)index cycleScrollView:(SDCycleScrollView *)view;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>由代理可知，实际上有两个功能</p><ul><li>回调的滚动和点击事件</li><li>自动以cell样式</li></ul><h1 id="项目中使用-SDSyscleScrollView"><a href="#项目中使用-SDSyscleScrollView" class="headerlink" title="项目中使用 SDSyscleScrollView"></a>项目中使用 SDSyscleScrollView</h1><p>由于实际项目中，<code>轮播图</code>的主要应用是展示<code>网络图片</code>，并<code>点击</code>能进入下一个控制器，因此，下面我主要介绍这种类型功能的使用：</p><ol><li>声明属性，并初始化（使用推荐方式），设置占位图</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@interface SDSyscleScrollViewVC ()&lt;SDCycleScrollViewDelegate&gt;</span><br><span class="line">@property (nonatomic,strong)SDCycleScrollView * scrollV;</span><br><span class="line">@property (nonatomic,copy)NSArray * imgsArr;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#pragma mark -懒加载</span><br><span class="line">- (SDCycleScrollView *)scrollV&#123;</span><br><span class="line">    if (!_scrollV) &#123;</span><br><span class="line">        _scrollV = [SDCycleScrollView cycleScrollViewWithFrame:CGRectMake(0, kNavAndStatusHeight, kScreenWidth, 200) delegate:self placeholderImage:kImg(@&quot;placeholder&quot;)];</span><br><span class="line">        _scrollV.backgroundColor = kRandomColor;</span><br><span class="line">    &#125;</span><br><span class="line">    return _scrollV;</span><br><span class="line">&#125;</span><br><span class="line">- (NSArray *)imgsArr&#123;</span><br><span class="line">    if (!_imgsArr) &#123;</span><br><span class="line">        _imgsArr = @[</span><br><span class="line">            @&quot;https://user-images.githubusercontent.com/25925248/94383795-9a81d980-0173-11eb-8b6b-df2e3fa7f139.png&quot;,</span><br><span class="line">            @&quot;https://user-images.githubusercontent.com/25925248/94384327-e719e480-0174-11eb-9a54-797a578b4a3a.png&quot;,</span><br><span class="line">            @&quot;https://user-images.githubusercontent.com/25925248/94384868-3c0a2a80-0176-11eb-958c-054e19244d4e.png&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return _imgsArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>添加到要显示的view上</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.view.backgroundColor = kWhiteColor;</span><br><span class="line">    </span><br><span class="line">    // scrollV</span><br><span class="line">    [self.view addSubview:self.scrollV];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>设置相关API<br>具体可以<code>参照上面API</code>去设置，得到你想要的效果</p></li><li><p>待网络请求成功，返回图片数据时，设置图片数据</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.scrollV.imageURLStringsGroup = self.imgArr;    </span><br></pre></td></tr></table></figure><ol start="5"><li>通过代码方法可以得到你要下标和你要跳转的设置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -SDCycleScrollViewDelegate</span><br><span class="line">// 点击图片的回调</span><br><span class="line">- (void)cycleScrollView:(SDCycleScrollView *)cycleScrollView didSelectItemAtIndex:(NSInteger)index&#123;</span><br><span class="line">    NSLog(@&quot;index:%ld&quot;,index);</span><br><span class="line">&#125;</span><br><span class="line">// 图片滚动回调</span><br><span class="line">- (void)cycleScrollView:(SDCycleScrollView *)cycleScrollView didScrollToIndex:(NSInteger)index&#123;</span><br><span class="line">    NSLog(@&quot;index:%ld&quot;,index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>经过上面的基本设置，已经可以满足你的需求了，如果还未满足，那么你可以自定义<code>cell</code>去实现，是继承自 <code>CollectionViewCell</code> ：</li></ol><p>.h中实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface SDSyscleScrollViewVC ()&lt;SDCycleScrollViewDelegate&gt;</span><br><span class="line">@property (nonatomic,strong)SDCycleScrollView * scrollV;</span><br><span class="line">@property (nonatomic,copy)NSArray * imgsArr;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>.m中实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@implementation SDCell</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame&#123;</span><br><span class="line">    self = [super initWithFrame:frame];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        [self initUI];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)initUI&#123;</span><br><span class="line">    [self.contentView addSubview:self.img];</span><br><span class="line">    [self.img mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.edges.mas_equalTo(UIEdgeInsetsMake(0, 0, 0, 0));</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImageView *)img&#123;</span><br><span class="line">    if (!_img) &#123;</span><br><span class="line">        _img = [UIImageView initImgVWithFrame:CGRectZero bgColor:kRandomColor img:kPlaceholder userInteractionEnabled:YES hidden:NO];</span><br><span class="line">    &#125;</span><br><span class="line">    return _img;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在viewDidLoad中实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 如果你需要自定义cell样式，请在实现此代理方法返回你的自定义cell的class</span><br><span class="line">- (Class)customCollectionViewCellClassForCycleScrollView:(SDCycleScrollView *)view&#123;</span><br><span class="line">    SDCell * cell = [[SDCell alloc] init];</span><br><span class="line">    cell.backgroundColor = kRandomColor;</span><br><span class="line">    </span><br><span class="line">    return cell.class;</span><br><span class="line">&#125;</span><br><span class="line">// 如果你自定义了cell样式，请在实现此代理方法为你的cell填充数据以及其它一系列设置</span><br><span class="line">- (void)setupCustomCell:(UICollectionViewCell *)cell forIndex:(NSInteger)index cycleScrollView:(SDCycleScrollView *)view&#123;</span><br><span class="line">    SDCell * sdCell = (SDCell *)cell;</span><br><span class="line">    [sdCell.img sd_setImageWithURL:kUrl(self.imgsArr[index])];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OC-三方框架探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC：YYWebImage基本用法</title>
      <link href="/BboyZJ.github.io/2020/08/02/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B601%EF%BC%9AYYWebImage%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/02/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/OC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B601%EF%BC%9AYYWebImage%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OC-三方框架探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC学习14：cocoapods探索</title>
      <link href="/BboyZJ.github.io/2020/08/01/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A014%EF%BC%9Acocoapods%E6%8E%A2%E7%B4%A2/"/>
      <url>/BboyZJ.github.io/2020/08/01/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A014%EF%BC%9Acocoapods%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="CocoaPods-简介"><a href="#CocoaPods-简介" class="headerlink" title="CocoaPods 简介"></a>CocoaPods 简介</h1><ul><li><p>每种语言发展到一个阶段，就会出现响应的 <code>依赖管理工具</code>,例如 <code>Java</code> 的 <code>Maven</code>，<code>nodejs</code> 的 <code>nmp</code>，随着iOS开发者的增多，业界出现了为iOS程序提供 <code>依赖管理工具</code>，它的名字叫做：<a class="link"   href="https://cocoapods.org/" >Cocoapods <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p></li><li><p><code>Cocoapods</code> 项目 <a class="link"   href="https://github.com/CocoaPods/CocoaPods" >源码 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 存放在 <code>Github</code> 上进行管理，我们在开发iOS项目时，不可避免的要使用 <code>第三方开源库</code>，<code>Cocoapods</code> 的出现使我们 <code>节省了设置和更新第三方开源库的时间</code>。</p></li><li><p>从Github上我们可以看到它是用 <code>Ruby</code> 写的，主要依赖于 <code>Ruby</code> 环境，<code>Ruby</code> 是一种真正的 <code>面向对象编程语言</code>，它是由 <code>日本的松本行弘（まつもとゆきひろ/Yukihiro Matsumoto）</code> 创建于1993年，与Perl、Python等类似，是一种 <code>脚本语言</code>。</p></li></ul><h1 id="Ruby查看"><a href="#Ruby查看" class="headerlink" title="Ruby查看"></a>Ruby查看</h1><ul><li><p>在安装 <code>Cocoapods</code> 管理依赖工具前，我们需要保证 <code>Ruby</code> 环境是 <code>最新</code> 的，否则会出现一些 <code>安装问题</code></p></li><li><p>默认情况下，<code>MacOS</code> 系统已经安装好 <code>Ruby</code>，默认安装在 <code>/System/Library/Frameworks/Ruby.framework/Versions/Current</code> 目录下，但不是最新的环境</p></li><li><p>在 <code>终端</code> 可以直接通过以下命令，确认系统的 <code>Ruby</code> 的版本信息:</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@MacdeMBP ~ % ruby -v</span><br><span class="line">ruby 2.6.3p62 (2019-04-16 revision 67580) [universal.x86_64-darwin19]</span><br></pre></td></tr></table></figure></div><ul><li><p>但是，由于默认的 <code>Ruby</code> 安装在 <code>/System</code> 目录下，过深的与 <code>linux</code> 约定不同的目录结构对日常的开发、维护都带来许多不便。</p></li><li><p>所以，在 <code>MacOS</code> 上推荐使用 <code>homebrew</code> 来安装、管理 <code>Ruby</code> 的版本。</p></li></ul><h1 id="homebrew-安装-Ruby"><a href="#homebrew-安装-Ruby" class="headerlink" title="homebrew 安装 Ruby"></a>homebrew 安装 Ruby</h1><ol><li>安装 <code>homebrew</code></li></ol><ul><li>在终端下，执行下面的命令，即可完成homebrew的安装（注:安装过程中提示输入当前用户的密码）：</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&quot;</span><br></pre></td></tr></table></figure></div><ul><li><p>该命令将会从 <code>homebrew</code> 的 <code>GitHub</code> 仓库抓取最新版本并 <code>自动完成安装</code>。安装成功后，即可使用 <code>brew</code> 命令来安装 <code>Ruby</code> 的最新版本，以及其他工具。</p></li><li><p><code>homebrew</code> 的默认安装目录为 <code>/usr/local</code>，所有通过 <code>brew</code> 安装的程序都会默认安装到 <code>/usr/local/Cellars/程序名/版本号/</code> 目录下。</p></li></ul><ol start="2"><li>通过 <code>brew</code> 安装 <code>Ruby</code> 最新版本</li></ol><p>在终端下执行以下命令，即可自动完成最新版本 <code>Ruby</code> 的安装：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install ruby</span><br></pre></td></tr></table></figure></div><blockquote><p>说明:<br>1、<code>brew update</code> 将会从 <code>GitHub</code> 上更新 <code>brew</code> 所支持的所有软件的版本信息，保证你能够安装到最新的版本<br>2、<code>brew install ruby</code> 将会从 <code>Ruby</code> 的 <code>GitHub</code> 仓库抓取最新版本的代码，并编译安装</p></blockquote><ol start="3"><li>安装成功后，重新执行 <code>ruby -v</code> 确认已成功安装了最新版本的 Ruby：</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ruby -v</span><br><span class="line">ruby 2.6.3p62 (2019-04-16 revision 67580) [universal.x86_64-darwin19]</span><br></pre></td></tr></table></figure></div><h1 id="替换镜像源"><a href="#替换镜像源" class="headerlink" title="替换镜像源"></a>替换镜像源</h1><p>默认的镜像资源服务器被天朝给墙了。所以需要先更换源地址，然后再安装。</p><ol><li>移除原先的 <code>Ruby</code> 源：</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --remove https://rubygems.org/</span><br></pre></td></tr></table></figure></div><ol start="2"><li>指定为 <code>Ruby China</code> 的镜像源：</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --add https://gems.ruby-china.com/</span><br></pre></td></tr></table></figure></div><ol start="3"><li>验证新源是否替换成功</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -l</span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://gems.ruby-china.com/</span><br></pre></td></tr></table></figure></div><h1 id="Cocoapods-安装"><a href="#Cocoapods-安装" class="headerlink" title="Cocoapods 安装"></a>Cocoapods 安装</h1><p>使用 <code>ruby</code> 的 <code>gem</code> 命令下载并安装 <code>CocoaPods</code>。</p><ol><li><p><code>macOS Catalina</code> 系统版本之前用：<code>$sudo gem install cocoapods</code>；<br><code>macOS Catalina</code> 系统版本之前版本后需要改为 : <code>$ sudo gem install -n /usr/local/bin cocoapods </code></p></li><li><p>安装<code>$ pod setup</code></p></li></ol><ul><li><p>所有项目的 <code>Podspec</code> 文件都托管在 <a class="link"   href="https://github.com/CocoaPods/Specs" >https://github.com/CocoaPods/Specs <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 中。第一次执行 <code>pod setup</code> 时，<code>CocoaPods</code> 会将这些 <code>Podspec</code> 索引文件更新到本地的 <code>~/.cocoapods/目录下</code>，该索引文件较大且更新非常缓慢。</p></li><li><p>可以替换镜像，有两种方式：<code>gitcafe</code> 或者 <code>occhina</code> 镜像：</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod repo remove master</span><br><span class="line">pod repo add master https://gitcafe.com/akuandev/Specs.git</span><br><span class="line">pod repo update</span><br></pre></td></tr></table></figure></div><ul><li>也可以将以上代码中的 <code>https://gitcafe.com/akuandev/Specs.git</code> 替换成 h<code>ttp://git.oschina.net/akuandev/Specs.git</code> 即可使用 <code>occhina</code> 上的镜像。</li></ul><h1 id="搜索相关框架"><a href="#搜索相关框架" class="headerlink" title="搜索相关框架"></a>搜索相关框架</h1><p>打开终端，输入以下命令：<code>pod search 框架名</code>，如搜索网络框架 <code>AFNetworking</code></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod search AFNetworking</span><br></pre></td></tr></table></figure></div><h1 id="移除-trunk-源"><a href="#移除-trunk-源" class="headerlink" title="移除 trunk 源"></a>移除 trunk 源</h1><p>如果执行 <code>pod</code> 相关命令时，显示 <code>CDN</code> 无法连接、连接超时之类的情况，可以移除 <code>trunk</code> 源，然后在 <code>Podfile</code> 文件中第一行指明依赖库的来源地址，不使用默认 <code>CDN</code>。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo remove trunk</span><br></pre></td></tr></table></figure></div><h1 id="项目中的使用"><a href="#项目中的使用" class="headerlink" title="项目中的使用"></a>项目中的使用</h1><ol><li>创建 <code>Podfile</code> 文件</li></ol><p>新建 <code>Xcode</code> 项目，在终端里 <code>cd</code> 到项目的主文件夹(就是包含 项目 <code>.xcodeproj</code> 的文件)。执行命令：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建 Podfile 文件</span><br><span class="line">$ pod init</span><br></pre></td></tr></table></figure></div><ol start="2"><li>编辑 <code>Podfile</code> 文件有两种方式：</li></ol><ul><li><p>【方法一】：终端编辑 <code>vim Podfile</code><br>执行 <code>vim Podfile</code> 命令后，会打开上一步骤创建的 <code>Podfile</code> 文件，你需要通过 <code>vim</code> 编辑此文件，默认进入命令模式。</p><ul><li>键盘命令 <code>i</code> :input，输入模式</li><li>键盘命令 <code>ESC</code> : 从输入模式退出到命令模式</li><li>键盘命令 <code>shift + :</code> : 在命令模式下，输入该键盘组合命令，就会进入末行模式</li><li>键盘命令 <code>wq</code> : 在末行模式下，输入 wq ，即 <code>write and quit</code>，保存并退出！</li></ul></li><li><p>【方法二】：直接打开项目文件 <code>Podfile</code></p></li></ul><ol start="3"><li>保存文件后，安装第三方库</li></ol><ul><li>更新依赖库，执行 <code>pod update</code>（记得cd 到项目主文件下）。</li><li>安装依赖库，执行 <code>pod install</code>。</li></ul><ol start="4"><li>安装完成，此时项目文件中会多出 <code>.xcworkspace </code>文件，以后就通过它来打开项目。</li></ol><h1 id="Podfile-文件示例"><a href="#Podfile-文件示例" class="headerlink" title="Podfile 文件示例"></a>Podfile 文件示例</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"># 指明依赖库的来源地址，不使用默认 CDN</span><br><span class="line">source  &#x27;[https://github.com/CocoaPods/Specs.git](https://github.com/CocoaPods/Specs.git)&#x27;</span><br><span class="line"></span><br><span class="line"># Uncomment this line to define a global platform for your project</span><br><span class="line">platform :ios, &#x27;9.0&#x27;</span><br><span class="line"></span><br><span class="line"># 屏蔽所有第三方框架警告</span><br><span class="line">inhibit_all_warnings!    </span><br><span class="line"></span><br><span class="line">target &#x27;ProjectName&#x27; do</span><br><span class="line"></span><br><span class="line">  # Uncomment this line if you&#x27;re using Swift or would like to use dynamic frameworks</span><br><span class="line">  # use_frameworks!</span><br><span class="line"></span><br><span class="line">  # Pods for ProjectName</span><br><span class="line"></span><br><span class="line">  # 网络库</span><br><span class="line">  pod &#x27;AFNetworking&#x27;</span><br><span class="line">  pod &#x27;SDWebImage&#x27;</span><br><span class="line">  pod &#x27;Reachability&#x27;</span><br><span class="line"></span><br><span class="line">  # 服务类</span><br><span class="line">  pod &#x27;Bugly&#x27;</span><br><span class="line"></span><br><span class="line">  # UI</span><br><span class="line">  pod &#x27;Masonry&#x27;</span><br><span class="line">  pod &#x27;MBProgressHUD&#x27;</span><br><span class="line">  pod &#x27;MJRefresh&#x27;</span><br><span class="line">  pod &#x27;EAIntroView&#x27;</span><br><span class="line">  pod &#x27;SDCycleScrollView&#x27;</span><br><span class="line">  pod &#x27;DZNEmptyDataSet&#x27;</span><br><span class="line">  pod &#x27;XLForm&#x27;</span><br><span class="line">  pod &#x27;SHSPhoneComponent&#x27;</span><br><span class="line">  pod &#x27;BEMCheckBox&#x27;</span><br><span class="line">  pod &#x27;SCLAlertView-Objective-C&#x27;</span><br><span class="line"></span><br><span class="line">  # 工具组件类</span><br><span class="line">  pod &#x27;ChameleonFramework&#x27;</span><br><span class="line">  pod &#x27;FDFullscreenPopGesture&#x27;</span><br><span class="line">  pod &#x27;IQKeyboardManager&#x27;</span><br><span class="line">  pod &#x27;YYKit&#x27;</span><br><span class="line">  pod &#x27;UIAlertController+Blocks&#x27;</span><br><span class="line">  pod &#x27;LBXScan/LBXNative&#x27;</span><br><span class="line">  pod &#x27;LBXScan/UI&#x27;</span><br><span class="line">  pod &#x27;UITableView+FDTemplateLayoutCell&#x27;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#x27;ProjectNameTests&#x27; do</span><br><span class="line">  inherit! :search_paths</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">&quot;Podfile&quot; 52L, 999C</span><br></pre></td></tr></table></figure></div><h1 id="三方库常用命令"><a href="#三方库常用命令" class="headerlink" title="三方库常用命令"></a>三方库常用命令</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">###### 安装 Cocoapods ######</span><br><span class="line"></span><br><span class="line"># 更新 gem 版本</span><br><span class="line">$ sudo gem update --system</span><br><span class="line"></span><br><span class="line"># 查看已安装的 Ruby 版本</span><br><span class="line">$ gem -v</span><br><span class="line"></span><br><span class="line"># 替换 Ruby 源</span><br><span class="line">$ gem sources --remove [https://rubygems.org/](https://rubygems.org/)</span><br><span class="line">$ gem sources -add [https://gems.ruby-china.com/](https://gems.ruby-china.com/)</span><br><span class="line"></span><br><span class="line"># 查看验证镜像源</span><br><span class="line">$ gem sources -l</span><br><span class="line"></span><br><span class="line"># 卸载 Cocoapods</span><br><span class="line">$ sudo gem uninstall cocoapods</span><br><span class="line"></span><br><span class="line"># 重新安装 Cocoapods 到指定目录</span><br><span class="line">$ sudo gem install cocoapods -n /usr/local/bin</span><br><span class="line"></span><br><span class="line"># 查看当前 Cocoapods 版本</span><br><span class="line">$ pod --version</span><br><span class="line"></span><br><span class="line"># 更新本地的 Cocoapods 列表</span><br><span class="line">$ pod repo update</span><br><span class="line"></span><br><span class="line"># 移除 trunk 源</span><br><span class="line">$ pod repo remove trunk</span><br><span class="line"></span><br><span class="line">###### 项目中使用 ######</span><br><span class="line"></span><br><span class="line"># 搜索框架</span><br><span class="line">$ pod search 框架名</span><br><span class="line"></span><br><span class="line"># 终端导航到项目目录下</span><br><span class="line">$ cd [Project]</span><br><span class="line"></span><br><span class="line"># 创建 Podfile 文件</span><br><span class="line">$ pod init</span><br><span class="line"></span><br><span class="line"># 编辑 Podfile 文件</span><br><span class="line">$ vim Podfile</span><br><span class="line"></span><br><span class="line"># 安装</span><br><span class="line">$ pod install</span><br><span class="line"></span><br><span class="line"># 更新所有依赖的开源库</span><br><span class="line">$ pod update</span><br><span class="line">$ pod install --no-repo-update</span><br><span class="line">$ pod update --no-repo-update</span><br><span class="line"></span><br><span class="line"># 查看依赖库版本信息</span><br><span class="line">$ pod install --verbose --no-repo-update</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC-学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OCRunloop01：Runloop底层原理</title>
      <link href="/BboyZJ.github.io/2020/07/29/OCRuntime&amp;Runloop/OCRunloop01%EF%BC%9ARunloop%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/BboyZJ.github.io/2020/07/29/OCRuntime&amp;Runloop/OCRunloop01%EF%BC%9ARunloop%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Runloop"><a href="#什么是Runloop" class="headerlink" title="什么是Runloop?"></a>什么是Runloop?</h1><ol><li>runloop不仅仅是一个运行循环，还是一个对象，这个对象管理其需要处理的事件和消息，并提供了一个入口函数，通过这个入口函数，程序进入do…while循环，保证程序持续运行，不会退出。</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/88535378-5ae82580-d03c-11ea-8664-f0380cc8f6b8.png"></p><ol start="2"><li>验证：<a href="https://opensource.apple.com/tarballs/CF/">下载源码</a>,查看CFRunloop.c文件，找到CFRunLoopRun源码可知：确实是do…while循环。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopRun(void) &#123;/* DOES CALLOUT */</span><br><span class="line">    int32_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><a href="https://developer.apple.com/documentation/foundation/runloop">官方文档</a>：也有详细的说明:</li></ol><ul><li>Runloop不是线程安全的</li></ul><h1 id="Runloop的作用？"><a href="#Runloop的作用？" class="headerlink" title="Runloop的作用？"></a>Runloop的作用？</h1><ol><li>保持程序的持续运行。</li><li>处理APP中各种事件（触摸、定时器、performSelector）。</li><li>节省CPU资源，提高程序性能：该做事时做事，该休息时休息。</li></ol><p>程序中main函数的UIApplicationMain函数主要作用就是创建了一个主运行循环，主线程几乎所有的事情都是交给runloop去完成，如UI界面的刷新、点击事件的处理、performSelector等等，但并非所有的任务都是由runloop完成。</p><h1 id="Runloop对象"><a href="#Runloop对象" class="headerlink" title="Runloop对象"></a>Runloop对象</h1><h2 id="对象：iOS中有2套API来访问和使用RunLoop"><a href="#对象：iOS中有2套API来访问和使用RunLoop" class="headerlink" title="对象：iOS中有2套API来访问和使用RunLoop"></a>对象：iOS中有2套API来访问和使用RunLoop</h2><ul><li>OC语言：Foundation – NSRunloop </li><li>C语言： Core Foundaton – CFRunloopRef<br>NSRunLoop是基于CFRunLoopRef的一层OC包装。<br>获取RunLoop对象：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foundation</span><br><span class="line">[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象</span><br><span class="line">[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象</span><br><span class="line"></span><br><span class="line">Core Foundation</span><br><span class="line">CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象</span><br><span class="line">CFRunLoopGetMain(); // 获得主线程的RunLoop对象</span><br></pre></td></tr></table></figure><h1 id="Runloop相关的类"><a href="#Runloop相关的类" class="headerlink" title="Runloop相关的类"></a>Runloop相关的类</h1><p><strong>1.Core Foundation中关于Runloop的5个类：</strong></p><ul><li>CFRunloopRef： Runloop的对象</li><li>CFRunloopModeRef： 模式</li><li>CFRunloopSourceRef： 输入源&#x2F;事件源</li><li>CFRunloopTimerRef： Timer事件</li><li>CFRunloopObserveRef： 监听这，监听Runloop的状态改变</li></ul><p><strong>2.CFRunloopRef:</strong></p><p>CFRunloopRef是Runloop的对象</p><p><strong>3.CFRunloopModeRef：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __CFRunLoopMode *CFRunLoopModeRef;</span><br><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/25925248/88552900-364d7700-d057-11ea-8e52-51056b6536a4.png"></p><p>由上述源码和图可知:</p><ol><li>CFRunLoopModeRef代表RunLoop的运行模式，一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer，RunLoop启动时只能选择其中一个Mode，作为currentMode，如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入，不同组的Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer能分隔开来，互不影响，如果Mode里没有任何Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer，RunLoop会立马退出。</li></ol><p><strong>2) NSRunloopRef常见的几种Mode:</strong><br>代码去打印一下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// CFRunloopModel研究</span><br><span class="line">CFRunLoopRef lp = CFRunLoopGetCurrent();</span><br><span class="line">CFRunLoopMode mode = CFRunLoopCopyCurrentMode(lp);</span><br><span class="line">NSLog(@&quot;mode:%@&quot;,mode);</span><br><span class="line">CFArrayRef modeArr = CFRunLoopCopyAllModes(lp);</span><br><span class="line">NSLog(@&quot;modeArr:%@&quot;,modeArr);</span><br></pre></td></tr></table></figure><ul><li>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App的默认Mode，通常主线程是在这个Mode下运行;</li><li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li><li>NSRunLoopCommonModes：并不是一个真正的模式,只是一个标记</li><li>GSEventReceiveRunLoopMode</li></ul><p><strong>4.CFRunloopSourceRef：</strong><br>触摸事件：source0</p><p><img src="https://user-images.githubusercontent.com/25925248/88558928-c8a54900-d05e-11ea-826c-6c21a0a943d9.png"></p><p>由上面的截图可知：runloop处理source0事件是调用的*<strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong>*函数。<br>我们来看一下源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__() __attribute__((noinline));</span><br><span class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(void (*perform)(void *), void *info) &#123;</span><br><span class="line">    if (perform) &#123;</span><br><span class="line">        perform(info);</span><br><span class="line">    &#125;</span><br><span class="line">    asm __volatile__(&quot;&quot;); // thwart tail-call optimization</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.CFRunloopTimerRef：</strong><br>timer类型:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">        NSLog(@&quot;小老弟&quot;);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/25925248/88558179-c989ab00-d05d-11ea-9d3b-5f0e0121c66c.png"></p><p>由上面的截图可知：runloop处理timer事件是调用的__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__*函数进行事件处理：<br>再看一下源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__() __attribute__((noinline));</span><br><span class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(CFRunLoopTimerCallBack func, CFRunLoopTimerRef timer, void *info) &#123;</span><br><span class="line">    if (func) &#123;</span><br><span class="line">        func(timer, info);</span><br><span class="line">    &#125;</span><br><span class="line">    asm __volatile__(&quot;&quot;); // thwart tail-call optimization</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6.CFRunloopObserveRef：</strong><br>用来监听runloop的活动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/ Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理timers</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理sources</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7), //即将推出Loop</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>添加Observer监听RunLoop的所有状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 创建监听者</span><br><span class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">    switch (activity) &#123;</span><br><span class="line">      case kCFRunLoopEntry:</span><br><span class="line">        NSLog(@&quot;kCFRunLoopEntry&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case kCFRunLoopBeforeTimers:</span><br><span class="line">        NSLog(@&quot;kCFRunLoopBeforeTimers&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case kCFRunLoopBeforeSources:</span><br><span class="line">        NSLog(@&quot;kCFRunLoopBeforeSources&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case kCFRunLoopBeforeWaiting:</span><br><span class="line">        NSLog(@&quot;kCFRunLoopBeforeWaiting&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case kCFRunLoopAfterWaiting:</span><br><span class="line">        NSLog(@&quot;kCFRunLoopAfterWaiting&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case kCFRunLoopExit:</span><br><span class="line">        NSLog(@&quot;kCFRunLoopExit&quot;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 添加Observer到RunLoop中</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">// 释放</span><br><span class="line">CFRelease(observer);</span><br></pre></td></tr></table></figure><p><strong>7.Mode中各个成员的含义:</strong></p><ul><li>source0:<br>1）触摸事件(TouchUp)<br>2）performSelector :OnThread</li><li>source1<br>1）基于Port的线程间通信<br>2）系统事件的捕捉</li><li>Timer<br>1）NSTimer<br>2）performSelector :afterDelay &#x2F;&#x2F; 这句代码的本质是往Runloop中添加定时器</li><li>Observers<br>1）监听runloop的状态<br>2）UI刷新(在runloop休眠之前)<br>3）自动释放池(在runloop休眠之前)</li></ul><p><strong>8.runloop处理items事件的总结:</strong><br>runloop处理items以下事件调用函数的总结:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* block:__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span><br><span class="line">* timer:__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span><br><span class="line">* source0:__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span><br><span class="line">* source1:__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span><br><span class="line">* gcd主队列:_CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</span><br><span class="line">* observe源：__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><br></pre></td></tr></table></figure><h1 id="Runloop与线程的关系？"><a href="#Runloop与线程的关系？" class="headerlink" title="Runloop与线程的关系？"></a>Runloop与线程的关系？</h1><ol><li>每一条线程都有一个与之对应runloop对象。</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/88561601-3606a900-d062-11ea-8775-1fc03400c90c.png"></p><p>查看源码验证，线程和runloop是一一对应的关系:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    static CFRunLoopRef __main = NULL; // no retain needed</span><br><span class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</span><br><span class="line">    return __main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFLock(&amp;loopsLock);</span><br><span class="line">    if (!__CFRunLoops) &#123;</span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line">CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">//获取mainloop</span><br><span class="line">CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">//通过key value方式一一对应</span><br><span class="line">CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">    CFRelease(dict);</span><br><span class="line">&#125;</span><br><span class="line">CFRelease(mainLoop);</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>runloop保存在全局的NSMutableDictionaryRef字典当中，以线程为key，runloop为value。<br>由上面的源码可验证。</p></li><li><p>主线程的Runloop系统自动获取（创建），子线程默认没有开启runloop。<br>看代码：问下面的<em>子线程 timer</em>会打印么？<br>答:不会，因为子线程的runloop默认没有开启，需要开启子线程的runloop</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSThread * thread = [[NSThread alloc] initWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;hello:%@&quot;,[NSThread currentThread]);</span><br><span class="line">    [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">        NSLog(@&quot;子线程 timer&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">thread.name = @&quot;zj&quot;;</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure><p>问：那要怎么写才能开启？并能控制其打印?<br>答：通过[[NSRunLoop currentRunLoop] run];获取子线程的runloop并开启子线程的runloop。通过控制线程退出-&gt;控制runloop退出-&gt;控制timer不打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,assign)BOOL isStop;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.isStop = NO;</span><br><span class="line">    </span><br><span class="line">    NSThread * thread = [[NSThread alloc] initWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;hello:%@&quot;,[NSThread currentThread]);</span><br><span class="line">        [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">            NSLog(@&quot;子线程 timer&quot;);</span><br><span class="line">            if (self.isStop) &#123;</span><br><span class="line">                [NSThread exit];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        [[NSRunLoop currentRunLoop] run];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    thread.name = @&quot;zj&quot;;</span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    self.isStop = YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>线程刚创建时是没有runloop对象，runloop会在第一次获取时创建。</li><li>runloop在线程销毁时销毁。</li></ol><h1 id="timer和runloop？"><a href="#timer和runloop？" class="headerlink" title="timer和runloop？"></a>timer和runloop？</h1><ol><li>问：视图在滑动的时候为什么NSTimer会不走？</li></ol><p>答：因为默认在主线程NSTimer是加入到kCFRunLoopDefaultMode下的，而视图滑动的时候主线程的mode会切换到UITrackingRunLoopMode模式下，导致NSTimer不走，因而需要将NSTimer加入到UITrackingRunLoopMode或者KCFRunloopCommonMode下。</p><p>代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">    NSLog(@&quot;aaaaa&quot;);</span><br><span class="line">&#125;];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure><ol start="2"><li>问NSTimer是怎么加入到UITrackingRunLoopMode或者KCFRunloopCommonMode下就不会造成卡顿?</li></ol><p>答:NSTimer通过底层函数CFRunLoopAddTimer加入到items中。然后再runloopRun运行的时候，通过while循环遍历item找到timer的mode是否和当前的mode相等或等于commonMode，如果相等调用block函数返回执行。</p><p>自己去写代码验证一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)cftimerDemo&#123;</span><br><span class="line">    CFRunLoopTimerContext context = &#123;</span><br><span class="line">        0,</span><br><span class="line">        ((__bridge void *)self),</span><br><span class="line">        NULL,</span><br><span class="line">        NULL,</span><br><span class="line">        NULL</span><br><span class="line">    &#125;;</span><br><span class="line">    CFRunLoopRef rlp = CFRunLoopGetCurrent();</span><br><span class="line">    /*</span><br><span class="line">     参数一：用于分配对象的内存</span><br><span class="line">     参数二：在什么时候触发</span><br><span class="line">     参数三：每隔多少时间触发一次</span><br><span class="line">     参数四：未来参数</span><br><span class="line">     参数五：CFRunloopObserver的优先级，当Runloop同一运行阶段中有多少CFRunloopObserver 正常情况下使用0</span><br><span class="line">     参数六：回调，比如触发事件，我们就会来到这里</span><br><span class="line">     参数七：上下文记录信息</span><br><span class="line">     */</span><br><span class="line">    CFRunLoopTimerRef timerRef = CFRunLoopTimerCreate(kCFAllocatorDefault, 0, 1, 0, 0, zjRunloopTimerCallBack, &amp;context);</span><br><span class="line">    CFRunLoopAddTimer(rlp, timerRef, kCFRunLoopDefaultMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void zjRunloopTimerCallBack(CFRunLoopTimerRef timer,void * info) &#123;</span><br><span class="line">    NSLog(@&quot;%@---%@&quot;,timer,info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Observer和runloop"><a href="#Observer和runloop" class="headerlink" title="Observer和runloop"></a>Observer和runloop</h1><h1 id="Runloop运行流程"><a href="#Runloop运行流程" class="headerlink" title="Runloop运行流程"></a>Runloop运行流程</h1><p><strong>1.NSRunLoop:</strong><br> 是基于 CFRunLoopRef 的OC封装，提供了面向对象的 API，但不是线程安全的，CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，是线程安全的，CoreFoundation是开源的(<a href="https://opensource.apple.com/tarballs/CF/">CoreFoundation 源码地址</a>)</p><p><strong>2.runloop的运行逻辑</strong></p><p><img src="https://user-images.githubusercontent.com/25925248/88556638-d6a59a80-d05b-11ea-8a9c-a4ab1a75a0af.png"></p><p><img src="https://user-images.githubusercontent.com/25925248/88557269-95fa5100-d05c-11ea-87a9-2aebc850f62b.png"></p><h1 id="Runloop实际应用"><a href="#Runloop实际应用" class="headerlink" title="Runloop实际应用"></a>Runloop实际应用</h1>]]></content>
      
      
      <categories>
          
          <category> OC-Runloop探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC：Block底层探索</title>
      <link href="/BboyZJ.github.io/2020/07/26/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A017%EF%BC%9ABlock/"/>
      <url>/BboyZJ.github.io/2020/07/26/OC%E5%AD%A6%E4%B9%A0/OC%E5%AD%A6%E4%B9%A017%EF%BC%9ABlock/</url>
      
        <content type="html"><![CDATA[<h1 id="Block初探"><a href="#Block初探" class="headerlink" title="Block初探"></a>Block初探</h1><h2 id="什么是Block？"><a href="#什么是Block？" class="headerlink" title="什么是Block？"></a>什么是Block？</h2><p>Block是将函数及其上下文封装起来的对象。</p><h2 id="什么是Block调用"><a href="#什么是Block调用" class="headerlink" title="什么是Block调用?"></a>什么是Block调用?</h2><p>Block调用即函数的调用。</p><h2 id="Block的分类？"><a href="#Block的分类？" class="headerlink" title="Block的分类？"></a>Block的分类？</h2><p>根据内存分布</p><ul><li>全局Block(NSGlobalBlock):</li></ul><p>全局Block存储在已初始化静态(.data)区。</p><p>例子1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 全局block __NSGlobalBlock__</span><br><span class="line">void (^block)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;张建&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br><span class="line">NSLog(@&quot;%@&quot;,block);</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-08-01 23:57:47.626190+0800 OC-Block初探[14671:824715] &lt;__NSGlobalBlock__: 0x10556c038&gt;</span><br></pre></td></tr></table></figure><p>例子2：在实际开发中往往是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[self testBlock:^(id data) &#123;</span><br><span class="line">    NSLog(@&quot;我来了&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">- (void)testBlock:(void(^)(id data))block&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,block);</span><br><span class="line">    if (block) &#123;</span><br><span class="line">        block(@&quot;zj&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>栈Block(NSStackBlock):<br>栈Block存储在栈(stack)区。</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 栈block __NSStackBlock__</span><br><span class="line">int b = 20;</span><br><span class="line">NSLog(@&quot;%@&quot;,^&#123;</span><br><span class="line">    NSLog(@&quot;%d&quot;,b);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打印结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 栈block __NSStackBlock__</span><br><span class="line">int b = 20;</span><br><span class="line">NSLog(@&quot;%@&quot;,^&#123;</span><br><span class="line">    NSLog(@&quot;%d&quot;,b);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>堆Block(NSMallocBlock):<br>堆Block存储在堆(heap)区。</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 堆block __NSMallocBlock__</span><br><span class="line">int a = 10;</span><br><span class="line">void (^ZJBlock)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;%d&quot;,a);</span><br><span class="line">&#125;;</span><br><span class="line">ZJBlock();</span><br><span class="line">NSLog(@&quot;%@&quot;,ZJBlock);</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-08-02 00:23:32.061735+0800 OC-Block初探[14930:847689] 10</span><br><span class="line">2020-08-02 00:23:34.873090+0800 OC-Block初探[14930:847689] &lt;__NSMallocBlock__: 0x6000029ef510&gt;</span><br></pre></td></tr></table></figure><h1 id="Block底层原理"><a href="#Block底层原理" class="headerlink" title="Block底层原理"></a>Block底层原理</h1><ol><li>block的本质<br>block本质上是一个OC对象，它内部也有isa指针，这个对象封装了函数调用地址以及函数调用环境(函数参数、返回值、捕获的外部变量等)。当我们定义一个block，在编译后它的底层存储结构是怎样的呢？<br>下面我们来看一个例子，定义了一个block，并在block里面访问量block外面的变量age，它底层存储结构如下图所示，block底层就是一个结构体__main_block_impl_0。</li></ol><p><img src="https://user-images.githubusercontent.com/25925248/89857411-90f5df80-dbce-11ea-9d8e-9fa1cdd0615e.png"></p><ul><li>impl-&gt;isa：就是isa指针，可见它就是一个OC对象。</li><li>impl-&gt;FuncPtr：是一个函数指针，也就是底层将block中要执行的代码封装成了一个函数，然后用这个指针指向那个函数。</li><li>Desc-&gt;Block_size：block占用的内存大小。</li><li>age：捕获的外部变量age，可见block会捕获外部变量并将其存储在block的底层结构体中。</li></ul><p>当我们调用block时(block())，实际上就是通过函数指针FuncPtr找到封装的函数并将block的地址作为参数传给这个函数进行执行，把block传给函数是因为函数执行中需要用到的某些数据是存在block的结构体中的(比如捕获的外部变量)。如果定义的是带参数的block，调用block时是将block地址和block的参数一起传给封装好的函数。</p><ol start="2"><li>block的变量捕获机制</li></ol><p>block外部的变量是可以被block捕获的，这样就可以在block内部使用外部的变量了。不同类型的变量的捕获机制是不一样的。下面我们来看一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int c = 1000; // 全局变量</span><br><span class="line">static int d = 10000; // 静态全局变量</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        int a = 10; // 局部变量</span><br><span class="line">        static int b = 100; // 静态局部变量</span><br><span class="line">        void (^block)(void) = ^&#123;</span><br><span class="line">             NSLog(@&quot;a = %d&quot;,a);</span><br><span class="line">             NSLog(@&quot;b = %d&quot;,b);</span><br><span class="line">             NSLog(@&quot;c = %d&quot;,c);</span><br><span class="line">             NSLog(@&quot;d = %d&quot;,d);</span><br><span class="line">         &#125;;</span><br><span class="line">         a = 20;</span><br><span class="line">         b = 200;</span><br><span class="line">         c = 2000;</span><br><span class="line">         d = 20000;</span><br><span class="line">         block();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ***************打印结果***************</span><br><span class="line">2020-07-07 15:08:37.541840+0800 CommandLine[70672:7611766] a = 10</span><br><span class="line">2020-07-07 15:08:37.542168+0800 CommandLine[70672:7611766] b = 200</span><br><span class="line">2020-07-07 15:08:37.542201+0800 CommandLine[70672:7611766] c = 2000</span><br><span class="line">2020-07-07 15:08:37.542222+0800 CommandLine[70672:7611766] d = 20000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于运行结果我们后面再做讲解，我们先来看一下定义的这个block的在编译后底层存储结构是怎么样的呢？(可以在命令行运行xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m将这个main.m文件转成编译后的c&#x2F;c++文件，然后在这个文件搜索__main_block_impl_0就可以找到这个block的结构体)。<br>struct __main_block_impl_0 {<br>  struct __block_impl impl;<br>  struct __main_block_desc_0* Desc;<br>  int a;<br>  int *b;<br>};<br>我们可以发现，我定义了4个变量，结果只有2个局部变量被捕获了，而且2个局部变量的捕获方式还不一样。为什么会这样呢？下面来一一解释：</p><p>2.1 全局变量的捕获<br>不管是普通全局变量还是静态全局变量，block都不会捕获。因为全局变量在哪里都可以访问，所以block内部不捕获也是可以直接访问全局变量的，所以外部更改全局变量的值时，block内部打印的就是最新更改的值。</p><p>2.2 静态局部变量的捕获<br>我们发现定义的静态局部变量b被block捕获后，在block结构体里面是以int *b;的形式来存储的，也就是说block其实是捕获的变量b的地址，block内部是通过b的地址去获取或修改b的值，所以block外部更改b的值会影响block里面获取的b的值，block里面更改b的值也会影响block外面b的值。所以上面会打印b &#x3D; 200。</p><p>2.3 普通局部变量的捕获<br>所谓的普通局部变量就是在一个函数或代码块中定义的类似int a &#x3D; 10;的变量，它其实是省略了auto关键字，等价于auto int a &#x3D; 10，所以也叫auto变量。和静态局部变量不同的是，普通局部变量被block捕获后再block底层结构体中是以int a;的形式存储，也就是说block捕获的其实是a的值(也就是10)，并且在block内部重新定义了一个变量来存储这个值，这个时候block外部和里面的a其实是2个不同的变量，所以外面更改a的值不会影响block里面的a。所以打印的结果是a &#x3D; 10。<br>那有人可能就有疑问了，为什么普通局部变量要捕获值，跟静态局部变量一样捕获地址不行吗？是的，不行。因为普通局部变量a在出了大括号后就会被释放掉了，这个时候如果我们在大括号外面调用这个block，block内部通过a的指针去访问a的值就会抛出异常，因为a已经被释放了。而静态局部变量的生命周期是和整个程序的生命周期是一样的，也就是说在整个程序运行过程中都不会释放b，所以不会出现这种情况。<br>那有人又有疑问了，既然静态局部变量一直都不会被释放，那block为什么还要捕获它，直接拿来用不就可以了吗？这是因为静态局部变量作用域只限制在这个大括号类，出了这个大括号，虽然它还存在，但是外面无法访问它。而前面已经介绍过，block里面的代码在底层是被封装成了一个函数，那这个函数肯定是在b所在的大括号外面，所以这个函数是无法直接访问到b的，所以block必须将其捕获。</p><p>2.4 block捕获变量小结</p><p>全局变量–不会捕获，是直接访问。<br>静态局部变量–是捕获变量地址。<br>普通局部变量–是捕获变量的值。</p><p>所以我们判断一个变量是否会被block捕获关键就在于这个变量是局部变量还是全局变量。那我们来看一下以下几种情况中block是否会捕获self:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)blockTest&#123;</span><br><span class="line">    </span><br><span class="line">    // 第一种</span><br><span class="line">    void (^block1)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;%p&quot;,self);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 第二种</span><br><span class="line">    void (^block2)(void) = ^&#123;</span><br><span class="line">        self.name = @&quot;Jack&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 第三种</span><br><span class="line">    void (^block3)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,_name);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 第四种</span><br><span class="line">    void (^block4)(void) = ^&#123;</span><br><span class="line">        [self name];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要搞清楚这个问题，我们主要是要搞清楚self是局部变量还是全局变量。可能很多人以为它是全局变量，其实他是一个局部变量。再强调一遍，self是局部变量。那有人就疑惑了，它为什么是局部变量？它是在哪里定义的。要搞清楚这个问题，我们需要对OC的方法调用机制有一定了解。<br>OC中一个对象调用方法，其实就是给这个这个对象发送消息。比如我调用[self blockTest]，它转成C语言后就变成了objc_msgSend(self, @selector(blockTest))。OC的blockTest方法是没有参数的，但是转成objc_msgSend后就多出来了2个参数，一个就是self，是指向函数调用者的，另一个参数就是要调用的这个方法。所以对于所有的OC方法来说，它们都有这2个默认的参数，第一个参数就是self，所以self就是这么通过参数的形式传进来的，它的确是一个局部变量。<br>这个问题解决了，那上面几种情况就简单了，这4中情况下block都会捕获self。对第一、二、四这3种情况都好理解，第三种情况可能有人会有疑惑，block里面都没有用到self为什么还会捕获self呢。其实_name这种写法并不是没有self，它只是将self给省略了，它其实等同于self-&gt;_name，所以这种情况要格外注意。</p><ol start="3"><li>block的类型</li></ol><p>block既然是一个OC对象,那它就有类，那它的类时什么呢？我们可以通过调用block的class方法或object_getClass()函数来得到block的类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)test&#123;</span><br><span class="line">    int age = 10;</span><br><span class="line">    </span><br><span class="line">    void (^block1)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;-----&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    NSLog(@&quot;block1的类：%@&quot;,[block1 class]);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;block2的类：%@&quot;,[^&#123;</span><br><span class="line">        NSLog(@&quot;----%d&quot;,age);</span><br><span class="line">    &#125; class]);</span><br><span class="line">    </span><br><span class="line">   NSLog(@&quot;block3的类：%@&quot;,[[^&#123;</span><br><span class="line">       NSLog(@&quot;----%d&quot;,age);</span><br><span class="line">   &#125; copy] class]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ***************打印结果***************</span><br><span class="line">2020-07-08 09:07:46.253895+0800 AppTest[72445:7921459] block1的类：__NSGlobalBlock__</span><br><span class="line">2020-07-08 09:07:46.254027+0800 AppTest[72445:7921459] block2的类：__NSStackBlock__</span><br><span class="line">2020-07-08 09:07:46.254145+0800 AppTest[72445:7921459] block3的类：__NSMallocBlock__</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>block的类有三种，就是上面打印的结果：__NSGlobalBlock__、__NSStackBlock__、__NSMallocBlock__。有人可能会疑惑，打印第2和3这两个block时为不像block1那样先定义一个block1然后再打印block1。这是因为在ARC模式下，如果一个__NSStackBlock__类型的block被一个强指针指着，那系统会自动对这个block进行一次copy操作将这个block变成__NSMallocBlock__类型，这样会影响运行的结果。<br>下面我们一一介绍一下这三种类型的区别：</p><ol start="3"><li>1__NSGlobalBlock__</li></ol><p>如果一个block里面没有访问普通局部变量(也就是说block里面没有访问任何外部变量或者访问的是静态局部变量或者访问的是全局变量)，那这个block就是__NSGlobalBlock__。__NSGlobalBlock__类型的block在内存中是存在数据区的(也叫全局区或静态区，全局变量和静态变量是存在这个区域的)。__NSGlobalBlock__类型的block调用copy方法的话什么都不会做。<br>下面我们再来看下__NSGlobalBlock__的继承链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)test&#123;</span><br><span class="line">    void (^block)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;-----&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    NSLog(@&quot;--- %@&quot;,[block class]);</span><br><span class="line">    NSLog(@&quot;--- %@&quot;,[[block class] superclass]);</span><br><span class="line">    NSLog(@&quot;--- %@&quot;,[[[block class] superclass] superclass]);</span><br><span class="line">    NSLog(@&quot;--- %@&quot;,[[[[block class] superclass] superclass] superclass]);</span><br><span class="line">&#125;</span><br><span class="line">// ***************打印结果***************</span><br><span class="line">2020-07-08 11:03:34.331652+0800 AppTest[72667:7957820] --- __NSGlobalBlock__</span><br><span class="line">2020-07-08 11:03:34.331777+0800 AppTest[72667:7957820] --- __NSGlobalBlock</span><br><span class="line">2020-07-08 11:03:34.331883+0800 AppTest[72667:7957820] --- NSBlock</span><br><span class="line">2020-07-08 11:03:34.331950+0800 AppTest[72667:7957820] --- NSObject</span><br><span class="line">看了block最终也是继承自NSObject，__NSGlobalBlock__的继承链为：__NSGlobalBlock__ : __NSGlobalBlock : NSBlock : NSObject。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.2__NSStackBlock__</p><p>如果一个block里面访问了普通的局部变量，那它就是一个__NSStackBlock__，它在内存中存储在栈区，栈区的特点就是其释放不受开发者控制，都是由系统管理释放操作的，所以在调用__NSStackBlock__类型block时要注意，一定要确保它还没被释放。如果对一个__NSStackBlock__类型block做copy操作，那会将这个block从栈复制到堆上。<strong>NSStackBlock__的继承链是：__NSStackBlock</strong> : __NSStackBlock : NSBlock : NSObject。</p><p>3.3__NSMallocBlock__</p><p>一个__NSStackBlock__类型block做调用copy，那会将这个block从栈复制到堆上，堆上的这个block类型就是__NSMallocBlock__，所以__NSMallocBlock__类型的block是存储在堆区。如果对一个__NSMallocBlock__类型block做copy操作，那这个block的引用计数+1。<strong>NSMallocBlock__的继承链是：__NSMallocBlock</strong> : __NSMallocBlock : NSBlock : NSObject。</p><p>在ARC环境下，编译器会根据情况，自动将栈上的block复制到堆上。有一下4种情况会将栈block复制到堆上：<br>a. block作为函数返回值时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^MyBlock)(void);</span><br><span class="line"></span><br><span class="line">- (MyBlock)createBlock&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    return ^&#123;</span><br><span class="line">        NSLog(@&quot;******%d&quot;,a);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. 将block赋值给强指针时：<br>将定义的栈上的block赋值给强指针myBlock，就变成了堆block。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)test&#123;</span><br><span class="line">    int a = 10; // 局部变量</span><br><span class="line"></span><br><span class="line">    void (^myBlock)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;a = %d&quot;,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>c. 当block作为参数传给Cocoa API时：<br>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[UIView animateWithDuration:1.0f animations:^&#123;</span><br><span class="line">        </span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>d. block作为GCD的API的参数时：<br>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另外在MRC环境下，定义block属性建议使用copy关键字，这样会将栈区的block复制到堆区。<br>@property (copy,nonatomic) void(^block)void;<br>在ARC环境下，定义block属性用copy或strong关键字都会将栈区block复制到堆上，所以这两种写法都可以。<br>@property (strong, nonatomic) void (^block)(void);<br>@property (copy, nonatomic) void (^block)(void);</p><ol start="4"><li>block对对象型的局部变量的捕获<br>block对对象类型和对基本数据类型变量的捕获是不一样的，对象类型的变量涉及到强引用和弱引用的问题，强引用和弱引用在block底层是怎么处理的呢？<br>如果block是在栈上，不管捕获的对象时强指针还是弱指针，block内部都不会对这个对象产生强引用。所以我们主要来看下block在堆上的情况。<br>首先来看下强引用的对象被block捕获后在底层结构体中是如何存储的。这里用下面这条命令来将OC代码转成c&#x2F;c++代码：<br>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime&#x3D;ios-8.0.0 main.m</li></ol><p>&#x2F;&#x2F; OC代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        Person *person = [[Person alloc] init];</span><br><span class="line">        person.age = 20;</span><br><span class="line"></span><br><span class="line">        void (^block)(void) = ^&#123;</span><br><span class="line">            NSLog(@&quot;age--- %ld&quot;,person.age);</span><br><span class="line">         &#125;;</span><br><span class="line">        block();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 底层结构体</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  Person *__strong person;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到和基本数据类型不同的是，person对象被block捕获后，在结构体中多了一个修饰关键字__strong。<br>我们再来看下弱引用对象被捕获后是什么样的：<br>&#x2F;&#x2F; OC代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        Person *person = [[Person alloc] init];</span><br><span class="line">        person.age = 20;</span><br><span class="line"></span><br><span class="line">        __weak Person *weakPerson = person;</span><br><span class="line">        void (^block)(void) = ^&#123;</span><br><span class="line">            NSLog(@&quot;age--- %ld&quot;,weakPerson.age);</span><br><span class="line">         &#125;;</span><br><span class="line">        block();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 底层block</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  Person *__weak weakPerson;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见此时block中weakPerson的关键字变成了__weak。<br>在block中修饰被捕获的对象类型变量的关键字除了__strong、__weak外还有一个__unsafe_unretained。那这结果关键字起什么作用呢？<br>当block被拷贝到堆上时是调用的copy函数，copy函数内部会调用_Block_object_assign函数，_Block_object_assign函数就会根据这3个关键字来进行操作。</p><p>如果关键字是__strong，那block内部就会对这个对象进行一次retain操作，引用计数+1，也就是block会强引用这个对象。也正是这个原因，导致在使用block时很容易造成循环引用。<br>如果关键字是__weak或__unsafe_unretained，那block对这个对象是弱引用，不会造成循环引用。所以我们通常在block外面定义一个__weak或__unsafe_unretained修饰的弱指针指向对象，然后在block内部使用这个弱指针来解决循环引用的问题。</p><p>block从堆上移除时，则会调用block内部的dispose函数，dispose函数内部调用_Block_object_dispose函数会自动释放强引用的变量。</p><ol start="4"><li>__block修饰符的作用<br>在介绍__block之前，我们先来看下下面这段代码：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)test&#123;</span><br><span class="line">    int age = 10;</span><br><span class="line">    void (^block)(void) = ^&#123;</span><br><span class="line">        age = 20;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码有什么问题吗？编译器会直接报错，在block中不可以修改这个age的值。为什么呢？<br>因为age是一个局部变量，它的作用域和生命周期就仅限在是test方法里面，而前面也介绍过了，block底层会将大括号中的代码封装成一个函数，也就相当于现在是要在另外一个函数中访问test方法中的局部变量，这样肯定是不行的，所以会报错。<br>如果我想在block里面更改age的值要怎么做呢？我们可以将age定义成静态局部变量static int age &#x3D; 10;。虽然静态局部变量的作用域也是在test方法里面，但是它的生命周期是和程序一样的，而且block捕获静态局部变量实际是捕获的age的地址，所以block里面也是通过age的地址去更改age的值，所以是没有问题的。<br>但我们并不推荐这样做，因为静态局部变量在程序运行过程中是不会被释放的，所以还是要尽量少用。那还有什么别的方法来实现这个需求呢？这就是我们要讲的__block关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)test1&#123;</span><br><span class="line">    __block int age = 10;</span><br><span class="line">    void (^block)(void) = ^&#123;</span><br><span class="line">        age = 20;</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    NSLog(@&quot;%d&quot;,age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们用__block关键字修饰后，底层到底做了什么让我们能在block里面访问age呢？下面我们来看下上面代码转成c++代码后block的存储结构是什么样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_age_0 *age; // by ref</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_age_0 &#123;</span><br><span class="line">  void *__isa; // isa指针</span><br><span class="line">__Block_byref_age_0 *__forwarding; // 如果这block是在堆上那么这个指针就是指向它自己，如果这个block是在栈上，那这个指针是指向它拷贝到堆上后的那个block</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size; // 结构体大小</span><br><span class="line"> int age; // 真正捕获到的age</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到，age用__block修饰后，在block的结构体中变成了__Block_byref_age_0 *age;，而__Block_byref_age_0是个结构体，里面有个成员int age;，这个才是真正捕获到的外部变量age，实际上外部的age的地址也是指向这里的，所以不管是外面还是block里面修改age时其实都是通过地址找到这里来修改的。<br>所以age用__block修饰后它就不再是一个test1方法内部的局部变量了，而是被包装成了一个对象，age就被存储在这个对象中。之所以说是包装成一个对象，是因为__Block_byref_age_0这个结构体的第一个成员就是isa指针。</p><p>__block修饰变量的内存管理:<br>__block不管是修饰基础数据类型还是修饰对象数据类型，底层都是将它包装成一个对象(我这里取个名字叫__blockObj)，然后block结构体中有个指针指向__blockObj。既然是一个对象，那block内部如何对它进行内存管理呢？<br>当block在栈上时，block内部并不会对__blockObj产生强引用。<br>当block调用copy函数从栈拷贝到堆中时，它同时会将__blockObj也拷贝到堆上，并对__blockObj产生强引用。<br>当block从堆中移除时，会调用block内部的dispose函数，dispose函数内部又会调用<br>_Block_object_dispose函数来释放__blockObj。</p><h1 id="Block循环引用"><a href="#Block循环引用" class="headerlink" title="Block循环引用"></a>Block循环引用</h1><h1 id="Block面试题"><a href="#Block面试题" class="headerlink" title="Block面试题"></a>Block面试题</h1><ul><li><p>block既然是对象，那么用copy修饰还是strong修饰呢？<br>答：用copy和strong都可以，因为在ARC下有自动copy效果。</p></li><li><p>变量截取面试题<br>下面代码能正常编译吗？不能的话是那些代码不能通过编译呢？</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int d = 1000; // 全局变量</span><br><span class="line">static int e = 10000; // 静态全局变量</span><br><span class="line">- (void)test&#123;</span><br><span class="line">    </span><br><span class="line">    int a = 10; // 局部变量</span><br><span class="line">    static int b = 100; // 静态局部变量</span><br><span class="line">    __block int c = 1000;</span><br><span class="line">    NSMutableArray *array1 = nil;</span><br><span class="line">    __block NSMutableArray *array2 = nil;</span><br><span class="line">    void (^block)(void) = ^&#123;</span><br><span class="line">        a = 20;</span><br><span class="line">        b = 200;</span><br><span class="line">        c = 2000;</span><br><span class="line">        d = 20000;</span><br><span class="line">        e = 200000;</span><br><span class="line">        array1 = [NSMutableArray array];</span><br><span class="line">        [array1 addObject:@&quot;111&quot;];</span><br><span class="line">        array2 = [NSMutableArray array];</span><br><span class="line">        [array2 addObject:@&quot;222&quot;];</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：<br>1)a &#x3D; 20;无法通过编译，因为a是局部变量，其作用域和生命周期仅限于它所在的大括号内部，而block底层是将块中的代码封装到了一个函数中，在那个函数中修改a就相当于在一个函数中去修改另外一个函数中的局部变量，这样肯定是无法通过编译。</p><p>2)array1 &#x3D; [NSMutableArray array];无法通过编译。原因和上面一样，array1是一个指针，这里是想在一个函数中去给另外一个函数中的变量重新赋值一个指针，所以无法通过编译。</p><p>3)其它的都可以通过编译。</p><p>4)全局变量在哪里都可以访问到，所以在block里面可以修改，实际上block并不会捕获全局变量存到block内部。</p><p>5)__block修饰的变量(以变量c为例)是被包装成了一个对象，c就存储在对象中，block外面 的c的地址实际上就是这个对象中存储的c的地址，而block里面也存储着一个指针指向这个对象进而能访问到这个对象中的c，所以是可以直接修改的。</p><p>6)[array1 addObject:@”111”];可以通过编译是因为block捕获了array1的值(也就是数组的地址)存储在block里面，这里是通过这个地址找到数组，然后对数组中的元素进行操作，所以是可以通过编译的。所以对于一个对象类型的变量，block内部只要不是想修改这个变量的值，都不需要用__block来修饰这个变量(比如增、删、修改集合类型对象里面的元素，或者修改一个实例对象的属性等都不需要用__block修饰)。</p><ul><li>睡眠有关<br>1.下面代码运行结果是什么？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)test&#123;</span><br><span class="line">  </span><br><span class="line">    __block Person *person = [[Person alloc] init];</span><br><span class="line">    person.age = 20;</span><br><span class="line">    </span><br><span class="line">    __weak Person *weakPerson = person;</span><br><span class="line">    self.block = ^&#123;</span><br><span class="line">        NSLog(@&quot;block-begin:%@ age = %d&quot;,[NSThread currentThread],weakPerson.age);</span><br><span class="line">        [NSThread sleepForTimeInterval:1.0f];</span><br><span class="line">        NSLog(@&quot;block-eng:%@ age = %d&quot;,[NSThread currentThread],weakPerson.age);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        self.block();</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    [NSThread sleepForTimeInterval:0.2f];</span><br><span class="line">    NSLog(@&quot;test-end:%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ***************打印结果***************</span><br><span class="line">2020-08-11 11:59:08.632317+0800 OC-Block变量截获的原理[32169:1868943] block-begin:&lt;NSThread: 0x60000324eec0&gt;&#123;number = 4, name = (null)&#125; age = 20</span><br><span class="line">2020-08-11 11:59:08.833335+0800 OC-Block变量截获的原理[32169:1868876] test-end:&lt;NSThread: 0x600003200200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-08-11 11:59:09.635217+0800 OC-Block变量截获的原理[32169:1868943] block-eng:&lt;NSThread: 0x60000324eec0&gt;&#123;number = 4, name = (null)&#125; age = 0</span><br></pre></td></tr></table></figure><p>weakPerson是一个弱指针，所以self.block对person是弱引用。然后在并发队列中通过异步函数添加一个任务来执行self.block();，所以是开启了一个子线程来执行这个任务，此时打印age值是20，然后子线程开始睡眠1秒钟。与此同时主线程也睡眠0.2秒，0.2秒后主线程执行完最后的打印操作，test函数就执行完了。而由于person是一个局部变量，而且self.block对它也是弱引用，所以在test函数执行完后person对象就被释放了。再过0.8秒钟，子线程结束睡眠，此时weakPerson所指向的对象已经变成了nil，所以打印的age是0。</p><p>此时如果将主线程的睡眠时间改的比子线程睡眠时间长的话结果又不一样，因为子线程睡眠结束时主线程还在睡眠睡眠，也就是test方法还没执行完，那person对象就还存在，所以子线程睡眠前后打印的age都是20。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 主线程睡眠时间改为：[NSThread sleepForTimeInterval:1.2f];</span><br><span class="line"></span><br><span class="line">// ***************打印结果***************</span><br><span class="line">2020-08-11 12:00:01.276795+0800 OC-Block变量截获的原理[32192:1869873] block-begin:&lt;NSThread: 0x600003987680&gt;&#123;number = 6, name = (null)&#125; age = 20</span><br><span class="line">2020-08-11 12:00:02.277239+0800 OC-Block变量截获的原理[32192:1869873] block-eng:&lt;NSThread: 0x600003987680&gt;&#123;number = 6, name = (null)&#125; age = 20</span><br><span class="line">2020-08-11 12:00:02.476903+0800 OC-Block变量截获的原理[32192:1869745] test-end:&lt;NSThread: 0x6000039bc240&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure><ul><li>线程有关<br>1.下面代码运行结果是什么？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)test&#123;</span><br><span class="line">    __block Person *person = [[Person alloc] init];</span><br><span class="line">    person.age = 20;</span><br><span class="line">    </span><br><span class="line">    __weak Person *weakPerson = person;</span><br><span class="line">    self.block = ^&#123;</span><br><span class="line">        __strong Person *strongPerson = weakPerson;</span><br><span class="line">        NSLog(@&quot;block-begin:%@ age = %d&quot;,[NSThread currentThread],strongPerson.age);</span><br><span class="line">        [NSThread sleepForTimeInterval:1.0f];</span><br><span class="line">        NSLog(@&quot;block-eng:%@ age = %d&quot;,[NSThread currentThread],strongPerson.age);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        [self test1];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;test - end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test1&#123;</span><br><span class="line">    self.block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ***************打印结果***************</span><br><span class="line">2020-08-11 11:41:03.530846+0800 OC-Block变量截获的原理[32030:1857989] test - end</span><br><span class="line">2020-08-11 11:41:03.641728+0800 OC-Block变量截获的原理[32030:1857989] block-begin:&lt;NSThread: 0x6000025303c0&gt;&#123;number = 1, name = main&#125; age = 0</span><br><span class="line">2020-08-11 11:41:04.688181+0800 OC-Block变量截获的原理[32030:1857989] block-eng:&lt;NSThread: 0x6000025303c0&gt;&#123;number = 1, name = main&#125; age = 0</span><br></pre></td></tr></table></figure><p>解释：<br>在并发队列中通过异步函数添加任务执行test1，是开启一个新线程来执行，而新线程是先睡眠0.1秒再执行test1，所以会先执行异步函数后面的代码，所以等到开始执行test1时，test已经执行结束了，所以在执行block之前person就已经被释放了，这种情况下__strong修饰符是不起作用的。</p><p>2.如果我将并发队列换成串行队列会怎么样？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_queue_create(&quot;testQueue&quot;, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:0.1f];</span><br><span class="line">        [self test1];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">// ***************打印结果***************</span><br><span class="line">2020-08-11 11:51:06.899764+0800 OC-Block变量截获的原理[32094:1863643] test - end</span><br><span class="line">2020-08-11 11:51:07.000155+0800 OC-Block变量截获的原理[32094:1863824] block-begin:&lt;NSThread: 0x600000891040&gt;&#123;number = 4, name = (null)&#125; age = 0</span><br><span class="line">2020-08-11 11:51:08.001081+0800 OC-Block变量截获的原理[32094:1863824] block-eng:&lt;NSThread: 0x600000891040&gt;&#123;number = 4, name = (null)&#125; age = 0</span><br></pre></td></tr></table></figure><p>其实这里不管是改成主队列还是自定义的串行队列结果都一样，只要保证是异步函数就行，异步函数不会阻塞当前线程，所以执行test1时test已经执行完了。</p><p>3.这种情况下如果我将异步函数换成同步函数，其他地方不变：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:0.1f];</span><br><span class="line">        [self test1];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">// ***************打印结果***************</span><br><span class="line">2020-08-11 11:52:16.707598+0800 OC-Block变量截获的原理[32121:1864960] block-begin:&lt;NSThread: 0x600002a346c0&gt;&#123;number = 1, name = main&#125; age = 20</span><br><span class="line">2020-08-11 11:52:17.709068+0800 OC-Block变量截获的原理[32121:1864960] block-eng:&lt;NSThread: 0x600002a346c0&gt;&#123;number = 1, name = main&#125; age = 20</span><br><span class="line">2020-08-11 11:52:17.709353+0800 OC-Block变量截获的原理[32121:1864960] test - end</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>因为同步函数会阻塞当前线程，所以是等test1执行结束后，test才会继续执行后面的代码，所以person是在block执行结束后才被释放的。</p><ul><li>计时器有关<br>下面代码会造成什么上面后果：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)test&#123;</span><br><span class="line">    __block Person *person = [[Person alloc] init];</span><br><span class="line">    person.age = 20;</span><br><span class="line">    </span><br><span class="line">    __weak Person *weakPerson = person;</span><br><span class="line">    self.block = ^&#123;</span><br><span class="line">        __strong Person *strongPerson = weakPerson;</span><br><span class="line">        NSLog(@&quot;block-begin:%@ age = %d&quot;,[NSThread currentThread],strongPerson.age);</span><br><span class="line">        [NSThread sleepForTimeInterval:1.0f];</span><br><span class="line">        NSLog(@&quot;block-eng:%@ age = %d&quot;,[NSThread currentThread],strongPerson.age);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    [self performSelector:@selector(test1) withObject:nil afterDelay:.0f];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;test - end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)test1&#123;</span><br><span class="line">    self.block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ***************打印结果***************</span><br><span class="line">2020-08-11 11:41:03.530846+0800 OC-Block变量截获的原理[32030:1857989] test - end</span><br><span class="line">2020-08-11 11:41:03.641728+0800 OC-Block变量截获的原理[32030:1857989] block-begin:&lt;NSThread: 0x6000025303c0&gt;&#123;number = 1, name = main&#125; age = 0</span><br><span class="line">2020-08-11 11:41:04.688181+0800 OC-Block变量截获的原理[32030:1857989] block-eng:&lt;NSThread: 0x6000025303c0&gt;&#123;number = 1, name = main&#125; age = 0</span><br></pre></td></tr></table></figure><p>解释：</p><p>performSelector:withObject:afterDelay这个方法底层实现实际上是将一个定时器添加到了runloop中，然后等时间到了后就执行test1方法。虽然这里最后一个参数传的是0，也就是等待0秒后执行test1，但它并不是立马执行，因为需要先唤醒runloop，这是要耗一定时间的，所以会先执行后面的方法。所以等到开始执行test1是test已经执行结束了，person已经释放</p><ul><li>内存泄漏<br>下面代码会造成什么上面后果：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)test&#123;</span><br><span class="line">    self.age = 20;</span><br><span class="line">    self.block = ^&#123;</span><br><span class="line">      NSLog(@&quot;%d&quot;,self.age);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    self.block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：</p><p>会因循环引用而导致内存泄露。因为self通过一个强指针指向了block，而block内部又捕获了self而且用强指针指向self，所以self和block互相强引用对方而造成循环引用。</p><p>解决这个问题很简单，只需要定义一个弱指针指向self，然后block内部就是用一个若指针指向self，所以结果是self强引用block，block弱引用self，所以不会造成循环引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)test&#123;</span><br><span class="line">    self.age = 20;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    self.block = ^&#123;</span><br><span class="line">      NSLog(@&quot;%d&quot;,weakSelf.age);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    self.block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里说明一点，我们判断会不会造成循环引用关键看block有没有捕获并强引用self。我们只需要记住以下下几点：<br>1.如果block内部使用到了某个变量，而且这个变量是局部变量，那么block会捕获这个变量并存储到block底层的结构体中。<br>2.如果捕获的这个变量是用__weak或__unsafe_unretained修饰的，那么block内部就是用弱指针指向这个变量(也就是block不持有这个对象)，否则block内部就是用强指针指向这个对象(也就是block持有这个对象)。<br>3.self是一个局部变量。因为self是所有OC方法的一个隐藏参数，所以它是一个局部变量。<br>如果self并不持有这个block，block内部怎么引用self都不会造成循环引用。</p><ul><li>循环引用面试题，<br>1.下面代码是否会造成循环引用：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)test&#123;</span><br><span class="line">    self.age = 20;</span><br><span class="line">    self.block = ^&#123;</span><br><span class="line">      NSLog(@&quot;%d&quot;,self.age);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：<br>会造成循环引用，这里虽然没有调用block，但并不影响它们相互引用的结果。</p><p>2.下面代码是否会造成循环引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)test1&#123;</span><br><span class="line">    self.age = 20;</span><br><span class="line">    </span><br><span class="line">    self.block = ^&#123;</span><br><span class="line">      NSLog(@&quot;%d&quot;,_age);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    self.block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：</p><p>会造成循环引用。block里面虽然看不到self，实际上_age这种写法只是省略了self，完整写法是self-&gt;_age，所以是会造成循环引用的。这一点开发中要格外注意。</p><p>3.下面代码是否会造成循环引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)test&#123;</span><br><span class="line">    self.block = ^&#123;</span><br><span class="line">        [self setAge:10];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    self.block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：</p><p>会造成循环引用。OC中调用方法就是给某个对象发送消息，所以调用方法时是需要用到self的，所以block会捕获self并强引用它。</p><p>4.下面代码是否会造成循环引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">       NSLog(@&quot;%d&quot;,self.age);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">[UIView animateWithDuration:1.0f animations:^&#123;</span><br><span class="line">       NSLog(@&quot;%d&quot;,self.age);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>解答：</p><p>不会造成循环引用。当block是某个函数的参数时，虽然block内部是对self强引用的，但self并不持有block，所以不会造成循环引用。</p><p>5.下面代码是否会造成循环引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)test1&#123;</span><br><span class="line"></span><br><span class="line">    dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        self.block = ^&#123;</span><br><span class="line">            NSLog(@&quot;%d&quot;,self.age);</span><br><span class="line">        &#125;;</span><br><span class="line">        self.block();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：</p><p>会造成循环引用。这是一个嵌套的block，虽然外层block不会循环引用，但是里面的block会造成循环引用。</p><p>6.下面代码是否会造成循环引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^MyBlock)(void);</span><br><span class="line"></span><br><span class="line">- (void)test&#123;</span><br><span class="line"></span><br><span class="line">    dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        self.age = [self testWithBlock:^&#123;</span><br><span class="line">           NSLog(@&quot;%d&quot;,self.age);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (int)testWithBlock:(MyBlock)myBlock&#123;</span><br><span class="line">    myBlock();</span><br><span class="line">    return 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：</p><p>不会造成循环引用。这也是嵌套的block。外层block并没有被self持有，所以不会造成循环引用。我们主要看下里面那个block，其实里面的block就是一个函数的参数，self并不持有它，所以不会造成循环引用。</p><p>7.下面代码是否会造成循环引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)test1&#123;</span><br><span class="line"></span><br><span class="line">    self.block = [self blockWithBlock:^&#123;</span><br><span class="line">       NSLog(@&quot;%d&quot;,self.age);</span><br><span class="line">    &#125;];</span><br><span class="line">    self.block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (MyBlock)blockWithBlock:(MyBlock)myBlock&#123;</span><br><span class="line">    myBlock();</span><br><span class="line">    </span><br><span class="line">    return ^&#123;</span><br><span class="line">      NSLog(@&quot;block作为返回值&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：</p><p>不会造成循环引用。这道题很具有迷惑性。有人会觉得self是持有block的，而block内部又强引用了self，所以会造成循环引用。其实仔细观察会发现这里有2个不同的block，self持有的是一个block，而强引用self的又是另外一个block，所以它们并不会造成循环引用。</p><p>8.下面代码是否会造成循环引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)test1&#123;</span><br><span class="line">    self.block = [self blockWithBlock:^&#123;</span><br><span class="line">       NSLog(@&quot;作为参数的block&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    self.block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (MyBlock)blockWithBlock:(MyBlock)myBlock&#123;</span><br><span class="line">    myBlock();</span><br><span class="line">    </span><br><span class="line">    return ^&#123;</span><br><span class="line">      NSLog(@&quot;block作为返回值--%d&quot;,_age);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：</p><p>会造成循环引用。这道题同样具有迷惑性。表面上看起来self持有的是一个block，作为参数的又是另外一个block，而且这个block里面也没有用到self。其实这里的关键在于第二个函数的返回值，它返回的就是一个block，这个block里面强引用了self，而且将这个block赋值给了self的block，所以self是强指针指向这个返回的block的。所以它们构成了循环引用。</p>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OCRuntime03：方法的本质</title>
      <link href="/BboyZJ.github.io/2020/07/15/OCRuntime&amp;Runloop/OCRuntime03%EF%BC%9A%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
      <url>/BboyZJ.github.io/2020/07/15/OCRuntime&amp;Runloop/OCRuntime03%EF%BC%9A%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="OC方法的本质"><a href="#OC方法的本质" class="headerlink" title="OC方法的本质"></a>OC方法的本质</h1><p>1.方法的类别</p><ul><li>对象方法</li><li>类方法</li></ul><p>2.为了方便我们去探索OC方法调用的本质，首先：我们创建一个命令行项目，并新建一个Person类和Student类，里面声明两个方法，一个带参数的和一个不带参数的方法，并实现两个方法，在main.m中去调用以下这两个方法，如下:<br><img src="https://user-images.githubusercontent.com/25925248/88411611-d367a000-ce0a-11ea-93e4-24fbb5263386.png"></p><p>Student.h中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface Student : Person</span><br><span class="line">- (void)run; //实例方法</span><br><span class="line">+ (void)walk:(NSString *)distance; //类方法</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>Student.m中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)run&#123;</span><br><span class="line">    NSLog(@&quot;run&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)walk:(NSString *)distance&#123;</span><br><span class="line">    NSLog(@&quot;walk:%@&quot;,distance);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.m中代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student * s = [Student new];</span><br><span class="line">//实例对象方法</span><br><span class="line">[s run];</span><br><span class="line">//类方法</span><br><span class="line">[Student walk:@&quot;走路&quot;];</span><br></pre></td></tr></table></figure><p>2.通过clang编译mian.m文件为main.cpp文件去查看到底是通过什么方式调用方法的：xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o mian.cpp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student * s = ((Student *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;Student&quot;), sel_registerName(&quot;new&quot;));</span><br><span class="line"></span><br><span class="line">((void (*)(id, SEL))(void *)objc_msgSend)((id)s, sel_registerName(&quot;run&quot;));</span><br><span class="line"></span><br><span class="line">((void (*)(id, SEL, NSString * _Nonnull))(void *)objc_msgSend)((id)objc_getClass(&quot;Student&quot;), sel_registerName(&quot;walk:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_wr_2dt58x1n67bbb3g292d9ygy80000gn_T_main_a4c800_mi_0);</span><br></pre></td></tr></table></figure><p>3.由上面的代码可知：方法的本质是&#x3D;&#x3D;发送消息&#x3D;&#x3D;,任何的方法的调用都会编译成消息。即消息的组成:</p><ul><li>objc_msgSend(id self, SEL _cmd, …)<br>1）id self：消息接受者(调用方法的对象),分为实例对象和类对象<br>2）SEL _cmd：方法编号<br>3）…：参数</li><li>id self:可以理解为调用方法的对象，消息接受者，即上文中的 ：<br>  实例对象：p。<br>  类对象：objc_getClass(“Person”)。</li><li>SEL _cmd 为方法名，传入类似sel_registerName(“MethodName”)，即下文中的”[p run];”方法。若方法中需要传入参数，就在后面拼接，即下文中的 “[p walk:]”方法。</li></ul><p>4.获取SEL的三种方法：</p><ol><li>Runtime提供的sel_registerName(“MethodName”)</li><li>Objective-C编译器提供的 @selector(方法名)</li><li>NSObject提供的NSSelectorFromString(“MethodName”)</li></ol><p>5.获取类对象的方法<br>objc_getClass(“Person”)</p><p>6.SEL与IMP(implementation)的关系：<br>sel_registerName(“MethodName”)为方法编号，通过方法编号找到方法对应的&#x3D;&#x3D;IMP是函数实现的指针&#x3D;&#x3D;，<br>最后直接调用函数。<br>比喻：通过书页(SEL) 找到该页的具体内容  (IMP)</p><h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p>为了能够使用objc_msgSend，需要修改配置objc_msgSend Calls改为No如下：<br><img src="https://user-images.githubusercontent.com/25925248/88385353-bae29000-cde0-11ea-9d52-180cb32b0837.png"></p><p>1.实例对象调用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//实例对象方法底层编译</span><br><span class="line">[s run];</span><br><span class="line">objc_msgSend(s, @selector(run));</span><br><span class="line">objc_msgSend(s, sel_registerName(&quot;run&quot;));</span><br><span class="line">NSLog(@&quot;%p---%p&quot;,@selector(run),sel_registerName(&quot;run&quot;));</span><br><span class="line">//0x7fff79c49a9b---0x7fff79c49a9b说明这两个方法作用相同</span><br></pre></td></tr></table></figure><p>@selector(run)和sel_registerName(“run”)都是SEL</p><p>2.类对象调用方法：实际上是向类对象发送消息:objc_getClass(“Person”)获取类对象的意思</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//2.类方法底层编译</span><br><span class="line">[Student walk:@&quot;走路&quot;];</span><br><span class="line">objc_msgSend(objc_getClass(&quot;Student&quot;), @selector(walk:), @&quot;Hello World&quot;);</span><br><span class="line">objc_msgSend(objc_getClass(&quot;Student&quot;), sel_registerName(&quot;walk:&quot;), @&quot;Hello World&quot;);</span><br><span class="line">NSLog(@&quot;%@&quot;,objc_getClass(&quot;Student&quot;));//返回的是类对象Student</span><br></pre></td></tr></table></figure><p>3.向父类方法发送消息<br>必须引入头文件<code>#import &lt;objc/message.h&gt;</code><br>1）对象方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//对象方法</span><br><span class="line">struct objc_super mySuper;</span><br><span class="line">mySuper.receiver = s; //确定消息发送的对象s</span><br><span class="line">mySuper.super_class = class_getSuperclass([s class]);//获取父类的类对象</span><br><span class="line">objc_msgSendSuper(&amp;mySuper, @selector(run));</span><br></pre></td></tr></table></figure><p>2）类方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//类方法</span><br><span class="line">struct objc_super myClassSuper;</span><br><span class="line">myClassSuper.receiver = [s class];//消息发送者为类对象</span><br><span class="line">myClassSuper.super_class = class_getSuperclass(object_getClass([s class]));//获取元类对象</span><br><span class="line">objc_msgSendSuper(&amp;myClassSuper, @selector(walk));</span><br></pre></td></tr></table></figure><p>4.这里要介绍一下objc_getClass(const chat *aClassName)、object_getClass(id obj)和(class)class的区别：<br>1)objc_getClass：传入类名，返回类对象<br>2)object_getClass:传入对象</p><ul><li>传入instance对象，返回class对象</li><li>传入class对象，返回meta-class对象</li><li>传入是meta-class对象，返回NSObject（基类）的meta-class对象<br>3)class</li><li>返回的就是类对象</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>1.对象方法和类方法分别存在哪?<br>答：对象方法存在类中。<br>    类方法存在元类中</p><p>2.“类方法”在元类中是以什么样的姿态存在？<br>答：以实例方法存在，因为对象在类中是实例，而类在元类中也是实例。</p>]]></content>
      
      
      <categories>
          
          <category> OC-Runloop探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OCRuntime03：对象的本质</title>
      <link href="/BboyZJ.github.io/2020/07/13/OCRuntime&amp;Runloop/OCRuntime02%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
      <url>/BboyZJ.github.io/2020/07/13/OCRuntime&amp;Runloop/OCRuntime02%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="OC对象的本质"><a href="#OC对象的本质" class="headerlink" title="OC对象的本质"></a>OC对象的本质</h1><p>1.我们平时编写的Object-C代码，底层实现其实都是C&#x2F;C++代码。所以Objective-C的面向对象都是基于C&#x2F;C++的数据结构实现的<br><img src="https://user-images.githubusercontent.com/25925248/88036081-a2227200-cb75-11ea-835f-192845ba38b1.png"></p><p>2.由于OC对象内部可以容纳不同数据类型的数据，因此可以推断OC对象的底层数据结构就是&#x3D;&#x3D;结构体&#x3D;&#x3D;。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object Person; //说明Person的本质就是结构体</span><br></pre></td></tr></table></figure><h1 id="将OC代码转化成C-x2F-C-代码"><a href="#将OC代码转化成C-x2F-C-代码" class="headerlink" title="将OC代码转化成C&#x2F;C++代码"></a>将OC代码转化成C&#x2F;C++代码</h1><p>那么我们就把OC代码尝试着转化成C&#x2F;C++代码，来看一下到底是不是结构体。<br>1.新建一个MacOS命令行项目<br>1)打开Xcode并新建一个Commend Line Tool命令行项目，如下：<br><img src="https://user-images.githubusercontent.com/25925248/88041296-c7ff4500-cb7c-11ea-96cc-99b6af3c1962.png"><br><img src="https://user-images.githubusercontent.com/25925248/88041399-e9f8c780-cb7c-11ea-9844-582e4c7d6b8a.png"><br><img src="https://user-images.githubusercontent.com/25925248/88045562-4c53c700-cb81-11ea-9f38-06f6dfbe77f0.png"></p><p>2.为了进一步研究OC对象的本质，我们使用苹果Xcode内置的LLVM编译器前端clang中-rewrite-objc 将我们的OC代码转为C&#x2F;C++实现。</p><p>1）打开终端，cd到main.m文件夹下，将<code>OC</code>代码转化成<code>C/C++</code>:</p><p><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc  OC源文件 -o 输出的cpp文件</code><br>2）由于不同平台支持的代码肯定是不一样的，目前我们关注点是iOS开发，建议在将OC代码转成C&#x2F;C++代码指定平台：<br><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code></p><p>3)生成main.cpp文件如下:<br><img src="https://user-images.githubusercontent.com/25925248/88045740-963cad00-cb81-11ea-93a6-07a2a436cd78.png"></p><p>4）通过生成的C&#x2F;C++代码，我们编写的OC对象NSObject的底层实现为:<br><img src="https://user-images.githubusercontent.com/25925248/88046417-9ab59580-cb82-11ea-92a1-4afd7f7782b6.png"></p><p>说明:NSObject在内存中布局就是一个指向struct objc_class类型结构体的指针isa,由于内部只有一个成员，那么isa的地址就是NSObject结构体在内存中的地址。</p><h1 id="问题：一个NSObject对象占用多少内存？"><a href="#问题：一个NSObject对象占用多少内存？" class="headerlink" title="问题：一个NSObject对象占用多少内存？"></a>问题：一个NSObject对象占用多少内存？</h1><p>根据上面NSObject内存本质的分析，我们应该会认为NSObject对象在内存中占用了8个字节（在64位的环境下占8个字节，在32环境上占4个字节，因为我们所使用的是64位架构的），那么实际上并不是，而是16个字节，为什么呢？让我们来进一步分析：<br>1.在runtime中有个class_getInstanceSize方法获取实例的大小，首先导入头文件#import &lt;objc&#x2F;runtime.h&gt;<br>2.还有一个获取内存大小的malloc_size方法，导入头文件#import &lt;malloc&#x2F;malloc.h&gt;<br>3.那么我们来打印一下看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &lt;malloc/malloc.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSObject * obj = [[NSObject alloc] init];</span><br><span class="line">        //获取实例的大小</span><br><span class="line">        NSLog(@&quot;class_getInstanceSize:%ld&quot;,class_getInstanceSize([NSObject class]));</span><br><span class="line">        //获取内存大小</span><br><span class="line">        NSLog(@&quot;:%ld&quot;,malloc_size((__bridge const void *)obj));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-07-21 19:07:40.772581+0800 NSObject对象的本质[21818:1404119] class_getInstanceSize:8</span><br><span class="line">2020-07-21 19:07:40.773072+0800 NSObject对象的本质[21818:1404119] :16</span><br></pre></td></tr></table></figure><p>根据上面的两个方法获取的内存大小不一样,class_getInstanceSize获取的大小为8个字节，malloc_size获取的大小是16个字节。为什么会出现两种不同的情况呢，不要着急，我们来进一步分析,我们可以去runtime的源码里面，看一下class_getInstanceSize具体是怎么实现的。往下看。</p><p>4.<a href="https://opensource.apple.com/tarballs/">OC所有开放的源码地址</a>我们找到runtime源码位置然后下载下来:<br><img src="https://user-images.githubusercontent.com/25925248/88049384-a192d700-cb87-11ea-8783-c4669865780e.png"></p><p>点进去然后下载数字最大的。下载完成，打开项目，然后找到class_getInstanceSize的实现:<br><img src="https://user-images.githubusercontent.com/25925248/88049530-e3bc1880-cb87-11ea-9c49-23839a6de68b.png"></p><p>全局搜索class_getInstanceSize方法，在objc_class.mm这个c++文件夹下：<br><img src="https://user-images.githubusercontent.com/25925248/88050235-069afc80-cb89-11ea-9ca1-9e76da95a1c9.png"></p><p>我们点下去看下实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Class&#x27;s ivar size rounded up to a pointer-size boundary.</span><br><span class="line">    uint32_t alignedInstanceSize() const &#123;</span><br><span class="line">        return word_align(unalignedInstanceSize());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以从注释上看出来返回的是Class’s ivar size,类的成员变量的大小，而alignedInstanceSize()表示内存对齐，因为NSObject对象只有一个isa成员变量，因此返回的是8个字节。</p><p><strong>5.我们还可以从源码的另外一个角度来分析一下为什么malloc_size开辟16个字节的内存空间</strong><br>1）事实上，查看源码看一下alloc的时候分配了多大的内存大小，我们还是搜索刚才的源码allocWithZone:<br><img src="https://user-images.githubusercontent.com/25925248/88051968-1b2cc400-cb8c-11ea-913c-e4db433ac9d0.png"></p><p>2）这个方法中返回的是_objc_rootAllocWithZone(self, (malloc_zone_t *)zone),然后搜索找到这个方法源码：<br><img src="https://user-images.githubusercontent.com/25925248/88051995-267fef80-cb8c-11ea-844b-b49733c6949b.png"></p><p>3）这个方法返回_class_createInstanceFromZone(Class cls,size_t,)<br><img src="https://user-images.githubusercontent.com/25925248/88093425-93af7700-cbc4-11ea-9fe9-5b1c449fb664.png"><br>终于找到了，从上述代码注释中可以看到，CF要求所有对象至少得返回16个字节的内存大小。</p><p>4）而系统开辟的内存空间通过malloc_zone_calloc或calloc方式开辟至少16bytes字节或16字节的倍数的内存空间。</p><p><strong>6.总结</strong><br>从上面的所有分析来看，我们很容易能回答出文中最开始提出的问题一个NSObject占用多少内存？<br>答：<br>1、系统分配了16个字节给NSObject对象（可以通过malloc_size函数得到）<br>2、但NSObject对象内部只使用了8个字节空间（在64bit环境下，可以通过class_getInstanceSize函数获得）</p><h1 id="如果一个Person对象继承NSObject类，那么Person类的对象占多少内存？"><a href="#如果一个Person对象继承NSObject类，那么Person类的对象占多少内存？" class="headerlink" title="如果一个Person对象继承NSObject类，那么Person类的对象占多少内存？"></a>如果一个Person对象继承NSObject类，那么Person类的对象占多少内存？</h1><p>1.分析： 新建Person类，添加成员变量。通过clang反编译main.m，打开main.cpp文件找到Person类的底层实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mac@192 Person对象的本质 % cd /Users/mac/Desktop/iOS学习/iOS中进阶高/OC对象的本 质/Person对象的本质/Person对象的本质</span><br><span class="line">mac@192 Person对象的本质 % xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp  </span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/25925248/88088214-a58d1c00-cbbc-11ea-9782-abda1513517c.png"></p><p>2.由上图可知，Person对象其实是一个指向objc_object结构体的指针，objc_object里面也有一个isa指针,如下图：<br><img src="https://user-images.githubusercontent.com/25925248/88089632-edad3e00-cbbe-11ea-9d14-39eb7ca815b5.png"></p><p>3.而且若一个类继承自另一个类，则它的底层会将父类的成员变量放在结构体的最前面，此后依次放置本类的成员变量，如下图：<br><img src="https://user-images.githubusercontent.com/25925248/88089632-edad3e00-cbbe-11ea-9d14-39eb7ca815b5.png"></p><p>而从之前的分析可知，NSObject_IMPL的本质就是一个装有成员变量isa的结构体。因此，Person类对象所占的内存为isa的内存8加上Person类成员变量所占的空间。若不满16个字节，会强制分配到16个字节。</p><p>4.我们来验证一下：<br>如果Person对象中有两个属性和两个实例变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    int add;</span><br><span class="line">    NSString * sex;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic,copy)NSString * name;</span><br><span class="line">@property (nonatomic,assign)int age;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>此时我们打印一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Person * p = [[Person alloc] init];</span><br><span class="line">        //实例对象的内存大小</span><br><span class="line">        NSLog(@&quot;class_getInstanceSize:%ld&quot;,class_getInstanceSize([Person class]));</span><br><span class="line">        //系统给对象开辟的内存大小,OC对象转C对象，需要__bridge桥接</span><br><span class="line">        NSLog(@&quot;malloc_size:%ld&quot;,malloc_size((__bridge const void *)p));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-07-22 02:20:36.303506+0800 Person对象的本质[23797:1588297] class_getInstanceSize:40</span><br><span class="line">2020-07-22 02:20:36.305285+0800 Person对象的本质[23797:1588297] malloc_size:48</span><br></pre></td></tr></table></figure><p><strong>5.结果：</strong><br>说明：属性name和age各占了8个字节的内存空间，实例变量add和sex也各占了8个字节；但是系统每次开辟的内存空间为16的倍数既3*16。</p><h1 id="那么alloc和init都做了些什么呢？"><a href="#那么alloc和init都做了些什么呢？" class="headerlink" title="那么alloc和init都做了些什么呢？"></a>那么alloc和init都做了些什么呢？</h1><p>1.alloc<br>我们通过LLDB调试可以看到，对象alloc时，在汇编中调用了_objc_rootAlloc，明显这就是在苹果源码中的调用入口。<br><img src="https://user-images.githubusercontent.com/25925248/88313984-dbf6a280-cd46-11ea-9c30-2c5a9190728f.png"></p><p><img src="https://user-images.githubusercontent.com/25925248/88314052-f597ea00-cd46-11ea-96d1-060bd8b1917c.png"></p><p>我们去源码中查看一下，调用流程：发现_objc_rootAlloc调用的是callAlloc;继续跳转调用的是_objc_rootAllocWithZone；继续跳转调用的是class_createInstance；继续跳转调用的是_class_createInstanceFromZone</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">+ (id)alloc &#123;</span><br><span class="line">    return _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br><span class="line">// ************* 跳转 **************</span><br><span class="line">_objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);</span><br><span class="line">&#125;</span><br><span class="line">// ************* 跳转 **************</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone=false)</span><br><span class="line">&#123;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        return _objc_rootAllocWithZone(cls, nil); //调用的是这个</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // No shortcuts available.</span><br><span class="line">    if (allocWithZone) &#123;</span><br><span class="line">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));</span><br><span class="line">&#125;</span><br><span class="line">// ************* 跳转 **************</span><br><span class="line">_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)</span><br><span class="line">&#123;</span><br><span class="line">    id obj;</span><br><span class="line"></span><br><span class="line">    if (fastpath(!zone)) &#123;</span><br><span class="line">        obj = class_createInstance(cls, 0); //调用的是这个</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        obj = class_createInstanceFromZone(cls, 0, zone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (slowpath(!obj)) obj = _objc_callBadAllocHandler(cls);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">// ************* 跳转 **************</span><br><span class="line">static id _class_createInstance(Class cls, size_t extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    return _class_createInstanceFromZone (cls, extraBytes, nil);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终会来到这里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone)</span><br><span class="line">&#123;</span><br><span class="line">    void *bytes;</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">    // Can&#x27;t create something for nothing</span><br><span class="line">    if (!cls) return nil;</span><br><span class="line"></span><br><span class="line">    // Allocate and initialize</span><br><span class="line">    // 内存对齐，对象实际是8个字节</span><br><span class="line">    size = cls-&gt;alignedInstanceSize() + extraBytes;</span><br><span class="line"></span><br><span class="line">    // CF requires all objects be at least 16 bytes.</span><br><span class="line">    // 系统分配16个字节</span><br><span class="line">    if (size &lt; 16) size = 16;</span><br><span class="line"></span><br><span class="line">    if (zone) &#123;</span><br><span class="line">        bytes = malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 开辟内存空间</span><br><span class="line">        bytes = calloc(1, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return objc_constructInstance(cls, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.init呢？<br>实际上 init 只是一个抽象方法，并没有做什么操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_objc_rootInit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    // In practice, it will be hard to rely on this function.</span><br><span class="line">    // Many classes do not properly chain -init calls.</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.new呢？<br>调用的是callAlloc,和上面的alloc其实一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)new &#123;</span><br><span class="line">    return [callAlloc(self, false/*checkNil*/) init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OC-Runloop探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC底层原理：我的中级到高级进阶之路</title>
      <link href="/BboyZJ.github.io/2020/07/12/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9A%E6%88%91%E7%9A%84%E4%B8%AD%E7%BA%A7%E5%88%B0%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"/>
      <url>/BboyZJ.github.io/2020/07/12/OC%E8%BF%9B%E9%98%B6/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9A%E6%88%91%E7%9A%84%E4%B8%AD%E7%BA%A7%E5%88%B0%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="源码和开发文档"><a href="#源码和开发文档" class="headerlink" title="源码和开发文档"></a>源码和开发文档</h1><ol><li><a href="https://opensource.apple.com/tarballs/">OC源码下载地址</a></li><li><a href="https://developer.apple.com/documentation/">苹果开发文档地址</a></li></ol><h1 id="OC-底层探索篇"><a href="#OC-底层探索篇" class="headerlink" title="OC 底层探索篇"></a>OC 底层探索篇</h1><ol><li>底层分析：LLDB &amp; 查找源码三种方式</li></ol><ul><li><p><a href="https://www.bboyzj.cn/2020/09/18/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8600%EF%BC%9ALLDB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">OC底层原理00：LLDB常用命令</a></p></li><li><p><a href="https://www.bboyzj.cn/2020/09/12/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8601%EF%BC%9A%E6%9F%A5%E6%89%BE%E6%BA%90%E7%A0%81%E6%9C%89%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/">OC底层原理01：查找源码有三种方式</a></p></li></ul><ol start="2"><li>底层分析：源码 &amp; alloc</li></ol><ul><li><p><a href="https://www.bboyzj.cn/2020/09/05/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8602%EF%BC%9AObjc4%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/">OC底层原理02：Objc4源码编译</a></p></li><li><p><a href="https://www.bboyzj.cn/2020/09/12/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8603%EF%BC%9Aalloc&init&new%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">OC底层原理03：alloc&amp;init&amp;new源码分析</a></p></li><li><p><a href="">OC底层原理04：Optimization-Level-优化等级</a></p></li><li><p><a href="https://www.bboyzj.cn/2020/09/12/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8605%EF%BC%9Aobjc-alloc%E6%8E%A2%E7%B4%A2/">OC底层原理05：objc-alloc探索</a></p></li><li><p><a href="https://www.bboyzj.cn/2020/09/12/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8606%EF%BC%9A%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E6%8E%A2%E7%B4%A2/">OC底层原理06：内存对齐探索</a></p></li><li><p><a href="https://www.bboyzj.cn/2020/09/12/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8607%EF%BC%9Amalloc%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2/">OC底层原理07：malloc源码探索</a></p></li></ul><ol start="3"><li>底层分析：isa &amp; 类 &amp; 结构体</li></ol><ul><li><p><a href="https://www.bboyzj.cn/2020/09/20/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8608%EF%BC%9Aisa%E5%92%8C%E7%B1%BB%E5%85%B3%E8%81%94%E6%8E%A2%E7%B4%A2/">OC底层原理08：isa和类关联探索</a></p></li><li><p><a href="https://www.bboyzj.cn/2020/09/24/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8609%EF%BC%9Aisa%E8%B5%B0%E5%90%91&%E7%BB%A7%E6%89%BF%E5%88%86%E6%9E%90/">OC底层原理09：isa走向&amp;继承分析</a></p></li><li><p><a href="https://www.bboyzj.cn/2020/09/24/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8610%EF%BC%9A%E7%B1%BB%20&%20%E7%B1%BB%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">OC底层原理10：类 &amp; 类结构分析</a></p></li><li><p><a href="https://www.bboyzj.cn/2020/09/16/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8611%EF%BC%9A%E7%B1%BB%20&%20isa%20%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/">OC底层原理11：类 &amp; isa 底层面试题分析</a></p></li><li><p><a href="https://www.bboyzj.cn/2020/09/28/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8612%EF%BC%9Acopy-strong-weak%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/">OC底层原理12：copy-strong-weak底层分析</a></p></li></ul><ol start="4"><li>底层分析：cache-t &amp; 消息流程</li></ol><ul><li><p><a href="https://www.bboyzj.cn/2020/09/30/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8613%EF%BC%9Acache-t%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">OC底层原理13：cache-t底层原理分析</a></p></li><li><p><a href="https://www.bboyzj.cn/2020/10/04/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8614-1%EF%BC%9A%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE/">OC底层原理14-1：消息流程分析之快速查找</a></p></li><li><p><a href="https://www.bboyzj.cn/2020/10/05/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8614-2%EF%BC%9A%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE/">OC底层原理14-2：消息流程分析之快速查找</a></p></li><li><p><a href="https://www.bboyzj.cn/2020/10/06/OC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%8614-3%EF%BC%9A%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%E4%B9%8B%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E5%86%B3%E8%AE%AE&%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/">OC底层原理14-3：消息流程分析之动态方法决议&amp;消息转发</a></p></li></ul><ol start="5"><li>底层分析：dyld &amp; 类</li></ol><ul><li><p><a href="">OC底层原理15：dyld源码分析</a></p></li><li><p><a href="">OC底层原理16：dyld与objc的关联</a></p></li><li><p><a href="">OC底层原理17：类的加载（上）</a></p></li><li><p><a href="">OC底层原理18：类的加载（下）</a></p></li><li><p><a href="">OC底层原理19：类扩展与关联对象</a></p></li><li><p><a href="">OC底层原理20：OC底层面试题解析</a></p></li><li><p><a href="">OC底层原理21：Method-Swizzling方法交换</a></p></li></ul><ol start="6"><li>底层分析：KVC &amp; KVO * 内存五大区</li></ol><ul><li><p><a href="">OC底层原理22：KVC底层原理分析</a></p></li><li><p><a href="">OC底层原理23：KVO底层原理分析</a></p></li><li><p><a href="">OC底层原理24：内存五大区</a></p></li></ul><ol start="7"><li>底层分析：多线程 &amp; 锁 * Block</li></ol><ul><li><p><a href="">OC底层原理25：多线程原理探索</a></p></li><li><p><a href="">OC底层原理26：GCD之函数与队列</a></p></li><li><p><a href="">OC底层原理27：GCD之 NSThread &amp; GCD &amp; NSOperation</a></p></li><li><p><a href="">OC底层原理28：GCD之底层原理分析</a></p></li><li><p><a href="">OC底层原理29：锁的原理</a></p></li><li><p><a href="">OC底层原理30：Block底层原理</a></p></li></ul><ol start="8"><li>底层分析：启动优化</li></ol><ul><li><p><a href="">OC底层原理31：LLVM编译流程-Cland插件开发</a></p></li><li><p><a href="">OC底层原理32：启动优化（一）基本概念</a></p></li><li><p><a href="">OC底层原理33：启动优化（二）优化建议</a></p></li><li><p><a href="">OC底层原理34：启动优化（三）二进制重排</a></p></li></ul><ol start="9"><li>底层分析：内存管理</li></ol><ul><li><p><a href="">OC底层原理35：内存管理（一）TaggedPointer-retain-release-dealloc-retainCount-底层分析</a></p></li><li><p><a href="">OC底层原理36：内存管理（二）強引用分析</a></p></li><li><p><a href="">OC底层原理37：内存管理（三）AutoReleasePool-NSRunLoop-底层分析</a></p></li></ul><ol start="10"><li>底层分析：App优化</li></ol><ul><li><p><a href="">OC底层原理38：界面优化方案</a></p></li><li><p><a href="">OC底层原理39：组件化（一）方案</a></p></li><li><p><a href="">OC底层原理40：组件化（二）组件间通讯方式</a></p></li><li><p><a href="">OC底层原理41：内存优化（一）野指针探测</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OC-底层原理探索篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-OC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
