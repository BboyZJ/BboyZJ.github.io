<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="我是小J，关注我">
    <meta name="author" content="张建">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://www.bboyzj.cn/2020/08/11/oc学习/oc学习16：多线程/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    <meta property="og:type" content="article">
    <meta property="og:title" content="OC：多线程探索">
    <meta property="og:description" content="我是小J，关注我">
    <meta property="og:url" content="https://www.bboyzj.cn2020/08/11/OC学习/OC学习16：多线程/">
    <meta property="og:image" content="/images/redefine-logo.svg">
    <meta property="og:site_name" content="BboyZJ">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="OC：多线程探索">
    <meta name="twitter:description" content="我是小J，关注我">
    <meta name="twitter:image" content="/images/redefine-logo.svg">
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/BboyZJ.github.io/images/redefine-logo.svg">
    
    <title>
        
            OC：多线程探索 -
        
        BboyZJ
    </title>
    
<link rel="stylesheet" href="/BboyZJ.github.io/css/style.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/assets/fonts.css">

    
    
    
    
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"www.bboyzj.cn","root":"/BboyZJ.github.io/","language":"en","path":"search.xml"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/head_img.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"学无止境 学而不思则罔 思而不学则殆","custom_font":{"enable":false,"font_family":null,"font_url":null}},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_block":{"copy":true,"style":"mac","custom_font":{"enable":false,"font_family":null,"font_url":null}},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"1.1.5","friend_links":{"columns":2},"home_article":{"date_format":"auto","category":{"enable":true,"limit":3},"tag":{"enable":true,"limit":3}},"plugins":{"aplayer":{"enable":false,"audio":[{"name":null,"artist":null,"url":null,"cover":null},{"name":null,"artist":null,"url":null,"cover":null}]}}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/BboyZJ.github.io/atom.xml" title="张建的博客" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="menu-wrapper">
    
    <div class="menu-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                BboyZJ
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        首页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/tags/"  >
                                    
                                        
                                            <i class="fa-regular fa-tags"></i>
                                        
                                        标签
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/categories/"  >
                                    
                                        
                                            <i class="fa-regular fa-categories"></i>
                                        
                                        分类
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="menu-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                首页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/tags/"  >
                             
                                
                                    <i class="fa-regular fa-tags"></i>
                                
                                标签
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/categories/"  >
                             
                                
                                    <i class="fa-regular fa-categories"></i>
                                
                                分类
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">OC：多线程探索</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/BboyZJ.github.io/images/head_img.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">张建</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2020-08-11 12:42:42</span>
        <span class="mobile">2020-08-11 12:42</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="pc">2023-03-10 05:12:56</span>
            <span class="mobile">2023-03-10 05:12</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/BboyZJ.github.io/categories/OC/">OC</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/BboyZJ.github.io/tags/OC-%E5%AD%A6%E4%B9%A0/">OC-学习</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol>
<li>进程</li>
</ol>
<ul>
<li>在系统中正在运行的一个应用程序</li>
<li>每个进程之间是独立的,它们均运行在其专用且受保护的内存空间内.若你此时打开了微信,又打开了QQ音乐,则系统会分别启动两个进程.</li>
<li>iOS开发都是单进程,安卓可以支持多进程</li>
<li>进程可以控制很多条线程来执行相应的任务</li>
<li>进程至少要有一条线程,用来执行任务</li>
</ul>
<ol start="2">
<li>线程</li>
</ol>
<ul>
<li>是进程的基本执行单元,1个进程若想执行任务,至少要有一个线程</li>
<li>系统会默认开启一条线程,称为主线程或UI线程</li>
<li>线程上的任务执行完毕后,线程会自动销毁</li>
<li>但是开辟线程要耗费一定的内存空间,会耗时,异步不会堵塞线程,会先执行下面的语句,就是因为辟线程耗时了</li>
<li>我们开辟线程时有时会给他们命名,这样是为了打断点调试时能看到调用的堆栈信息</li>
</ul>
<ol start="3">
<li>主线程</li>
</ol>
<p>处理UI，所有更新UI的操作都必须在主线程上执行。不要把耗时操作放在主线程，界面会卡。</p>
<ol start="4">
<li>多线程</li>
</ol>
<p>在同一时刻，一个CPU只能处理1条线程，但CPU可以在多条线程之间快速的切换，只要切换的足够快，就造成了多线程一同执行的假象。</p>
<ol start="5">
<li>同步和异步</li>
</ol>
<ul>
<li>同步：在当前线程中执行任务，不具备开启新线程的能力；</li>
<li>异步：在新的线程中执行任务,具备开启新线程的能力；</li>
<li>同步函数(dispatch中的sync函数)：<ul>
<li>在当前线程中执行队列里面的任务，不具备开启线程的能力；</li>
<li>立马在当前线程执行任务，执行完毕后才能继续往下执行</li>
<li>阻塞当前线程，即同步函数内的任务不执行完，该函数就会卡住，不会继续往下执行；</li>
</ul>
</li>
<li>异步函数(dispatch中的async函数)：<ul>
<li>在新的线程中执行队列里面的任务，具备开启线程的能力；</li>
<li>不阻塞当前线程，不用管当前的任务是否完成，都会往下执行；</li>
<li>会有一段时间去执行线程中的任务，因此后面的任务可能会在它之前执行；</li>
</ul>
</li>
</ul>
<ol start="6">
<li>串行和并发</li>
</ol>
<ul>
<li>串行队列(DISPATCH_QUEUE_SERIAL )：一个任务执行完成后,再执行下一个任务。</li>
<li>并发队列(DISPATCH_QUEUE_CONCURRENT)：多个任务并发(同时)执行；</li>
</ul>
<h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><ol>
<li><p>地址空间<br>  进程之间是独立的地址空间,但同一进程的线程共享本进程的地址空间</p>
</li>
<li><p>资源拥有<br> 进程之间的资源是独立的,但同一进程的线程共享本进程的资源(如内存,I&#x2F;O,cpu等)</p>
</li>
<li><p>线程是处理器调度的基本单位,但进程不是,意思是CPU调度是调度线程</p>
</li>
<li><p>执行过程<br>进程可以独立执行,每个独立的进程都有一个程序运行的入口<br>线程不能独立执行,必须存活在应用程序中</p>
</li>
<li><p>崩溃<br>  进程崩溃时,对其他进程没有影响<br>  线程崩溃时,整个进程就死掉了<br>  多进程比多线程健壮</p>
</li>
</ol>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ol>
<li><p>多线程的原理：<br>CPU在单位时间片里快速的在各个线程之间切换</p>
</li>
<li><p>多线程的意义：</p>
</li>
</ol>
<p>优点： </p>
<ul>
<li>提高执行效率</li>
<li>提高资源(CPU,内存)利用率</li>
<li>线程执行完任务后,会自动销毁</li>
</ul>
<p>缺点：</p>
<ul>
<li>开启线程需要占用一定的内存空间,进行耗时</li>
<li>线程越多,耗时越多,会降低程序的性能,也会增大CPU在调用线程上的开销</li>
<li>程序设计会更加复杂,比如线程间的通信,多线程的数据共享</li>
</ul>
<h1 id="实现多线程的几种方式"><a href="#实现多线程的几种方式" class="headerlink" title="实现多线程的几种方式"></a>实现多线程的几种方式</h1><ol>
<li>NSThread</li>
<li>GCD</li>
<li>NSOperation</li>
</ol>
<h1 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h1><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点：NSThread比其他两个轻量级；</li>
<li>缺点：需要自己管理线程的生命周期，线程同步，线程同步时对数据的加锁会有一定的系统开销。</li>
</ul>
<h2 id="NSThread的使用"><a href="#NSThread的使用" class="headerlink" title="NSThread的使用"></a>NSThread的使用</h2><p>优点：NSThread比其他两个轻量级；<br>缺点：需要自己管理线程的生命周期，线程同步，线程同步时对数据的加锁会有一定的系统开销。</p>
<ol>
<li>实例方法创建NSThread</li>
</ol>
<ul>
<li>实例方法创建的NSThread对象，我们需要手动调用方法[thread start]来启动线程，实际上都是开辟了一个子线程。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo&#123;</span><br><span class="line">    //第一种方法：block方式</span><br><span class="line">    NSThread * thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">    [thread start];</span><br><span class="line">    </span><br><span class="line">    //第二种方法：SEL方式</span><br><span class="line">    NSThread * thread1 = [[NSThread alloc] initWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [thread1 start];</span><br><span class="line">&#125;</span><br><span class="line">- (void)run&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*********打印结果********</span><br><span class="line">2020-08-13 15:19:24.874162+0800 OC-多线程之NSThread[43983:2668593] &lt;NSThread: 0x600002269a80&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-13 15:19:24.874219+0800 OC-多线程之NSThread[43983:2668594] &lt;NSThread: 0x600002269800&gt;&#123;number = 7, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p>2.类方法创建NSThread</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//类方法创建</span><br><span class="line">- (void)demo1&#123;</span><br><span class="line">    //block</span><br><span class="line">    [NSThread detachNewThreadWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //SEL</span><br><span class="line">    [NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*********打印结果********</span><br><span class="line">2020-08-13 15:24:21.931115+0800 OC-多线程之NSThread[44042:2672229] &lt;NSThread: 0x600001314480&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-13 15:24:21.931220+0800 OC-多线程之NSThread[44042:2672230] &lt;NSThread: 0x600001308a80&gt;&#123;number = 6, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p>3.NSThread的其他方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//获取当前线程</span><br><span class="line">@property (class, readonly, strong) NSThread *currentThread;</span><br><span class="line"></span><br><span class="line">设置线程沉睡到指定日期</span><br><span class="line">+ (void)sleepUntilDate:(NSDate *)date;</span><br><span class="line">  </span><br><span class="line">线程沉睡时间间隔，这个方法在设置启动页间隔的时候比较常见</span><br><span class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)ti;</span><br><span class="line">  </span><br><span class="line">线程退出，当执行到某一个特殊情况下的时候你可以退出当前的线程，注意不要在主线程随便调用</span><br><span class="line">+ (void)exit;</span><br><span class="line">  </span><br><span class="line">线程的优先级</span><br><span class="line">+ (double)threadPriority;</span><br><span class="line">  </span><br><span class="line">设置线程的优先级：取值范围0~1，值越大，执行越早</span><br><span class="line">+ (BOOL)setThreadPriority:(double)p;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h2 id="NSObject分类中创建线程的方法"><a href="#NSObject分类中创建线程的方法" class="headerlink" title="NSObject分类中创建线程的方法"></a>NSObject分类中创建线程的方法</h2><p>除了上面的两种方式创建线程外，@interface NSObject (NSThreadPerformAdditions)这个NSObject分类别中也有一些创建线程的方法：<br>1）主线程执行任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">在主线程执行任务</span><br><span class="line">aSelector：一个选择器, 指定要调用的方法</span><br><span class="line">arg：需要传递给调用方法的参数，如果没有需要的参数,传入nil</span><br><span class="line">waitUntilDone：一个布尔值，指定是否阻塞当前线程直到指定选择器在主线程中执行完毕。选择YES会阻塞这个线程；选择NO，本方法会立刻返回。</span><br><span class="line">modes：RunLoop的运行的类型</span><br><span class="line">*/</span><br><span class="line">[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES modes:nil];</span><br><span class="line">[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];</span><br></pre></td></tr></table></figure>

<p>2)实际使用<br>例子1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    [self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">- (void)run&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*******打印结果******</span><br><span class="line">2020-08-13 23:11:39.640250+0800 OC-多线程之NSThread[45345:2800240] 1</span><br><span class="line">2020-08-13 23:11:39.662218+0800 OC-多线程之NSThread[45345:2800240] &lt;NSThread: 0x600001114480&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结论：waitUntilDone设置为NO，没有堵塞主线程，先打印1，后打印[NSThread currentThread]。</p>
<p>例子2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES];</span><br></pre></td></tr></table></figure>
<p>如果将waitUntilDone设置为YES，堵塞主线程，先打印[NSThread currentThread]后打印1</p>
<p>2.指定线程执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self performSelector:@selector(run) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</span><br><span class="line">[self  performSelector:@selector(run) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO modes:nil];</span><br></pre></td></tr></table></figure>

<p>3.指定后台执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//后台执行</span><br><span class="line">[self performSelectorInBackground:@selector(run) withObject:nil];</span><br></pre></td></tr></table></figure>

<p>开启了一个新的线程去执行任务</p>
<h1 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h1><h2 id="什么是GCD？"><a href="#什么是GCD？" class="headerlink" title="什么是GCD？"></a>什么是GCD？</h2><p>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。</p>
<h2 id="GCD的优点"><a href="#GCD的优点" class="headerlink" title="GCD的优点?"></a>GCD的优点?</h2><ul>
<li>GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>GCD更接近底层，性能较高</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h1><h2 id="NSOperation介绍"><a href="#NSOperation介绍" class="headerlink" title="NSOperation介绍"></a>NSOperation介绍</h2><ul>
<li><p>NSOperation是基于GCD开发的，是GCD更高一层的封装，比GCD拥有更强的可控性和代码可读性。</p>
</li>
<li><p>NSOperation是一个抽象基类，表示一个独立的计算单元，可以为子类提供有用且线程安全的建立状态，优先级，依赖和取消等操作。</p>
</li>
<li><p>我们使用比较多的就是它的子类NSInvocationOperation和NSBlockOperation。不过我们更多的使用是自己继承并定制自己的操作。</p>
</li>
</ul>
<h2 id="为什么要使用-NSOperation？"><a href="#为什么要使用-NSOperation？" class="headerlink" title="为什么要使用 NSOperation？"></a>为什么要使用 NSOperation？</h2><ul>
<li>可添加完成的代码块，在操作完成后执行。</li>
<li>添加操作之间的依赖关系，方便的控制执行顺序。</li>
<li>设定操作执行的优先级。</li>
<li>可以很方便的取消一个操作的执行。</li>
<li>使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。</li>
</ul>
<h2 id="NSOperation、NSOperationQueue-操作和操作队列"><a href="#NSOperation、NSOperationQueue-操作和操作队列" class="headerlink" title="NSOperation、NSOperationQueue 操作和操作队列"></a>NSOperation、NSOperationQueue 操作和操作队列</h2><p>既然是基于 GCD 的更高一层的封装。那么，GCD 中的一些概念同样适用于 NSOperation、NSOperationQueue。在 NSOperation、NSOperationQueue 中也有类似的任务（操作）和队列（操作队列）的概念。</p>
<p>1.操作（Operation）</p>
<ul>
<li>执行操作的意思，换句话说就是你在线程中执行的那段代码。</li>
<li>在 GCD 中是放在 block 中的。在 NSOperation 中，我们使用 NSOperation 子类 NSInvocationOperation、NSBlockOperation，或者自定义子类来封装操作。</li>
</ul>
<p>2.操作队列（Operation Queues）：</p>
<ul>
<li>这里的队列指操作队列，即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</li>
<li>操作队列通过设置最大并发操作数（maxConcurrentOperationCount）来控制并发、串行。</li>
<li>NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。</li>
</ul>
<h2 id="NSOperation、NSOperationQueue-使用介绍"><a href="#NSOperation、NSOperationQueue-使用介绍" class="headerlink" title="NSOperation、NSOperationQueue 使用介绍"></a>NSOperation、NSOperationQueue 使用介绍</h2><ul>
<li><p>NSOperation 需要配合 NSOperationQueue 来实现多线程。因为默认情况下，NSOperation 单独使用时系统同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行。</p>
</li>
<li><p>NSOperation 实现多线程的使用步骤分为三步：</p>
<ul>
<li>创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。</li>
<li>创建队列：创建 NSOperationQueue 对象。</li>
<li>将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。</li>
</ul>
</li>
<li><p>之后呢，系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。</p>
</li>
</ul>
<h2 id="NSOperation的基本使用"><a href="#NSOperation的基本使用" class="headerlink" title="NSOperation的基本使用"></a>NSOperation的基本使用</h2><p><strong>1.使用子类 NSInvocationOperation</strong></p>
<ul>
<li>在主线程执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo&#123;</span><br><span class="line">    //1.创建NSInvocationOperation 对象</span><br><span class="line">    NSInvocationOperation * operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">    //2.调用 start 方法开始执行操作</span><br><span class="line">    [operation start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**********打印结果**********</span><br><span class="line">2020-08-16 11:59:20.701876+0800 OC-NSOperation[1670:53602] &lt;NSThread: 0x600003f28d40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到：在没有使用 NSOperationQueue、在主线程中单独使用使用子类 NSInvocationOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。</p>
<ul>
<li>在子线程执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo&#123;</span><br><span class="line">    //3.在其他线程使用</span><br><span class="line">    [NSThread detachNewThreadWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        //1.创建NSInvocationOperation 对象</span><br><span class="line">        NSInvocationOperation * operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">        //2.调用 start 方法开始执行操作</span><br><span class="line">        [operation start];</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run&#123;</span><br><span class="line">    NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**********打印结果**********</span><br><span class="line">2020-08-16 12:06:20.454733+0800 OC-NSOperation[1782:60475] 1---&lt;NSThread: 0x600000cfe200&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 12:06:20.455356+0800 OC-NSOperation[1782:60475] 2---&lt;NSThread: 0x600000cfe200&gt;&#123;number = 6, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到：在其他线程中单独使用子类 NSInvocationOperation，操作是在当前调用的其他线程执行的，并没有开启新线程。</p>
<p><strong>2.使用子类 NSBlockOperation</strong></p>
<ul>
<li>在主线程使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo1&#123;</span><br><span class="line">    //1.创建 NSBlockOperation 对象</span><br><span class="line">    NSBlockOperation * operation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        //打印当前线程</span><br><span class="line">        NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    //2.调用 start 方法开始执行操作</span><br><span class="line">    [operation start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*********打印结果**********</span><br><span class="line">2020-08-16 12:09:47.030187+0800 OC-NSOperation[1837:63421] &lt;NSThread: 0x6000034b0380&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到：在没有使用 NSOperationQueue、在主线程中单独使用 NSBlockOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。</p>
<p>注意：和上边 NSInvocationOperation 使用一样。因为代码是在主线程中调用的，所以打印结果为主线程。如果在其他线程中执行操作，则打印结果为其他线程。</p>
<p>但是，NSBlockOperation 还提供了一个方法 addExecutionBlock:，通过 addExecutionBlock: 就可以为 NSBlockOperation 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中同时（并发）执行。只有当所有相关的操作已经完成执行时，才视为完成。</p>
<p>如果添加的操作多的话，blockOperationWithBlock: 中的操作也可能会在其他线程（非当前线程）中执行，这是由系统决定的，并不是说添加到 blockOperationWithBlock: 中的操作一定会在当前线程中执行。（可以使用 addExecutionBlock: 多添加几个操作试试）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo1&#123;</span><br><span class="line">    //1.创建 NSBlockOperation 对象</span><br><span class="line">    NSBlockOperation * operation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        //打印当前线程</span><br><span class="line">        NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //2.添加额外的操作</span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">        //打印当前线程</span><br><span class="line">        NSLog(@&quot;1-%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">        //打印当前线程</span><br><span class="line">        NSLog(@&quot;2-%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">        //打印当前线程</span><br><span class="line">        NSLog(@&quot;3-%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">        //打印当前线程</span><br><span class="line">        NSLog(@&quot;4-%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //调用 start 方法开始执行操作</span><br><span class="line">    [operation start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**********打印结果********</span><br><span class="line">2020-08-16 12:13:40.905153+0800 OC-NSOperation[1926:67565] 1-&lt;NSThread: 0x6000032c4f80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 12:13:40.905162+0800 OC-NSOperation[1926:67564] 2-&lt;NSThread: 0x6000032be140&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 12:13:40.905168+0800 OC-NSOperation[1926:67563] 3-&lt;NSThread: 0x6000032cd180&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-16 12:13:40.905186+0800 OC-NSOperation[1926:67504] &lt;NSThread: 0x60000328c240&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-08-16 12:13:40.905385+0800 OC-NSOperation[1926:67565] 4-&lt;NSThread: 0x6000032c4f80&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出：使用子类 NSBlockOperation，并调用方法 AddExecutionBlock: 的情况下，blockOperationWithBlock:方法中的操作 和 addExecutionBlock: 中的操作是在不同的线程中并发执行的。而且，这次执行结果中 blockOperationWithBlock:方法中的操作也不是在当前线程（主线程）中执行的。从而印证了blockOperationWithBlock: 中的操作也可能会在其他线程（非当前线程）中执行。</p>
<p>一般情况下，如果一个 NSBlockOperation 对象封装了多个操作。NSBlockOperation 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。</p>
<p><strong>3.使用自定义继承自 NSOperation 的子类</strong><br>如果使用子类 NSInvocationOperation、NSBlockOperation 不能满足日常需求，我们可以使用自定义继承自 NSOperation 的子类。可以通过重写 main 或者 start 方法 来定义自己的 NSOperation 对象。重写main方法比较简单，我们不需要管理操作的状态属性 isExecuting 和 isFinished。当 main 执行完返回的时候，这个操作就结束了。</p>
<ul>
<li>在主线程中使用<br>先定义一个继承自 NSOperation 的子类，重写main方法。<br>.h文件中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface ZJOperation : NSOperation</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>.m文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ZJOperation.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZJOperation</span><br><span class="line">- (void)main&#123;</span><br><span class="line">    if (!self.cancelled) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;ZJ---%@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在其他类中使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo2&#123;</span><br><span class="line">    //1.创建ZJOperation对象</span><br><span class="line">    ZJOperation * operation = [[ZJOperation alloc] init];</span><br><span class="line">    //2.调用 start 方法开始执行操作</span><br><span class="line">    [operation start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*******打印结果******</span><br><span class="line">2020-08-16 12:24:16.940268+0800 OC-NSOperation[2093:75334] ZJ---&lt;NSThread: 0x600001994380&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-08-16 12:24:18.941867+0800 OC-NSOperation[2093:75334] ZJ---&lt;NSThread: 0x600001994380&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出：在没有使用 NSOperationQueue、在主线程单独使用自定义继承自 NSOperation 的子类的情况下，是在主线程执行操作，并没有开启新线程。</p>
<ul>
<li>在子线程中使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo2&#123;</span><br><span class="line">    //1.在子线程中使用</span><br><span class="line">    [NSThread detachNewThreadWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">        //1.创建ZJOperation对象</span><br><span class="line">        ZJOperation * operation = [[ZJOperation alloc] init];</span><br><span class="line">        //2.调用 start 方法开始执行操作</span><br><span class="line">        [operation start];</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*******打印结果******</span><br><span class="line">2020-08-16 12:26:04.684475+0800 OC-NSOperation[2117:76849] 1---&lt;NSThread: 0x600003fd6900&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 12:26:06.689546+0800 OC-NSOperation[2117:76849] ZJ---&lt;NSThread: 0x600003fd6900&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 12:26:08.694929+0800 OC-NSOperation[2117:76849] ZJ---&lt;NSThread: 0x600003fd6900&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出：在没有使用 NSOperationQueue、在子线程单独使用自定义继承自 NSOperation 的子类的情况下，是在子线程执行操作，没有开启新线程。</p>
<h2 id="NSOperationQueue的基本使用"><a href="#NSOperationQueue的基本使用" class="headerlink" title="NSOperationQueue的基本使用"></a>NSOperationQueue的基本使用</h2><p>NSOperationQueue 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。下边是主队列、自定义队列的基本创建方法和特点。</p>
<ul>
<li>主队列：凡是添加到主队列中的操作，都会放到主线程中执行（注：不包括操作使用addExecutionBlock:添加的额外操作，额外操作可能在其他线程执行，感谢指正）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 主队列获取方法</span><br><span class="line">NSOperationQueue *queue = [NSOperationQueue mainQueue];</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义队列（非主队列）：添加到这种队列中的操作，就会自动放到子线程中执行。同时包含了：串行、并发功能。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 自定义队列创建方法</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br></pre></td></tr></table></figure>

<p><strong>1.将操作加入到队列中</strong><br>上边我们说到 NSOperation 需要配合 NSOperationQueue 来实现多线程。</p>
<p>那么我们需要将创建好的操作加入到队列中去。总共有两种方法：</p>
<p>1)- (void)addOperation:(NSOperation *)op;<br>需要先创建操作，再将创建好的操作加入到创建好的队列中去。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo3&#123;</span><br><span class="line">    //1.创建队列</span><br><span class="line">    NSOperationQueue * queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    </span><br><span class="line">    // 2.创建操作</span><br><span class="line">    // 使用 NSInvocationOperation 创建操作1</span><br><span class="line">    NSInvocationOperation * op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line"></span><br><span class="line">    // 使用 NSBlockOperation 创建操作3</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        // 打印当前线程</span><br><span class="line">        NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [op2 addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 3.使用 addOperation: 添加所有操作到队列中</span><br><span class="line">    [queue addOperation:op1]; // [op1 start]</span><br><span class="line">    [queue addOperation:op2]; // [op2 start]</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run&#123;</span><br><span class="line">    NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*********打印操作*******</span><br><span class="line">2020-08-16 12:37:09.954238+0800 OC-NSOperation[2180:82843] 2---&lt;NSThread: 0x600002018d40&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2020-08-16 12:37:09.954238+0800 OC-NSOperation[2180:82848] 3---&lt;NSThread: 0x60000201db40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2020-08-16 12:37:09.954271+0800 OC-NSOperation[2180:82845] 1---&lt;NSThread: 0x600002062d40&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出：使用 NSOperation 子类创建操作，并使用 addOperation: 将操作加入到操作队列后能够开启新线程，进行并发执行。</p>
<p>2)- (void)addOperationWithBlock:(void (^)(void))block;<br>无需先创建操作，在 block 中添加操作，直接将包含操作的 block 加入到队列中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo4&#123;</span><br><span class="line">    //1.创建队列</span><br><span class="line">    NSOperationQueue * queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    //2.使用 addOperationWithBlock: 添加操作到队列中</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*********打印操作*******</span><br><span class="line">2020-08-16 12:40:45.166909+0800 OC-NSOperation[2238:85786] 2---&lt;NSThread: 0x60000291a680&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2020-08-16 12:40:45.166909+0800 OC-NSOperation[2238:85788] 1---&lt;NSThread: 0x600002965400&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2020-08-16 12:40:45.166921+0800 OC-NSOperation[2238:85784] 3---&lt;NSThread: 0x600002965540&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出：使用 addOperationWithBlock: 将操作加入到操作队列后能够开启新线程，进行并发执行。</p>
<p><strong>2.NSOperationQueue 控制串行执行、并发执行</strong></p>
<p>之前我们说过，NSOperationQueue 创建的自定义队列同时具有串行、并发功能，上边我们演示了并发功能，那么他的串行功能是如何实现的？</p>
<p>这里有个关键属性 maxConcurrentOperationCount，叫做最大并发操作数。用来控制一个特定队列中可以有多少个操作同时参与并发执行。</p>
<p><code>注意：这里 maxConcurrentOperationCount 控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。</code></p>
<ul>
<li>最大并发操作数：maxConcurrentOperationCount<br>maxConcurrentOperationCount <ul>
<li>默认情况下为-1，表示不进行限制，可进行并发执行。</li>
<li>maxConcurrentOperationCount 为1时，队列为串行队列。只能串行执行。</li>
<li>maxConcurrentOperationCount 大于1时，队列为并发队列。操作并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为 min{自己设定的值，系统设定的默认最大值}。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo5&#123;</span><br><span class="line">    /*</span><br><span class="line">     设置 MaxConcurrentOperationCount（最大并发操作数）</span><br><span class="line">     */</span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue * queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 2.设置最大并发操作数</span><br><span class="line">//    queue.maxConcurrentOperationCount = 1; // 串行队列</span><br><span class="line">// queue.maxConcurrentOperationCount = 2; // 并发队列</span><br><span class="line"> queue.maxConcurrentOperationCount = 8; // 并发队列</span><br><span class="line"></span><br><span class="line">    // 3.添加操作</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最大并发操作数为1 输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-08-16 12:48:09.090860+0800 OC-NSOperation[2324:91784] 1---&lt;NSThread: 0x600002a2e780&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 12:48:09.091107+0800 OC-NSOperation[2324:91784] 2---&lt;NSThread: 0x600002a2e780&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 12:48:09.091296+0800 OC-NSOperation[2324:91784] 3---&lt;NSThread: 0x600002a2e780&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 12:48:09.091446+0800 OC-NSOperation[2324:91784] 4---&lt;NSThread: 0x600002a2e780&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最大并发操作数为2 输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2020-08-16 12:48:24.421434+0800 OC-NSOperation[2338:92272] 2---&lt;NSThread: 0x600001106780&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 12:48:24.421437+0800 OC-NSOperation[2338:92269] 1---&lt;NSThread: 0x6000011066c0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2020-08-16 12:48:24.421724+0800 OC-NSOperation[2338:92269] 4---&lt;NSThread: 0x6000011066c0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2020-08-16 12:48:24.421733+0800 OC-NSOperation[2338:92272] 3---&lt;NSThread: 0x600001106780&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最大并发操作数为8 输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*******打印结果******8</span><br><span class="line">2020-08-16 12:46:22.158690+0800 OC-NSOperation[2307:90480] 2---&lt;NSThread: 0x6000024003c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 12:46:22.158727+0800 OC-NSOperation[2307:90478] 4---&lt;NSThread: 0x60000240bb00&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-16 12:46:22.158737+0800 OC-NSOperation[2307:90482] 1---&lt;NSThread: 0x600002408ac0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2020-08-16 12:46:22.158760+0800 OC-NSOperation[2307:90485] 3---&lt;NSThread: 0x600002418ac0&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出：当最大并发操作数为1时，操作是按顺序串行执行的，并且一个操作完成之后，下一个操作才开始执行。当最大操作并发数为2时，操作是并发执行的，可以同时执行两个操作。而开启线程数量是由系统决定的，不需要我们来管理。</p>
<p><strong>3.NSOperationQueue 操作依赖</strong><br>NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。NSOperation 提供了3个接口供我们管理和查看依赖。</p>
<ul>
<li>(void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。</li>
<li>(void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。<br>@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。<br>当然，我们经常用到的还是添加依赖操作。现在考虑这样的需求，比如说有 A、B 两个操作，其中 A 执行完操作，B 才能执行操作。</li>
</ul>
<p>如果使用依赖来处理的话，那么就需要让操作 B 依赖于操作 A。具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo5&#123;</span><br><span class="line">    /*</span><br><span class="line">     设置 MaxConcurrentOperationCount（最大并发操作数）</span><br><span class="line">     */</span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue * queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 2.设置最大并发操作数</span><br><span class="line">//    queue.maxConcurrentOperationCount = 1; // 串行队列</span><br><span class="line"> queue.maxConcurrentOperationCount = 2; // 并发队列</span><br><span class="line">// queue.maxConcurrentOperationCount = 8; // 并发队列</span><br><span class="line"></span><br><span class="line">    // 3.添加操作</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)demo6&#123;</span><br><span class="line">    /*</span><br><span class="line">        操作依赖</span><br><span class="line">        使用方法：addDependency:</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 2.创建操作</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 3.添加依赖</span><br><span class="line">    [op2 addDependency:op1]; // 让op2 依赖于 op1，则先执行op1，在执行op2</span><br><span class="line"></span><br><span class="line">    // 4.添加操作到队列中</span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">******打印结果*****</span><br><span class="line">2020-08-16 12:52:02.556360+0800 OC-NSOperation[2376:94789] 1---&lt;NSThread: 0x6000017fe000&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2020-08-16 12:52:02.556627+0800 OC-NSOperation[2376:94792] 2---&lt;NSThread: 0x6000017f4ac0&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到：通过添加操作依赖，无论运行几次，其结果都是 op1 先执行，op2 后执行。</p>
<p><strong>4.NSOperationQueue 优先级</strong><br>NSOperation 提供了queuePriority（优先级）属性，queuePriority属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是NSOperationQueuePriorityNormal。但是我们可以通过setQueuePriority:方法来改变当前操作在同一队列中的执行优先级。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 优先级的取值</span><br><span class="line">typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123;</span><br><span class="line">    NSOperationQueuePriorityVeryLow = -8L,</span><br><span class="line">    NSOperationQueuePriorityLow = -4L,</span><br><span class="line">    NSOperationQueuePriorityNormal = 0,</span><br><span class="line">    NSOperationQueuePriorityHigh = 4,</span><br><span class="line">    NSOperationQueuePriorityVeryHigh = 8</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上边我们说过：对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</p>
<p><strong>那么，什么样的操作才是进入就绪状态的操作呢？</strong></p>
<ul>
<li><p>当一个操作的所有依赖都已经完成时，操作对象通常会进入准备就绪状态，等待执行。<br>举个例子，现在有4个优先级都是 NSOperationQueuePriorityNormal（默认级别）的操作：op1，op2，op3，op4。其中 op3 依赖于 op2，op2 依赖于 op1，即 op3 -&gt; op2 -&gt; op1。现在将这4个操作添加到队列中并发执行。</p>
</li>
<li><p>因为 op1 和 op4 都没有需要依赖的操作，所以在 op1，op4 执行之前，就是处于准备就绪状态的操作。<br>而 op3 和 op2 都有依赖的操作（op3 依赖于 op2，op2 依赖于 op1），所以 op3 和 op2 都不是准备就绪状态下的操作。<br>理解了进入就绪状态的操作，那么我们就理解了queuePriority 属性的作用对象。</p>
</li>
<li><p>queuePriority 属性决定了进入准备就绪状态下的操作之间的开始执行顺序。并且，优先级不能取代依赖关系。<br>如果一个队列中既包含高优先级操作，又包含低优先级操作，并且两个操作都已经准备就绪，那么队列先执行高优先级操作。比如上例中，如果 op1 和 op4 是不同优先级的操作，那么就会先执行优先级高的操作。<br>如果，一个队列中既包含了准备就绪状态的操作，又包含了未准备就绪的操作，未准备就绪的操作优先级比准备就绪的操作优先级高。那么，虽然准备就绪的操作优先级低，也会优先执行。优先级不能取代依赖关系。如果要控制操作间的启动顺序，则必须使用依赖关系。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo6&#123;</span><br><span class="line">    /*</span><br><span class="line">        操作依赖</span><br><span class="line">        使用方法：addDependency:</span><br><span class="line">        优先级：setQueuePriority</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line"></span><br><span class="line">    // 2.创建操作</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [op1 setQueuePriority:NSOperationQueuePriorityLow];</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [op2 setQueuePriority:NSOperationQueuePriorityVeryHigh];</span><br><span class="line"></span><br><span class="line">    NSBlockOperation * op3 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">    &#125;];</span><br><span class="line">    [op3 setQueuePriority:NSOperationQueuePriorityHigh];</span><br><span class="line">    </span><br><span class="line">    // 3.添加依赖</span><br><span class="line">    [op2 addDependency:op1]; // 让op2 依赖于 op1，则先执行op1，在执行op2</span><br><span class="line"></span><br><span class="line">    // 4.添加操作到队列中</span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">    [queue addOperation:op3];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">********打印结果*******</span><br><span class="line">2020-08-16 13:38:09.628886+0800 OC-NSOperation[2556:109314] 3---&lt;NSThread: 0x6000039d1880&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2020-08-16 13:38:09.628901+0800 OC-NSOperation[2556:109318] 1---&lt;NSThread: 0x6000039dcd80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2020-08-16 13:38:09.629143+0800 OC-NSOperation[2556:109318] 2---&lt;NSThread: 0x6000039dcd80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>由打印结果可知：优先级高的限制性，再执行优先级低的，再执行依赖关系的</p>
<h2 id="NSOperation、NSOperationQueue-线程间的通信"><a href="#NSOperation、NSOperationQueue-线程间的通信" class="headerlink" title="NSOperation、NSOperationQueue 线程间的通信"></a>NSOperation、NSOperationQueue 线程间的通信</h2><p>在 iOS 开发过程中，我们一般在主线程里边进行 UI 刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 线程间通信</span><br><span class="line"> */</span><br><span class="line">- (void)demo7 &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc]init];</span><br><span class="line"></span><br><span class="line">    // 2.添加操作</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        // 异步进行耗时操作</span><br><span class="line">        NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line"></span><br><span class="line">        // 回到主线程</span><br><span class="line">        [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            // 进行一些 UI 刷新等操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">   &#125;];</span><br><span class="line">&#125;</span><br><span class="line">***********打印结果********</span><br><span class="line">2020-08-16 13:43:39.078799+0800 OC-NSOperation[2631:113017] 1---&lt;NSThread: 0x60000328d940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2020-08-16 13:43:39.097297+0800 OC-NSOperation[2631:112960] 2---&lt;NSThread: 0x6000032c8e80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到：通过线程间的通信，先在其他线程中执行操作，等操作执行完了之后再回到主线程执行主线程的相应操作</p>
<h2 id="NSOperation、NSOperationQueue-线程同步和线程安全"><a href="#NSOperation、NSOperationQueue-线程同步和线程安全" class="headerlink" title="NSOperation、NSOperationQueue 线程同步和线程安全"></a>NSOperation、NSOperationQueue 线程同步和线程安全</h2><ul>
<li><p>线程安全：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。<br>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
</li>
<li><p>线程同步：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。</p>
</li>
</ul>
<p>举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。</p>
<p>1.例子:下面，我们模拟火车票售卖的方式，实现 NSOperation 线程安全和解决线程同步问题。<br>场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。</p>
<p>1）先来看看不考虑线程安全的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 非线程安全：不使用 NSLock</span><br><span class="line">* 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票</span><br><span class="line">*/</span><br><span class="line">- (void)demo8&#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程</span><br><span class="line">    </span><br><span class="line">    //总票数</span><br><span class="line">    self.ticketSurplusCount = 10;</span><br><span class="line"></span><br><span class="line">    // 1.创建 queue1,queue1 代表北京火车票售卖窗口</span><br><span class="line">    NSOperationQueue * queue1 = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue1.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    // 2.创建 queue2,queue2 代表上海火车票售卖窗口</span><br><span class="line">    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue2.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    // 3.创建卖票操作 op1</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">       [self saleTicketNotSafe];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 4.创建卖票操作 op2</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">       [self saleTicketNotSafe];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 5.添加操作，开始卖票</span><br><span class="line">    [queue1 addOperation:op1];</span><br><span class="line">    [queue2 addOperation:op2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 售卖火车票(非线程安全)</span><br><span class="line"> */</span><br><span class="line">- (void)saleTicketNotSafe &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        if (self.ticketSurplusCount &gt; 0) &#123;</span><br><span class="line">            //如果还有票，继续售卖</span><br><span class="line">            self.ticketSurplusCount--;</span><br><span class="line">            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%ld 窗口:%@&quot;, (long)self.ticketSurplusCount, [NSThread currentThread]]);</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSLog(@&quot;所有火车票均已售完&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2020-08-16 13:51:15.967134+0800 OC-NSOperation[2709:117554] currentThread---&lt;NSThread: 0x600000170d40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-08-16 13:51:15.970381+0800 OC-NSOperation[2709:117657] 剩余票数:9 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:15.971286+0800 OC-NSOperation[2709:117652] 剩余票数:8 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.171627+0800 OC-NSOperation[2709:117657] 剩余票数:7 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.171722+0800 OC-NSOperation[2709:117652] 剩余票数:6 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.374218+0800 OC-NSOperation[2709:117657] 剩余票数:5 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.374490+0800 OC-NSOperation[2709:117652] 剩余票数:4 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.574756+0800 OC-NSOperation[2709:117657] 剩余票数:3 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.574900+0800 OC-NSOperation[2709:117652] 剩余票数:2 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.778734+0800 OC-NSOperation[2709:117652] 剩余票数:1 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.778655+0800 OC-NSOperation[2709:117657] 剩余票数:1 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.980112+0800 OC-NSOperation[2709:117657] 剩余票数:0 窗口:&lt;NSThread: 0x60000013c980&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:16.980114+0800 OC-NSOperation[2709:117652] 剩余票数:0 窗口:&lt;NSThread: 0x600000170ac0&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2020-08-16 13:51:17.183727+0800 OC-NSOperation[2709:117657] 所有火车票均已售完</span><br><span class="line">2020-08-16 13:51:17.183727+0800 OC-NSOperation[2709:117652] 所有火车票均已售完</span><br></pre></td></tr></table></figure>

<p>可以看到：在不考虑线程安全，不使用 NSLock 情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。</p>
<p>2）再来看看考虑线程安全的代码:<br>线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set&#x2F;get等等各种方式。这里我们使用 NSLock 对象来解决线程同步问题。NSLock 对象可以通过进入锁时调用 lock 方法，解锁时调用 unlock 方法来保证线程安全。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程安全：使用 NSLock 加锁</span><br><span class="line"> * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)demo9 &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程</span><br><span class="line">    </span><br><span class="line">    // 总票数</span><br><span class="line">    self.ticketSurplusCount = 10;</span><br><span class="line"></span><br><span class="line">    // 初始化 NSLock 对象</span><br><span class="line">    self.lock = [[NSLock alloc] init];</span><br><span class="line"></span><br><span class="line">    // 1.创建 queue1,queue1 代表北京火车票售卖窗口</span><br><span class="line">    NSOperationQueue *queue1 = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue1.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    // 2.创建 queue2,queue2 代表上海火车票售卖窗口</span><br><span class="line">    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];</span><br><span class="line">    queue2.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    // 3.创建卖票操作 op1</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [self saleTicketSafe];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 4.创建卖票操作 op2</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [self saleTicketSafe];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 5.添加操作，开始卖票</span><br><span class="line">    [queue1 addOperation:op1];</span><br><span class="line">    [queue2 addOperation:op2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 售卖火车票(线程安全)</span><br><span class="line"> */</span><br><span class="line">- (void)saleTicketSafe &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line"></span><br><span class="line">        // 加锁</span><br><span class="line">        [self.lock lock];</span><br><span class="line"></span><br><span class="line">        if (self.ticketSurplusCount &gt; 0) &#123;</span><br><span class="line">            //如果还有票，继续售卖</span><br><span class="line">            self.ticketSurplusCount--;</span><br><span class="line">            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%ld 窗口:%@&quot;, (long)self.ticketSurplusCount, [NSThread currentThread]]);</span><br><span class="line">            [NSThread sleepForTimeInterval:0.2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 解锁</span><br><span class="line">        [self.lock unlock];</span><br><span class="line"></span><br><span class="line">        if (self.ticketSurplusCount &lt;= 0) &#123;</span><br><span class="line">            NSLog(@&quot;所有火车票均已售完&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2020-08-16 13:56:47.871368+0800 OC-NSOperation[2745:120698] currentThread---&lt;NSThread: 0x6000035a8440&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2020-08-16 13:56:47.872873+0800 OC-NSOperation[2745:120803] 剩余票数:9 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:48.075868+0800 OC-NSOperation[2745:120803] 剩余票数:8 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:48.276917+0800 OC-NSOperation[2745:120803] 剩余票数:7 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:48.477632+0800 OC-NSOperation[2745:120803] 剩余票数:6 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:48.683070+0800 OC-NSOperation[2745:120803] 剩余票数:5 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:48.887849+0800 OC-NSOperation[2745:120803] 剩余票数:4 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:49.093434+0800 OC-NSOperation[2745:120803] 剩余票数:3 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:49.295885+0800 OC-NSOperation[2745:120803] 剩余票数:2 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:49.501106+0800 OC-NSOperation[2745:120803] 剩余票数:1 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:49.704799+0800 OC-NSOperation[2745:120803] 剩余票数:0 窗口:&lt;NSThread: 0x6000035ee100&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2020-08-16 13:56:49.909619+0800 OC-NSOperation[2745:120804] 所有火车票均已售完</span><br><span class="line">2020-08-16 13:56:49.909621+0800 OC-NSOperation[2745:120803] 所有火车票均已售完</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出：在考虑了线程安全，使用 NSLock 加锁、解锁机制的情况下，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。</p>
<h2 id="NSOperation、NSOperationQueue-常用属性和方法归纳"><a href="#NSOperation、NSOperationQueue-常用属性和方法归纳" class="headerlink" title="NSOperation、NSOperationQueue 常用属性和方法归纳"></a>NSOperation、NSOperationQueue 常用属性和方法归纳</h2><p>1.NSOperation 常用属性和方法</p>
<ul>
<li>取消操作方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancel; 可取消操作，实质是标记 isCancelled 状态。</span><br><span class="line">判断操作状态方法</span><br><span class="line">- (BOOL)isFinished; 判断操作是否已经结束。</span><br><span class="line">- (BOOL)isCancelled; 判断操作是否已经标记为取消。</span><br><span class="line">- (BOOL)isExecuting; 判断操作是否正在在运行。</span><br><span class="line">- (BOOL)isReady; 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。</span><br></pre></td></tr></table></figure>

<ul>
<li>操作同步</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)waitUntilFinished; 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。</span><br><span class="line">- (void)setCompletionBlock:(void (^)(void))block; completionBlock 会在当前操作执行完毕时执行 completionBlock。</span><br><span class="line">- (void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。</span><br><span class="line">- (void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。</span><br><span class="line">@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.NSOperationQueue 常用属性和方法</p>
<ul>
<li>取消&#x2F;暂停&#x2F;恢复操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancelAllOperations; 可以取消队列的所有操作。</span><br><span class="line">- (BOOL)isSuspended; 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。</span><br><span class="line">- (void)setSuspended:(BOOL)b; 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>操作同步</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)waitUntilAllOperationsAreFinished; 阻塞当前线程，直到队列中的操作全部执行完毕。</span><br></pre></td></tr></table></figure>

<ul>
<li>添加&#x2F;获取操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)addOperationWithBlock:(void (^)(void))block; 向队列中添加一个 NSBlockOperation 类型操作对象。</span><br><span class="line">- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束</span><br><span class="line">- (NSArray *)operations; 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。</span><br><span class="line">- (NSUInteger)operationCount; 当前队列中的操作数。</span><br><span class="line"></span><br><span class="line">作者：行走少年郎</span><br><span class="line">链接：https://www.jianshu.com/p/4b1d77054b35</span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<ul>
<li>获取队列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (id)currentQueue; 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。</span><br><span class="line">+ (id)mainQueue; 获取主队列。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
</blockquote>
<blockquote>
<p>这里的暂停和取消（包括操作的取消和队列的取消）并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。<br>暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。</p>
</blockquote>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：OC：多线程探索</li>
        <li>Post author：张建</li>
        <li>Create time：2020-08-11 12:42:42</li>
        <li>
            Post link：https://redefine.ohevan.com/2020/08/11/OC学习/OC学习16：多线程/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/BboyZJ.github.io/tags/OC-%E5%AD%A6%E4%B9%A0/">#OC-学习</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/BboyZJ.github.io/2020/08/11/OCRuntime&amp;Runloop/OCRuntime01%EF%BC%9Aruntime%E5%88%9D%E6%8E%A2/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">OCRunloop02：runtime初探</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/BboyZJ.github.io/2020/08/11/Swift/Swift%E5%AD%A6%E4%B9%A0%EF%BC%9ASnapkit%E4%BD%BF%E7%94%A8%E6%8E%A2%E7%B4%A2/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">Swift学习：Snapkit使用探索</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">OC：多线程探索</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">进程和线程的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-text">实现多线程的几种方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NSThread"><span class="nav-text">NSThread</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSThread%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">NSThread的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSObject%E5%88%86%E7%B1%BB%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">NSObject分类中创建线程的方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GCD"><span class="nav-text">GCD</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFGCD%EF%BC%9F"><span class="nav-text">什么是GCD？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCD%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-text">GCD的优点?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NSOperation"><span class="nav-text">NSOperation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NSOperation%E4%BB%8B%E7%BB%8D"><span class="nav-text">NSOperation介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-NSOperation%EF%BC%9F"><span class="nav-text">为什么要使用 NSOperation？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSOperation%E3%80%81NSOperationQueue-%E6%93%8D%E4%BD%9C%E5%92%8C%E6%93%8D%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-text">NSOperation、NSOperationQueue 操作和操作队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSOperation%E3%80%81NSOperationQueue-%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D"><span class="nav-text">NSOperation、NSOperationQueue 使用介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSOperation%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-text">NSOperation的基本使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSOperationQueue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-text">NSOperationQueue的基本使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSOperation%E3%80%81NSOperationQueue-%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-text">NSOperation、NSOperationQueue 线程间的通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSOperation%E3%80%81NSOperationQueue-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">NSOperation、NSOperationQueue 线程同步和线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSOperation%E3%80%81NSOperationQueue-%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E5%BD%92%E7%BA%B3"><span class="nav-text">NSOperation、NSOperationQueue 常用属性和方法归纳</span></a></li></ol></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2019</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">张建</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        VISITOR COUNT&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        TOTAL PAGE VIEWS&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a></span>
                <br> 
            <span class="theme-version-container">THEME&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v1.1.5</a>
        </div>
        
        
        
            <div id="start_time_div" style="display:none">
                2019/8/17 11:45:14
            </div>
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="unfolded-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="fa-regular fa-arrow-up"></i>
            </li>
        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="folded-tools-list">
        <li class="right-bottom-tools tool-toggle-show flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>




<script src="/BboyZJ.github.io/js/utils.js"></script>

<script src="/BboyZJ.github.io/js/main.js"></script>

<script src="/BboyZJ.github.io/js/layouts/menu-shrink.js"></script>

<script src="/BboyZJ.github.io/js/tools/go-top-bottom.js"></script>

<script src="/BboyZJ.github.io/js/tools/dark-light-toggle.js"></script>



    
<script src="/BboyZJ.github.io/js/tools/local-search.js"></script>




    
<script src="/BboyZJ.github.io/js/tools/code-block.js"></script>




    
<script src="/BboyZJ.github.io/js/layouts/lazyload.js"></script>




    
<script src="/BboyZJ.github.io/js/tools/runtime.js"></script>

    
<script src="/BboyZJ.github.io/js/layouts/odometer.min.js"></script>

    
<link rel="stylesheet" href="/BboyZJ.github.io/assets/odometer-theme-minimal.css">





<div class="post-scripts pjax">
    
        
<script src="/BboyZJ.github.io/js/tools/toc-toggle.js"></script>

<script src="/BboyZJ.github.io/js/libs/anime.min.js"></script>

<script src="/BboyZJ.github.io/js/layouts/toc.js"></script>

<script src="/BboyZJ.github.io/js/plugins/tabs.js"></script>

    
    
</div>


    
<script src="/BboyZJ.github.io/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>




<script src="/BboyZJ.github.io/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
