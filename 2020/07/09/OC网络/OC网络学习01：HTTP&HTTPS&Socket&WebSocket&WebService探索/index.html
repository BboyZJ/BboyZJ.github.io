<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="我是小J，关注我">
    <meta name="author" content="张建">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://www.bboyzj.cn/2020/07/09/oc网络/oc网络学习01：http&https&socket&websocket&webservice探索/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    <meta property="og:type" content="article">
    <meta property="og:title" content="OC网络学习01：TCP/UDP/HTTP/HTTPS/Socket/WebSocket/WebService探索">
    <meta property="og:description" content="我是小J，关注我">
    <meta property="og:url" content="https://www.bboyzj.cn2020/07/09/OC网络/OC网络学习01：HTTP&amp;HTTPS&amp;Socket&amp;WebSocket&amp;WebService探索/">
    <meta property="og:image" content="/images/redefine-logo.svg">
    <meta property="og:site_name" content="BboyZJ">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="OC网络学习01：TCP/UDP/HTTP/HTTPS/Socket/WebSocket/WebService探索">
    <meta name="twitter:description" content="我是小J，关注我">
    <meta name="twitter:image" content="/images/redefine-logo.svg">
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/BboyZJ.github.io/images/redefine-logo.svg">
    
    <title>
        
            OC网络学习01：TCP/UDP/HTTP/HTTPS/Socket/WebSocket/WebService探索 -
        
        BboyZJ
    </title>
    
<link rel="stylesheet" href="/BboyZJ.github.io/css/style.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/assets/fonts.css">

    
    
    
    
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"www.bboyzj.cn","root":"/BboyZJ.github.io/","language":"en","path":"search.xml"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/head_img.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"学无止境 学而不思则罔 思而不学则殆","custom_font":{"enable":false,"font_family":null,"font_url":null}},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_block":{"copy":true,"style":"mac","custom_font":{"enable":false,"font_family":null,"font_url":null}},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"1.1.5","friend_links":{"columns":2},"home_article":{"date_format":"auto","category":{"enable":true,"limit":3},"tag":{"enable":true,"limit":3}},"plugins":{"aplayer":{"enable":false,"audio":[{"name":null,"artist":null,"url":null,"cover":null},{"name":null,"artist":null,"url":null,"cover":null}]}}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/BboyZJ.github.io/fontawesome/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/BboyZJ.github.io/atom.xml" title="张建的博客" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="menu-wrapper">
    
    <div class="menu-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                BboyZJ
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        首页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/tags/"  >
                                    
                                        
                                            <i class="fa-regular fa-tags"></i>
                                        
                                        标签
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/BboyZJ.github.io/categories/"  >
                                    
                                        
                                            <i class="fa-regular fa-categories"></i>
                                        
                                        分类
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="menu-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                首页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/tags/"  >
                             
                                
                                    <i class="fa-regular fa-tags"></i>
                                
                                标签
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/BboyZJ.github.io/categories/"  >
                             
                                
                                    <i class="fa-regular fa-categories"></i>
                                
                                分类
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">OC网络学习01：TCP/UDP/HTTP/HTTPS/Socket/WebSocket/WebService探索</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/BboyZJ.github.io/images/head_img.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">张建</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2020-07-09 13:07:02</span>
        <span class="mobile">2020-07-09 13:07</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="pc">2023-07-28 10:49:22</span>
            <span class="mobile">2023-07-28 10:49</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/BboyZJ.github.io/categories/OC/">OC</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/BboyZJ.github.io/tags/OC-%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/">OC-网络学习</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h1><p>网络协议从低到高：</p>
<ul>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层（IP）</li>
<li>传输层（TCP&#x2F;UDP）</li>
<li>会话层（SSL&#x2F;TLS）</li>
<li>表示层</li>
<li>应用层（HTTP&#x2F;DNS&#x2F;WebSocket）</li>
</ul>
<p><strong>问：那么SSL和TLS在哪一层呢？</strong></p>
<p>答：SSL&#x2F;TLS作用于应用层和传输层之间，如果硬要说在哪个位置，那就是：会话层</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303260952378.png"
                     
                ></p>
<h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><ol>
<li><p><code>URL</code> 全称是 <code>Uniform Resource Locator</code>(统一资源定位符)，通过一个URL能找到 <code>互联网唯一一个资源</code>，URL就是资源的地址、位置，互联网上的每个资源都有一个唯一的URL</p>
</li>
<li><p>URL基本格式 &#x3D; 协议:&#x2F;&#x2F;主机地址:端口号&#x2F;路径</p>
</li>
</ol>
<p>例如： <a class="link"   target="_blank" rel="noopener" href="http://www.bboyzj.top/2020" >http://www.bboyzj.top:80/2020 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ul>
<li>协议：不同协议，代表着不通的资源查找路径、传输路径</li>
<li>主机地址：存放资源的主机（服务器）的IP地址（域名）</li>
<li>端口：跟在域名后面的是端口，默认是省略的</li>
<li>路径：资源在主机（服务器）中的具体位置</li>
</ul>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>把MAC帧变成二进制比特流，并转换为电信号，在物理链路传输</p>
<h1 id="数据链路层（MAC）"><a href="#数据链路层（MAC）" class="headerlink" title="数据链路层（MAC）"></a>数据链路层（MAC）</h1><ul>
<li><p>MAC帧是数据帧的一种。而所谓 <code>数据帧</code>，就是数据链路层的协议数据单元，它包括三部分：<code>帧头，数据部分，帧尾</code>。其中，帧头和帧尾包含一些必要的控制信息，比如同步信息、地址信息、差错控制信息等；数据部分则包含网络层传下来的数据，比如 <code>ip数据包</code>。</p>
</li>
<li><p>在 <code>发送端</code>，数据链路层把网络层传下来得 <code>数据封装成帧</code>，然后发送到链路上去；在 <code>接收端</code>，数据链路层把收到的帧中的数据取出并交给网络层。不同的数据链路层协议对应着不同的帧，所以，帧有多种，比如PPP帧、MAC帧等，其具体格式也不尽相同。</p>
</li>
</ul>
<h1 id="IP（网络层协议）"><a href="#IP（网络层协议）" class="headerlink" title="IP（网络层协议）"></a>IP（网络层协议）</h1><ul>
<li><code>IP</code> 是 <code>网络层协议</code>。比作：高速公路</li>
</ul>
<p>网络传输需要解决的主要问题有两个： 发给谁 和 通过怎么样的路线才能发给他（也就是路由）。</p>
<ol>
<li>IP的作用</li>
</ol>
<p>我们先来看一下TCP&#x2F;IP封装的数据包结构：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307280955413.png"
                     
                ></p>
<p>当我们 <code>发送数据</code> 时，按照 <code>应用层 —&gt;数据链路层自上而下封装数据包</code>。<br>当我们 <code>接收数据</code> 时，按照 <code>数据链路层 —&gt;应用层 进行拆包</code>。</p>
<p>每个 <code>网卡</code> 在出厂时就会有一个 <code>全世界唯一的MAC地址</code>，就相当于是我们每个人在世界上都是唯一的。那MAC地址其实就能解决第一个 <code>发给谁</code> 的问题。那为啥还需要IP层呢？</p>
<p>想象你到世界上找一个叫 Monica 的人，你不可能大街上随便逮到一个人就问你认识 Monica 吗.. 你应该先搞清楚 Monica 住址是在哪个国家哪个城市哪个区哪个街道，从国家-&gt;城市-&gt;区-&gt;小区一步步定位，这么找人就符合常理了。。<code>IP解决的就是网络上数据包的路由定位困难问题</code>。</p>
<ol start="2">
<li>IP的定义</li>
</ol>
<p><code>IP</code> 怎么表达出 <code>国家城市区</code> 的概念呢，这就是IP地址定义的事了。</p>
<p><code>IP 地址</code> 用 <code>32位</code> 来表示，通常被分割为 <code>4个8位</code>。以 <code>点分十进制</code> 表示成 <code>[a.b.c.d]</code> 的形式。同时这32bit又被划分为 <code>网络号和主机号</code> 组成。比如 <code>10.100.122.2/24</code> 这个IP： <code>10.100.122.2</code> 是 <code>点分十进制</code> 表示形式，<code>/24</code> 表示的是 <code>前24位是网络号，后8位是主机号</code>。这个网络号其实充当的就是 国家城市区 的概念。比如我们只需要记住怎么去往 <code>10.100.122.x</code>，就知道怎么去找 10.100.122.1&#x2F;24 和 10.100.122.2&#x2F;24 了。为了方便获取网络号 ，又出现一个 <code>子网掩码</code> 的概念。<code>子网掩码就是网络号位上全为1，主机号全为0的IP地址</code>。这样当 <code>IP&amp;子网掩码</code> 得到的就是 <code>IP的网络号</code>。所以 10.100.122.2&#x2F;24 的子网掩码就是 255.255.255.0。</p>
<p>即：<br>子网掩码 &#x3D; 网络号全是1，主机号全是0<br>IP网络号 &#x3D; IP地址 &amp; 子网掩码</p>
<p>好了，我们来看一下IPv4对IP地址的划分：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307281001267.png"
                     
                ></p>
<p>其中A&#x2F;B&#x2F;C类可用于表示公网IP。D类用于多播组号，使用这一类地址，属于某个组（相同网络号的）的机器都能收到，E类还留待使用。但是我们并不用记住公网IP是属于A&#x2F;B&#x2F;C类中哪一类，我们只需要 <code>用/24或/16</code> 这样的CIDR方式去 <code>区分IP的网络号和主机号就可以</code>。</p>
<p>实际上，A&#x2F;B&#x2F;C类划分的IP显然是不够用每个地球人用的，我们日常在接入公网时，都需要走能有 <code>公网IP的网关</code>。在整个公网内部，<code>再分配私有IP地址</code> 给每个人上网使用就可以了。比如家庭常用的192.168.0.x&#x2F;24 私有IP网段。</p>
<p>此外，在这五类IP地址基础上还划分出了特殊的IP网段。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307281003224.png"
                     
                ></p>
<ol start="3">
<li>IP路由</li>
</ol>
<p>IP的目的就是将路由简单化，IP的网络号承担了 <code>一组IP 的路由</code> 出入口的作用。实际上 <code>网关</code> 就是这个出入口。不同局域网（IP网络号不同）的网络通信必须经过网关，相同局域网的网络通信可以靠广播和MAC地址来送达目标机器。</p>
<p>假使我们从 <code>203.16.20.5/24 —&gt; 203.16.24.4/24</code> 发一个包，其中源IP和目标IP都是公网IP。那包的路由过程如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307281006958.png"
                     
                ></p>
<p>源机器网络程序在封装数据包的过程中发现目标机器和自己的IP不在同一局域网内，则需要通过 <code>网关</code> 将包从 <code>网卡</code> 发出去。<code>1处</code> 的数据包结构为：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307281007948.png"
                     
                ></p>
<p>到了网关1，拆包发现目标IP地址是 203.16.24.4&#x2F;24。查了下自己的路由表，发现要想访问 203.16.24.4&#x2F;24，要从 203.16.22.2&#x2F;24 这个口出去，下一跳为 203.16.22.4&#x2F;24。此时2处的数据包结构为:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307281008251.png"
                     
                ></p>
<p>到了网关2，拆包发现目标IP地址是 203.16.24.4&#x2F;24。查了下自己的路由表，发现要想访问 203.16.24.4&#x2F;24，要从 203.16.24.1&#x2F;24 这个口出去。此时3处的数据包结构为:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307281008687.png"
                     
                ></p>
<p>到了目标机器，拆包发现目标IP地址就是自己呀，所以进行更上层的拆包，把数据收进来就可以了。</p>
<p>我们可以发现这种方式的 <code>路由每经过一次局域网，MAC地址需要改变</code>，但IP地址不需要改变。这种 <code>网关称为转发网关</code>。而实际上还存在一种改变 IP 地址的网关，称为 <code>NAT 网关</code>。我们就不展开了，小伙伴可以自行搜索。</p>
<p>现在我们知道 <code>IP/MAC地址/网关</code> 等怎么解决上述两个 <code>发给谁</code> 和 <code>通过怎么样的路线才能发给目标机器</code> 的问题了</p>
<h1 id="TCP-amp-UDP（传输层协议）"><a href="#TCP-amp-UDP（传输层协议）" class="headerlink" title="TCP &amp; UDP（传输层协议）"></a>TCP &amp; UDP（传输层协议）</h1><p><code>TCP</code> 和 <code>UDP</code> 是 <code>传输层的协议</code>，比作：卡车。</p>
<h2 id="TCP（传输控制协议，Transmission-Control-Protocol）"><a href="#TCP（传输控制协议，Transmission-Control-Protocol）" class="headerlink" title="TCP（传输控制协议，Transmission Control Protocol）"></a>TCP（<code>传输控制协议</code>，Transmission Control Protocol）</h2><p><code>TCP</code> 是 <code>面向连接的、可靠的、基于字节流的传输层控制协议，需要建立连接和断开连接，即三次握手和四次挥手</code>，<code>TCP</code> 提供 <code>超时重发、丢弃重复数据、检验数据、流量控制</code> 等功能</p>
<ol>
<li>TCP三次握手过程</li>
</ol>
<ul>
<li><p>为什么是三次握手，而不是二次握手？（三次握手是为了建立一个 <code>可靠的数据传输通道</code>）</p>
<ul>
<li><p>刚开始 <code>客户端</code> 处于关闭状态，而且 <code>服务端</code> 一直处于监听状态，时刻监听是否有建立连接的请求</p>
</li>
<li><p>当客户端需要建立连接的时候就会发送一个 <code>请求连接</code> 的报文，此报文是 <code>同步报文SYN=1</code>，并且会生成一个 <code>随机的序号seq=x</code>，这是 <code>第一次握手</code></p>
</li>
<li><p>当服务端接收到请求连接报文时，会发送一个 <code>确认连接</code> 的报文，此报文是 <code>同步报文SYN=1</code>，并且 <code>确认报文ACK=1</code>，同时服务端也会生成一个 <code>随机的序号seq=y</code>，并且将 <code>确认报文确认号ack=x+1</code>，回传给客户端，这是 <code>第二次握手</code></p>
</li>
<li><p>当客户端接收到服务端的 <code>ACK确认报文后</code>，会回复一个 <code>ACK确认报文</code>，用于确认确认报文已经收到，此报文 <code>ACK=1，seq=x+1，ack=y+1</code>，这是 <code>第三次握手</code></p>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>四次挥手</li>
</ol>
<ul>
<li><p><code>四次挥手则是为了保证数据传输完成接收再关闭连接</code></p>
<ul>
<li><p>客户端断开连接时会发送一个 <code>请求断开连接</code> 的报文，此报文是 <code>FIN=1</code>，并且会生成一个 <code>随机的序号seq=u</code>，发送给服务端，这是 <code>第一次挥手</code></p>
</li>
<li><p>服务端接收到请求断开连接 <code>FIN报文</code> 后，回复一个 <code>确认断开连接</code> 报文 <code>ACK=1,seq=v,ack=u+1</code>，这是 <code>第二次挥手</code></p>
</li>
<li><p>当 <code>服务端数据发送完后</code>，再发送一个 <code>准备关闭连接</code> 的 <code>FIN</code> 报文给客户端，通知客户端，服务端准备关闭连接，此报文 <code>FIN=1,ACK=1,ack=u+1,seq=w</code>，这是 <code>第三次挥手</code></p>
</li>
<li><p>当客户端收到准备关闭连接 <code>FIN报文</code>，再发送一个关闭连接 <code>FIN</code> 报文 <code>ACK=1,seq=u+1,ack=w+1</code>，并进入<code> TIME-WAIT</code> 等待，等待 <code>2MSL</code> 后关闭连接，这是 <code>第四次挥手</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="UDP-用户数据报协议，User-Data-Protocol"><a href="#UDP-用户数据报协议，User-Data-Protocol" class="headerlink" title="UDP(用户数据报协议，User Data Protocol)"></a>UDP(用户数据报协议，User Data Protocol)</h2><p><code>UDP</code> 是 <code>面向非连接的、不可靠的传输层协议</code>，不需要建立连接，没有超时重发等功能</p>
<h2 id="TCP-和-UDP-的区别-重点面试题"><a href="#TCP-和-UDP-的区别-重点面试题" class="headerlink" title="TCP 和 UDP 的区别 重点面试题"></a>TCP 和 UDP 的区别 <strong>重点面试题</strong></h2><ul>
<li><p>TCP 需要建立连接和断开连接。UDP 不需要</p>
</li>
<li><p>TCP 数据传输慢。UDP 数据传输快</p>
</li>
<li><p>TCP 传输可靠。UDP 传输不可靠</p>
</li>
<li><p>TCP 传输有序。UDP 传输无序</p>
</li>
<li><p>TCP 基于字节流。UDP 基于数据报</p>
</li>
<li><p>TCP 有超时重发等功能。UDP 没有超时重发等功能</p>
</li>
</ul>
<h1 id="HTTP（应用层协议）"><a href="#HTTP（应用层协议）" class="headerlink" title="HTTP（应用层协议）"></a>HTTP（应用层协议）</h1><ol>
<li>HTTP是什么？</li>
</ol>
<ul>
<li><p>HTTP的全称是 <code>Hypertext Transfer Protocol</code>，<code>超文本传输协议</code>，是互联网上应用最广泛的一种网络协议。<code>应用层的协议</code>，比作：货物</p>
</li>
<li><p>是建立在 <code>TCP</code> 协议之上的一种应用。最显著的特点是 <code>客户端发送的每次请求都需要服务端响应</code>。</p>
</li>
<li><p>端口号 80</p>
</li>
</ul>
<ol start="2">
<li>作用:</li>
</ol>
<ul>
<li>规定客户端和服务端的数据传输格式</li>
<li>让客户端和服务器进行有效的数据沟通</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303260908423.png"
                     
                ></p>
<ol start="3">
<li>为什么选HTTP？</li>
</ol>
<ul>
<li><code>简单快速</code>：因为HTTP协议简单，所有的HTTP服务器的程序规模小，因而通信速度很快</li>
<li><code>灵活</code>：HTTP允许传输任意类型的数据</li>
<li><code>持续链接</code>：限制每次链接只处理一个请求，服务器对客户端的请求作出响应后，马上断开链接，这种方式可以节省传输时间</li>
</ul>
<ol start="4">
<li>通信过程</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303260908409.png"
                     
                ></p>
<ol>
<li>请求：客户端向服务器索要数据</li>
</ol>
<ul>
<li>请求行：包含了 <code>请求方法，请求资源路径，HTTP协议版本</code></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET // 请求方法</span><br><span class="line">/MJServer/resources/images/1.jpg // 请求资源路径</span><br><span class="line">HTTP/1.1 // HTTP协议版本</span><br></pre></td></tr></table></figure></div>

<ul>
<li>请求头：包含了对 <code>客户端的描述</code>，客服端请求的主机地址等信息</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host:192.168.1.105:80 // 客户端想访问的服务器 主机地址/域名/端口号</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9) Firefox/30.0// 客户端的类型，客户端的软件环境 </span><br><span class="line">Accept: text/html, // 客户端所能接收的数据类型 </span><br><span class="line">Accept-Language: zh-cn // 客户端的语言环境 </span><br><span class="line">Accept-Encoding: gzip // 客户端支持的数据压缩格式 </span><br></pre></td></tr></table></figure></div>

<ul>
<li>请求体：客户端发给服务器的 <code>具体数据</code>，比如文件数据</li>
</ul>
<ol start="2">
<li>响应：服务器返回客户端响应的数据</li>
</ol>
<ul>
<li>状态行：包含了 <code>HTTP协议版本，状态码，状态英文名称</code>：</li>
</ul>
<p><code>HTTP/1.1 200 OK</code></p>
<p>常用的响应状态码：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202303260909798.png"
                     
                ></p>
<ul>
<li>响应头：包含了对 <code>服务器的描述</code>，对返回数据的描述</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Server: Apache-Coyote/1.1 // 服务器的类型 </span><br><span class="line">Content-Type: image/jpeg // 返回数据的类型 </span><br><span class="line">Content-Length: 56811 // 返回数据的长度 </span><br><span class="line">Date: Mon, 23 Jun 2014 12:54:52 GMT // 响应的时间 </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<ul>
<li>实体内容：服务器返回给客户端的 <code>具体数据</code>，比如文件数据</li>
</ul>
<ol start="5">
<li>发送请求的方法：</li>
</ol>
<ul>
<li>简单说明 : 在HTTP&#x2F;1.1协议中，定义了8种发送http请求的方法</li>
</ul>
<p>Get,Post,Put,Delete,Patch,Trace,Connect,Options,Head</p>
<ul>
<li><p>get和post请求 ，要想使用Get和Post请求跟服务器进行交互，得先了解一个概念:参数就是传递给服务器的具体数据，比如登录时的账号，密码 ，Get和Post对比: </p>
<ul>
<li>Get ：在请求URL后面以 <code>?</code> 的形式跟上发给服务器的参数，多个参数之间用 <code>&amp;</code> 隔开。 注意:由于客户端和服务器对URL长度有限，因此在URL后面附带的 <code>参数是有限制</code> 的，通常不能超过1KB </li>
<li>Post ：发给服务器的 <code>参数全部放在请求体</code> 中，理论上，Post传递的 <code>参数没有限制</code>(具体还得看服务器的处理能力)</li>
</ul>
</li>
<li><p>Get和Post的选择的建议 </p>
<ul>
<li>如果要传递大量数据，比如文件上传，只能用Post请求 </li>
<li>Get的安全性比Post要差些，如果包含机密&#x2F;敏感信息，建议用Post </li>
<li>如果仅仅要索取数据(数据查询)，建议使用Get </li>
<li>如果是增加，修改，删除数据，建议使用Post</li>
</ul>
</li>
</ul>
<ol start="6">
<li>HTTP版本历史</li>
</ol>
<p>6.1 HTTP&#x2F;1.0</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305082151590.png"
                     
                ></p>
<ul>
<li><p>默认是：<code>短连接</code>，一次请求-响应，建立一次连接，用完了关闭，每次请求都需要建立一次TCP连接，<code>网络利用率低</code></p>
</li>
<li><p>长连接：想要 <code>建立长连接</code>，则使用 <code>keep-alive</code> 参数，建立一个连接，所有请求串行起来，客户端收到前一个请求的服务端响应后，后一个请求才能发出（可能造成 <code>对头阻塞head of line blocking</code>）</p>
</li>
<li><p>HTTP1.0 <code>不支持断点续传功能</code>，每次都会传送全部的页面和数据。如果只需要部分数据就会浪费多余带宽</p>
</li>
</ul>
<p>6.2 HTTP&#x2F;1.1 </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305082155003.png"
                     
                ></p>
<ul>
<li><p>默认是：<code>长连接，一个连接处理多个请求</code>。为了解决早期 <code>HTTP/1.0</code> 每次都要建立连接导致 <code>通信效率低</code> 的性能问题，因为 <code>HTTP/1.1</code> 基于 <code>TCP/IP</code> 协议，为了解决上述 <code>TCP</code> 连接问题，<code>HTTP/1.1</code> 提出了 <code>长连接</code> 的通信方式，也叫 <code>持久连接</code>。这种方式的好处在于减少了 <code>TCP</code> 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>
</li>
<li><p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 <code>TCP</code> 连接状态。如果某个 <code>HTTP</code> 长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。</p>
</li>
</ul>
<p><strong>管道传输</strong></p>
<ul>
<li><p>因为 <code>HTTP/1.1</code> 采用了 <code>长连接</code> 的方式，这使得 <code>管道（Pipelining）</code> 网络传输成为了可能。</p>
</li>
<li><p>管道（Pipelining）：即可在同一个 <code>TCP</code> 连接里面，<code>客户端可以发起多个请求</code>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是 <code>服务器必须按照接收请求的顺序发送对这些管道化请求的响应。</code></p>
</li>
<li><p>如果服务端在处理 <code>A</code> 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为 <code>对头阻塞（head of line blocking）</code>。</p>
</li>
</ul>
<p><strong>什么是对头阻塞</strong></p>
<ul>
<li><p>对头阻塞（head of line blocking），由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。</p>
</li>
<li><p>HTTP&#x2F;1.1 管道解决了 <code>请求</code> 的队头阻塞，但是没有解决 <code>响应</code> 的队头阻塞。</p>
</li>
</ul>
<p><strong>keep-alive 怎么断开连接？</strong></p>
<ul>
<li><p>通过在服务器配置文件中设置 <code>Keep-Alive超时时间</code>  来完成（<code>超时，则服务器自动关闭连接</code>）</p>
</li>
<li><p>你可以发送一个HTTP请求头部中包含 <code>“Connection:close”</code> 的请求（这将告诉服务器，在发送响应之后关闭连接，而不是保持链接打开以等待其他请求）</p>
</li>
</ul>
<p><strong>HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 区别</strong> </p>
<ul>
<li><p><code>HTTP/1.0</code> 发完一个请求后立马结束tcp链接，接着在发起第二个，属于一种 <code>串行短连接</code> 的方式</p>
</li>
<li><p><code>HTTP/1.1</code> 可以只用一个 <code>tcp长链接发起请求</code>，这样可以较少tcp链接的开销，同时也可以 <code>开启管道机制</code>，<code>并行的发送多个请求，但必须要按顺序返回</code>。</p>
</li>
<li><p><code>HTTP/1.1</code> 有 <code>keep-Alive</code> 功能，即 <code>长链接</code></p>
</li>
<li><p><code>HTTP/1.1</code> 有 <code>管道机制(pipeline)</code>，即 <code>并行发起请求</code></p>
</li>
</ul>
<p>6.2 HTTP&#x2F;2.0 </p>
<p><code>HTTP/2.0</code> 协议是基于 <code>HTTPS</code> 的，更加安全，<code>HTTP/2.0</code> 增加如下几点的重大优化：</p>
<p><strong>头部压缩</strong></p>
<ul>
<li><p><code>HTTP2.0</code> 会压缩 <code>Header</code> 部分；如果同时多个请求其头部一样或相似，那么协议会消除重复部分。</p>
</li>
<li><p>利用 <code>HPAK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，就不用重复发送同样字段了，只发送索引号，减少数据量提高速度</p>
</li>
</ul>
<p><strong>二进制分帧</strong></p>
<ul>
<li><p><code>HTTP/1.0</code> 和 <code>HTTP/1.1</code> 中，报文都是 <code>纯文本的格式</code> 简单易读；而在 <code>HTTP/2.0</code> 中采用了 <code>二进制的格式</code> 报头和数据体 称为：<code>帧（frame）-&gt; 头信息帧（Headers Frame）和数据帧（Data Frame）</code></p>
</li>
<li><p>数据以 <code>数据流（stream）</code> 的形式以 <code>字节</code> 单位发送，数据包可以不按顺序发送</p>
</li>
<li><p>在 <code>HTTP/2.0</code> 中每个 <code>请求或响应</code> 的所有数据包，称为一个 <code>数据流（Stream）</code>。每个数据流都标记着一个独一无二的 <code>编号（Stream ID）</code>；</p>
</li>
<li><p>所有 <code>HTTP2.0</code> 通信都在一个 <code>TCP</code> 链接上完成，这个链接可以承载任意流量的 <code>双向数据流</code>。每个数据流以 <code>消息</code> 的形式发送，而消息由 <code>一或多个帧</code> 组成。不同 <code>Stream</code> 的帧是可以乱序发送的（因此可以并发不同的 <code>Stream</code> ），因为每个帧的头部会携带 <code>Stream ID</code> 信息，所以接收端可以通过 <code>Stream ID</code> 有序组装成 <code>HTTP</code> 消息</p>
</li>
<li><p>客户端还可以 <code>指定数据流的优先级</code>。优先级高的请求，服务器就先响应该请求</p>
</li>
</ul>
<p><strong>多路复用</strong></p>
<ul>
<li><p><code>HTTP2.0</code> 实现了真正的 <code>并行传输</code>，它能够在一个 <code>TCP</code> 上进行任意数量的HTTP请求，由于其 <code>二进制分帧</code> 特性</p>
</li>
<li><p><code>HTTP/2.0</code> 是可以在一个连接中 <code>并发多个请求或回应</code>，而不用按照顺序一一对应。</p>
</li>
<li><p><code>移除</code> 了 <code>HTTP/1.1</code> 中的 <code>串行请求</code>，不需要排队等待，<code>彻底解决队头阻塞问题</code>，降低了延迟，大幅度提高了连接的利用率。</p>
</li>
</ul>
<p><strong>服务端推送</strong></p>
<ul>
<li><code>HTTP/2.0</code> 还在一定程度上改善了传统的 <code>请求 - 应答</code> 工作模式，服务端不再是被动地响应，可以主动向客户端发送消息、推送额外的资源。</li>
</ul>
<p><strong>TCP导致队头阻塞</strong></p>
<ul>
<li><p>因为 <code>TCP</code> 面向 <code>字节流</code> 传输，而且保证传输可靠性和数据的完整性</p>
</li>
<li><p>只有 <code>TCP</code> 拿到完整连续的数据时，内核才会将数据从缓冲区交给 <code>HTTP</code> 应用，而只要前一个字节没有收到，HTTP就无法从内核缓冲区中得到数据，直到其到达，所以在此过程仍然 <code>会导致队头阻塞</code></p>
</li>
</ul>
<p><strong>HTTP&#x2F;1.0和HTTP&#x2F;2.0的区别？</strong></p>
<p><code>HTTP/2.0</code> 传输效率上大大提升，主要得益于 <code>采用二进制分帧</code> 的方式，可以真正做到 <code>多路复用</code>，并且 <code>可以对首部进行压缩和使用字典较少传输的字符数</code>。</p>
<ul>
<li><p><code>多路复用</code>，真正做到一个 <code>tcp</code> 链接可以 <code>并行</code> 的发送请求，相对 <code>HTTP/1.1</code> 的长链接和管道机制优化返回必须按顺序的缺点</p>
</li>
<li><p>二进制分帧</p>
</li>
<li><p>首部压缩</p>
</li>
<li><p>服务器推送</p>
</li>
<li><p>请求优先级控制</p>
</li>
</ul>
<p>6.3 HTTP&#x2F;3.0 </p>
<ul>
<li><p>为了解决 <code>HTTP/2.0</code> 中 <code>TCP</code> 造成的 <code>队头阻塞问题</code>，<code>HTTP/3.0</code> 直接放弃使用 <code>TCP</code>，将传输层协议改成 <code>UDP</code>；但是因为 <code>UDP</code> 是不可靠传输，所以这就需要 <code>QUIC</code> 实现可靠机制</p>
</li>
<li><p><code>QUIC</code> 也是需要 <code>三次握手</code> 来建立连接的，主要目的是为了确定 <code>连接 ID</code>。</p>
</li>
</ul>
<p><strong>无队头阻塞</strong></p>
<ul>
<li><p><code>QUIC</code> 协议也有类似 <code>HTTP/2.0 Stream</code> 与 <code>多路复用</code> 的概念，也是 <code>可以在同一条连接上并发传输</code> 多个 <code>Stream</code>，<code>Stream</code> 可以认为就是一条 <code>HTTP</code> 请求。</p>
</li>
<li><p><code>QUIC</code> 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。这与 <code>HTTP/2.0</code> 不同，<code>HTTP/2.0</code> 只要某个流中的数据包丢失了，其他流也会因此受影响。</p>
</li>
<li><p>所以，<code>QUIC</code> 连接上的多个 <code>Stream</code> 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p>
</li>
</ul>
<p><strong>连接建立</strong></p>
<ul>
<li><code>HTTP/3.0</code> 在传输数据前虽然需要 <code>QUIC</code> 协议握手，这个握手过程只需要 <code>1 RTT</code>，握手的目的是为确认双方的 <code>连接 ID</code>，<code>连接迁移</code> 就是基于 <code>连接 ID</code> 实现的。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202305082224830.png"
                     
                ></p>
<p><strong>连接迁移</strong></p>
<ul>
<li><p>基于 <code>TCP</code> 传输协议的 <code>HTTP</code> 协议，由于是通过 <code>四元组（源 IP、源端口、目的 IP、目的端口）</code> 确定一条 <code>TCP</code> 连接，例如设备要连接wifi（IP地址改变）就必须要重新建立连接，而建立连接包含 <code>TCP三次握手和TSL四次握手</code>，以及TCP慢启动所以会造成使用者卡顿的感觉</p>
</li>
<li><p>而 <code>QUIC</code> 通过 <code>连接ID</code> 标记自己，客户端和服务器可以各自选择一组 <code>ID</code> 来标记自己，因此即使移动设备的网络变化后，导致 <code>IP</code> 地址变化了，只要有上下文信息（比如 <code>连接 ID</code>、<code>TLS 密钥</code> 等），就可以 <code>无缝</code> 地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了 <code>连接迁移</code>  的功能。</p>
</li>
<li><p>其实，<code>QUIC</code> 是一个在 <code>UDP</code> 之上的伪 <code>TCP + TLS + HTTP/2.0</code> 的多路复用的协议。</p>
</li>
</ul>
<p><strong>HTTP&#x2F;2.0和HTTP&#x2F;3.0的区别</strong></p>
<p><code>HTTP/2.0</code> 效率已经很高了，但还是存在三个问题，其一是 <code>tcp</code> 和 <code>ssl</code> 链接太费时间，其二是 <code>tcp</code> 有 <code>队头阻塞</code> 的问题，其三是 <code>网路切换</code> 问题。<code>HTTP/3.0</code> 就是为了解决上面这些问题而产生的。</p>
<ul>
<li>采用 <code>udp</code> 协议，提高握手效率</li>
<li><code>0或1 RTT 建立链接</code>，<code>QUIC</code> 协议包含了 <code>TLS1.3</code> 不再分层，可以进一步优化握手过程，首次链接只需要 <code>1RTT</code>，而非首次链接更能做到 <code>0RTT</code> 建立链接，主要是把应用数据和秘钥协商的过程进行了统一</li>
<li>可以 <code>无缝迁移网路</code>，使用 <code>链接ID</code> 来标识，与ip无关</li>
</ul>
<h1 id="HTTPS（应用层协议）"><a href="#HTTPS（应用层协议）" class="headerlink" title="HTTPS（应用层协议）"></a>HTTPS（应用层协议）</h1><ol>
<li>HTTPS 是什么？</li>
</ol>
<ul>
<li><p>HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer）<code>超文本传输安全协议</code>。</p>
</li>
<li><p>是应用层的协议，在 <code>HTTP</code> 基础上引入一个 <code>加密层</code>，使用 <code>SSL/TLS</code> 加密数据包</p>
</li>
<li><p>保护数据的隐私和完整性</p>
</li>
<li><p>默认是建立在 <code>TCP</code> 协议之上的一种应用</p>
</li>
<li><p>端口号 <code>443</code></p>
</li>
</ul>
<ol start="2">
<li>组成：HTTPS协议 &#x3D; HTTP协议 + SSL&#x2F;TLS协议</li>
</ol>
<ul>
<li><p>SSL：全称是 Secure Sockets Layer，即 <code>安全套接层协议</code></p>
</li>
<li><p>TLS：全称 Transport Layer Security，即 <code>安全传输层协议</code></p>
</li>
</ul>
<ol start="3">
<li>加密是什么？</li>
</ol>
<ul>
<li><p>加密相关术语：</p>
<ul>
<li>明文：传输的原始数据</li>
<li>密文：通过一定的规则将明文变换后的数据</li>
<li>加密：将明文变成密文</li>
<li>解密：将密文变成明文</li>
<li>密钥：在加密和解密的过程中，往往需要一个或多个中间的数据来辅助该过程，这样的数据称为密钥</li>
</ul>
</li>
<li><p>为什么需要 HTTPS，为什么需要加密？</p>
<ul>
<li>防止传输的数据被 <code>运营商/黑客等</code> 篡改。</li>
<li><code>HTTPS</code> 密文传输保证了用户信息的安全。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>加密方式</li>
</ol>
<p>为了保证数据的安全，就需要进行 <code>加密</code>，即网络传输中不再使用 <code>明文</code>，而是 <code>加密</code> 后的 <code>密文</code>。加密的方式有很多种，整体分为两大类：<code>对称加密</code> 和 <code>非对称加密</code></p>
<ul>
<li><p>对称加密：<code>加密和解密</code> 都会用到 <code>同一个密钥</code>。常见的 <code>对称加密算法</code> 有 <code>DES、AES、3DES、Blowfish、IDEA、RC5、RC6</code>。</p>
</li>
<li><p>非对称加密：使用 <code>一对非对称的密钥</code>，一把叫做 <code>私有密钥</code>，另一把叫做 <code>公有密钥</code>；公钥加密只能用私钥来解密，私钥加密只能用公钥来解密。常见的有：<code>RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法</code>。</p>
</li>
</ul>
<h2 id="HTTPS-工作过程："><a href="#HTTPS-工作过程：" class="headerlink" title="HTTPS 工作过程："></a>HTTPS 工作过程：</h2><ul>
<li><p><code>HTTPS</code> 为了兼顾 <code>安全与效率</code>，同时使用了 <code>对称加密 + 非对称加密 + 消息摘要算法</code>。</p>
</li>
<li><p>SSL&#x2F;TLS &#x3D; 对称加密(DES AES) + 非对称加密(RSA) + 消息摘要算法(MD5 SHA)</p>
</li>
</ul>
<ol>
<li>引入对称加密</li>
</ol>
<p><code>对称加密</code> 只通过一个 <code>秘钥</code>，把明文加密成密文，并且也能把密文解密成明文。</p>
<p><strong>只引入对称秘钥存在的问题：</strong></p>
<p>通过对称秘钥加密，貌似就可以进行数据的保护了。黑客就算入侵了路由器，也只能得到请求的密文内容</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304201827873.png"
                     
                ></p>
<p>但是上述方案有一个问题，就是密钥如何进行约定？毕竟一个服务器对应着很多的客户端，每个客户端和服务器之间都需要约定一个独自的密钥。</p>
<p>可如果让服务器管理所有的密钥，其实并不简单，因此更好的做法就是客户端连接过来时，就自带一个客户端生成好的密钥。当每个客户端在连接之前，自己先生成一个密钥，通过网络将该信息告诉服务器，服务器将这个密钥保存即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304201915381.png"
                     
                ></p>
<p>也正是因为如此，黑客在获取密文请求的同时，也获取到了密钥，因此只使用对称加密并不能起到数据保护的作用。所以还需要让密钥进行加密，但是使用对称加密的话，是行不通的，故引入了 <code>非对称加密</code></p>
<ol start="2">
<li>非对称加密</li>
</ol>
<p><code>非对称加密</code> 要 <code>额外</code> 再用到两个密钥，一个叫做 <code>公钥</code>，一个叫做 <code>私钥</code>。公钥和私钥是成对的，这对密钥由服务器产生。</p>
<p><strong>缺点：</strong></p>
<p>运算速度非常慢，比对称加密慢很多</p>
<p><strong>引入流程：</strong></p>
<p>服务器将公钥直接发送给客户端，将私钥保留。客户端得到公钥后，通过公钥将密钥进行加密，再发送给服务器，服务器通过私钥解密获取到密钥。之后再将收到密钥的消息通过密钥加密后发送给客户端，客户端收到后，就使用该密钥通过对称加密的方式与客户端进行数据传输</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304201918655.png"
                     
                ></p>
<p><strong>引入非对称加密后，为什么还要使用对称加密？</strong></p>
<p>由于对称加密的成本（对机器资源的消耗）远远低于非对称加密，而实际上客户端和服务器之间传输的数据量会很大，如果都使用非对称加密，整体的传输速度就会很慢，因此通过非对称加密，让服务器得到密钥后，再使用对称加密进行传输，能够提高传输的效率</p>
<p><strong>引入非对称加密后还存在的问题？</strong></p>
<p>服务器首先生成一对公钥A和私钥A。首先服务器要把公钥A发送给客户端，此时黑客可以当作一个中间人，自己生成一对公钥B和私钥B。他会将服务器的信息阶段，并将自己生成的公钥B发送给客户端。当客户端得到公钥B后，就使用公钥B加密自己生成的密钥A并发送给服务器。此时黑客再次截取，通过私钥B解密公钥B，得到密钥A，并使用公钥A将密钥进行加密返回给服务器。至此服务器和客户端都确定了密钥A，但黑客也神不知鬼不觉的知道了密钥A。故在之后的数据传输中，黑客就可以直接完全的获取客户端和服务器的明文数据。因此即使引入了非对称机密还是存在两个问题：</p>
<p>1）客户端如何获取到公钥？<br>2）客户端如何确定这个公钥不是黑客伪造的？</p>
<p>为了解决这两个问题，就引入了 <code>证书</code></p>
<ol start="3">
<li>引入证书机制</li>
</ol>
<ul>
<li>基本介绍</li>
</ul>
<p>在客户端和服务器刚建立连接时，服务器就给客户端返回一个 <code>证书</code>。这个证书就好比人的身份证，用来作为网站的身份标识。而每搭建一个 <code>HTTPS</code> 网址时都需要在 <code>CA</code> 机构申请一个证书。</p>
<ul>
<li><p>证书含有的重要信息：</p>
<ul>
<li>证书发布机构</li>
<li>证书有效期</li>
<li>公钥</li>
<li>证书所有者</li>
<li>签名</li>
</ul>
</li>
<li><p>引入证书流程：</p>
</li>
</ul>
<p>服务器首先产生一对 <code>公钥和私钥</code>，在第三方公证机构申请一个证书时，该证书内就包含了公钥的信息，然后服务器就会将 <code>证书</code> 发送给客户端，由于证书的校验很严格，因此黑客就算获取了，也很难伪造一个假的证书。即使伪造了，客户端也可以拿到第三方公证机构去校验，因此客户端就能够拿到服务器发送的公钥，之后再通过公钥加密自己产生的密钥，发送给服务器。由于黑客没有私钥，就算截获了该请求，也不能拿到密钥，因此服务器就能顺利的得到加密的密钥，并使用私钥来解密。最终就能够很好的防止黑客获取或篡改数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202304201927830.png"
                     
                ></p>
<ul>
<li><p>校验证书方式：</p>
<ul>
<li>判定证书的有效期是否过期</li>
<li>判定证书的发布机构是否受信任</li>
<li>判定证书是否被篡改（从系统中拿到该证书发布机构的公钥，对签名解密，得到一个 <code>hash</code> 值（称为数据摘要），设为 <code>hash1</code>。然后计算整个证书的 <code>hash</code> 值，设为 <code>hash2</code>。对比 <code>hash1</code> 和 <code>hash2</code> 是否相等，如果相等，则说明证书是没有被篡改过的）</li>
</ul>
</li>
<li><p>证书机制</p>
<ul>
<li>服务器首先把自己的 <code>公钥、网址等信息</code> 发给证书颁发机构，向证书颁发机构申请证书。</li>
<li>证书颁发机构自己也有一对公钥私钥，<code>机构</code> 利用自己的 <code>私钥</code> 对服务器的 <code>公钥、网址等信息</code> 进行 <code>签名加密</code>，生成一个 <code>证书</code>。</li>
<li>机构把证书发送给服务端，服务端把证书发送给客户端</li>
<li>客户端到指定的机构验证证书，根据 <code>机构公钥去解密</code>，得到服务器的 <code>公钥</code>。</li>
</ul>
</li>
</ul>
<p><strong>理解数据值摘要和签名：</strong></p>
<p>针对一段数据，可以通过一些特定的算法对这个数据生成一个签名。由于不同的数据生成的签名差别很大，因此就可以使用签名在一定程度上区分不同的数据。常见的生成签名的算法有：<code>MD5</code> 和 <code>SHA</code>，以下以 <code>MD5</code> 为例，介绍其特点</p>
<ul>
<li>定长：无论多长的字符串，计算出来的 MD5 值都是固定长度（16字节版本或者32字节版本）</li>
<li>分散：源字符串只要改变一点点，最终得到的 MD5 值都会差别很大</li>
<li>不可逆：通过源字符串生成 MD5 很容易，但是通过 MD5 还原成原串理论上是不可能的</li>
<li>由于 MD5 这样的特性，因此可以认为如果两段数据的 MD5 值相同，则这两段数据相同</li>
</ul>
<ol start="4">
<li>完整流程</li>
</ol>
<ul>
<li><p><code>对称加密</code>：需要有一个客户端生成的对称密钥，用于对传输的数据进行加密，但需要将该对称密钥告知给服务器</p>
</li>
<li><p><code>非对称加密</code>： 服务器提供一个公钥（自己持有私钥），将公钥传发送给客户端，客户端使用公钥对对称密钥进行加密，将密文传送给服务器</p>
</li>
<li><p><code>引入证书机制</code>： 通过第三方公证机构，向网站颁发证书，该证书里面就含有公钥。客户端向服务器请求的也就是证书，客户端拿到证书后去公证机构校验，如果证书合法，就使用里面的公钥对对称密钥进行加密</p>
</li>
</ul>
<h2 id="HTTPS连接过程"><a href="#HTTPS连接过程" class="headerlink" title="HTTPS连接过程"></a>HTTPS连接过程</h2><ul>
<li><p>【第一步】<code>客户端访问HTTPS连接</code></p>
</li>
<li><p>【第二步】<code>服务端发送证书给客户端</code>，证书是从第三方机构获取</p>
</li>
<li><p>【第三步】<code>客户端验证服务端证书</code>，从里面将 <code>公钥</code> 拿出来</p>
</li>
<li><p>【第四步】<code>客户端用公钥加密对称秘钥</code>，将密文发送给服务端</p>
</li>
<li><p>【第五步】<code>服务端通过私钥解密得到对称秘钥</code></p>
</li>
<li><p>【第六步】这个时候就可以通过 对称秘钥加密数据进行传输数据了</p>
</li>
</ul>
<h2 id="HTTPS和HTTP的区别？-重点"><a href="#HTTPS和HTTP的区别？-重点" class="headerlink" title="HTTPS和HTTP的区别？ 重点"></a>HTTPS和HTTP的区别？ <strong>重点</strong></h2><ul>
<li><p>HTTP：超文本传输协议，信息明文传输；端口号80；响应速度快；</p>
</li>
<li><p>HTTPS：超文本传输安全协议，等价于HTTP协议 + SSL&#x2F;TLS协议；端口号443；响应速度慢；</p>
</li>
</ul>
<h2 id="为什么客户端在四次挥手后还等待2MSL-重点"><a href="#为什么客户端在四次挥手后还等待2MSL-重点" class="headerlink" title="为什么客户端在四次挥手后还等待2MSL? 重点"></a>为什么客户端在四次挥手后还等待2MSL? <strong>重点</strong></h2><p>MSL：一段TCP报文在传输过程中最大生命周期</p>
<p>因为客户端发出最后的ACK确认报文时，并不能确定服务器能接收到该报文，所以客户端发送完ACK报文后，需要设置一个时长为2MSL计时器，<code>2MSL是服务端发出FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长</code>。</p>
<h1 id="Socket-重要"><a href="#Socket-重要" class="headerlink" title="Socket 重要"></a>Socket <strong>重要</strong></h1><ol>
<li>什么是socket？</li>
</ol>
<ul>
<li><p><code>Socket</code> 俗称 <code>套接字</code>，是 <code>网络通信的基本操作单元</code>。它可以通过 <code>IP地址、端口号、TCP/UDP协议</code> 实现客户端和服务端的双向通信。</p>
</li>
<li><p>不属于协议范畴，而是一个接口（API），是对 <code>TCP/IP协议</code> 的封装</p>
</li>
<li><p>可以基于TCP连接，也可以基于UDP连接</p>
<ul>
<li><p>基于TCP连接，需要三次握手，是可靠的</p>
</li>
<li><p>基于UDP连接，不需要握手，是不可靠的，大多数IM都是不可靠的</p>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>长链接 和 短链接</li>
</ol>
<ul>
<li><p>长链接：连上就一直聊，通常用于 <code>及时通讯</code>，效率高。（一对一）</p>
</li>
<li><p>短链接：通讯一次，马上断开，下次再建立连接，效率低。（一对多）</p>
</li>
</ul>
<p>及时通讯：客户端和服务端是 <code>短链接</code>，客户端与客户端是 <code>长链接</code></p>
<ol start="3">
<li>iOS端实现 Socket</li>
</ol>
<p>用 <code>GCDAsyncSocket</code> 框架</p>
<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><ol>
<li>什么是WebSocket？</li>
</ol>
<p><code>WebSocket</code> 是 <code>HTML5</code> 中新协议、新API，同HTTP一样是 <code>应用层的协议</code>。</p>
<ol start="2">
<li>特点</li>
</ol>
<ul>
<li><code>WebSocket</code> 是建立在 <code>TCP</code> 之上</li>
<li><code>WebSocket</code> 是一种 <code>双向通信协议</code></li>
<li><code>WebSocket</code> 是 <code>全双工通信</code>，服务器和客户端能主动向对方发送或接收数据。</li>
</ul>
<blockquote>
<p>注：什么是单工、半双工、全工通信？<br>数据只能单向传送为 <code>单工</code><br>数据能双向传送但不能同时双向传送称为 <code>半双工</code><br>数据能够同时双向传送则称为 <code>全双工</code></p>
</blockquote>
<h1 id="WebService"><a href="#WebService" class="headerlink" title="WebService"></a>WebService</h1><ol>
<li>什么是WebService？</li>
</ol>
<ul>
<li>基于web的服务：服务器端整出一些资源让客户端应用访问（获取数据）</li>
<li>一个夸语言、跨平台的规范（抽象）</li>
<li>多个跨平台、跨语言的应用间通信整合的方案（实际）</li>
</ul>
<ol start="2">
<li>为什么要用WebService？</li>
</ol>
<p><code>WebService</code> 能解决 <code>跨平台、跨语言、远程调用</code></p>
<ol start="3">
<li>什么时候使用WebService</li>
</ol>
<ul>
<li>同一家公司的新旧应用之间</li>
<li>不同公司应用之间</li>
<li>一些提供数据的内容聚合应用：天气预报、股票行情</li>
</ul>
<h1 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260913649.png"
                     
                ></p>
<p>一、计算机网络体系结构分层:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260917477.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260918484.png"
                     
                ></p>
<p>不难看出，<code>TCP/IP</code> 与 <code>OSI</code> 在分层模块上稍有区别。<code>OSI</code> 参考模型注重 通信协议必要的功能是什么 ，而 <code>TCP/IP</code> 则更强调 <code>在计算机上实现协议应该开发哪种程序</code> 。</p>
<p>二、 TCP&#x2F;IP 基础</p>
<ol>
<li>TCP&#x2F;IP 的具体含义</li>
</ol>
<p>从字面意义上讲，有人可能会认为 TCP&#x2F;IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP&#x2F;IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP&#x2F;IP 一词泛指这些协议，因此，有时也称 TCP&#x2F;IP 为网际协议群。<br>互联网进行通信时，需要相应的网络协议，TCP&#x2F;IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP&#x2F;IP，TCP&#x2F;IP 就是互联网的协议。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260919577.png"
                     
                ></p>
<ol start="2">
<li>数据包</li>
</ol>
<p><code>包、帧、数据包、段、消息</code><br>以<br>上五个术语都用来表述数据的单位，大致区分如下：</p>
<ul>
<li><code>包</code> 可以说是全能性术语；</li>
<li><code>帧</code> 用于表示数据链路层中包的单位；</li>
<li><code>数据包</code> 是 <code>IP</code> 和 <code>UDP</code> 等网络层以上的分层中包的单位；</li>
<li><code>段</code> 则表示 <code>TCP</code> 数据流中的信息；</li>
<li><code>消息</code> 是指应用协议中数据的单位。</li>
</ul>
<p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260921168.png"
                     
                ></p>
<p>网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。包首部就像协议的脸。</p>
<ol start="3">
<li>数据处理流程</li>
</ol>
<p>下图以用户 a 向用户 b 发送邮件为例子：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260922493.png"
                     
                ></p>
<p>① 应用程序处理<br>首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；<br>编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。<br>② TCP 模块的处理<br>TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。<br>③ IP 模块的处理<br>IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。<br>④ 网络接口（以太网驱动）的处理<br>从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。<br>⑤ 网络接口（以太网驱动）的处理<br>主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。<br>如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。<br>⑥ IP 模块的处理<br>IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。<br>另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。<br>⑦ TCP 模块的处理<br>在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。<br>⑧ 应用程序的处理<br>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</p>
<p>三、传输层中的 TCP 和 UDP</p>
<p><code>TCP/IP</code> 中有两个具有代表性的传输层协议，分别是 <code>TCP</code> 和 <code>UDP</code>。</p>
<ul>
<li><p><code>TCP</code> 是面向连接的、可靠的 <code>流协议</code>。流就是指不间断的数据结构，当应用程序采用 <code>TCP</code> 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。<code>TCP</code> 为提供可靠性传输，实行 <code>顺序控制</code> 或 <code>重发控制</code> 机制。此外还具备 <code>流控制（流量控制） 、 拥塞控制 、提高网络利用率等</code> 众多功能。</p>
</li>
<li><p><code>UDP</code> 是不具有可靠性的 <code>数据报协议</code>。细微的处理它会交给上层的应用去完成。在 <code>UDP</code> 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p>
</li>
<li><p><code>TCP</code> 和 <code>UDP</code> 的优缺点无法简单地、绝对地去做比较：<code>TCP</code> 用于在传输层有必要实现可靠传输的情况；而在一方面，<code>UDP</code> 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。<code>TCP</code> 和 <code>UDP</code> 应该根据应用的目的按需使用。</p>
</li>
</ul>
<ol>
<li>端口号</li>
</ol>
<p><code>数据链路</code> 和 <code>IP</code> 中的地址，分别指的是 <code>MAC地址</code> 和 <code>IP地址</code>。前者用来识别同一链路中不同的计算机，后者用来识别 <code>TCP/IP</code> 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是 <code>端口号</code>。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为 <code>程序地址</code>。</p>
<p>1.1 根据端口号识别应用</p>
<p>一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260927383.png"
                     
                ></p>
<p>1.2 通过 IP 地址、端口号、协议号进行通信识别</p>
<p>仅凭目标端口号识别某一个通信是远远不够的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260928520.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260929554.png"
                     
                ></p>
<p>① 和 ② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。<br>③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。<br>此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。</p>
<p>1.3 端口号的确定</p>
<ul>
<li><p>标准既定的端口号：这种方法也叫 <code>静态方法</code>。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 <code>HTTP、FTP、TELNET</code> 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 <code>0~1023</code> 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 <code>1024~49151</code> 之间，不过这些端口号可用于任何通信用途。</p>
</li>
<li><p>时序分配法：服务器有必要确定 <code>监听端口号</code>，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 <code>49152~65535</code> 之间。</p>
</li>
</ul>
<p>1.4 端口号与协议</p>
<ul>
<li><p><code>端口号</code> 由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。</p>
</li>
<li><p>此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。</p>
</li>
</ul>
<ol start="2">
<li>UDP</li>
</ol>
<ul>
<li><p>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。</p>
</li>
<li><p>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</p>
</li>
<li><p>此外，传输途中出现丢包，UDP 也不负责重发。</p>
</li>
<li><p>甚至当包的到达顺序出现乱序时也没有纠正的功能。</p>
</li>
<li><p>如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。</p>
</li>
<li><p>UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）。</p>
</li>
</ul>
<ol start="3">
<li>TCP</li>
</ol>
<ul>
<li><p>TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</p>
</li>
<li><p>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</p>
</li>
<li><p>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。</p>
</li>
</ul>
<p>3.1 三次握手（重点）</p>
<ul>
<li><p>TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。</p>
</li>
<li><p>所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。</p>
</li>
</ul>
<p>下面来看看三次握手的流程图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260936136.png"
                     
                ></p>
<ul>
<li><p>第一次握手：客户端将标志位SYN置为1，随机产生一个值seq&#x3D;J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。</p>
</li>
<li><p>第二次握手：服务器端收到数据包后由标志位SYN&#x3D;1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack&#x3D;J+1，随机产生一个值seq&#x3D;K，并将该数据包发送给客户端以确认连接请求，服务器端进入 <code>SYN_RCVD</code> 状态。</p>
</li>
<li><p>第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack&#x3D;K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p>
</li>
</ul>
<p>3.2 四次挥手（重点）</p>
<ul>
<li><p>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</p>
</li>
<li><p>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
</li>
</ul>
<p>下面来看看四次挥手的流程图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260936136.png"
                     
                ></p>
<ul>
<li><p>中断连接端可以是客户端，也可以是服务器端。</p>
</li>
<li><p>第一次挥手：客户端发送一个FIN&#x3D;M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</p>
</li>
<li><p>第二次挥手：服务器端收到FIN后，先发送ack&#x3D;M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。</p>
</li>
<li><p>第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN&#x3D;N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。</p>
</li>
<li><p>第四次挥手：客户端收到FIN&#x3D;N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack&#x3D;N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</p>
</li>
</ul>
<p>上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，<br>具体流程如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260939969.png"
                     
                ></p>
<p>3.3 通过序列号与确认应答提高可靠性</p>
<ul>
<li><p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。</p>
</li>
<li><p>在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。</p>
</li>
<li><p>未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。</p>
</li>
<li><p>此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。</p>
</li>
<li><p>对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。</p>
</li>
<li><p>序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260940897.png"
                     
                ></p>
<p>3.4 重发超时的确定</p>
<ul>
<li><p>重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。</p>
</li>
<li><p>TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。</p>
</li>
<li><p>在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。</p>
</li>
<li><p>数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</p>
</li>
<li><p>此外，数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</p>
</li>
</ul>
<p>3.5 以段为单位发送数据</p>
<ul>
<li><p>在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS）。最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度。</p>
</li>
<li><p>TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。</p>
</li>
<li><p>MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。</p>
</li>
</ul>
<p>3.6 利用窗口控制提高速度</p>
<ul>
<li><p>TCP 以1个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。</p>
</li>
<li><p>为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260941847.png"
                     
                ></p>
<ul>
<li>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。</li>
</ul>
<p>3.7 滑动窗口控制</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260942517.png"
                     
                ></p>
<ul>
<li><p>上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。</p>
</li>
<li><p>在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</p>
</li>
<li><p>收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。</p>
</li>
</ul>
<p>3.8 窗口控制中的重发控制</p>
<p>在使用窗口控制中， 出现丢包一般分为两种情况：</p>
<p>① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260942690.png"
                     
                ></p>
<p>② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260942387.png"
                     
                ></p>
<p>四、网络层中的 IP 协议</p>
<ul>
<li><p><code>IP（IPv4、IPv6）</code> 相当于 <code>OSI</code> 参考模型中的第3层——网络层。网络层的主要作用是 <code>实现终端节点之间的通信</code> 。这种终端节点之间的通信也叫 <code>点对点通信</code> 。</p>
</li>
<li><p>网络的下一层 —— <code>数据链路层</code> 的主要作用是 <code>在互连同一种数据链路的节点之间进行包传递</code>。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p>
</li>
<li><p>IP 大致分为三大作用模块，它们是 <code>IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包</code>。</p>
</li>
</ul>
<ol>
<li>IP 地址</li>
</ol>
<p>1.1 IP 地址概述</p>
<ul>
<li><p>在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。</p>
</li>
<li><p>作为网络层的 <code>IP</code> ,也有这种地址信息，一般叫做 <code>IP</code> 地址。<code>IP 地址</code> 用于在 <code>连接到网络中的所有主机中识别出进行通信的目标地址</code>。因此，在 <code>TCP/IP</code> 通信中所有主机或路由器必须设定自己的 <code>IP 地址</code>。</p>
</li>
<li><p>不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。</p>
</li>
<li><p>IP 地址（IPv4 地址）由32位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：</p>
</li>
</ul>
<p>2828282810101100000101000000000100000001（2进制）10101100.00010100.00000001.00000001（2进制）172.20.1.1（10进制）</p>
<p>1.2 IP 地址由网络和主机两部分标识组成</p>
<ul>
<li>如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 IP 地址具有了唯一性。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260946179.png"
                     
                ></p>
<ul>
<li>如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260947168.png"
                     
                ></p>
<p>1.3 IP 地址的分类</p>
<ul>
<li><p>IP 地址分为四个级别，分别为 <code>A类、B类、C类、D类</code>。它根据 <code>IP</code> 地址中从第 <code>1</code> 位到第 <code>4</code> 位的比特列对其网络标识和主机标识进行区分。</p>
</li>
<li><p><code>A 类 IP</code> 地址是首位以 <code>0</code> 开头的地址。从第 1 位到第 8 位是它的网络标识。用十进制表示的话，<code>0.0.0.0~127.0.0.0</code> 是 <code>A 类的网络地址</code>。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为16,777,214个。</p>
</li>
<li><p><code>B 类 IP</code> 地址是前两位 <code>10</code> 的地址。从第 1 位到第 16 位是它的网络标识。用十进制表示的话，<code>128.0.0.0~191.255.0.0</code> 是 B 类的网络地址。B 类地址的后 <code>16</code> 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为65,534个。</p>
</li>
<li><p><code>C 类 IP</code> 地址是前三位为 <code>110</code> 的地址。从第 1 位到第 24 位是它的网络标识。用十进制表示的话，<code>192.0.0.0~223.255.255.0</code> 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为254个。</p>
</li>
<li><p><code>D 类 IP</code> 地址是前四位为 <code>1110</code> 的地址。从第 1 位到第 32 位是它的网络标识。用十进制表示的话，<code>224.0.0.0~239.255.255.255</code> 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。</p>
</li>
<li><p>在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 &#x3D; 254）个主机地址的原因。</p>
</li>
</ul>
<p>1.4 广播地址</p>
<ul>
<li><p>广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。</p>
</li>
<li><p>广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。</p>
</li>
</ul>
<p>1.5 IP 多播</p>
<ul>
<li><p>多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。</p>
</li>
<li><p>相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307260955123.png"
                     
                ></p>
<ul>
<li><p>多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。</p>
</li>
<li><p>此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。</p>
</li>
</ul>
<p>1.6 子网掩码</p>
<ul>
<li><p>现在一个 <code>IP 地址</code> 的 <code>网络标识</code> 和 <code>主机标识</code> 已不再受限于该地址的类别，而是由一个叫做 <code>子网掩码</code> 的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络。这种方式实际上就是 <code>将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址</code>，可以将原网络分为多个物理网络的一种机制。</p>
</li>
<li><p><code>子网掩码</code> 用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。</p>
</li>
<li><p>对于子网掩码，目前有两种表示方式。第一种是，将 <code>IP 地址</code> 与 <code>子网掩码</code> 的地址分别用两行来表示。以 <code>172.20.100.52</code> 的 <code>前 26 位</code> 是 <code>网络地址</code> 的情况为例，如下：</p>
</li>
</ul>
<p>IP 地址 172.20.100.52 子网掩码 255.255.255.192<br>网络地址 172.20.100.0 子网掩码 255.255.255.192<br>广播地址 172.20.100.63 子网掩码 255.255.255.192</p>
<ul>
<li>第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “&#x2F; ” 隔开，如下：</li>
</ul>
<p>IP 地址 172.20.100.52&#x2F;26<br>网络地址 172.20.100.0&#x2F;26<br>广播地址 172.20.100.63&#x2F;26</p>
<p>另外，在第二种方式下记述网络地址时可以省略后面的 “0” 。例如：172.20.0.0&#x2F;26 跟 172.20&#x2F;26 其实是一个意思。</p>
<ol start="2">
<li>路由</li>
</ol>
<ul>
<li><p>发送数据包时所使用的地址是网络层的地址，即 <code>IP 地址</code>。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于 <code>指明路由器或主机</code> 的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。</p>
</li>
<li><p>该路由控制表的形成方式有两种：<code>一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新</code>。前者也叫做 <code>静态路由控制</code>，而后者叫做 <code>动态路由控制</code>。</p>
</li>
<li><p>IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。</p>
</li>
</ul>
<p>2.1 IP 地址与路由控制</p>
<ul>
<li><p>IP 地址的网络地址部分用于进行路由控制。</p>
</li>
<li><p>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。</p>
</li>
<li><p>在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307261001362.png"
                     
                ></p>
<ol start="3">
<li>IP 分包与组包</li>
</ol>
<ul>
<li><p>每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。</p>
</li>
<li><p>任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。</p>
</li>
<li><p>经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</p>
</li>
</ul>
<p>3.1 路径 MTU 发现</p>
<ul>
<li><p>分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。</p>
</li>
<li><p>为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。</p>
</li>
<li><p>进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。</p>
</li>
</ul>
<ol start="4">
<li>IPv6</li>
</ol>
<ul>
<li>IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。</li>
</ul>
<p>4.1 IPv6 的特点</p>
<ul>
<li><p>IP 得知的扩大与路由控制表的聚合。</p>
</li>
<li><p>性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。</p>
</li>
<li><p>支持即插即用功能。即使没有DHCP服务器也可以实现自动分配 IP 地址。</p>
</li>
<li><p>采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。</p>
</li>
<li><p>多播、Mobile IP 成为扩展功能。</p>
</li>
</ul>
<p>4.2 IPv6 中 IP 地址的标记方法</p>
<ul>
<li><p>一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（“：”）隔开进行标记。</p>
</li>
<li><p>而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（“：：”）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</p>
</li>
</ul>
<p>4.3 IPv6 地址的结构</p>
<ul>
<li><p>IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。</p>
</li>
<li><p>在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。</p>
</li>
<li><p>未定义0000 … 0000（128比特）：：&#x2F; 128环回地址0000 … 0001（128比特）：：1 &#x2F; 128唯一本地地址1111 110FC00：&#x2F; 7链路本地单播地址1111 1110 10FE80：：&#x2F; 10多播地址1111 1111FF00：：&#x2F; 8全局单播地址（其他）</p>
</li>
</ul>
<p>4.4 全局单播地址</p>
<ul>
<li><p>全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。</p>
</li>
<li><p>格式如下图所示，现在 IPv6 的网络中所使用的格式为，n &#x3D; 48，m &#x3D; 16 以及 128 - n - m &#x3D; 64。即前 64 比特为网络标识，后 64 比特为主机标识。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307261003692.png"
                     
                ></p>
<p>4.5 链路本地单播地址</p>
<p>链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口 ID 保存 64 比特版的 MAC 地址。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307261003788.png"
                     
                ></p>
<p>4.6 唯一本地地址</p>
<ul>
<li><p>唯一本地地址是不进行互联网通信时所用的地址。</p>
</li>
<li><p>唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。</p>
</li>
<li><p>L 通常被置为 1</p>
</li>
<li><p>全局 ID 的值随机决定</p>
</li>
<li><p>子网 ID 是指该域子网地址</p>
</li>
<li><p>接口 ID 即为接口的 ID</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307261019002.png"
                     
                ></p>
<p>4.7 IPv6 分段处理</p>
<p>IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。<br>IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径 MTU 发现”，而是在发送 IP 包时直接以 1280 字节为单位分片送出。<br>4.8 IP 首部（暂略）</p>
<ol start="5">
<li>IP 协议相关技术</li>
</ol>
<ul>
<li>IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。</li>
</ul>
<p>5.1 DNS</p>
<ul>
<li><p>我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 <code>TCP/IP</code> 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。</p>
</li>
<li><p>这种 DNS 不仅适用于 IPv4，还适用于 IPv6。</p>
</li>
</ul>
<p>5.2 ARP</p>
<ul>
<li><p>只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。</p>
</li>
<li><p>ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。</p>
</li>
<li><p>RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。</p>
</li>
</ul>
<p>5.3 ICMP</p>
<ul>
<li><p>ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。</p>
</li>
<li><p>IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。</p>
</li>
</ul>
<p>5.4 DHCP</p>
<ul>
<li><p>如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。</p>
</li>
<li><p>于是，为了实现 <code>自动设置 IP 地址、统一管理 IP 地址分配</code>，就产生了 <code>DHCP（Dynamic Host Configuration Protocol）协议</code>。有了 DHCP，计算机只要连接到网络，就可以进行 TCP&#x2F;IP 通信。也就是说，DHCP 让即插即用变得可能。</p>
</li>
<li><p>DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。</p>
</li>
</ul>
<p>5.5 NAT</p>
<ul>
<li><p>NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。</p>
</li>
<li><p>除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。</p>
</li>
<li><p>NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT。</p>
</li>
</ul>
<p>5.6 IP 隧道</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bboy-blog.oss-cn-beijing.aliyuncs.com/img/202307261022330.png"
                     
                ></p>
<ul>
<li><p>如上图的网络环境中，<code>网络 A</code> 与 <code>网络 B</code> 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 <code>IP 隧道</code> 的功能。</p>
</li>
<li><p><code>IP 隧道</code> 可以将那些从 <code>网络 A</code> 发过来的 <code>IPv6</code> 的包统合为一个数据，再为之追加一个 <code>IPv4</code> 的首部以后转发给 <code>网络 C</code>。</p>
</li>
<li><p>一般情况下，紧接着 IP 首部的是 <code>TCP</code> 或 <code>UDP</code> 的首部。然而，现在的应用当中 <code>IP 首部的后面还是 IP 首部</code> 或者 <code>IP 首部的后面是 IPv6 的首部</code> 等情况与日俱增。这种在 <code>网络层的首部后面追加网络层首部</code> 的通信方法就叫做 <code>IP 隧道</code> 。</p>
</li>
</ul>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：OC网络学习01：TCP/UDP/HTTP/HTTPS/Socket/WebSocket/WebService探索</li>
        <li>Post author：张建</li>
        <li>Create time：2020-07-09 13:07:02</li>
        <li>
            Post link：https://redefine.ohevan.com/2020/07/09/OC网络/OC网络学习01：HTTP&amp;HTTPS&amp;Socket&amp;WebSocket&amp;WebService探索/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/BboyZJ.github.io/tags/OC-%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/">#OC-网络学习</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/BboyZJ.github.io/2020/07/11/OC/OC%E5%AD%A6%E4%B9%A031%EF%BC%9A%E7%BC%96%E8%AF%91%E5%99%A8Clang%E5%92%8CLLVM%E6%8E%A2%E7%B4%A2/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">OC学习31：编译器Clang和LLVM探索</span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">OC网络学习01：TCP/UDP/HTTP/HTTPS/Socket/WebSocket/WebService探索</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#OSI%E6%A8%A1%E5%9E%8B"><span class="nav-text">OSI模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#URL"><span class="nav-text">URL</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="nav-text">物理层</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%88MAC%EF%BC%89"><span class="nav-text">数据链路层（MAC）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IP%EF%BC%88%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="nav-text">IP（网络层协议）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP-amp-UDP%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="nav-text">TCP &amp; UDP（传输层协议）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%EF%BC%88%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%EF%BC%8CTransmission-Control-Protocol%EF%BC%89"><span class="nav-text">TCP（传输控制协议，Transmission Control Protocol）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP-%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE%EF%BC%8CUser-Data-Protocol"><span class="nav-text">UDP(用户数据报协议，User Data Protocol)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E5%92%8C-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB-%E9%87%8D%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">TCP 和 UDP 的区别 重点面试题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="nav-text">HTTP（应用层协议）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTPS%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="nav-text">HTTPS（应用层协议）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS-%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-text">HTTPS 工作过程：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="nav-text">HTTPS连接过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="nav-text">HTTPS和HTTP的区别？ 重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%90%8E%E8%BF%98%E7%AD%89%E5%BE%852MSL-%E9%87%8D%E7%82%B9"><span class="nav-text">为什么客户端在四次挥手后还等待2MSL? 重点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Socket-%E9%87%8D%E8%A6%81"><span class="nav-text">Socket 重要</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WebSocket"><span class="nav-text">WebSocket</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WebService"><span class="nav-text">WebService</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP-x2F-IP"><span class="nav-text">TCP&#x2F;IP</span></a></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2019</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">张建</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        VISITOR COUNT&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        TOTAL PAGE VIEWS&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a></span>
                <br> 
            <span class="theme-version-container">THEME&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v1.1.5</a>
        </div>
        
        
        
            <div id="start_time_div" style="display:none">
                2019/8/17 11:45:14
            </div>
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="unfolded-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="fa-regular fa-arrow-up"></i>
            </li>
        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="folded-tools-list">
        <li class="right-bottom-tools tool-toggle-show flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>




<script src="/BboyZJ.github.io/js/utils.js"></script>

<script src="/BboyZJ.github.io/js/main.js"></script>

<script src="/BboyZJ.github.io/js/layouts/menu-shrink.js"></script>

<script src="/BboyZJ.github.io/js/tools/go-top-bottom.js"></script>

<script src="/BboyZJ.github.io/js/tools/dark-light-toggle.js"></script>



    
<script src="/BboyZJ.github.io/js/tools/local-search.js"></script>




    
<script src="/BboyZJ.github.io/js/tools/code-block.js"></script>




    
<script src="/BboyZJ.github.io/js/layouts/lazyload.js"></script>




    
<script src="/BboyZJ.github.io/js/tools/runtime.js"></script>

    
<script src="/BboyZJ.github.io/js/layouts/odometer.min.js"></script>

    
<link rel="stylesheet" href="/BboyZJ.github.io/assets/odometer-theme-minimal.css">





<div class="post-scripts pjax">
    
        
<script src="/BboyZJ.github.io/js/tools/toc-toggle.js"></script>

<script src="/BboyZJ.github.io/js/libs/anime.min.js"></script>

<script src="/BboyZJ.github.io/js/layouts/toc.js"></script>

<script src="/BboyZJ.github.io/js/plugins/tabs.js"></script>

    
    
</div>


    
<script src="/BboyZJ.github.io/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>




<script src="/BboyZJ.github.io/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
